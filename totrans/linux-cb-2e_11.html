<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Creating and Managing Filesystems"><div class="chapter" id="cha-create-filesystems">
<h1><span class="label">Chapter 11. </span>Creating and Managing Filesystems</h1>


<p>Linux supports a lot of filesystems, more than any other operating system. Filesystems
are essential to computing and do an astounding amount of work. A computer filesystem
stores, organizes, and protects our data, and is under continual stress from being
constantly in use. As Linux users we are fortunate to have many first-rate filesystems to
choose from.</p>

<p>In this chapter you will learn about the command-line tools for creating and managing
the <a data-type="indexterm" data-primary="filesystems" data-secondary="Linux support for" id="idm46466158286856"/><a data-type="indexterm" data-primary="Linux" data-secondary="supported filesystems" id="idm46466158286344"/>following general-purpose filesystems, which are fully supported on Linux and well maintained:</p>

<ul>
<li>
<p>Ext4, the Extended Filesystem</p>
</li>
<li>
<p>XFS, the X File System; the X stands only for X</p>
</li>
<li>
<p>Btrfs, the b-tree filesystem, pronounced Butter FS</p>
</li>
<li>
<p>FAT16/32, File Allocation Table 16- and 32-bit</p>
</li>
<li>
<p>exFAT, Extended FAT, Microsoft’s newest 64-bit filesytem</p>
</li>
</ul>

<p>Not included in this chapter are Microsoft’s NTFS or Apple’s HFS/HFS+/APFS. Linux
has good support for Microsoft’s NTFS, both read and write. To try it, look for
<em>ntfs-3g</em> (NTFS third generation) packages.</p>

<p>Support for Apple’s HFS/HFS+/APFS is unreliable. To give it a test drive, look
for packages with <em>hfs</em> or <em>apfs</em> in the names, and make sure the description
specifies they are for Apple filesystems.</p>

<p>There are many special-purpose filesystems, such as UBIFS and JFFS2 for CompactFlash devices; the compressed filesystem SquashFS, HDFS, CephFS, and GlusterFS
for distributed computing; NFS for network file sharing; and many more. These
could easily fill a large book by themselves and are not included here. They are
freely available to try out and learn.</p>






<section data-type="sect1" class="orm:non-recipe" data-pdf-bookmark="Filesystem Overview"><div class="sect1" id="idm46466158278888">
<h1>Filesystem Overview</h1>

<p>Before<a data-type="indexterm" data-primary="filesystems" data-secondary="operational overview" id="filesystem-operation-overview"/> you can use any storage device, such as a hard disk, USB flash drive, or SD card,
it must be partitioned <a data-type="indexterm" data-primary="partitions" data-secondary="filesystems and" id="idm46466158274856"/>and formatted with a filesystem. Every filesystem must have its own
disk partition. A partition can cover an entire disk, or a disk can be divided into multiple
partitions. Each partition is like an independent disk, and each partition can have a
different filesystem.</p>

<p>A filesystem must be mounted, or attached, to the running filesystem before it is
accessible.  A filesystem <a data-type="indexterm" data-primary="filesystems" data-secondary="mountpoints" id="idm46466158274248"/><a data-type="indexterm" data-primary="mountpoints" id="idm46466158273736"/>needs a <em>mountpoint</em>, which is a directory created for that
filesystem. This directory can be anywhere, though the traditional locations are
<em>/mnt</em> and <em>/media</em>.</p>

<p>You may mount only one filesystem per mountpoint. If you mount a second
filesystem, it overwrites the first filesystem.</p>

<p>A filesystem can be set up to mount automatically at system startup, dynamically when
you attach removable media, manually from the command line, or by clicking a button on
your desktop or in your file manager. Most Linux distributions take good care of handling
removable media. Plug in your USB device or optical disk, and Linux takes care of setting
up the mountpoint and automounting it, or setting it up for you to mount it with the click
of a button (<a data-type="xref" href="#fig-filesystem-icons-1">Figure 11-1</a>).</p>

<figure class="width-60"><div id="fig-filesystem-icons-1" class="figure">
<img src="Images/lcb2_1101.png" alt="Removable media buttons on XFCE desktop" width="451" height="306"/>
<h6><span class="label">Figure 11-1. </span>Removable media buttons on Xfce desktop</h6>
</div></figure>

<p>Ext4, XFS, Btrfs, and<a data-type="indexterm" data-primary="filesystems" data-secondary="64-bit" data-secondary-sortas="sixty-four bit" id="idm46466158264216"/><a data-type="indexterm" data-primary="64-bit filesystems" data-primary-sortas="sixty-four bit filesystems" id="idm46466158263128"/> exFAT are <em>64-bit</em> filesystems. This means they support a
64-bit block addressing space, which enables much larger file and filesystem
sizes than 32- and 16-bit filesystems. 64-bit computing has been around at least since the
1970s on supercomputers, then later on high-end business machines like IBM Power and
Sun Microsystems UltraSPARC.</p>

<p>My first Windows 3.1/DOS PC, back in the mid-1990s, was a 16-bit system. Windows 95
boasted of being the first 32-bit consumer operating system. The first 64-bit filesystems
for x86 PCs started appearing in Linux around 2001. See
<a href="https://oreil.ly/kufyJ">Ext4 High Level Design</a>
in the Linux kernel documentation to see nice tables that lay this all out for us, comparing
32- and 64-bit filesystems.</p>

<p>64-bit filesystems are backward compatible with 32-bit applications. After all
these years it is unlikely you will run into 32-bit apps, though if you do they
will run on your modern Linux, provided that it supplies the necessary packages
to set up a 32-bit environment.</p>

<p>Ext4 and XFS <a data-type="indexterm" data-primary="filesystems" data-secondary="journaling" id="idm46466158259160"/><a data-type="indexterm" data-primary="journaling filesystems" id="idm46466158254696"/>are <em>journaling</em> filesystems, and Btrfs is a <em>copy-on-write</em>
(CoW) filesystem. <a data-type="indexterm" data-primary="filesystems" data-secondary="CoW (copy-on-write)" id="idm46466158257928"/><a data-type="indexterm" data-primary="CoW (copy-on-write) filesystems" id="idm46466158257080"/>Journaling and CoW keep your filesystems in consistent states
even after a power failure or system crash. Filesystems are complex and busy,
and an interruption affects more than just the files you are working on.
Interruptions result in large numbers of files with incompleted tasks, and in
the olden days this meant possibly losing your whole filesystem.</p>

<p><em>Ext4</em> is<a data-type="indexterm" data-primary="Ext4 filesystems" id="idm46466158252744"/> the most widely used filesystem on Linux and is the
default on the majority of Linux distributions. It’s not exciting. It’s
well tested, well supported, and does its job without drama. The Ext4
journal records changes until they are written to disk, providing
protection from data loss in the event of an interruption.
Ext4 filesystems can be resized, both larger and smaller.</p>

<p><em>XFS</em> was <a data-type="indexterm" data-primary="XFS filesystems" id="idm46466158244520"/>originally a high-performance Unix 64-bit filesystem, ported to Linux
in 2001. XFS is a fast, efficient, reliable journaling filesystem suitable for
systems from small personal machines and to multidisk datacenter setups.
XFS can be resized larger, but not smaller.</p>

<p><em>Btrfs</em> is <a data-type="indexterm" data-primary="Btrfs filesystems" id="idm46466158248104"/>an advanced copy-on-write (CoW) filesystem that includes a batch of
features not present in the other filesystems in this chapter, including
snapshots; RAID 0, 1, and 10; and subvolumes. Subvolumes are wonderfully
flexible, as they enable creating multiple filesystem roots on a single
partition. CoW is a cool way of creating snapshots in a space-efficient way,
where each snapshot contains only the changes from the previous snapshot. When
you run into problems, you can roll back to an older known good snapshot. Btrfs
resizes smaller and larger.</p>

<p><em>FAT16/32</em> are<a data-type="indexterm" data-primary="FAT16 filesystems" id="idm46466158245576"/><a data-type="indexterm" data-primary="FAT32 filesystems" id="idm46466158252008"/> the elderly Microsoft 16- and 32-bit filesystems. FAT32 is the
most universal filesystem, supported by Microsoft Windows, Apple’s macOS, Linux,
Unix, and DOS operating systems. Use FAT32 for easiest file sharing on portable
media. It has one limitation that is a showstopper for some uses, and that is
a maximum file size of 4 GB (on media with 4K blocks).</p>

<p><em>exFAT</em> is <a data-type="indexterm" data-primary="exFAT filesystems" id="idm46466158250856"/>the newest Microsoft 64-bit filesystem, a nice upgrade from FAT32.
exFAT is a fast, lightweight filesystem for USB sticks and SD media, and
supports much larger file and volume sizes than FAT32. Wikipedia cites a 16 EiB
maximum file size and 128 PiB maximum volume size. It does not have a journal
or CoW.</p>

<p>exFAT is troublesome for Linux users because it is a patented proprietary filesystem, which was not available to Linux as a native filesystem until 2020. You need to worry about Linux compatibility only if you want to read and copy USB flash drives or SDXC cards formatted with exFAT to your Linux computer. For example, you want to use exFAT-formatted SDXC cards with your digital camera, or audio recording device.</p>

<p>To use exFAT with Linux you have two options. One is to use the <em>exfatprogs</em>, or <em>exfat-fuse</em> and <em>exfat-utils</em> packages, which are available on most distributions.
exFAT FUSE was<a data-type="indexterm" data-primary="exFAT FUSE utility" id="idm46466158243240"/><a data-type="indexterm" data-primary="FUSE (Filesystem in Userspace)" id="idm46466158242632"/> developed and is maintained outside of the US, making it
immune to US patent laws. exFAT FUSE takes advantage of Filesystem in Userspace
(FUSE), which enables unprivileged users to run filesystems in userspace. It is not as
efficient as a filesystem properly integrated into the kernel, but it works, and you can read
and write exFAT files. Some hardy souls try to use exFAT FUSE in shared partitions to
share files with Windows and macOS. In theory this should work, though there are
sometimes glitches related to how well a particular Windows or macOS release implements exFAT.</p>

<p>The other option is to wait a little while for native support. Microsoft released exFAT in
2006 and licensed it primarily to companies that make embedded systems and
embedded media. But times change. Microsoft has become an open source contributor,
and a member of the <a href="https://oreil.ly/AJepb">Open Invention Network (OIN)</a>.
Microsoft released the exFAT specification in 2019. Releasing the specification
sidestepped licensing hassles with the existing exFAT code, and Linux kernel
developers wasted no time writing new code. Native support for exFAT with this
shiny new code is in Linux kernel 5.7. This should find its way into your
favorite distro soon; run <em>uname -r</em> to see your kernel <a data-type="indexterm" data-primary="filesystems" data-secondary="operational overview" data-startref="filesystem-operation-overview" id="idm46466158234936"/>version.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="11.1 Listing Supported Filesystems"><div class="sect1" id="idm46466158276968">
<h1>11.1 Listing Supported Filesystems</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466158231208">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="listing" data-tertiary="supported" id="filesystem-list-support"/><a data-type="indexterm" data-primary="listing" data-secondary="filesystems" data-tertiary="supported" id="list-filesystem-support"/><a data-type="indexterm" data-primary="supported filesystems, listing" id="support-filesystem-list"/> need to know what filesystems are installed on your Linux system.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466158226808">
<h2>Solution</h2>

<p>Read <em>/proc/filesystems</em> to <a data-type="indexterm" data-primary="/proc/filesystems" id="idm46466158225512"/>see a list of installed filesystems:</p>
<pre>$ <strong>cat /proc/filesystems</strong>
nodev   sysfs
nodev   tmpfs
nodev   bdev
nodev   proc
nodev   cgroup
nodev   cgroup2
nodev   cpuset
nodev   devtmpfs
nodev   debugfs
nodev   tracefs
nodev   securityfs
nodev   sockfs
nodev   bpf
nodev   pipefs
nodev   ramfs
nodev   hugetlbfs
nodev   devpts
        ext3
        ext2
        ext4
nodev   autofs
nodev   mqueue
nodev   pstore
        btrfs
        vfat
        xfs
        fuseblk
nodev   fuse
nodev   fusectl
        jfs
        nilfs2</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466158223064">
<h2>Discussion</h2>

<p>See all those <em>nodev</em> entries? Those are all virtual filesystems that exist only
in memory and are not attached to a physical device like <em>/dev/sda1</em>.
Systemd manages all of these virtual filesystems.</p>

<p>The other filesystems, Ext4, XFS, and so on, are the filesystems we use on our
storage devices to store, organize, and protect our <a data-type="indexterm" data-primary="filesystems" data-secondary="listing" data-tertiary="supported" data-startref="filesystem-list-support" id="idm46466158219784"/><a data-type="indexterm" data-primary="listing" data-secondary="filesystems" data-tertiary="supported" data-startref="list-filesystem-support" id="idm46466158219032"/><a data-type="indexterm" data-primary="supported filesystems, listing" data-startref="support-filesystem-list" id="idm46466158217240"/>data.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466158215768">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://oreil.ly/QCMN7">“sysfs, the filesystem for exporting kernel objects”</a> is written for developers, but it has useful information for Linux users and admins.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.2 Identifying Your Existing Filesystems"><div class="sect1" id="rec-lsblk">
<h1>11.2 Identifying Your Existing Filesystems</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466158211208">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="listing" data-tertiary="existing" id="filesystem-list-existing"/><a data-type="indexterm" data-primary="listing" data-secondary="filesystems" data-tertiary="existing" id="list-filesystem-existing"/><a data-type="indexterm" data-primary="existing filesystems, listing" id="existing-filesystem-list"/> do not know what filesystems are already on your system, or on a removable storage
disk, and you need to know how to list them.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466158205608">
<h2>Solution</h2>

<p>Use <a data-type="indexterm" data-primary="lsblk command" data-secondary="listing existing filesystems" id="lsblk-list-filesystem"/>the <em>lsblk</em> command. You can list just the device names and filesystems with
the <em>NAME</em> and <em>FSTYPE</em> options:</p>
<pre>$ <strong>lsblk -o NAME,FSTYPE</strong>
NAME   FSTYPE
sda
├─sda1 vfat
├─sda2 btrfs
├─sda3 xfs
└─sda4 swap
sdb
├─sdb1 ext2
├─sdb2 ext4
├─sdb3 swap
└─sdb4 LVM2_member
sdc
└─sdc1 vfat
sr0</pre>

<p>Query a single disk:</p>
<pre>$ <strong>lsblk -o NAME,FSTYPE /dev/sdb</strong>
├─sdb1 ext2
├─sdb2 ext4
├─sdb3 swap
└─sdb4 LVM2_member
</pre>

<p>Or a single partition:</p>
<pre>$ <strong>lsblk -o NAME,FSTYPE /dev/sda1</strong>
NAME FSTYPE
sda1 vfat</pre>

<p>This is my favorite <em>lsblk</em> incantation. It shows all device names, filesystem types,
filesystem sizes, percentage used, labels, and mountpoints:</p>
<pre>$ <strong>lsblk -o NAME,FSTYPE,LABEL,FSSIZE,FSUSE%,MOUNTPOINT</strong>
NAME   FSTYPE   LABEL     FSSIZE FSUSE% MOUNTPOINT
loop0  squashfs           646.5M   100% /run/archiso/sfs/airootfs
sda
├─sda1
└─sda2 ntfs
sdb
├─sdb1 vfat     BOOT
├─sdb2 btrfs    root
├─sdb3 xfs      home
└─sdb4 swap
sdc    iso9660  RESCUE800
└─sdc1 iso9660  RESCUE800   708M   100% /run/archiso/bootmnt
sr0</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466158194872">
<h2>Discussion</h2>

<p>Run <em>lsblk --help</em> to see a list of columns. There is quite a bit of useful information,
such as PATH, LABEL, UUID, HOTPLUG, MODEL, SERIAL, and SIZE.</p>

<p>On some distros you may need root permissions to see the filesystem types, UUIDs, and
labels.</p>

<p><em>lsblk</em> always prints <em>vfat</em> for both FAT16 and FAT32 filesystems. Use GParted
or <em>parted</em> to see whether a filesystem is FAT16 or FAT32.</p>

<p><em>vfat</em> is <a data-type="indexterm" data-primary="Virtual FAT (vfat)" id="idm46466158191528"/><a data-type="indexterm" data-primary="FAT16 filesystems" data-secondary="Virtual FAT" id="idm46466158188808"/><a data-type="indexterm" data-primary="FAT32 filesystems" data-secondary="Virtual FAT" id="idm46466158187960"/>Virtual FAT, the kernel’s filesystem driver for FAT16 <a data-type="indexterm" data-primary="lsblk command" data-secondary="listing existing filesystems" data-startref="lsblk-list-filesystem" id="idm46466158185544"/><a data-type="indexterm" data-primary="filesystems" data-secondary="listing" data-tertiary="existing" data-startref="filesystem-list-existing" id="idm46466158184456"/><a data-type="indexterm" data-primary="listing" data-secondary="filesystems" data-tertiary="existing" data-startref="list-filesystem-existing" id="idm46466158183128"/><a data-type="indexterm" data-primary="existing filesystems, listing" data-startref="existing-filesystem-list" id="idm46466158181560"/>and FAT32.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466158186872">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://oreil.ly/beFOx">Linux Kernel SCSI Interfaces Guide</a></p>
</li>
<li>
<p><a href="https://oreil.ly/NW2S7">Major and minor numbers for block and character devices</a></p>
</li>
<li>
<p><em>man 8 lsblk</em></p>
</li>
<li>
<p><em>man 8 parted</em></p>
</li>
<li>
<p><a data-type="xref" href="ch08.xhtml#cha-partitioning-parted">Chapter 8</a></p>
</li>
<li>
<p><a data-type="xref" href="ch09.xhtml#cha-partitioning-gparted">Chapter 9</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.3 Resizing Filesystems"><div class="sect1" id="idm46466158172088">
<h1>11.3 Resizing Filesystems</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466158170984">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="filesystems" data-secondary="resizing" id="idm46466158169720"/><a data-type="indexterm" data-primary="resizing" data-secondary="filesystems" id="idm46466158168872"/><a data-type="indexterm" data-primary="partitions" data-secondary="resizing" id="idm46466158168024"/><a data-type="indexterm" data-primary="resizing" data-secondary="partitions" id="idm46466158167080"/>want to enlarge or reduce the size of your filesystem.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466158165320">
<h2>Solution</h2>

<p>Every filesystem has its own commands for resizing.
See Recipes <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch08.xhtml#rec-resize-partition-fs">8.8</a>, <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch08.xhtml#rec-shrink-partition">8.9</a>, and
<a data-xrefstyle="select:labelnumber" data-type="xref" href="ch09.xhtml#rec-resize-partitions-gparted">9.7</a> to learn about resizing filesystems.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466158159880">
<h2>Discussion</h2>

<p>The filesystem’s partition
must also be resized to match. GParted does this in a single operation
(see <a data-type="xref" href="ch09.xhtml#rec-resize-partitions-gparted">Recipe 9.7</a>).</p>

<p>Recipes <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch08.xhtml#rec-resize-partition-fs">8.8</a> and <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch08.xhtml#rec-shrink-partition">8.9</a> use <em>parted</em> and
filesystem utilities to resize a filesystem and its partition in two steps.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466158153896">
<h2>See Also</h2>

<ul>
<li>
<p><a data-type="xref" href="ch08.xhtml#rec-resize-partition-fs">Recipe 8.8</a></p>
</li>
<li>
<p><a data-type="xref" href="ch08.xhtml#rec-shrink-partition">Recipe 8.9</a></p>
</li>
<li>
<p><a data-type="xref" href="ch09.xhtml#rec-resize-partitions-gparted">Recipe 9.7</a></p>
</li>
<li>
<p><em>man 8 resize2fs</em></p>
</li>
<li>
<p><em>man 8 parted</em></p>
</li>
<li>
<p><em>man 8 xfs_growfs</em></p>
</li>
<li>
<p><em>man 8 btrfs</em></p>
</li>
<li>
<p><em>man 8 fsck.vfat</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.4 Deleting Filesystems"><div class="sect1" id="idm46466158142344">
<h1>11.4 Deleting Filesystems</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466158141352">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="filesystems" data-secondary="deleting" data-tertiary="with parted command" data-tertiary-sortas="parted command" id="filesystem-delete"/><a data-type="indexterm" data-primary="deleting" data-secondary="filesystems" data-tertiary="with parted command" data-tertiary-sortas="parted command" id="delete-filesystem"/><a data-type="indexterm" data-primary="partitions" data-secondary="deleting" data-tertiary="with parted command" data-tertiary-sortas="parted command" id="partition-delete"/><a data-type="indexterm" data-primary="deleting" data-secondary="partitions" data-tertiary="with parted command" data-tertiary-sortas="parted command" id="delete-partition"/><a data-type="indexterm" data-primary="parted command" data-secondary="filesystems" data-tertiary="deleting" id="parted-delete-filesystem"/>need to delete a filesystem and its underlying partition.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466158130776">
<h2>Solution</h2>

<p>To delete the filesystem and its partition, use <em>parted</em>. In this example,
<em>/dev/sdb1</em> is deleted. Verify which partition and filesystem you are going to
delete, then make sure the filesystem is unmounted. In the example, the
mountpoint is <em>/media/duchess/stuff</em>:</p>
<pre>$ <strong>lsblk -f</strong>
sda
├─sdb1 ext4   /media/duchess/stuff
[...]
$ <strong>umount /media/duchess/stuff</strong>
</pre>

<p>Then use <em>parted</em> to delete the partition:</p>
<pre>$ <strong>sudo parted /dev/sdb</strong>
GNU Parted 3.2
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted)<strong> print </strong>
Model: ATA SAMSUNG HD204UI (scsi)
Disk /dev/sdb: 2000GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name  Flags
 1      1049kB  1656GB  1656GB  ext4          stor-1
 1      1656GB  2656GB  1000GB  ext4          stor-2
(parted) <strong>rm 1</strong>
</pre>

<p>If you prefer a graphical tool, use GParted (<a data-type="xref" href="ch09.xhtml#cha-partitioning-gparted">Chapter 9</a>).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466158123224">
<h2>Discussion</h2>

<p>Yes, the command<a data-type="indexterm" data-primary="umount command" id="idm46466158120376"/> is <em>umount</em>, not <em>unmount</em>. <em>umount</em> dates from the ancient
Unix era, when identifiers had a limit of six characters.</p>

<p>Deleting all the files in a partition does not delete the filesystem. The filesystem structure
remains in<a data-type="indexterm" data-primary="filesystems" data-secondary="deleting" data-tertiary="with parted command" data-tertiary-sortas="parted command" data-startref="filesystem-delete" id="idm46466158118232"/><a data-type="indexterm" data-primary="deleting" data-secondary="filesystems" data-tertiary="with parted command" data-tertiary-sortas="parted command" data-startref="delete-filesystem" id="idm46466158117112"/><a data-type="indexterm" data-primary="partitions" data-secondary="deleting" data-tertiary="with parted command" data-tertiary-sortas="parted command" data-startref="partition-delete" id="idm46466158116216"/><a data-type="indexterm" data-primary="deleting" data-secondary="partitions" data-tertiary="with parted command" data-tertiary-sortas="parted command" data-startref="delete-partition" id="idm46466158113048"/><a data-type="indexterm" data-primary="parted command" data-secondary="filesystems" data-tertiary="deleting" data-startref="parted-delete-filesystem" id="idm46466158111160"/> place.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466158108936">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 1 dd</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.5 Using a New Filesystem"><div class="sect1" id="rec-filesystem-temp-mount">
<h1>11.5 Using a New Filesystem</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466158104840">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="mounting" id="filesystem-mount"/><a data-type="indexterm" data-primary="mounting" data-secondary="filesystems" id="mount-filesystem"/><a data-type="indexterm" data-primary="mountpoints" data-secondary="creating" id="mountpoint-create"/> just created a nice new filesystem, and you need to mount it.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466158099304">
<h2>Solution</h2>

<p>After creating your new filesystem, you must create a mountpoint, and optionally
configure automatic mounting. As discussed in the introduction to this chapter, a new
filesystem must be mounted, or attached, to the running filesystem to be usable.</p>

<p>Ext4, XFS, and Btrfs all have access controls. If you want the files on these
filesystems available to anyone other than the root user, you must adjust ownership and permissions. FAT16/32 and exFAT do not have access controls and are wide open to anyone.</p>

<p>Start by mounting your new filesystem. Create a mountpoint, which is a directory,
and then mount the filesystem, like this example for Mad Max:</p>
<pre>$ <strong>sudo mkdir -p <i>/mnt/madmax/newfs</i></strong>
$ <strong>sudo mount <i>/dev/sdb1 /mnt/madmax/newfs</i> </strong>
</pre>

<p>The following example sets the ownership of the new filesystem to Mad Max,
read-write-execute, with read-only permissions for group and world:</p>
<pre>$ <strong>sudo chown -R <i>madmax:madmax /mnt/madmax/newfs</i></strong>
$ <strong>sudo chmod -R 0755 <i>/mnt/madmax/newfs</i></strong>
</pre>

<p>Now Mad Max can access the new filesystem. This mount only lasts until the next
system restart; see <a data-type="xref" href="#rec-automatic-fs-mount">Recipe 11.6</a> to learn how to configure automatic
filesystem mounts.</p>
<div data-type="tip"><h1>Only One Filesystem per Mountpoint</h1>
<p>Every filesystem needs its own unique mountpoint; you cannot put multiple filesystems on a single mountpoint.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466158099048">
<h2>Discussion</h2>

<p>See <a data-type="xref" href="ch06.xhtml#cha-files-directories">Chapter 6</a> for detailed recipes on managing ownership and
permissions.</p>

<p>The traditional directories that contain<a data-type="indexterm" data-primary="/mnt" data-secondary="mountpoints in" id="idm46466158085144"/><a data-type="indexterm" data-primary="/media" data-secondary="mountpoints in" id="idm46466158082936"/> mountpoints are <em>/mnt</em> and <em>/media</em>.
<em>/mnt</em> is traditionally for static mounts (configured in <em>/etc/fstab</em>), and
<em>/media</em> is for automounting removable media. You may create your mountpoints
wherever you want. The advantage of using the traditional directories is having
your mountpoints in a limited number of predictable locations.</p>

<p>A shared directory with mountpoints for multiple users could look like this, with
a directory for each user:</p>
<pre>$ <strong>tree /shared</strong>
/shared
├── duchess
├── madmax
└── stash
</pre>

<p>Then every filesystem needs its own mountpoint in the user subdirectories. For
example, Mad Max has two filesystems mounted at <em>madmax1</em> and <em>madmax2</em>:</p>
<pre>$ <strong>tree -L 2 /mnt</strong>
/mnt
├── duchess
├── madmax
│   ├── madmax1
│   └── madmax2
└── stash
</pre>

<p>The mountpoints can have any names you want. For example, Mad Max’s
mountpoints could be <em>fs1</em> and <em>fs2</em>, or <em>fred</em> and <em>ethel</em>, or <em>max1</em>
and <em>max2</em>, whatever helps you remember what they are.</p>

<p>Use the <em>stat</em> command <a data-type="indexterm" data-primary="stat command" id="idm46466158072472"/>to see the permissions on a filesystem, like this example
for Mad
Max’s new filesystem:</p>
<pre>$ <strong>stat /shared/madmax/madmax1</strong>
[...]
Access: (0755/drwxr-xr-x) Uid: ( 0/ madmax) Gid: ( 0/ madmax)
</pre>

<p>List all filesystem mounts <a data-type="indexterm" data-primary="mount command" id="idm46466158069800"/>with <em>mount</em>:</p>
<pre>$ <strong>mount</strong>
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs
[...]</pre>

<p>Use the <em>mountpoint</em> command to learn if a directory is a <a data-type="indexterm" data-primary="mountpoint command" id="idm46466158066568"/><a data-type="indexterm" data-primary="filesystems" data-secondary="mounting" data-startref="filesystem-mount" id="idm46466158065960"/><a data-type="indexterm" data-primary="mounting" data-secondary="filesystems" data-startref="mount-filesystem" id="idm46466158064872"/><a data-type="indexterm" data-primary="mountpoints" data-secondary="creating" data-startref="mountpoint-create" id="idm46466158063752"/>mountpoint:</p>
<pre>$ <strong>mountpoint madmax1/</strong>
madmax1/ is a mountpoint</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466158087176">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 1 chown</em></p>
</li>
<li>
<p><em>man 1 chmod</em></p>
</li>
<li>
<p><em>man 1 stat</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.6 Creating Automatic Filesystem Mounts"><div class="sect1" id="rec-automatic-fs-mount">
<h1>11.6 Creating Automatic Filesystem Mounts</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466158055624">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="filesystems" data-secondary="mounting" data-tertiary="automatically" id="filesystem-mount-auto"/><a data-type="indexterm" data-primary="mounting" data-secondary="filesystems" data-tertiary="automatically" id="mount-filesystem-auto"/><a data-type="indexterm" data-primary="automatic filesystem mounts" id="auto-filesystem-mount"/><a data-type="indexterm" data-primary="/etc/fstab" id="etc-fstab"/>have added a new filesystem, and you want it to automatically mount at system
startup.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466158048472">
<h2>Solution</h2>

<p>This is what your <em>/etc/fstab</em> file is for. The following example is added to the
existing <em>/etc/fstab</em> file to create a static mount for the filesystem in
<a data-type="xref" href="#rec-filesystem-temp-mount">Recipe 11.5</a>, and it will be automatically mounted at startup:</p>

<pre data-type="programlisting">#&lt;file system&gt;    &lt;mount point&gt;        &lt;type&gt;   &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
LABEL=xfs-ehd     /mnt/madmax/newfs    xfs      defaults,user   0       2</pre>

<p>Use <a data-type="indexterm" data-primary="findmnt command" id="idm46466158043896"/>the <em>findmnt</em> command to test your new configuration:</p>
<pre>$ <strong>sudo findmnt --verbose --verify </strong>
/
   [ ] target exists
   [ ] UUID=102a6fce-8985-4896-a5f9-e5980cb21fdb translated to /dev/sda2
   [ ] source /dev/sda2 exists
   [ ] FS type is btrfs
   [W] recommended root FS passno is 1 (current is 0)
/mnt/madmax/newfs
   [ ] target exists
   [ ] LABEL=xfs-ehd translated to /dev/sdb1
   [ ] source /dev/sdb1 exists
   [ ] FS type is xfs
[...]
0 parse errors, 0 errors, 1 warning</pre>

<p>The warning “recommended root FS passno is 1 (current is 0)” is not significant.
If that is the only warning, and there are no errors, reboot to test, or run the
following command to mount your new <em>/etc/fstab</em> entry:</p>
<pre>$ <strong>sudo mount -a</strong></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466158048216">
<h2>Discussion</h2>

<p>This is what the six <em>fstab</em> columns are for:</p>
<dl>
<dt>device</dt>
<dd>
<p>The UUID or filesystem LABEL. Don’t use <em>/dev</em> names because they are not
unique, and sometimes they change. Run <em>lsblk -o UUID,LABEL</em> to list UUIDs and
filesystem labels to use in the <em>device:</em> column.</p>
</dd>
<dt>mountpoint</dt>
<dd>
<p>The directory you created for the filesystem.</p>
</dd>
<dt>type</dt>
<dd>
<p>The filesystem type, for example, <em>xfs</em>, <em>ext4</em>, or <em>btrfs</em>. You may use <em>auto</em>
for the filesystem type, and the kernel will automatically detect the filesystem type.</p>
</dd>
<dt>options</dt>
<dd>
<p>Your mount options in a comma-delimited list (see below for a list).</p>
</dd>
<dt>dump</dt>
<dd>
<p>If you’re using the <em>dump</em> command for backups, this tells <em>dump</em> the backup interval, in days. So, 1 means every day, 2 means every other day, 3 is every third day, and so
on. Most likely you are not using <em>dump</em> and should enter 0.</p>
</dd>
<dt>pass</dt>
<dd>
<p>This tells the filesystem checker which filesystem to check first at bootup, if it ever needs to. Make your root filesystem 1, any other Linux filesystems 2, and non-Linux filesystems 0.</p>
</dd>
</dl>

<p>The following <em>options</em> define permissions:</p>
<dl>
<dt>defaults</dt>
<dd>
<p>The default options are <em>rw</em>, <em>suid</em>, <em>dev</em>, <em>exec</em>, <em>auto</em>, <em>nouser</em>, and <em>async</em>.
The <em>defaults</em> values are overridden by appending additional options, for example
<em>defaults,user</em> gives the user permission to mount and unmount the filesystem. You may
append as many options as you like, or omit <em>defaults</em> and list only the options you
want.</p>
</dd>
<dt>rw</dt>
<dd>
<p>Read/write.</p>
</dd>
<dt>ro</dt>
<dd>
<p>Read-only.</p>
</dd>
<dt>suid</dt>
<dd>
<p>Allow setuid and setgid bits to operate.</p>
</dd>
<dt>dev</dt>
<dd>
<p>Interpret block and character devices.</p>
</dd>
<dt>exec</dt>
<dd>
<p>Allow binaries to run.</p>
</dd>
<dt>auto</dt>
<dd>
<p>Indicates which filesystems should start at boot.</p>
</dd>
<dt>nouser</dt>
<dd>
<p>Nonroot users cannot mount or unmount the filesystem.</p>
</dd>
<dt>async</dt>
<dd>
<p>Asynchronous I/O, which is standard for Linux.</p>
</dd>
<dt>user</dt>
<dd>
<p>Nonroot users can mount and unmount the device, if they mounted it.</p>
</dd>
<dt>users</dt>
<dd>
<p>Any user can mount and unmount the device.</p>
</dd>
<dt>noauto</dt>
<dd>
<p>Do not automatically mount at boot.</p>
</dd>
<dt>ro</dt>
<dd>
<p>Mount the filesystem read-only.</p>
</dd>
<dt>noatime</dt>
<dd>
<p>Do not update the “time accessed” file attribute. <em>noatime</em> was used
in times past to speed up performance. If you are on a modern computer, it probably
won’t make much difference.</p>
</dd>
<dt>gid</dt>
<dd>
<p>Limit access to a <a data-type="indexterm" data-primary="filesystems" data-secondary="mounting" data-tertiary="automatically" data-startref="filesystem-mount-auto" id="idm46466157996040"/><a data-type="indexterm" data-primary="mounting" data-secondary="filesystems" data-tertiary="automatically" data-startref="mount-filesystem-auto" id="idm46466157994760"/><a data-type="indexterm" data-primary="automatic filesystem mounts" data-startref="auto-filesystem-mount" id="idm46466157993432"/><a data-type="indexterm" data-primary="/etc/fstab" data-startref="etc-fstab" id="idm46466157992488"/>group (from <em>/etc/group</em>); for example, <em>gid=group1</em>.</p>
</dd>
</dl>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466158022024">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 8 mount</em></p>
</li>
<li>
<p><em>man 5 fstab</em></p>
</li>
<li>
<p><a href="https://systemd.io">systemd</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.7 Creating Ext4 Filesystems"><div class="sect1" id="rec-create-filesystem">
<h1>11.7 Creating Ext4 Filesystems</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157984104">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="creating" id="filesystem-ext4-create"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="creating" id="ext4-create"/> want to create a new Ext4 filesystem on an internal or external storage
disk.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157979704">
<h2>Solution</h2>

<p>Start with a partition of the size you want for your filesystem. Then use the
<em>mkfs.ext4</em> command <a data-type="indexterm" data-primary="mkfs.ext4 command" id="mkfsext4"/>to create the new Ext4 filesystem.</p>

<p>The following example overwrites an existing XFS filesystem with a new Ext4
filesystem. When you overwrite an existing filesystem, it must first be
unmounted. In this example, the filesystem on <em>/dev/sdb1</em> is mounted at
<em>/media/duchess/stuff</em>, which you can see with the <em>df</em> command:</p>
<pre>$ <strong>df -Th /media/duchess/stuff/</strong>
Filesystem     Type  Size  Used Avail Use% Mounted on
/dev/sdb1      xfs   952M  7.9M  944M   1% /media/duchess/stuff</pre>

<p>You may need root permissions to unmount:</p>
<pre>$ <strong>sudo umount /media/duchess/stuff</strong></pre>

<p>Create the new Ext4 filesystem:</p>
<pre>$ <strong>sudo mkfs.ext4 -L <i>'mylabel' /dev/sdb1</i></strong>
mke2fs 1.44.1 (24-Mar-2018)
/dev/sdb1 contains a XFS file system labelled 'stuff'
        created on Sun Sep 20 19:37:43 2020
Proceed anyway? (y,N) <strong>y</strong>
Creating filesystem with 466432 4k blocks and 116640 inodes
Filesystem UUID: 99da2e5d-f96a-4fb6-990d-599cf56247a2
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
</pre>

<p>You could also create a new partition and put your new filesystem on it; see
the examples for creating new partitions in Recipes <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch08.xhtml#rec-create-gpt">8.4</a> and
<a data-xrefstyle="select:labelnumber" data-type="xref" href="ch09.xhtml#rec-new-partition-gparted">9.4</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157967896">
<h2>Discussion</h2>

<p>Overwriting a filesystem destroys all the data on it.</p>

<p>The <em>-L</em> option is for creating a volume label. This can be anything you
want, up to 16 characters (FAT32 is limited to 11 characters). It is not
required, though filesystem labels are useful, and for some operations, such as
in <em>/etc/fstab</em>, can be used in place of the long UUID.</p>

<p>The <em>-n</em> option does a dry run, so you see what will happen without actually
creating the new filesystem.</p>

<p><em>mke2fs</em> has numerous options, but you will likely use just a few of them:
device name, volume label, dry-run, and creating an external journal. Its
defaults are set in <em>/etc/mke2fs.conf</em>, and I suggest not changing them
without thorough study of the available<a data-type="indexterm" data-primary="mkfs.ext4 command" data-startref="mkfsext4" id="idm46466157962104"/><a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="creating" data-startref="filesystem-ext4-create" id="idm46466157961368"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="creating" data-startref="ext4-create" id="idm46466157957320"/> settings.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157958424">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 8 mke2fs</em></p>
</li>
<li>
<p><a data-type="xref" href="ch08.xhtml#rec-create-gpt">Recipe 8.4</a></p>
</li>
<li>
<p><a data-type="xref" href="#rec-filesystem-temp-mount">Recipe 11.5</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.8 Configuring the Ext4 Journal Mode"><div class="sect1" id="rec-journal-mode">
<h1>11.8 Configuring the Ext4 Journal Mode</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157949880">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="configuring journal mode" id="filesystem-ext4-journal-config"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="journal mode, configuring" id="ext4-journal-config"/><a data-type="indexterm" data-primary="journal mode (Ext4), configuring" id="journal-config"/><a data-type="indexterm" data-primary="configuring" data-secondary="journal mode (Ext4)" id="config-journal"/><a data-type="indexterm" data-primary="tune2fs command" data-secondary="configuring journal mode" id="tune2fs"/> know that the default journal mode for ext4 is <em>data=ordered</em>, which does
not journal data, but only metadata. It is a good balance of safety and speed,
but you want to set it to <em>data=journal</em>, which is the safest.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157940984">
<h2>Solution</h2>

<p>Use the <em>tune2fs</em> command. First check your existing journal mode <a data-type="indexterm" data-primary="dmesg command" id="idm46466157937928"/>with <em>dmesg</em>.
The filesystem must be mounted:</p>
<pre>$ <strong>dmesg | grep sdb1</strong>
[25023.525279] EXT4-fs (sdb1): mounted filesystem with ordered data mode.
</pre>

<p class="pagebreak-before less_space">That confirms <em>/dev/sdb1</em> is formatted as Ext4 and has the default
<em>data=ordered</em> journal mode. Now change it to <em>data=journal</em> mode:</p>
<pre>$ <strong>sudo tune2fs -o journal_data /dev/sdb1</strong>
tune2fs 1.44.1 (24-Mar-2018)
</pre>

<p>Unmount and remount, and check again with <em>dmesg</em>:</p>
<pre>$ <strong>dmesg | grep sdb1</strong>
[25023.525279] EXT4-fs (sdb1): mounted filesystem with ordered data mode.
</pre>

<p>If you see multiple lines with conflicting information, like this:</p>

<pre data-type="programlisting">[  206.076123] EXT4-fs (sdb1): mounted filesystem with journalled data mode.
[  206.076433] EXT4-fs (sdb1): mounted filesystem with ordered data mode.</pre>

<p>Reboot, and then you should see only the “mounted filesystem with journalled
data mode” line.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157941832">
<h2>Discussion</h2>

<p>The journal mode command options are named differently, depending on what
documentation you are reading. In <em>man 8 tune2fs</em>, the following options are listed:</p>

<ul>
<li>
<p>journal_data</p>
</li>
<li>
<p>journal_data_ordered</p>
</li>
<li>
<p>journal_data_writeback</p>
</li>
</ul>

<p>In the kernel documentation, and a whole lot of how-tos, these are the options:</p>

<ul>
<li>
<p>data=journal</p>
</li>
<li>
<p>data=ordered</p>
</li>
<li>
<p>data=writeback</p>
</li>
</ul>

<p>The <em>data=</em> options are meant to be passed to the kernel at boot either in your
bootloader configuration, or in <em>/etc/fstab</em>. I favor using <em>tune2fs</em> because
it is fast and easy, and works on all Ext4 filesystems regardless of their
mount configurations.</p>

<p>These are the journal modes in order of data safety:</p>
<dl>
<dt>data=journal</dt>
<dd>
<p>Provides the most protection for your data. All data and
metadata are first written to the journal, and then written to the filesystem.
In the event of a failure, this gives you the best chance of recovering your
data. This is also the most resource intensive, as your changes are written
twice.</p>
</dd>
<dt>data=ordered</dt>
<dd>
<p>This does not write your data to the journal. Data is first written
to the filesystem, and then metadata is written to the journal. The metadata is
logically grouped in order and held in a single transaction. When the metadata
is written to disk, its associated data blocks are written first.</p>
</dd>
<dt>data=writeback</dt>
<dd>
<p>This is the fastest and the least safe. Data is first written
to the filesystem, and then metadata is written to the journal. Data ordering
is not preserved. I don’t think the small performance gain is worth the<a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="configuring journal mode" data-startref="filesystem-ext4-journal-config" id="idm46466157909816"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="journal mode, configuring" data-startref="ext4-journal-config" id="idm46466157914760"/><a data-type="indexterm" data-primary="journal mode (Ext4), configuring" data-startref="journal-config" id="idm46466157913624"/><a data-type="indexterm" data-primary="configuring" data-secondary="journal mode (Ext4)" data-startref="config-journal" id="idm46466157912632"/><a data-type="indexterm" data-primary="tune2fs command" data-secondary="configuring journal mode" data-startref="tune2fs" id="idm46466157908136"/> extra
risk.</p>
</dd>
</dl>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157929432">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 8 tune2fs</em></p>
</li>
<li>
<p><a href="https://oreil.ly/Y4ajq">Kernel documentation for the Ext4 filesystem</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.9 Finding Which Journal Your Ext4 Filesystem Is Attached To"><div class="sect1" id="idm46466157902392">
<h1>11.9 Finding Which Journal Your Ext4 Filesystem Is Attached To</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157901160">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="finding attached journals" id="filesystem-ext4-attach-journal"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="journals, finding attached" id="ext4-journal-attach"/><a data-type="indexterm" data-primary="journals (Ext4)" data-secondary="finding attached" id="journal-attach"/><a data-type="indexterm" data-primary="attached journals (Ext4), finding" id="attach-journal"/><a data-type="indexterm" data-primary="finding" data-secondary="attached journals (Ext4)" id="find-attach-journal"/><a data-type="indexterm" data-primary="dumpe2fs command" id="dumpe2fs"/> have several Ext4 filesystems, some with internal journals and some with
external journals, and you want to know which journals they are using.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157891832">
<h2>Solution</h2>

<p>Meet a new command, <em>dumpe2fs</em>. This is a part of the <em>e2fsprogs</em> suite of
ext2/3/4 utilities. Query your Ext4 filesystem:</p>
<pre>$ <strong>sudo dumpe2fs -h /dev/sda1 | grep -i uuid</strong>
dumpe2fs 1.43.8 (1-Jan-2018)
Filesystem UUID:          8593f3b7-4b7b-4da7-bf4a-cc6b0551cff8
Journal UUID:             f8e42703-94eb-49af-a94c-966e5b40e756
</pre>

<p>The <em>Journal UUID</em> belongs to the journal. Run <em>lsblk</em> to verify details:</p>
<pre>$ <strong>lsblk -f | grep  f8e42703-94eb-49af-a94c-966e5b40e756</strong>
└─sdb5 ext4    journal1 f8e42703-94eb-49af-a94c-966e5b40e756
</pre>

<p>And there it is. An Ext4 filesystem using an internal journal looks like this,
without the Journal UUID line:</p>
<pre>$ <strong>sudo dumpe2fs -h /dev/sda2 | grep UUID</strong>
dumpe2fs 1.44.1 (24-Mar-2018)
Filesystem UUID:          64bfb5a8-0ef6-418a-bb44-6c389514ecfc
</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157891576">
<h2>Discussion</h2>

<p>There is always a way to find out where things are in Linux. The <em>dumpe2fs</em>
command shows a lot of useful information about your Ext4 filesystems, including
UUIDs, filesystem creation time, block count, free blocks, journal size, <a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="finding attached journals" data-startref="filesystem-ext4-attach-journal" id="idm46466157883240"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="journals, finding attached" data-startref="ext4-journal-attach" id="idm46466157881512"/><a data-type="indexterm" data-primary="journals (Ext4)" data-secondary="finding attached" data-startref="journal-attach" id="idm46466157880376"/><a data-type="indexterm" data-primary="attached journals (Ext4), finding" data-startref="attach-journal" id="idm46466157878920"/><a data-type="indexterm" data-primary="finding" data-secondary="attached journals (Ext4)" data-startref="find-attach-journal" id="idm46466157877976"/><a data-type="indexterm" data-primary="dumpe2fs command" data-startref="dumpe2fs" id="idm46466157876760"/>and
much more.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157875016">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 8 dumpe2fs</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.10 Improving Performance with an External Journal for Ext4"><div class="sect1" id="idm46466157902088">
<h1>11.10 Improving Performance with an External Journal for Ext4</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157871192">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="external journals" id="filesystem-ext4-external"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="external journals" id="ext4-external"/><a data-type="indexterm" data-primary="journals (Ext4)" data-secondary="external" id="journal-external"/><a data-type="indexterm" data-primary="external journals (Ext4)" id="external-journal"/><a data-type="indexterm" data-primary="performance of external journals (Ext4)" id="performance-external-journal"/> have heard that placing the Ext4 journal on a different disk than the
filesystem improves performance, and you want to do this.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157863288">
<h2>Solution</h2>

<p>An external journal improves performance when your journal mode is
<em>data=journal</em>. (See the Discussion for more information on journal modes.)
You may create a new Ext4 filesystem and external journal, or convert an
existing filesystem to use an external journal.</p>

<p>The two disks must be on the same machine and have similar read and write
speeds. If the journal disk is slower than the filesystem disk, you will not see
much, if any, of a performance gain. You could use two similar solid-state disks (SSDs), two similar
hard disk drives (HDDs), or use a small SSD for the journal
and a large HDD for the filesystem, because SSDs are much faster than HDDs.</p>

<p>Locating the Ext4 journal on a separate disk takes several steps. In the
following example, we will create two new partitions, one for the journal and
one for the new Ext4 filesystem. Then create the journal, then the filesystem,
and attach it to the 
<span class="keep-together">journal</span>.</p>

<p>The first partition is for the journal on <em>/dev/sdb5</em>, 200 GB in size, and the second
partition is for the Ext4 filesystem on <em>/dev/sda1</em>, 500 GB:</p>
<pre>$ <strong>sudo parted</strong>
(parted)<strong> select /dev/sdb</strong>
Using /dev/sdb
(parted) <strong>mkpart "journal1" ext4 1600GB 1800GB</strong>
(parted) <strong>select /dev/sda</strong>
Using /dev/sda
(parted) <strong>mkpart "ext4fs" ext4 1MB 500GB</strong>
</pre>

<p>The external journal and the filesystem must have the same block size, which is specified
in the following example with <em>-b 4096</em>. If you don’t know the block size, find<a data-type="indexterm" data-primary="tune2fs command" data-secondary="finding block size" id="idm46466157853064"/> 
<span class="keep-together">it with</span> <em>tune2fs</em>.
The following commands are run in the Bash shell, and not in the 
<span class="keep-together"><em>parted</em></span> shell:</p>
<pre>$ <strong>sudo tune2fs -l /dev/sda1  | grep -i 'block size'</strong>
Block size:               4096</pre>

<p>Now create the journal, which can take a few minutes, and then the new filesystem:</p>
<pre>
$ <strong>sudo mke2fs -b 4096 -O journal_dev /dev/sdb5</strong>
mke2fs 1.43.8 (1-Jan-2018)
/dev/sdb2 contains a ext4 file system labelled 'ext4'
        created on Mon Jan  4 18:25:30 2021
Proceed anyway? (y,N) <strong>y</strong>
Creating filesystem with 48747520 4k blocks and 0 inodes
Filesystem UUID: f8e42703-94eb-49af-a94c-966e5b40e756
Superblock backups stored on blocks:
Zeroing journal device:

$ <strong>sudo mkfs.ext4 -b 4096 -J device=/dev/sdb5 /dev/sda1</strong>
mke2fs 1.43.8 (1-Jan-2018)
Creating filesystem with 35253504 4k blocks and 8814592 inodes
Filesystem UUID: 8593f3b7-4b7b-4da7-bf4a-cc6b0551cff8
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
        4096000, 7962624, 11239424, 20480000, 23887872

Allocating group tables: done
Writing inode tables: done
Adding journal to device /dev/sdb2: done
Writing superblocks and filesystem accounting information: done
</pre>

<p>You’re finished and can use your new filesystem.</p>

<p>You can attach an external journal to an existing filesystem with the
<em>tune2fs</em> command. First clear the journal on the existing filesystem, then
link the filesystem to the external journal:</p>
<pre>$ <strong>sudo tune2fs -O ^has_journal /dev/sda1</strong>
$ <strong>sudo tune2fs -b 4096 -J device=/dev/sdb5 /dev/sda1</strong>
</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157843240">
<h2>Discussion</h2>

<p>The Ext4 journal provides extra protection for your data, in the event of
a disk or system failure, by tracking changes that are not yet written to
disk. Even if it loses your most recent changes, it protects the filesystem from
being corrupted, so you lose just a little bit instead of the whole works.</p>

<p>Moving the journal to a separate disk on the same machine provides a noticeable
performance boost when the journal mode is <em>data=journal</em>. Ext4 has three
journaling modes: <em>journal</em>, <em>ordered</em>, and <em>writeback</em>. The default is
<em>ordered</em>. See <a data-type="xref" href="#rec-journal-mode">Recipe 11.8</a> to learn about these modes and how
to select the one you want to use.</p>

<p>The caret, <em>^</em>, disables a feature. In the example in the recipe, it clears
the existing internal journal.</p>

<p>Ext4 journals cannot be shared, and can be used by only one filesystem.<a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="external journals" data-startref="filesystem-ext4-external" id="idm46466157834856"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="external journals" data-startref="ext4-external" id="idm46466157833640"/><a data-type="indexterm" data-primary="journals (Ext4)" data-secondary="external" data-startref="journal-external" id="idm46466157832552"/><a data-type="indexterm" data-primary="external journals (Ext4)" data-startref="external-journal" id="idm46466157831464"/><a data-type="indexterm" data-primary="performance of external journals (Ext4)" data-startref="performance-external-journal" id="idm46466157830616"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157840088">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 8 mke2fs</em></p>
</li>
<li>
<p><em>man 8 tune2fs</em></p>
</li>
<li>
<p><a data-type="xref" href="ch08.xhtml#cha-partitioning-parted">Chapter 8</a></p>
</li>
<li>
<p><a data-type="xref" href="ch09.xhtml#cha-partitioning-gparted">Chapter 9</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.11 Freeing Space from Reserved Blocks on Ext4 Filesystems"><div class="sect1" id="idm46466157823608">
<h1>11.11 Freeing Space from Reserved Blocks on Ext4 Filesystems</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157822712">
<h2>Problem</h2>

<p>Most<a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="freeing reserved space" id="filesystem-ext4-free"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="freeing reserved space" id="ext4-free"/><a data-type="indexterm" data-primary="reserved space in Ext4 filesystems, freeing" data-secondary-sortas="Ext4 filesystems" id="reserve-ext4-free"/><a data-type="indexterm" data-primary="freeing reserved space in Ext4 filesystems" id="free-reserve-ext4"/><a data-type="indexterm" data-primary="tune2fs command" data-secondary="freeing reserved space" id="tune2fs-free"/> Linux distributions reserve 5% of Ext4 filesystems for the root user and
system services. On large modern hard disks that is a lot of space, and you want
to free some of that space.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157814312">
<h2>Solution</h2>

<p>Use the <em>tune2fs</em> command to adjust the size of the free space on an Ext4
filesystem. You may configure it by percentage, like this example that reduces
it to 1%:</p>
<pre>$ <strong>sudo tune2fs -m 1 /dev/sda1</strong>
tune2fs 1.44.1 (24-Mar-2018)
Setting reserved blocks percentage to 1% (820474 blocks)
</pre>

<p>That is still about 3 gigabytes, with 4K blocks (820,474 x 4,096 = 3,360,661,504 bytes). Find
your block size:</p>
<pre>$ <strong>sudo tune2fs -l /dev/sda1  | grep -i 'block size'</strong>
Block size:               4096</pre>

<p>You can set a fractional percentage:</p>
<pre>$ <strong>sudo tune2fs -m .25 /dev/sda1</strong>
tune2fs 1.44.1 (24-Mar-2018)
Setting reserved blocks percentage to 0.25% (205118 blocks)
</pre>

<p class="pagebreak-before less_space">That is roughly 800 MB. Or, specify a number of blocks:</p>
<pre>$ <strong>sudo tune2fs -r 250000 /dev/sda1</strong>
tune2fs 1.44.1 (24-Mar-2018)
Setting reserved blocks count to 250000
</pre>

<p>250,000 4K blocks is about a gigabyte. Check your work:</p>
<pre>$ <strong>sudo tune2fs -l /dev/sda1 | grep -i 'reserved block'</strong>
Reserved block count:     250000
</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157813736">
<h2>Discussion</h2>

<p>If you run out of disk space, you can still log in as root and
free up space, which you could not do if that 5% was not held in reserve.
However, that 5% is a holdover from the days of megabyte hard disks. Hard disks
are so large now, you don’t need all that reserved space. For example, 5% of a 1
TB disk is about 50 GB. Only a few hundred megabytes of reserved space is
necessary. I set mine to a gigabyte. It’s easy to remember and provides more than
enough room.</p>

<p>Use the <em>dumpe2fs</em> command to check out the reserved blocks settings in your
Ext4<a data-type="indexterm" data-primary="dumpe2fs command" data-secondary="reserved space settings" id="idm46466157803880"/><a data-type="indexterm" data-primary="filesystems" data-secondary="Ext4" data-tertiary="freeing reserved space" data-startref="filesystem-ext4-free" id="idm46466157803032"/><a data-type="indexterm" data-primary="Ext4 filesystems" data-secondary="freeing reserved space" data-startref="ext4-free" id="idm46466157801544"/><a data-type="indexterm" data-primary="reserved space in Ext4 filesystems, freeing" data-secondary-sortas="Ext4 filesystems" data-startref="reserve-ext4-free" id="idm46466157800296"/><a data-type="indexterm" data-primary="freeing reserved space in Ext4 filesystems" data-startref="free-reserve-ext4" id="idm46466157798984"/><a data-type="indexterm" data-primary="tune2fs command" data-secondary="freeing reserved space" data-startref="tune2fs-free" id="idm46466157797944"/> filesystem:</p>
<pre>$ <strong>sudo dumpe2fs -h /dev/sda1</strong>
[...]
Block count:              82047488
Reserved block count:     250000
[...]
</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157793160">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 8 dumpe2fs</em></p>
</li>
<li>
<p><em>man 8 tune2fs</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.12 Creating a New XFS Filesystem"><div class="sect1" id="idm46466157789608">
<h1>11.12 Creating a New XFS Filesystem</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157788648">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="filesystems" data-secondary="XFS" data-tertiary="creating" id="idm46466157787512"/><a data-type="indexterm" data-primary="XFS filesystems" data-secondary="creating" id="idm46466157786424"/>like XFS, and want to create a new XFS filesystem.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157785192">
<h2>Solution</h2>

<p>You need the <em>xfsprogs</em> package installed on your system and a partition
for the new filesystem. Then create your new XFS filesystem with
<em>mkfs.xfs</em>. The<a data-type="indexterm" data-primary="mkfs.xfs command" id="idm46466157782696"/> following example, on Ubuntu, demonstrates all these steps.
The example new partition is <em>/dev/sda1</em>, and the new filesystem gets an <em>xfstest</em> label:</p>
<pre>$ <strong>sudo apt install xfsprogs</strong>
$ <strong>sudo parted /dev/sda mkpart testxfs xfs 1MB 500GB</strong>
$ <strong>sudo mkfs.xfs -L xfstest /dev/sda1</strong>
meta-data=/dev/sdb5              isize=512    agcount=4, agsize=640000 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=0, rmapbt=0,
reflink=0
data     =                       bsize=4096   blocks=2560000, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
</pre>

<p>Check your work with <em>lsblk</em>:</p>
<pre>$ <strong>lsblk -f | grep -w sda1</strong>
├─sda1 xfs    xfstest  bb5dddb3-af74-4bed-9d2a-e79589278e84</pre>

<p>Mount your new filesystem, adjust ownership and permissions, and it’s ready to
use. The following example mounts it on <em>/mnt/xfstest</em>, sets ownership to
Duchess, read-write for Duchess and read only for everyone else:</p>
<pre>
$ <strong>sudo mkdir /mnt/xfstest</strong>
$ <strong>sudo mount /dev/sda1 /mnt/xfstest </strong>
$ <strong>sudo chown -R duchess:duchess /mnt/xfstest</strong>
$ <strong>sudo chmod -R -755 /mnt/xfstest</strong>
</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157772648">
<h2>Discussion</h2>

<p>The command output from creating a new XFS filesystem contains a few helpful
items, like the block size, number of blocks, and sector size.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157772104">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 8 mkfs.xfs</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.13 Resizing an XFS Filesystem"><div class="sect1" id="idm46466157768056">
<h1>11.13 Resizing an XFS Filesystem</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157766968">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="filesystems" data-secondary="XFS" data-tertiary="resizing" id="filesystem-xfs-resize"/><a data-type="indexterm" data-primary="XFS filesystems" data-secondary="resizing" id="xfs-resize"/><a data-type="indexterm" data-primary="resizing" data-secondary="XFS filesystems" id="resize-xfs"/>want to resize an XFS filesystem.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157761896">
<h2>Solution</h2>

<p>You can only increase the size of an XFS filesystem. If you need it to be smaller, you
must copy your data to a safe location, create a smaller partition, format it as XFS,
then restore your data.</p>

<p>Increasing the size is less work. You need free space at the end of the partition
that your XFS filesystem is on. In the following examples, the new endpoint for the
partition is 2700 GB, and the filesystem is mounted at <em>/media/duchess/xfs</em>.</p>

<p>Launch <em>parted</em>. Print<a data-type="indexterm" data-primary="parted command" data-secondary="filesystems" data-tertiary="resizing XFS" id="idm46466157759288"/> the partition information to verify the correct partition
and endpoint, increase the partition size, then quit <em>parted</em>:</p>
<pre>$ <strong>sudo parted <i>/dev/sdb</i></strong>
GNU Parted 3.3
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) <strong>p free </strong>
Model: ATA SAMSUNG HD204UI (scsi)
Disk /dev/sdb: 4000GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name   Flags
        17.4kB  1049kB  1031kB  Free Space
 1      1049kB  1656GB  1656GB  xfs          files
 2      1656GB  1759GB  103GB   xfs          files2
        1759GB  4000GB  242GB   Free Space

(parted) <strong>resizepart 2</strong>
(parted) Warning: Partition /dev/sdb2 is being used. Are you sure you want to
continue?
Yes/No? <strong>Yes</strong>
End?  [1759GB]? <strong>1900GB</strong>
(parted) <strong>q</strong>
</pre>

<p>Now, expand the filesystem to match the new partition size:</p>
<pre>$ <strong>sudo xfs_growfs /media/duchess/xfs</strong></pre>

<p>You’re done! Enjoy your new larger filesystem.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157751304">
<h2>Discussion</h2>

<p>You also have the option to unmount the filesystem and resize it offline. This
is a little safer.</p>

<p>Using GParted to resize a filesystem is fast and easy; <a data-type="indexterm" data-primary="filesystems" data-secondary="XFS" data-tertiary="resizing" data-startref="filesystem-xfs-resize" id="idm46466157746600"/><a data-type="indexterm" data-primary="XFS filesystems" data-secondary="resizing" data-startref="xfs-resize" id="idm46466157745016"/><a data-type="indexterm" data-primary="resizing" data-secondary="XFS filesystems" data-startref="resize-xfs" id="idm46466157743928"/>see
<a data-type="xref" href="ch09.xhtml#rec-resize-partitions-gparted">Recipe 9.7</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157742040">
<h2>See Also</h2>

<ul>
<li>
<p><a data-type="xref" href="ch08.xhtml#rec-resize-partition-fs">Recipe 8.8</a></p>
</li>
<li>
<p><a data-type="xref" href="ch09.xhtml#rec-resize-partitions-gparted">Recipe 9.7</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.14 Creating an exFAT Filesystem"><div class="sect1" id="idm46466157767752">
<h1>11.14 Creating an exFAT Filesystem</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157737064">
<h2>Problem</h2>

<p>Your<a data-type="indexterm" data-primary="filesystems" data-secondary="exFAT, creating" id="filesystem-exfat-create"/><a data-type="indexterm" data-primary="exFAT filesystems" data-secondary="creating" id="exfat-create"/> digital camera flash drive is formatted with the exFAT filesystem, or you have other
flash storage devices that use exFAT, and you want to read, write, and edit the files from
these devices on your Linux system.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157733224">
<h2>Solution</h2>

<p>There are two possible solutions: one is to use the exFAT implementation that runs on
Filesystem in Userspace (FUSE). The other solution is to use the native implementation
that runs in the Linux kernel, rather than userspace. In this recipe we will use<a data-type="indexterm" data-primary="exFAT FUSE utility" id="idm46466157731928"/><a data-type="indexterm" data-primary="FUSE (Filesystem in Userspace)" id="idm46466157731320"/> exFAT FUSE
because at the time this was written the native implementation had not yet made it into
most distribution releases. Look for kernel version 5.7, and check your distribution release
notes and news. (Run the <em>uname -r</em> command to see your kernel version.)</p>

<p>The exFAT package names vary. <em>exfat-fuse</em> and <em>exfat-utils</em> are the older packages.
<em>exfatprogs</em> is the newest implementation, replacing both <em>exfat-fuse</em> and <em>exfat-utils</em>.
Whatever you have, go ahead and install it.</p>

<p>The command to create a new exFAT filesystem is the same for both. The following
example<a data-type="indexterm" data-primary="mkfs.exfat command" id="idm46466157723448"/> formats <em>/dev/sdc1</em> as exFAT:</p>
<pre>$ <strong>sudo mkfs.exfat /dev/sdc1</strong>
mkexfatfs 1.2.8
Creating... done.
Flushing... done.
File system created successfully.</pre>

<p>exFAT is designed to be simple, so there are not a lot of options. You can give it
a label:</p>
<pre>$ <strong>sudo exfatlabel /dev/sdc2 exfatfs</strong></pre>

<p>Verify your changes with <em>lsblk</em>:</p>
<pre>$ <strong>lsblk -f</strong>
NAME   FSTYPE LABEL   UUID
sdc
├─sdc1
├─sdc2 exfat  exfatfs 8178-51D4
└─sdc3 </pre>
</div></section>













<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157719784">
<h2>Discussion</h2>

<p>You do not need a special exFAT partition to read exFAT files on other devices,
but only exFAT installed on your Linux system.</p>

<p>If you prefer a graphical partitioning tool, GParted does not support exFAT, due to legal
concerns. GNOME Disks, <a data-type="indexterm" data-primary="GNOME Disks" id="idm46466157718072"/>called Disks in most GNOME implementations, does support
exFAT. You do not have to install GNOME to get Disks; look for the <em>gnome-disk-utility</em>
package.</p>

<p>Microsoft released the exFAT specification in 2019. Samsung wrote <em>exfatprogs</em> and
released it in early 2020. By the time you read this, the latest releases of Fedora, Ubuntu,
and openSUSE Tumbleweed should have native exFAT <a data-type="indexterm" data-primary="filesystems" data-secondary="exFAT, creating" data-startref="filesystem-exfat-create" id="idm46466157717368"/><a data-type="indexterm" data-primary="exFAT filesystems" data-secondary="creating" data-startref="exfat-create" id="idm46466157714056"/>support.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157719656">
<h2>See Also</h2>

<ul class="no-space-list">
<li>
<p><em>man 8 exfat</em></p>
</li>
<li>
<p><em>man 8  exfatlabel</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.15 Creating FAT16 and FAT32 Filesystems"><div class="sect1" id="rec-create-fat">
<h1>11.15 Creating FAT16 and FAT32 Filesystems</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157706920">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="filesystems" data-secondary="FAT16, creating" id="filesystem-fat16-create"/><a data-type="indexterm" data-primary="filesystems" data-secondary="FAT32, creating" id="filesystem-fat32-create"/><a data-type="indexterm" data-primary="FAT16 filesystems" data-secondary="creating" id="fat16-create"/><a data-type="indexterm" data-primary="FAT32 filesystems" data-secondary="creating" id="fat32-create"/> need to know how to create FAT16 and FAT32 filesystems.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157700216">
<h2>Solution</h2>

<p>You need the <em>dosfstools</em> package, which is installed by default on most Linuxes. The
following examples demonstrate creating a new 500 MB partition with <em>parted</em>, then
formatting the partition with FAT32.</p>

<p>Create<a data-type="indexterm" data-primary="parted command" data-secondary="filesystems" data-tertiary="creating FAT16/FAT32" id="parted-fat16fat32"/><a data-type="indexterm" data-primary="mkpart command" id="mkpart"/> the new partition, and note how to change the measurement units to MB, and how
to use <em>mkpart</em> interactively:</p>
<pre>$ <strong>sudo parted /dev/sdb</strong>
GNU Parted 3.2
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) <strong>print</strong>
Model: ATA SAMSUNG HD204UI (scsi)
Disk /dev/sdb: 2000399MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start    End     Size    File system  Name   Flags
1       0.00GB   1656GB  1656GB  xfs          files

(parted) unit mb
<strong>mkpart </strong>
Partition name?  []?
File system type?  [ext2]? <strong>fat32</strong>
Start? <strong>1656331MB</strong>
End? <strong>1656831MB</strong>
(parted) <strong>print</strong>
Model: ATA SAMSUNG HD204UI (scsi)
Disk /dev/sdb: 2000399MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start      End        Size       File system  Name  Flags
 1      1.05MB     1656331MB  1656330MB  xfs          bup
 2      1656331MB  1656831MB  500MB      fat32

(parted) <strong>q</strong>
</pre>

<p>The <em>partition</em> name is<a data-type="indexterm" data-primary="parted command" data-secondary="filesystems" data-tertiary="creating FAT16/FAT32" data-startref="parted-fat16fat32" id="idm46466157686696"/><a data-type="indexterm" data-primary="mkpart command" data-startref="mkpart" id="idm46466157685368"/> optional; in the example it is left empty. Now create a nice new
FAT32 filesystem:</p>
<pre>$ <strong>sudo mkfs.fat -F 32 -n fat32test /dev/sdb2</strong>
mkfs.fat 4.1 (2017-01-24)
mkfs.fat: warning - lowercase labels might not work properly with DOS or Windows</pre>

<p>Verify with <em>lsblk</em>:</p>
<pre>$ <strong>lsblk  -f /dev/sdb</strong>
NAME   FSTYPE LABEL       UUID                          FSAVAIL FSUSE% MOUNTPOINT
sdb
├─sdb1 xfs    xfstest     1d742b2d-a621-4454-b4d3-469216a6f01e
└─sdb2 vfat   fat32test   AB39-1808
</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157699800">
<h2>Discussion</h2>

<p>If you want a FAT16 filesystem, use <em>-F 16</em>.</p>

<p>FAT16 files and filesystems max out at 4 GB.</p>

<p>FAT32 supports a maximum file size of 4 GB, and a maximum partition size of 16 TB,
using 4 KB sectors <a data-type="indexterm" data-primary="filesystems" data-secondary="FAT16, creating" data-startref="filesystem-fat16-create" id="idm46466157678648"/><a data-type="indexterm" data-primary="filesystems" data-secondary="FAT32, creating" data-startref="filesystem-fat32-create" id="idm46466157676344"/><a data-type="indexterm" data-primary="FAT16 filesystems" data-secondary="creating" data-startref="fat16-create" id="idm46466157675704"/><a data-type="indexterm" data-primary="FAT32 filesystems" data-secondary="creating" data-startref="fat32-create" id="idm46466157675064"/>and 64 KB clusters.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157674072">
<h2>See Also</h2>

<ul>
<li>
<p><a data-type="xref" href="ch08.xhtml#cha-partitioning-parted">Chapter 8</a></p>
</li>
<li>
<p><a data-type="xref" href="ch09.xhtml#cha-partitioning-gparted">Chapter 9</a></p>
</li>
<li>
<p><em>man 8 mkfs.fat</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="11.16 Creating a Btrfs Filesystem"><div class="sect1" id="idm46466157707752">
<h1>11.16 Creating a Btrfs Filesystem</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157667144">
<h2>Problem</h2>

<p>Btrfs <a data-type="indexterm" data-primary="filesystems" data-secondary="Btrfs, creating" id="filesystem-btrfs-create"/><a data-type="indexterm" data-primary="Btrfs filesystems" id="btrfs-create"/><a data-type="indexterm" data-primary="openSUSE" data-secondary="creating Btrfs filesystem" id="opensuse-btrfs-create"/>sounds cool, and you want to try it out.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157662776">
<h2>Solution</h2>

<p>It is cool, and it is also complex. SUSE Linux Enterprise Server (SLES) and openSUSE are
the best Linux distributions to try Btrfs on. SLES and openSUSE are the biggest Btrfs
supporters and developers, and they created the excellent Snapper tool for managing
Btrfs snapshots. They also provide the most thorough documentation. The default
partitioning on an openSUSE/SLES sets up Btrfs subvolumes and automatic snapshots.</p>

<p>Start by downloading the latest openSUSE Tumbleweed. Launch the installer, and
when you get to the Suggested Partitioning screen, take a look at the installer’s
first proposal (<a data-type="xref" href="#fig-btrfs-1">Figure 11-2</a>).</p>

<figure class="width-85"><div id="fig-btrfs-1" class="figure">
<img src="Images/lcb2_1102.png" alt="openSUSE first partitioning proposal" width="761" height="572"/>
<h6><span class="label">Figure 11-2. </span>openSUSE first partitioning proposal</h6>
</div></figure>

<p>Click Guided Setup to modify this proposal. Skip past the “Enable logical volume
management (LVM) / Enable disk encryption” screen, and stop at the Filesystem
Options screen. Select “Propose Separate Home Partition,” and format it as Btrfs.
Check both boxes for “Propose Separate Swap Partition,” then click Next (<a data-type="xref" href="#fig-btrfs-2">Figure 11-3</a>).</p>

<figure><div id="fig-btrfs-2" class="figure">
<img src="Images/lcb2_1103.png" alt="Create home partition" width="258" height="309"/>
<h6><span class="label">Figure 11-3. </span>Create a home partition</h6>
</div></figure>

<p>This returns you to the Suggested Partitioning screen. If you wish to adjust partition sizes,
click Expert Partitioner → Start with Current Proposal (<a data-type="xref" href="#fig-btrfs-4">Figure 11-4</a>). Otherwise click Next and
continue with the installation.</p>

<figure class="width-85"><div id="fig-btrfs-4" class="figure">
<img src="Images/lcb2_1104.png" alt="Custom partitioning, using current proposal" width="768" height="590"/>
<h6><span class="label">Figure 11-4. </span>Custom partitioning, using current proposal</h6>
</div></figure>

<p>When you are finished, you will have a ready-to-use Btrfs Linux system, already set up
with good defaults.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157649048">
<h2>Discussion</h2>

<p>Setting up Btrfs manually is a bit of a chore, though as you learn about it you might want
to try setting it up manually. I like to learn new things by starting with a working
implementation. It is not possible, at least for me, to provide a useful Btrfs how-to in a few
recipes. Btrfs is so flexible and so capable, it needs its own book. Which it has, thanks to
the good SUSE people. Consult the Startup Guide for installation, and the “System Recovery and Snapshot Management with Snapper” section in the <a href="https://oreil.ly/1Vi9L">openSUSE documentation</a>. Snapper + Btrfs is a great
combination for Btrfs management and fast failure <a data-type="indexterm" data-primary="filesystems" data-secondary="Btrfs, creating" data-startref="filesystem-btrfs-create" id="idm46466157645304"/><a data-type="indexterm" data-primary="Btrfs filesystems" data-startref="btrfs-create" id="idm46466157644264"/><a data-type="indexterm" data-primary="openSUSE" data-secondary="creating Btrfs filesystem" data-startref="opensuse-btrfs-create" id="idm46466157643288"/>recovery.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157646376">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://oreil.ly/1Vi9L">The openSUSE Startup and Reference Guides</a></p>
</li>
<li>
<p>The Deployment and Administration guides in the <a href="https://oreil.ly/fX5G9">SLES Product Manuals</a></p>
</li>
</ul>
</div></section>





</div></section>







</div></section></div></body></html>