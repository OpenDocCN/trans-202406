- en: Chapter 20\. Networking and Our App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow. We’ve come a long way with our app. The last chapter, dealing with databases,
    was a doozy. We’ve now got a great app for browsing through our catalog of books.
    We can *even* favorite some books for later to check them out again. That’s great!
    It’s probably time to set this app aside and start working on another project.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait! The librarian from before, our octogenarian guide and muse, ambles
    up to you from out of the shadows of wherever you’re working and lets you in on
    a secret that makes your hair stand on end: this isn’t the only library of this
    type. There are multiple locations scattered throughout the globe in different
    countries and they all must be displayed in this app to help patrons—such as yourself—unlock
    the knowledge contained within.'
  prefs: []
  type: TYPE_NORMAL
- en: Looks like we’re not done yet with this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how might we go about supporting this new feature? It’s possible we could
    use the same approach as before with our catalog: bundle the list of locations
    with the app. However, that approach seems a bit static and unchanging. What if
    a location closes and a weary traveler searches for the knowledge of mankind in
    vain? It might be best, instead, to use this as an opportunity to finally break
    down the barriers around this app and let it communicate with the outside world
    via, you guessed it, the Internet! This will allow our data to be dynamic and
    changing, just like the world around it.'
  prefs: []
  type: TYPE_NORMAL
- en: So buckle up. Let’s dial in and start searching!
  prefs: []
  type: TYPE_NORMAL
- en: Searching the World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fundamentally, interacting with a search endpoint is the same for Android as
    it is for iOS. It consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A button or search bar to initiate the search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A string of text to pass to a network service somewhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A response containing the results of our query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A screen that displays our results—most likely a list or table view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we need is a way to initiate the search in the UI. On Android,
    since again we’ve omitted the `ActionBar` for our `Activities`, we’ll add an AOSP-provided
    component called `SearchView` to the top of the `BrowseContentActivity` UI. When
    a string is entered and actionable (button press, Enter key, IME action), we’ll
    pass that value to a web service, which will open the returns in a new `Activity`
    when it returns successfully and complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s modify the layout of *res/layout/activity_browse.xml* to include
    a `SearchView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s wire up some basic functionality in our existing `Activity`:'
  prefs: []
  type: TYPE_NORMAL
- en: Add new search activity to manifest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show search activity and layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update this log statement to call the search method in the local project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix emoji.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Meanwhile, on iOS, we’ll add a search button to the top of the catalog screen.
    That will display a `UISearchController` with a `UISearchBar` that we’ll use to
    capture the text a search user is searching for; we’ll use that for a request
    to our search endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with the UI!
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s prepare a simple layout and `Activity` to display our search results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will provide a spinner to show the user that something is happening while
    we wait for the results to arrive from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Activity` should expect a `String` extra for the query passed from the
    `SearchView`—we’ll use this to perform a fetch to the web service and manipulate
    the UI as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make some assumptions here. Let’s say our URL is *magic://my.app/search*
    (we’re going to use the scheme “magic://” so that we don’t forget the missing
    pieces—most Java HTTP clients will reject that scheme with a friendly, descriptive
    error), and it accepts a `GET` query parameter named `query`. It will return a
    JSON response that is an array of `Location` objects, or an empty array if none
    matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say the JSON looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And our data structure will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got a layout, a model, and a general strategy—what’s left is the actual
    implementation of our logic. We’ll take the deep dive in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach we’ll take on iOS is very similar, but ever so slightly different.
    On iOS, it’s common to have a button in our navigation bar to initiate the search
    process. To start, open up *Main.storyboard* and head over to the welcome scene.
    From the library, drag a bar button item onto the right side of the navigation
    bar. An outline should appear where you can drop the bar button item. Using the
    Attributes inspector, set the value for System Item to “Search.” Notice that this
    will change the button displayed on the screen from a plain button labeled “Item”
    to a button with a magnifying glass icon.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the welcome screen will function as our jump-off point. We’re going to
    segue to another view controller to handle displaying our search bar and search
    results. To facilitate this action, drag a new Table View Controller object from
    the library onto the canvas near the welcome scene. Next, in the Table View scene,
    expand the table view and select the table view cell object in the Document Outline.
    Inside the Attributes inspector on the right side of the screen, set the Reuse
    Identifier value to `LocationCell`. Then, if you’d like, in the Identity inspector
    set the Title value to “Locations” so that this title will display on this screen
    whenever it’s shown.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, head back over the welcome screen and Control-click and drag from the
    search button we placed earlier over to the new Locations scene with the Kind
    set to Show. This will wire up a segue that will present the Table View scene
    whenever we click on the magnifying glass button on the welcome screen.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the app and you’ll see the new search button at the top right
    of screen. Tap the icon and it should present a blank table view with no results
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is where our journey ends with the storyboard editor when
    it comes to searching. We’ve got one more step and that’s to create a custom class
    for the results view controller so we’re able to initiate the searching. Add a
    new Cocoa Touch Class inheriting from `UITableViewController` named `LocationsTableViewController`
    to the project by going to File > New > File in the menu bar. To switch our table
    view controller over to this class, select the Locations scene, and in the Identity
    inspector, set the value for Custom Class to “LocationsTableViewController.”
  prefs: []
  type: TYPE_NORMAL
- en: Controlling our searches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a handy class in iOS called `UISearchController` that makes updating
    the UI for searching fairly straightforward and simple. However, it’s not possible
    to utilize this class in the storyboard editor or Interface Builder. We’ll have
    to re-create it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up *LocationsTableViewController.swift*. The first thing we’re going to
    do is delete all the boilerplate code that Xcode gives us whenever we inherit
    from `UITableViewController`. Delete some of the existing methods you see so you
    end up with a view controller that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we’re going to do is instantiate and save our search controller
    to use whenever our initial view controller, `LocationsTableViewController`, loads
    its view. If you’ll recall from our discussion of the life of a view controller
    in [Chapter 2](ch02.html#topics_views), this is done by overriding the `viewDidLoad`
    method on a view controller. In this instance, we’re using a `UITableViewController`
    as our parent class; however, `UITableViewController` inherits from `UIViewController`
    so it adheres to the same set of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the body of `viewDidLoad`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new `UISearchController` object and assigns it to the variable
    `searchController`. We then set the `delegate` on the search bar to respond to
    whenever a search is done being entered by the user. We’ll adhere to that protocol
    momentarily, so let’s continue—ignoring the compiler error for now, of course.
    Next, we set some placeholder text for the search bar that’s created. In this
    instance, it’s just “Search Locations by Country,” but it could be whatever we
    desire to give users some guidance about what we’re actually searching.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines are important for the display of the search results. `UISearchController`
    is utilized to provide a consistent experience for searching in iOS. There are
    some predefined behaviors that we want to configure to make searching as best
    of an experience as possible. The first property, `obscuresBackgroundDuringPresentation`,
    prevents the search controller from dimming the current view controller we’re
    in to display the search results. This is important because when we initialize
    our search controller, we’re not providing a new `searchResultsViewController`
    directly, so our search results are going to display in this view controller.
    If this view controller is dimmed, the experience might seem a bit off for users.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we also need to make sure that `definesPresentationContext`
    is set to `true` so that when the `UISearchController` displays its results view,
    the view controller we’re in is the one that provides the context of the results
    display and the search bar display. It basically means this view controller will
    prevent the search bar from remaining on-screen if we navigate to another view.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do is set the `searchController` we just created as the search
    controller for the navigation item. This allows the parent navigation controller
    that controls this view to display the search bar inside its navigation bar (among
    other things). We also set a property called `hidesSearchBarWhenScrolling` that
    keeps the search bar visible at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make our view controller adhere to `UISearchBarDelegate`. This
    is the protocol necessary to update the table view that’s displaying the search
    results. Whenever the Search button is tapped on the keyboard (or the Return key
    hit), this method is called. A simple, but temporarily incomplete, version of
    this method could be added as an extension onto `LocationsTableViewController`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you build and run the project, you’ll see something like this whenever you
    tap on the magnifying glass to view the location search screen.
  prefs: []
  type: TYPE_NORMAL
- en: We’re very close to populating this table view. It’s time to start communicating
    with the network!
  prefs: []
  type: TYPE_NORMAL
- en: Building a Search Endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you might have noticed this *isn’t* a book on web services, per se. This
    puts us in something of a conundrum because in order to communicate with a web
    service we need to have…a web service. There are a number of ways you can approach
    this. If you’d like, you could just follow along in the code without actually
    hitting a web service. Luckily, the app should still function just fine, there
    just won’t be any results. In a second, we’ll look at what our library locations
    JSON that the app is going to consume will look like, so you could put that somewhere
    locally and have the app consume that file.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you add a file locally, you’ll need to make sure you specify the `Content-Type`
    of the content as `application/json`. Some services, like Google Drive, have support
    for this, but this is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: A perfectly viable option, however, is to write a very quick-and-dirty node.js
    service to handle serving out the content. In fact, the authors have written such
    a service. It uses Express to make things simple. If you know anything about Node,
    it’s very easy to work with a service locally.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node and Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What follows is the quickest “get up and running” with a web service you’ll
    ever find. If you are already up to speed with Node, you can probably skip this
    part. Or, if you’re not interested in installing and working with Node, you can
    safely skip this part as well. The instructions were largely taken from the Node
    and Express websites. Let’s go!
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [*https://nodejs.org*](https://nodejs.org) and install the latest
    version of Node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up Terminal and create a directory to hold your project called *library-node-service*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Initialize a new Node project by calling `npm init` at the prompt. There will
    be a number of options, and you can safely hit Enter to go past all of them and
    use the default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command `npm install express --save` to install Express to the project.
    Express is a lightweight framework useful for writing quick-and-dirty Node services.
    Perfect for our use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named *index.js* if it doesn’t exist already and put the following
    code in that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy a version of *catalog.json* from the Xcode or Android Studio project and
    put it in the same directory as *index.js*. (Do the same with *locations.json*
    when we create it in just a moment.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the app locally, type `node index.js` from the command prompt. Your app
    should now be accessible at *[*http://localhost:3000*](http://localhost:3000)*.
    You can check this by going to *[*http://localhost:3000/catalog*](http://localhost:3000/catalog)*;
    you should see a list of all the books in our *catalog.json* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locations JSON File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re going to be using JSON again as the transport structure for the data
    we’re receiving from our web service. Here’s what our `locations.json` file should
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you might have noticed, this contains a few locations. These are just example
    locations (and not actually real) and used to illustrate the structure of our
    data. Feel free to add more locations as you see fit. It’s an opportunity to be
    a bit creative!
  prefs: []
  type: TYPE_NORMAL
- en: Calling Our Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to send a request to our service, it’s good practice in Android and
    iOS to build an object that’s responsible for handling the communication instead
    of directly dealing with API calls in our view layer. The object we’re creating
    will be called `LocationsController`, and it’ll be an intermediary between our
    search user interface and our network service. Once the object is created, we’ll
    wire everything up.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check out how this is done in Android first.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So while there are a number of services that can aid in interacting with RESTful
    web services, we’re going to again defer to standard libraries (for the most part)
    to make the network request as shown in [Chapter 9](ch09.html#topics_networking).
    Since we’re assuming the result will come back as a JSON string, we’ll once again
    fall back on the Gson library discussed in [Chapter 12](ch12.html#topics_transports).
    Since we’ve seen so much of this already in our evolving app, like deserializing
    JSON, the `RecyclerView` with `Adapter` mechanism, and passing data via `Intents`,
    let’s just jump right in. What follows is a single `Activity` with all of the
    relevant search and UI code encapsulated. If this app were to get any larger or
    need more flexibility in its feature set, you’d probably want to start separating
    out logical blocks into the appropriate classes and interfaces right away—but
    since we’ve seen almost all of this before, let’s just blast out a quick and dirty
    feature-full file and ship to our client (who’re never known for either their
    patience or their appreciation of elegant code):'
  prefs: []
  type: TYPE_NORMAL
- en: (Remember to add this `Activity` to your *AndroidManifest.xml*!)
  prefs: []
  type: TYPE_NORMAL
- en: Pretty long! So what’s going on in there? Previously, we’ve broken operations
    down line by line and explained precisely what each statement or expression was
    intended to do. As we mature as developers, let’s depart from that a bit—we’ll
    do our best to explain what’s happening here like we would to an experienced colleague,
    one who may be about to review the code or run some QA, or even just catch up
    with the feature for potential extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we’ have an `Activity`, so a dedicated screenful of information.
    The `Activity` expects a `String` to be passed to it immediately, representing
    a search query, that it got from the `SearchView` in the `BrowseContentActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Activity`’s layout initially shows a `ProgressBar` spinning in the center
    of the screen to show we’re doing work in the background. The `RecyclerView` is
    not rendered until we’ve successfully fetched content.
  prefs: []
  type: TYPE_NORMAL
- en: During the creation cycle, we’ll take that search term and append it to the
    known URL of our search web service. We’ll use standard library classes like `URL`
    and `HttpConnection` to get the server’s response as bytes and read them into
    a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make sure we do that in a background `Thread` so we don’t block the UI
    while the network request is happening; we’ve all seen even simple responses sometimes
    take several seconds (or more) to resolve—it’s not good if our UI is frozen that
    whole time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know we’re dealing with a traditional RESTful JSON response, we’ll
    use Gson to parse it into what we expect: a collection of `Location` objects.
    Assuming that’s successful, let’s hide the `ProgressBar` and show the `RecyclerView`
    and then pass those `Location` instances to a custom `Adapter` and attach it.
    If there’s a failure in the network call, or the deserialization operation, we’re
    just logging out failure—in a production-ready app, you’d probably want some kind
    of UI to display to the user, report it back to you, or even retry the operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our `RecyclerView` has a primed and populated `Adapter`, we should
    see a list of all the `Location` objects returned from our search, presented in
    an arbitrary `String` representing the physical location of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Even poorly designed, high line count code can be pretty straightforward if
    we know how to use the tools we’re given.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how our iOS friends handle this…
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Xcode, add a new Swift file to the project called `LocationsController`.
    If you’ll recall, our UI has one primary purpose: retrieve a list of additional
    library locations from a given country. The service we built has an endpoint that
    does just this. If you hit *http://localhost:3000/locations?country=`<country
    name>`*, you’ll see a list of filtered locations for a given country. So, we have
    a parameter, `country`, where we can pass our country name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, we might think of `LocationsController` as having one method that
    fetches the locations for a given country. We can express that with a method like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define `Location` as well. We know we’ll be working with JSON, so
    we can utilize a structure and `Codable` similar to how we did earlier for `Book`
    in our *catalog.json* file. Using our *locations.json* file as a guide, we arrive
    at a `Location` object that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note the property `streetAddress`. In our JSON, that property is named `the_address`.
    Because these don’t match, a private enum called `CodingKeys` has been created
    that provides mapping between the JSON values and the structure values. Unfortunately,
    when one property doesn’t match, you have to specify all the values being encoded
    and decoded in the JSON, so it makes `Codable` a bit more manual, but still mostly
    automatic.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, `JSONDecoder` can help you for some cases like converting
    from snake-case in the JSON to camel-case in the properties like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to use the `fetchLocations(for:)` method we just declared,
    it would work well on a fast connection, but there is a major problem that could
    hamper it as our dataset grows or as our network connection degrades: it’s synchronous
    and potentially all on the main thread. This means that if we call this from the
    main thread, we would need to sit and wait for the process to finish before anything
    else could happen; our app would be unresponsive and appear to freeze.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s not a great experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it’s pretty easy to fix using closures. A common, Swift-y pattern
    for network operations is to supply a completion handler that’s executed whenever
    the operation completes. Keeping that in mind, let’s adjust our method signature
    so that the `[Location]` array that’s returned is returned in the completion handler.
    We’ll also use an error handler to provide a closure to execute code if the operation
    was a not a success. This ends up looking like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we include our `Location` structure, we have a file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: URLSession and friends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take our `fetchLocations(for:completionHandler:errorHandler:)` method
    and define the functionality it provides. For that, we’ll delve into the `URLSession`
    library with a specific type of `URLSessionTask`—namely, `URLSessionDataTask`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways to interact with the web, but `URLSession` has broken
    up the interactions into three types with three different implementations of `URLSessionTask`—essentially,
    one network request—to make things a bit easier to use: the types of tasks are
    `URLSessionDataTask`, `URLSessionDownloadTask`, and `URLSessionUploadTask`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these are purpose-built and provide functionality unique to that purpose.
    The data task, or `URLSessionDataTask`, we’ll be using is intended to be used
    to retrieve data from a URL—in other words, our use case. For a more thorough
    look at these objects, check out [Chapter 9](ch09.html#topics_networking).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we’ll use `URLSessionDataTask` in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is create a URL to where our location search service resides.
    It’s currently at *[*http://localhost:3000/locations*](http://localhost:3000/locations)*
    if you followed along with the Node part of this chapter, but if not, then you’ll
    need to use whatever URL is relevant here. The `URL(string:)` initializer generates
    a nullable `URL`—or `URL?` type—so we are also force unwrapping that property
    with a `!` because, in this instance, we know it won’t be `nil`. (And if it is,
    we probably want to know about by having the app crash versus silently failing
    too!)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `shared` class property on `URLSession` to grab the shared
    session. The session itself generates our `URLSessionDataTask` through the `dataTask(with:completionHandler:)`
    method; we are never creating and instantiating `URLSessionDataTask` directly.
    This task is saved to the `task` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completion handler passed has three parameters: `data`, `response`, and
    `error`. The `data` parameter is an object of type `Any?` that contains the data
    retrieved by the response. The `response` parameter contains the raw `URLResponse`
    received, and the `error` property is an `Error?` object used to validate the
    success or failure of the response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, adding this to our `fetchLocations(for:completionHandler:errorHandler)`
    method would call our service, but because the body of the completion closure
    passed in is empty, nothing would happen. Let’s fix that. Here’s what the entire
    body of our method should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the body of `dataTask(with:completionHandler:)` we’re passing in a trailing
    closure that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks for a server error via the `error` parameter that was passed into
    the method. If an error occurred, we call the `errorHandler` closure that was
    passed in and then `return`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is good server side (i.e., `error` is `nil`), then we proceed
    to check to make sure our response was a valid HTTP status code, which is anything
    less than `300`. If the response isn’t valid, we also call `errorHandler`, but
    there is no server error to pass along, so we just pass `nil`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we’re good server side and client side with errors, we check the data returned.
    The `data` object shouldn’t be empty, and we’re expecting a `Data` object that
    we’re going to use, momentarily, to decode. If the data is empty, we call `errorHandler`,
    yet again, with a `nil` error so we can execute our error-handling code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s wrap up this object by taking our `data` object and decoding it from
    raw JSON into an array of `Location`s. After adding this, we end up with the following
    code in our *LocationsController.swift* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All right. We’ve got a working network client we can use to search for locations.
    We’re *almost* done, but the final missing piece of this is that we need to add
    it to the original UI we created. Let’s head back over to `LocationsTableViewController`
    and add the following to our `UISearchBarDelegate` method, `searchBarTextDidEndEditing(_:)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through this code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we grab the `country` we’re searching for from the search bar’s `text`
    property. This is a `String` type, so it could be `nil`; we fix this with the
    `??` operator that means “if the thing preceding this operator is `nil`, use the
    thing after this operator as the value.” In our case, we set it to an empty string.
    After that, we call `fetchLocations` on a new property we’ve added to the class
    that holds the `LocationsController` we just created. We pass in a `completionHandler`
    and an `errorHandler` closure that set a local property that contains the locations
    returned and reloads the table view contained in this view.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we dispatch to the main thread in order to update the table view
    from our closure. We don’t know what thread this call is coming from, and any
    UI updates *must* be done on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve got one more thing to adjust in this class before we’re ready to test
    it out. We need to make our table view get its data from the `locations` array
    that we’re storing in the class now. Luckily, if you’ll recall, this class is
    the table view’s `dataSource` so it’s as easy as updating the `UITableViewDataSource`
    protocol method definitions to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The full `LocationsViewController` class looks like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application, click the magnifying glass, and search for a
    country and you’ll get…nothing. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, if you look at the console, you’ll notice the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is Apple’s security practices request an *https://* URL
    and we’re using an *http://* URL. The fix for this is easy and, in fact, is mentioned
    in the error message. You’ll need to add an exception to your app’s *Info.plist*
    file. This file is where application-level configurable values go.
  prefs: []
  type: TYPE_NORMAL
- en: To add the exception to your domain, go to *Info.plist* and in the last row
    of data displayed, click the “+” button to add a new property. From the drop-down,
    select App Transport Security Settings. Then, add a new child property for Allow
    Arbitrary Loads and set its value from NO to YES. This makes it so that any nonsecure
    URL can be used by the app. If you build and run the app now and search for “France,”
    you should see [Figure 20-1](#france) in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vive lé Simulator!](assets/nmdv_2001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-1\. Vive lé Simulator!
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Look out! You made your app less secure by allowing arbitrary loads. In the
    interests of this example, we’re using this technique. Really, you should be using
    an HTTPS URL to communicate with your service. Don’t deploy an app in the wild
    with this enabled unless you know what you’re doing. Another available option
    is to set `NSAllowsLocalNetworking` to `YES` in your app’s *Info.plist* instead,
    which allows local file loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you submit an app with Allow Arbitrary Loads enabled, be prepared: you’ll
    have to justify that decision during App Review!'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing we can do to make it apparent a network call is happening.
    We can add calls to `UIApplication.shared.isNetworkActivityIndicatorVisible` to
    make the network activity indicator in the status bar active and inactive whenever
    a call is happening. We can do this before we start the `URLSessionDataTask` we
    created in our `LocationsController` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can set `UIApplication.shared.isNetworkActivityIndicatorVisible` to
    `false` inside the completion handler whenever it completes.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all we’ll cover on networking for now with iOS.
  prefs: []
  type: TYPE_NORMAL
- en: What We’ve Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve seen how to talk to the internet in both Android and iOS. There are similarities,
    but each operating also has its own unique way of handling communication with
    a web service. There are a lot of moving parts, but we’ve seen how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new screen that handles searching
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a network client to communicate with an API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire up a search UI with the network client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a lot more functionality contained inside Android and iOS, and we’ve
    just scratched the surface. Check out [Chapter 9](ch09.html#topics_networking)
    for more detail and examples of how to add networking to your app.
  prefs: []
  type: TYPE_NORMAL
