<html><head></head><body><section data-pdf-bookmark="Chapter 10. eBPF Programming" data-type="chapter" epub:type="chapter"><div class="chapter" id="ebpf_programming">&#13;
<h1><span class="label">Chapter 10. </span>eBPF Programming</h1>&#13;
<p><a contenteditable="false" data-primary="programming, eBPF" data-type="indexterm" id="ch10.html0"/>In this book so far, you’ve learned a lot about eBPF and seen many examples of how it’s used for a variety of applications. But what if you want to implement your own ideas based on eBPF? This chapter discusses your options when it comes to writing your own eBPF code.</p>&#13;
<p>As you know from reading this book, eBPF programming consists of two parts:</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p>Writing eBPF programs that run in the kernel</p></li>&#13;
<li><p>Writing the user space code that manages and interacts with eBPF programs</p></li>&#13;
</ul>&#13;
<p>Most of the libraries and languages I’ll discuss in this chapter require you as a programmer to handle both parts, with an awareness of what is being handled where. But <code>bpftrace</code>, perhaps the simplest eBPF programming language, masks this distinction from the programmer.</p>&#13;
<section data-pdf-bookmark="Bpftrace" data-type="sect1"><div class="sect1" id="bpftrace">&#13;
<h1>Bpftrace</h1>&#13;
<p><a contenteditable="false" data-primary="bpftrace" data-type="indexterm" id="ch10.html1"/><a contenteditable="false" data-primary="programming, eBPF" data-secondary="bpftrace" data-type="indexterm" id="ch10.html2"/>As described on the project’s <em>README</em> page, “<code>bpftrace</code> is a high-level tracing language for Linux eBPF … inspired by awk and C, and predecessor tracers such as DTrace and SystemTap.”</p>&#13;
<p>The <a href="https://oreil.ly/BZNZO"><code>bpftrace</code></a> command-line tool converts programs written in this high-level language into eBPF kernel code and provides some output formatting for the results within the terminal. As a user, you don’t really need to think about the kernel–user space split.</p>&#13;
<p>You’ll find several examples of useful one-liners in the project documentation, including a nice <a href="https://oreil.ly/Ah2QB">tutorial</a> that takes you from writing a simple “Hello World” script up to writing more sophisticated scripts that can trace out data read from within kernel data structures.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Get a feel for the range of capabilities that <code>bpftrace</code> provides from Brendan Gregg’s <a href="https://oreil.ly/VBwLm"><code>bpftrace</code> cheat sheet</a>. Or, for in-depth coverage of both <code>bpftrace</code> and BCC, see his book <a href="https://oreil.ly/kjc95"><em>BPF Performance Tools</em></a>.</p>&#13;
</div>&#13;
<p>As its name suggests, <code>bpftrace</code> can attach to tracing (also known as perf-related) events, including kprobes, uprobes, and tracepoints. For example, you can list the available tracepoints and kprobes on a machine with the <code>-l</code> option, like this:</p>&#13;
<pre data-type="programlisting">$ bpftrace -l "*execve*"&#13;
tracepoint:syscalls:sys_enter_execve&#13;
tracepoint:syscalls:sys_exit_execve&#13;
...&#13;
kprobe:do_execve_file&#13;
kprobe:do_execve&#13;
kprobe:__ia32_sys_execve&#13;
kprobe:__x64_sys_execve&#13;
...</pre>&#13;
<p>This example finds all the available attachment points that contain “execve.” From this output you can see that it’s possible to attach to a kprobe called <code>do_execve</code>. Here’s a <code>bpftrace</code> one-line script that attaches to that event:</p>&#13;
<pre data-type="programlisting">bpftrace -e 'kprobe:do_execve { @[comm] = count(); }'&#13;
Attaching 1 probe...&#13;
^C&#13;
&#13;
@[node]: 6&#13;
@[sh]: 6&#13;
@[cpuUsage.sh]: 18</pre>&#13;
<p>The <code>{ @[comm] = count(); }</code> part is the script attached to that event. This example keeps track of the number of times the event was triggered by different executables.</p>&#13;
<p>Scripts for <code>bpftrace</code> can coordinate multiple eBPF programs attached to different events. For example, consider the <a href="https://oreil.ly/3HWZ2"><em>opensnoop.bt</em> script</a> that reports on files being opened. Here is an extract:</p>&#13;
<pre data-type="programlisting">tracepoint:syscalls:sys_enter_open,&#13;
tracepoint:syscalls:sys_enter_openat&#13;
{&#13;
    @filename[tid] = args-&gt;filename;&#13;
}&#13;
&#13;
tracepoint:syscalls:sys_exit_open,&#13;
tracepoint:syscalls:sys_exit_openat&#13;
/@filename[tid]/&#13;
{&#13;
    $ret = args-&gt;ret;&#13;
    $fd = $ret &gt; 0 ? $ret : -1;&#13;
    $errno = $ret &gt; 0 ? 0 : - $ret;&#13;
&#13;
    printf("%-6d %-16s %4d %3d %s\n", pid, comm, $fd, $errno,&#13;
        str(@filename[tid]));&#13;
    delete(@filename[tid]);&#13;
}</pre>&#13;
<p>This script defines two different eBPF programs, each attached to two different kernel tracepoints, at the entry to and exit from the <code>open()</code> and <code>openat()</code> syscalls.<sup><a data-type="noteref" href="ch10.html#ch10fn1" id="ch10fn1-marker">1</a></sup> Both of these syscalls are used to open files and take a filename as an input argument. The program triggered by either flavor of syscall entry caches that filename, storing it in a map where the key is the current thread ID. When the exit tracepoint is hit, the cached filename is retrieved from this map by the <code>/@filename[tid]/</code> line in the script.</p>&#13;
<p>Running this script generates output like this:</p>&#13;
<pre data-type="programlisting">./opensnoop.bt &#13;
Attaching 6 probes...&#13;
Tracing open syscalls... Hit Ctrl-C to end.&#13;
PID    COMM               FD ERR PATH&#13;
297388 node               30   0 /home/liz/.vscode-server/data/User/&#13;
                                 workspaceStorage/73ace3ed015&#13;
297360 node               23   0 /proc/307224/cmdline&#13;
297360 node               23   0 /proc/305897/cmdline&#13;
297360 node               23   0 /proc/307224/cmdline</pre>&#13;
<p>I’ve just told you there are four eBPF programs attached to tracepoints, so why does this output say there are six probes? The answer is that there are two “special probes” for the <code>BEGIN</code> and <code>END</code> clauses that the full version of this program includes to initialize and clean up the script (very similar to the awk language). I’ve omitted those clauses here for brevity, but you can find them in the <a href="https://oreil.ly/X8wgW">source code in GitHub</a>.</p>&#13;
<p>If you’re using <code>bpftrace</code>, you don’t need to know about the underlying programs and maps, but for those of you who have read earlier chapters of this book, those concepts should be familiar to you by now. If you’re interested to see the programs and maps that are loaded in the kernel while a <code>bpftrace</code> program is running, you can easily do this with <code>bpftool</code> (just as you saw in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>). Here’s the output I got while running <em>opensnoop.bt</em>:</p>&#13;
<pre data-type="programlisting">$ bpftool prog list &#13;
...&#13;
494: tracepoint  name sys_enter_open  tag 6f08c3c150c4ce6e  gpl&#13;
        loaded_at 2022-11-18T12:44:05+0000  uid 0&#13;
        xlated 128B  jited 93B  memlock 4096B  map_ids 254&#13;
495: tracepoint  name sys_enter_opena  tag 26c093d1d907ce74  gpl&#13;
        loaded_at 2022-11-18T12:44:05+0000  uid 0&#13;
        xlated 128B  jited 93B  memlock 4096B  map_ids 254&#13;
496: tracepoint  name sys_exit_open  tag 0484b911472301f7  gpl&#13;
        loaded_at 2022-11-18T12:44:05+0000  uid 0&#13;
        xlated 936B  jited 565B  memlock 4096B  map_ids 254,255&#13;
497: tracepoint  name sys_exit_openat  tag 0484b911472301f7  gpl&#13;
        loaded_at 2022-11-18T12:44:05+0000  uid 0&#13;
        xlated 936B  jited 565B  memlock 4096B  map_ids 254,255&#13;
&#13;
$ bpftool map list &#13;
254: hash  flags 0x0&#13;
        key 8B  value 8B  max_entries 4096  memlock 331776B&#13;
255: perf_event_array  name printf  flags 0x0&#13;
        key 4B  value 4B  max_entries 2  memlock 4096B</pre>&#13;
<p>You can clearly see the four tracepoint programs, plus the hash map that’s used for caching the filenames and the <code>perf_event_array</code> that is being used to pass output data from kernel to user space.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <code>bpftrace</code> utility is built on top of BCC, which you met elsewhere in this book and which I’ll cover later in this chapter. <code>bpftrace</code> scripts get converted into BCC programs, which are then compiled at runtime using the LLVM/Clang toolchain.</p>&#13;
</div>&#13;
<p>If you want command-line tools for eBPF-based performance measurement, you may well find that your needs are met using <a href="https://oreil.ly/u5FrJ"><code>bpftrace</code></a>. But although <code>bpftrace</code> can be a powerful tool for using eBPF for tracing, it doesn’t open up the full range of possibilities that eBPF enables.</p>&#13;
<p>To unlock the full potential of eBPF, you’ll need to directly write eBPF programs yourself for the kernel and also handle the user space part. These two aspects can, and often are, written in entirely different languages. Let’s start with the choices for eBPF code that runs in the kernel.<a contenteditable="false" data-primary="" data-startref="ch10.html2" data-type="indexterm" id="idm46123191537728"/><a contenteditable="false" data-primary="" data-startref="ch10.html1" data-type="indexterm" id="idm46123191536352"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Language Choices for eBPF in the Kernel" data-type="sect1"><div class="sect1" id="language_choices_for_ebpf_in_the_kernel">&#13;
<h1>Language Choices for eBPF in the Kernel</h1>&#13;
<p><a contenteditable="false" data-primary="programming, eBPF" data-secondary="language choices for eBPF in the kernel" data-type="indexterm" id="idm46123191533776"/>eBPF programs can be written directly in eBPF bytecode,<sup><a data-type="noteref" href="ch10.html#ch10fn2" id="ch10fn2-marker">2</a></sup> but in practice, most are compiled to bytecode from either C or Rust. These languages have compilers that support eBPF bytecode as a target output.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>eBPF bytecode isn’t a suitable target for all compiled languages. If the language involves a runtime component (like Go, or Java’s virtual machine), it’s likely to be incompatible with eBPF’s verifier. For example, it’s hard to imagine how memory garbage collection could work hand in hand with the verifier’s checks on safe use of memory. Similarly, eBPF programs are required to be single threaded, so any concurrency features in a language couldn’t be used.</p>&#13;
</div>&#13;
<p>Although not really eBPF, there is an interesting project called <a href="https://oreil.ly/7_3Fx">XDPLua</a> that proposes writing XDP programs in Lua scripts that run directly within the kernel. However, the initial research in this project suggested that eBPF would likely be more performant, and as eBPF becomes more powerful with each kernel release (e.g., now being able to implement loops), it’s not clear that there is much advantage other than the personal preference that some people might have to write code in Lua scripts.</p>&#13;
<p>I would hazard a guess that most people who choose to write eBPF kernel code in Rust would also opt for the same language for the user space code, since shared data structures wouldn’t need to be rewritten. It’s not obligatory, though—you can mix and match eBPF code with whatever user space language you choose.</p>&#13;
<p><a contenteditable="false" data-primary="C (language)" data-secondary="kernel-side code in" data-type="indexterm" id="idm46123191527232"/>Those who choose to write the kernel-side code in C also have the option to write user space code in C (you’ve seen plenty of examples of that in this book already). But C is a pretty low-level language that requires programmers to handle lots of details for themselves, notably, memory management. While some people are comfortable doing this, many people would prefer to write the user space code in another, higher-level language. Whatever your preferred language, you’d like a library that provides eBPF support so that you don’t have to write directly to the system call interface you saw in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>. In the rest of this chapter we’ll discuss some of the most popular options for eBPF libraries in a variety of languages.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BCC Python/Lua/C++" data-type="sect1"><div class="sect1" id="bcc_pythonsolidusluasoliduscplusplus">&#13;
<h1>BCC Python/Lua/C++</h1>&#13;
<p><a contenteditable="false" data-primary="BCC framework" data-secondary="Python/Lua/C++" data-type="indexterm" id="ch10.html3"/><a contenteditable="false" data-primary="programming, eBPF" data-secondary="BCC Python/Lua/C++" data-type="indexterm" id="ch10.html4"/><a contenteditable="false" data-primary="Python BCC tools" data-type="indexterm" id="ch10.html5"/>Back in <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>, the first “Hello World” example I gave you was a Python program written using the BCC library. This project includes plenty of useful performance measurement tools implemented using this same library (as well as newer implementations based on <em>libbpf</em> that I’ll come to momentarily).</p>&#13;
<p>In addition to the <a href="https://oreil.ly/Elggv">documentation</a> that describes how to use the provided BCC tools to measure performance, BCC also includes a <a href="https://oreil.ly/WgeJA">reference guide</a> and a <a href="https://oreil.ly/hR3xr">Python programming tutorial</a> to help you develop your own eBPF tools in this framework.</p>&#13;
<p><a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a> included a discussion of BCC’s approach to portability, which is to compile the eBPF code at runtime to ensure that it’s compatible with the target machine’s kernel data structures. In BCC, you define the kernel-side eBPF program code as a string (or the contents of a file that BCC reads into a string). This string gets passed to Clang for compilation, but before that happens, BCC does some preprocessing on the string. This enables it to provide handy shortcuts for the programmer, some of which you’ve seen already in this book. For example, here are some relevant lines from the example code in <em>chapter2/hello_map.py</em>:</p>&#13;
<pre data-code-language="python" data-type="programlisting"><code class="ch">#!/usr/bin/python3                                </code><a class="co" href="#list_id_10_1" id="code_id_10_1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="kn">from</code><code> </code><code class="nn">bcc</code><code> </code><code class="kn">import</code><code> </code><code class="n">BPF</code><code>&#13;
</code><code>&#13;
</code><code class="n">program</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">                                     </code><a class="co" href="#list_id_10_2" id="code_id_10_2"><img alt="2" src="assets/2.png"/></a><code class="s2">&#13;
</code><code class="s2">BPF_RINGBUF_OUTPUT(output, 1);                    </code><a class="co" href="#list_id_10_3" id="code_id_10_3"><img alt="3" src="assets/3.png"/></a><code class="s2"> </code><code class="s2">&#13;
</code><code class="s2">...</code><code class="s2">&#13;
</code><code class="s2">int hello(void *ctx) </code><code class="s2">{</code><code class="s2">&#13;
</code><code class="s2">  ...</code><code class="s2">&#13;
</code><code class="s2">   output.ringbuf_output(&amp;data, sizeof(data), 0); </code><a class="co" href="#list_id_10_4" id="code_id_10_4"><img alt="4" src="assets/4.png"/></a><code class="s2">&#13;
</code><code class="s2"> </code><code class="s2">&#13;
</code><code class="s2">   return 0;</code><code class="s2">&#13;
</code><code class="s2">}</code><code class="s2">&#13;
</code><code class="s2">"""</code><code>&#13;
</code><code>&#13;
</code><code class="n">b</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code class="o">=</code><code class="n">program</code><code class="p">)</code><code>                             </code><a class="co" href="#list_id_10_5" id="code_id_10_5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>&#13;
</code><code> </code><code>&#13;
</code><code class="n">b</code><code class="p">[</code><code class="s2">"</code><code class="s2">output</code><code class="s2">"</code><code class="p">]</code><code class="o">.</code><code class="n">open_ring_buffer</code><code class="p">(</code><code class="n">print_event</code><code class="p">)</code><code>         </code><a class="co" href="#list_id_10_6" id="code_id_10_6"><img alt="6" src="assets/6.png"/></a><code>&#13;
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_10_1" id="list_id_10_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>This is a Python program, which will run in user space.</dd>&#13;
<dt><a class="co" href="#code_id_10_2" id="list_id_10_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>The <code>program</code> string holds the eBPF program to be compiled and then loaded into the kernel.</dd>&#13;
<dt><a class="co" href="#code_id_10_3" id="list_id_10_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><code>BPF_RINGBUF_OUTPUT</code> is a BCC macro that defines a ring buffer called <code>output</code>. This is part of the <code>program</code> string, so it’s natural to assume it’s defining the buffer from the kernel’s perspective. Hold that thought until we get to callout 6.</dd>&#13;
<dt><a class="co" href="#code_id_10_4" id="list_id_10_4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>This line looks like a <code>ringbuf_output()</code> method on an object called <code>object</code>. But wait a minute—methods on objects aren’t even part of the C language! BCC is doing some heavy lifting here, <a href="https://oreil.ly/vLVth">expanding methods</a> like these into underlying BPF helper functions, <code>bpf_ringbuf_output()</code> in this case.</dd>&#13;
<dt><a class="co" href="#code_id_10_5" id="list_id_10_5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd>This is where the program string gets rewritten into the BPF C code that Clang can compile. This line also loads the resultant program into the kernel.</dd>&#13;
<dt><a class="co" href="#code_id_10_6" id="list_id_10_6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd>There is no other place in the code that defines the ring buffer called <code>output</code>, and yet it’s accessible from the Python user space code here. BCC does double duty when it preprocesses the line in callout 3, as it defines the ring buffer for both the user space and kernel parts.</dd>&#13;
</dl>&#13;
<p>As this example shows, BCC essentially provides its own C-like language for BPF programming. It makes life easy for the programmer, handling things like shared structure definitions for both kernel and user space and providing convenient shortcuts to wrap around BPF helper functions. This means BCC is an accessible way to get into eBPF programming if you’re new to the field, especially if you’re already comfortable with Python.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’d like to explore BCC programming, this <a href="https://oreil.ly/0pHKY">tutorial aimed at Python programmers</a> is a great way to walk through many more of the features and capabilities of BCC than there is space for in this book.</p>&#13;
</div>&#13;
<p>The documentation doesn’t make it terribly clear, but as well as supporting Python as the language for the user space part of eBPF tools, <a contenteditable="false" data-primary="C++, BCC tools in" data-type="indexterm" id="idm46123191378768"/><a contenteditable="false" data-primary="Lua, BCC tools in" data-type="indexterm" id="idm46123191377664"/>BCC enables writing tools in Lua and C++. There are <em>lua</em> and <em>cpp</em> directories within the supplied <a href="https://oreil.ly/PP0cL">examples</a> that you can base your own code on, should you be keen to try this approach.</p>&#13;
<p>BCC may be convenient for the programmer, but because of the inefficiencies of distributing a compiler toolchain alongside your utility (discussed in more depth in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>), if you’re looking to write production-quality tools that you intend to distribute, I recommend considering some of the other libraries discussed in this <span class="keep-together">chapter</span>.<a contenteditable="false" data-primary="" data-startref="ch10.html5" data-type="indexterm" id="idm46123191372816"/><a contenteditable="false" data-primary="" data-startref="ch10.html4" data-type="indexterm" id="idm46123191371408"/><a contenteditable="false" data-primary="" data-startref="ch10.html3" data-type="indexterm" id="idm46123191370032"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="C and Libbpf" data-type="sect1"><div class="sect1" id="c_and_libbpf">&#13;
<h1>C and Libbpf</h1>&#13;
<p><a contenteditable="false" data-primary="C (language)" data-secondary="eBPF programming in" data-type="indexterm" id="ch10.html6"/><a contenteditable="false" data-primary="libbpf" data-secondary="eBPF programming and" data-type="indexterm" id="ch10.html7"/><a contenteditable="false" data-primary="programming, eBPF" data-secondary="C and libbpf" data-type="indexterm" id="ch10.html8"/>You’ve seen lots of examples in this book of eBPF programs written in C, using the LLVM toolchain to compile into eBPF bytecode. You’ve also seen that extensions were added to support BTF and CO-RE. Many C programmers will also be familiar with the other major C compiler, GCC, and will be happy to hear that <a href="https://oreil.ly/XAzxP">GCC from version 10</a> also supports compiling to eBPF as a target; however, there are still some gaps compared with the functionality provided in LLVM.</p>&#13;
<p>As you saw in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, CO-RE and <em>libbpf</em> enabled an approach to portable eBPF programming that doesn’t require shipping a compiler toolchain alongside every eBPF tool. The BCC project took advantage of this and, in addition to the original set of BCC performance tracing tools, it now has versions of these tools rewritten to take advantage of <em>libbpf</em>. The general consensus is that the versions of the BCC tools that have been rewritten based on <em>libbpf</em> are the better option to use, since they have a significantly lower memory footprint<sup><a data-type="noteref" href="ch10.html#ch10fn3" id="ch10fn3-marker">3</a></sup> and don’t involve a start-up delay while the compilation step takes place.</p>&#13;
<p>If you’re comfortable with programming in C, using <em>libbpf</em> can make a lot of sense. You’ve seen lots of examples of this already in this book.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To write your own <em>libbpf</em> programs in C, the best place to start (now that you have read this book!) is <a href="https://oreil.ly/4mx81"><em>libbpf-bootstrap</em></a>. Read Andrii Nakryiko’s <a href="https://oreil.ly/-OW8v">blog post about it</a> as a good introduction to the motivations behind this project.</p>&#13;
</div>&#13;
<p>There’s also a library called <a href="https://oreil.ly/374mL"><em>libxdp</em></a> that builds on <em>libbpf</em> to allow for easier development and management of XDP programs. This is part of xdp-tools, which also holds one of my favorite learning resources for eBPF programming: the <a href="https://oreil.ly/E6dvl">XDP Tutorial</a>.<sup><a data-type="noteref" href="ch10.html#ch10fn4" id="ch10fn4-marker">4</a></sup></p>&#13;
<p>But C is quite a challenging, low-level language. C programmers have to take responsibility for things like memory management and buffer handling, and it’s very easy to end up writing code with security vulnerabilities, not to mention crashes due to mishandling pointers. The eBPF verifier helps out on the kernel side, but there is no equivalent protection for your user space code.</p>&#13;
<p>The good news is that there are libraries for other programming languages that interface to <em>libbpf</em>, or provide similar relocation functionality to allow for portable eBPF programs. Here are a few of the most popular ones.</p>&#13;
<section data-pdf-bookmark="Go" data-type="sect2"><div class="sect2" id="go">&#13;
<h2>Go</h2>&#13;
<p><a contenteditable="false" data-primary="Go" data-type="indexterm" id="idm46123191344000"/><a contenteditable="false" data-primary="programming, eBPF" data-secondary="Go" data-type="indexterm" id="idm46123191342896"/>The Go language has been widely adopted for infrastructure and cloud native tooling, so it’s natural that there should be options for writing eBPF code in it.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a href="https://oreil.ly/s9umt">This article by Michael Kashin</a> provides another perspective comparing different eBPF libraries for Go.</p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Gobpf" data-type="sect2"><div class="sect2" id="gobpf">&#13;
<h2>Gobpf</h2>&#13;
<p><a contenteditable="false" data-primary="gobpf" data-type="indexterm" id="idm46123191337952"/>Possibly the first serious Golang implementation was the <a href="https://oreil.ly/pC0dF">gobpf</a> project that sits alongside BCC as part of Iovisor. However, it hasn’t been actively maintained for a while, and as I write this, there’s some <a href="https://oreil.ly/MnE79">discussion of deprecating it</a>, so bear this in mind when making your library choice.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Ebpf-go" data-type="sect2"><div class="sect2" id="ebpf_go">&#13;
<h2>Ebpf-go</h2>&#13;
<p><a contenteditable="false" data-primary="Cilium" data-secondary="ebpf-go library" data-type="indexterm" id="ch10.html9"/><a contenteditable="false" data-primary="ebpf-go" data-type="indexterm" id="ch10.html10"/><a contenteditable="false" data-primary="libbpf" data-secondary="ebpf-go" data-type="indexterm" id="ch10.html11"/>The <a href="https://oreil.ly/BnGyl">eBPF Go library included as part of the Cilium project</a> is widely used (I found around 10,000 references on GitHub, and the project has close to 4,000 stars). It provides convenient functions for managing and loading eBPF programs and maps, including CO-RE support, all implemented purely in Go.</p>&#13;
<p>With this library you have the option to compile your eBPF programs to bytecode and embed that bytecode into Go source code, using a supplied tool called <a href="https://oreil.ly/-kDbH">bpf2go</a>. You need the LLVM/Clang compiler to do this generation as part of the build step. Once the Go code is compiled, you have a single Go binary that you can distribute that includes the eBPF bytecode and is portable to different kernels, without any dependencies other than the Linux kernel itself.</p>&#13;
<p>The <em>cilium/ebpf</em> library also supports loading and managing eBPF programs built as standalone ELF files (like the <em>*.bpf.o</em> examples you have seen in this book).</p>&#13;
<p>At the time of this writing, the <em>cilium/ebpf</em> library supports the perf events for tracing, including the relatively recent fentry events, as well as an extensive set of network program types like XDP and cgroup socket attachments.</p>&#13;
<p>In this project’s <a href="https://oreil.ly/Vuf9d"><em>examples</em> directory under <em>cilium/ebpf</em></a>, you’ll see that the C code for in-kernel programs sits in the same directories as the corresponding user space code in Go:</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p>The C files start with <code>// +build ignore</code>, which tells the Go compiler to ignore them. At the time of this writing there is an <a href="https://oreil.ly/ymuyn">update in progress</a> to change to the newer <code>//go:build</code> style of build tag.</p></li>&#13;
<li><p>The user space files include a line like the following, which tells the Go compiler to invoke the bpf2go tool on the C file(s):</p>&#13;
<pre data-type="programlisting">//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG&#13;
                     -cflags $BPF_CFLAGS bpf &lt;C filename&gt; -- -I../headers</pre>&#13;
<p>Running <code>go:generate</code> on the package rebuilds the eBPF program and regenerates the skeleton in a single step.</p></li>&#13;
</ul>&#13;
<p>Much like <code>bpftool gen skeleton</code>, which you saw in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, <code>bpf2go</code> generates skeleton code for manipulating the eBPF objects, minimizing the user space code you need to write yourself (except it’s generating Go code rather than C). The output files also include the <em>.o</em> object files containing the bytecode.</p>&#13;
<p>In fact, <code>bpf2go</code> generates two versions of the bytecode <em>.o</em> files, for big- and little-endian architectures. There are also two correspondingly generated <em>.go</em> files, and the correct versions for the target platform get used at compile time. As an example, the auto-generated files in the <a href="https://oreil.ly/CgwVd">kprobe example from <em>cilium/ebpf</em></a> are:</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p>The <em>bpf_bpfeb.o</em> and <em>bpf_bpfel.o</em> ELF files containing eBPF bytecode</p></li>&#13;
<li><p>The <em>bpf_bpfeb.go</em> and <em>bpf_bpfel.go</em> files, which define Go structures and functions that correspond to the maps, programs, and links defined in that bytecode</p></li>&#13;
</ul>&#13;
<p>You can relate the objects defined in the auto-generated Go code to the C code from which it was generated. Here are the objects defined in the C code for that kprobe example:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">bpf_map_def</code><code class="w"> </code><code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code><code class="w"> </code><code class="n">kprobe_map</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="n">SEC</code><code class="p">(</code><code class="s">"kprobe/sys_execve"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">kprobe_execve</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>The auto-generated Go code includes structures representing all the maps and programs (in this case, there is only one of each):</p>&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code><code class="w"> </code><code class="nx">bpfMaps</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">KprobeMap</code><code class="w"> </code><code class="o">*</code><code class="nx">ebpf</code><code class="p">.</code><code class="nx">Map</code><code class="w"> </code><code class="s">`ebpf:"kprobe_map"`</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">type</code><code class="w"> </code><code class="nx">bpfPrograms</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">KprobeExecve</code><code class="w"> </code><code class="o">*</code><code class="nx">ebpf</code><code class="p">.</code><code class="nx">Program</code><code class="w"> </code><code class="s">`ebpf:"kprobe_execve"`</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>The names “KprobeMap” and “KprobeExecve” are derived from the map and program names used in the C code. These objects are grouped into a <code>bpfObjects</code> structure representing everything that’s being loaded into the kernel:</p>&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code><code class="w"> </code><code class="nx">bpfObjects</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">bpfPrograms</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">bpfMaps</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>You can then use these object definitions and related auto-generated functions in your user space Go code. To give you an idea of what this might involve, here’s an extract based on the main function from the same <a href="https://oreil.ly/YXAjH">kprobe example</a> (omitting error handling for brevity):</p>&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">objs</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bpfObjects</code><code class="p">{</code><code class="p">}</code><code class="w">                                   &#13;
</code><code class="nx">loadBpfObjects</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">objs</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w">                             </code><a class="co" href="#list_id_10_7" id="code_id_10_7"><img alt="1" src="assets/1.png"/></a><code class="w"> &#13;
</code><code class="k">defer</code><code class="w"> </code><code class="nx">objs</code><code class="p">.</code><code class="nx">Close</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="nx">kp</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">link</code><code class="p">.</code><code class="nx">Kprobe</code><code class="p">(</code><code class="s">"sys_execve"</code><code class="p">,</code><code class="w"> &#13;
                     </code><code class="nx">objs</code><code class="p">.</code><code class="nx">KprobeExecve</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w">           </code><a class="co" href="#list_id_10_8" id="code_id_10_8"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="k">defer</code><code class="w"> </code><code class="nx">kp</code><code class="p">.</code><code class="nx">Close</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="nx">ticker</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">NewTicker</code><code class="p">(</code><code class="mi">1</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w">              </code><a class="co" href="#list_id_10_9" id="code_id_10_9"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="k">defer</code><code class="w"> </code><code class="nx">ticker</code><code class="p">.</code><code class="nx">Stop</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="k">for</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">ticker</code><code class="p">.</code><code class="nx">C</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">value</code><code class="w"> </code><code class="kt">uint64</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">objs</code><code class="p">.</code><code class="nx">KprobeMap</code><code class="p">.</code><code class="nx">Lookup</code><code class="p">(</code><code class="nx">mapKey</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">value</code><code class="p">)</code><code class="w">              </code><a class="co" href="#list_id_10_10" id="code_id_10_10"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
    </code><code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%s called %d times\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">fn</code><code class="p">,</code><code class="w"> </code><code class="nx">value</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_10_7" id="list_id_10_7"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>Load all the BPF objects that were embedded in bytecode form, into the <code>bpfObjects</code> I just showed you defined by the auto-generated code.</dd>&#13;
<dt><a class="co" href="#code_id_10_8" id="list_id_10_8"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Attach the program to the <code>sys_execve</code> kprobe.</dd>&#13;
<dt><a class="co" href="#code_id_10_9" id="list_id_10_9"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Set up a ticker so that the code can poll the map once per second.</dd>&#13;
<dt><a class="co" href="#code_id_10_10" id="list_id_10_10"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>Read an item out of the map.</dd>&#13;
</dl>&#13;
<p>There are several other examples in the <em>cilium/ebpf</em> directory that you can use for reference and inspiration.<a contenteditable="false" data-primary="" data-startref="ch10.html11" data-type="indexterm" id="idm46123191010256"/><a contenteditable="false" data-primary="" data-startref="ch10.html10" data-type="indexterm" id="idm46123190948640"/><a contenteditable="false" data-primary="" data-startref="ch10.html9" data-type="indexterm" id="idm46123190947424"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Libbpfgo" data-type="sect2"><div class="sect2" id="libbpfgo">&#13;
<h2>Libbpfgo</h2>&#13;
<p><a contenteditable="false" data-primary="libbpfgo" data-type="indexterm" id="idm46123190945072"/>The <a href="https://oreil.ly/gvbXr"><em>libbpfgo</em> project</a> by Aqua Security implements a Go wrapper around <em>libbpf</em>’s C code, providing utilities for loading and attaching programs and using Go-native features like channels for receiving events. Because it’s built on <em>libbpf</em>, it supports CO-RE.</p>&#13;
<p>Here’s an extract from the example from <em>libbpfgo</em>’s <em>README</em>, which gives a good high-level view of what to expect from this library:</p>&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">bpfModule</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bpf</code><code class="p">.</code><code class="nx">NewModuleFromFile</code><code class="p">(</code><code class="nx">bpfObjectPath</code><code class="p">)</code><code class="w">         </code><a class="co" href="#list_id_10_11" id="code_id_10_11"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nx">bpfModule</code><code class="p">.</code><code class="nx">BPFLoadObject</code><code class="p">(</code><code class="p">)</code><code class="w">                                 </code><a class="co" href="#list_id_10_12" id="code_id_10_12"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
&#13;
</code><code class="nx">mymap</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bpfModule</code><code class="p">.</code><code class="nx">GetMap</code><code class="p">(</code><code class="s">"mymap"</code><code class="p">)</code><code class="w">                     </code><a class="co" href="#list_id_10_13" id="code_id_10_13"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="nx">mymap</code><code class="p">.</code><code class="nx">Update</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code><code class="w"> </code><code class="nx">value</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="nx">rb</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bpfModule</code><code class="p">.</code><code class="nx">InitRingBuffer</code><code class="p">(</code><code class="s">"events"</code><code class="p">,</code><code class="w"> </code><code class="nx">eventsChannel</code><code class="p">,</code><code class="w"> </code><code class="nx">buffSize</code><code class="p">)</code><code class="w">&#13;
</code><code class="nx">rb</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="nx">e</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">eventsChannel</code><code class="w">                                      </code><a class="co" href="#list_id_10_14" id="code_id_10_14"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_10_11" id="list_id_10_11"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>Read eBPF bytecode from an object file.</dd>&#13;
<dt><a class="co" href="#code_id_10_12" id="list_id_10_12"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Load that bytecode into the kernel.</dd>&#13;
<dt><a class="co" href="#code_id_10_13" id="list_id_10_13"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Manipulate an entry in an eBPF map.</dd>&#13;
<dt><a class="co" href="#code_id_10_14" id="list_id_10_14"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>Go programmers will appreciate receiving data from a ring or perf buffer on a channel, which is a language feature designed to handle asynchronous events.</dd>&#13;
</dl>&#13;
<p>This library was created for Aqua’s <a href="https://oreil.ly/A03zd">Tracee</a> security project, and it’s also being used by other projects such as <a href="https://oreil.ly/s8JP9">Parca</a> from Polar Signals, which provides eBPF-based CPU profiling. The only concern about this project’s approach is the CGo boundary between the <em>libbpf</em> C code and Go, which can cause performance and other issues.<sup><a data-type="noteref" href="ch10.html#ch10fn5" id="ch10fn5-marker">5</a></sup></p>&#13;
<p>While Go has been the established language for lots of infrastructure coding for around a decade, there has more recently been a growing body of developers who prefer to use Rust.<a contenteditable="false" data-primary="" data-startref="ch10.html8" data-type="indexterm" id="idm46123190807696"/><a contenteditable="false" data-primary="" data-startref="ch10.html7" data-type="indexterm" id="idm46123190806480"/><a contenteditable="false" data-primary="" data-startref="ch10.html6" data-type="indexterm" id="idm46123190805168"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Rust" data-type="sect1"><div class="sect1" id="rust">&#13;
<h1>Rust</h1>&#13;
<p><a contenteditable="false" data-primary="programming, eBPF" data-secondary="Rust" data-type="indexterm" id="ch10.html12"/><a contenteditable="false" data-primary="Rust" data-type="indexterm" id="ch10.html13"/>Rust is increasingly being used for building infrastructure tools. It allows for the low-level access of C, but with the added benefit of memory safety. Indeed, Linus Torvalds <a href="https://oreil.ly/7fINA">confirmed in 2022</a> that the Linux kernel itself will start to incorporate Rust code, and the recent <a href="https://oreil.ly/HrXy2">6.1 release has some initial Rust support</a>.</p>&#13;
<p>As I discussed earlier in this chapter, Rust can be compiled to eBPF bytecode, meaning that (with the right library support) it’s possible to write both the user space and kernel code for eBPF utilities in Rust.</p>&#13;
<p>There are a few options for Rust eBPF development: <em>libbpf-rs</em>, <em>Redbpf</em>, and Aya.</p>&#13;
<section data-pdf-bookmark="Libbpf-rs" data-type="sect2"><div class="sect2" id="libbpf_rs">&#13;
<h2>Libbpf-rs</h2>&#13;
<p><a contenteditable="false" data-primary="libbpf-rs" data-type="indexterm" id="idm46123190794048"/><a contenteditable="false" data-primary="Rust" data-secondary="libbpf-rs and" data-type="indexterm" id="idm46123190792944"/><a href="https://oreil.ly/qBagk"><em>Libbpf-rs</em></a> is part of the <em>libbpf</em> project, and provides a Rust wrapper around the <em>libbpf</em> C code so that you can write the user space parts of eBPF code in Rust. As you can see from the project’s <a href="https://oreil.ly/6wpf8">examples</a>, the eBPF programs themselves are written in C.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There are further examples in Rust in the <a href="https://oreil.ly/ter6c"><em>libbpf-bootstrap</em></a> project, designed to help you get off the ground if you want to try building your own code using this crate.</p>&#13;
</div>&#13;
<p>This crate is helpful for incorporating eBPF programs into a Rust-based project, but it doesn’t fulfill the desire that many people have to write the kernel-side code in Rust as well. Let’s look at some other projects that enable that.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Redbpf" data-type="sect2"><div class="sect2" id="redbpf">&#13;
<h2>Redbpf</h2>&#13;
<p><a contenteditable="false" data-primary="redbpf" data-type="indexterm" id="idm46123190784512"/><a contenteditable="false" data-primary="Rust" data-secondary="redbpf and" data-type="indexterm" id="idm46123190783408"/><a href="https://oreil.ly/AtJod"><em>Redbpf</em></a> is a set of Rust crates that interface with <em>libbpf</em>, developed as part of <a href="https://oreil.ly/dwGNK">foniod</a>, an eBPF-based security monitoring agent.</p>&#13;
<p><a contenteditable="false" data-primary="LLVM" data-type="indexterm" id="idm46123190779664"/><em>Redbpf</em> predates Rust’s ability to compile to eBPF bytecode, so it uses a <a href="https://oreil.ly/DuHxE">multistep compilation process</a> that involves compiling from Rust to LLVM bitcode and then using the LLVM toolchain to generate eBPF bytecode in ELF format. <em>Redbpf</em> supports a range of program types including tracepoints, kprobes and uprobes, XDP, TC, and some socket events.</p>&#13;
<p>As the Rust compiler rustc gained the ability to generate eBPF bytecode directly, this was leveraged by a project called Aya. At the time of this writing, Aya is considered “emerging” according to the <a href="https://oreil.ly/WynV6">community site at ebpf.io</a>, while <em>Redbpf</em> is listed as a major project, but my personal perspective is that momentum seems to be moving toward Aya.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Aya" data-type="sect2"><div class="sect2" id="aya">&#13;
<h2>Aya</h2>&#13;
<p><a contenteditable="false" data-primary="Aya project" data-type="indexterm" id="ch10.html14"/><a contenteditable="false" data-primary="Rust" data-secondary="Aya and" data-type="indexterm" id="ch10.html15"/><a href="https://aya-rs.dev/book">Aya</a> is built in Rust directly to the syscall level, so it doesn’t depend on <em>libbpf</em> (or indeed on BCC or the LLVM toolchain). But it does support the BTF format, the same relocations that <em>libbpf</em> does (as described in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>), so it’s providing the same CO-RE abilities to compile once and run on other kernels. At the time of this writing, it supports a wider range of eBPF program types than <em>Redbpf</em>, including tracing/perf-related events, XDP and TC, cgroups, and LSM attachments.</p>&#13;
<p>As I mentioned, the Rust compiler also supports <a href="https://oreil.ly/a5q7M">compiling to eBPF bytecode</a>, so this language can be used for both kernel and user space eBPF programming.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The ability to write both the kernel side and the user space side natively in Rust without the intermediate dependency on LLVM has attracted Rust programmers to this option. There’s an interesting <a href="https://oreil.ly/nls4l">discussion on GitHub</a> about why the developers of the <a href="https://oreil.ly/_-L6z">lockc project</a> (an eBPF-based project that enhances the security of container workloads using LSM hooks) decided to port their project from <em>libbpf-rs</em> to Aya.</p>&#13;
</div>&#13;
<p>The project includes <a href="https://oreil.ly/Kd0nf">aya-tool</a>, a utility for generating Rust structure definitions that match kernel data structures so that you don’t have to write them yourself.</p>&#13;
<p>The Aya project strongly emphasizes developer experience and makes it easy for newcomers to get started. With that in mind, the <a href="https://aya-rs.dev/book">“Aya book”</a> is a very readable introduction with some good example code, annotated with helpful explanations.</p>&#13;
<p>To give you a brief idea of what eBPF code looks like in Rust, here’s an extract from Aya’s basic XDP example that permits all traffic:</p>&#13;
<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[</code><code class="cp">xdp(name=</code><code class="s">"</code><code class="s">myapp</code><code class="s">"</code><code class="cp">)</code><code class="cp">]</code><code class="w">                                         </code><a class="co" href="#list_id_10_15" id="code_id_10_15"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code><code> </code><code class="nf">myapp</code><code class="p">(</code><code class="n">ctx</code><code>:</code><code> </code><code class="nc">XdpContext</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="kt">u32</code><code> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">try_myapp</code><code class="p">(</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="p">{</code><code class="w">                        </code><a class="co" href="#list_id_10_16" id="code_id_10_16"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">ret</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ret</code><code class="p">,</code><code class="w">&#13;
</code><code class="w">        </code><code class="nb">Err</code><code class="p">(</code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">&gt;</code><code class="w"> </code><code class="n">xdp_action</code><code>::</code><code class="n">XDP_ABORTED</code><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="k">unsafe</code><code class="w"> </code><code class="k">fn</code><code> </code><code class="nf">try_myapp</code><code class="p">(</code><code class="n">ctx</code><code>:</code><code> </code><code class="nc">XdpContext</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="kt">u32</code><code class="p">,</code><code class="w"> </code><code class="kt">u32</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">   </code><a class="co" href="#list_id_10_17" id="code_id_10_17"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
    </code><code class="n">info</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">received a packet</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">xdp_action</code><code>::</code><code class="n">XDP_PASS</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_10_15" id="list_id_10_15"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>This line is what defines the section name, equivalent to <code>SEC("xdp/myapp")</code> in C.</dd>&#13;
<dt><a class="co" href="#code_id_10_16" id="list_id_10_16"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>The eBPF program called <code>myapp</code> calls the function <code>try_myapp</code> to process a network packet received at XDP.</dd>&#13;
<dt><a class="co" href="#code_id_10_17" id="list_id_10_17"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>The <code>try_myapp</code> function logs the fact that a packet was received and always returns the <code>XDP_PASS</code> value that tells the kernel to carry on processing the packet as usual.</dd>&#13;
</dl>&#13;
<p>Just as we’ve seen in C-based examples throughout this book, the eBPF program gets compiled to an ELF object file. The difference is that Aya uses the Rust compiler instead of Clang to create that file.</p>&#13;
<p>Aya also generates code for the user space activities of loading the eBPF program into the kernel and attaching it to an event. Here are a few key lines from the user space side of that same basic example:</p>&#13;
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">bpf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Bpf</code><code>::</code><code class="n">load</code><code class="p">(</code><code class="n">include_bytes_aligned</code><code class="o">!</code><code class="p">(</code><code class="w">&#13;
</code><code class="w">   </code><code class="s">"</code><code class="s">../../target/bpfel-unknown-none/release/myapp</code><code class="s">"</code><code class="w">&#13;
</code><code class="p">)</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w">                                                                     </code><a class="co" href="#list_id_10_19" id="code_id_10_19"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
&#13;
</code><code class="kd">let</code><code class="w"> </code><code class="n">program</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Xdp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf</code><code class="p">.</code><code class="n">program_mut</code><code class="p">(</code><code class="s">"</code><code class="s">myapp</code><code class="s">"</code><code class="p">)</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">try_into</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w">   </code><a class="co" href="#list_id_10_20" id="code_id_10_20"><img alt="2" src="assets/2.png"/></a><code class="w"> &#13;
&#13;
</code><code class="n">program</code><code class="p">.</code><code class="n">load</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w">                                                         </code><a class="co" href="#list_id_10_21" id="code_id_10_21"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="n">program</code><code class="p">.</code><code class="n">attach</code><code class="p">(</code><code class="o">&amp;</code><code class="n">opt</code><code class="p">.</code><code class="n">iface</code><code class="p">,</code><code class="w"> </code><code class="n">XdpFlags</code><code>::</code><code class="n">default</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">                          </code><a class="co" href="#list_id_10_22" id="code_id_10_22"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_10_19" id="list_id_10_19"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>Read the eBPF bytecode from the ELF object file produced by the compiler.</dd>&#13;
<dt><a class="co" href="#code_id_10_20" id="list_id_10_20"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Find the program called <code>myapp</code> in that bytecode.</dd>&#13;
<dt><a class="co" href="#code_id_10_21" id="list_id_10_21"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Load it into the kernel.</dd>&#13;
<dt><a class="co" href="#code_id_10_22" id="list_id_10_22"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>Attach it to the XDP event on a specified network interface.</dd>&#13;
</dl>&#13;
<p>If you’re a Rust programmer, I highly recommend you explore the <a href="https://oreil.ly/bp_Hq">additional examples</a> in the “Aya book” in more detail. There’s also a nice <a href="https://oreil.ly/mUVIk">blog post from Kong</a> that walks through writing an XDP load balancer using Aya.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Aya maintainers Dave Tucker and Alessandro Decina joined me for <a href="https://oreil.ly/U7bRu">episode 25 of the “eBPF and Cilium Office Hours” livestream</a> where they demonstrated and gave an introduction to eBPF programming with Aya.<a contenteditable="false" data-primary="" data-startref="ch10.html15" data-type="indexterm" id="idm46123190448464"/><a contenteditable="false" data-primary="" data-startref="ch10.html14" data-type="indexterm" id="idm46123190446944"/></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Rust-bcc" data-type="sect2"><div class="sect2" id="rust_bcc">&#13;
<h2>Rust-bcc</h2>&#13;
<p><a href="https://oreil.ly/prP_K">Rust-bcc</a> provides Rust bindings that mimic the BCC project’s Python bindings, along with some Rust implementations of some of the BCC set of tracing <a href="https://oreil.ly/Dd2nO">tools</a>.<a contenteditable="false" data-primary="" data-startref="ch10.html13" data-type="indexterm" id="idm46123190442656"/><a contenteditable="false" data-primary="" data-startref="ch10.html12" data-type="indexterm" id="idm46123190441248"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Testing BPF Programs" data-type="sect1"><div class="sect1" id="testing_bpf_programs">&#13;
<h1>Testing BPF Programs</h1>&#13;
<p><a contenteditable="false" data-primary="programming, eBPF" data-secondary="testing" data-type="indexterm" id="idm46123190437808"/><a contenteditable="false" data-primary="testing BPF programs" data-type="indexterm" id="idm46123190436432"/><a contenteditable="false" data-primary="BPF_PROG_RUN" data-type="indexterm" id="idm46123190435328"/><a contenteditable="false" data-primary="bpf() system calls" data-secondary="testing with BPF_PROG_RUN" data-type="indexterm" id="idm46123190434224"/>There’s a <code>bpf()</code> command, <a href="https://oreil.ly/Y2xPC"><code>BPF_PROG_RUN</code></a>, that allows for running an eBPF program from user space for test purposes.</p>&#13;
<p><code>BPF_PROG_RUN</code> (currently) works only with a subset of BPF program types that are mostly networking related.</p>&#13;
<p>You can also get information about eBPF program performance with some built-in statistics information. Run the following command to enable it:</p>&#13;
<pre data-type="programlisting">$ sysctl -w kernel.bpf_stats_enabled=1</pre>&#13;
<p>This will show additional information in <code>bpftool</code>’s output about programs, like this:</p>&#13;
<pre data-type="programlisting">$ bpftool prog list &#13;
...&#13;
2179: raw_tracepoint  name raw_tp_exec  tag 7f6d182e48b7ed38  gpl&#13;
        <strong>run_time_ns 316876 run_cnt 4</strong>&#13;
        loaded_at 2023-01-09T11:07:31+0000  uid 0&#13;
        xlated 216B  jited 264B  memlock 4096B  map_ids 780,777&#13;
        btf_id 953&#13;
        pids hello(19173)</pre>&#13;
<p>The additional statistics are shown in bold, and here they show that the program has run four times, taking about 300 microseconds in total.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Learn more from Quentin Monnet’s FOSDEM 2020 talk titled <a href="https://oreil.ly/I5Jhd">“Tools and mechanisms to debug BPF programs.”</a></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Multiple eBPF Programs" data-type="sect1"><div class="sect1" id="multiple_ebpf_programs">&#13;
<h1>Multiple eBPF Programs</h1>&#13;
<p><a contenteditable="false" data-primary="programming, eBPF" data-secondary="multiple BPF programs" data-type="indexterm" id="idm46123190423520"/>An eBPF program is a function attached to an event in the kernel. Many applications need to track more than one event to achieve their goals. <a contenteditable="false" data-primary="opensnoop" data-type="indexterm" id="idm46123190421856"/>A simple example of this is opensnoop.<sup><a data-type="noteref" href="ch10.html#ch10fn6" id="ch10fn6-marker">6</a></sup> I covered the <code>bpftrace</code> version of this early in this chapter, and you saw that it attaches BPF programs to four different syscall tracepoints:</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p><code>syscall_enter_open</code></p></li>&#13;
<li><p><code>syscall_exit_open</code></p></li>&#13;
<li><p><code>syscall_enter_openat</code></p></li>&#13;
<li><p><code>syscall_exit_openat</code></p></li>&#13;
</ul>&#13;
<p>These are the entry and exit points to the kernel’s handling of the <code>open()</code> and <code>openat()</code> system calls. These two system calls can be used for opening files, and the opensnoop tool tracks both of them.</p>&#13;
<p>But why does it need to track both entry and exit for these system calls? The entry points are used because that’s when the system call arguments are available, and these include the filename and any flags being passed to the <code>open[at]</code> syscall. But at that stage it’s too soon to know whether the file will be opened successfully or not. That explains why it’s necessary to have eBPF programs attached to the exit points too.</p>&#13;
<p>If you look at the <a href="https://oreil.ly/IOty_"><em>libbpf-tools</em> version of opensnoop</a>, you’ll see there’s just one user space program, and it loads all four eBPF programs into the kernel and attaches them to their events. The eBPF programs themselves are essentially independent, but they use eBPF maps to coordinate among themselves.</p>&#13;
<p>A complex application might even need to add and remove eBPF programs dynamically throughout a long period of time. There may not even be a fixed number of eBPF programs for any given application. For example, Cilium attaches eBPF programs to each virtual networking interface, and in a Kubernetes environment these interfaces come and go depending on how many pods are running.</p>&#13;
<p>Most of the libraries in this chapter handle this multiplicity of eBPF programs automatically. For example, <em>libbpf</em> and <em>ebpf-go</em> generate skeleton code that will load <em>all</em> the programs and maps from the bytecode in an object file or buffer in one function call. They also generate finer-granularity functions so that you can manipulate programs and maps individually.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000019">&#13;
<h1>Summary</h1>&#13;
<p>The vast majority of people who use eBPF-based tooling won’t need to write eBPF code themselves, but if you do find yourself wanting to implement something yourself, you have a lot of options. This is a changing field, so it’s very possible that by the time you read this, new language libraries and frameworks might exist, or consensus may have gathered around some of the libraries I’ve highlighted in this chapter. You’ll find an up-to-date list of the major language projects around eBPF on the <a href="https://ebpf.io/infrastructure">Infrastructure page of ebpf.io’s list of significant projects</a>.</p>&#13;
<p>For quickly collecting trace information, <code>bpftrace</code> can be a very valuable option.</p>&#13;
<p>For more flexibility and control, BCC is a fast way to build an eBPF tool if you’re comfortable with Python, provided that you don’t care about the compilation step that takes place at runtime.</p>&#13;
<p>If you’re writing eBPF code to be widely distributed and portable across different kernel versions, you’ll probably want to take advantage of CO-RE. The user space frameworks that support CO-RE at time of this writing are <em>libbpf</em> for C, <em>cilium/ebpf</em> and <em>libbpfgo</em> for Go, and Aya for Rust.</p>&#13;
<p>For further advice, I highly recommend joining the <a href="http://ebpf.io/slack">eBPF Slack</a> and discussing your questions there. You’ll likely find the maintainers of many of these language libraries in that community.<a contenteditable="false" data-primary="" data-startref="ch10.html0" data-type="indexterm" id="idm46123190400800"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="exercises_id000007">&#13;
<h1>Exercises</h1>&#13;
<p>If you’d like to try one or more of the libraries discussed in this chapter, “Hello World” is always a good place to start:</p>&#13;
<ol>&#13;
<li><p>Using one or more libraries of your choosing, write an example “Hello World” program that outputs a simple trace message.</p></li>&#13;
<li><p>Use <code>llvm-objdump</code> to compare the bytecode produced with the “Hello World” example from <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>. You’ll find lots of similarities!</p></li>&#13;
<li><p>As you saw in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>, you can use <code>strace -e bpf</code> to see when <code>bpf()</code> system calls are made. Try that on your “Hello World” program to see if it’s behaving as you expect.</p></li>&#13;
</ol>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch10fn1"><sup><a href="ch10.html#ch10fn1-marker">1</a></sup> Being attached to syscall entry points means this script has the same Time Of Check To Time Of Use (TOCTOU) vulnerability discussed in the previous chapter. That doesn’t stop it from being a useful tool; it’s just that you shouldn’t rely on it as your only line of defense for security purposes.</p><p data-type="footnote" id="ch10fn2"><sup><a href="ch10.html#ch10fn2-marker">2</a></sup> For an example of this, check out Cloudflare’s blog post <a href="https://oreil.ly/2GjuK">“eBPF, Sockets, Hop Distance and manually writing eBPF assembly”</a>.</p><p data-type="footnote" id="ch10fn3"><sup><a href="ch10.html#ch10fn3-marker">3</a></sup> See, for example, Brendan Gregg’s <a href="https://oreil.ly/fz_dQ">observation</a> that the <em>libbpf</em>-based version of opensnoop required around 9 MB compared with 80 MB for the Python-based version.</p><p data-type="footnote" id="ch10fn4"><sup><a href="ch10.html#ch10fn4-marker">4</a></sup> Watch me working through some of the XDP Tutorial examples in <a href="https://oreil.ly/9SaKn">episode 13 of the eBPF and Cilium Office Hours” livestream</a>.</p><p data-type="footnote" id="ch10fn5"><sup><a href="ch10.html#ch10fn5-marker">5</a></sup> Dave Cheney’s 2016 post “<a href="https://oreil.ly/mxThs">cgo is not Go</a>” remains a good overview of concerns related to the CGo boundary.</p><p data-type="footnote" id="ch10fn6"><sup><a href="ch10.html#ch10fn6-marker">6</a></sup> As well as the <code>bpftrace</code> version of this tool, there are equivalents in BCC and in <em>libbpf-tools</em>. They all do very much the same thing, generating a line of trace whenever a process opens a file. There’s a walkthrough of the eBPF code for BCC’s version of opensnoop in my report <a class="orm:hideurl" href="https://www.oreilly.com/library/view/what-is-ebpf/9781492097266">“What Is eBPF?”</a>.</p></div></div></section></body></html>