<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. JavaScript MV* Patterns"><div class="chapter" id="javascript-mv-patterns">
<h1><span class="label">Chapter 8. </span>JavaScript MV* Patterns</h1>


<p>Object design and application architecture are the two principal aspects of application design. <a data-type="indexterm" data-primary="MV* patterns" data-secondary="about" id="idm45017699405328"/><a data-type="indexterm" data-primary="architectural patterns" data-secondary="about" id="idm45017699404352"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="about" id="idm45017699403408"/><a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="about" id="idm45017699402496"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="about" id="idm45017699401584"/><a data-type="indexterm" data-primary="objects" data-secondary="object design patterns" data-see="design patterns" id="idm45017699400672"/><a data-type="indexterm" data-primary="Model-View-Presenter pattern" data-see="MVP pattern" id="idm45017699399456"/><a data-type="indexterm" data-primary="Model-View-ViewModel pattern" data-see="MVVM pattern" id="idm45017699398544"/><a data-type="indexterm" data-primary="Model-View-Controller pattern" data-see="MVC  pattern" id="idm45017699355312"/>We have covered patterns that relate to the first in the previous chapter. In this chapter, we’re going to review three fundamental architectural patterns: MVC (Model-View-Controller), MVP (Model-View-Presenter), and MVVM (Model-View-ViewModel). In the past, these patterns were heavily used for structuring desktop and server-side applications. Now they have been adapted for JavaScript too.</p>

<p>As most JavaScript developers currently using these patterns opt to utilize various libraries or frameworks for implementing an MVC/MV*-like structure, we will compare how these solutions differ in their interpretation of MVC compared to classical takes on these patterns.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can easily distinguish the Model and View layers in most modern browser-based UI design frameworks based on MVC/MVVM. However, the third component varies in both name and function. The * in MV* thus represents whatever form the third component takes in the different frameworks.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="MVC"><div class="sect1" id="mvc">
<h1>MVC</h1>

<p>MVC is an architectural design pattern that encourages improved application organization through a separation of concerns. It enforces the isolation of business data (Models) from UIs (Views), with a third component (Controllers) traditionally managing logic and user input.<a data-type="indexterm" data-primary="MV* patterns" data-secondary="MVC" id="ch08-mvc"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" id="ch08-mvc2"/><a data-type="indexterm" data-primary="architectural patterns" data-secondary="MVC" id="ch08-mvc3"/><a data-type="indexterm" data-primary="Reenskaug, Trygve" id="idm45017699348096"/><a data-type="indexterm" data-primary="Smalltalk-80" data-secondary="Model-View-Controller-Editor" id="idm45017699347424"/><a data-type="indexterm" data-primary="history" data-secondary="Model-View-Controller" id="idm45017699346512"/><a data-type="indexterm" data-primary="history" data-secondary="Model-View-Controller" data-tertiary="Smalltalk-80 MVC" id="idm45017699345568"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Smalltalk-80 MVC" id="idm45017699344352"/><a data-type="indexterm" data-primary="Design Patterns: Elements of Reusable Object-Oriented Software (Gamma, Helm, Johnson, and Vlissides)" data-secondary="MVC" id="idm45017699343440"/><a data-type="indexterm" data-primary="Gamma, Erich" id="idm45017699342416"/><a data-type="indexterm" data-primary="Helm, Richard" id="idm45017699341744"/><a data-type="indexterm" data-primary="Johnson, Ralph" id="idm45017699341072"/><a data-type="indexterm" data-primary="Vlissides, John" id="idm45017699340400"/> <a href="https://oreil.ly/N9Dt5">Trygve Reenskaug</a> originally designed the pattern while working on <a href="https://oreil.ly/6gft1">Smalltalk-80</a> (1979), where it was initially called Model-View-Controller-Editor. MVC was later described in depth in 1995’s <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> (aka the “GoF” book), which played a role in popularizing its use.</p>








<section data-type="sect2" data-pdf-bookmark="Smalltalk-80 MVC"><div class="sect2" id="smalltalk-80-mvc">
<h2>Smalltalk-80 MVC</h2>

<p>It’s essential to understand what<a data-type="indexterm" data-primary="history" data-secondary="Model-View-Controller" data-tertiary="Smalltalk-80 MVC" id="idm45017699336096"/><a data-type="indexterm" data-primary="Smalltalk-80" data-secondary="Model-View-Controller-Editor" id="idm45017699334848"/><a data-type="indexterm" data-primary="Separated Presentation" id="idm45017699333936"/><a data-type="indexterm" data-primary="history" data-secondary="Separated Presentation" id="idm45017699333264"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Smalltalk-80 MVC" id="idm45017699332320"/> the original MVC pattern was aiming to solve, as it has mutated quite heavily since its origin. Back in the 1970s, GUIs were few and far between. A concept known as <a href="https://oreil.ly/yTX-F">Separated Presentation</a> became famous as a means to make a clear division between domain objects that modeled ideas in the real world (e.g., a photo, a person) and the presentation objects that were rendered to the users’ screen.</p>

<p>The Smalltalk-80 implementation of MVC took this concept further and aimed to separate the application logic from the UI. The idea was that decoupling these parts of the application would also allow the reuse of Models for other interfaces in the application. There are some interesting points worth noting about Smalltalk-80’s MVC architecture:<a data-type="indexterm" data-primary="Observer pattern" data-secondary="MVC architecture" id="idm45017699330160"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="about" data-tertiary="Observer pattern in architecture" id="idm45017699329184"/></p>

<ul>
<li>
<p>A Model represented domain-specific data and was ignorant of the UI (Views and Controllers). When a Model changed, it would inform its observers.</p>
</li>
<li>
<p>A View  represented the current state of a Model. The Observer pattern was used to let the View know whenever the Model was updated or modified.</p>
</li>
<li>
<p>The View took care of the presentation, but there wasn’t just a single View and Controller—a View-Controller pair was required for each section or element displayed on the screen.</p>
</li>
<li>
<p>The Controller’s role in this pair was handling user interaction (such as key presses and actions such as clicks) and making decisions for the View.</p>
</li>
</ul>

<p>Developers are sometimes surprised when they learn that the Observer pattern (nowadays commonly implemented as the Publish/Subscribe variation) was included as a part of MVC’s architecture decades ago. In Smalltalk-80’s MVC, the View observes the Model. As mentioned in the bullet point, anytime the Model changes, the Views react. A simple example of this is an application backed by stock market data. For the application to be helpful, any change to the data in our Models should result in the View being refreshed instantly.</p>

<p><a href="https://oreil.ly/yTX-F">Martin Fowler</a> has done<a data-type="indexterm" data-primary="Fowler, Martin" id="idm45017699322672"/> an excellent job of writing about the origins of MVC over the years. If you’re interested in some further historical information about Smalltalk-80’s, I recommend reading his work.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="MVC for JavaScript Developers"><div class="sect1" id="mvc-for-javascript-developers">
<h1>MVC for JavaScript Developers</h1>

<p>We’ve reviewed the 1970s, but<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="about" id="idm45017699319488"/> let us return to the present. In modern times, the MVC pattern has been used with a diverse range of programming languages and application types, including those of most relevance to us: JavaScript. JavaScript now has several frameworks boasting support for MVC (or variations of it, which we refer to as the MV* family), allowing developers to add structure to their applications easily.</p>

<p>The first among these frameworks include Backbone, Ember.js, and AngularJS. More recently, React, Angular, and Vue.js ecosystems have been used to implement variations of the MV* family of patterns. <a data-type="indexterm" data-primary="“spaghetti” code" data-primary-sortas="spaghetti" id="idm45017699317936"/>Given the importance of avoiding “spaghetti” code, a term that describes code that is very difficult to read or maintain due to its lack of structure, the modern JavaScript developer must understand what this pattern provides. This allows us to effectively appreciate what these frameworks enable us to do differently (<a data-type="xref" href="#MVC_pattern">Figure 8-1</a>).</p>

<figure><div id="MVC_pattern" class="figure">
<img src="Images/ljd2_0801.png" alt="ljd2 0801" width="1212" height="577"/>
<h6><span class="label">Figure 8-1. </span>MVC pattern</h6>
</div></figure>

<p>MVC comprises three core components, described in the following sections.</p>








<section data-type="sect2" data-pdf-bookmark="Models"><div class="sect2" id="models">
<h2>Models</h2>

<p>Models manage the data for an application.<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" id="idm45017699311712"/><a data-type="indexterm" data-primary="Models" data-secondary="about" id="idm45017699310720"/> They are concerned with neither the UI nor presentation layers but represent unique data forms that an application may require. When a Model changes (e.g., when it is updated), it will typically notify its observers (e.g., Views, a concept we will cover shortly) that a change has occurred so that it may react accordingly.</p>

<p>To understand Models further, let us imagine<a data-type="indexterm" data-primary="Models" data-secondary="photo gallery application" id="idm45017699309264"/><a data-type="indexterm" data-primary="photo gallery application" id="idm45017699308272"/> we have a photo gallery application. In a photo gallery, the concept of a photo would merit its own Model, as it represents a unique kind of domain-specific data. <a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="attributes" id="idm45017699307456"/><a data-type="indexterm" data-primary="attributes of Models" id="idm45017699306224"/><a data-type="indexterm" data-primary="Models" data-secondary="attributes" id="idm45017699305552"/>Such a Model may contain related attributes such as a caption, image source, and additional metadata. You would store a specific photo in an instance of a Model, and a Model may also be reusable.</p>

<p>The built-in capabilities of Models vary across frameworks. However, it is pretty standard for them to support the validation of attributes, where attributes represent the properties of the Model, such as a Model identifier. <a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="persistence" id="idm45017699304096"/><a data-type="indexterm" data-primary="persistence of Models" id="idm45017699302832"/><a data-type="indexterm" data-primary="Models" data-secondary="persistence" id="idm45017699302160"/>When using Models in real-world applications, we generally also desire Model persistence. Persistence allows us to edit and update Models with the knowledge that their most recent state will be saved in either memory, local storage, or synchronized with a database.</p>

<p>In addition, a Model may have multiple Views<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="Views" id="ch08-mvcview"/><a data-type="indexterm" data-primary="Models" data-secondary="Views" id="ch08-mvcview2"/><a data-type="indexterm" data-primary="Views" data-secondary="about" id="idm45017699297952"/> observing it. If, say, our photo Model contained metadata, such as its location (longitude and latitude), friends who were present in the photo (a list of identifiers), and a list of tags, a developer may decide to provide a single View to display each of these three facets.</p>

<p>It is not uncommon for MVC/MV* frameworks<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="groups of Models" id="idm45017699296432"/><a data-type="indexterm" data-primary="groups of Models" id="idm45017699295168"/><a data-type="indexterm" data-primary="Models" data-secondary="groups of Models" id="idm45017699294496"/> to provide a means to group Models as a collection. Managing Models in groups allows us to write application logic based on notifications from the group whenever any of the Models in the group is changed. This avoids the need to observe individual Model instances manually.</p>

<p>Older texts on MVC may also refer<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="state" id="idm45017699293040"/><a data-type="indexterm" data-primary="state management" data-secondary="Models versus JavaScript applications" id="idm45017699291728"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="state versus Model state management" id="idm45017699290768"/><a data-type="indexterm" data-primary="Models" data-secondary="state" id="idm45017699289808"/> to a notion of Models managing application <em>state</em>. In JavaScript applications, the <em>state</em> has a different connotation, typically referring to the current “state”—i.e., view or subview (with specific data) on a user’s screen at a fixed point. The state is regularly discussed when looking at single-page applications (SPAs), where the concept of state needs to be simulated.</p>

<p>So to summarize, Models are primarily concerned with business data.<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="business data primarily" id="idm45017699287456"/><a data-type="indexterm" data-primary="Models" data-secondary="business data primarily" id="idm45017699286144"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Views"><div class="sect2" id="views">
<h2>Views</h2>

<p>Views are a visual representation of Models<a data-type="indexterm" data-primary="Views" id="idm45017699282640"/> that present a filtered view of their current state. While Smalltalk Views are about painting and maintaining a bitmap, JavaScript Views build and organize a collection of DOM elements.</p>

<p>A View typically observes a Model and is notified when the Model changes, allowing the View to update itself accordingly. Design pattern literature commonly refers to Views as “dumb,” given that their knowledge of Models and Controllers in an application is limited.</p>

<p>Users can interact with Views, including the ability to read and edit (i.e., get or set the attribute values in) Models. Because the View is the presentation layer, we generally present the ability to edit and update in a user-friendly fashion. For example, in the photo gallery application we discussed earlier, we could facilitate Model editing through an “edit” View where a user who selected a specific photo could edit its 
<span class="keep-together">metadata.</span></p>

<p>The actual task of updating the Model falls to the Controllers (which we will cover shortly).</p>

<p>Let’s explore Views a little further using a conventional JavaScript sample implementation. <a data-type="indexterm" data-primary="Models" data-secondary="photo gallery application" data-tertiary="View" id="idm45017699279392"/><a data-type="indexterm" data-primary="photo gallery application" data-secondary="View" id="idm45017699278128"/>Now we can see a function that creates a single photo View, consuming both a Model and a Controller instance.</p>

<p>We define a <code>render()</code> utility within our View,<a data-type="indexterm" data-primary="Lodash library" data-secondary="templating" data-tertiary="View of Model" id="idm45017699275888"/><a data-type="indexterm" data-primary="templating" data-secondary="Lodash library example code" data-tertiary="View of Model" id="idm45017699274608"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="templating" data-tertiary="Lodash library" id="idm45017699273376"/><a data-type="indexterm" data-primary="Views" data-secondary="templating" data-tertiary="Lodash library" id="idm45017699272160"/><a data-type="indexterm" data-primary="Models" data-secondary="Views" data-tertiary="templating" id="idm45017699270944"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="templating" id="idm45017699269728"/> which is responsible for rendering the contents of the <code>photoModel</code> using a JavaScript templating engine (Lodash templating) and updating the contents of our View, referenced by <code>photoEl</code>.</p>

<p>The <code>photoModel</code> then adds our <code>render()</code> callback as one of its subscribers so that we can trigger the View to update when the Model changes using the Observer pattern.</p>

<p>One may wonder where user interaction comes into play here. When users click on any element within the View, it’s not the View’s responsibility to know what to do next. It relies on a Controller to make this decision for it. Our sample implementation achieves this by adding an event listener to <code>photoEl</code>, which will delegate handling the click behavior back to the Controller, passing the Model information along with it in case it’s needed.</p>

<p>The architecture’s benefit is that each component plays its role in making the application function as needed:<a data-type="indexterm" data-startref="ch08-mvcview" id="idm45017699264848"/><a data-type="indexterm" data-startref="ch08-mvcview2" id="idm45017699264144"/></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">buildPhotoView</code> <code class="o">=</code> <code class="p">(</code><code class="nx">photoModel</code><code class="p">,</code> <code class="nx">photoController</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">base</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code> <code class="s2">"div"</code> <code class="p">);</code>
  <code class="kr">const</code> <code class="nx">photoEl</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code> <code class="s2">"div"</code> <code class="p">);</code>

  <code class="nx">base</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">photoEl</code><code class="p">);</code>

  <code class="kr">const</code> <code class="nx">render</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="c1">// We use Lodash's template method</code>
        <code class="c1">// which generates the HTML for our photo entry</code>
        <code class="nx">photo</code> <code class="nx">entry</code>
        <code class="nx">photoEl</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">template</code><code class="p">(</code><code class="s2">"#photoTemplate"</code><code class="p">,</code> <code class="p">{</code>
            <code class="nx">src</code><code class="o">:</code> <code class="nx">photoModel</code><code class="p">.</code><code class="nx">getSrc</code><code class="p">()</code>
        <code class="p">});</code>
    <code class="p">};</code>

  <code class="nx">photoModel</code><code class="p">.</code><code class="nx">addSubscriber</code><code class="p">(</code> <code class="nx">render</code> <code class="p">);</code>

  <code class="nx">photoEl</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code> <code class="s2">"click"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">photoController</code><code class="p">.</code><code class="nx">handleEvent</code><code class="p">(</code> <code class="s2">"click"</code><code class="p">,</code> <code class="nx">photoModel</code> <code class="p">);</code>
  <code class="p">});</code>

  <code class="kr">const</code> <code class="nx">show</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">photoEl</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">display</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
  <code class="p">};</code>

  <code class="kr">const</code> <code class="nx">hide</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">photoEl</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">display</code> <code class="o">=</code> <code class="s2">"none"</code><code class="p">;</code>
  <code class="p">};</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">showView</code><code class="o">:</code> <code class="nx">show</code><code class="p">,</code>
    <code class="nx">hideView</code><code class="o">:</code> <code class="nx">hide</code>
  <code class="p">};</code>
<code class="p">};</code></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Templating"><div class="sect2" id="templating">
<h2>Templating</h2>

<p>It would be worthwhile to briefly touch<a data-type="indexterm" data-primary="templating" id="idm45017699258992"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="templating" id="idm45017699088896"/><a data-type="indexterm" data-primary="Models" data-secondary="Views" data-tertiary="templating" id="idm45017699087952"/><a data-type="indexterm" data-primary="Views" data-secondary="templating" id="idm45017699086736"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Models" data-tertiary="templating" id="idm45017699085792"/><a data-type="indexterm" data-primary="photo gallery application" data-secondary="templating" id="idm45017699084608"/><a data-type="indexterm" data-primary="Models" data-secondary="photo gallery application" data-tertiary="templating" id="idm45017699083696"/> upon JavaScript templating while discussing JavaScript frameworks that support MVC/MV*. As mentioned in the previous section, templating is related to Views.</p>
<p class="fix_tracking">
It has long been considered (and proven) a performance bad practice to manually create large blocks of HTML markup in memory through string concatenation. Developers have fallen prey to inefficient iterations through their data, wrapping it in nested <code>div</code>s and using outdated techniques such as <code>document.write</code> to inject the generated “template” into the DOM. This typically means including scripted markup inline with our standard markup. The markup can quickly become difficult to read, and, more importantly, a nontrivial application with such code can be a maintenance disaster. </p>

<p>Modern JavaScript<a data-type="indexterm" data-primary="templating" data-secondary="tagged template literals" id="idm45017699080480"/><a data-type="indexterm" data-primary="Views" data-secondary="templating" data-tertiary="tagged template literals" id="idm45017699079504"/><a data-type="indexterm" data-primary="tagged template literals" id="idm45017699054256"/><a data-type="indexterm" data-primary="templating" data-secondary="variables" id="idm45017699053648"/> templating solutions have moved toward using tagged template literals, which are a powerful feature of ES6 (ECMAScript 2015). Tagged template literals allow you to create reusable templates using JavaScript’s template literal syntax, along with a custom processing function that can be used to manipulate and populate the template with data. This approach eliminates the need for additional templating libraries and provides a clean, maintainable way to create dynamic HTML 
<span class="keep-together">content.</span></p>

<p>Variables within tagged template literals can be easily interpolated using the 
<span class="keep-together"><code>${variable}</code></span> syntax, which is more concise and easier to read than traditional variable delimiters like <code>{{name}}</code>. This makes it simpler to maintain clean Models and templates while allowing the framework to handle most of the work for populating templates from Models. This has many benefits, particularly when opting to store templates externally. This can give way to templates being dynamically loaded on an as-needed basis when building <a data-type="indexterm" data-primary="tagged template literals" data-secondary="example code" id="idm45017699050192"/><a data-type="indexterm" data-primary="templating" data-secondary="tagged template literals" data-tertiary="example code" id="idm45017699049248"/><a data-type="indexterm" data-primary="templating" data-secondary="Lodash library example code" id="idm45017699048016"/><a data-type="indexterm" data-primary="Lodash library" data-secondary="templating" id="idm45017699047056"/><a data-type="indexterm" data-primary="Views" data-secondary="templating" data-tertiary="Lodash library" id="idm45017699046112"/><a data-type="indexterm" data-primary="Views" data-secondary="templating" data-tertiary="tagged template literals example code" id="idm45017699044896"/>larger applications.</p>

<p>Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#handlebar_js">8-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#underscore_js">8-2</a> are two examples of JavaScript templates. One has been implemented using tagged template literals, and another using Lodash’s templates.</p>
<div id="handlebar_js" data-type="example">
<h5><span class="label">Example 8-1. </span>Tagged template literals code</h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Sample data</code>
<code class="kr">const</code> <code class="nx">photos</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code>
    <code class="nx">caption</code><code class="o">:</code> <code class="s1">'Sample Photo 1'</code><code class="p">,</code>
    <code class="nx">src</code><code class="o">:</code> <code class="s1">'photo1.jpg'</code><code class="p">,</code>
    <code class="nx">metadata</code><code class="o">:</code> <code class="s1">'Some metadata for photo 1'</code><code class="p">,</code>
  <code class="p">},</code>
  <code class="p">{</code>
    <code class="nx">caption</code><code class="o">:</code> <code class="s1">'Sample Photo 2'</code><code class="p">,</code>
    <code class="nx">src</code><code class="o">:</code> <code class="s1">'photo2.jpg'</code><code class="p">,</code>
    <code class="nx">metadata</code><code class="o">:</code> <code class="s1">'Some metadata for photo 2'</code><code class="p">,</code>
  <code class="p">},</code>
<code class="p">];</code>

<code class="c1">// Tagged template literal function</code>
<code class="kd">function</code> <code class="nx">photoTemplate</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="nx">caption</code><code class="p">,</code> <code class="nx">src</code><code class="p">,</code> <code class="nx">metadata</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">strings</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">+</code> <code class="nx">caption</code> <code class="o">+</code> <code class="nx">strings</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">+</code> <code class="nx">src</code> <code class="o">+</code> <code class="nx">strings</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">+</code> <code class="nx">metadata</code>
     <code class="o">+</code> <code class="nx">strings</code><code class="p">[</code><code class="mi">3</code><code class="p">];</code>
<code class="p">}</code>

<code class="c1">// Define the template as a tagged template literal string</code>
<code class="kr">const</code> <code class="nx">template</code> <code class="o">=</code> <code class="p">(</code><code class="nx">caption</code><code class="p">,</code> <code class="nx">src</code><code class="p">,</code> <code class="nx">metadata</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">photoTemplate</code><code class="sb">`&lt;li class="photo"&gt;</code>
<code class="sb">  &lt;h2&gt;</code><code class="si">${</code><code class="nx">caption</code><code class="si">}</code><code class="sb">&lt;/h2&gt;</code>
<code class="sb">  &lt;img class="source" src="</code><code class="si">${</code><code class="nx">src</code><code class="si">}</code><code class="sb">"/&gt;</code>
<code class="sb">  &lt;div class="metadata"&gt;</code>
<code class="sb">    </code><code class="si">${</code><code class="nx">metadata</code><code class="si">}</code><code class="sb"/>
<code class="sb">  &lt;/div&gt;</code>
<code class="sb">&lt;/li&gt;`</code><code class="p">;</code>

<code class="c1">// Loop through the data and populate the template</code>
<code class="kr">const</code> <code class="nx">photoList</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s1">'ul'</code><code class="p">);</code>
<code class="nx">photos</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">photo</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">photoItem</code> <code class="o">=</code> <code class="nx">template</code><code class="p">(</code><code class="nx">photo</code><code class="p">.</code><code class="nx">caption</code><code class="p">,</code> <code class="nx">photo</code><code class="p">.</code><code class="nx">src</code><code class="p">,</code> <code class="nx">photo</code><code class="p">.</code><code class="nx">metadata</code><code class="p">);</code>
  <code class="nx">photoList</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">+=</code> <code class="nx">photoItem</code><code class="p">;</code>
<code class="p">});</code>

<code class="c1">// Insert the populated template into the DOM</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">photoList</code><code class="p">);</code></pre></div>
<div id="underscore_js" data-type="example">
<h5><span class="label">Example 8-2. </span>Lodash.js templates</h5>

<pre data-type="programlisting" data-code-language="html"><code class="p">&lt;</code><code class="nt">li</code> <code class="na">class</code><code class="o">=</code><code class="s">"photo"</code><code class="p">&gt;</code>
  <code class="p">&lt;</code><code class="nt">h2</code><code class="p">&gt;</code><code class="err">&lt;</code>%- caption %&gt;<code class="p">&lt;/</code><code class="nt">h2</code><code class="p">&gt;</code>
  <code class="p">&lt;</code><code class="nt">img</code> <code class="na">class</code><code class="o">=</code><code class="s">"source"</code> <code class="na">src</code><code class="o">=</code><code class="s">"&lt;%- src %&gt;"</code><code class="p">/&gt;</code>
  <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"metadata"</code><code class="p">&gt;</code>
    <code class="err">&lt;</code>%- metadata %&gt;
  <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>
<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code></pre></div>

<p>Note that templates are not themselves Views. A View is an object that observes a Model and keeps the visual representation up to date. A template <em>might</em> be a declarative way to specify part or even all of a View object so that the framework may generate it from the template specification.</p>

<p>It is also worth noting that in classical web development,<a data-type="indexterm" data-primary="Views" data-secondary="about" data-tertiary="new View without refresh" id="idm45017698782976"/><a data-type="indexterm" data-primary="browsers" data-secondary="new View without refresh" id="idm45017698781888"/> navigating between independent Views required the use of a page refresh. In single-page JavaScript applications, however, once data is fetched from a server, it can be dynamically rendered in a new View within the same page without any such refresh being necessary. The navigation role thus falls to a router, which assists in managing application state (e.g., allowing users to bookmark a particular View they have navigated to). However, as routers are neither a part of MVC nor present in every MVC-like framework, I will not be going into them in greater detail in this section.</p>

<p>To summarize, Views represent our application data visually, and templates may be used to generate Views. Modern templating techniques, like tagged template literals, provide a clean, efficient, and maintainable way to create dynamic HTML content in JavaScript applications.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Controllers"><div class="sect2" id="controllers">
<h2>Controllers</h2>

<p>Controllers are intermediaries between<a data-type="indexterm" data-primary="Models" data-secondary="Views" data-tertiary="Controllers as intermediaries" id="idm45017698778896"/><a data-type="indexterm" data-primary="Views" data-secondary="Controllers as intermediaries" id="idm45017698777680"/><a data-type="indexterm" data-primary="Controllers between Models and Views" id="idm45017698776768"/> Models and Views, which are classically responsible for updating the Model when the user manipulates the View. They manage the logic and coordination between Models and Views in an application.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="What Does MVC Give Us?"><div class="sect1" id="what-does-mvc-give-us">
<h1>What Does MVC Give Us?</h1>

<p>This separation of concerns in MVC facilitates simpler modularization of an application’s functionality and enables:<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="benefits of" id="idm45017698774176"/><a data-type="indexterm" data-primary="decoupling" data-secondary="Views" data-tertiary="Models in MVC pattern" id="idm45017698733552"/><a data-type="indexterm" data-primary="modules" data-secondary="MVC facilitating modularization" id="idm45017698732464"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="decoupling Views from Models" id="idm45017698731616"/></p>

<ul>
<li>
<p>Easier overall maintenance. When the application needs to be updated, it is obvious whether the changes are data-centric, meaning changes to Models and possibly Controllers, or merely visual, meaning changes to Views.</p>
</li>
<li>
<p>Decoupling Models and Views means that writing unit tests for business logic is significantly more straightforward.</p>
</li>
<li>
<p>Duplication of low-level Model and Controller code (i.e., what we may have been using instead) is eliminated across the application.</p>
</li>
<li>
<p>Depending on the size of the application and the separation of roles, this modularity allows developers responsible for core logic and developers working on the UIs to work simultaneously.</p>
</li>
</ul>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Smalltalk-80 MVC in JavaScript"><div class="sect1" id="smalltalk-80-mvc-in-javascript">
<h1>Smalltalk-80 MVC in JavaScript</h1>

<p>Most modern-day JavaScript frameworks attempt<a data-type="indexterm" data-primary="Smalltalk-80" data-secondary="Maria.js as faithful MVC implementation" id="idm45017698724960"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="Smalltalk-80 MVC" data-tertiary="Maria.js as faithful implementation" id="idm45017698723920"/><a data-type="indexterm" data-primary="Maria.js" id="idm45017698722672"/><a data-type="indexterm" data-primary="Michaux, Peter" id="idm45017698722000"/> to evolve the MVC paradigm to fit the differing needs of web application development. However, there has been one framework that tried to adhere to the pure form of the pattern found in Smalltalk-80.  <a href="https://oreil.ly/rNJLu">Maria.js</a> by Peter Michaux offers an implementation that is faithful to MVC’s origins: Models are Models, Views are Views, and Controllers are nothing but Controllers. While some developers might feel an MV* framework should address more concerns, this is a valuable reference to be aware of in case you would like a JavaScript implementation of the original MVC.</p>
<aside data-type="sidebar" epub:type="sidebar" class="less_space pagebreak-before"><div class="sidebar" id="idm45017698720416">
<h1>An Alternate View of MVC</h1>
<p>At this point in the book, we should have a basic understanding of the MVC pattern, but there’s still some fascinating information about it worth noting.</p>

<p>The GoF does not refer to MVC as a <a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="class set perspective" id="idm45017698717840"/><a data-type="indexterm" data-primary="classes" data-secondary="MVC as set of classes to build UI" id="idm45017698716800"/><a data-type="indexterm" data-primary="Design Patterns: Elements of Reusable Object-Oriented Software (Gamma, Helm, Johnson, and Vlissides)" data-secondary="MVC" data-tertiary="as set of classes to build UI" id="idm45017698715840"/><a data-type="indexterm" data-primary="Gamma, Erich" id="idm45017698714528"/><a data-type="indexterm" data-primary="Helm, Richard" id="idm45017698713856"/><a data-type="indexterm" data-primary="Johnson, Ralph" id="idm45017698713184"/><a data-type="indexterm" data-primary="Vlissides, John" id="idm45017698712512"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="about" data-tertiary="variation of Observer, Strategy, and Composite" id="idm45017698711840"/>design pattern but considers it <em>a set of classes to build a UI</em>. In their view, it’s a variation of three classical design patterns: the Observer, Strategy, and Composite patterns. Depending on how MVC has been implemented in a framework, it may also use the Factory and Template patterns. The GoF book mentions these patterns as useful extras when working with MVC.</p>

<p>As we have discussed, Models represent application data, while Views represent what the user is presented with on-screen. As such, MVC relies on the Observer pattern for some of its core communication (something that, surprisingly, isn’t covered in many articles about the MVC pattern). When a Model is changed, it notifies its observers (Views) that something has been updated—this is perhaps the most crucial relationship in MVC. The observer nature of this relationship also facilitates multiple Views being attached to the same Model.</p>

<p>For developers interested in the decoupled<a data-type="indexterm" data-primary="decoupling" data-secondary="Views" data-tertiary="one-to-many relationships" id="idm45017698709440"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="decoupling Views from Models" data-tertiary="one-to-many relationships" id="idm45017698708144"/> nature of MVC, one of the goals of the pattern is to help define one-to-many relationships between a topic and its observers. When a topic changes, its observers are updated. Views and Controllers have a slightly different relationship. Controllers facilitate Views to respond to user input and are an example of the Strategy pattern.</p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary of MVC"><div class="sect1" id="idm45017698706496">
<h1>Summary of MVC</h1>

<p>Having reviewed the classical MVC pattern, we should now understand how it allows us to cleanly separate concerns in an application. We should also appreciate how JavaScript MVC frameworks may differ in their interpretation of the MVC pattern. Although quite open to variation, they still share some fundamental concepts the original pattern offers.</p>

<p>When reviewing a new JavaScript MVC/MV* framework, remember: it can be helpful to step back and examine how it has opted to approach the architecture (specifically, how it supports implementing Models, Views, Controllers, or other alternatives), as this can better help us grok the best way to use the framework.<a data-type="indexterm" data-startref="ch08-mvc" id="idm45017698704816"/><a data-type="indexterm" data-startref="ch08-mvc2" id="idm45017698704112"/><a data-type="indexterm" data-startref="ch08-mvc3" id="idm45017698703440"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="MVP"><div class="sect1" id="mvp">
<h1>MVP</h1>

<p>Model-View-Presenter (MVP) is a derivative<a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" id="ch08-mvp"/><a data-type="indexterm" data-primary="MV* patterns" data-secondary="MVP" id="ch08-mvp2"/><a data-type="indexterm" data-primary="architectural patterns" data-secondary="MVP" id="ch08-mvp3"/><a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="about" id="idm45017698697104"/><a data-type="indexterm" data-primary="Taligent" id="idm45017698696144"/> of the MVC design pattern that focuses on improving presentation logic. It originated at a company named <a href="https://oreil.ly/sKiE8">Taligent</a> in the early 1990s while they were working on a Model for a C++ CommonPoint 
<span class="keep-together">environment.</span> While both MVC and MVP target the separation of concerns across multiple components, there are some fundamental differences between them.</p>

<p>Here, we will focus on the version of MVP most suitable for web-based architectures.</p>








<section data-type="sect2" data-pdf-bookmark="Models, Views, and Presenters"><div class="sect2" id="models-views-presenters">
<h2>Models, Views, and Presenters</h2>

<p>The P in MVP stands for Presenter.<a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="Presenters" id="idm45017698691712"/><a data-type="indexterm" data-primary="Presenters in Views" id="idm45017698690672"/><a data-type="indexterm" data-primary="Views" data-secondary="Presenters" id="idm45017698690000"/><a data-type="indexterm" data-primary="decoupling" data-secondary="Views" data-tertiary="Presenters in MVP pattern" id="idm45017698689056"/> It’s a component that contains the UI business logic for the View. Unlike MVC, invocations from the View are delegated to the Presenters, which are decoupled from the View and instead talk to it through an interface. This has many advantages, such as being able to mock Views in unit tests (MVP pattern) (<a data-type="xref" href="#MVP_pattern">Figure 8-2</a>).</p>

<figure><div id="MVP_pattern" class="figure">
<img src="Images/ljd2_0802.png" alt="ljd2 0802" width="811" height="451"/>
<h6><span class="label">Figure 8-2. </span>MVP pattern</h6>
</div></figure>

<p>The most common implementation of MVP is one<a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="passive View" id="idm45017698684416"/><a data-type="indexterm" data-primary="Views" data-secondary="passive View" id="idm45017698683424"/> that uses a passive View (a View which is, for all intents and purposes, “dumb”), containing little to no logic. <a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="MVC versus" id="idm45017698682224"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="MVP versus" id="idm45017698681264"/>MVC and MVP are different because the roles played by C and P are diverse. In MVP, the P observes Models and updates Views when Models change. The P effectively binds Models to Views, a Controller’s responsibility in MVC.</p>

<p>Solicited by a View, Presenters perform any work related to user requests and pass data back to them. In this respect, they retrieve data, manipulate it, and determine how the data should be displayed in the View. In some implementations, the Presenter also interacts with a service layer to persist data (Models). Models may trigger events, but it’s the Presenter’s role to subscribe to them so that it can update the View. In this passive architecture, we have no concept of direct data binding. Views expose setters that Presenters can use to set data.</p>

<p>The benefit of this change from MVC<a data-type="indexterm" data-primary="testing" data-secondary="MVP increasing testability over MVC" id="idm45017698679376"/> is that it increases our application’s testability and provides a cleaner separation between the View and the Model. This isn’t, however, without its costs, as the lack of data-binding support in the pattern can often mean having to take care of this task separately.</p>

<p class="less_space pagebreak-before">Although a common implementation of a <a href="https://oreil.ly/SQUNj">passive View</a> is for the View to implement an interface, there are variations on it, including the use of events that can decouple the View from the Presenter a little more. As we don’t have the interface construct in JavaScript, we use more of a protocol than an explicit interface here. It’s technically still an API, and it’s probably fair for us to refer to it as an interface from that 
<span class="keep-together">perspective.</span></p>

<p>There is also a <a href="https://oreil.ly/RZM34">Supervising Controller</a> variation of MVP,<a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="Supervising Controller variation" id="idm45017698675152"/> closer to the MVC and <a href="https://oreil.ly/f5apN">MVVM</a> patterns, as it provides data binding from the Model directly from the View.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="MVP or MVC?"><div class="sect2" id="mvp-or-mvc">
<h2>MVP or MVC?</h2>

<p>Now that we’ve discussed both MVP and MVC, how do you select the most appropriate pattern for your application?<a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="MVC versus" data-tertiary="which to use" id="idm45017698671216"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="MVP versus" data-tertiary="which to use" id="idm45017698670000"/></p>

<p>MVP is generally used in enterprise-level applications where it’s necessary to reuse as much presentation logic as possible. Applications with very complex Views and a great deal of user interaction may find that MVC doesn’t quite fit the bill here, as solving this problem may mean heavily relying on multiple Controllers. In MVP, all of this complex logic can be encapsulated in a Presenter, significantly simplifying maintenance.</p>

<p>As MVP Views are defined through an interface, and the interface is technically the only point of contact between the system and the View (other than a Presenter), this pattern also allows developers to write presentation logic without needing to wait for designers to produce layouts and graphics for the application.</p>

<p>MVP may be easier to unit test than MVC, depending on the implementation. The reason often cited for this is that you can use the Presenter as a complete mock of the UI so it can be unit-tested independent of other components. In my experience, this depends on the languages we are implementing MVP in (there’s quite a difference between opting for MVP for a JavaScript project over one for, say, ASP.NET).</p>

<p>The underlying concerns we may have with MVC will likely hold for MVP, given that the differences between them are mainly semantic. As long as we cleanly separate concerns into Models, Views, and Controllers (or Presenters), we should achieve most of the same benefits regardless of the variation we choose.</p>

<p>Few, if any, JavaScript architectural frameworks claim to implement the MVC or MVP patterns in their classical form. Many JavaScript developers don’t view MVC and MVP as mutually exclusive (we are more likely to see MVP strictly implemented in web frameworks such as ASP.NET or Google Web Toolkit). This is because we can have additional Presenter/View logic in our application and still consider it a flavor of MVC.<a data-type="indexterm" data-startref="ch08-mvp" id="idm45017698666720"/><a data-type="indexterm" data-startref="ch08-mvp2" id="idm45017698666016"/><a data-type="indexterm" data-startref="ch08-mvp3" id="idm45017698665344"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="MVVM"><div class="sect1" id="mvvm">
<h1>MVVM</h1>

<p>MVVM (Model-View-ViewModel) is an <a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" id="ch08-mvvm"/><a data-type="indexterm" data-primary="MV* patterns" data-secondary="MVVM" id="ch08-mvvm2"/><a data-type="indexterm" data-primary="architectural patterns" data-secondary="MVVM" id="ch08-mvvm3"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="about" id="idm45017698658896"/><a data-type="indexterm" data-primary="decoupling" data-secondary="UIs" data-tertiary="MVVM pattern" id="idm45017698657936"/>architectural pattern based on MVC and MVP, which attempts to more clearly separate the development of UIs from that of the business logic and behavior in an application. To this end, many implementations of this pattern make use of declarative data bindings to allow a separation of work on Views from other layers.</p>

<p>This facilitates UI and development work occurring almost simultaneously within the same codebase. UI developers write bindings to the ViewModel within their document markup (HTML), whereas developers working on the logic for the application maintain the Model and ViewModel (<a data-type="xref" href="#MVVM_pattern">Figure 8-3</a>).</p>

<figure><div id="MVVM_pattern" class="figure">
<img src="Images/ljd2_0803.png" alt="ljd2 0803" width="1005" height="477"/>
<h6><span class="label">Figure 8-3. </span>MVVM pattern</h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="History"><div class="sect2" id="history-1">
<h2>History</h2>

<p>MVVM (by name) was initially defined<a data-type="indexterm" data-primary="history" data-secondary="MVVM" id="idm45017698651472"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="history" id="idm45017698650496"/> by Microsoft for use with <a href="https://oreil.ly/1_I11">Windows Presentation Foundation (WPF)</a> and <a href="https://oreil.ly/ve1Oh">Silverlight</a>, having been officially announced in 2005 by John Grossman in a blog post about Avalon (the codename for WPF). It also found some popularity in the Adobe Flex community as an alternative to using MVC.</p>

<p>Before Microsoft adopted the MVVM name, there was a movement in the community to go from MVP to MVPM: Model-View PresentationModel. <a data-type="indexterm" data-primary="MVPM (Model-View PresentationModel)" id="idm45017698647552"/><a data-type="indexterm" data-primary="PresentationModels" id="idm45017698646784"/><a data-type="indexterm" data-primary="Fowler, Martin" id="idm45017698646112"/>Martin Fowler wrote an <a href="https://oreil.ly/78R8q">article on PresentationModels back in 2004</a> for those interested in reading more about it. The idea of a PresentationModel had been around much longer than this article. However, it was considered a significant break for the concept and helped popularize it.</p>
<p class="fix_tracking">
There was quite a lot of uproar in the “alt.net” circles after Microsoft announced MVVM as an alternative to MVPM. Many claimed the company’s dominance in the GUI world allowed them to take over the community, renaming existing concepts as they pleased for marketing purposes. A progressive crowd recognized that while MVVM and MVPM were effectively the same ideas, they came in slightly different packages.
</p>

<p>MVVM was originally implemented in JavaScript in the form of structural frameworks such as KnockoutJS, Kendo MVVM, and Knockback.js, with an overall positive response from the community.</p>

<p>Let’s now review the three components that compose MVVM:</p>
<dl>
<dt>Model</dt>
<dd>
<p>Representing the domain-specific information</p>
</dd>
<dt>View</dt>
<dd>
<p>The UI</p>
</dd>
<dt>ViewModel</dt>
<dd>
<p>An interface between the Model and the View</p>
</dd>
</dl>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Model"><div class="sect2" id="model">
<h2>Model</h2>

<p>As with other members of the MV* family,<a data-type="indexterm" data-primary="Models" data-secondary="about" data-tertiary="MVVM Model" id="idm45017698636464"/><a data-type="indexterm" data-primary="Models" data-secondary="business data primarily" id="idm45017698635216"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="Model" id="idm45017698634272"/> the Model in MVVM represents domain-specific data or information with which our application will work. A typical example of domain-specific data might be a user account (e.g., name, avatar, email) or a music track (e.g., title, year, album).</p>

<p>Models hold information but typically<a data-type="indexterm" data-primary="Models" data-secondary="information not behavior except validation" id="idm45017698632848"/> don’t handle behavior. They don’t format information or influence how data appears in the browser, as this isn’t their responsibility. Instead, the View governs data formatting, while the behavior is considered business logic that you should encapsulate in another layer that interacts with the Model: the ViewModel.</p>

<p>The only exception to this rule tends<a data-type="indexterm" data-primary="validation of data as rare Model behavior" id="idm45017698631264"/> to be validation, and it’s acceptable for Models to validate data used to define or update existing Models (e.g., does an email address being input meet the requirements of a particular regular expression?).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="View"><div class="sect2" id="view">
<h2>View</h2>

<p>As with MVC, the View is the only part<a data-type="indexterm" data-primary="Models" data-secondary="Views" id="idm45017698628336"/><a data-type="indexterm" data-primary="Views" id="idm45017698627360"/><a data-type="indexterm" data-primary="ViewModel" data-secondary="View as state of" id="idm45017698626688"/><a data-type="indexterm" data-primary="Models" data-secondary="Views" data-tertiary="ViewModel state" id="idm45017698625744"/><a data-type="indexterm" data-primary="Views" data-secondary="ViewModel" data-tertiary="View as state of" id="idm45017698624528"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="View" id="idm45017698623312"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="ViewModel" id="idm45017698622352"/> of the application that users interact with. The View is an interactive UI that represents the state of a ViewModel. <a data-type="indexterm" data-primary="Views" data-secondary="active View" id="idm45017698621136"/>In this sense, the View is considered active rather than passive, which is also true for MVC and MVP Views. In MVC, MVP, and MVVM, a View can also be passive, but what does this mean?</p>

<p>A passive View only outputs a display<a data-type="indexterm" data-primary="Views" data-secondary="passive View" id="idm45017698619808"/> and does not accept any user input. Such a View may also have no real knowledge of the Models in our application and could be manipulated by a Presenter. MVVM’s active View contains the data bindings, events, and behaviors, which requires an understanding of the ViewModel. Although these behaviors can be mapped to properties, the View is still responsible for handling events from the ViewModel.</p>

<p>It’s important to remember that the View isn’t responsible for handling state; it keeps this in sync with the ViewModel.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="ViewModel"><div class="sect2" id="viewmodel">
<h2>ViewModel</h2>

<p>The ViewModel can be considered<a data-type="indexterm" data-primary="Views" data-secondary="ViewModel" id="idm45017698616416"/><a data-type="indexterm" data-primary="ViewModel" id="idm45017698615440"/><a data-type="indexterm" data-primary="Controllers between Models and Views" data-secondary="ViewModel" id="idm45017698614768"/> a specialized Controller that acts as a data converter. It changes Model information into View information, passing commands from the View to the Model.</p>

<p>For example, let us imagine that we have a Model containing a <code>date</code> attribute in UNIX format (e.g., 1333832407). Rather than our Models being aware of a user’s View of the date (e.g., 04/07/2012 @ 5:00 pm), where it would be necessary to convert the address to its display format, our Model holds the raw format of the data. Our View contains the formatted date, and our ViewModel acts as a middleman between the two.</p>

<p>In this sense, the ViewModel can be seen as more of a Model than a View, but it does handle most of the View’s display logic. The ViewModel may also expose methods for helping to maintain the View’s state, update the Model based on the actions on a View, and trigger events on the View.</p>

<p>In summary, the ViewModel sits behind our UI layer. It exposes data needed by a View (from a Model) and can be the source the View goes to for both data and actions.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Recap: The View and the ViewModel"><div class="sect2" id="recap-the-view-and-the-viewmodel">
<h2>Recap: The View and the ViewModel</h2>

<p>Views and ViewModels communicate<a data-type="indexterm" data-primary="Views" data-secondary="ViewModel" data-tertiary="data bindings and events" id="idm45017698609984"/><a data-type="indexterm" data-primary="events" data-secondary="Views and ViewModels" id="idm45017698608672"/><a data-type="indexterm" data-primary="ViewModel" data-secondary="data bindings and events" id="idm45017698607728"/> using data bindings and events. As we saw in our initial ViewModel example, the ViewModel doesn’t just expose Model attributes but also provides access to other methods and features, such as validation.</p>

<p>Our Views handle their own UI events, mapping them to the ViewModel as necessary. Models and attributes on the ViewModel are synchronized and updated via two-way data binding.</p>

<p>Triggers (data triggers) also allow us to react further to changes in the state of our Model attributes.<a data-type="indexterm" data-primary="triggers for changes in state" id="idm45017698605712"/><a data-type="indexterm" data-primary="Models" data-secondary="triggers for changes in state" id="idm45017698604992"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="ViewModel Versus Model"><div class="sect2" id="viewmodel-Vs-model">
<h2>ViewModel Versus Model</h2>

<p>While the ViewModel may be entirely<a data-type="indexterm" data-primary="Views" data-secondary="ViewModel" data-tertiary="Model versus" id="idm45017698602208"/><a data-type="indexterm" data-primary="Models" data-secondary="Views" data-tertiary="ViewModel versus Model" id="idm45017698600960"/><a data-type="indexterm" data-primary="ViewModel" data-secondary="Model versus" id="idm45017698599744"/> responsible for the Model in MVVM, there are some subtleties with this relationship worth noting. The ViewModel can expose a Model or Model attributes for data binding and contain interfaces for fetching and manipulating properties exposed in the View.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Pros and Cons"><div class="sect1" id="pros-and-cons">
<h1>Pros and Cons</h1>

<p>We now hopefully have a better appreciation for what MVVM is and how it works. Let’s review the advantages and disadvantages of employing this pattern.</p>








<section data-type="sect2" data-pdf-bookmark="Advantages"><div class="sect2" id="advantages-2">
<h2>Advantages</h2>

<ul>
<li>
<p>MVVM facilitates easier parallel development of a UI and the building blocks that power it.<a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="advantages" id="idm45017698594064"/></p>
</li>
<li>
<p>MVVM abstracts the View and thus reduces the quantity of business logic (or glue) required in the code behind it.</p>
</li>
<li>
<p>The ViewModel can be easier to unit test  than in the case of event-driven code.</p>
</li>
<li>
<p>The ViewModel (being more Model than View) can be tested without UI automation and interaction concerns.</p>
</li>
</ul>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Disadvantages"><div class="sect2" id="disadvantages-2">
<h2>Disadvantages</h2>

<ul>
<li>
<p>For simpler UIs, MVVM can be overkill.<a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="disadvantages" id="idm45017698587584"/></p>
</li>
<li>
<p>While data bindings can be declarative and nice to work with, they can be harder to debug than imperative code, where we simply set breakpoints.</p>
</li>
<li>
<p>Data bindings in nontrivial applications can create a lot of bookkeeping. We also don’t want to end up in a situation where bindings are heavier than the objects being bound.</p>
</li>
<li>
<p>In larger applications, it can be more challenging to design the ViewModel up-front to get the necessary generalization.</p>
</li>
</ul>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="MVC Versus MVP Versus MVVM"><div class="sect1" id="mvc-vs.-mvp-vs.-mvvm">
<h1>MVC Versus MVP Versus MVVM</h1>

<p>Both MVP and MVVM are derivatives of MVC.<a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="MVP versus MVVM versus" id="idm45017698581664"/><a data-type="indexterm" data-primary="MVP (Model-View-Presenter) pattern" data-secondary="MVC versus MVVM versus" id="idm45017698580672"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="MVC versus MVP versus" id="idm45017698579712"/><a data-type="indexterm" data-primary="dependencies" data-secondary="MVC versus MVP versus MVVM" id="idm45017698578752"/> The key difference between MVC and its derivatives is the dependency each layer has on other layers and how tightly bound they are to each other.</p>

<p>In MVC, the View sits on top of our architecture with the Controller beside it. Models sit below the Controller, so our Views know about our Controllers, and Controllers know about Models. Here, our Views have direct access to Models. Exposing the complete Model to the View, however, may have security and performance costs, depending on the complexity of our application. MVVM attempts to avoid these issues.</p>

<p>In MVP, the role of the Controller is replaced with a Presenter. Presenters sit at the same level as Views, listening to events from both the View and Model and mediating the actions between them. Unlike MVVM, there isn’t a mechanism for binding Views to ViewModels, so we instead rely on each View implementing an interface allowing the Presenter to interact with the View.</p>

<p>MVVM consequently allows us to create View-specific subsets of a Model, which can contain state and logic information, avoiding exposing the entire Model to a View. Unlike MVP’s Presenter, a ViewModel is not required to reference a View. The View can bind to properties on the ViewModel, in turn exposing data contained in Models to the View. As we’ve mentioned, the abstraction of the View means there is less logic required in the code behind it.</p>

<p>However, one of the downsides to this is that a level of interpretation is needed between the ViewModel and the View, which can have performance costs. The complexity of this interpretation can also vary: it can be as simple as copying data or as complex as manipulating it to a form we would like the View to see. MVC doesn’t have this problem, as the whole Model is readily available, and such manipulation can be avoided.<a data-type="indexterm" data-startref="ch08-mvvm" id="idm45017698575872"/><a data-type="indexterm" data-startref="ch08-mvvm2" id="idm45017698575168"/><a data-type="indexterm" data-startref="ch08-mvvm3" id="idm45017698574496"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Modern MV* Patterns"><div class="sect1" id="modern-mv-patterns">
<h1>Modern MV* Patterns</h1>

<p>Frameworks such as Backbone and KnockoutJS <a data-type="indexterm" data-primary="MV* patterns" data-secondary="modern MV* patterns" id="idm45017698571920"/><a data-type="indexterm" data-primary="Backbone" id="idm45017698570944"/><a data-type="indexterm" data-primary="KnockoutJS" id="idm45017698570272"/>used initially to implement MVC and MVVM are no longer popular or updated. They have made way for other libraries and frameworks such as React, Vue.js, Angular, Solid, and many others. Understanding architecture from a Backbone or KnockoutJS perspective may still be relevant because it gives us a sense of where we came from and what changed with modern frameworks.</p>

<p>MV* patterns can always be implemented<a data-type="indexterm" data-primary="JavaScript" data-secondary="MV* pattern implementation" id="idm45017698569088"/><a data-type="indexterm" data-primary="MVC (Model-View-Controller) pattern" data-secondary="ToDo list in vanilla JavaScript" id="idm45017698568048"/> using the latest vanilla JavaScript as illustrated by this example of a list: <a href="https://oreil.ly/QVYPY">ToDo list MVC application</a>. However, developers generally prefer libraries and frameworks for building larger, scalable applications.</p>

<p>Technically modern libraries and frameworks<a data-type="indexterm" data-primary="React (React.js)" data-secondary="View or presentation layer" id="idm45017698565712"/><a data-type="indexterm" data-primary="Vue.js" id="idm45017698564672"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) pattern" data-secondary="ViewModel" data-tertiary="Vue.js as" id="idm45017698564000"/> such as React or Vue.js form the View or the presentation layer of applications. In most cases, the frameworks are flexible about how you implement your Model and manage the state in your applications. Vue officially claims to be the <a href="https://oreil.ly/UqbVh">ViewModel</a> layer in MVVM. Here are some additional thoughts on MV* in React.</p>








<section data-type="sect2" data-pdf-bookmark="MV* and React.js"><div class="sect2" id="idm45017698561856">
<h2>MV* and React.js</h2>

<p>To be very clear, React is not an MVC framework.<a data-type="indexterm" data-primary="MV* patterns" data-secondary="React.js and" id="idm45017698560288"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="MV* patterns and" id="idm45017698559312"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="about" id="idm45017698558368"/> It is a JavaScript library for building UIs and is often used for creating SPAs.</p>

<p class="less_space pagebreak-before">React isn’t considered MVC because it doesn’t map well with how it has been conceived and used on the backend. React is a rendering library that ideally takes care of the View layer. It doesn’t have a central Controller as an orchestrator/router, similar to MVC.</p>

<p>React follows a declarative approach to programming—you describe your application’s desired state, and React renders the appropriate Views based on that state. You don’t use React in an MVC design pattern simply because, with React, the server does not provide a “View” to the browser but “data.” React parses the data on the browser to generate the actual Views. In this sense, you could say that React is a “V” (View) in the MVC pattern, but it is not an MVC framework in the traditional sense.</p>

<p>Another way of looking at it is that React slices the MVC vertically (by concern) instead of horizontally (by technology). You could say Components in React started as small vertically sliced encapsulated MVCs: containing state (Model), rendering (View), and control-flow logic (a localized mini-Controller).</p>

<p>These days, with a lot of component logic extracted into Hooks, you can see Components as Views and Hooks as Controllers. You can also consider “Model ⇒ Suspense resource, View ⇒ Component, Controller ⇒ Hook” if it helps, but don’t take it too seriously.</p>

<p>Next.js is a framework built on top of React<a data-type="indexterm" data-primary="React (React.js)" data-secondary="Next.js for server-rendered applications" id="idm45017698554608"/><a data-type="indexterm" data-primary="Next.js" data-secondary="about" id="idm45017698553536"/> that makes it easy to construct server-rendered React applications. It includes features such as automatic code splitting, optimized performance, and easy deployment to production. Like React, Next.js is not an MVC framework, but when you use server-side rendering (SSR) or static site generators (SSGs), it can be like MVC. When Next.js acts as a backend, interacting with a database and providing the View to prerender it, then yes, it’s MVC that is hydrated afterward with the reactive functionalities.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45017698552336">
<h1>Summary</h1>

<p>We have now analyzed the concepts of Model, View, Controller, Presenter, and ViewModel and where they fit in different architectural patterns. Today, we may not see these patterns applied as-is on the frontend where JavaScript is most relevant. However, they may help us figure out the overall architecture of the web application. They may also be applied to individual frontend components where the application sliced vertically may have multiple components, each with a ViewModel or Model to power the View.</p>

<p>By this point, we have now covered a good mix of patterns at the micro (class) as well as macro (architecture) levels. The next chapter will help us design the application flow for a modern JavaScript application. We will look at asynchronous programming patterns that can help us better manage long-running tasks on browsers.</p>
</div></section>
</div></section></div></body></html>