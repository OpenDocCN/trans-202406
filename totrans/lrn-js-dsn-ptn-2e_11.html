<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Namespacing Patterns"><div class="chapter" id="namespacing-patterns">
<h1><span class="label">Chapter 11. </span>Namespacing Patterns</h1>


<p>In this chapter, we will explore patterns<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="about namespaces" id="idm45017692707456"/> for namespacing in JavaScript. Namespaces can be considered a logical grouping of code units under a unique identifier. You can reference the identifier in many namespaces, and each identifier can contain a hierarchy of nested (or sub) namespaces.</p>

<p>In application development, we employ namespaces for many important reasons. JavaScript namespaces help us avoid <em>collisions</em> with other objects or variables in the global namespace. They’re also handy for helping organize blocks of functionality in a codebase so that it can be more easily referenced and used.</p>

<p>Namespacing any serious script or application is critical because it’s crucial to safeguard our code from breaking in the event of another script on the page using the <em>same</em> variable or method names we are. With the number of <em>third-party</em> tags regularly injected into pages, this can be a common problem we all need to tackle at some point in our careers. As a well-behaved “citizen” of the global namespace, it’s also imperative that we try our best not to prevent other developers’ scripts from executing due to the same issues.</p>

<p>While JavaScript doesn’t have built-in <a data-type="indexterm" data-primary="namespacing patterns" data-secondary="about namespaces" data-tertiary="JavaScript support" id="idm45017692703696"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="namespace support" id="idm45017692702448"/>support for namespaces like other languages, it does have objects and closures that you can use to achieve a similar effect.</p>






<section data-type="sect1" data-pdf-bookmark="Namespacing Fundamentals"><div class="sect1" id="namespacing-fundamentals">
<h1>Namespacing Fundamentals</h1>

<p>You can find namespaces in almost any serious<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="fundamentals of namespacing" data-tertiary="about" id="idm45017692699680"/> JavaScript application. Unless we’re working with a simple code snippet, we must do our best to ensure that we’re implementing namespacing correctly, as it’s not just easy to pick up; it’ll also avoid third-party code destroying our own. The patterns we’ll be examining in this section are:</p>

<ul class="less_space pagebreak-before">
<li>
<p>Single global variables</p>
</li>
<li>
<p>Prefix namespacing</p>
</li>
<li>
<p>Object literal notation</p>
</li>
<li>
<p>Nested namespacing</p>
</li>
<li>
<p>Immediately invoked function</p>
</li>
<li>
<p>Expressions</p>
</li>
<li>
<p>Namespace injection</p>
</li>
</ul>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Single Global Variables"><div class="sect1" id="single-global-variables">
<h1>Single Global Variables</h1>

<p>One popular pattern for namespacing<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="fundamentals of namespacing" data-tertiary="single global variables" id="idm45017692689360"/><a data-type="indexterm" data-primary="single global variable namespacing pattern" id="idm45017692688272"/> in JavaScript is opting for a single global variable as our primary object of reference. Here’s a skeleton implementation of this where we return an object with functions and properties:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">myUniqueApplication</code> <code class="o">=</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">function</code> <code class="nx">myMethod</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// code</code>
    <code class="k">return</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">myMethod</code><code class="p">,</code>
  <code class="p">};</code>
<code class="p">})();</code>

<code class="c1">// Usage</code>
<code class="nx">myUniqueApplication</code><code class="p">.</code><code class="nx">myMethod</code><code class="p">();</code>

<code class="c1">// In this updated example, we use an immediately invoked function expression</code>
<code class="c1">// (IIFE) to create a unique namespace for our application, which is stored in</code>
<code class="c1">// the myUniqueApplication variable. The IIFE returns an object with functions</code>
<code class="c1">// and properties, and we can access these using dot notation</code>
<code class="c1">// (e.g., myUniqueApplication.myMethod()).</code></pre>

<p>Although this works for certain situations, the biggest challenge with the single global variable pattern is ensuring that no one else has used the same global variable name as we have on the page.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Prefix Namespacing"><div class="sect1" id="prefix-namespacing">
<h1>Prefix Namespacing</h1>

<p>One solution to the problem mentioned,<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="fundamentals of namespacing" data-tertiary="prefix namespacing" id="idm45017692651328"/><a data-type="indexterm" data-primary="prefix namespacing" id="idm45017692650112"/><a data-type="indexterm" data-primary="Michaux, Peter" id="idm45017692649440"/> as noted by <a href="https://oreil.ly/o2dgF">Peter Michaux</a>, is to use prefix namespacing. It’s a simple concept at heart, but the idea is we select a unique prefix namespace we wish to use (in this example, <code>myApplication_</code>) and then define any methods, variables, or other objects after the prefix as follows:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">myApplication_propertyA</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">myApplication_propertyB</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">function</code> <code class="nx">myApplication_myMethod</code><code class="p">(){</code>   <code class="c1">//...</code>
<code class="p">}</code></pre>

<p>This effectively decreases the chances of a particular variable existing in the global scope, but remember that a uniquely named object can have the same effect.</p>

<p>This aside, the biggest issue with the pattern is that it can result in many global objects once our application grows. There is also a heavy reliance on our prefix not being used by any other developers in the global namespace, so be careful if opting to use this.</p>

<p>For more on Peter’s views about the single global variable pattern,  <a href="https://oreil.ly/o2dgF">read his excellent post</a>.<a data-type="indexterm" data-primary="Michaux, Peter" id="idm45017692592880"/><a data-type="indexterm" data-primary="single global variable namespacing pattern" data-secondary="Peter Michaux post" id="idm45017692592176"/><a data-type="indexterm" data-primary="resources online" data-secondary="single global variable pattern post" id="idm45017692591264"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Object Literal Notation"><div class="sect1" id="object-literal-notation">
<h1>Object Literal Notation</h1>

<p>Object literal notation, which we also cover<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="fundamentals of namespacing" data-tertiary="object literal notation" id="ch11-obj"/><a data-type="indexterm" data-primary="object literal notation namespacing pattern" id="ch11-obj2"/> in the Module pattern section, can be thought of as an object containing a collection of key-value pairs with a colon separating each pair of keys and values, where keys can also represent new namespaces:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="p">{</code>

    <code class="c1">// As we've seen, we can easily define functionality for</code>
    <code class="c1">// this object literal...</code>
    <code class="nx">getInfo</code><code class="p">()</code> <code class="p">{</code>
      <code class="c1">//...</code>
    <code class="p">},</code>

    <code class="c1">// but we can also populate it to support</code>
    <code class="c1">// further object namespaces containing anything</code>
    <code class="c1">// anything we wish:</code>
    <code class="nx">models</code> <code class="o">:</code> <code class="p">{},</code>
    <code class="nx">views</code> <code class="o">:</code> <code class="p">{</code>
        <code class="nx">pages</code> <code class="o">:</code> <code class="p">{}</code>
    <code class="p">},</code>
    <code class="nx">collections</code> <code class="o">:</code> <code class="p">{}</code>
<code class="p">};</code></pre>

<p>One can also opt for adding properties directly to the namespace:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">myApplication</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"bar"</code>

<code class="nx">myApplication</code><code class="p">.</code><code class="nx">utils</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">//...</code>
    <code class="p">},</code>
    <code class="kr">export</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">//...</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Object literals don’t pollute the global namespace but assist in organizing code and parameters logically. They are truly beneficial if you wish to create easily readable structures that you can expand to support deep nesting. Unlike simple global variables, object literals often consider tests for the existence of a variable by the same name, so the chances of a collision occurring are significantly reduced.</p>

<p>The following sample demonstrates several ways to check if an object namespace already exists, defining it if it doesn’t:<a data-type="indexterm" data-primary="object literal notation namespacing pattern" data-secondary="checking if object namespace exists" id="idm45017692484928"/></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// This doesn't check for existence of "myApplication" in</code>
<code class="c1">// the global namespace. Bad practice as we can easily</code>
<code class="c1">// clobber an existing variable/namespace with the same name</code>
<code class="kr">const</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="p">{};</code>

<code class="c1">// The following options *do* check for variable/namespace existence.</code>
<code class="c1">// If already defined, we use that instance, otherwise we assign a new</code>
<code class="c1">// object literal to myApplication.</code>
<code class="c1">//</code>
<code class="c1">// Option 1: var myApplication = myApplication || {};</code>
<code class="c1">// Option 2  if( !MyApplication ){ MyApplication = {} };</code>
<code class="c1">// Option 3: window.myApplication || ( window.myApplication = {} );</code>
<code class="c1">// Option 4: var myApplication = $.fn.myApplication = function() {};</code>
<code class="c1">// Option 5: var myApplication = myApplication === undefined ? {} :</code>
<code class="c1">// myApplication;</code></pre>

<p>You’ll often see developers opting for Option 1 or Option 2—they are both straightforward and equivalent in terms of their results.</p>

<p>Option 3 assumes that you’re working in the global namespace, but it can also be written as:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">myApplication</code> <code class="o">||</code> <code class="p">(</code><code class="nx">myApplication</code> <code class="o">=</code> <code class="p">{});</code></pre>

<p>This variation assumes that <code>myApplication</code> has already been initialized, so it’s only handy for a parameter/argument scenario, as in the following example:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
  <code class="nx">myApplication</code> <code class="o">||</code> <code class="p">(</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="p">{}</code> <code class="p">);</code>
<code class="p">}</code>

<code class="c1">// myApplication hasn't been initialized,</code>
<code class="c1">// so foo() throws a ReferenceError</code>

<code class="nx">foo</code><code class="p">();</code>

<code class="c1">// However accepting myApplication as an</code>
<code class="c1">// argument</code>

<code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code> <code class="nx">myApplication</code> <code class="p">)</code> <code class="p">{</code>
  <code class="nx">myApplication</code> <code class="o">||</code> <code class="p">(</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="p">{}</code> <code class="p">);</code>
<code class="p">}</code>

<code class="nx">foo</code><code class="p">();</code>

<code class="c1">// Even if myApplication === undefined, there is no error</code>
<code class="c1">// and myApplication gets set to {} correctly</code></pre>

<p>Option 4 can help write jQuery plug-ins where:<a data-type="indexterm" data-primary="jQuery" data-secondary="plug-ins via object literal" id="idm45017692361696"/></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// If we were to define a new plug-in...</code>
<code class="kd">var</code> <code class="nx">myPlugin</code> <code class="o">=</code> <code class="nx">$</code><code class="p">.</code><code class="nx">fn</code><code class="p">.</code><code class="nx">myPlugin</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="p">...</code> <code class="p">};</code>

<code class="c1">// Then later rather than having to type:</code>
<code class="nx">$</code><code class="p">.</code><code class="nx">fn</code><code class="p">.</code><code class="nx">myPlugin</code><code class="p">.</code><code class="nx">defaults</code> <code class="o">=</code> <code class="p">{};</code>

<code class="c1">// We can do:</code>
<code class="nx">myPlugin</code><code class="p">.</code><code class="nx">defaults</code> <code class="o">=</code> <code class="p">{};</code></pre>

<p>This results in better compression (minification) and can save on scope lookups.</p>

<p>Option 5 is a little similar to Option 4 but is a long form that evaluates whether 
<span class="keep-together"><code>myApplication</code></span> is <code>undefined</code> inline, such that it’s defined as an object if not and set to a current value for <code>myApplication</code> if so.</p>

<p>It is shown just for the sake of being thorough, but in most situations, Options 1–4 will more than suffice for most needs.</p>

<p>There is, of course, a great deal of variance in how and where object literals are used for organizing and structuring code. For smaller applications wishing to expose a nested API for a particular self-enclosed module, you may just find yourself using the Revealing Module pattern, which we covered earlier in the book:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">namespace</code> <code class="o">=</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// defined within the local scope</code>
    <code class="kr">const</code> <code class="nx">privateMethod1</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">};</code>

    <code class="kr">const</code> <code class="nx">privateMethod2</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">};</code>
    <code class="nx">privateProperty1</code> <code class="o">=</code> <code class="s2">"foobar"</code><code class="p">;</code>

    <code class="k">return</code> <code class="p">{</code>

        <code class="c1">// the object literal returned here can have as many</code>
        <code class="c1">// nested depths as we wish; however, as mentioned,</code>
        <code class="c1">// this way of doing things works best for smaller,</code>
        <code class="c1">// limited-scope applications in my personal opinion</code>
        <code class="nx">publicMethod1</code><code class="o">:</code> <code class="nx">privateMethod1</code><code class="p">,</code>

        <code class="c1">// nested namespace with public properties</code>
        <code class="nx">properties</code><code class="o">:</code><code class="p">{</code>
            <code class="nx">publicProperty1</code><code class="o">:</code> <code class="nx">privateProperty1</code>
        <code class="p">},</code>

        <code class="c1">// another tested namespace</code>
        <code class="nx">utils</code><code class="o">:</code><code class="p">{</code>
            <code class="nx">publicMethod2</code><code class="o">:</code> <code class="nx">privateMethod2</code>
        <code class="p">}</code>
        <code class="p">...</code>
    <code class="p">}</code>
<code class="p">})();</code></pre>

<p>The benefit of using object literals here is that they offer us a very elegant key-value syntax to work with—one where we’re able to easily encapsulate any distinct logic or functionality for our application in a way that clearly separates it from others and provides a solid foundation for extending our code:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">myConfig</code> <code class="o">=</code> <code class="p">{</code>

    <code class="nx">language</code><code class="o">:</code> <code class="s2">"english"</code><code class="p">,</code>

    <code class="nx">defaults</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">enableGeolocation</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">enableSharing</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
        <code class="nx">maxPhotos</code><code class="o">:</code> <code class="mi">20</code>
    <code class="p">},</code>

    <code class="nx">theme</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">skin</code><code class="o">:</code> <code class="s2">"a"</code><code class="p">,</code>
        <code class="nx">toolbars</code><code class="o">:</code> <code class="p">{</code>
            <code class="nx">index</code><code class="o">:</code> <code class="s2">"ui-navigation-toolbar"</code><code class="p">,</code>
            <code class="nx">pages</code><code class="o">:</code> <code class="s2">"ui-custom-toolbar"</code>
        <code class="p">}</code>
    <code class="p">}</code>

<code class="p">};</code></pre>

<p>Note that JSON is a subset of object literal notation,<a data-type="indexterm" data-primary="JSON as subset of object literal notation" id="idm45017692087616"/><a data-type="indexterm" data-primary="object literal notation namespacing pattern" data-secondary="JSON as subset of object literal notation" id="idm45017692105648"/> and there are only minor syntactical differences between it and the preceding code (e.g., JSON keys must be strings). If, for any reason, one wishes to use JSON for storing configuration data instead (e.g., for simpler storage when sending to the backend), feel free to.<a data-type="indexterm" data-startref="ch11-obj" id="idm45017692104672"/><a data-type="indexterm" data-startref="ch11-obj2" id="idm45017692104064"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Nested Namespacing"><div class="sect1" id="nested-namespacing">
<h1>Nested Namespacing</h1>

<p>An extension of the Object Literal pattern<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="fundamentals of namespacing" data-tertiary="nested namespacing" id="idm45017692101792"/><a data-type="indexterm" data-primary="nested namespacing pattern" id="idm45017692067440"/> is nested namespacing. It’s another common pattern that offers a lower risk of collision because even if a namespace already exists, it’s unlikely the same nested children do.</p>

<p>For example, something like this:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">YAHOO</code><code class="p">.</code><code class="nx">util</code><code class="p">.</code><code class="nx">Dom</code><code class="p">.</code><code class="nx">getElementsByClassName</code><code class="p">(</code><code class="s2">"test"</code><code class="p">);</code></pre>

<p>Older versions of Yahoo!’s YUI library<a data-type="indexterm" data-primary="YUI library (Yahoo)" data-secondary="Nested Object Namespacing pattern" id="idm45017692060432"/> regularly used the Nested Object Namespacing pattern. During my time as an engineer at AOL, we also used this pattern in many of our larger applications. A sample implementation of nested namespacing may look like this:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">myApp</code> <code class="o">=</code>  <code class="nx">myApp</code> <code class="o">||</code> <code class="p">{};</code>

<code class="c1">// perform a similar existence check when defining nested</code>
<code class="c1">// children</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">routers</code> <code class="o">=</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">routers</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">model</code> <code class="o">=</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">model</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">special</code> <code class="o">=</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">model</code><code class="p">.</code><code class="nx">special</code> <code class="o">||</code> <code class="p">{};</code>

<code class="c1">// nested namespaces can be as complex as required:</code>
<code class="c1">// myApp.utilities.charting.html5.plotGraph(/*..*/);</code>
<code class="c1">// myApp.modules.financePlanner.getSummary();</code>
<code class="c1">// myApp.services.social.facebook.realtimeStream.getLatest();</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This code differs from how YUI3 approaches<a data-type="indexterm" data-primary="YUI library (Yahoo)" data-secondary="Nested Object Namespacing pattern" data-tertiary="YUI3 differences" id="idm45017692017408"/> namespacing. YUI3 modules use a sandboxed API host object with far less and far shallower namespacing.</p>
</div>

<p>We can also opt to declare new nested namespaces/properties as indexed properties as follows:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">myApp</code><code class="p">[</code><code class="s2">"routers"</code><code class="p">]</code> <code class="o">=</code> <code class="nx">myApp</code><code class="p">[</code><code class="s2">"routers"</code><code class="p">]</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">myApp</code><code class="p">[</code><code class="s2">"models"</code><code class="p">]</code> <code class="o">=</code> <code class="nx">myApp</code><code class="p">[</code><code class="s2">"models"</code><code class="p">]</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">myApp</code><code class="p">[</code><code class="s2">"controllers"</code><code class="p">]</code> <code class="o">=</code> <code class="nx">myApp</code><code class="p">[</code><code class="s2">"controllers"</code><code class="p">]</code> <code class="o">||</code> <code class="p">{};</code></pre>

<p>Both options are readable and organized and offer a relatively safe way of namespacing our application, similar to what we may be used to in other languages. The only real caveat is that it requires our browser’s JavaScript engine first to locate the <code>myApp</code> object and then dig down until it gets to the function we actually wish to use.</p>

<p>This can mean more work to perform lookups; however,<a data-type="indexterm" data-primary="Zaytsev, Juriy" id="idm45017691926864"/> developers such as <a href="https://oreil.ly/hxJnZ">Juriy Zaytsev</a> have previously tested and found the performance differences between single object namespacing versus the “nested” approach quite 
<span class="keep-together">negligible.</span></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Immediately Invoked Function Expressions"><div class="sect1" id="immediately-invoked-function-expressions-iifes">
<h1>Immediately Invoked Function Expressions</h1>

<p>Earlier in the book, we briefly covered<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="fundamentals of namespacing" data-tertiary="immediately invoked function expressions (IIFEs)" id="ch11-iife"/><a data-type="indexterm" data-primary="immediately invoked function expressions (IIFEs)" data-secondary="namespacing pattern" id="ch11-iife2"/><a data-type="indexterm" data-primary="anonymous function self-invoked" data-see="immediately invoked function expressions (IIFEs)" id="idm45017691884944"/> the concept of an immediately invoked function expression (IIFE); an <a href="https://oreil.ly/KSspI">IIFE</a>, which is effectively an unnamed function, is immediately invoked after it’s been defined. If it sounds familiar, it’s because you may have previously come across it referred to as a self-executing (or self-invoked) <code>anonymous</code> function. <a data-type="indexterm" data-primary="Alman, Ben" id="idm45017691883072"/>However, I feel Ben Alman’s IIFE naming is more accurate. In JavaScript, because both variables and functions explicitly defined within such a context may be accessed only inside of it, function invocation provides an easy means to achieving privacy.</p>

<p>IIFEs are a popular approach to encapsulating application logic to protect it from the global namespace, but they also have their use in the world of namespacing.</p>

<p>Here are examples of IIFEs:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// an (anonymous) immediately invoked function expression</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/*...*/</code><code class="p">})();</code>

<code class="c1">// a named immediately invoked function expression</code>
<code class="p">(</code><code class="kd">function</code> <code class="nx">foobar</code> <code class="p">()</code> <code class="p">{</code> <code class="cm">/*..*/</code><code class="p">}());</code>

<code class="c1">// this is technically a self-executing function which is quite different</code>
<code class="kd">function</code> <code class="nx">foobar</code> <code class="p">()</code> <code class="p">{</code> <code class="nx">foobar</code><code class="p">();</code> <code class="p">}</code></pre>

<p>A slightly more expanded version of the first example might look like this:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">namespace</code> <code class="o">=</code> <code class="nx">namespace</code> <code class="o">||</code> <code class="p">{};</code>

<code class="c1">// here a namespace object is passed as a function</code>
<code class="c1">// parameter, where we assign public methods and</code>
<code class="c1">// properties to it</code>
<code class="p">(</code><code class="nx">o</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">o</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="s2">"foo"</code><code class="p">;</code>
    <code class="nx">o</code><code class="p">.</code><code class="nx">bar</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"bar"</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">namespace</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">namespace</code> <code class="p">);</code></pre>

<p>While readable, this example could be significantly expanded to address common development concerns such as defined levels of privacy (public/private functions and variables) as well as convenient namespace extension. Let’s go through some more code:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// namespace (our namespace name) and undefined are passed here</code>
<code class="c1">// to ensure: 1. namespace can be modified locally and isn't</code>
<code class="c1">// overwritten outside of our function context;</code>
<code class="c1">// 2. the value of undefined is guaranteed as being truly</code>
<code class="c1">// undefined. This is to avoid issues with undefined being</code>
<code class="c1">// mutable pre-ES5.</code>

<code class="p">;((</code><code class="nx">namespace</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// private properties</code>
    <code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="s2">"foo"</code><code class="p">;</code>

    <code class="kr">const</code> <code class="nx">bar</code> <code class="o">=</code> <code class="s2">"bar"</code><code class="p">;</code>

    <code class="c1">// public methods and properties</code>
    <code class="nx">namespace</code><code class="p">.</code><code class="nx">foobar</code> <code class="o">=</code> <code class="s2">"foobar"</code><code class="p">;</code>
    <code class="nx">namespace</code><code class="p">.</code><code class="nx">sayHello</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">speak</code><code class="p">(</code> <code class="s2">"hello world"</code> <code class="p">);</code>
    <code class="p">};</code>

    <code class="c1">// private method</code>
    <code class="kd">function</code> <code class="nx">speak</code><code class="p">(</code><code class="nx">msg</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="sb">`You said: </code><code class="si">${</code><code class="nx">msg</code><code class="si">}</code><code class="sb">`</code> <code class="p">);</code>
    <code class="p">};</code>

    <code class="c1">// check to evaluate whether "namespace" exists in the</code>
    <code class="c1">// global namespace - if not, assign window.namespace an</code>
    <code class="c1">// object literal</code>
<code class="p">})(</code><code class="nb">window</code><code class="p">.</code><code class="nx">namespace</code> <code class="o">=</code> <code class="nb">window</code><code class="p">.</code><code class="nx">namespace</code> <code class="o">||</code> <code class="p">{});</code>



<code class="c1">// we can then test our properties and methods as follows</code>

<code class="c1">// public</code>

<code class="c1">// Outputs: foobar</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">namespace</code><code class="p">.</code><code class="nx">foobar</code> <code class="p">);</code>

<code class="c1">// Outputs: hello world</code>
<code class="nx">namespace</code><code class="p">.</code><code class="nx">sayHello</code><code class="p">();</code>

<code class="c1">// assigning new properties</code>
<code class="nx">namespace</code><code class="p">.</code><code class="nx">foobar2</code> <code class="o">=</code> <code class="s2">"foobar"</code><code class="p">;</code>

<code class="c1">// Outputs: foobar</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">namespace</code><code class="p">.</code><code class="nx">foobar2</code> <code class="p">);</code></pre>

<p>Extensibility is of course key to any scalable namespacing pattern and IIFEs can be used to achieve this quite easily. In the following example, our “namespace” is once again passed as an argument to our <code>anonymous</code> function and is then extended (or decorated) with additional functionality:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// let's extend the namespace with new functionality</code>
<code class="p">((</code><code class="nx">namespace</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>

    <code class="c1">// public method</code>
    <code class="nx">namespace</code><code class="p">.</code><code class="nx">sayGoodbye</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">namespace</code><code class="p">.</code><code class="nx">foo</code> <code class="p">);</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">namespace</code><code class="p">.</code><code class="nx">bar</code> <code class="p">);</code>
        <code class="nx">speak</code><code class="p">(</code> <code class="s2">"goodbye"</code> <code class="p">);</code>
    <code class="p">}</code>
<code class="p">})(</code><code class="nb">window</code><code class="p">.</code><code class="nx">namespace</code> <code class="o">=</code> <code class="nb">window</code><code class="p">.</code><code class="nx">namespace</code> <code class="o">||</code> <code class="p">{});</code>

<code class="c1">// Outputs: goodbye</code>
<code class="nx">namespace</code><code class="p">.</code><code class="nx">sayGoodbye</code><code class="p">();</code></pre>

<p>If you want to learn more about this pattern, I recommend reading Ben’s <a href="https://oreil.ly/KSspI">IIFE post</a> for more information.<a data-type="indexterm" data-startref="ch11-iife" id="idm45017691569696"/><a data-type="indexterm" data-startref="ch11-iife2" id="idm45017691569088"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Namespace Injection"><div class="sect1" id="namespace-injection">
<h1>Namespace Injection</h1>

<p>Namespace injection is another variation<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="fundamentals of namespacing" data-tertiary="namespace injection" id="ch11-inj"/><a data-type="indexterm" data-primary="namespace injection pattern" id="ch11-inj2"/><a data-type="indexterm" data-primary="this keyword" data-secondary="namespace proxy in namespace injection pattern" id="ch11-inj3"/> on the IIFE in which we “inject” the methods and properties for a specific namespace from within a function wrapper using <code>this</code> as a namespace proxy. The benefit this pattern offers is the easy application of functional behavior to multiple objects or namespaces and can come in useful when applying a set of base methods to be built on later (e.g., getters and setters).</p>

<p>The disadvantages of this pattern are that there may be easier or more optimal approaches to achieving this goal (e.g., deep object extension or merging), which I cover earlier in the section.</p>

<p>Next we can see an example of this pattern in action, where we use it to populate the behavior for two namespaces: one initially defined (<code>utils</code>) and another which we dynamically create as a part of the functionality assignment for <code>utils</code> (a new namespace called <code>tools</code>):</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">myApp</code> <code class="o">=</code> <code class="nx">myApp</code> <code class="o">||</code> <code class="p">{};</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">utils</code> <code class="o">=</code>  <code class="p">{};</code>

<code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">val</code> <code class="o">=</code> <code class="mi">5</code><code class="p">;</code>

  <code class="k">this</code><code class="p">.</code><code class="nx">getValue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">val</code><code class="p">;</code>

  <code class="k">this</code><code class="p">.</code><code class="nx">setValue</code> <code class="o">=</code> <code class="nx">newVal</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">val</code> <code class="o">=</code> <code class="nx">newVal</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="c1">// also introduce a new subnamespace</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">tools</code> <code class="o">=</code> <code class="p">{};</code>

<code class="p">}).</code><code class="nx">apply</code><code class="p">(</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">utils</code> <code class="p">);</code>

<code class="c1">// inject new behavior into the tools namespace</code>
<code class="c1">// which we defined via the utilities module</code>

<code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">diagnose</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"diagnosis"</code>
<code class="p">}).</code><code class="nx">apply</code><code class="p">(</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">utils</code><code class="p">.</code><code class="nx">tools</code> <code class="p">);</code>

<code class="c1">// note, this same approach to extension could be applied</code>
<code class="c1">// to a regular IIFE, by just passing in the context as</code>
<code class="c1">// an argument and modifying the context rather than just</code>
<code class="c1">// "this"</code>

<code class="c1">// Usage:</code>

<code class="c1">// Outputs our populated namespace</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">myApp</code> <code class="p">);</code>

<code class="c1">// Outputs: 5</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">utils</code><code class="p">.</code><code class="nx">getValue</code><code class="p">()</code> <code class="p">);</code>

<code class="c1">// Sets the value of `val` and returns it</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">utils</code><code class="p">.</code><code class="nx">setValue</code><code class="p">(</code> <code class="mi">25</code> <code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">utils</code><code class="p">.</code><code class="nx">getValue</code><code class="p">()</code> <code class="p">);</code>

<code class="c1">// Testing another level down</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">utils</code><code class="p">.</code><code class="nx">tools</code><code class="p">.</code><code class="nx">diagnose</code><code class="p">()</code> <code class="p">);</code></pre>

<p>Previously, Angus Croll has suggested<a data-type="indexterm" data-primary="Croll, Angus" id="idm45017691408944"/><a data-type="indexterm" data-primary="APIs" data-secondary="call between contexts and arguments" id="idm45017691408336"/><a data-type="indexterm" data-primary="call API between contexts and arguments" id="idm45017691407488"/> <a href="https://oreil.ly/eBc5N">using the call API to provide a natural separation between contexts and arguments</a>. This pattern can feel a lot more like a module creator, but as modules still offer an encapsulation solution, we’ll briefly cover it for the sake of thoroughness:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// define a namespace we can use later</code>
<code class="kr">const</code> <code class="nx">ns</code> <code class="o">=</code> <code class="nx">ns</code> <code class="o">||</code> <code class="p">{};</code>

<code class="kr">const</code> <code class="nx">ns2</code> <code class="o">=</code> <code class="nx">ns2</code> <code class="o">||</code> <code class="p">{};</code>

<code class="c1">// the module/namespace creator</code>
<code class="kr">const</code> <code class="nx">creator</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code> <code class="nx">val</code> <code class="p">){</code>

    <code class="kd">var</code> <code class="nx">val</code> <code class="o">=</code> <code class="nx">val</code> <code class="o">||</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">this</code><code class="p">.</code><code class="nx">next</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">val</code><code class="o">++</code><code class="p">;</code>

    <code class="k">this</code><code class="p">.</code><code class="nx">reset</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">val</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="nx">creator</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code> <code class="nx">ns</code> <code class="p">);</code>

<code class="c1">// ns.next, ns.reset now exist</code>
<code class="nx">creator</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code> <code class="nx">ns2</code> <code class="p">,</code> <code class="mi">5000</code> <code class="p">);</code>

<code class="c1">// ns2 contains the same methods</code>
<code class="c1">// but has an overridden value for val</code>
<code class="c1">// of 5000</code></pre>

<p>As mentioned, this type of pattern helps assign a similar base set of functionality to multiple modules or namespaces. I would, however, suggest using it only where explicitly declaring functionality within an object/closure as direct access doesn’t make sense.<a data-type="indexterm" data-startref="ch11-inj" id="idm45017693716640"/><a data-type="indexterm" data-startref="ch11-inj2" id="idm45017693716032"/><a data-type="indexterm" data-startref="ch11-inj3" id="idm45017691185920"/></p>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Advanced Namespacing Patterns"><div class="sect1" id="advanced-namespacing-patterns">
<h1>Advanced Namespacing Patterns</h1>

<p>We’ll now explore some advanced patterns and utilities that I have found invaluable when working on more extensive applications, some of which have required a rethink of traditional approaches to application namespacing. I’ll note that I am not advocating the following as  <em>the</em> way to namespace but rather as ways I have found to work in practice.</p>








<section data-type="sect2" data-pdf-bookmark="Automating Nested Namespacing"><div class="sect2" id="automating-nested-namespacing">
<h2>Automating Nested Namespacing</h2>

<p>As we’ve reviewed, nested namespaces<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="advanced patterns" data-tertiary="automating nested namespacing" id="ch11-auto"/><a data-type="indexterm" data-primary="nested namespacing pattern" data-secondary="automating" id="ch11-auto2"/><a data-type="indexterm" data-primary="object literal notation namespacing pattern" data-secondary="nested namespace" id="idm45017691177856"/> can provide an organized hierarchy of structure for a unit of code. An example of such a namespace could be the following: <code>application.utilities.drawing.canvas.2d</code>. This can also be expanded using the Object Literal pattern to be:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">application</code> <code class="o">=</code> <code class="p">{</code>
      <code class="nx">utilities</code><code class="o">:</code><code class="p">{</code>
          <code class="nx">drawing</code><code class="o">:</code><code class="p">{</code>
              <code class="nx">canvas</code><code class="o">:</code><code class="p">{</code>
                  <code class="nx">paint</code><code class="o">:</code><code class="p">{</code>
                          <code class="c1">//...</code>
                  <code class="p">}</code>
              <code class="p">}</code>
          <code class="p">}</code>
    <code class="p">}</code>
<code class="p">};</code></pre>

<p>One of the obvious challenges with this pattern is that each additional layer we wish to create requires yet another object to be defined as a child of some parent in our top-level namespace. This can become particularly laborious when multiple depths are required as our application increases in complexity.</p>

<p>How can this problem be better solved? <a data-type="indexterm" data-primary="Stefanov, Stoyan" id="idm45017691134304"/><a data-type="indexterm" data-primary="JavaScript Patterns (Stefanov)" id="idm45017691133696"/>In <em>JavaScript Patterns</em>, Stoyan Stefanov presents a clever approach for automatically defining nested namespaces under an existing global variable. He suggests a convenience method that takes a single string argument for a nest, parses this, and automatically populates our base namespace with the objects required.</p>

<p>The method he suggests using is the following, which I’ve updated to be a generic function for easier reuse with multiple namespaces:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// top-level namespace being assigned an object literal</code>
<code class="kr">const</code> <code class="nx">myApp</code> <code class="o">=</code> <code class="p">{};</code>

<code class="c1">// a convenience function for parsing string namespaces and</code>
<code class="c1">// automatically generating nested namespaces</code>
<code class="kd">function</code> <code class="nx">extend</code><code class="p">(</code> <code class="nx">ns</code><code class="p">,</code> <code class="nx">ns_string</code> <code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">parts</code> <code class="o">=</code> <code class="nx">ns_string</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">"."</code><code class="p">);</code>
    <code class="kd">let</code> <code class="nx">parent</code> <code class="o">=</code> <code class="nx">ns</code><code class="p">;</code>
    <code class="kd">let</code> <code class="nx">pl</code><code class="p">;</code>

    <code class="nx">pl</code> <code class="o">=</code> <code class="nx">parts</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>

    <code class="k">for</code> <code class="p">(</code> <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">pl</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">)</code> <code class="p">{</code>
        <code class="c1">// create a property if it doesn't exist</code>
        <code class="k">if</code> <code class="p">(</code> <code class="k">typeof</code> <code class="nx">parent</code><code class="p">[</code><code class="nx">parts</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">===</code> <code class="s2">"undefined"</code> <code class="p">)</code> <code class="p">{</code>
            <code class="nx">parent</code><code class="p">[</code><code class="nx">parts</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="p">{};</code>
        <code class="p">}</code>

        <code class="nx">parent</code> <code class="o">=</code> <code class="nx">parent</code><code class="p">[</code><code class="nx">parts</code><code class="p">[</code><code class="nx">i</code><code class="p">]];</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="nx">parent</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Usage:</code>
<code class="c1">// extend myApp with a deeply nested namespace</code>
<code class="kr">const</code> <code class="nx">mod</code> <code class="o">=</code> <code class="nx">extend</code><code class="p">(</code><code class="nx">myApp</code><code class="p">,</code> <code class="s2">"modules.module2"</code><code class="p">);</code>

<code class="c1">// the correct object with nested depths is output</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">mod</code><code class="p">);</code>

<code class="c1">// minor test to check the instance of mod can also</code>
<code class="c1">// be used outside of the myApp namespace as a clone</code>
<code class="c1">// that includes the extensions</code>

<code class="c1">// Outputs: true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">mod</code> <code class="o">==</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">modules</code><code class="p">.</code><code class="nx">module2</code><code class="p">);</code>

<code class="c1">// further demonstration of easier nested namespace</code>
<code class="c1">// assignment using extend</code>
<code class="nx">extend</code><code class="p">(</code><code class="nx">myApp</code><code class="p">,</code> <code class="s2">"moduleA.moduleB.moduleC.moduleD"</code><code class="p">);</code>
<code class="nx">extend</code><code class="p">(</code><code class="nx">myApp</code><code class="p">,</code> <code class="s2">"longer.version.looks.like.this"</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">myApp</code><code class="p">);</code></pre>

<p><a data-type="xref" href="#web_inspector_output">Figure 11-1</a> shows the Chrome Developer Tools output.<a data-type="indexterm" data-primary="Chrome" data-secondary="nested namespacing in Developer Tools output" id="idm45017690963424"/><a data-type="indexterm" data-primary="browsers" data-secondary="Chrome" data-tertiary="nested namespacing in Developer Tools output" id="idm45017690962448"/> Where one would previously have had to explicitly declare the various nests for their namespace as objects, this can now be easily achieved using a single, cleaner line of code.<a data-type="indexterm" data-startref="ch11-auto" id="idm45017691039200"/><a data-type="indexterm" data-startref="ch11-auto2" id="idm45017691038528"/></p>

<figure><div id="web_inspector_output" class="figure">
<img src="Images/ljd2_1101.png" alt="ljd2 1101" width="2497" height="1634"/>
<h6><span class="label">Figure 11-1. </span>Chrome Developer Tools output</h6>
</div></figure>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Dependency Declaration Pattern"><div class="sect2" id="dependency-declaration-pattern">
<h2>Dependency Declaration Pattern</h2>

<p>We’ll now explore a minor augmentation<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="advanced patterns" data-tertiary="Dependency Declaration pattern" id="idm45017691034176"/><a data-type="indexterm" data-primary="Dependency Declaration pattern" id="idm45017691032960"/><a data-type="indexterm" data-primary="dependencies" data-secondary="Dependency Declaration pattern" id="idm45017691032320"/> to the Nested Namespacing pattern, which we’ll refer to as the Dependency Declaration pattern. We all know that local references to objects can decrease overall lookup times, but let’s apply this to namespacing to see how it might look in practice:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// common approach to accessing nested namespaces</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">utilities</code><code class="p">.</code><code class="nx">math</code><code class="p">.</code><code class="nx">fibonacci</code><code class="p">(</code> <code class="mi">25</code> <code class="p">);</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">utilities</code><code class="p">.</code><code class="nx">math</code><code class="p">.</code><code class="nx">sin</code><code class="p">(</code> <code class="mi">56</code> <code class="p">);</code>
<code class="nx">myApp</code><code class="p">.</code><code class="nx">utilities</code><code class="p">.</code><code class="nx">drawing</code><code class="p">.</code><code class="nx">plot</code><code class="p">(</code> <code class="mi">98</code><code class="p">,</code><code class="mi">50</code><code class="p">,</code><code class="mi">60</code> <code class="p">);</code>

<code class="c1">// with local/cached references</code>
<code class="kr">const</code> <code class="nx">utils</code> <code class="o">=</code> <code class="nx">myApp</code><code class="p">.</code><code class="nx">utilities</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">maths</code> <code class="o">=</code> <code class="nx">utils</code><code class="p">.</code><code class="nx">math</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">drawing</code> <code class="o">=</code> <code class="nx">utils</code><code class="p">.</code><code class="nx">drawing</code><code class="p">;</code>

<code class="c1">// easier to access the namespace</code>
<code class="nx">maths</code><code class="p">.</code><code class="nx">fibonacci</code><code class="p">(</code> <code class="mi">25</code> <code class="p">);</code>
<code class="nx">maths</code><code class="p">.</code><code class="nx">sin</code><code class="p">(</code> <code class="mi">56</code> <code class="p">);</code>
<code class="nx">drawing</code><code class="p">.</code><code class="nx">plot</code><code class="p">(</code> <code class="mi">98</code><code class="p">,</code> <code class="mi">50</code><code class="p">,</code><code class="mi">60</code> <code class="p">);</code>

<code class="c1">// note that this is particularly performant when</code>
<code class="c1">// compared to hundreds or thousands of calls to nested</code>
<code class="c1">// namespaces vs. a local reference to the namespace</code></pre>

<p>Working with a local variable here is almost always faster than working with a top-level global (e.g., <code>myApp</code>). It’s also more convenient and more performant than accessing nested properties/subnamespaces on every subsequent line and can improve readability in more complex applications.</p>

<p>Stoyan recommends declaring<a data-type="indexterm" data-primary="Stefanov, Stoyan" id="idm45017690867856"/> localized namespaces required by a function or module at the top of our function scope (using the single-variable pattern) and calls this a Dependency Declaration pattern. One of the benefits this offers is a decrease in locating dependencies and resolving them, should we have an extendable architecture that dynamically loads modules into our namespace when required.</p>

<p>In my opinion, this pattern works best when working at a modular level, localizing a namespace to be used by a group of methods. Localizing namespaces on a per-function level, especially where there is significant overlap between namespace dependencies, is something I recommend avoiding where possible. Instead, define it further up and have them all access the same reference.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Deep Object Extension"><div class="sect2" id="deep-object-extension">
<h2>Deep Object Extension</h2>

<p>An alternative approach to automatic namespacing<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="advanced patterns" data-tertiary="deep object extension" id="ch11-deep"/><a data-type="indexterm" data-primary="deep object extension namespacing pattern" id="ch11-deep2"/> is deep object extension. Namespaces defined using object literal notation may be easily extended (or merged) with other objects (or namespaces) such that the properties and functions of both namespaces can be accessible under the same namespace postmerge.</p>

<p>This is something that’s been made relatively easy to accomplish with JavaScript frameworks (e.g., see jQuery’s <a href="https://oreil.ly/WDJWX"><code>$.extend</code></a>); however, if looking to extend objects (namespaces) using conventional JS, the following routine may be of assistance:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Deep object extension using Object.assign and recursion</code>
<code class="kd">function</code> <code class="nx">extendObjects</code><code class="p">(</code><code class="nx">destinationObject</code><code class="p">,</code> <code class="nx">sourceObject</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">property</code> <code class="k">in</code> <code class="nx">sourceObject</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code>
      <code class="nx">sourceObject</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code> <code class="o">&amp;&amp;</code>
      <code class="k">typeof</code> <code class="nx">sourceObject</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"object"</code> <code class="o">&amp;&amp;</code>
      <code class="o">!</code><code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">sourceObject</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code>
    <code class="p">)</code> <code class="p">{</code>
      <code class="nx">destinationObject</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code> <code class="o">=</code> <code class="nx">destinationObject</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code> <code class="o">||</code> <code class="p">{};</code>
      <code class="nx">extendObjects</code><code class="p">(</code><code class="nx">destinationObject</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code> <code class="nx">sourceObject</code><code class="p">[</code><code class="nx">property</code><code class="p">]);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
      <code class="nx">destinationObject</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code> <code class="o">=</code> <code class="nx">sourceObject</code><code class="p">[</code><code class="nx">property</code><code class="p">];</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">destinationObject</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Example usage</code>
<code class="kr">const</code> <code class="nx">myNamespace</code> <code class="o">=</code> <code class="nx">myNamespace</code> <code class="o">||</code> <code class="p">{};</code>

<code class="nx">extendObjects</code><code class="p">(</code><code class="nx">myNamespace</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">utils</code><code class="o">:</code> <code class="p">{},</code>
<code class="p">});</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"test 1"</code><code class="p">,</code> <code class="nx">myNamespace</code><code class="p">);</code>

<code class="nx">extendObjects</code><code class="p">(</code><code class="nx">myNamespace</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">hello</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">world</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">wave</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">test</code><code class="p">()</code> <code class="p">{</code>
          <code class="c1">// ...</code>
        <code class="p">},</code>
      <code class="p">},</code>
    <code class="p">},</code>
  <code class="p">},</code>
<code class="p">});</code>

<code class="nx">myNamespace</code><code class="p">.</code><code class="nx">hello</code><code class="p">.</code><code class="nx">test1</code> <code class="o">=</code> <code class="s2">"this is a test"</code><code class="p">;</code>
<code class="nx">myNamespace</code><code class="p">.</code><code class="nx">hello</code><code class="p">.</code><code class="nx">world</code><code class="p">.</code><code class="nx">test2</code> <code class="o">=</code> <code class="s2">"this is another test"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"test 2"</code><code class="p">,</code> <code class="nx">myNamespace</code><code class="p">);</code>

<code class="nx">myNamespace</code><code class="p">.</code><code class="nx">library</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">foo</code><code class="p">()</code> <code class="p">{},</code>
<code class="p">};</code>

<code class="nx">extendObjects</code><code class="p">(</code><code class="nx">myNamespace</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">library</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
      <code class="c1">// ...</code>
    <code class="p">},</code>
  <code class="p">},</code>
<code class="p">});</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"test 3"</code><code class="p">,</code> <code class="nx">myNamespace</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">shorterNamespaceAccess</code> <code class="o">=</code> <code class="nx">myNamespace</code><code class="p">.</code><code class="nx">hello</code><code class="p">.</code><code class="nx">world</code><code class="p">;</code>
<code class="nx">shorterNamespaceAccess</code><code class="p">.</code><code class="nx">test3</code> <code class="o">=</code> <code class="s2">"hello again"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"test 4"</code><code class="p">,</code> <code class="nx">myNamespace</code><code class="p">);</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This implementation is not cross-browser compatible with all objects and should be considered a proof of concept only. <a data-type="indexterm" data-primary="Lodash library" data-secondary="extend() method" id="idm45017690762528"/><a data-type="indexterm" data-primary="deep object extension namespacing pattern" data-secondary="Lodash extend() method instead" id="idm45017690761616"/>One may find the <a href="https://oreil.ly/TD1-D">Lodash.js <code>extend()</code> method</a> to be a simpler, more cross-browser-friendly implementation to start with.</p>
</div>

<p class="less_space pagebreak-before">For developers who are going to use jQuery in their applications, one can achieve the same object namespace extensibility with <code>$.extend</code> as follows:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// top-level namespace</code>
<code class="kr">const</code> <code class="nx">myApplication</code> <code class="o">=</code> <code class="nx">myApplication</code> <code class="o">||</code> <code class="p">{};</code>

<code class="c1">// directly assign a nested namespace</code>
<code class="nx">myApplication</code><code class="p">.</code><code class="nx">library</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">},</code>
<code class="p">};</code>

<code class="c1">// deep extend/merge this namespace with another</code>
<code class="c1">// to make things interesting, let's say it's a namespace</code>
<code class="c1">// with the same name but with a different function</code>
<code class="c1">// signature: $.extend( deep, target, object1, object2 )</code>
<code class="nx">$</code><code class="p">.</code><code class="nx">extend</code><code class="p">(</code><code class="kc">true</code><code class="p">,</code> <code class="nx">myApplication</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">library</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
      <code class="c1">// ...</code>
    <code class="p">},</code>
  <code class="p">},</code>
<code class="p">});</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"test"</code><code class="p">,</code> <code class="nx">myApplication</code><code class="p">);</code></pre>

<p>For thoroughness, please check <a href="https://oreil.ly/ZCB2C">this</a> for jQuery <code>$.extend</code> equivalents to the rest of the namespacing experiments in this section.<a data-type="indexterm" data-startref="ch11-deep" id="idm45017690420752"/><a data-type="indexterm" data-startref="ch11-deep2" id="idm45017690420112"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Recommendation"><div class="sect1" id="recommendation">
<h1>Recommendation</h1>

<p>Reviewing the namespace patterns<a data-type="indexterm" data-primary="namespacing patterns" data-secondary="recommendation" id="idm45017690417568"/> we’ve explored in this section, the option that I would personally use for most larger applications is Nested Object Namespacing with the Object Literal pattern. Where possible, I would implement this using automated nested namespacing. However, this is just a personal preference.</p>

<p>IIFEs and single global variables may work fine for applications in the small to medium range. However, larger codebases requiring both namespaces and deep subnamespaces require a succinct solution that promotes readability and scale. This pattern achieves all of these objectives well.</p>

<p>I recommend trying out some of the suggested advanced utility methods for namespace extension, as they can save time in the long run.</p>
</div></section>






<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Summary"><div class="sect1" id="idm45017690415536">
<h1>Summary</h1>

<p>This chapter discussed how namespacing could help bring structure to your JavaScript and jQuery applications and prevent collisions between variables and function names. Organizing our project files in large JavaScript applications with many code files helps you better manage modules and namespaces and enhances the development experience.</p>

<p>We have now covered different aspects of design and architecture using plain JavaScript. We have mentioned React in passing but haven’t discussed any React patterns in detail. In the next chapter, we aim to do just that.</p>
</div></section>
</div></section></div></body></html>