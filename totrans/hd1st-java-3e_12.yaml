- en: 'Chapter 10\. Numbers Matter: Numbers and Statics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0275-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Do the Math.** But there’s more to working with numbers than just doing primitive
    arithmetic. You might want to get the absolute value of a number, or round a number,
    or find the larger of two numbers. You might want your numbers to print with exactly
    two decimal places, or you might want to put commas into your large numbers to
    make them easier to read. And what about parsing a String into a number? Or turning
    a number into a String? Someday you’re gonna want to put a bunch of numbers into
    a collection like ArrayList that takes only objects. You’re in luck. Java and
    the Java API are full of handy number-tweaking capabilities and methods, ready
    and easy to use. But most of them are **static**, so we’ll start by learning what
    it means for a variable or method to be static, including constants in Java, also
    known as static *final* variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'MATH methods: as close as you’ll ever get to a *global* method'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Except there’s no global *anything* in Java. But think about this: what if
    you have a method whose behavior doesn’t depend on an instance variable value.
    Take the round() method in the Math class, for example. It does the same thing
    every time—rounds a floating-point number (the argument to the method) to the
    nearest integer. Every time. If you had 10,000 instances of class Math, and ran
    the round(42.2) method, you’d get an integer value of 42\. Every time. In other
    words, the method acts on the argument but is never affected by an instance variable
    state. The only value that changes the way the round() method runs is the argument
    passed to the method!'
  prefs: []
  type: TYPE_NORMAL
- en: Doesn’t it seem like a waste of perfectly good heap space to make an instance
    of class Math simply to run the round() method? And what about *other* Math methods
    like min(), which takes two numerical primitives and returns the smaller of the
    two? Or max(). Or abs(), which returns the absolute value of a number.
  prefs: []
  type: TYPE_NORMAL
- en: '***These methods never use instance variable values***. In fact, the Math class
    doesn’t *have* any instance variables. So there’s nothing to be gained by making
    an instance of class Math. So guess what? You don’t have to. As a matter of fact,
    you can’t.'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you try to make an instance of class Math:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**You’ll get this error:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0276-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Methods in the Math class don’t use any instance variable values. And because
    the methods are “static,” you don’t need to have an instance of Math. All you
    need is the Math class.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0276-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference between regular (non-static) and static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is object-oriented, but once in a while you have a special case, typically
    a utility method (like the Math methods), where there is no need to have an instance
    of the class. The keyword **`static`** lets a method run ***without any instance
    of the class***. A static method means “behavior not dependent on an instance
    variable, so no instance/object is required. Just the class.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0277-01.png)![image](Images/f0278-01.png)![image](Images/f0278-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What it means to have a class with static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often (although not always), a class with static methods is not meant to be
    instantiated. In [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst),
    *Serious Polymorphism*, we talked about abstract classes, and how marking a class
    with the **`abstract`** modifier makes it impossible for anyone to say “new” on
    that class type. In other words, ***it’s impossible to instantiate an abstract
    class.***
  prefs: []
  type: TYPE_NORMAL
- en: But you can restrict other code from instantiating a *non*-abstract class by
    marking the constructor **`private`**. Remember, a *method* marked private means
    that only code from within the class can invoke the method. A *constructor* marked
    private means essentially the same thing—only code from within the class can invoke
    the constructor. Nobody can say “new” from *outside* the class. That’s how it
    works with the Math class, for example. The constructor is private; you cannot
    make a new instance of Math. The compiler knows that your code doesn’t have access
    to that private constructor.
  prefs: []
  type: TYPE_NORMAL
- en: This does *not* mean that a class with one or more static methods should never
    be instantiated. In fact, every class you put a main() method in is a class with
    a static method in it!
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you make a main() method so that you can launch or test another class,
    nearly always by instantiating a class in main and then invoking a method on that
    new instance.
  prefs: []
  type: TYPE_NORMAL
- en: So you’re free to combine static and non-static methods in a class, although
    even a single non-static method means there must be *some* way to make an instance
    of the class. The only ways to get a new object are through “new” or deserialization
    (or something called the Java Reflection API that we don’t go into). No other
    way. But exactly *who* says new can be an interesting question, and one we’ll
    look at a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods can’t use non-static (instance) variables!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static methods run without knowing about any particular instance of the static
    method’s class. And as you saw on the previous pages, there might not even *be*
    any instances of that class. Since a static method is called using the *class*
    (***Math***.random()) as opposed to an *instance reference* (***t2***.play()),
    a static method can’t refer to any instance variables of the class. The static
    method doesn’t know *which* instance’s variable value to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**If you try to compile this code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0279-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You’ll get this error:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0279-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you try to use an instance variable from inside a static method, the compiler
    thinks, “I don’t know which object’s instance variable you’re talking about!”
    If you have ten Duck objects on the heap, a static method doesn’t know about any
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0279-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Static methods can’t use non-static methods, either!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do non-static methods do? ***They usually use instance variable state to
    affect the behavior of the method.*** A getName() method returns the value of
    the name variable. Whose name? The object used to invoke the getName() method.
  prefs: []
  type: TYPE_NORMAL
- en: '**This won’t compile:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0280-01.png)![image](Images/f0280-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Static variable: value is the same for ALL instances of the class'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you wanted to count how many Duck instances are being created while
    your program is running. How would you do it? Maybe an instance variable that
    you increment in the constructor?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0281-01.png)'
  prefs: []
  type: TYPE_IMG
- en: No, that wouldn’t work because duckCount is an instance variable, and starts
    at 0 for each Duck. You could try calling a method in some other class, but that’s
    kludgey. You need a class that’s got only a single copy of the variable, and all
    instances share that one copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s what a static variable gives you: a value shared by all instances of
    a class. In other words, one value per *class*, instead of one value per *instance*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0281-02.png)![image](Images/f0281-03.png)![image](Images/f0282-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Static variables are shared.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**All instances of the same class share a single copy of the static variables.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'instance variables: 1 per **instance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'static variables: 1 per **class**'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a static variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static variables are initialized when a *class is loaded*. A class is loaded
    because the JVM decides it’s time to load it. Typically, the JVM loads a class
    because somebody’s trying to make a new instance of the class, for the first time,
    or use a static method or variable of the class. As a programmer, you also have
    the option of telling the JVM to load a class, but you’re not likely to need to
    do that. In nearly all cases, you’re better off letting the JVM decide when to
    *load* the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'And there are two guarantees about static initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: Static variables in a class are initialized before any *object* of that class
    can be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static variables in a class are initialized before any *static method* of the
    class runs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0283-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you don’t explicitly initialize a static variable (by assigning it a value
    at the time you declare it), it gets a default value, so int variables are initialized
    to zero, which means we didn’t need to explicitly say playerCount = 0\. Declaring,
    but not initializing, a static variable means the static variable will get the
    default value for that variable type, in exactly the same way that instance variables
    are given default values when declared.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0283-02.png)'
  prefs: []
  type: TYPE_IMG
- en: static final variables are constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable marked **`final`** means that—once initialized—it can never change.
    In other words, the value of the static final variable will stay the same as long
    as the class is loaded. Look up Math.PI in the API, and you’ll find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The variable is marked **`public`** so that any code can access it.
  prefs: []
  type: TYPE_NORMAL
- en: The variable is marked **`static`** so that you don’t need an instance of class
    Math (which, remember, you’re not allowed to create).
  prefs: []
  type: TYPE_NORMAL
- en: The variable is marked **`final`** because PI doesn’t change (as far as Java
    is concerned).
  prefs: []
  type: TYPE_NORMAL
- en: There is no other way to designate a variable as a constant, but there is a
    naming convention that helps you to recognize one. ***Constant variable names
    are usually in all caps!***
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialize a *final* static variable:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **At the time you declare it:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0284-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**OR**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **In a static initializer:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0284-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**If you don’t give a value to a final variable in one of those two places:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0284-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The compiler will catch it:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0284-04.png)'
  prefs: []
  type: TYPE_IMG
- en: final isn’t just for static variables...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the keyword **`final`** to modify non-static variables too, including
    instance variables, local variables, and even method parameters. In each case,
    it means the same thing: the value can’t be changed. But you can also use final
    to stop someone from overriding a method or making a subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: '**non-static final variables**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0285-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**final method**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**final class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**A final variable means you can’t change its value.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A final method means you can’t override the method.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A final class means you can’ extend the class (i.e., you can’t make a subclass).**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0285-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“Sharpen your pencil”](#sharpen_your_pencil_left_parenthesisfrom).**'
  prefs: []
  type: TYPE_NORMAL
- en: Math methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how static methods work, let’s look at some static methods
    in class Math. This isn’t all of them, just the highlights. Check your API for
    the rest including cos(), sin(), tan(), ceil(), floor(), and asin().
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0288-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Math.abs()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a double that is the absolute value of the argument. The method is overloaded,
    so if you pass it an int, it returns an int. Pass it a double, it returns a double.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Math.random()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a double between (and including) 0.0 through (but not including) 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ve been using this method so far, but there’s also java.util.Random, which
    is a bit nicer to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Math.round()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an int or a long (depending on whether the argument is a float or a
    double) rounded to the nearest integer value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0289-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Math.min()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a value that is the minimum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Math.max()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a value that is the maximum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Math.sqrt()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the positive square root of the argument. The method takes a double,
    but of course you can pass in anything that fits in a double.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping a primitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you want to treat a primitive like an object. For example, collections
    like ArrayList only work with Objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0290-01.png)'
  prefs: []
  type: TYPE_IMG
- en: There’s a wrapper class for every primitive type, and since the wrapper classes
    are in the java.lang package, you don’t need to import them. You can recognize
    wrapper classes because each one is named after the primitive type it wraps, but
    with the first letter capitalized to follow the class naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh yeah, for reasons absolutely nobody on the planet is certain of, the API
    designers decided not to map the names *exactly* from primitive type to class
    type. You’ll see what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0290-02.png)![image](Images/f0290-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you need to treat a primitive like an object, wrap it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0290-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note: the picture at the top is a chocolate in a foil wrapper. Get it? Wrapper?
    Some people think it looks like a baked potato, but that works too.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0291-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Java will Autobox primitives for you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In The Olden Days (pre–Java 5), we did have to do all this ourselves, manually
    wrapping and unwrapping primitives. Fortunately, now it’s all done for us *automatically*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens when we want to make an ArrayList to hold ints.
  prefs: []
  type: TYPE_NORMAL
- en: '**An ArrayList of primitive ints**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0291-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Autoboxing works almost everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Autoboxing lets you do more than just the obvious wrapping and unwrapping to
    use primitives in a collection...it also lets you use either a primitive or its
    wrapper type virtually anywhere one or the other is expected. Think about that!
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun with autoboxing**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method arguments** If a method takes a wrapper type, you can pass a reference
    to a wrapper or a primitive of the matching type. And of course the reverse is
    true—if a method takes a primitive, you can pass in either a compatible primitive
    or a reference to a wrapper of that primitive type. | ![image](Images/f0292-01.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Return values** If a method declares a primitive return type, you can return
    either a compatible primitive or a reference to the wrapper of that primitive
    type. And if a method declares a wrapper return type, you can return either a
    reference to the wrapper type or a primitive of the matching type. | ![image](Images/f0292-02.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Boolean expressions** Any place a boolean value is expected, you can use
    either an expression that evaluates to a boolean (4 > 2), a primitive boolean,
    or a reference to a Boolean wrapper. | ![image](Images/f0292-03.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **Operations on numbers** This is probably the strangest one—yes, you can
    use a wrapper type as an operand in operations where the primitive type is expected.
    That means you can apply, say, the increment operator against a reference to an
    Integer object!'
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry—this is just a compiler trick. The language wasn’t modified
    to make the operators work on objects; the compiler simply converts the object
    to its primitive type before the operation. It sure looks weird, though.
  prefs: []
  type: TYPE_NORMAL
- en: Integer i = new Integer(42); i++;
  prefs: []
  type: TYPE_NORMAL
- en: 'And that means you can also do things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer j = new Integer(5); Integer k = j + 3; | ![image](Images/f0293-01.png)
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assignments** You can assign either a wrapper or primitive to a variable
    declared as a matching wrapper or primitive. For example, a primitive int variable
    can be assigned to an Integer reference variable, and vice versa—a reference to
    an Integer object can be assigned to a variable declared as an int primitive.
    | ![image](Images/f0293-02.png) |'
  prefs: []
  type: TYPE_TB
- en: '![Images](Images/arr.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: But wait! There’s more! Wrappers have static utility methods too!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides acting like a normal class, the wrappers have a bunch of really useful
    static methods.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the *parse* methods take a String and give you back a primitive
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Converting a String to a primitive value is easy:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**But if you try to do this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You’ll get a runtime exception:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Every method or constructor that parses a String can throw a NumberFormatException****.
    It’s a runtime exception, so you don’t have to handle or declare it. But you might
    want to.**'
  prefs: []
  type: TYPE_NORMAL
- en: (We’ll talk about exceptions in [Chapter 13](ch13.xhtml#risky_behavior_exception_handling),
    *Risky Behavior*.)
  prefs: []
  type: TYPE_NORMAL
- en: And now in reverse...turning a primitive number into a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to turn a number into a String, for example when you want to show
    this number to a user or put it into a message. There are several ways to turn
    a number into a String. The easiest is to simply concatenate the number to an
    existing String.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0295-01.png)![image](Images/f0295-02.png)![image](Images/f0295-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Number formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, formatting numbers and dates doesn’t have to be coupled with I/O. Think
    about it. One of the most typical ways to display numbers to a user is through
    a GUI. You put Strings into a scrolling text area, or maybe a table. If formatting
    was built only into print statements, you’d never be able to format a number into
    a nice String to display in a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: The Java API provides powerful and flexible formatting using the Formatter class
    in java.util. But often you don’t need to create and call methods on the Formatter
    class yourself, because the Java API has convenience methods in some of the I/O
    classes (including printf()) and the String class. So it can be a simple matter
    of calling a static String.format() method and passing it the thing you want formatted
    along with formatting instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you do have to know how to supply the formatting instructions, and
    that takes a little effort unless you’re familiar with the ***printf()*** function
    in C/C++. Fortunately, even if you *don’t* know printf(), you can simply follow
    recipes for the most basic things (that we’re showing in this chapter). But you
    *will* want to learn how to format if you want to mix and match to get *anything*
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start here with a basic example and then look at how it works. (Note:
    we’ll revisit formatting again in [Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr),
    *Saving Objects*.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Making big numbers more readable with underscores, a quick detour**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into formatting numbers, let’s take a small, useful detour. Sometimes
    you’ll want to declare variables with large initial values. Let’s look at three
    declarations that assign the same large value, a billion, to long primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0296-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Formatting a number to use commas**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0296-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Formatting deconstructed...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the most basic level, formatting consists of two main parts (there is more,
    but we’ll start with this to keep it cleaner):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Formatting instructions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use special format specifiers that describe how the argument should be formatted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **The argument to be formatted.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although there can be more than one argument, we’ll start with just one. The
    argument type can’t be just *anything*...it has to be something that can be formatted
    using the format specifiers in the formatting instructions. For example, if your
    formatting instructions specify a *floating-point number*, you can’t pass in a
    Dog or even a String that looks like a floating-point number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0297-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**What do these instructions actually say?**'
  prefs: []
  type: TYPE_NORMAL
- en: “Take the second argument to this method, and format it as a **d**ecimal integer
    and insert **commas**.”
  prefs: []
  type: TYPE_NORMAL
- en: '**How do they say that?**'
  prefs: []
  type: TYPE_NORMAL
- en: On the next page we’ll look in more detail at what the syntax “%,d” actually
    means, but for starters, any time you see the percent sign (%) in a format String
    (which is always the first argument to a format() method), think of it as representing
    a variable, and the variable is the other argument to the method. The rest of
    the characters after the percent sign describe the formatting instructions for
    the argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note: if you already know printf() from c/C++, you can probably just skim the
    next few pages. Otherwise, read carefully!'
  prefs: []
  type: TYPE_NORMAL
- en: The percent (%) says, “insert argument here” (and format it using these instructions)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first argument to a format() method is called the format String, and it
    can actually include characters that you just want printed as-is, without extra
    formatting. When you see the % sign, though, think of the percent sign as a variable
    that represents the other argument to the method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0298-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The “%” sign tells the formatter to insert the other method argument (the second
    argument to format(), the number) here, AND format it using the “.2f” characters
    after the percent sign. Then the rest of the format String, “bugs to fix,” is
    added to the final output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding a comma**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0298-02.png)![image](Images/f0299-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The format String uses its own little language syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You obviously can’t put just *anything* after the “%” sign. The syntax for what
    goes after the percent sign follows very specific rules, and describes how to
    format the argument that gets inserted at that point in the result (formatted)
    String.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**%,d** means “insert commas and format the number as a decimal integer.”'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '**%.2f** means “format the number as a floating point with a precision of two
    decimal places.”'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '**%,.2f** means “insert commas and format the number as a floating point with
    a precision of two decimal places.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Really the question is: “How do I know what to put after the percent sign to
    get it to do what I want?” And that includes knowing the symbols (like “d” for
    decimal and “f” for floating point) as well as the order in which the instructions
    must be placed following the percent sign. For example, if you put the comma after
    the “d” like “%d,” instead of “%,d” it won’t work!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or will it? What do you think this will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: (We’ll answer that on the next page.)
  prefs: []
  type: TYPE_NORMAL
- en: The format specifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything after the percent sign up to and including the type indicator (like
    “d” or “f”) is part of the formatting instructions. After the type indicator,
    the formatter assumes the next set of characters is meant to be part of the output
    String, until or unless it hits another percent (%) sign. Hmmmm...is that even
    possible? Can you have more than one formatted argument variable? Put that thought
    on hold for right now; we’ll come back to it in a few minutes. For now, let’s
    look at the syntax for the format specifiers—the things that go after the percent
    (%) sign and describe how the argument should be formatted.
  prefs: []
  type: TYPE_NORMAL
- en: '**A format specifier can have up to five different parts (not including the
    “%”). Everything in brackets [ ] below is optional, so only the percent (%) and
    the type are required. But the order is also mandatory, so any parts you DO use
    must go in this order.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0300-01.png)![image](Images/f0300-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The only required specifier is for TYPE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although type is the only required specifier, remember that if you *do* put
    in anything else, type must always come last! There are more than a dozen different
    type modifiers (not including dates and times; they have their own set), but most
    of the time you’ll probably use %d (decimal) or %f (floating point). And typically
    you’ll combine %f with a precision indicator to set the number of decimal places
    you want in your output.
  prefs: []
  type: TYPE_NORMAL
- en: '**The TYPE is mandatory, everything else is optional.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0301-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must include a type in your format instructions, and if you specify things
    besides type, the type must always come last. Most of the time, you’ll probably
    format numbers using either “d” for decimal or “f” for floating point.
  prefs: []
  type: TYPE_NORMAL
- en: The argument must be a byte, short, char, or int (including both primitive and
    wrapper types).
  prefs: []
  type: TYPE_NORMAL
- en: What happens if I have more than one argument?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you want a String that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: “The rank is ***20,456,654*** out of ***100,567,890.24***.”
  prefs: []
  type: TYPE_NORMAL
- en: But the numbers are coming from variables. What do you do? You simply add *two*
    arguments after the format String (first argument), so that means your call to
    format() will have three arguments instead of two. And inside that first argument
    (the format String), you’ll have two different format specifiers (two things that
    start with “%”). The first format specifier will insert the second argument to
    the method, and the second format specifier will insert the third argument to
    the method. In other words, the variable insertions in the format String use the
    order in which the other arguments are passed into the format() method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0302-01.png)'
  prefs: []
  type: TYPE_IMG
- en: As you’ll see when we get to date formatting, you might actually want to apply
    different formatting specifiers to the same argument. That’s probably hard to
    imagine until you see how *date* formatting (as opposed to the *number* formatting
    we’ve been doing) works. Just know that in a minute, you’ll see how to be more
    specific about which format specifiers are applied to which arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Just one more thing...static imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static imports are a real mixed blessing. Some people love this idea, some people
    hate it. Static imports exist to make your code a little shorter. If you hate
    to type or hate long lines of code, you might just like this feature. The downside
    to static imports is that—if you’re not careful—using them can make your code
    a lot harder to read.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that whenever you’re using a static class, a static variable,
    or an enum (more on those later), you can import them and save yourself some typing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Without static imports:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Same code, with static imports:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0303-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use carefully: Static imports can make your code confusing to read. Always
    re-read your code after using a static import and think: “Will I understand this
    in six months time?”'
  prefs: []
  type: TYPE_NORMAL
- en: Fireside Chats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0304-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tonight’s Talk: **An instance variable takes cheap shots at a static variable**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Instance Variable | Static Variable |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| I don’t even know why we’re doing this. Everyone knows static variables are
    just used for constants. And how many of those are there? I think the whole API
    must have, what, four? And it’s not like anybody ever uses them. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | You really should check your facts. When was the last time you looked
    at the API? It’s frickin’ loaded with statics! It even has entire classes dedicated
    to holding constant values. There’s a class called SwingConstants, for example,
    that’s just full of them. |'
  prefs: []
  type: TYPE_TB
- en: '| Full of it. Yeah, you can say that again. OK, so there are a few in the Swing
    library, but everybody knows Swing is just a special case. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | It might be a special case, but it’s a really important one! And what
    about the Color class? What a pain if you had to remember the RGB values to make
    the standard colors! But the color class already has constants defined for blue,
    purple, white, red, etc. Very handy. |'
  prefs: []
  type: TYPE_TB
- en: '| Ok, but besides a few GUI things, give me an example of just one static variable
    that anyone would actually use. In the real world. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | How’s System.out for starters? The out in System.out is a static variable
    of the System class. You personally don’t make a new instance of the System; you
    just ask the System class for its out variable. |'
  prefs: []
  type: TYPE_TB
- en: '| Well, that’s another special case. And nobody uses that except for debugging
    anyway. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Oh, like debugging isn’t important? And here’s something that probably
    never crossed your narrow mind—let’s face it, static variables are more efficient.
    One per class instead of one per instance. The memory savings might be huge! |'
  prefs: []
  type: TYPE_TB
- en: '| Um, aren’t you forgetting something? |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | What? |'
  prefs: []
  type: TYPE_TB
- en: '| Static variables are about as un-OO as it gets!! Gee, why not just go take
    a giant backward step and do some procedural programming while we’re at it. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | What do you mean *un-*OO? |'
  prefs: []
  type: TYPE_TB
- en: '| You’re like a global variable, and any programmer worth their sticker-covered
    laptop knows that’s usually a Bad Thing. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | I am NOT a global variable. There’s no such thing. I live in a class!
    That’s pretty OO you know, a CLASS. I’m not just sitting out there in space somewhere;
    I’m a natural part of the state of an object; the only difference is that I’m
    shared by all instances of a class. Very efficient. |'
  prefs: []
  type: TYPE_TB
- en: '| Yeah, you live in a class, but they don’t call it *Class*-Oriented programming.
    That’s just stupid. You’re a relic. Something to help the old-timers make the
    leap to Java. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Alright just stop right there. THAT is definitely not true. Some static
    variables are absolutely crucial to a system. And even the ones that aren’t crucial
    sure are handy. |'
  prefs: []
  type: TYPE_TB
- en: '| Well, OK, every once in a while sure, it makes sense to use a static, but
    let me tell you, abuse of static variables (and methods) is the mark of an immature
    OO programmer. A designer should be thinking about *object* state, not *class*
    state. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Why do you say that? And what’s wrong with static methods? |'
  prefs: []
  type: TYPE_TB
- en: '| Static methods are the worst things of all, because it usually means the
    programmer is thinking procedurally instead of about objects doing things based
    on their unique object state. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Sure, I know that objects should be the focus of an OO design, but just
    because there are some clueless programmers out there...don’t throw the baby out
    with the bytecode. There’s a time and place for statics, and when you need one,
    nothing else beats it. |'
  prefs: []
  type: TYPE_TB
- en: '| Riiiiiight. Whatever you need to tell yourself. |  |'
  prefs: []
  type: TYPE_TB
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0306-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The Java file on this page represents a complete program. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it? When it runs, what would be its output?**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Which of these is the output?
  prefs: []
  type: TYPE_NORMAL
- en: '**Possible Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0306-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Possible Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0306-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“BE the compiler”](#be_the_compiler_left_parenthesisfrom_pag).**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explored the wonderful, static world of Java. Your job is to decide
    whether each of the following statements is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: True or False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/hand.png)![image](Images/hand1.png)'
  prefs: []
  type: TYPE_IMG
- en: To use the Math class, the first step is to make an instance of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can mark a constructor with the **`static`** keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static methods don’t have access to instance variable state of the “this” object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is good practice to call a static method using a reference variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static variables could be used to count the instances of a class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructors are called before static variables are initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MAX_SIZE would be a good name for a static final variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A static initializer block runs before a class’s constructor runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a class is marked final, all of its methods must be marked final.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A final method can be overridden only if its class is extended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no wrapper class for boolean primitives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper is used when you want to treat a primitive like an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parseXxx methods always return a String.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisfr-id0002).**'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharpen your pencil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00021))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/pencil.png)'
  prefs: []
  type: TYPE_IMG
- en: 1, 4, 5, and 6 are legal.
  prefs: []
  type: TYPE_NORMAL
- en: 2 doesn’t compile because the static method references a non-static instance
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 3 doesn’t compile because the instance variable is final but hasn’t been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: BE the compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the compiler”](#be_the_compiler-id00002))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: StaticSuper is a constructor and must have ( ) in its signature. Notice that
    as the output below demonstrates, the static blocks for both classes run before
    either of the constructors run.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0308-02.png)'
  prefs: []
  type: TYPE_IMG
- en: True or False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“True or False”](#true_or_false))
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: To use the Math class, the first step is to make an instance of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: You can mark a constructor with the keyword “static.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Static methods don’t have access to an object’s instance variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to call a static method using a reference variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Static variables could be used to count the instances of a class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors are called before static variables are initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: MAX_SIZE would be a good name for a static final variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A static initializer block runs before a class’s constructor runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If a class is marked final, all of its methods must be marked final.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A final method can be overridden only if its class is extended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: There is no wrapper class for boolean primitives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A wrapper is used when you want to treat a primitive like an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The parseXxx methods always return a String.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  prefs: []
  type: TYPE_TB
