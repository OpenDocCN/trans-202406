- en: Chapter 10\. Modular JavaScript Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of scalable JavaScript, when we say an application is *modular*,
    we often mean it’s composed of a set of highly decoupled, distinct pieces of functionality
    stored in modules. Loose coupling facilitates easier maintainability of apps by
    removing *dependencies* where possible. When implemented efficiently, it becomes
    pretty easy to see how changes to one part of a system may affect another.
  prefs: []
  type: TYPE_NORMAL
- en: In the earlier chapters, we covered the importance of modular programming and
    the modern way of implementing modular design patterns. While [ES2015](https://oreil.ly/Pcc5o)
    introduced native modules to JavaScript, writing modular JavaScript was still
    possible before 2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at three formats for modular JavaScript using
    classic JavaScript (ES5) syntax: Asynchronous Module Definition (AMD), CommonJS,
    and Universal Module Definition (UMD). To learn more about JavaScript modules,
    please refer to [Chapter 5](ch05.xhtml#modern-javascript-syntax), which covers
    ES2015+ syntax for module imports, exports, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Script Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It isn’t easy to discuss AMD and CommonJS modules without talking about [script
    loaders](https://oreil.ly/ssCQT). Script loading was a means to a goal. Modular
    JavaScript could be implemented only using compatible script loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Several great loaders were available for handling module loading in the AMD
    and CommonJS formats, but I personally preferred [RequireJS](https://oreil.ly/Ri_9R)
    and [curl.js](https://oreil.ly/s7QRg).
  prefs: []
  type: TYPE_NORMAL
- en: AMD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AMD format was introduced as a proposal for defining modules in which both
    the module and dependencies can be [asynchronously loaded](https://oreil.ly/iTNe3).
    The overall goal for the AMD format is to provide a solution for modular JavaScript
    that developers could use. It has several distinct advantages, including being
    both asynchronous and highly flexible by nature, which removes the tight coupling
    one might commonly find between code and module identity. Many developers enjoyed
    using AMD, and one could consider it a reliable stepping stone toward [JavaScript
    modules](https://oreil.ly/yxADG), which were unavailable at the time.
  prefs: []
  type: TYPE_NORMAL
- en: AMD began as a draft specification for a module format on the CommonJS list,
    but as it couldn’t reach full consensus, further development of the format moved
    to the [amdjs group](https://oreil.ly/0-XeU).
  prefs: []
  type: TYPE_NORMAL
- en: It was embraced by projects including Dojo, MooTools, and even jQuery. Although
    the term *CommonJS AMD format* has been seen in the wild occasionally, it’s best
    to refer to it as just AMD or Async Module support because not all participants
    on the CommonJS list wished to pursue it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There was a time when the proposal was referred to as Modules Transport/C. However,
    because the spec wasn’t geared toward transporting existing CommonJS modules but
    rather for defining modules, it made more sense to opt for the AMD naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first two concepts worth noting about AMD are the ideas of a `define` method
    for facilitating module definition and a `require` method for handling dependency
    loading. `define` is used to define named or unnamed modules using the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can tell by the inline comments, the `module_id` is an optional argument
    that is typically required only when non-AMD concatenation tools are being used
    (there may be some other edge cases where it’s useful, too). When this argument
    is left out, we refer to the module as *anonymous*.
  prefs: []
  type: TYPE_NORMAL
- en: When working with anonymous modules, the idea of a module’s identity is DRY
    (Don’t repeat yourself), making it trivial to avoid duplication of filenames and
    code. Because the code is more portable, it can be easily moved to other locations
    (or around the filesystem) without needing to alter the code itself or change
    its module ID. Consider the `module_id` similar to the concept of folder paths.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Developers can run this same code on multiple environments using an AMD optimizer
    that works with a CommonJS environment such as [r.js](https://oreil.ly/48dSL).
  prefs: []
  type: TYPE_NORMAL
- en: Back to the `define` signature, the `dependencies` argument represents an array
    of dependencies required by the module we are defining, and the third argument
    (`definition` `function` or `factory function`) is a function that’s executed
    to instantiate our module. A bare bones module could be defined as in [Example 10-1](#understanding_AMD_define).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10-1\. Understanding AMD: `define()`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, `require` is typically used to load code in a top-level JavaScript
    file or within a module should we wish to fetch dependencies dynamically. An example
    of its usage is in [Example 10-2](#understanding_AMD_require).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10-2\. Understanding AMD: `require()`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10-3](#dynamically-loaded-dependencies) shows a dynamically loaded
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. Dynamically loaded dependencies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10-4](#understanding-amd-plugins) shows defining an AMD-compatible
    plug-in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10-4\. Understanding AMD: plug-ins'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although `css!` is included for loading Cascading Style Sheets (CSS) dependencies
    in the preceding example, it’s important to remember that this approach has some
    caveats, such as not being able to establish when the CSS is fully loaded. Depending
    on how we approach our build process, it may also result in CSS being included
    as a dependency in the optimized file, so use CSS as a loaded dependency in such
    cases with caution. If you’re interested in doing this, we can explore [@VIISON’s
    RequireJS CSS plug-in](https://oreil.ly/PrLim).
  prefs: []
  type: TYPE_NORMAL
- en: 'This example could simply be looked at as `requirejs(["app/myModule"], function(){})`,
    which indicates the loader’s top-level globals are being used. This is how to
    kick off the top-level loading of modules with different AMD loaders. However,
    if a `define()` function is passed as a local require, all `require([]`) examples
    apply to both types of loader: curl.js and RequireJS (Examples [10-5](#loading-amd-using-requirejs)
    and [10-6](#loading-amd-using-curljs)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5\. Loading AMD modules using RequireJS
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Example 10-6\. Loading AMD modules using curl.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows is the code for modules with deferred dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we’ve seen in previous sections, design patterns can be highly effective
    in improving how we approach structuring solutions to common development problems.
    [John Hann](https://oreil.ly/SrQI5) has given some excellent presentations about
    AMD module design patterns covering the Singleton, Decorator, Mediator, and others.
    I highly recommend checking out his [slides](https://oreil.ly/7koME).
  prefs: []
  type: TYPE_NORMAL
- en: AMD Modules with jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'jQuery comes with only one file. However, given the plug-in-based nature of
    the library, we can demonstrate how straightforward it is to define an AMD module
    that uses it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, there is something missing from this example, and it’s the registration
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: Registering jQuery as an async-compatible module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the key features that landed in jQuery 1.7 was support for registering
    jQuery as an asynchronous module. A number of compatible script loaders (including
    RequireJS and curl) are capable of loading modules using an asynchronous module
    format, which means fewer hacks are required to get things working.
  prefs: []
  type: TYPE_NORMAL
- en: If a developer wants to use AMD and does not want her jQuery version leaking
    into the global space, she should call `noConflict` in their top-level module
    that uses jQuery. In addition, since multiple versions of jQuery can be on a page,
    there are special considerations that an AMD loader must account for, so jQuery
    only registers with AMD loaders that have recognized these concerns, which are
    indicated by the loader specifying `define.amd.jQuery`. RequireJS and curl are
    two loaders that do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The named AMD provides a robust and safe safety blanket for most use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Why was AMD a better choice for writing modular JavaScript?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have now reviewed several code samples taking us through what AMD is capable
    of. It appears to be more than just a typical Module pattern, but why was it a
    better choice for modular application development?
  prefs: []
  type: TYPE_NORMAL
- en: Provides a clear proposal for how to approach defining flexible modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significantly cleaner than the present global namespace and `<script>` tag solutions
    many of us rely on. There’s a clean way to declare standalone modules and dependencies
    they may have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module definitions are encapsulated, helping us to avoid pollution of the global
    namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguably works better than some alternative solutions (e.g., CommonJS, which
    we’ll be looking at shortly). It doesn’t have issues with cross-domain, local,
    or debugging and doesn’t rely on server-side tools to be used. Most AMD loaders
    support loading modules in the browser without a build process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a “transport” approach for including multiple modules in a single file.
    Other approaches like CommonJS have yet to agree on a transport format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s possible to lazy-load scripts if this is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most of the points mentioned are valid for YUI’s module-loading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Related reading for AMD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[The RequireJS Guide to AMD](https://oreil.ly/uPEJg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What’s the Fastest Way to Load AMD Modules?](https://oreil.ly/Z04H9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[AMD vs. CommonJS, What’s the Better Format?](https://oreil.ly/W4Fqi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Future Is Modules Not Frameworks](https://oreil.ly/A9S7c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[AMD No Longer a CommonJS Specification](https://oreil.ly/Tkti9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[On Inventing JavaScript Module Formats and Script Loaders](https://oreil.ly/AB01l)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The AMD Mailing List](https://oreil.ly/jdTYO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script loaders and frameworks that support AMD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In-browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[RequireJS](https://oreil.ly/Ri_9R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[curl.js](https://oreil.ly/fi105)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Yabble](https://oreil.ly/oBWDi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PINF](https://oreil.ly/C28-D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server-side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[RequireJS](https://oreil.ly/Ri_9R)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PINF](https://oreil.ly/TJldu)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having used AMD for several projects, I conclude that it ticks a lot of the
    checkboxes that developers creating serious applications might desire from a better
    module format. It avoids the need to worry about globals, supports named modules,
    doesn’t require server transformation to function, and is a pleasure to use for
    dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also an excellent addition for modular development using Backbone.js, ember.js,
    or other structural frameworks for keeping applications organized.
  prefs: []
  type: TYPE_NORMAL
- en: As AMD was heavily discussed within the Dojo and CommonJS worlds, we know it’s
    had time to mature and evolve. We also know it’s been battle-tested in the wild
    by a number of large companies to build nontrivial applications (IBM, BBC iPlayer),
    and so, if it didn’t work, chances are they would have abandoned it, but they
    didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are still areas where AMD could have been improved. Developers
    who have used the format for some time may feel the AMD boilerplate/wrapper code
    was an annoying overhead. While I share this concern, there were tools such as
    [Volo](https://oreil.ly/TLSYv) that helped work around these issues, and I would
    argue that, on the whole, the pros with using AMD far outweighed the cons.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CommonJS module proposal specifies a simple API for declaring modules server-side.
    Unlike AMD, it attempts to cover broader concerns such as I/O, file-system, promises,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Originally called ServerJS in a project started by Kevin Dangoor back in 2009,
    the format was later formalized by [CommonJS](https://oreil.ly/EUFt3), a volunteer
    working group that aims to design, prototype, and standardize JavaScript APIs.
    They attempted to ratify standards for both [modules](https://oreil.ly/v_hsu)
    and [packages](https://oreil.ly/Trgzj).
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From a structural perspective, a CommonJS module is a reusable piece of JavaScript
    that exports specific objects made available to any dependent code. Unlike AMD,
    there are typically no function wrappers around such modules (so we won’t see
    `define` here, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'CommonJS modules contain two primary parts: a free variable named `exports`,
    which includes the objects a module wishes to make available to other modules,
    and a `require` function that modules can use to import the exports of other modules
    (Examples [10-7](#understanding-common-js-exports), [10-8](#basic-consumption-of-exports),
    and [10-9](#amd-equivalent-first-commonjs)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10-7\. Understanding CommonJS: `require()` and `exports`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 10-8\. Basic consumption of `exports`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 10-8](#basic-consumption-of-exports), we first import the module
    containing the `foo` function from [Example 10-7](#understanding-common-js-exports)
    using the `require()` function. Then, we consume the `foo` function by calling
    it from the imported module with `exampleModule.foo()`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9\. AMD-equivalent of the first CommonJS example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This can be done as AMD supports a [simplified CommonJS wrapping](https://oreil.ly/IzG9s)
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Multiple Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*app.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*bar.js:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*foo.js:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: CommonJS in Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ES module format has become the standard format for encapsulating JavaScript
    code for reuse, but CommonJS is the default in Node.js. CommonJS modules are the
    original way to package JavaScript code for [Node.js](https://oreil.ly/4Bh_O),
    although starting with version 13.2.0, Node.js has stable support of ES modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Node.js treats the following as CommonJS modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Files with a *.cjs* extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files with a *.js* extension when the nearest parent *package.json* file contains
    a top-level field *type* with a value of *commonjs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files with a *.js* extension when the nearest parent *package.json* file doesn’t
    contain a top-level field *type*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files with an extension that is not *.mjs*, *.cjs*, *.json*, *.node*, or *.js*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `require()` always uses the CommonJS module loader, while calling `import()`
    always uses the ECMAScript module loader irrespective of the type value configured
    in the nearest parent *package.json*.
  prefs: []
  type: TYPE_NORMAL
- en: Many Node.js libraries and modules are written with CommonJS. For browser support,
    all major browsers support the ES module syntax, and you can use import/export
    in frameworks like React and Vue.js. These frameworks use a transpiler like Babel
    to compile the import/export syntax to `require()`, which older Node.js versions
    natively support. Libraries written using ES6 module syntax will be transpiled
    to CommonJS under the hood if you run the code in Node.
  prefs: []
  type: TYPE_NORMAL
- en: Is CommonJS Suitable for the Browser?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are developers who feel that CommonJS is better suited to server-side
    development, which is one reason there was a disagreement over whether AMD or
    CommonJS should be used as the de facto standard before ES2015\. Some arguments
    against CommonJS were that many CommonJS APIs address server-oriented features
    that one would be unable to implement at a browser level in JavaScript—for example,
    *io*, *system*, and *js* could be considered unimplementable by the nature of
    their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, it’s useful to know how to structure CommonJS modules so that we
    can better appreciate how they fit in when defining modules that may be used everywhere.
    Modules with applications on both the client and server include validation, conversion,
    and templating engines. Some developers approached choosing which format to use
    by opting for CommonJS when a module can be used in a server-side environment
    and using AMD or ES2015 if this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 and AMD modules can define more granular things like constructors and
    functions. CommonJS modules can only define objects, which can be tedious to work
    with if we’re trying to obtain constructors from them. For new projects in Node.js,
    ES2015 modules provide an alternative to CommonJS on the server and also ensure
    that the syntax is identical to the client-side code. Thus, it creates an easier
    route to isomorphic JavaScript, which can run in the browser or on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s beyond the scope of this section, you may have noticed that there
    were different types of `require` methods mentioned when discussing AMD and CommonJS.
    The concern with a similar naming convention is confusion, and the community is
    split on the merits of a global `require` function. John Hann’s suggestion here
    is that rather than calling it `require`, which would probably fail to achieve
    the goal of informing users about the different between a global and inner `require`,
    it may make more sense to rename the global loader method something else (e.g.,
    the name of the library). It’s for this reason that a loader like curl.js uses
    `curl()` instead of `require`.
  prefs: []
  type: TYPE_NORMAL
- en: Related Reading for CommonJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[JavaScript Growing Up](https://oreil.ly/NeuFT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The RequireJS Notes on CommonJS](https://oreil.ly/Nb-5e)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Taking Baby Steps with Node.js and CommonJS—Creating Custom Modules](https://oreil.ly/ZpO5u)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Asynchronous CommonJS Modules for the Browser](https://oreil.ly/gJhQA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The CommonJS Mailing List](https://oreil.ly/rL3C2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AMD and CommonJS: Competing, but Equally Valid Standards'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both AMD and CommonJS are valid module formats with different end goals.
  prefs: []
  type: TYPE_NORMAL
- en: AMD adopts a browser-first approach to development, opting for asynchronous
    behavior and simplified backward compatibility, but it doesn’t have any concept
    of file I/O. It supports objects, functions, constructors, strings, JSON, and
    many other types of modules, running natively in the browser. It’s incredibly
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS, on the other hand, takes a server-first approach, assuming synchronous
    behavior, no global *baggage*, and attempts to cater to the future (on the server).
    What I mean by this is that because CommonJS supports unwrapped modules, it can
    feel a little closer to the ES2015+ specifications, freeing us of the `define()`
    wrapper that AMD enforces. CommonJS modules, however, support objects only as
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'UMD: AMD and CommonJS-Compatible Modules for Plug-ins'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These solutions could be a little lacking for developers wishing to create modules
    that can work in browser and server-side environments. To help alleviate this,
    James Burke, I, and several other developers created [Universal Module Definition
    (UMD)](https://oreil.ly/HaHHJ).
  prefs: []
  type: TYPE_NORMAL
- en: UMD is an experimental module format that allows the definition of modules that
    work in both client and server environments with all or most of the popular script-loading
    techniques available at the time of writing. Although the idea of (yet) another
    module format may be daunting, we will cover UMD briefly for thoroughness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We began defining UMD by looking at the simplified CommonJS wrapper supported
    in the AMD specification. Developers wishing to write modules as if they were
    CommonJS modules could use the following CommonJS-compatible format:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic AMD hybrid format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It’s essential, however, to note that a module is really only treated as a CommonJS
    module if it doesn’t contain a dependency array and the definition function contains
    one parameter at minimum. This also won’t work correctly on some devices (e.g.,
    the PS3). For further information about the wrapper, see the [RequireJS documentation](https://oreil.ly/7A9k6).
  prefs: []
  type: TYPE_NORMAL
- en: Taking this further, we wanted to provide several different patterns that worked
    with AMD and CommonJS and solved typical compatibility problems developers wishing
    to develop such modules had with other environments.
  prefs: []
  type: TYPE_NORMAL
- en: One such variation we can see next allows us to use CommonJS, AMD, or browser
    globals to create a module.
  prefs: []
  type: TYPE_NORMAL
- en: Using CommonJS, AMD, or browser globals to create a module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Define a module `commonJsStrict`, which depends on another module called `b`.
    The filename implies the module’s name, and it’s best practice for the filename
    and the exported global to have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the module `b` also uses the same boilerplate type in the browser, it will
    create a global `.b` that is used. If we don’t wish to support the browser global
    patch, we can remove the `root` and pass `this` as the first argument to the top
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The UMD repository contains variations covering modules that work optimally
    in the browser, those best for providing exports, those optimal for CommonJS runtimes,
    and even those that work best for defining jQuery plug-ins, which we will look
    at next.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery plug-ins that function in all environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UMD provides two patterns for working with jQuery plug-ins: one that defines
    plug-ins that work well with AMD and browser globals and another that can also
    work in CommonJS environments. jQuery is not likely to be used in most CommonJS
    environments, so keep this in mind unless we’re working with an environment that
    does play well with it.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now define a plug-in composed of a core and an extension to that core.
    The core plug-in is loaded into a `$.core` namespace, which can then be easily
    extended using plug-in extensions via the namespacing pattern. Plug-ins loaded
    via `script` tags automatically populate a `plugin` namespace under `core` (i.e.,
    `$.core.plugin.methodName()`).
  prefs: []
  type: TYPE_NORMAL
- en: The pattern can be nice to work with, because plug-in extensions can access
    properties and methods defined in the base or, with a bit of tweaking, override
    default behavior so that it can be extended to do more. A loader is also not required
    to make any of this fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: For more details of what is being done, please see the inline comments in these
    code samples.
  prefs: []
  type: TYPE_NORMAL
- en: '*usage.html:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*pluginCore.js:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*pluginExtension.js:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: UMD doesn’t aim to replace AMD or CommonJS but merely offers some supplemental
    assistance for developers wishing to get their code working in more environments
    today. For further information or to contribute suggestions toward this experimental
    format, see [this GitHub page](https://oreil.ly/H2pUf).
  prefs: []
  type: TYPE_NORMAL
- en: Related reading for UMD and AMD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Using AMD Loaders to Write and Manage Modular JavaScript](https://oreil.ly/Zgs_G)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[AMD Module Patterns: Singleton](https://oreil.ly/IP22B)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Standards and Proposals for JavaScript Modules and jQuery](https://oreil.ly/I-3jy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section reviewed several options for writing modular JavaScript using different
    module formats before ES2015+.
  prefs: []
  type: TYPE_NORMAL
- en: These formats had several advantages over using the Module pattern alone, including
    avoiding the need to manage global variables, better support for static and dynamic
    dependency management, improved compatibility with script loaders, better compatibility
    for modules on the server, and more.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude our discussion of classic design and architecture patterns, I want
    to touch on one area where we can apply patterns to structure and organize our
    JavaScript code in the next chapter on Namespacing patterns.
  prefs: []
  type: TYPE_NORMAL
