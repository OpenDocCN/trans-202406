<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Workload Runtime Security"><div class="chapter" id="workload_runtime_security">
<h1><span class="label">Chapter 4. </span>Workload Runtime Security</h1>

<p class="byline plain">With contributions from Manoj Ahuje,</p> 
<p class="byline">Senior Threat Intelligence Research Engineer at Tigera</p> 

<p>Kubernetes’ default pod provisioning mechanism has a wide attack surface that can be used by adversaries to exploit the cluster or escape the container. In this chapter you will learn how to implement pod security policies (PSPs) to limit the attack surface of the pods and how to monitor processes (e.g., process privileges), file access, and runtime security for your workloads. Here are a few specifics of what we will <span class="keep-together">discuss:</span></p>
<ul>
<li><p>We will cover the implementation details of PSPs, like pod security contexts, and also explain the limitations of PSPs. Note PSPs are deprecated as of Kubernetes v1.21; however, we will cover this topic in this chapter as we are aware that PSPs are widely used.</p></li>
<li><p>We will discuss process monitoring, which focuses on the need for Kubernetes-native monitoring to detect suspicious activities. We will cover runtime monitoring and enforcement using kernel security features like seccomp, SELinux, and AppArmor to prevent containers from accessing host resources.</p></li>
<li><p>We will cover both detection and runtime defense against vulnerabilities, workload isolation, and a blast radius containment.</p></li>
</ul>
<section data-type="sect1" data-pdf-bookmark="Pod Security Policies"><div class="sect1" id="pod_security_policies_left_parenthesisp">
<h1>Pod Security Policies</h1>
<p>Kubernetes provides a way to securely onboard your pods and containers by using PSPs.<a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="security policies" data-tertiary="about" id="idm45326832437616"/><a contenteditable="false" data-type="indexterm" data-primary="pod security policies (PSPs)" data-secondary="about" id="idm45326832435968"/><a contenteditable="false" data-type="indexterm" data-primary="policies" data-secondary="pod security policies" data-see="pod security policies" id="idm45326832434528"/><a contenteditable="false" data-type="indexterm" data-primary="runtime security" data-secondary="pod security policies" id="ch04-psp2"/> They are a cluster-scoped resource that checks for a set of conditions before a pod is admitted and scheduled to run in a cluster. This is achieved via a Kubernetes admission controller, which evaluates every pod creation request for compliance with the PSP assigned to the pod.</p>
<p>Please note that PSPs are deprecated with Kubernetes<a contenteditable="false" data-type="indexterm" data-primary="pod security policies (PSPs)" data-secondary="about" data-tertiary="deprecation" id="idm45326832430400"/><a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="security policies" data-tertiary="deprecation" id="idm45326832428736"/> release 1.21 and are scheduled to be removed in release 1.25. They are widely used in production clusters, though, and therefore this section will help you understand how they work and what best practices are for implementing PSPs.</p>
<p>PSPs let you enforce rules with controls like <em>pods should not run as root</em> or <em>pods should not use host network, host namespace, or run as privileged.</em> The policies are enforced at pod creation time. By using PSPs you can make sure pods are created with the minimum privileges needed for operation, which reduces the attack surface for your application. Additionally, this mechanism helps you to be compliant with various standards like PCI, SOC 2, or HIPAA, which mandates the use of principle of least privilege access. As the name suggests, the principle requires that any process, user, or, in our case, workload be granted the least amount of privileges necessary for it to function.</p>
<section data-type="sect2" data-pdf-bookmark="Using Pod Security Policies"><div class="sect2" id="using_pod_security_policies">
<h2>Using Pod Security Policies</h2>
<p>Kubernetes PSPs are recommended but implemented via an optional admission controller.<a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="security policies" data-tertiary="using" id="ch04-use"/><a contenteditable="false" data-type="indexterm" data-primary="pod security policies (PSPs)" data-secondary="using" id="ch04-use2"/><a contenteditable="false" data-type="indexterm" data-primary="admission controllers" data-secondary="pod security policies" id="ch04-use4"/><a contenteditable="false" data-type="indexterm" data-primary="plug-ins" data-secondary="PodSecurityPolicy" id="idm45326832417344"/> The enforcement of PSPs can be turned on by enabling an admission controller. That means the Kubernetes API server manifest should have a PodSecurityPolicy plug-in in its --enable-admission-plugins list. Many Kubernetes distros do not support or by default disable PSPs, so it’s worth checking while choosing the Kubernetes distros.</p>
<p>Once the PSPs are enabled, it’s a three-step process to apply PSPs, as shown in <a data-type="xref" href="#process_to_apply_psps">Figure 4-1</a>. A best practice is to apply PSPs to groups rather than individual service accounts.</p>
<figure><div id="process_to_apply_psps" class="figure">
<img src="Images/ksao_0401.png" alt="" width="1442" height="617"/>
<h6><span class="label">Figure 4-1. </span>Process to apply PSPs</h6>
</div></figure>
<p>Step 1 is to create a PSP. Step 2 is to create ClusterRole with the <code>use</code> verb, which authorizes pod deployment controllers to use the policies. Then step 3 is to create ClusterRoleBindings, which is used to enforce policy for the groups (i.e., system:authenticated or system:unauthenticated) or service accounts.</p>
<p>A good starting point is the PSP template from the Kubernetes project:</p>
<pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">policy/v1beta1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">PodSecurityPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">restricted</code>
  <code class="nt">annotations</code><code class="p">:</code>
    <code class="nt">seccomp.security.alpha.kubernetes.io/allowedProfileNames</code><code class="p">:</code> <code class="p-Indicator">|</code>
    <code class="s">'docker/default,runtime/default'</code>
    <code class="nt">apparmor.security.beta.kubernetes.io/allowedProfileNames</code><code class="p">:</code> <code class="s">'runtime/default'</code>
    <code class="nt">seccomp.security.alpha.kubernetes.io/defaultProfileName</code><code class="p">:</code>  <code class="s">'runtime/default'</code>
    <code class="nt">apparmor.security.beta.kubernetes.io/defaultProfileName</code><code class="p">:</code>  <code class="s">'runtime/default'</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">privileged</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>
  <code class="c1"># Required to prevent escalations to root.</code>
  <code class="nt">allowPrivilegeEscalation</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>
  <code class="c1"># This is redundant with non-root + disallow privilege escalation,</code>
  <code class="c1"># but we can provide it for defense in depth.</code>
  <code class="nt">requiredDropCapabilities</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">ALL</code>
  <code class="c1"># Allow core volume types.</code>
  <code class="nt">volumes</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="s">'configMap'</code>
    <code class="p-Indicator">-</code> <code class="s">'emptyDir'</code>
    <code class="p-Indicator">-</code> <code class="s">'projected'</code>
    <code class="p-Indicator">-</code> <code class="s">'secret'</code>
    <code class="p-Indicator">-</code> <code class="s">'downwardAPI'</code>
    <code class="c1"># Assume that persistentVolumes set up by the cluster admin are safe to use.</code>
    <code class="p-Indicator">-</code> <code class="s">'persistentVolumeClaim'</code>
  <code class="nt">hostNetwork</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>
  <code class="nt">hostIPC</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>
  <code class="nt">hostPID</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>
  <code class="nt">runAsUser</code><code class="p">:</code>
    <code class="c1"># Require the container to run without root privileges.</code>
    <code class="nt">rule</code><code class="p">:</code> <code class="s">'MustRunAsNonRoot'</code>
  <code class="nt">seLinux</code><code class="p">:</code>
    <code class="c1"># This policy assumes the nodes are using AppArmor rather than SELinux.</code>
    <code class="nt">rule</code><code class="p">:</code> <code class="s">'RunAsAny'</code>
  <code class="nt">supplementalGroups</code><code class="p">:</code>
    <code class="nt">rule</code><code class="p">:</code> <code class="s">'MustRunAs'</code>
    <code class="nt">ranges</code><code class="p">:</code>
      <code class="c1"># Forbid adding the root group.</code>
      <code class="p-Indicator">-</code> <code class="nt">min</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>
        <code class="nt">max</code><code class="p">:</code> <code class="l-Scalar-Plain">65535</code>
  <code class="nt">fsGroup</code><code class="p">:</code>
    <code class="nt">rule</code><code class="p">:</code> <code class="s">'MustRunAs'</code>
    <code class="nt">ranges</code><code class="p">:</code>
      <code class="c1"># Forbid adding the root group.</code>
      <code class="p-Indicator">-</code> <code class="nt">min</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>
        <code class="nt">max</code><code class="p">:</code> <code class="l-Scalar-Plain">65535</code>
  <code class="nt">readOnlyRootFilesystem</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code></pre>
<p>In the following example, you apply this policy to all authenticated users using Kubernetes role-based access control:<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-use" id="idm45326832408576"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-use2" id="idm45326832407360"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-use4" id="idm45326832234480"/></p>
<pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole  Policy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">psp-restricted</code>
<code class="nt">rules</code><code class="p">:</code>
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">policy</code>
  <code class="nt">resourceNames</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">restricted</code>
  <code class="nt">resources</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">podsecuritypolicies</code>
  <code class="nt">verbs</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">use</code>
<code class="nn">---</code>
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRoleBinding</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">psp-restricted-binding</code>
<code class="nt">roleRef</code><code class="p">:</code>
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">psp-restricted</code>
<code class="nt">subjects</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>
    <code class="nt">kind </code><code class="p">:</code> <code class="l-Scalar-Plain">Group</code>
    <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">system:authenticated</code></pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Pod Security Policy Capabilities"><div class="sect2" id="pod_security_policy_capabilities">
<h2>Pod Security Policy Capabilities</h2>
<p>Let’s focus on the capabilities provided by PSPs that you can utilize as <a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="security policies" data-tertiary="capabilities" id="idm45326832124368"/><a contenteditable="false" data-type="indexterm" data-primary="pod security policies (PSPs)" data-secondary="capabilities" id="idm45326832122752"/>required by your use case and internal threat model. You can follow the example PSP template we just discussed to build your own PSPs. In this template most of the PSP capabilities are utilized to formulate a restrictive policy.</p>
<p>To explain the impact of a capability, let’s take a look at an example where you see capabilities granted to the pod created with privileged:true and with privileged:false. <a contenteditable="false" data-type="indexterm" data-primary="Linux distributions" data-secondary="utilities/modules" data-tertiary="capsh" id="idm45326832120336"/><a contenteditable="false" data-type="indexterm" data-primary="capsh Linux utility" id="idm45326832118688"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="capsh" id="idm45326832117584"/>A Linux utility <a href="https://oreil.ly/UuDcu">capsh</a> can be used to evaluate the permissions of containerized root users. As you can see in <a data-type="xref" href="#pod_capabilities_for_default_and_privil">Figure 4-2</a>, the privileged pod has a plethora of capabilities in its Linux namespace, which translates to a wider attack surface for an attacker to escape your container.</p>
<figure><div id="pod_capabilities_for_default_and_privil" class="figure">
<img src="Images/ksao_0402.png" alt="" width="1717" height="514"/>
<h6><span class="label">Figure 4-2. </span>Pod capabilities for default and privileged pods</h6>
</div></figure>

<p><a data-type="xref" href="#summarizes_the_capabilities_for_pods_as">Table 4-1</a> summarizes the capabilities for pods as described in the <a href="https://oreil.ly/FSDGN">Kubernetes PSP documentation</a>.</p>

<table class="border" id="summarizes_the_capabilities_for_pods_as">
<caption><span class="label">Table 4-1. </span>Pod capabilities<a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="security policies" data-tertiary="documentation online" id="idm45326832108720"/><a contenteditable="false" data-type="indexterm" data-primary="pod security policies (PSPs)" data-secondary="documentation online" id="idm45326832107040"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="documentation online" data-tertiary="pod security policies" id="idm45326832105648"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="Kubernetes documentation" data-tertiary="pod security policies" id="idm45326832104000"/></caption>
<thead>
<tr>
<th>Field</th>
<th>Uses</th>
</tr>
</thead>
<tbody>
<tr>
<td>privileged</td>
<td>Allow containers to gain capabilities that include access to host mounts, filesystem to change settings, and many more. You can check capabilities with command capsh --print.</td>
</tr>
<tr>
<td>hostPID, hostIPC</td>
<td>Give container access to host namespaces where process and Ethernet interfaces are visible to it.</td>
</tr>
<tr>
<td>hostNetwork, hostPorts</td>
<td>Give container IP access to the host network and ports.</td>
</tr>
<tr>
<td>volumes</td>
<td>Allow volumes types like configMap, emtyDir, or secret.</td>
</tr>
<tr>
<td>allowedHostPaths</td>
<td>Allow the whitelisting of host paths that can be used by hostPath volumes (i.e., /tmp).</td>
</tr>
<tr>
<td>allowedFlexVolumes</td>
<td>Allow specific FlexVolume drivers (i.e., azure/kv).</td>
</tr>
<tr>
<td>fsGroup</td>
<td>Set a GID or range of GID that owns the pod’s volumes.</td>
</tr>
<tr>
<td>readOnlyRootFilesystem</td>
<td>Set the container’s root filesystem to read-only.</td>
</tr>
<tr>
<td>runAsUser, runAsGroup, supplementalGroups</td>
<td>Define containers UID and GID. Here you can specify non-root user or groups.</td>
</tr>
<tr>
<td>allowPrivilegeEscalation, defaultAllowPrivilegeEscalation</td>
<td>Restrict privilege escalation by process.</td>
</tr>
<tr>
<td>defaultAddCapabilities, requiredDropCapabilities, allowedCapabilities</td>
<td>Add or drop <a href="https://oreil.ly/H87Jc">Linux capabilities</a> as needed.</td>
</tr>
<tr>
<td>SELinux</td>
<td>Define the SELinux context of the container.</td>
</tr>
<tr>
<td>allowedProcMountTypes</td>
<td>Allowed proc mount types by container.</td>
</tr>
<tr>
<td>forbiddenSysctls,allowedUnsafeSysctls</td>
<td>Set the sysctl profile used by the container.</td>
</tr>
<tr>
<td>annotations</td>
<td>Set the AppArmor and seccomp profiles used by containers.</td>
</tr>
</tbody>
</table>
<p>AppArmor and seccomp profiles are used with PSP annotation where you can use the runtime’s (Docker, CRI) default profile or choose a custom profile loaded on the host by you. You will see more about these defenses in <a data-type="xref" href="#process_monitoring">“Process Monitoring”</a>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Pod Security Context"><div class="sect2" id="pod_security_context">
<h2>Pod Security Context</h2>
<p>Unlike PSPs, which are defined cluster-wide, a pod<a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="security contexts" id="idm45326832075104"/><a contenteditable="false" data-type="indexterm" data-primary="pod security policies (PSPs)" data-secondary="security contexts versus" id="idm45326832073728"/> securityContext can be defined at runtime while creating a deployment or pod. Here is a simple example of pod securityContext in action, where the pod is created with the root user <code>(uid=0)</code> and allows only four capabilities:</p>
<pre data-code-language="yaml"><code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">attacker-privileged-test</code>
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">normal-app</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">containers</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">attacker-container</code>
    <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">alpine:latest</code>
    <code class="nt">args</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"sleep"</code><code class="p-Indicator">,</code> <code class="s">"10000"</code><code class="p-Indicator">]</code>
    <code class="nt">securityContext</code><code class="p">:</code>
      <code class="nt">runAsUser</code><code class="p">:</code> <code class="l-Scalar-Plain">0</code>
      <code class="nt">capabilities</code><code class="p">:</code>
        <code class="nt">drop</code><code class="p">:</code>
          <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">all</code>
        <code class="nt">add</code><code class="p">:</code>
          <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">SYS_CHROOT</code>
          <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">NET_BIND_SERVICE</code>
          <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">SETGID</code>
          <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">SETUID</code></pre>
<p>This code snippet shows how you can create a pod running a root but limited to a subset of capabilities by specifying a security context. <a data-type="xref" href="#four_allowed_pod_capabilities">Figure 4-3</a> shows commands you can run to verify that the pod runs as root with the limited set of capabilities.</p>
<figure><div id="four_allowed_pod_capabilities" class="figure">
<img src="Images/ksao_0403.png" alt="" width="1717" height="201"/>
<h6><span class="label">Figure 4-3. </span>Four allowed pod capabilities</h6>
</div></figure>
<p>Pod securityContext, as shown in <a data-type="xref" href="#four_allowed_pod_capabilities">Figure 4-3</a>, can be used without enabling PSPs cluster-wide, but once the PSPs are enabled, you need to define securityContext to make sure pods are created properly. Since the securityContext has a PSP construct, all the PSPs’ capabilities apply to securityContext.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Limitations of PSPs"><div class="sect2" id="limitations_of_psps">
<h2>Limitations of PSPs</h2>
<p>Some of the limitations of PSPs include:<a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="security policies" data-tertiary="limitations" id="idm45326831967168"/><a contenteditable="false" data-type="indexterm" data-primary="pod security policies (PSPs)" data-secondary="limitations" id="idm45326831965520"/></p>
<ul>
<li><p>PodSecurityPolicySpec has references to allowedCapabilities, privileged, or hostNetwork. These enforcements can work only on Linux-based runtimes.</p></li>
<li><p>If you are creating a pod using controllers (e.g., replication controller), it’s worth checking if PSPs are authorized for use by those controllers.</p></li>
<li><p>Once PSPs are enabled cluster-wide and a pod doesn’t start because of an incorrect PSP, it becomes hectic to troubleshoot the issue. Moreover, if PSPs are enabled cluster-wide in production clusters, you need to test each and every component in your cluster, including dependencies like mutating admission controllers and conflicting verdicts.</p></li>
<li><p><a href="https://oreil.ly/Z99lf">Azure Kubernetes Service (AKS)</a> has deprecated support for PSPs and preferred OPA Gatekeeper for policy enforcement to support more flexible policies using the OPA engine.</p></li>
<li><p>PSP are deprecated and scheduled to be removed by Kubernetes v1.25.</p></li>
<li><p>Kubernetes can have edge cases where PSPs can be bypassed (e.g., <a href="https://oreil.ly/PqfNQ">TOB-K8S-038</a>).</p></li>
</ul>
<p>Now that you understand PSPs, best practices to implement them, and the limitations of PSPs, let’s look at process monitoring.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-psp2" id="idm45326831957664"/></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Process Monitoring"><div class="sect2" id="process_monitoring">
<h2>Process Monitoring</h2>
<p>When you containerize a workload and run it on a host with an orchestrator<a contenteditable="false" data-type="indexterm" data-primary="monitoring" data-secondary="process monitoring" data-tertiary="about" id="idm45326831954384"/><a contenteditable="false" data-type="indexterm" data-primary="process monitoring" data-secondary="about" id="idm45326831952736"/><a contenteditable="false" data-type="indexterm" data-primary="runtime security" data-secondary="process monitoring" id="ch04-pm2"/> like Kubernetes, there are a number of layers you need to take into consideration for monitoring a process inside a container. These start with container process logs and artifacts, filesystem access, network connections, system calls required, kernel permission (specialized workload), Kubernetes artifacts, and cloud infrastructure artifacts. Usually your organization’s security posture depends on how good your solutions are in stitching together these various log contexts. And this is where the traditional monitoring system fails measurably and a need for Kubernetes’ native monitoring and observability arises. Traditional solutions, like endpoint detection and response (EDR) and endpoint protection systems, have the following limitations when used in Kubernetes clusters:</p>
<ul>
<li><p>They are not container aware.</p></li>
<li><p>They are not aware of container networking and typically see activity from the host perspective, which can lead to false negatives on attackers’ lateral <span class="keep-together">movements.</span></p></li>
<li><p>They are blind to traffic between containers and don’t have any sight of underlays like IPIP or VXLAN.</p></li>
<li><p>They are not aware of process privileges and file permissions of containers accessing the underlying host.</p></li>
<li><p>They are not aware of the Kubernetes container runtime interface (CRI) or its intricacies and security issues, <a contenteditable="false" data-type="indexterm" data-primary="authorization" data-secondary="privilege escalation" id="idm45326831944368"/><a contenteditable="false" data-type="indexterm" data-primary="privilege escalation" id="idm45326831942992"/>which can lead to containers being able to access resources on the host. This is also known as <em>privilege escalation</em>.</p></li>
</ul>
<p>In the following sections, we will go over various techniques you can use for process monitoring. First we look at monitoring using various logs available in Kubernetes; then we explore seccomp, SELinux, and AppArmor features that allow you to control what a process can access (e.g., system calls, filesystem, etc.)</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Kubernetes Native Monitoring"><div class="sect2" id="kubernetes_native_monitorin">
<h2>Kubernetes Native Monitoring</h2>
<p>As shown in <a data-type="xref" href="#kubernetes_native_monitoring">Figure 4-4</a>, each layer<a contenteditable="false" data-type="indexterm" data-primary="process monitoring" data-secondary="Kubernetes native monitoring" id="idm45326831937472"/><a contenteditable="false" data-type="indexterm" data-primary="monitoring" data-secondary="process monitoring" data-tertiary="Kubernetes native monitoring" id="idm45326831936032"/> leading up to your containerized application process introduces monitoring and logging requirements and a new attack surface that is different from what traditional IT security practitioners are used to for monitoring networks and applications. The challenge is to reduce this monitoring overhead, as it can get really expensive for the storage and compute resources. The topic of metric collection and how to do this efficiently is covered in detail in <a data-type="xref" href="ch05.xhtml#observability-id000002">Chapter 5</a>.</p>
<figure><div id="kubernetes_native_monitoring" class="figure">
<img src="Images/ksao_0404.png" alt="" width="1206" height="779"/>
<h6><span class="label">Figure 4-4. </span>Kubernetes native monitoring</h6>
</div></figure>
<p>In order to build defenses in each layer, the following are some options you should consider incorporating while choosing solutions:</p>
<ul>
<li><p>Ability to block processes spawned by each container or Kubernetes orchestration creating containers.</p></li>
<li><p>Monitor kernel system calls used by each container process and ability to filter, block, and alert on suspicious calls to prevent containers accessing host resources.</p></li>
<li><p>Monitor each network connection (socket) originated by a container process and ability to enforce network policy.</p></li>
<li><p>Ability to isolate a container using network policy (or a node running this container) and pause it to investigate suspicious activities and collect forensics data in Kubernetes. The <a href="https://oreil.ly/LE52U"><code>pause</code> command</a> for Docker-based containers suspends processes in a container to allow for detailed analysis. Note that pausing a container will cause the container to suspend normal operation and should be used as a response to an event (e.g., security incident).</p></li>
<li><p>Monitor filesystem reads and writes to know filesystem changes (binaries, packages) and additional isolation through mandatory access control (MAC) to prevent privilege escalations.</p></li>
<li><p>Monitor the Kubernetes audit log to know what Kubernetes API requests clients are making and detect suspicious activity.</p></li>
<li><p>Enable a cloud provider’s logging for your infrastructure and ability to detect suspicious activity in the cloud provider’s infrastructure.</p></li>
</ul>
<p>There are many enterprise and open source solutions (e.g., Falco) that target groups of layers using various tools and mechanisms (like ebpf, kprobes, ptrace, tracepoints, etc.) to help build defense at various layers. You should look at their threat model and choose solutions that fulfill their requirements.</p>
<p>In the next section you will see some of the mechanisms that are offered by Kubernetes by bringing Linux defenses closer to the container, which will help you in monitoring and reducing the attack surface at various layers. The previous section focused on monitoring to allow you to detect unintended (malicious) behavior. The following mechanisms allow you to set controls to prevent unintended (malicious) behavior.</p>
<p>Kernel security features like seccomp, AppArmor, and SELinux can control what system calls are required for your containerized application, virtually isolate and customize each container for the workload it is running, and use MAC to provide access to resources like volume or filesystem that prevent container breakouts efficiently. Just using the feature with default settings can tremendously reduce the attack surface throughout your cluster. In the following sections you will look at each defense in depth and how it works in the Kubernetes cluster so that you can choose the best option for your threat model.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Seccomp"><div class="sect2" id="seccomp">
<h2>Seccomp</h2>
<p>Seccomp is a Linux kernel feature that can filter system calls executed<a contenteditable="false" data-type="indexterm" data-primary="process monitoring" data-secondary="seccomp" id="idm45326831918816"/><a contenteditable="false" data-type="indexterm" data-primary="monitoring" data-secondary="process monitoring" data-tertiary="seccomp" id="idm45326831917440"/><a contenteditable="false" data-type="indexterm" data-primary="seccomp" id="idm45326831915792"/><a contenteditable="false" data-type="indexterm" data-primary="Linux distributions" data-secondary="utilities/modules" data-tertiary="seccomp" id="idm45326831914688"/> by the container on a granular basis. Kubernetes lets you automatically apply seccomp profiles loaded onto a node by Kubernetes runtimes like <a href="https://www.docker.com">Docker</a>, <a href="https://oreil.ly/O4ZUZ">podman</a>, or <a href="https://oreil.ly/Cgrep">CRI-O</a>. A simple seccomp profile consists of a list of syscalls and the appropriate action to take when a syscall is invoked. This action reduces the attack surface to only allowed syscalls, reducing the risk of privilege escalation and container escape.</p>
<p>In the following seccomp profile, a default action is <code>SCMP_ACT_ERRNO</code>, which denies a system call. But defaultAction for syscall chmod is overwritten with <code>SCMP_ACT_ALLOW</code>. Usually seccomp profiles are loaded into the directory /var/lib/kubelet/seccomp on all nodes by your runtimes. You can add your custom profile at the same place:</p>
<pre data-code-language="yaml"><code class="p-Indicator">{</code>
    <code class="s">"defaultAction"</code><code class="p-Indicator">:</code> <code class="s">"SCMP_ACT_ERRNO"</code><code class="p-Indicator">,</code>
    <code class="s">"architectures"</code><code class="p-Indicator">:</code> <code class="p-Indicator">[</code>
        <code class="s">"SCMP_ARCH_X86_64"</code><code class="p-Indicator">,</code>
        <code class="s">"SCMP_ARCH_X86"</code><code class="p-Indicator">,</code>
        <code class="s">"SCMP_ARCH_X32"</code>
    <code class="p-Indicator">],</code>
    <code class="s">"syscalls"</code><code class="p-Indicator">:</code> <code class="p-Indicator">[</code>
        <code class="p-Indicator">{</code>
            <code class="s">"names"</code><code class="p-Indicator">:</code> <code class="p-Indicator">[</code>
                <code class="s">"chmod"</code><code class="p-Indicator">,</code>
            <code class="p-Indicator">],</code>
            <code class="s">"action"</code><code class="p-Indicator">:</code> <code class="s">"SCMP_ACT_ALLOW"</code>
        <code class="p-Indicator">}</code>
    <code class="p-Indicator">]</code>
<code class="p-Indicator">}</code></pre>
<p>To find the system calls used by your application, you can use <code>strace</code> as shown in the next example. For this example, you can list syscalls used by <code>curl</code> utility as follows:</p>
<pre data-code-language="yaml"><code class="l-Scalar-Plain">$ strace -c -S name curl -sS google.com</code>

<code class="l-Scalar-Plain">% time     seconds  usecs/call     calls    errors syscall</code>
<code class="l-Scalar-Plain">------ ----------- ----------- --------- --------- ----------------</code>
  <code class="l-Scalar-Plain">4.56    0.000242           6        43        43 access</code>
  <code class="l-Scalar-Plain">0.06    0.000003           3         1           arch_prctl</code>
  <code class="l-Scalar-Plain">1.28    0.000068          10         7           brk</code>
  <code class="l-Scalar-Plain">0.28    0.000015          15         1           clone</code>
  <code class="l-Scalar-Plain">4.62    0.000245           5        48           close</code>
  <code class="l-Scalar-Plain">1.38    0.000073          73         1         1 connect</code>
  <code class="l-Scalar-Plain">0.00    0.000000           0         1           execve</code>
  <code class="l-Scalar-Plain">0.36    0.000019          10         2           fcntl</code>
  <code class="l-Scalar-Plain">4.20    0.000223           5        48           fstat</code>
  <code class="l-Scalar-Plain">0.66    0.000035           3        11           futex</code>
  <code class="l-Scalar-Plain">0.23    0.000012          12         1           getpeername</code>
  <code class="l-Scalar-Plain">0.13    0.000007           7         1           getrandom</code>
  <code class="l-Scalar-Plain">0.19    0.000010          10         1           getsockname</code>
  <code class="l-Scalar-Plain">0.24    0.000013          13         1           getsockopt</code>
  <code class="l-Scalar-Plain">0.15    0.000008           4         2           ioctl</code>
 <code class="l-Scalar-Plain">13.96    0.000741           7       108           mmap</code>
 <code class="l-Scalar-Plain">11.94    0.000634           7        85           mprotect</code>
  <code class="l-Scalar-Plain">0.32    0.000017          17         1           munmap</code>
 <code class="l-Scalar-Plain">11.02    0.000585          13        45         1 openat</code>
  <code class="l-Scalar-Plain">0.11    0.000006           6         1           pipe</code>
 <code class="l-Scalar-Plain">19.50    0.001035         115         9           poll</code>
  <code class="l-Scalar-Plain">0.08    0.000004           4         1           prlimit64</code>
  <code class="l-Scalar-Plain">5.43    0.000288           6        45           read</code>
  <code class="l-Scalar-Plain">0.41    0.000022          22         1           recvfrom</code>
 <code class="l-Scalar-Plain">11.47    0.000609          17        36           rt_sigaction</code>
  <code class="l-Scalar-Plain">0.08    0.000004           4         1           rt_sigprocmask</code>
  <code class="l-Scalar-Plain">1.00    0.000053          53         1           sendto</code>
  <code class="l-Scalar-Plain">0.06    0.000003           3         1           set_robust_list</code>
  <code class="l-Scalar-Plain">0.04    0.000002           2         1           set_tid_address</code>
  <code class="l-Scalar-Plain">2.22    0.000118          30         4           setsockopt</code>
  <code class="l-Scalar-Plain">1.60    0.000085          43         2           socket</code>
  <code class="l-Scalar-Plain">0.08    0.000004           4         1         1 stat</code>
  <code class="l-Scalar-Plain">2.35    0.000125          21         6           write</code>
<code class="l-Scalar-Plain">------ ----------- ----------- --------- --------- ----------------</code>
<code class="l-Scalar-Plain">100.00    0.005308                   518        46 total</code></pre>
<p>The default seccomp profiles provided by the Kubernetes runtime contain a list of common syscalls that are used by most of the applications. Just enabling this feature forbids the use of dangerous system calls, which can lead to a kernel exploit and a container escape. The <a href="https://oreil.ly/pGX2O">default Docker runtime seccomp profile is available</a> for your <span class="keep-together">reference.</span></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>At the time of writing, the Docker/default profile was deprecated, so we recommend you use runtime/default as the seccomp profile instead.</p>
</div>
<p><a data-type="xref" href="#shows_the_options_for_deploying_seccomp">Table 4-2</a> shows the options for deploying seccomp profile in Kubernetes via PSP <span class="keep-together">annotations.</span></p>
<table class="border" id="shows_the_options_for_deploying_seccomp">
<caption><span class="label">Table 4-2. </span>Seccomp options</caption>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>runtime/default</td>
<td>Default container runtime profile</td>
</tr>
<tr>
<td>unconfined</td>
<td>No seccomp profile—this option is default in Kubernetes</td>
</tr>
<tr>
<td>localhost/&lt;path&gt;</td>
<td>Your own profile located on node, usually in /var/lib/kubelet/seccomp directory</td>
</tr>
</tbody>
</table>

</div></section>
<section data-type="sect2" data-pdf-bookmark="SELinux"><div class="sect2" id="selinux">
<h2>SELinux</h2>
<p>In the recent past, every container runtime breakout (container escape or privilege escalation) <a contenteditable="false" data-type="indexterm" data-primary="process monitoring" data-secondary="SELinux" id="ch04-sel"/><a contenteditable="false" data-type="indexterm" data-primary="monitoring" data-secondary="process monitoring" data-tertiary="SELinux" id="ch04-sel2"/><a contenteditable="false" data-type="indexterm" data-primary="Linux distributions" data-secondary="utilities/modules" data-tertiary="SELinux" id="ch04-sel3"/><a contenteditable="false" data-type="indexterm" data-primary="SELinux" id="ch04-sel4"/>was some kind of filesystem breakout (i.e., CVE-2019-5736, CVE-2016-9962, CVE-2015-3627, and more). SELinux mitigates these issues by providing control over who can access the filesystem and the interaction between resources (i.e., user, files, directories, memory, sockets, and more). In the cloud computing context, it makes sense to apply SELinux profiles to workloads to get better isolation and reduce attack surface by limiting filesystem access by the host kernel.</p>
<p>SELinux was originally developed by the National Security Agency in the early 2000s and is predominantly used on Red Hat- and centOS-based distros. The reason SELinux is effective is it provides a MAC, which greatly augments the traditional Linux discretionary access control (DAC) system.</p>
<p>Traditionally with the Linux DAC, users have the ability to change permissions on files, directories, and the process owned by them. And a root user has access to everything. But with SELinux (MAC), each OS resource is assigned a label by the kernel, which is stored as extended file attributes. These labels are used to evaluate SELinux policies inside the kernel to allow any interaction. With SELinux enabled, even a root user in a container won’t be able to access a host’s files in a mounted volume if the labels are not accurate.</p>
<p>SELinux operates in three modes: Enforcing, Permissive, and Disabled. Enforcing enables SELinux policy enforcement, Permissive provides warnings, and Disabled is to no longer use SELinux policies. The SELinux policies themselves can be further categorized into Targeted and Strict, where Targeted policies apply to particular processes and Strict policies apply to all processes.</p>
<p>The  following  is  the  SELinux  label  for  Docker  binaries  on  a  host,  which  consists <span class="keep-together">of <code>&lt;user:role:type:level&gt;</code>.</span> Here you will see the type, which is <span class="keep-together"><code>container_runtime_exec_t</code></span>:</p>
<pre data-code-language="yaml"><code class="l-Scalar-Plain">$ ls -Z /usr/bin/docker*</code>
<code class="l-Scalar-Plain">-rwxr-xr-x. root root system_u:object_r:container_runtime_exec_t:s0</code>
<code class="l-Scalar-Plain">/usr/bin/docker</code>
<code class="l-Scalar-Plain">-rwxr-xr-x. root root system_u:object_r:container_runtime_exec_t:s0</code>
<code class="l-Scalar-Plain">/usr/bin/docker-current</code>
<code class="l-Scalar-Plain">-rwxr-xr-x. root root system_u:object_r:container_runtime_exec_t:s0</code>
<code class="l-Scalar-Plain">/usr/bin/docker-storage-setup</code></pre>
<p>To further enhance SELinux, multicategory security (MCS) is used to allow users to label resources with a category. So a file labeled with a category can be accessed by only users or processes of that category.</p>
<p class="pagebreak-before">Once SELinux is enabled, a container runtime like <a href="https://oreil.ly/WKf97">Docker</a>, <a href="https://oreil.ly/HW4Cc">podman</a>, or <a href="https://oreil.ly/2bOJA"><code>CRI-O</code></a> picks a random MCS label to run the container. These MCS labels consist of two random numbers between 1 and 1023, and they are prefixed with the character “c” (category) and a sensitivity level (i.e., s0). So a complete MCS label looks like “s0:c1,c2.” As shown in <a data-type="xref" href="#selinux_enforcing_filesystem_access">Figure 4-5</a>, a container won’t be able to access a file on a host or Kubernetes volume unless it is labeled correctly as needed. This provides an important isolation between resource interaction, which prevents many security vulnerabilities targeted toward escaping containers.</p>
<figure><div id="selinux_enforcing_filesystem_access" class="figure">
<img src="Images/ksao_0405.png" alt="" width="1418" height="591"/>
<h6><span class="label">Figure 4-5. </span>SELinux enforcing filesystem access</h6>
</div></figure>
<p>Next is an example of a pod deployed with SELinux profile; this pod won’t be able to access any host volume mount files unless they are labeled so:c123,c456 on host. Even though you see the entire host, the filesystem is mounted on the pod:</p>
<pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">pod-se-linux-label</code>
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">normal-app</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">containers</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">app-container</code>
    <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">alpine:latest</code>
    <code class="nt">args</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"sleep"</code><code class="p-Indicator">,</code> <code class="s">"10000"</code><code class="p-Indicator">]</code>
    <code class="nt">securityContext</code><code class="p">:</code>
      <code class="nt">seLinuxOptions</code><code class="p">:</code>
        <code class="nt">level</code><code class="p">:</code> <code class="s">"s0:c123,c456"</code>
  <code class="nt">volumes</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">rootfs</code>
      <code class="nt">hostPath</code><code class="p">:</code>
        <code class="nt">path</code><code class="p">:</code> <code class="l-Scalar-Plain">/</code></pre>
<p class="pagebreak-before"><a data-type="xref" href="#table_four_three">Table 4-3</a> lists the CVEs pertaining to container escape that are prevented just by enabling SELinux on hosts. Though SELinux policies can be challenging to maintain, they are critical for a defense-in-depth strategy. Openshift, a Kubernetes distribution, comes with SELinux enabled in its default configuration with targeted policies; for other distros it’s worth checking the status.</p>
<table class="border" id="table_four_three">
<caption><span class="label">Table 4-3. </span>CVEs related to container escape</caption>
<thead>
<tr>
<th>CVE</th>
<th>Description</th>
<th>Blocked by SELinux</th>
</tr>
</thead>
<tbody>
<tr>
<td>CVE-2019-5736</td>
<td>Allows attackers to overwrite host runc binary and consequently obtain host root access</td>
<td>Yes</td>
</tr>
<tr>
<td>CVE-2016-9962</td>
<td>RunC exec vulnerability</td>
<td>Yes</td>
</tr>
<tr>
<td>CVE-2015-3627</td>
<td>Insecure file-descriptor exploitation</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Kubernetes provides the following options to enforce SELinux in PSPs:<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-sel" id="idm45326831607888"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-sel2" id="idm45326831606512"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-sel3" id="idm45326831605136"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-sel4" id="idm45326831603760"/></p>
<table class="border">
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>MustRunAs</td>
<td>Need to have seLinuxOptions configured as shown in <a data-type="xref" href="#selinux_enforcing_filesystem_access">Figure 4-5</a>.</td>
</tr>
<tr>
<td>RunAsAny</td>
<td>No defaults are provided in PSP (can be optionally configured on pod and deployments)</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="AppArmor"><div class="sect2" id="apparmor">
<h2>AppArmor</h2>
<p>Like SELinux, AppArmor was developed for Debian and Ubuntu<a contenteditable="false" data-type="indexterm" data-primary="process monitoring" data-secondary="AppArmor" id="idm45326831594080"/><a contenteditable="false" data-type="indexterm" data-primary="monitoring" data-secondary="process monitoring" data-tertiary="AppArmor" id="idm45326831592704"/><a contenteditable="false" data-type="indexterm" data-primary="AppArmor" id="idm45326831591056"/><a contenteditable="false" data-type="indexterm" data-primary="Linux distributions" data-secondary="utilities/modules" data-tertiary="AppArmor" id="idm45326831589952"/> operating systems. AppArmor works in a similar way to SELinux, where an AppArmor profile defines what a process has access to. Let’s look at an example of an AppArmor profile:</p>
<pre data-code-language="yaml"><code class="c1">#include &lt;tunables/global&gt;</code>
<code class="l-Scalar-Plain">/{usr/,}bin/ping flags=(complain) {</code>
  <code class="l-Scalar-Plain">#include &lt;abstractions/base&gt;</code>
  <code class="l-Scalar-Plain">#include &lt;abstractions/consoles&gt;</code>
  <code class="l-Scalar-Plain">#include &lt;abstractions/nameservice&gt;</code>

  <code class="l-Scalar-Plain">capability net_raw,</code>
  <code class="l-Scalar-Plain">capability setuid,</code>
  <code class="l-Scalar-Plain">network inet raw,</code>

  <code class="l-Scalar-Plain">/bin/ping mixr,</code>
  <code class="l-Scalar-Plain">/etc/modules.conf r,</code>

  <code class="l-Scalar-Plain"># Site-specific additions and overrides. See local/README for details.</code>
  <code class="l-Scalar-Plain">#include &lt;local/bin.ping&gt;</code>
<code class="l-Scalar-Plain">}</code></pre>
<p class="pagebreak-before">Here a ping utility has only three capabilities (i.e., net_raw, setuid, and inet raw and read access to /etc/modules.conf). With these permissions a ping utility cannot modify or write to the filesystem (keys, binaries, settings, persistence) or load any modules, which reduces attack surface for the ping utility to perform any malicious activity in case of a compromise.</p>
<p>By default, your Kubernetes runtime like <a href="https://oreil.ly/WKf97">Docker</a>, <a href="https://oreil.ly/HW4Cc">podman</a>, or <a href="https://oreil.ly/Cgrep">CRI-O</a> provides an AppArmor profile. Docker’s runtime profile is <a href="https://oreil.ly/utKNx">provided for your <span class="keep-together">reference</span></a>.</p>
<p>Since AppArmor is much more flexible and easy to work with, we recommend having a policy per microservice. Kubernetes provides the following options to enforce these policies via PSP annotations:</p>
<table class="border">
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>runtime/default</td>
<td>Runtime’s default policy</td>
</tr>
<tr>
<td>localhost/&lt;profile_name&gt;</td>
<td>Apply profile loaded on host, usually in directory /sys/kernel/security/apparmor/profiles</td>
</tr>
<tr>
<td>unconfined</td>
<td>No profile will be loaded</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Sysctl"><div class="sect2" id="sysctl">
<h2>Sysctl</h2>
<p><a href="https://oreil.ly/zwlcG"><code>Kubernetes sysctl</code></a> allows you to use the <a contenteditable="false" data-type="indexterm" data-primary="sysctl" data-secondary="documentation online" id="idm45326831534752"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="documentation online" data-tertiary="sysctl" id="idm45326831533376"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="Kubernetes documentation" data-tertiary="sysctl" id="idm45326831531728"/><a contenteditable="false" data-type="indexterm" data-primary="process monitoring" data-secondary="sysctl" id="idm45326831530064"/><a contenteditable="false" data-type="indexterm" data-primary="monitoring" data-secondary="process monitoring" data-tertiary="sysctl" id="idm45326831528688"/><a contenteditable="false" data-type="indexterm" data-primary="sysctl" id="idm45326831527040"/>sysctl interface to use and configure kernel parameters in your cluster. An example of using sysctls is to manage containers with resource-hungry workloads that need to handle a large number of concurrent connections or need a special parameter set (i.e., IPv6 forwarding) to run efficiently. In such cases, sysctl provides a way to modify kernel behavior only for those workloads without affecting the rest of the cluster.</p>
<p>The sysctls are categorized into two buckets: safe and unsafe. Safe sysctl only affects the containers, but unsafe sysctl affects the container and node it is running on. Sysctl lets administrators set both the sysctl buckets at their discretion.</p>
<p>Let’s take an example where a containerized web server needs to handle a high number of concurrent connections and needs to set the net.core.somaxconn value to a higher number than the kernel default. In this case it can be set as follows:</p>
<pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">sysctl-example</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">securityContext</code><code class="p">:</code>
    <code class="nt">sysctls</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">net.core.somaxconn</code>
      <code class="nt">value</code><code class="p">:</code> <code class="s">"1024"</code></pre>
<p class="pagebreak-before">Please note that we recommend that you use node affinity to schedule workloads on nodes that have the sysctl applied, in case you need to use a sysctl that applies to the node. The following example shows how PSPs allow sysctls to be forbidden or allowed:<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch04-pm2" id="idm45326831503792"/></p>
<pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">policy/v1beta1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">PodSecurityPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">sysctl-psp</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">allowedUnsafeSysctls</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">kernel.msg*</code>
  <code class="nt">forbiddenSysctls</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">kernel.shm_rmid_forced</code></pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000009">
<h1>Conclusion</h1>
<p>In this chapter we covered tools and best practices for defining and implementing your workload runtime security. The most important takeaways are:</p>
<ul>
<li><p>Pod security policies are an excellent way to enable workload controls at workload creation time. They have limitations but can be used effectively.</p></li>
<li><p>You need to pick a solution that is native to Kubernetes for monitoring processes and implement controls based on your threat model for your workloads.</p></li>
<li><p>We recommend you review the various security options that are available in the Linux kernel and leverage the right set of features based on your use case.</p></li>
</ul>
</div></section>
</div></section></div></body></html>