<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 5. Connecting to a Network" data-type="chapter" epub:type="chapter"><div class="chapter" id="connecting_to_a_network">
<h1><span class="label">Chapter 5. </span>Connecting to a Network</h1>
<p>A standalone Linux system is powerful, but the scope of what the system is ultimately capable of is limited. <a contenteditable="false" data-primary="networks" data-type="indexterm" id="ix_ntwk"/>Only a single operator or administrator can use a standalone system simultaneously. While the system can still run multiple workloads, its services are restricted to local access.</p>
<p>Linux is a multitasking, multiuser operating system. One of its most outstanding values is being networked with other computers to allow multiple users to run various workloads simultaneously. Connecting a Linux system to a network enables it to become part of a local network, a grid, a cloud, or the global internet.<a contenteditable="false" data-primary="cloud computing" data-type="indexterm" id="idm45657875769904"/></p>
<p>In this chapter, you will learn how to select an IP addressing scheme for your network and some advantages and disadvantages of the static and dynamic options. You also learn the security implications of connecting systems to a network. You will learn how to, as much as possible, prevent security breaches by implementing good security practices, such as using secure protocols, turning off unnecessary services and daemons, and keeping systems patched and updated.<a contenteditable="false" data-primary="patching" data-type="indexterm" id="idm45657874698192"/></p>
<section data-pdf-bookmark="Plugging into a Network" data-type="sect1"><div class="sect1" id="plugging_into_a_network">
<h1>Plugging into a Network</h1>
<p>There’s no great skill required to plug a server system into <a contenteditable="false" data-primary="networks" data-secondary="plugging into a network" data-type="indexterm" id="ix_ntwkplg"/>an existing network. These days, as soon as a new system comes online, a <a contenteditable="false" data-primary="DHCP (Dynamic Host Configuration Protocol)" data-type="indexterm" id="idm45657874686736"/>Dynamic Host Configuration Protocol (DHCP) server provides it with an IP address, subnet mask, gateway, Domain Name System (DNS) servers, and some basic routing information.<a contenteditable="false" data-primary="subnet masks" data-type="indexterm" id="idm45657874735376"/><a contenteditable="false" data-primary="gateways" data-type="indexterm" id="idm45657874696752"/><a contenteditable="false" data-primary="IP addressing" data-secondary="provided by DHCP server" data-type="indexterm" id="idm45657874683744"/><a contenteditable="false" data-primary="DNS (Domain Name System) servers" data-type="indexterm" id="idm45657874682528"/><a contenteditable="false" data-primary="Domain Name System (DNS) servers" data-type="indexterm" id="idm45657874681552"/> There are two schools of thought concerning DHCP and servers.<a contenteditable="false" data-primary="Dynamic Host Configuration Protocol" data-see="DHCP" data-type="indexterm" id="idm45657874679408"/> The first claims that all server systems should have static IP addresses, and the second asserts that all systems should use DHCP for IP address distribution and management. I’ve always configured servers, printers, and networking equipment with static IP addresses near the lower end of the IP address pool. For me, it makes good organizational sense to do so rather than relying on DHCP and DNS services to maintain order for services that users rely on so heavily.</p>
<p>In the following sections, I describe <a contenteditable="false" data-primary="IP addressing" data-type="indexterm" id="ix_IPadd"/>the two IP addressing schemes—static and dynamic—and the advantages and disadvantages of each. The example network for each has the following IP addressing information:</p>
<ul>
<li>
<p>Network: 192.168.1.0/24</p>
</li>
<li>
<p>Gateway: 192.168.1.254 (static IP address)</p>
</li>
<li>
<p>DNS: 192.168.1.1, 192.168.1.2 (static IP addresses)</p>
</li>
</ul>
<p>This example network is for learning purposes and is only practical for the smallest of companies or groups of users. This scheme will only work for small companies because there are only 251 usable IP addresses on this network after subtracting the gateway address and two DNS server addresses (254 – 3 = 251). A user might have as many as five devices that consume IP addresses, and it’s easy to see that it doesn’t take long to exhaust such a small pool.</p>
<p>Assigning a static IP address varies among Linux distributions. For these examples, I use Debian and CentOS distributions.</p>
<section data-pdf-bookmark="Static IP Addressing" data-type="sect2"><div class="sect2" id="static_ip_addressing">
<h2>Static IP Addressing</h2>
<p>A static IP <a contenteditable="false" data-primary="IP addressing" data-secondary="static" data-type="indexterm" id="idm45657874680288"/>address is a “hard-coded” IP address <a contenteditable="false" data-primary="static IP addressing" data-type="indexterm" id="idm45657874660720"/>embedded into a configuration file.<a contenteditable="false" data-primary="networks" data-secondary="plugging into a network" data-tertiary="static IP addressing" data-type="indexterm" id="idm45657874659744"/> The IP address does not change unless it’s changed manually. Static IP addresses do not depend on or use DHCP services. When assigning static IP addresses to systems, you should decide on a reserved block of IP addresses that you use for servers, network equipment (switches, routers, WiFi access points), printers, and any IP-capable system that is not mobile. Workstations, laptops, tablets, phones, and other mobile devices should use DHCP.</p>
<p>For example, using the network parameters mentioned in the preceding section, I reserve 192.168.1.1 through 192.168.1.25 for servers, network equipment, printers, and other stationary systems. As you note, the addresses 192.168.1.1 and .2 are already used on this reserved list. You can exclude a range of IP addresses in your DHCP configuration so that these addresses are not part of the available IP address pool.<a contenteditable="false" data-primary="DHCP (Dynamic Host Configuration Protocol)" data-secondary="static IP addresses and" data-type="indexterm" id="idm45657874658416"/></p>
<p>One of the advantages of using a static pool of IP addresses is that network services are stable. If you set up some inventory service and monitoring on your network, which I highly recommend, having those statically addressed systems will save some headaches for you. You’ll be able to compare inventories over time, see what’s changed, measure growth, and plan for changes. Another advantage is that you can find critical systems even if DNS and DHCP are down. A static IP address gives you the stability you need, irrespective of any other services’ status.<a contenteditable="false" data-primary="services" data-secondary="networking services requiring static IP addresses" data-type="indexterm" id="idm45657875410656"/></p>
<p>Some network services require static IP addresses for the server systems on which they reside. Services such as FTP, web, VPN, database, Active Directory, and DNS require static IP addresses or are recommended to have them. The primary disadvantage and argument against static IP addressing is management. The argument is that managing static IP addresses is labor-intensive and might cause conflicts elsewhere on the network. I don’t see this as a problem for most sysadmins because the equipment you assign static IP addresses to lasts for years, and their locations are stable. You don’t typically move a server to different locations within a company; you never move them offsite to use and then return them as you do laptops, tablets, and mobile phones. A reserved pool that’s excluded from your DHCP pool prevents potential conflicts with other systems.</p>
</div></section>
<section data-pdf-bookmark="Dynamic IP Addressing" data-type="sect2"><div class="sect2" id="dynamic_ip_addressing">
<h2>Dynamic IP Addressing</h2>
<p>Using a DHCP service eliminates many of the IP address management problems that plagued system administrators in the days before DHCP. <a contenteditable="false" data-primary="DHCP (Dynamic Host Configuration Protocol)" data-secondary="dynamic IP addressing" data-type="indexterm" id="idm45657874955984"/><a contenteditable="false" data-primary="networks" data-secondary="plugging into a network" data-tertiary="dynamic IP addressing" data-type="indexterm" id="idm45657874637088"/><a contenteditable="false" data-primary="dynamic IP addressing" data-type="indexterm" id="idm45657875495808"/><a contenteditable="false" data-primary="IP addressing" data-secondary="dynamic" data-type="indexterm" id="idm45657875306768"/>Assigning static IP addresses and keeping up with them for more than a few systems becomes a management nightmare. Static IP addresses made a little more sense when users only had desktop systems.<a contenteditable="false" data-primary="mobile devices, dynamic IP addressing" data-type="indexterm" id="idm45657874670400"/> But these days, with laptops, tablets, and mobile phones, a static IP address would likely mean that the user would have network access only on their corporate network, that they would experience IP conflicts if they ever connected to another network, or that they would have to know how to change their systems from static to dynamically assigned IP addresses each time they connected to a different network.</p>
<p>For example, if your laptop has a static IP address for your corporate network of 192.168.1.50, and you take that laptop to a remote location, such as your home, to do some work, then your home would have to use the same IP addressing scheme as your office. If it does, your laptop might conflict with a dynamically assigned IP address for your television, someone’s mobile phone, or some other IP-capable gadget. You might be able to work around the issue at home, but when you take that same laptop to a hotel and attempt to connect to your corporate VPN, chances are very good that you wouldn’t be able to because of that statically assigned IP address. The hotel might use a 10.0.1.0 IP addressing scheme, so your laptop would never connect.</p>
<p>Device mobility is one great advantage of DHCP. The user never has to reconfigure anything no matter where the laptop connects to another network or the internet. The other advantage is that once you configure a DHCP pool of addresses, there’s not much maintenance for you to do. You’ll have to determine which lease duration best suits your users. I’ve seen lease durations range from 24 hours to 30 days. I don’t have a particular preference, but if you use a long lease duration (more than a few days), you might have some occasional cleanup by removing duplicates, stale leases, and so on. DHCP is supposed to clean up after itself but doesn’t always.</p>
<p>Whether to use static IP addressing, DHCP, or a mixture of the two is really up to your personal preference for IP address management. You can still use a pure DHCP scheme and reserve IP addresses by entering MAC addresses, making them statically assigned. <a contenteditable="false" data-primary="MAC addresses" data-type="indexterm" id="idm45657875848976"/><a contenteditable="false" data-primary="NICs (network interface cards)" data-secondary="changing" data-type="indexterm" id="idm45657874656896"/>The only time there’s a problem is if you change network interface cards (NICs). You must remember to update the DHCP reservations list with the new NIC’s MAC address.<a contenteditable="false" data-primary="network interface cards" data-see="NICs" data-type="indexterm" id="idm45657874993776"/></p>
<div data-type="tip"><h6>Tip</h6>
<p>If you change network interface card (NIC or adapter) settings, such as changing from DHCP to a static IP address, you need to restart the adapter for those changes to take effect. <a contenteditable="false" data-primary="sudo (substitute user do) command" data-secondary="restarting network adapter" data-type="indexterm" id="idm45657874690176"/><a contenteditable="false" data-primary="adapter (network)" data-type="indexterm" id="idm45657875846576"/>Restart the adapter by issuing these commands:</p>
<pre data-type="programlisting">
$ sudo ifdown <em>adapter_name</em>
$ sudo ifup <em>adapter_name</em></pre>
<p>The adapter name varies by system, but some examples are <code>eth0</code> and <code>enp0s3</code>.</p>
</div>
<p>The next section discusses the security-related repercussions of placing systems on the network and how you can apply best security practices to your systems.<a contenteditable="false" data-primary="IP addressing" data-startref="ix_IPadd" data-type="indexterm" id="idm45657874603280"/><a contenteditable="false" data-primary="networks" data-secondary="plugging into a network" data-startref="ix_ntwkplg" data-type="indexterm" id="idm45657874771024"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Networking and Security" data-type="sect1"><div class="sect1" id="networking_and_security">
<h1>Networking and Security</h1>
<p>Two types of Linux systems can be considered secure: one powered off and one powered on but not connected to a network.<a contenteditable="false" data-primary="security" data-secondary="networking and" data-type="indexterm" id="ix_secntwk"/><a contenteditable="false" data-primary="networks" data-secondary="networking and security" data-type="indexterm" id="ix_ntwksec"/> The powered-off system is safe from over-the-network attacks, as are non-networked systems. The powered-off system’s only security vulnerability is physical security. Someone with physical access to the system could steal, dismantle, or damage it. Non-networked systems are, as mentioned at the outset of the chapter, still somewhat useful but have limited use beyond a single operator.</p>
<p>Once you <a contenteditable="false" data-primary="attacks on networked systems" data-type="indexterm" id="idm45657874591520"/>network a system, you’ve exposed it to over-the-network attacks. Malicious actors continuously scan IP address ranges, searching for vulnerable systems to exploit. <a contenteditable="false" data-primary="firewalls" data-type="indexterm" id="idm45657875582560"/>While many servers are exposed to the internet via <a href="https://oreil.ly/wxezB">demilitarized zones (DMZs)</a> or are inside corporate or home firewall-protected networks, they are also susceptible to attack. Once inside your network, a malicious actor can perform automated scans of all connected systems, searching for <span class="keep-together">vulnerabilities.</span><a contenteditable="false" data-primary="user management" data-secondary="user accounts on networked systems, security risks" data-type="indexterm" id="idm45657874759248"/></p>
<p>Additionally, creating user accounts on your system decreases security because of weak <a contenteditable="false" data-primary="passwords" data-secondary="weak, networking security and" data-type="indexterm" id="idm45657874581552"/>passwords, the potential for on-path attacks, and social engineering exploits that might compromise one’s credentials to a malicious actor.</p>
<p class="pagebreak-before">For these reasons, administrators must take the following measures:</p>
<ul class="left-align">
<li>
<p>Only grant what’s required for users to work (the principle of <em>least privilege</em>)</p>
</li>
<li>
<p>Enforce strong security policies for passwords, keys, or multifactor <span class="keep-together">authentication</span></p>
</li>
<li>
<p>Regularly patch and update systems</p>
</li>
<li>
<p>Perform periodic security audits on all systems, network equipment, <span class="keep-together">and devices that access corporate resources</span></p>
</li>
</ul>
<section data-pdf-bookmark="Preparing a System for Network Connectivity" data-type="sect2"><div class="sect2" id="preparing_a_system_for_network_connecti">
<h2>Preparing a System for Network Connectivity</h2>
<p>When a system <a contenteditable="false" data-primary="networks" data-secondary="networking and security" data-tertiary="preparing system for network connectivity" data-type="indexterm" id="idm45657874572320"/>administrator provisions a new system and installs <a contenteditable="false" data-primary="security" data-secondary="networking and" data-tertiary="preparing system for network connectivity" data-type="indexterm" id="idm45657874570000"/>it into a rack, plugging in network cables or connecting a virtual machine to a virtual network is standard practice. We often rely on others to vet the systems’ function, purpose, and security options.<a contenteditable="false" data-primary="operating systems" data-secondary="new system installations, network security and" data-type="indexterm" id="idm45657875051136"/> However, this is not always the case. New system installation is often automatically performed by provisioning a “standard build” from a prepared operating system image that could be months or years old. Using old images is a poor security practice. If the system is immediately connected to a network before it’s fully updated and secured, it’s vulnerable to attack and compromise before it begins its regular duties on the network.</p>
<p>A solution is to provision new systems on a private network where they can receive updates, patches, and secure configurations from an internal repository before being placed into a production network.<a contenteditable="false" data-primary="patching" data-type="indexterm" id="idm45657874567200"/></p>
</div></section>
<section data-pdf-bookmark="Pruning Your Systems" data-type="sect2"><div class="sect2" id="pruning_your_systems">
<h2>Pruning Your Systems</h2>
<p>Pruning means removing any unnecessary services and daemons from your systems. <a contenteditable="false" data-primary="security" data-secondary="networking and" data-tertiary="pruning your systems" data-type="indexterm" id="idm45657874562480"/><a contenteditable="false" data-primary="networks" data-secondary="networking and security" data-tertiary="pruning your systems" data-type="indexterm" id="idm45657874561072"/><a contenteditable="false" data-primary="pruning systems" data-type="indexterm" id="idm45657874559424"/><a contenteditable="false" data-primary="daemons (network)" data-secondary="pruning from your systems" data-type="indexterm" id="idm45657874558320"/>There’s no need to create problems for yourself by running a production system with multiple services that no one uses but that could leave your system vulnerable to attack. Only install what you need to provide services to your users or other systems.</p>
<p>At a minimum, you need to have an SSH daemon running on your systems so that you can log in and manage them remotely. <a contenteditable="false" data-primary="SSH daemon (SSHD)" data-type="indexterm" id="idm45657874619984"/>If you find that some users require a special service that’s only used occasionally or that leaves a system in a less than secure state, either turn on the service when needed and turn it off when it’s no longer being used or place the service on a secure network that can only be accessed from a restricted number of systems.</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Securing Network Daemons" data-type="sect2"><div class="sect2" id="securing_network_daemons">
<h2 class="less_space">Securing Network Daemons</h2>
<p>Deciding which network daemons to install and support is generally easy because you know your system’s intended purpose each time you build a system.<a contenteditable="false" data-primary="daemons (network)" data-secondary="securing" data-type="indexterm" id="idm45657874772848"/><a contenteditable="false" data-primary="security" data-secondary="networking and" data-tertiary="securing network daemons" data-type="indexterm" id="idm45657874579472"/><a contenteditable="false" data-primary="networks" data-secondary="networking and security" data-tertiary="securing network daemons" data-type="indexterm" id="idm45657874555168"/> If it’s a web server, you know that you’ll install a web service such as Apache or NGINX. You’ll install MySQL, MariaDB, or some other database software if the system is a database server. The issue is that for a system to be useful, it must expose the corresponding TCP ports for its services. These network daemons are vulnerable to attack and, therefore, must be protected.</p>
<p>There are multiple methods of securing network <a contenteditable="false" data-primary="services" data-secondary="securing network services" data-type="indexterm" id="idm45657874588896"/>daemons and services, but installing secure versions of the services you want to provide is the simplest method.<a contenteditable="false" data-primary="DNSSEC" data-type="indexterm" id="idm45657874586848"/><a contenteditable="false" data-primary="HTTPS" data-type="indexterm" id="idm45657874549456"/> For example, if your new system is a DNS server, use DNSSEC. If you configure a Lightweight Directory Access Protocol (LDAP) server, use LDAPS. And always use HTTPS for web servers secured with a certificate. <a data-type="xref" href="#examples_of_secure_services">Table 5-1</a> shows a partial list of secure services.</p>
<table class="border" id="examples_of_secure_services">
<caption><span class="label">Table 5-1. </span>Examples of secure services</caption>
<thead>
<tr>
<th>Protocol</th>
<th>Port</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>https</td>
<td>443/tcp</td>
<td>HTTP protocol over TLS/SSL</td>
</tr>
<tr>
<td>https</td>
<td>443/udp</td>
<td>HTTP protocol over TLS/SSL</td>
</tr>
<tr>
<td>ldaps</td>
<td>636/tcp</td>
<td>LDAP over SSL</td>
</tr>
<tr>
<td>ldaps</td>
<td>636/udp</td>
<td>LDAP over SSL</td>
</tr>
<tr>
<td>imaps</td>
<td>993/tcp</td>
<td>IMAP over SSL</td>
</tr>
<tr>
<td>imaps</td>
<td>993/udp</td>
<td>IMAP over SSL</td>
</tr>
<tr>
<td>pop3s</td>
<td>995/tcp</td>
<td>POP-3 over SSL</td>
</tr>
<tr>
<td>pop3s</td>
<td>995/udp</td>
<td>POP-3 over SSL</td>
</tr>
</tbody>
</table>
<p>Using secure protocols and encryption doesn’t guarantee security. Still, it’s better than using nonsecure protocols with no encryption. Vulnerabilities frequently appear even for secure applications and protocols. Keeping your systems updated and patched helps prevent security breaches. Security patches are generally available before widespread damage can be done but not always, so you must remain vigilant in maintaining security.</p>
</div></section>
<section data-pdf-bookmark="The Secure Shell Daemon" data-type="sect2"><div class="sect2" id="the_secure_shell_left_parenthesissshrig">
<h2>The Secure Shell Daemon</h2>
<p>The most common network daemon available on almost every Linux system is the Secure Shell (SSH) daemon. <a contenteditable="false" data-primary="security" data-secondary="networking and" data-tertiary="SSH daemon" data-type="indexterm" id="ix_secntwkSSHD"/><a contenteditable="false" data-primary="networks" data-secondary="networking and security" data-tertiary="SSH daemon" data-type="indexterm" id="ix_ntwksecSSHD"/><a contenteditable="false" data-primary="SSH daemon (SSHD)" data-type="indexterm" id="ix_SSHD"/>SSH provides a secure (encrypted) connection to a Linux system over the network. Although the SSH daemon (SSHD) has built-in security through its encrypted channel, its communications are still vulnerable to attack. There are multiple methods of securing the SSHD so that attacks are less fruitful for an attacker.</p>
<section data-pdf-bookmark="Limiting access to SSHD from specific hosts" data-type="sect3"><div class="sect3" id="limiting_access_to_sshd_from_specific_h">
<h3>Limiting access to SSHD from specific hosts</h3>
<p>There are two files that an administrator can use<a contenteditable="false" data-primary="SSH daemon (SSHD)" data-secondary="limiting access from specific hosts" data-type="indexterm" id="idm45657874691888"/> to limit access to any daemon: <em>/etc/hosts.allow</em> and <em>/etc/hosts.deny</em>. They require no service restart because they’re not configuration files, and the system checks them each time a client accesses a service. The <em>/etc/hosts.allow</em> file is the more important of the two because its settings override those in the <em>/etc/hosts.deny</em> file.<a contenteditable="false" data-primary="hosts.allow file" data-type="indexterm" id="idm45657874614832"/><a contenteditable="false" data-primary="hosts.deny file" data-type="indexterm" id="idm45657874507888"/><a contenteditable="false" data-primary="/etc/hosts.deny file" data-primary-sortas="etc" data-type="indexterm" id="idm45657874506912"/><a contenteditable="false" data-primary="/etc/hosts.allow file" data-primary-sortas="etc" data-type="indexterm" id="idm45657874505696"/></p>
<p>An <em>/etc/hosts.allow</em> file entry to enable SSH connectivity from a single IP address (192.168.1.50) is shown here:</p>
<pre data-type="programlisting">
sshd: 192.168.1.50
sshd: ALL: DENY</pre>
<p>This entry will only accept SSH connections from 192.168.1.50 and will deny them from all other IP addresses. If you find that setting such an entry in <em>/etc/hosts.allow</em> doesn’t work for you, then <a contenteditable="false" data-primary="tcp_wrapper integration in sshd" data-type="indexterm" id="idm45657875581792"/>you need to check for <code>tcp_wrapper</code> integration in <code>sshd</code> using the following command:</p>
<pre data-type="programlisting">
$ sudo ldd /path/to/binary | grep libwrap</pre>
<p>If you receive no response, your <code>sshd</code> wasn’t compiled with <code>tcp_wrappers</code> enabled and is likely deprecated for your distribution. This is, unfortunately, the case with many packaged <code>sshd</code> installations. The response you’re looking for is similar to the following:</p>
<pre data-type="programlisting">
$ sudo ldd /usr/sbin/sshd | grep libwrap
        libwrap.so.0 =&gt; /lib/x86_64-linux-gnu/libwrap.so.0 (0x00007fc6c2ab2000)</pre>
<p>You have three options if your <code>sshd</code> doesn’t have <code>tcp_wrappers</code> support:</p>
<ul>
<li>
<p>Use other methods to secure <code>sshd</code> (<code>firewall</code> rules, <code>iptables</code>, <code>nftables</code>).</p>
</li>
<li>
<p>Compile <code>openssh_server</code> with <code>tcp_wrappers</code> enabled.</p>
</li>
<li>
<p>Find and replace your current <code>sshd</code> with an <code>openssh_server</code> package that has <code>tcp_wrappers</code> enabled.</p>
</li>
</ul>
<p>To give you options for <code>firewalld</code>, <code>iptables</code>, and <code>nftables</code>, consider the following commands that perform similar functions to adding entries into <em>/etc/hosts.allow</em> and <em>/etc/hosts.deny</em>.</p>
</div></section>
<section data-pdf-bookmark="Implementing firewalld rules" data-type="sect3"><div class="sect3" id="implementing_firewalld_rules">
<h3>Implementing firewalld rules</h3>
<p>If you <a contenteditable="false" data-primary="firewalld, implementing rules for sshd" data-type="indexterm" id="idm45657874481776"/>use <code>firewalld</code>, first delete<a contenteditable="false" data-primary="SSH daemon (SSHD)" data-secondary="implementing firewalld rules for" data-type="indexterm" id="idm45657874480032"/> the <code>ssh</code> service from <code>firewalld</code>’s rules:</p>
<pre data-type="programlisting">
$ sudo firewall-cmd --permanent --remove-service=ssh</pre>
<p class="pagebreak-before">Add a new <code>zone</code> rather than <a contenteditable="false" data-primary="zones (SSH)" data-type="indexterm" id="idm45657874476208"/>using the default <code>zone</code>:</p>
<pre data-type="programlisting">
$ sudo firewall-cmd --permanent --new-zone=SSH_zone
$ sudo firewall-cmd --permanent --zone=SSH_zone --add-source=192.168.1.50
$ sudo firewall-cmd --permanent --zone=SSH_zone --add-service=ssh</pre>
<p>You must reload the <code>firewall</code> to make the new configuration active:</p>
<pre data-type="programlisting">
$ sudo firewall-cmd --reload</pre>
<p>If you use <code>iptables</code>, you can restrict <code>ssh</code> access <a contenteditable="false" data-primary="iptables command" data-secondary="using to secure sshd" data-type="indexterm" id="idm45657874470816"/>to a single IP <a contenteditable="false" data-primary="IP addressing" data-secondary="restricting ssh access to single IP address" data-type="indexterm" id="idm45657874469280"/>address with a single command:</p>
<pre data-type="programlisting">
$ sudo iptables -A INPUT -p tcp -s 192.168.1.50 --dport 22 -j ACCEPT</pre>
<p>For netfilter (<code>nft</code>), you add a new <code>rule</code>:</p>
<pre data-type="programlisting">
$ sudo nft insert rule ip filter input ip saddr 192.168.1.50 tcp dport 22 accept</pre>
<p>However if you receive<a contenteditable="false" data-primary="nftables" data-secondary="using to secure sshd" data-type="indexterm" id="idm45657874464432"/> an error that reads as follows, either you must create a new table and chain for the rule, or use an existing chain:</p>
<pre data-type="programlisting">
Error: Could not process rule: No such file or directory.</pre>
<p>Use the following commands to create a new table and chain named <code>input</code>:</p>
<pre data-type="programlisting">
$ sudo nft add table ip filter # create table

# next, create chain
$ sudo nft add chain ip filter input { type filter hook input priority 0\; }

$ sudo nft insert rule ip filter input ip saddr 192.168.1.50 tcp dport 22 accept</pre>
<p>Note that chain names are case-sensitive. <a contenteditable="false" data-primary="chains (nftables)" data-type="indexterm" id="idm45657874459072"/>For example, if you had used the existing input chain, <code>INPUT</code>, you would not have received the error:</p>
<pre data-type="programlisting">
$ sudo nft insert rule ip filter INPUT ip saddr 192.168.1.50 tcp dport 22 accept</pre>
<p>Restart <code>nftables</code> after you’ve made your changes:</p>
<pre data-type="programlisting">
$ sudo systemctl restart nftables</pre>
<p>The <code>nftables</code> system replaces <code>iptables</code> and combines functionality from <code>iptables</code>, <code>ip6tables</code>, <code>arptables</code>, and <code>ebtables</code> into a single utility.<a contenteditable="false" data-primary="nftables" data-secondary="learning more about" data-type="indexterm" id="idm45657874452064"/> You can read more about <code>nftables</code> on the <a href="https://oreil.ly/1RXmC">netfilter homepage</a>.</p>
<p>You now have multiple methods of limiting access to the SSH daemon from random hosts. If you don’t want to single out a specific IP address, you can isolate the target system by subnet using 192.168.1.0/24 instead of the individual IP address.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Be aware that opening access from an entire subnet might still place your system in significant danger if an intruder infiltrates your network. Ideally, you should limit access to one or two hosts so that logs and monitoring systems are likelier to detect a breach.</p>
</div>
<p>You can also configure the SSH daemon to limit access to certain users using the <em>/etc/ssh/sshd_config</em> file. You must prevent the root user from using SSH. You learn how to prevent root SSH access in the next section.<a contenteditable="false" data-primary="/etc/ssh/sshd_config" data-primary-sortas="etc" data-type="indexterm" id="idm45657874908672"/></p>
</div></section>
<section data-pdf-bookmark="Denying SSH access for the root user" data-type="sect3"><div class="sect3" id="denying_ssh_access_for_the_root_user">
<h3>Denying SSH access for the root user</h3>
<p>You should, upon installation, deny SSH access to the root user.<a contenteditable="false" data-primary="SSH daemon (SSHD)" data-secondary="denying SSH access for root user" data-type="indexterm" id="idm45657874446624"/><a contenteditable="false" data-primary="root user" data-secondary="denying SSH access to" data-type="indexterm" id="idm45657874445216"/> Some Linux systems deny root logins via SSH by default, while others allow it. The root user should never log into any system via SSH. A regular user should log in via SSH and then become root or use the <code>sudo</code> command to perform tasks as the root user.</p>
<p>You’ll have to check your <em>/etc/ssh/sshd_config</em> for the following line:</p>
<pre data-type="programlisting">
PermitRootLogin yes</pre>
<p>Change the <code>yes</code> to <code>no</code> and restart the SSH service:</p>
<pre data-type="programlisting">
$ sudo systemctl restart sshd</pre>
<p>The root user cannot login via SSH. The root user may directly log into the console.</p>
</div></section>
<section data-pdf-bookmark="Using keys rather than passwords for authentication" data-type="sect3"><div class="sect3" id="using_keys_rather_than_passwords_for_au">
<h3>Using keys rather than passwords for authentication</h3>
<p>Password <a contenteditable="false" data-primary="SSH daemon (SSHD)" data-secondary="using keys rather than passwords for authentication" data-type="indexterm" id="idm45657874437968"/>authentication is <a contenteditable="false" data-primary="authentication" data-secondary="using keys rather than passwords" data-type="indexterm" id="idm45657874436272"/>the least secure method for authenticating users.<a contenteditable="false" data-primary="passwords" data-secondary="using keys instead of for authentication" data-type="indexterm" id="idm45657874434208"/> Using key files is much more secure and efficient. <a contenteditable="false" data-primary="public/private keys" data-secondary="using keys instead of passwords for authentication" data-type="indexterm" id="idm45657874432608"/>You must make the following changes to the <em>/etc/ssh/sshd_config</em> file and restart <code>sshd</code> for the new configuration to take effect:</p>
<pre data-type="programlisting">
PasswordAuthentication yes</pre>
<p>Change the <code>yes</code> to <code>no</code> and then look for the following two entries to ensure they’re uncommented and set as shown:</p>
<pre data-type="programlisting">
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys</pre>
<p>Restart <code>sshd</code> to enable the new settings:</p>
<pre data-type="programlisting">
$ sudo systemctl restart sshd</pre>
<p class="pagebreak-before">On the client side (local system), users need to do the following to set up key pair authentication. Create the public/private key pair. This example is for the user <code>tux</code>, and the remote target system is 192.168.1.99:</p>
<pre data-type="programlisting">
$ ssh-keygen -t rsa

Generating public/private rsa key pair.
Enter file in which to save the key (/home/tux/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/tux/.ssh/id_rsa.
Your public key has been saved in /home/tux/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:NVweugZXvDitzl0JGypcWTJOww/F54vmHUbX7r4U2LQ tux@server1
The key's randomart image is:
+---[RSA 2048]----+
|         . +=    |
|         .B=+..  |
|        .o*@.+ ..|
|         +*o* * +|
|       .S.o+ B E |
|        o.o + * o|
|         + + + + |
|          o o o .|
|               oo|
+----[SHA256]-----+</pre>
<p>Copy the generated keys to a remote host:</p>
<pre data-type="programlisting">
$ ssh-copy-id tux@192.168.1.99
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/tux/...
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to f...
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are ...
tux@192.168.1.99's password:

Number of key(s) added:        1</pre>
<p>Now try logging into the target system with <code>ssh tux@192.168.1.99</code> and check to ensure that only the key(s) you want exist on the target system:</p>
<pre data-type="programlisting">
$ ssh tux@192.168.1.99

Last login: Sun Sep 26 13:48:19 2021 from 192.168.0.10
[tux@server1 ~]$</pre>
<p class="pagebreak-after">User <code>tux</code> has successfully logged into the remote host, <code>server1</code> (192.168.1.99), using a secure key pair rather than a password.</p>
</div></section>
<section data-pdf-bookmark="Remote connectivity: client to server" data-type="sect3"><div class="sect3" id="remote_connectivity_client_to_server">
<h3 class="less_space">Remote connectivity: client to server</h3>
<p>When connecting to a secure protocol service, your client software communicates on a secure channel with the service daemon.<a contenteditable="false" data-primary="remote connectivity, client to server" data-type="indexterm" id="idm45657874417472"/><a contenteditable="false" data-primary="SSH daemon (SSHD)" data-secondary="remote connectivity, client to server" data-type="indexterm" id="idm45657874415888"/> You don’t have to have users do anything special to negotiate a secure communications link between the client and the service daemon.</p>
<p>It’s just as important to keep client software up to date as it is for you, as an administrator, to update the software on servers. <a contenteditable="false" data-primary="client software, keeping up to date" data-type="indexterm" id="idm45657874416816"/>I suggest you set up <code>cron</code> jobs on each user system to automatically download and install updates and configure each new system to receive regular updates with no user interaction required. Be sure to schedule<a contenteditable="false" data-primary="SSH daemon (SSHD)" data-startref="ix_SSHD" data-type="indexterm" id="idm45657874411824"/> any <a contenteditable="false" data-primary="networks" data-secondary="networking and security" data-startref="ix_ntwksecSSHD" data-tertiary="SSH daemon" data-type="indexterm" id="idm45657874409776"/>required <a contenteditable="false" data-primary="security" data-secondary="networking and" data-startref="ix_secntwkSSHD" data-tertiary="SSH daemon" data-type="indexterm" id="idm45657874408032"/>reboots <a contenteditable="false" data-primary="networks" data-secondary="networking and security" data-startref="ix_ntwksec" data-type="indexterm" id="idm45657874405952"/>for nighttime or when the user’s system is idle.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00005">
<h1>Summary</h1>
<p>In this chapter, you learned about selecting an IP addressing scheme for your network and some advantages and disadvantages of the static and dynamic options. You also now know the security implications of connecting systems to your network. You should understand the dangers and how to, as much as possible, prevent security breaches by implementing some good security practices, such as using secure protocols, turning off unnecessary services and daemons, and keeping systems patched and updated.<a contenteditable="false" data-primary="security" data-secondary="networking and" data-startref="ix_secntwk" data-type="indexterm" id="idm45657874402544"/><a contenteditable="false" data-primary="networks" data-startref="ix_ntwk" data-type="indexterm" id="idm45657875460208"/></p>
<p>In the next chapter, you will learn how to install software via a package manager, update your system, and install software from source code.</p>
</div></section>
</div></section></div></body></html>