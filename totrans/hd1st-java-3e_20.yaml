- en: 'Chapter 18\. Dealing with Concurrency Issues: Race Conditions and Immutable
    Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0639-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Doing two or more things at once is hard.** Writing multithreaded code is
    easy. Writing multithreaded code that works the way you expect can be much harder.
    In this final chapter, we’re going to show you some of the things that can go
    wrong when two or more threads are working at the same time. You’ll learn about
    some of the tools in java.util.concurrent that can help you to write multithreaded
    code that works correctly. You’ll learn how to create immutable objects (objects
    that don’t change) that are safe for multiple threads to use. By the end of the
    chapter, you’ll have a lot of different tools in your toolkit for working with
    concurrency.'
  prefs: []
  type: TYPE_NORMAL
- en: What could possibly go wrong?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the end of the last chapter we hinted that things may not all be rainbows
    and sunshine when you’re working with multithreaded code. Well, actually, we did
    more than hint! We outright said:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '“It all comes down to one potentially deadly scenario: two or more threads
    have access to a single object’s data.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0640-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Marriage in Trouble.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0641-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Can this couple be saved?**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Next, on a very special Dr. Steve Show***'
  prefs: []
  type: TYPE_NORMAL
- en: '[Transcript from episode #42]'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to the Dr. Steve show.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got a story today that’s centered around one of the top reasons why couples
    split up—finances.
  prefs: []
  type: TYPE_NORMAL
- en: Today’s troubled pair, Ryan and Monica, share a bank account. But not for long
    if we can’t find a solution. The problem? The classic “two people—one bank account”
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how Monica described it to me:'
  prefs: []
  type: TYPE_NORMAL
- en: “Ryan and I agreed that neither of us will overdraw the checking account. So
    the procedure is, whoever wants to spend money *must* check the balance in the
    account *before* withdrawing cash or spending on a card. It all seemed so simple.
    But suddenly we’re getting hit with overdraft fees!
  prefs: []
  type: TYPE_NORMAL
- en: 'I thought it wasn’t possible; I thought our procedure was safe. But then *this*
    happened:'
  prefs: []
  type: TYPE_NORMAL
- en: Ryan had a full online shopping cart totalling $50\. He checked the balance
    in the account and saw that it was $100\. No problem. So he started the checkout
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0641-02.png)'
  prefs: []
  type: TYPE_IMG
- en: And that’s where *I* come in; while Ryan was filling in the shipping details,
    *I* wanted to spend $100\. I checked the balance, and it’s $100 (because Ryan
    hasn’t clicked the “Pay” button yet), so I think, no problem. So I spend the money,
    and again no problem. But then Ryan finally pays, and we’re suddenly overdrawn!
    He didn’t know that I was spending money at the same time, so he just went ahead
    and completed his transaction without checking the balance again. You’ve got to
    help us, Dr. Steve!”
  prefs: []
  type: TYPE_NORMAL
- en: Is there a solution? Are they doomed? We can’t help them with their online shopping
    addiction, but can we make sure one of them can’t start spending while the other
    one is shopping?
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment and think about that while we go to a commercial break.
  prefs: []
  type: TYPE_NORMAL
- en: The Ryan and Monica problem, in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following example shows what can happen when *two* threads (Ryan and Monica)
    share a *single* object (the bank account).
  prefs: []
  type: TYPE_NORMAL
- en: The code has two classes, BankAccount and RyanAndMonicaJob. There’s also a RyanAndMonicaTest
    with a main method to run everything. The RyanAndMonicaJob class implements Runnable,
    and represents the behavior that Ryan and Monica both have—checking the balance
    and spending money.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RyanAndMonicaJob class has instance variables for the shared BankAccount,
    the person’s name, and the amount they want to spend. The code works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0642-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1.png) **Make an instance of the shared bank account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new one will set up all the defaults correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/2.png) **Make one instance of RyanAndMonicaJob for each person**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need one job for each person. We also need to give them access to the BankAccount
    and tell them how much to spend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) **Create an ExecutorService and give it the two jobs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we know we have two jobs, one for Ryan and one for Monica, we can create
    a fixed-sized thread pool with two threads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/4.png) **Watch both jobs run**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thread represents Ryan, the other represents Monica. Both threads check
    the balance before spending money. Remember that when more than one thread is
    running at a time, you can’t assume that your thread is the only one making changes
    to a shared object (e.g., the BankAccount). Even if there’s only two lines of
    code related to the shared object, and they’re right next to each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**In the goShopping() method, do exactly what Ryan and Monica would do—check
    the balance and, if there’s enough money, spend.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**This should protect against overdrawing the account.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Except...if Ryan and Monica are spending money at the same time, the money
    in the bank account might be gone before the other one can spend it!**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ryan and Monica example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0643-01.png)![image](Images/f0644-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This code is not deterministic; it doesn’t always produce the same result every
    time. You may need to run it a few times before you see the problem.
  prefs: []
  type: TYPE_NORMAL
- en: This is common with multithreaded code, since it depends upon which threads
    start first and when each thread gets its time on a CPU core.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0644-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The goShopping() method always checks the balance before making a withdrawal,
    but still we went overdrawn.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Here’s one scenario:**'
  prefs: []
  type: TYPE_NORMAL
- en: Ryan checks the balance, sees that there’s enough money, and goes to check out.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, Monica checks the balance. She, too, sees that there’s enough money.
    She has no idea that Ryan is about to pay for something.
  prefs: []
  type: TYPE_NORMAL
- en: Ryan completes his purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Monica completes her purchase. Big Problem! In between the time when she checked
    the balance and spent the money, Ryan had already spent money!
  prefs: []
  type: TYPE_NORMAL
- en: '**Monica’s check of the account was not valid, because Ryan had already checked
    and was still in the middle of making a purchase.**'
  prefs: []
  type: TYPE_NORMAL
- en: Monica must be stopped from getting into the account until Ryan has finished,
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '**They need a lock for account access!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The lock works like this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) There’s a lock associated with the bank account transaction
    (checking the balance and withdrawing money). There’s only one key, and it stays
    with the lock until somebody wants to access the account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0645-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The bank account transaction is unlocked when nobody is using the account.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) When Ryan wants to access the bank account (to check
    the balance and withdraw money), he locks the lock and puts the key in his pocket.
    Now nobody else can access the account, since the key is gone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0645-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When Ryan wants to access the account, he secures the lock and takes the
    key.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) **Ryan keeps the key in his pocket until he finishes
    the transaction.** He has the only key, so Monica can’t access the account until
    Ryan unlocks the account and returns the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, even if Ryan gets distracted after he checks the balance, he has a guarantee
    that the balance will be the same when he spends the money, because he kept the
    key while he was doing something else!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0645-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When Ryan is finished, he unlocks the lock and returns the key. Now the key
    is available for Monica (or Ryan again) to access the account.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to check the balance and spend the money as one atomic thing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0646-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to make sure that once a thread starts a shopping transaction, *it must
    be allowed to finish* before any other thread changes the bank account.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we need to make sure that once a thread has checked the account
    balance, that thread has a guarantee that it can spend the money *before any other
    thread can check the account balance!*
  prefs: []
  type: TYPE_NORMAL
- en: Use the **`synchronized`** keyword on a method, or with an object, to lock an
    object so only one thread can use it at a time.
  prefs: []
  type: TYPE_NORMAL
- en: That’s how you protect the bank account! We can put a lock on the bank account
    inside the method that does the banking transaction. That way, one thread gets
    to complete the whole transaction, start to finish, even if that thread is taken
    out of the “running” state by the thread scheduler or another thread is trying
    to make changes at exactly the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next couple of pages we’ll look at the different things that we can
    lock. With the Ryan and Monica example, it’s quite simple—we want to wrap our
    shopping transaction in a block that locks the bank account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0646-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The** `synchronized` **keyword means that a thread needs a key in order to
    access the synchronized code.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**To protect your *data* (like the bank account), synchronize the code that
    acts on that data.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0646-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '(Note for you physics-savvy readers: yes, the convention of using the word
    “ atomic ” here does not reflect the whole subatomic particle thing. Think Newton,
    not Einstein, when you hear the word “ atomic ” in the context of threads or transactions.
    Hey, it’s not OUR convention. If WE were in charge, we’d apply Heisenberg’s Uncertainty
    Principle to pretty much everything related to threads.)'
  prefs: []
  type: TYPE_NORMAL
- en: Using an object’s lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0647-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Every object has a lock. Most of the time, the lock is unlocked, and you can
    imagine a virtual key sitting with it. Object locks come into play only when there
    is a **synchronized block**for an object (like in the last page) or a class has
    **synchronized methods**. A method is synchronized if it has the synchronized
    keyword in the method declaration.
  prefs: []
  type: TYPE_NORMAL
- en: When an object has one or more synchronized methods, ***a thread can enter a
    synchronized method only if the thread can get the key to the object’s lock!***
  prefs: []
  type: TYPE_NORMAL
- en: The locks are not per *method*, they are per *object*. If an object has two
    synchronized methods, it doesn’t *only* mean two threads can’t enter the same
    method. It means you can’t have two threads entering *any* of the synchronized
    methods. If you have two synchronized methods on the same object, method1() and
    method2(), if one thread is in method1(), a second thread can’t enter method1(),
    obviously, but it *also can’t enter method2()*, or any other synchronized method
    on that object.
  prefs: []
  type: TYPE_NORMAL
- en: Think about it. If you have multiple methods that can potentially act on an
    object’s instance variables, all those methods need to be protected with synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of synchronization is to protect critical data. But remember, you don’t
    lock the data itself; you synchronize the methods that *access* that data.
  prefs: []
  type: TYPE_NORMAL
- en: So what happens when a thread is cranking through its call stack (starting with
    the run() method) and it suddenly hits a synchronized method? The thread recognizes
    that it needs a key for that object before it can enter the method. It looks for
    the key (this is all handled by the JVM; there’s no API in Java for accessing
    object locks), and if the key is available, the thread grabs the key and enters
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: From that point forward, the thread hangs on to that key like the thread’s life
    depends on it. The thread won’t give up the key until it completes the synchronized
    method or block. So while that thread is holding the key, no other threads can
    enter *any* of that object’s synchronized methods, because the one key for that
    object won’t be available.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0647-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Every Java object has a lock. A lock has only one key.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the lock is unlocked and nobody cares.
  prefs: []
  type: TYPE_NORMAL
- en: But if an object has synchronized methods, a thread can enter one of the synchronized
    methods ONLY if the key for the object’s lock is available. In other words, only
    if another thread hasn’t already grabbed the one key.
  prefs: []
  type: TYPE_NORMAL
- en: Using synchronized methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can we synchronize the goShopping() method to fix Ryan and Monica’s problem?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**It does NOT work!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0648-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The synchronized keyword locks an object. The goShopping() method is in RyanAndMonicaJob.
    Synchronizing an instance method means “lock *this* RyanAndMonicaJob instance.”
    However, there are *two* instances of RyanAndMonicaJob; one is “ryan,” and the
    other is “monica.” If “ryan” is locked, “monica” can still make changes to the
    bank account; she doesn’t care that the “ryan” job is locked.
  prefs: []
  type: TYPE_NORMAL
- en: The object that needs locking, the object these two threads are fighting over,
    is the BankAccount. Putting synchronized on a method in RyanAndMonicaJob (and
    locking a RyanAndMonicaJob instance) isn’t going to solve anything.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to lock the correct object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since it’s the BankAccount object that’s shared, you could argue it should be
    the BankAccount that’s in charge of making sure it is safe for multiple threads
    to use. The spend() method on BankAccount could make sure there’s enough money
    *and* debit the account in a single transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0649-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The dreaded “Lost Update” problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s another classic concurrency problem. Sometimes you’ll hear them called
    “race conditions,” where two or more threads are changing the same data at the
    same time. It’s closely related to the Ryan and Monica story, so we’ll use this
    example to illustrate a few more points.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lost update revolves around one process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Get the balance in the account'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Add 1 to that balance'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0650-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Even if we used the more common syntax of **`balance++`**, there is no guarantee
    that the compiled bytecode will be an “atomic process.” In fact, it probably won’t—it’s
    actually multiple operations: a read of the current value and then adding one
    to that value and setting it back into the original variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the “Lost Update” problem, we have many threads trying to increment the
    balance. Take a look at the code, and then we’ll look at the real problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0650-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s run this code...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0651-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**We lost the last updates that Thread A made! Thread B had previously done
    a “read” of the value of balance, and when B woke up, it just kept going as if
    it never missed a beat.**'
  prefs: []
  type: TYPE_NORMAL
- en: Make the increment() method atomic. Synchronize it!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0646-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: Synchronizing the increment() method solves the “Lost Update” problem, because
    it keeps the steps in the method (read of balance and increment of balance) as
    one unbreakable unit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0652-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Once a thread enters the method, we have to make sure that all the steps
    in the method complete (as one atomic process) before any other thread can enter
    the method.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Thread A runs for a while'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to enter the increment() method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The method is synchronized, so **get the key** for this object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reads balance: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the value of balance to 0 + 1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now balance is 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return the key** (it completed the increment() method).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-enter the increment() method and **get the key**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reads balance: 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[now thread A is sent back to runnable, but since it has not completed the
    synchronized method, Thread A keeps the key]*'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0653-01.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) Thread B is selected to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to enter the increment() method. The method is synchronized, so we need
    to get the key.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The key is not available.**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*[now thread B is sent into an “object lock not available” lounge]*'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0653-02.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) Thread A runs again, picking up where it left off (remember,
    it still has the key)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: Set the value of balance 1 + 1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now balance is 2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return the key.**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*[now thread A is sent back to runnable, but since it has completed the increment()
    method, the thread does NOT hold on to the key]*'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0653-01.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) Thread B is selected to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0653-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Attempt to enter the increment() method. The method is synchronized, so we need
    to get the key.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This time, the key IS available; get the key.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Reads balance: 2'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*[continues to run...]*'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Deadlock, a deadly side of synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronization saved Ryan and Monica from using their bank account at the same
    time, and has saved us from losing updates. But we also mentioned that we shouldn’t
    synchronize everything, one reason being that synchronization can slow your program
    down.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another important consideration: we need to be careful using synchronized
    code, because nothing will bring your program to its knees like thread deadlock.
    Thread deadlock happens when you have two threads, both of which are holding a
    key the other thread wants. There’s no way out of this scenario, so the two threads
    will simply sit and wait. And wait. And wait.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with databases or other application servers, you might recognize
    the problem; databases often have a locking mechanism somewhat like synchronization.
    But a real transaction management system can sometimes deal with deadlock. It
    might assume, for example, that deadlock might have occurred when two transactions
    are taking too long to complete. But unlike Java, the application server can do
    a “transaction rollback” that returns the state of the rolled-back transaction
    to where it was before the transaction (the atomic part) began.
  prefs: []
  type: TYPE_NORMAL
- en: Java has no mechanism to handle deadlock. It won’t even *know* deadlock occurred.
    So it’s up to you to design carefully. We’re not going to go into more detail
    about deadlock than you see on this page, so if you find yourself writing multithreaded
    code, you might want to study *Java Concurrency in Practice* by Brian Goetz, et
    al. It goes into a lot of detail about the sorts of problems you can face with
    concurrency (like deadlock), and approaches to address these problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**All it takes for deadlock are two objects and two threads.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0654-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A simple deadlock scenario:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0654-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You don’t always have to use synchronized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since synchronization can come with some costs (like performance and potential
    deadlocks), you should know about other ways to manage data that’s shared between
    threads. The java.util.concurrent package has lots of classes and utilities for
    working with multithreaded code.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the shared data is an int, long, or boolean, we might be able to replace
    it with an *atomic variable*. These classes provide methods that are atomic, i.e.,
    can safely be used by a thread without worrying about another thread changing
    the object’s values at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: There are few types of atomic variable, e.g., **AtomicInteger**, **AtomicLong**,
    **AtomicBoolean**, and **AtomicReference**.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix our Lost Update problem with an AtomicInteger, instead of synchronizing
    the increment method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0655-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Atomic variables get more interesting when you use their *compare-and-swap*
    (CAS) operations. CAS is yet another way to make an atomic change to a value.
    You can use CAS on atomic variables by using the **`compareAndSet`** method. Yes,
    it’s a slightly different name! Gotta love programming, where naming is always
    the hardest problem to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The compareAndSet method takes a value, which is what you *expect* the atomic
    variable to be, compares it to the *current* value, and if that matches, *then*
    the operation will complete.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can use this to fix our Ryan and Monica problem, instead of locking
    the whole bank account with **`synchronized`**.
  prefs: []
  type: TYPE_NORMAL
- en: Compare-and-swap with atomic variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How could we make use of atomic variables, and CAS (via **`compareAndSet`**),
    to solve Ryan and Monica’s problem?
  prefs: []
  type: TYPE_NORMAL
- en: Since Ryan and Monica were both trying to access an int value, the account balance,
    we could use an AtomicInteger to store that balance. We could then use **`compareAndSet`**
    to update the balance when someone wants to spend money.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0656-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In plain English:'
  prefs: []
  type: TYPE_NORMAL
- en: '**“Set the balance to this new value only if the current balance is the same
    as this expected value, and tell me if the balance was actually changed.”**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compare-and-swap uses *optimistic locking*. Optimistic locking means you don’t
    stop all threads from getting to the object; you *try* to make the change, but
    you embrace the fact that the change ***might not happen***. If it doesn’t succeed,
    you decide what to do. You might decide to try again, or to send a message letting
    the user know it didn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: This may be more work than simply locking all other threads out from the object,
    but it can be faster than locking everything. For example, when the chances of
    multiple writes happening at the same time are very low or if you have a lot of
    threads reading and not so many writing, then you may not want to pay the price
    of a lock on every write.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re using CAS operations, you have to deal with the times when the operation
    does NOT succeed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ryan and Monica, going atomic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see the whole thing in action in Ryan and Monica’s bank account. We’ll
    put the balance in an AtomicInteger and use compareAndSet to make an *atomic*
    change to the balance.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0657-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: java.util.concurrent has lots of useful classes and utilities for working with
    multithreaded code. Take a look at what’s there!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0658-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Make an object immutable if you’re going to share it between threads and
    you don’t want the threads to change its data.**'
  prefs: []
  type: TYPE_NORMAL
- en: The very best way to know *for sure* that another thread isn’t changing your
    data is to make it impossible to change the data in the object. When an object’s
    data cannot be changed, we call it an **immutable object**.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a class for immutable data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0658-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Using immutable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is terribly convenient to be able to change data on a shared object and assume
    that all the other threads will be able to see these changes.
  prefs: []
  type: TYPE_NORMAL
- en: However, we’ve also seen that while it’s *convenient*, it’s not very *safe*.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when a thread is working with an object that cannot be changed,
    it can make assumptions about the data in that object; e.g., once the thread has
    read a value from the object, it knows that data can’t change.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to use synchronization or other mechanisms to control who changes
    the data because it can’t change.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0659-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Working with immutable objects means thinking in a different way.**'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of making changes to the *same* object, we *replace* the old object
    with a new one. The new object has the updated values, and any threads that need
    the new values need to use the new object.
  prefs: []
  type: TYPE_NORMAL
- en: What happens to the old object? Well, if it’s still being used by something
    (and it might be—it’s perfectly valid sometimes to work with older data), it will
    hang around on the heap. If it’s not being used, it’ll be garbage collected, and
    we don’t have to worry about it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Changing immutable data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a system that has customers, and that each Customer object has an Address
    that represents the street address of a customer. If the customer’s Address is
    an immutable object (all its fields are final and the data cannot be changed),
    how do you change the customer’s address when they move?
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1-circle.png) **The Customer has a reference to the original
    Address object containing the customer’s street address data.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0660-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2-circle.png) **When the customer moves, a brand new Address
    object is created with the new street address for the customer.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0660-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3-circle.png) **The Customer object’s reference to their address
    is changed to point to the new Address object.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0660-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![image](Images/f0661-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Absolutely right. If your system has data that changes, those changes do have
    to happen somewhere. The key idea to take away from this discussion is that not
    all of the classes in your application have to have data that changes. In fact,
    we’d argue for minimizing the places where things change. Then, there are far
    fewer places where you have to think about what happens if multiple threads are
    making changes at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of techniques for working effectively with immutable data
    classes; we’ve just scratched the surface here. It is interesting to note that
    Java 16 introduced *records*, which are immutable data classes provided directly
    by the language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use immutable data classes where you can.
  prefs: []
  type: TYPE_NORMAL
- en: Limit the number of places where data can be changed by multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: More problems with shared data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0662-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re nearly there, we promise! Just one last thing to look at.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve seen all sorts of problems that can come from many threads writing
    to the same data. This applies to data in Collections too.
  prefs: []
  type: TYPE_NORMAL
- en: We can even have problems when we have lots of threads *reading* the same data,
    even if only one thread is making changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: This code has just one thread writing to a collection, but two threads reading
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0662-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading from a changing data structure causes an Exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the code on the last page causes an Exception to be thrown, sometimes.
    By now you know these sorts of issues depend a lot on the whims of the hardware,
    the operating system, and the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0663-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a collection is changed by one thread while another thread is reading that
    collection, you can get a ConcurrentModificationException.
  prefs: []
  type: TYPE_NORMAL
- en: Use a thread-safe data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clearly good ol’ ArrayList just isn’t going to cut it if you have threads reading
    data that’s being changed at the same time. Luckily for us, there are other options.
    We want a thread-safe data structure, one that can be written to, and read from,
    by multiple threads at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The java.util.concurrent package has a number of thread-safe data structures,
    and we’re going to look at **`CopyOnWriteArrayList`** to solve this specific problem.
  prefs: []
  type: TYPE_NORMAL
- en: CopyOnWriteArrayList is a reasonable choice when you have a List that is being
    **read a lot, but not changed very often**. We’ll see why later.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0664-01.png)![image](Images/f0664-02.png)'
  prefs: []
  type: TYPE_IMG
- en: CopyOnWriteArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CopyOnWriteArrayList uses immutability to provide safe access for reading threads
    while other threads are writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does it work? Well, it does what it says on the tin: when a thread is writing
    to the list, it’s actually writing to a *copy* of the list. When the changes have
    been made, then the new copy replaces the original. In the meantime, any threads
    that were reading the list before the change are happily (and safely!) reading
    the original.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circle.png) **An instance of CopyOnWriteArrayList contains
    an ordered set of data, like an array.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0665-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2circle.png) When Thread A reads the CopyOnWriteArrayList,
    it gets an Iterator that allows it to read a **snapshot** of the list data at
    that point in time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0665-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3circle.png) Thread B writes data to the CopyOnWriteArrayList
    by adding a new element, and the CopyOnWriteArray creates a **copy** of the list
    data before any changes are made. This is invisible to any of the reading or writing
    threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0665-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4-circle.png) When Thread B makes changes to “the list,” it’s
    actually making changes to this copy. It’s happy knowing the changes are being
    made. The reading threads like Thread A are not affected at all; they’re iterating
    over the snapshot of the original data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0665-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/1circlee.png) Once Thread B has finished its updates, then
    the original data is replaced with the new data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Thread A is still reading, it’s safely reading the old data. If any other
    threads start reading after the change, they get the new data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0665-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Thread-safe collections in early versions of Java were made safe via locking.
    For example, java.util.Vector.
  prefs: []
  type: TYPE_NORMAL
- en: Java 5 introduced concurrent data structures in java.util.concurrent. These
    do NOT use locking.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the JVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0668-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The Java file on this page represents a complete source file. Your job is
    to play JVM and determine what the output would be when the program runs.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**How might you fix it, making sure the output is correct every time?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr1.png) **Answers in [“BE the JVM”](#be_the_jvm_left_parenthesisfrom_page_668).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Near-miss at the airlock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image](Images/f0415-01.png)'
  prefs: []
  type: TYPE_IMG
- en: As Sarah joined the onboard development team’s design review meeting, she gazed
    out the portal at sunrise over the Indian Ocean. Even though the ship’s conference
    room was incredibly claustrophobic, the sight of the growing blue and white crescent
    overtaking night on the planet below filled Sarah with awe and appreciation.
  prefs: []
  type: TYPE_NORMAL
- en: Five-Minute Mystery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0415-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This morning’s meeting was focused on the control systems for the orbiter’s
    airlocks. As the final construction phases were nearing their end, the number
    of spacewalks was scheduled to increase dramatically, and traffic was high both
    in and out of the ship’s airlocks. “Good morning, Sarah,” said Tom, “Your timing
    is perfect; we’re just starting the detailed design review.”
  prefs: []
  type: TYPE_NORMAL
- en: “As you all know,” said Tom, “Each airlock is outfitted with space-hardened
    GUI terminals, both inside and out. Whenever spacewalkers are entering or exiting
    the orbiter they will use these terminals to initiate the airlock sequences.”
    Sarah nodded and asked, “Tom, can you tell us what the method sequences are for
    entry and exit?” Tom rose and floated to the whiteboard, “First, here’s the exit
    sequence method’s pseudocode.” Tom quickly wrote on the board.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: “To ensure that the sequence is not interrupted, we have synchronized all of
    the methods called by the orbiterAirlockExitSequence() method,” Tom explained.
    “We’d hate to see a returning spacewalker inadvertently catch a buddy with his
    space pants down!”
  prefs: []
  type: TYPE_NORMAL
- en: Everyone chuckled as Tom erased the whiteboard, but something didn’t feel right
    to Sarah, and it finally clicked as Tom began to write the entry sequence pseudocode
    on the whiteboard. “Wait a minute, Tom!” cried Sarah, “I think we’ve got a big
    flaw in the exit sequence design.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go back and revisit it; it could be critical!”
  prefs: []
  type: TYPE_NORMAL
- en: '***Why did Sarah stop the meeting? What did she suspect?***'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr1.png) **Answers in [“Five-Minute Mystery”](#five-minute_mystery_left_parent-id0002).**'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the JVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the JVM”](#be_the_jvm))
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the output won’t be the same every time. In theory, one might
    expect the size to always be 52 (2 × 26 letters in the alphabet), but in fact
    this is one of those lost-update problems.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0670-01.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be solved in two different ways; both are valid.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronize the write method**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0670-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Use a thread-safe collection**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0670-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use either solution, you do NOT have to do both!!
  prefs: []
  type: TYPE_NORMAL
- en: With a thread-safe collection, you don’t have to synchronize the writing method.
  prefs: []
  type: TYPE_NORMAL
- en: Five-Minute Mystery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the JVM”](#be_the_jvm))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0415-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**What did Sarah know?**'
  prefs: []
  type: TYPE_NORMAL
- en: Sarah realized that in order to ensure that the entire exit sequence would run
    without interruption the `orbiterAirlockExitSequence`( ) method needed to be synchronized.
    As the design stood, it would be possible for a returning spacewalker to interrupt
    the Exit Sequence! The Exit Sequence thread couldn’t be interrupted in the middle
    of any of the lower-level method calls, but it could be interrupted in *between*
    those calls. Sarah knew that the entire sequence should be run as one atomic unit,
    and if the `orbiterAirlockExitSequence()` method was synchronized, it could not
    be interrupted at any point.
  prefs: []
  type: TYPE_NORMAL
