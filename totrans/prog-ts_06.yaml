- en: Chapter 6\. Advanced Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript has a world-class type system that supports powerful type-level programming
    features that might make even the crotchetiest Haskell programmer jealous. As
    you by now know, that type system isn’t just incredibly expressive, but also easy
    to use, and makes declaring type constraints and relationships simple, terse,
    and most of the time, inferred.
  prefs: []
  type: TYPE_NORMAL
- en: We need such an expressive and unusual type system because JavaScript is so
    dynamic. Modeling things like prototypes, dynamically bound `this`, function overloads,
    and always-changing objects requires a rich type system and a utility belt of
    type operators that would make Batman do a double-take.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start this chapter with a deep dive into subtyping, assignability, variance,
    and widening in TypeScript, giving more definition to the intuitions you’ve been
    developing over the last several chapters. I’ll then cover TypeScript’s control-flow-based
    typechecking features in more detail, including refinement and totality, and continue
    with some advanced type-level programming features: keying into and mapping over
    object types, using conditional types, defining your own type guards, and escape
    hatches like type assertions and definite assignment assertions. Finally, I’ll
    cover advanced patterns for squeezing more safety out of your types: the companion
    object pattern, improving inference for tuple types, simulating nominal types,
    and safely extending the prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships Between Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s begin by taking a closer look at type relations in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Subtypes and Supertypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We talked a little about assignability in [“Talking About Types”](ch03.html#talking-about-types).
    Now that you’ve seen most of the types TypeScript has to offer we can dive deeper,
    starting from the top: what’s a subtype?'
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0601](assets/prts_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. B is a subtype of A
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you look back at [Figure 3-1](ch03.html#ch03-type-hierarchy) at the very
    beginning of Chapter 3, you’ll see what the subtype relations built into TypeScript
    are. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Array is a subtype of Object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple is a subtype of Array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is a subtype of `any`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never` is a subtype of everything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a class `Bird` that extends `Animal`, then `Bird` is a subtype of
    `Animal`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the definition I just gave for subtype, that means:'
  prefs: []
  type: TYPE_NORMAL
- en: Anywhere you need an Object you can also use an Array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anywhere you need an Array you can also use a Tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anywhere you need an `any` you can also use an Object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a `never` anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anywhere you need an `Animal` you can also use a `Bird`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you might have guessed, a supertype is the opposite of a subtype.
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0602](assets/prts_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. B is a supertype of A
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Again from the flowchart in [Figure 3-1](ch03.html#ch03-type-hierarchy):'
  prefs: []
  type: TYPE_NORMAL
- en: Array is a supertype of Tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object is a supertype of Array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any is a supertype of everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never is a supertype of nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animal` is a supertype of `Bird`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just the opposite of how subtypes work, and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: Variance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most types it’s pretty easy to intuit whether or not some type `A` is a
    subtype of another type `B`. For simple types like `number`, `string`, and so
    on, you can just look them up in the flowchart in [Figure 3-1](ch03.html#ch03-type-hierarchy),
    or reason through it (”`number` is contained in the union `number | string`, so
    it must be a subtype of it”).
  prefs: []
  type: TYPE_NORMAL
- en: 'But for parameterized (generic) types and other more complex types, it gets
    more complicated. Consider these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When is `Array<A>` a subtype of `Array<B>`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is a shape `A` a subtype of another shape `B`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When is a function `(a: A) => B` a subtype of another function `(c: C) => D`?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subtyping rules for types that contain other types (i.e., things with type
    parameters like `Array<A>`, shapes with fields like `{a: number}`, or functions
    like `(a: A) => B`) are harder to reason about, and the answers aren’t as clear-cut.
    In fact, subtyping rules for these kinds of complex types are a big point of disagreement
    among programming languages—almost no two languages are alike!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the following rules easier to read, I’m going to introduce a few pieces
    of syntax that let us talk about types a little more precisely and tersely. This
    syntax is not valid TypeScript; it’s just a way for you and me to share a common
    language when we talk about types. And don’t worry, I swear the syntax isn’t math:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A <: B` means "`A` is a subtype of or the same as the type `B`.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A >: B` means "`A` is a supertype of or the same as the type `B`.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shape and array variance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get some intuition for why exactly languages disagree on subtyping rules
    for complex types, let me take you through an example complex type: shapes. Say
    you have a shape describing a user in your application. You might represent it
    with a pair of types that look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose an intern at your company is tasked with writing some code to delete
    a user. They start it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`deleteUser` takes an object of type `{id?: number, name: string}`, and it’s
    passed an `existingUser` of type `{id: number, name: string}`. Notice that the
    type of the `id` property (`number`) is a *subtype* of the expected type (`number
    | undefined`). Therefore the entire object `{id: number, name: string}` is a subtype
    of `{id?: number, name: string}`, so TypeScript lets it fly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you see the safety issue here? It’s a subtle one: after passing an `ExistingUser`
    to `deleteUser`, TypeScript doesn’t know that the user’s `id` has been deleted,
    so if we read `existingUser.id` after deleting it with `deleteUser(existingUser)`,
    TypeScript still thinks `existingUser.id` is of type `number`!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, using an object type in a place where something expects its supertype
    can be unsafe. So why does TypeScript allow it? In general, TypeScript is not
    designed to be perfectly safe; instead, its type system tries to strike a balance
    between catching real mistakes and being easy to use, without you needing to get
    a degree in programming language theory to understand why something is an error.
    This specific case of unsafety is a practical one: since destructive updates (like
    deleting a property) are relatively rare in practice, TypeScript is lax and lets
    you assign an object to a place where its supertype is expected.'
  prefs: []
  type: TYPE_NORMAL
- en: What about the opposite direction—can you assign an object to a place where
    its subtype is expected?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a new type for a legacy user, then delete a user of that type (imagine
    you’re adding types to code your coworker wrote before you started using TypeScript):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we pass a shape with a property whose type is a supertype of the expected
    type, TypeScript complains. That’s because `id` is a `string | number |` `undefined`,
    and `deleteUser` only handles the case of an `id` that’s a `number | undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript’s behavior is as follows: if you expect a shape, you can also pass
    a type with property types that are `<:` their expected types, but you cannot
    pass a shape with property types that are supertypes of their expected types.
    When talking about types, we say that TypeScript shapes (objects and classes)
    are *covariant* in their property types. That is, for an object `A` to be assignable
    to an object `B`, each of its properties must be `<:` its corresponding property
    in `B`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, covariance is just one of four sorts of variance:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Invariance*'
  prefs: []
  type: TYPE_NORMAL
- en: You want exactly a `T`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Covariance*'
  prefs: []
  type: TYPE_NORMAL
- en: You want a `<:T`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Contravariance*'
  prefs: []
  type: TYPE_NORMAL
- en: You want a `>:T`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bivariance*'
  prefs: []
  type: TYPE_NORMAL
- en: You’re OK with either `<:T` or `>:T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, every complex type is covariant in its members—objects, classes,
    arrays, and function return types—with one exception: function parameter types,
    which are *contravariant*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Not all languages make this same design decision. In some languages objects
    are *invariant* in their property types, because as we saw, covariant property
    types can lead to unsafe behavior. Some languages have different rules for mutable
    and immutable objects (try to reason through it yourself!). Some languages—like
    Scala, Kotlin, and Flow—even have explicit syntax for programmers to specify variance
    for their own data types.
  prefs: []
  type: TYPE_NORMAL
- en: When designing TypeScript, its authors opted for a balance between ease of use
    and safety. When you make objects invariant in their property types, even though
    it’s safer, it can make a type system tedious to use because you end up banning
    things that are safe in practice (e.g., if we didn’t `delete` the `id` in `deleteUser`,
    then it would have been perfectly safe to pass in an object that’s a supertype
    of the expected type).
  prefs: []
  type: TYPE_NORMAL
- en: Function variance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function `A` is a subtype of function `B` if `A` has the same or lower arity
    (number of parameters) than `B` and:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A`’s `this` type either isn’t specified, or is `>: B`’s `this` type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of `A`’s parameters is `>:` its corresponding parameter in `B`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A`’s return type is `<: B`’s return type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read that over a few times, and make sure you understand what each rule means.
    You might have noticed that for a function `A` to be a subtype of function `B`,
    we say that its `this` type and parameters must be `>:` their counterparts in
    `B`, while its return type has to be `<:`! Why does the direction flip like that?
    Why isn’t it simply `<:` for each component (`this` type, parameter types, and
    return type), like it is for objects, arrays, unions, and so on?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this question, let’s derive it ourselves. We’ll start by defining
    three types (we’re going to use a `class` for clarity, but this works for any
    choice of types where `A <: B <: C`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `Crow` is a subtype of `Bird`, which is a subtype of `Animal`.
    That is, `Crow <: Bird <: Animal`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define a function that takes a `Bird`, and makes it chirp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. What kinds of things does TypeScript let you pass into `chirp`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass an instance of `Bird` (because that’s what `chirp`’s parameter
    `bird`’s type is) or an instance of `Crow` (because it’s a subtype of `Bird`).
    Great: passing in a subtype works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a new function. This time, its parameter will be a *function*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`clone` needs a function `f` that takes a `Bird` and returns a `Bird`. What
    types of functions can you safely pass for `f`? Clearly you can pass a function
    that takes a `Bird` and returns a `Bird`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What about a function that takes a `Bird` and returns a `Crow`, or an `Animal`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`birdToCrow` works as expected, but `birdToAnimal` gives us an error. Why?
    Imagine that `clone`’s implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we passed to our `clone` function an `f` that returned an `Animal`, then
    we couldn’t call `.chirp` on it! So TypeScript has to make sure, at compile time,
    that the function we passed in returns *at least* a `Bird`.
  prefs: []
  type: TYPE_NORMAL
- en: We say that functions are *covariant* in their return types, which is a fancy
    way of saying that for a function to be a subtype of another function, its return
    type has to be `<:` the other function’s return type.
  prefs: []
  type: TYPE_NORMAL
- en: OK, what about parameter types?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For a function to be assignable to another function, its parameter types (including
    `this`) all have to be `>:` their corresponding parameter types in the other function.
    To see why, think about how a user might have implemented `crowToBird` before
    passing it into `clone`. What if they did this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now if `clone` called `crowToBird` with a `new Bird`, we’d get an exception
    because `.caw` is only defined on `Crow`s, not on all `Bird`s.
  prefs: []
  type: TYPE_NORMAL
- en: This means functions are *contravariant* in their parameter and `this` types.
    That is, for a function to be a subtype of another function, each of its parameters
    and its `this` type must be `>:` its corresponding parameter in the other function.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, you don’t have to memorize and recite these rules. Just have them
    in the back of your mind when your code editor gives you a red squiggly when you
    pass an incorrectly typed function somewhere, so you know why TypeScript is giving
    you the error it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'TSC Flag: strictFunctionTypes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For legacy reasons, functions in TypeScript are actually covariant in their
    parameter and `this` types by default. To opt into the safer, contravariant behavior
    we just explored, be sure to enable the `{"strictFunctionTypes": true}` flag in
    your *tsconfig.json*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`strict` mode includes `strictFunctionTypes`, so if you’re already using `{"strict":
    true}`, you’re good to go.'
  prefs: []
  type: TYPE_NORMAL
- en: Assignability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subtype and supertype relations are core concepts in any statically typed language.
    They’re also important to understanding how *assignability* works (as a reminder,
    assignability refers to TypeScript’s rules for whether or not you can use a type
    `A` where another type `B` is required).
  prefs: []
  type: TYPE_NORMAL
- en: 'When TypeScript wants to answer the question “Is type `A` assignable to type
    `B`?” it follows a few simple rules. For *non-enum types*—like arrays, booleans,
    numbers, objects, functions, classes, class instances, and strings, including
    literal types—`A` is assignable to `B` if either of the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A <: B`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A` is `any`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rule 1 is just the definition of what a subtype is: if `A` is a subtype of
    `B`, then wherever you need a `B` you can also use an `A`.'
  prefs: []
  type: TYPE_NORMAL
- en: Rule 2 is the exception to rule 1, and is a convenience for interoperating with
    JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *enum types* created with the `enum` or `const enum` keywords, a type `A`
    is assignable to an enum `B` if either of these is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A` is a member of enum `B`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`B` has at least one member that’s a `number`, and `A` is a `number`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rule 1 is exactly the same as for simple types (if `A` is a member of enum
    `B`, then `A`’s type is `B`, so all we’re saying is `B <: B`).'
  prefs: []
  type: TYPE_NORMAL
- en: Rule 2 is a convenience for working with enums. As we talked about in [“Enums”](ch03.html#enums),
    rule 2 is a big source of unsafety in TypeScript, and this is one reason I suggest
    throwing the baby out with the bathwater and avoiding enums entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Type Widening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Type widening* is key to understanding how TypeScript’s type inference works.
    In general, TypeScript will be lenient when inferring your types, and will err
    on the side of inferring a more general type rather than the most specific type
    possible. This makes your life as a programmer easier, and means less time spent
    quelling the typechecker’s complaints.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#types), you already saw a few instances of type widening
    in action. Let’s look at a few more examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare a variable in a way that allows it to be mutated later (e.g.,
    with `let` or `var`), its type is widened from its literal value to the base type
    that literal belongs to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Not so for immutable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use an explicit type annotation to prevent your type from being widened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When you reassign a nonwidened type using `let` or `var`, TypeScript widens
    it for you. To tell TypeScript to keep it narrow, add an explicit type annotation
    to your original declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables initialized to `null` or `undefined` are widened to `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But when a variable initialized to `null` or `undefined` leaves the scope it
    was declared in, TypeScript assigns it a definite type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The const type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript comes with a special `const` type that you can use to opt out of
    type widening a declaration at a time. Use it as a type assertion (read ahead
    to [“Type Assertions”](#type-assertions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`const` opts your type out of widening and recursively marks its members as
    `readonly`, even for deeply nested data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Use `as const` when you want TypeScript to infer your type as narrowly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Excess property checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type widening also comes into the picture when TypeScript checks whether or
    not one object type is assignable to another object type.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [“Shape and array variance”](#shape-variance) that object types
    are covariant in their members. But if TypeScript stuck to this rule without doing
    any additional checks, it could lead to a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider an `Options` object you might pass into a class to configure
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, what happens if you misspell an option?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a common bug when working with JavaScript, so it’s really helpful that
    TypeScript helps us catch it. But if object types are covariant in their members,
    how is it that TypeScript catches this?
  prefs: []
  type: TYPE_NORMAL
- en: 'That is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We expected the type `{baseURL: string, cacheSize?: number, tier?: ''prod''
    | ''dev''}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We passed in the type `{baseURL: string, tierr: string}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type we passed in is a subtype of the type we expected, but somehow, TypeScript
    knew to report an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript was able to catch this due to its *excess property checking*, which
    works like this: when you try to assign a fresh object literal type `T` to another
    type `U`, and `T` has properties that aren’t present in `U`, TypeScript reports
    an error.'
  prefs: []
  type: TYPE_NORMAL
- en: A *fresh object literal type* is the type TypeScript infers from an object literal.
    If that object literal either uses a type assertion (see [“Type Assertions”](#type-assertions))
    or is assigned to a variable, then the fresh object literal type is *widened*
    to a regular object type, and its freshness disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition is dense, so let’s walk through our example again, trying a
    few more variations on the theme this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate `API` with a `baseURL` and one of our two optional properties,
    `tier`. This works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we misspell `tier` as `badTier`. The options object we pass to `new API`
    is fresh (because its type is inferred, it isn’t assigned to a variable, and we
    don’t make a type assertion about its type), so TypeScript runs an excess property
    check on it, revealing the excess `badTier` property (which is defined in our
    options object but not on the `Options` type).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assert that our invalid options object is of type `Options`. TypeScript
    no longer considers it fresh, and bails out of excess property checking: no error.
    If you’re not familiar with the `as T` syntax, read ahead to [“Type Assertions”](#type-assertions).'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_types_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign our options object to a variable, `badOptions`. TypeScript no longer
    considers it to be fresh, and bails out of excess property checking: no error.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_types_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: When we explicitly type `options` as `Options`, the object we assign to `options`
    is fresh, so TypeScript performs excess property checking, catching our bug. Note
    that in this case the excess property check doesn’t happen when we pass `options`
    to `new API`; rather, it happens when we try to assign our options object to the
    variable `options`.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry—you don’t need to memorize these rules. They are TypeScript’s internal
    heuristics for catching the most bugs possible in a practical way, so as not to
    be a burden on you, the programmer. Just keep them in mind when you’re wondering
    how TypeScript knew to complain about that one bug that even Ivan, the battle-weathered
    gatekeeper of your company’s codebase and master code reviewer, didn’t notice.
  prefs: []
  type: TYPE_NORMAL
- en: Refinement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript performs flow-based type inference, which is a kind of symbolic execution
    where the typechecker uses control flow statements like `if`, `?`, `||`, and `switch`,
    as well as type queries like `typeof`, `instanceof`, and `in`, to *refine* types
    as it goes, just like a programmer reading through the code would.^([1](ch06.html#idm46304967500104))
    It’s an incredibly convenient feature for a typechecker to have, but is another
    one of those things that remarkably few languages support.^([2](ch06.html#idm46304967497288))
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through an example. Say we’ve built an API for defining CSS rules
    in TypeScript, and a coworker wants to use it to set an HTML element’s `width`.
    They pass in the width, which we then want to parse and validate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first implement a function to parse a CSS string into a value and a unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can then use `parseUnit` to parse a width value passed to us by a user. `width`
    might be a number (which we assume is in pixels), or a string with units attached,
    or it might be `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We take advantage of type refinement a few times in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is smart enough to know that doing a loose equality check against
    `null` will return `true` for both `null` and `undefined` in JavaScript. It knows
    that if this check passes then we will return, and if we didn’t return that means
    the check didn’t pass, so from then on `width`’s type is `number | string` (it
    can’t be `null` or `undefined` anymore). We say that the type was refined from
    `number | string | null | undefined` to `number | string`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `typeof` check queries a value at runtime to see what its type is. TypeScript
    takes advantage of `typeof` at compile time too: in the `if` branch where the
    check passes, TypeScript knows that `width` is a `number`; otherwise (since that
    branch `return`s) `width` must be a `string`—it’s the only type left.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Because calling `parseUnit` might return `null`, we check if it did by testing
    whether its result is truthy.^([3](ch06.html#idm46304967201672)) TypeScript knows
    that if `unit` is truthy then it must be of type `Unit` in the `if` branch—otherwise,
    `unit` must be falsy, meaning it must be of type `null` (refined from `Unit |
    null`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_types_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return `null`. This can only happen if the user passed a `string`
    for `width`, but that string contained a unit that we don’t support.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve spelled out exactly what TypeScript was thinking for each of the type refinements
    it performed here, but I hope this was already intuitive and obvious for you,
    the programmer reading that code. TypeScript does a superb job of taking what’s
    going through your mind as you read and write code, and crystallizing it in the
    form of typechecking and inference rules.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated union types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we just learned, TypeScript has a deep understanding of how JavaScript works,
    and is able to follow along as you refine your types, just like you would when
    you trace through your program in your head.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we’re building a custom event system for an application. We
    start by defining a couple of event types, along with a function to handle events
    that come in. Imagine that `UserTextEvent` models a keyboard event (e.g., the
    user typed something in a text `<input />`) and `UserMouseEvent` models a mouse
    event (e.g., the user moved their mouse to the coordinates `[100, 200]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `if` block, TypeScript knows that `event.value` has to be a `string`
    (because of the `typeof` check), which implies that after the `if` block `event.value`
    has to be a tuple of `[number, number]` (because of the `return` in the `if` block).
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we make this a little more complicated? Let’s add some more
    information to our event types, and see how TypeScript fares when we refine our
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: While the refinement worked for `event.value`, it didn’t carry over to `event.target`.
    Why? When `handle` takes a parameter of type `UserEvent`, that doesn’t mean we
    have to pass a `UserTextEvent` or `UserMouseEvent`—in fact, we could pass an argument
    of type `UserMouseEvent | UserTextEvent`. And since members of a union might overlap,
    TypeScript needs a more reliable way to know when we’re in one case of a union
    type versus another case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do this is to use a literal type to *tag* each case of your union
    type. A good tag is:'
  prefs: []
  type: TYPE_NORMAL
- en: On the same place in each case of your union type. That means the same object
    field if it’s a union of object types, or the same index if it’s a union of tuple
    types. In practice, tagged unions usually use object types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed as a literal type (a literal string, number, boolean, etc.). You can mix
    and match different types of literals, but it’s good practice to stick to a single
    type; typically, that’s a string literal type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not generic. Tags should not take any generic type arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutually exclusive (i.e., unique within the union type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that in mind, let’s update our event types again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now when we refine `event` based on the value of its tagged field (`event.type`),
    TypeScript knows that in the `if` branch `event` has to be a `UserTextEvent`,
    and after the `if` branch it has to be a `UserMouseEvent`. Since the tag is unique
    per union type, TypeScript knows that the two are mutually exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Use tagged unions when writing a function that has to handle the different cases
    of a union type. For example, they’re invaluable when working with Flux actions,
    Redux reducers, or React’s `useReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: Totality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A programmer puts two glasses on her bedside table before going to sleep: a
    full one, in case she gets thirsty, and an empty one, in case she doesn’t.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Anonymous
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Totality, also called *exhaustiveness checking*, is what allows the typechecker
    to make sure you’ve covered all your cases. It comes to us from Haskell, OCaml,
    and other languages that are based around pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript will check for totality in a variety of cases, and give you helpful
    warnings when you’ve missed a case. This is an incredibly helpful feature for
    preventing real bugs. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We clearly missed a few days (it’s been a long week). TypeScript comes to the
    rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'TSC Flag: noImplicitReturns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ask TypeScript to check that all of your functions’ code paths return a
    value (and throw the preceding warning if you missed a spot), enable the `noImplicitReturns`
    flag in your *tsconfig.json*. Whether you enable this flag or not is up to you:
    some people prefer a code style with fewer explicit `return`s, and some people
    are fine with a few extra `return`s in the name of better type safety and more
    bugs caught by the typechecker.'
  prefs: []
  type: TYPE_NORMAL
- en: This error message is telling us that either we missed some cases and should
    cover them with a catchall `return` statement at the end that returns something
    like `'Sat'` (that’d be nice, huh), or we should adjust `getNextDay`’s return
    type to `Day |` `undefined`. After we add a `case` for each `Day`, the error goes
    away (try it!). Because we annotated `getNextDay`’s return type, and not all branches
    are guaranteed to return a value of that type, TypeScript warns us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation details in this example aren’t important: no matter what
    kind of control structure you use—`switch`, `if`, `throw`, and so on—TypeScript
    will watch your back to make sure you have every case covered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe a client’s continued voicemails about that missed deadline have you jittery,
    and you forgot to handle numbers under `100` in your business-critical `isBig`
    function. Again, never fear—TypeScript is watching out for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Or maybe the weekend gave you a chance to clear your mind, and you realized
    that you should rewrite that `getNextDay` example from earlier to be more efficient.
    Instead of using a `switch`, why not a constant-time lookup in an object?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With your Bichon Frise yapping away in the other room (something about the neighbor’s
    dog?), you absentmindedly forgot to fill in the other days in your new `nextDay`
    object before you committed your code and moved on to other things.
  prefs: []
  type: TYPE_NORMAL
- en: While TypeScript will give you an error the next time you try to access `nextDay.Tue`,
    you could have been more proactive about it when declaring `nextDay` in the first
    place. There are two ways to do that, as you’ll learn in [“The Record Type”](#record-type)
    and [“Mapped Types”](#mapped-types); but before we get there, let’s take a slight
    detour into type operators for object types.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Object Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects are central to JavaScript, and TypeScript gives you a whole bunch of
    ways to express and manipulate them safely.
  prefs: []
  type: TYPE_NORMAL
- en: Type Operators for Object Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember union (`|`) and intersection (`&`), the two type operators I introduced
    in [“Union and intersection types”](ch03.html#union-intersection)? It turns out
    they’re not the only type operators TypeScript gives you! Let’s run through a
    few more type operators that come in handy for working with shapes.
  prefs: []
  type: TYPE_NORMAL
- en: The keying-in operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Say you have a complex nested type to model the GraphQL API response you got
    back from your social media API of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You might fetch that response from the API, then render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What should the type of `friendList` be? (It’s stubbed out as `unknown` for
    now.) You could type it out and reimplement your top-level `APIResponse` type
    in terms of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But then you’d have to come up with names for each of your top-level types,
    which you don’t always want (e.g., if you used a build tool to generate TypeScript
    types from your GraphQL schema). Instead, you can *key in* to your type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can key in to any shape (object, class constructor, or class instance),
    and any array. For example, to get the type of an individual friend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`number` is a way to key in to an array type; for tuples, use `0`, `1`, or
    another number literal type to represent the index you want to key in to.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for keying in is intentionally similar to how you look up fields
    in regular JavaScript objects—just as you might look up a value in an object,
    so you can look up a type in a shape. Note that you have to use bracket notation,
    not dot notation, to look up property types when keying in.
  prefs: []
  type: TYPE_NORMAL
- en: The keyof operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use `keyof` to get all of an object’s keys as a union of string literal types.
    Using the previous `APIResponse` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining the keying-in and `keyof` operators, you can implement a typesafe
    getter function that looks up the value at the given key in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`get` is a function that takes an object `o` and a key `k`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`keyof O` is a union of string literal types, representing all of `o`’s keys.
    The generic type `K` extends—and is a subtype of—that union. For example, if `o`
    has the type `{a: number, b: string, c: boolean}`, then `keyof o` is the type
    `''a'' | ''b'' | ''c''`, and `K` (which extends `keyof o`) could be the type `''a''`,
    `''b''`, `''a'' | ''c''`, or any other subtype of `keyof o`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`O[K]` is the type you get when you look up `K` in `O`. Continuing the example
    from [![2](assets/2.png)](#co_advanced_types_CO3-2), if `K` is `''a''`, then we
    know at compile time that `get` returns a `number`. Or, if `K` is `''b'' | ''c''`,
    then we know `get` returns `string | boolean`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s cool about these type operators is how precisely and safely they let
    you describe shape types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript goes to work for you, verifying *at compile time* that the type
    of `lastEvent` is `Date`. Of course, you could extend this in order to key in
    to an object more deeply too. Let’s overload `get` to accept up to three keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare an overloaded function signature for `get` with three cases for when
    we call `get` with one key, two keys, and three keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This one-key case is the same as the last example: `O` is a subtype of `object`,
    `K1` is a subtype of that object’s keys, and the return type is whatever specific
    type you get when you key in to `O` with `K1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The two-key case is like the one-key case, but we declare one more generic type,
    `K2`, to model the possible keys on the nested object that results from keying
    into `O` with `K1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_types_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We build on [![2](assets/2.png)](#co_advanced_types_CO4-2) by keying in twice—we
    first get the type of `O[K1]`, then get the type of `[K2]` on the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_types_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: For this example we handle up to three nested keys; if you’re writing a real-world
    library, you’ll probably want to handle a few more cases than that.
  prefs: []
  type: TYPE_NORMAL
- en: Cool, huh? If you have a minute, show this example to your Java friends, and
    be sure to gloat as you walk them through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'TSC Flag: keyofStringsOnly'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, objects and arrays can have both string and symbol keys. And
    by convention, we usually use number keys for arrays, which are coerced to strings
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, `keyof` in TypeScript returns a value of type `number | string
    | symbol` by default (though if you call it on a more specific shape, TypeScript
    can infer a more specific subtype of that union).
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is correct, but can make working with `keyof` wordy, as you may
    have to prove to TypeScript that the particular key you’re manipulating is a `string`,
    and not a `number` or a `symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: To opt into TypeScript’s legacy behavior—where keys must be strings—enable the
    `keyofStringsOnly` *tsconfig.json* flag.
  prefs: []
  type: TYPE_NORMAL
- en: The Record Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript’s built-in `Record` type is a way to describe an object as a map
    from something to something.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from the `Weekday` example in [“Totality”](#totality) that there are
    two ways to enforce that an object defines a specific set of keys. `Record` types
    are the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `Record` to build a map from each day of the week to the next day
    of the week. With `Record`, you can put some constraints on the keys and values
    in `nextDay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you get a nice, helpful error message right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Adding the missing `Weekday`s to your object, of course, makes the error go
    away.
  prefs: []
  type: TYPE_NORMAL
- en: '`Record` gives you one extra degree of freedom compared to regular object index
    signatures: with a regular index signature you can constrain the types of an object’s
    values, but the key can only be a regular `string`, `number`, or `symbol`; with
    `Record`, you can also constrain the types of an object’s keys to subtypes of
    `string` and `number`.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapped Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript gives us a second, more powerful way to declare a safer `nextDay`
    type: mapped types. Let’s use mapped types to say that `nextDay` is an object
    with a key for each `Weekday`, whose value is a `Day`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another way to get a helpful hint for how to fix what you missed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Mapped types are a language feature unique to TypeScript. Like literal types,
    they’re a utility feature that just makes sense for the challenge that is statically
    typing JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw, mapped types have their own special syntax. And like index signatures,
    you can have at most one mapped type per object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name implies, it’s a way to map over an object’s key and value types.
    In fact, TypeScript uses mapped types to implement its built-in `Record` type
    we used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Mapped types give you more power than a mere `Record` because in addition to
    letting you give types to an object’s keys and values, when you combine them with
    keyed-in types, they let you put constraints on which value type corresponds to
    which key name.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly run through some of the things you can do with mapped types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new object type `OptionalAccount` by mapping over `Account`, marking
    each field as optional along the way.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new object type `NullableAccount` by mapping over `Account`, adding
    `null` as a possible value for each field along the way.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new object type `ReadonlyAccount` by taking `Account` and making
    each of its fields read-only (that is, readable but not writable).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_types_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We can mark fields as optional (`?`) or `readonly`, and we can also unmark them.
    With the minus (`–`) operator—a special type operator only available with mapped
    types—we can undo `?` and `readonly`, making fields required and writable again,
    respectively. Here we create a new object type `Account2`, equivalent to our `Account`
    type, by mapping over `ReadonlyAccount` and removing the `readonly` modifier with
    the minus (`–`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_types_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new object type `Account3`, equivalent to our original `Account`
    type, by mapping over `OptionalAccount` and removing the optional (`?`) operator
    with the minus (`–`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Minus (`–`) has a corresponding plus (`+`) type operator. You will probably
    never use this operator directly, because it’s implied: within a mapped type,
    `readonly` is equivalent to `+readonly`, and `?` is equivalent to `+?`. `+` is
    just there for completeness.'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in mapped types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mapped types we derived in the last section are so useful that TypeScript
    ships with many of them built in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Record<Keys, Values>`'
  prefs: []
  type: TYPE_NORMAL
- en: An object with keys of type `Keys` and values of type `Values`
  prefs: []
  type: TYPE_NORMAL
- en: '`Partial<Object>`'
  prefs: []
  type: TYPE_NORMAL
- en: Marks every field in `Object` as optional
  prefs: []
  type: TYPE_NORMAL
- en: '`Required<Object>`'
  prefs: []
  type: TYPE_NORMAL
- en: Marks every field in `Object` as nonoptional
  prefs: []
  type: TYPE_NORMAL
- en: '`Readonly<Object>`'
  prefs: []
  type: TYPE_NORMAL
- en: Marks every field in `Object` as read-only
  prefs: []
  type: TYPE_NORMAL
- en: '`Pick<Object, Keys>`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a subtype of `Object`, with just the given `Keys`
  prefs: []
  type: TYPE_NORMAL
- en: Companion Object Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The companion object pattern comes to us from [Scala](http://bit.ly/2I9Nqg2),
    and is a way to pair together objects and classes that share the same name. In
    TypeScript, there’s a similar pattern that’s similarly useful—we’ll also call
    it the companion object pattern—that we can use to pair together a type and an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that in TypeScript, types and values live in separate namespaces;
    you’ll read a little more about this in [“Declaration Merging”](ch10.html#namespace-merging).
    That means in the same scope, you can have the same name (in this example, `Currency`)
    bound to both a type and a value. With the companion object pattern, we exploit
    this separate namespacing to declare a name twice: first as a type, then as a
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern has a few nice properties. It lets you group type and value information
    that’s semantically part of a single name (like `Currency`) together. It also
    lets consumers import both at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Currency` as a type
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Currency` as a value
  prefs: []
  type: TYPE_NORMAL
- en: Use the companion object pattern when a type and an object are semantically
    related, with the object providing utility methods that operate on the type.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Function Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a look at a few more advanced techniques that are often used with
    function types.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Type Inference for Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you declare a tuple in TypeScript, TypeScript will be lenient about inferring
    that tuple’s type. It will infer the most general possible type based on what
    you gave it, ignoring the length of your tuple and which position holds which
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: But sometimes you want inference that’s stricter, that would treat `a` as a
    fixed-length tuple and not as an array. You could, of course, use a type assertion
    to cast your tuple to a tuple type (more on this in [“Type Assertions”](#type-assertions)).
    Or, you could use an `as const` assertion ([“The const type”](#const-types)) to
    infer the tuple’s type as narrowly as possible, marking it as read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you want to type your tuple as a tuple, but avoid a type assertion,
    and avoid the narrow inference and read-only modifier that `as const` gives you?
    To do that, you can take advantage of the way TypeScript infers types for rest
    parameters (jump back to [“Using bounded polymorphism to model arity”](ch04.html#modelling-arity)
    for more about that):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a `tuple` function that we’ll use to construct tuple types (instead
    of using the built-in `[]` syntax).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a single type parameter `T` that’s a subtype of `unknown[]` (meaning
    `T` is an array of any kind of type).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple` takes a variable number of parameters, `ts`. Because `T` describes
    a rest parameter, TypeScript will infer a tuple type for it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_types_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple` returns a value of the same tuple type that it inferred `ts` as.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_types_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Our function returns the same argument that we passed it. The magic is all in
    the types.
  prefs: []
  type: TYPE_NORMAL
- en: Take advantage of this technique in order to avoid type assertions when your
    code uses lots of tuple types.
  prefs: []
  type: TYPE_NORMAL
- en: User-Defined Type Guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For some kinds of `boolean`-returning functions, simply saying that your function
    returns a `boolean` may not be enough. For example, let’s write a function that
    tells you if you passed it a `string` or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So far so good. What happens if you try to use `isString` in some real-world
    code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What gives? If `typeof` works for regular type refinement (see [“Refinement”](#refinement)),
    why doesn’t it work here?
  prefs: []
  type: TYPE_NORMAL
- en: The thing about type refinement is it’s only powerful enough to refine the type
    of a variable in the scope you’re in. As soon as you leave that scope, the refinement
    doesn’t carry over to whatever new scope you’re in. In our `isString` implementation,
    we refined the input parameter’s type to `string` using `typeof`, but because
    type refinement doesn’t carry over to new scopes, it got lost—all TypeScript knows
    is that `isString` returned a `boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can do is tell the typechecker that not only does `isString` return
    a `boolean`, but whenever that `boolean` is `true`, the argument we passed to
    `isString` is a `string`. To do that, we use something called a *user-defined
    type guard*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Type guards are a built-in TypeScript feature, and are what lets you refine
    types with `typeof` and `instanceof`. But sometimes, you need the ability to declare
    type guards yourself—that’s what the `is` operator is for. When you have a function
    that refines its parameters’ types and returns a `boolean`, you can use a user-defined
    type guard to make sure that refinement is flowed whenever you use that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'User-defined type guards are limited to a single parameter, but they aren’t
    limited to simple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You won’t use user-defined type guards often, but when you do, they’re awesome
    for writing clean, reusable code. Without them, you’d have to inline all your
    `typeof` and `instanceof` type guards instead of building functions like `isLegacyDialog`
    and `isString` to perform those same checks in a better-encapsulated, more readable
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional types might be the single most unique feature in all of TypeScript.
    At a high level, conditional types let you say, “Declare a type `T` that depends
    on types `U` and `V`; if `U <: V`, then assign `T` to `A`, and otherwise, assign
    `T` to `B`.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In code it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break that down line by line.
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_advanced_types_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a new conditional type `IsString` that takes a generic type `T`.
    The “condition” part of this conditional type is `T extends string`; that is,
    “Is `T` a subtype of `string`?”
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If `T` is a subtype of `string`, we resolve to the type `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we resolve to the type `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the syntax looks just like a regular value-level ternary expression,
    but at the type level. And like regular ternary expressions, you can nest them
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional types aren’t limited to type aliases. You can use them almost anywhere
    you can use a type: in type aliases, interfaces, classes, parameter types, and
    generic defaults in functions and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributive Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you can express simple conditions like the examples we just looked at
    in a variety of ways in TypeScript—with conditional types, overloaded function
    signatures, and mapped types—conditional types let you do more. The reason for
    this is that they follow the *distributive law* (remember, from algebra class?).
    That means if you have a conditional type, then the expressions on the right are
    equivalent to those on the left in [Table 6-1](#dist-condition-table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Distributing conditional types
  prefs: []
  type: TYPE_NORMAL
- en: '| This… | Is equivalent to |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `string extends T ? A : B` | `string extends T ? A : B` |'
  prefs: []
  type: TYPE_TB
- en: '| `(string &#124; number) extends T ? A : B` | `(string extends T ? A : B)
    &#124; (number extends T ? A : B)` |'
  prefs: []
  type: TYPE_TB
- en: '| `(string &#124; number &#124; boolean) extends T ? A : B` | `(string extends
    T ? A : B) &#124; (number extends T ? A : B) &#124; (boolean extends T ? A : B)`
    |'
  prefs: []
  type: TYPE_TB
- en: I know, I know, you didn’t shell out for this book to learn about math—you’re
    here for the types. So let’s get more concrete. Let’s say we have a function that
    takes some variable of type `T`, and lifts it to an array of type `T[]`. What
    happens if we pass in a union type for `T`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty straightforward. Now what happens if we add a conditional type? (Note
    that the conditional doesn’t actually do anything here because both its branches
    resolve to the same type `T[]`; it’s just here to tell TypeScript to *distribute*
    `T` over the tuple type.) Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Did you catch that? When you use a conditional type, TypeScript will distribute
    union types over the conditional’s branches. It’s like taking the conditional
    type and mapping (er, *distributing*) it over each element in the union.
  prefs: []
  type: TYPE_NORMAL
- en: Why does any of this matter? Well, it lets you safely express a bunch of common
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, TypeScript comes with `&` for computing what two types have in
    common and `|` for taking a union of two types. Let’s build `Without<T, U>`, which
    computes the types that are in `T` but not in `U`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You use `Without` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s walk through how TypeScript computes this type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Distribute the condition over the union:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Substitute in `Without`’s definition and apply `T` and `U`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate the conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Simplify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If it wasn’t for the distributive property of conditional types, we would have
    ended up with `never` (if you’re not sure why, walk through what would happen
    for yourself!).
  prefs: []
  type: TYPE_NORMAL
- en: The infer Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final feature of conditional types is the ability to declare generic types
    as part of a condition. As a refresher, so far we’ve seen just one way to declare
    generic type parameters: using angle brackets (`<T>`). Conditional types have
    their own syntax for declaring generic types inline: the `infer` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s declare a conditional type `ElementType`, which gets the type of an array’s
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s rewrite it using `infer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this simple example `ElementType` is equivalent to `ElementType2`. Notice
    how the `infer` clause declares a new type variable, `U`—TypeScript will infer
    the type of `U` from context, based on what `T` you passed to `ElementType2`.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice why we declared `U` inline instead of declaring it up front, alongside
    `T`. What would have happened if we did declare it up front?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Uh-oh. Because `ElementUgly` defines two generic types, `T` and `U`, we have
    to pass both of them in when instantiating `ElementUgly`. But if we do that, that
    defeats the point of having an `ElementUgly` type in the first place; it puts
    the burden of computing `U` on the caller, when we wanted `ElementUgly` to compute
    the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Honestly, this was a bit of a silly example because we already have the keying-in
    operator (`[]`) to look up the type of an array’s elements. What about a more
    complicated example?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: So, `[].slice`’s second argument is a `number | undefined`. And we know this
    at compile time—try doing *that* in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Conditional Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditional types let you express some really powerful operations at the type
    level. That’s why TypeScript ships with a few globally available conditional types
    out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Exclude<T, U>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like our `Without` type from before, computes those types in `T` that are not
    in `U`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`Extract<T, U>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computes the types in `T` that you can assign to `U`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`NonNullable<T>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computes a version of `T` that excludes `null` and `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`ReturnType<F>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computes a function’s return type (note that this doesn’t work as you’d expect
    for generic and overloaded functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`InstanceType<C>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computes the instance type of a class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Escape Hatches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you don’t have time to type something perfectly, and you just want
    TypeScript to trust that what you’re doing is safe. Maybe a type declaration for
    a third party module you’re using is wrong and you want to test your code before
    contributing the fix back to DefinitelyTyped,^([4](ch06.html#idm46304963799608))
    or maybe you’re getting data from an API and you haven’t regenerated type declarations
    with Apollo yet.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, TypeScript knows that we’re only human, and gives us a few escape hatches
    for when we just want to do something and don’t have time to prove to TypeScript
    that it’s safe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In case it’s not obvious, you should use the following TypeScript features as
    little as possible. If you find yourself relying on them, you might be doing something
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Type Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have a type `B` and `A <: B <: C`, then you can assert to the typechecker
    that `B` is actually an `A` or a `C`. Notably, you can only assert that a type
    is a supertype or a subtype of itself—you can’t, for example, assert that a `number`
    is a `string`, because those types aren’t related.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript gives us two syntaxes for type assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a type assertion (`as`) to tell TypeScript that `input` is a `string`,
    not a `string | number` as the types would have us believe. You might do this,
    for example, if you want to quickly test out your `formatInput` function and you
    know for sure that `getUserInput` returns a `string` for your test.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The legacy syntax for type assertions uses angle brackets. The two syntaxes
    are functionally equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prefer `as` syntax for type assertions over angle bracket (`<>`) syntax. The
    former is unambiguous, but the latter can clash with TSX syntax (see [“TSX = JSX
    + TypeScript”](ch09.html#tsx-jsx-ts)). Use TSLint’s [`no-angle-bracket-type-assertion`](http://bit.ly/2WEGGKe)
    rule to automatically enforce this for your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, two types might not be sufficiently related, so you can’t assert
    that one is the other. To get around this, simply assert as `any` (remember from
    [“Assignability”](#assignability) that `any` is assignable to anything), then
    spend a few minutes in the corner thinking about what you’ve done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, type assertions are unsafe, and you should avoid using them when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Nonnull Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the special case of nullable types—that is, a type that’s `T | null` or
    `T | null | undefined`—TypeScript has special syntax for asserting that a value
    of that type is a `T`, and not `null` or `undefined`. This comes up in a few places.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we’ve written a framework for showing and hiding dialogs in
    a web app. Each dialog gets a unique ID, which we use to get a reference to the
    dialog’s DOM node. Once a dialog is removed from the DOM, we delete its ID, indicating
    that it’s no longer live in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If the dialog is already deleted (so it has no `id`), we return early.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We remove the dialog from the DOM on the next turn of the event loop, so that
    any other code that depends on `dialog` has a chance to finish running.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re inside the arrow function, we’re now in a new scope. TypeScript
    doesn’t know if some code mutated `dialog` between [![1](assets/1.png)](#co_advanced_types_CO10-1)
    and [![3](assets/3.png)](#co_advanced_types_CO10-3), so it invalidates the refinement
    we made in [![1](assets/1.png)](#co_advanced_types_CO10-1). On top of that, while
    we know that if `dialog.id` is defined then an element with that ID definitely
    exists in the DOM (because we designed our framework that way), all TypeScript
    knows is that calling `document.``getElementById` returns an `HTMLElement | null`.
    We know it’ll always be a nonnullable `HTMLElement`, but TypeScript doesn’t know
    that—it only knows about the types we gave it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_types_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, while we know that the dialog is definitely in the DOM and it definitely
    has a parent DOM node, all TypeScript knows is that the type of `element.``parentNode`
    is `Node | null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to fix this is to add a bunch of `if (_ === null)` checks everywhere.
    While that’s the right way to do it if you’re unsure if something is `null` or
    not, TypeScript comes with special syntax for when you’re sure it’s not `null
    | undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the sprinkling of non`null` assertion operators (`!`) that tell TypeScript
    that we’re sure `dialog.id`, the result of our `document.getElementById` call,
    and `element.parentNode` are defined. When a non`null` assertion follows a type
    that might be `null` or `undefined`, TypeScript will assume that the type is defined:
    `T | null | undefined` becomes a `T`, `number | string | null` becomes `number
    | string`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you find yourself using non`null` assertions a lot, it’s often a sign
    that you should refactor your code. For example, we could get rid of an assertion
    by splitting `Dialog` into a union of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then update `closeDialog` to take advantage of the union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'After we check that `dialog` has an `id` property defined—implying that it’s
    a `Visible``Dialog`—even inside the arrow function TypeScript knows that the reference
    to `dialog` hasn’t changed: the `dialog` inside the arrow function is the same
    `dialog` outside the function, so the refinement carries over instead of being
    invalidated like it was in the last example.'
  prefs: []
  type: TYPE_NORMAL
- en: Definite Assignment Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript has special syntax for the special case of non`null` assertions
    for definite assignment checks (as a reminder, a definite assignment check is
    TypeScript’s way of making sure that by the time you use a variable, that variable
    has been assigned a value). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, TypeScript just did us a great service by catching this error. We declared
    the variable `userId`, but forgot to assign a value to it before we tried to convert
    it to uppercase. This would have been a runtime error if TypeScript hadn’t noticed
    it!
  prefs: []
  type: TYPE_NORMAL
- en: But, what if our code looks more like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We happen to have the world’s greatest cache, and when we query this cache
    we get a cache hit 100% of of the time. So after the call to `fetchUser`, `userId`
    is guaranteed to be defined. But TypeScript isn’t able to statically detect that,
    so it still throws the same error as before. We can use a definite assignment
    assertion to tell TypeScript that `userId` will definitely be assigned by the
    time we read it (notice the exclamation mark):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As with type assertions and non`null` assertions, if you find yourself using
    definite assignment assertions often, you might be doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating Nominal Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point in the book, if I were to shake you awake at three in the morning
    and yell “IS TYPESCRIPT’S TYPE SYSTEM STRUCTURAL OR NOMINAL?!” you’d yell back
    “OF COURSE IT’S STRUCTURAL! NOW GET OUT OF MY HOUSE OR I’LL CALL THE POLICE!”
    That would be a fair response to me breaking in for early morning type system
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laws aside, the reality is that sometimes nominal types really are useful.
    For example, let’s say you have a few `ID` types in your application, representing
    unique ways of addressing the different types of objects in your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'A value of type `UserID` might be a simple hash that looks like `"d21b1dbf"`.
    So while you might alias it as `UserID`, under the hood it’s of course just a
    regular `string`. A function that takes a `UserID` might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This is great documentation, and it helps other engineers on your team know
    for sure which type of `ID` they should pass in. But since `UserID` is just an
    alias for `string`, this approach does little to prevent bugs. An engineer might
    accidentally pass in the wrong type of `ID`, and the types system will be none
    the wiser!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This is where *nominal types* come in handy.^([5](ch06.html#idm46304962931080))
    While TypeScript doesn’t support nominal types out of the box, we can simulate
    them with a technique called *type branding*. Type branding takes a little work
    to set up, and using it in TypeScript is not as smooth an experience as it is
    in languages that have built-in support for nominal type aliases. That said, branded
    types can make your program significantly safer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Depending on your application and the size of your engineering team (the larger
    your team, the more likely this technique will come in handy for preventing mistakes),
    you may not need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a synthetic *type brand* for each of your nominal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'An intersection of `string` and `{readonly brand: unique symbol}` is, of course,
    gibberish. I chose it because it’s impossible to naturally construct that type,
    and the only way to create a value of that type is with an assertion. That’s the
    crucial property of branded types: they make it hard to accidentally use a wrong
    type in their place. I used `unique symbol` as the “brand” because it’s one of
    two truly nominal kinds of types in TypeScript (the other is `enum`); I took an
    intersection of that brand with `string` so that we can assert that a given `string`
    is a given branded type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need a way to create values of type `CompanyID`, `OrderID`, and `UserID`.
    To do that, we’ll use the companion object pattern (introduced in [“Companion
    Object Pattern”](#companion-objects)). We’ll make a constructor for each branded
    type, using a type assertion to construct a value of each of our gibberish types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s see what it feels like to use these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s nice about this approach is how little runtime overhead it has: just
    one function call per `ID` construction, which will probably be inlined by your
    JavaScript VM anyway. At runtime, each `ID` is simply a `string`—the brand is
    purely a compile-time construct.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, for most applications this approach is overkill. But for large applications,
    and when working with easily confused types like different kinds of IDs, branded
    types can be a killer safety feature.
  prefs: []
  type: TYPE_NORMAL
- en: Safely Extending the Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building JavaScript applications, tradition holds that it’s unsafe to extend
    prototypes for built-in types. This rule of thumb goes back to before the days
    of jQuery, when wise JavaScript mages built libraries like [MooTools](https://mootools.net)
    that extended and overwrote built-in prototype methods directly. But when too
    many mages augmented prototypes at once, conflicts arose. And without static type
    systems, you’d only find out about these conflicts from angry users at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not coming from JavaScript, you may be surprised to learn that in
    JavaScript, you can modify any built-in method (like `[].push`, `'abc'.toUpperCase`,
    or `Object.assign`) at runtime. Because it’s such a dynamic language, JavaScript
    gives you direct access to prototypes for every built-in object—`Array.prototype`,
    `Function.prototype`, `Object.prototype`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: While back in the day extending these prototypes was unsafe, if your code is
    covered by a static type system like TypeScript, then you can now do it safely.^([6](ch06.html#idm46304962666696))
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we’ll add a `zip` method to the `Array` prototype. It takes two
    things to safely extend the prototype. First, in a *.ts* file (say, *zip.ts*),
    we extend the type of `Array`’s prototype; then, we augment the prototype with
    our new `zip` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_types_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start by telling TypeScript that we’re adding `zip` to `Array`. We take advantage
    of interface merging ([“Declaration Merging”](ch05.html#interface-merging)) to
    augment the global `Array<T>` interface, adding our own `zip` method to the already
    globally defined interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our file doesn’t have any explicit imports or exports—meaning it’s in
    script mode, as described in [“Module Mode Versus Script Mode”](ch10.html#module-mode)—we
    were able to augment the global `Array` interface directly by declaring an interface
    with the exact same name as the existing `Array<T>` interface, and letting TypeScript
    take care of merging the two for us. If our file were in module mode (which might
    be the case if, for example, we needed to `import` something for our `zip` implementation),
    we’d have to wrap our global extension in a `declare global` type declaration
    (see [“Type Declarations”](ch11.html#type-declarations)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`global` is a special namespace containing all the globally defined values
    (anything that you can use in a module-mode file without `import`ing it first;
    see [Chapter 10](ch10.html#modules)) that lets you augment names in the global
    scope from a file in module mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_types_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We then implement the `zip` method on `Array`’s prototype. We use a `this` type
    so that TypeScript correctly infers the `T` type of the array we’re calling `.zip`
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_types_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Because TypeScript infers the mapping function’s return type as `(T | U)[]`
    (TypeScript isn’t smart enough to realize that it’s in fact always a tuple with
    `T` in the zeroth index and `U` in the first), we use our `tuple` utility (from
    [“Improving Type Inference for Tuples”](#improving-type-inference-for-tuples))
    to create a tuple type without resorting to a type assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we declare `interface Array<T>` we augment the global `Array`
    namespace for our whole TypeScript project—meaning even if we don’t import *zip.ts*
    from our file, TypeScript will think that `[].zip` is available. But in order
    to augment `Array.prototype`, we have to be sure that whatever file uses `zip`
    loads *zip.ts* first, in order to install the `zip` method on `Array.prototype`.
    How do we make sure that any file that uses `zip` loads *zip.ts* first?
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy: we update our *tsconfig.json* to explicitly exclude *zip.ts* from our
    project, so that consumers have to explicitly `import` it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use `zip` as we please, with total safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this gives us the result of first mapping, then zipping the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we covered the most advanced features of TypeScript’s type
    system: from the ins and outs of variance to flow-based type inference, refinement,
    type widening, totality, and mapped and conditional types. We then derived a few
    advanced patterns for working with types: type branding to simulate nominal types,
    taking advantage of the distributive property of conditional types to operate
    on types at the type level, and safely extending prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: If you didn’t understand or don’t remember everything, that’s OK—come back to
    this chapter later, and use it as a reference when you’re struggling with how
    to express something more safely.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For each of the following pairs of types, decide if the first type is assignable
    to the second type, and why or why not. Think about these in terms of subtyping
    and variance, and refer to the rules at the start of the chapter if you’re unsure
    (if you’re still unsure, just type it into your code editor to check!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1` and `number`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`number` and `1`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`string` and `number | string`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`boolean` and `number`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`number[]` and `(number | string)[]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(number | string)[]` and `number[]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{a: true}` and `{a: boolean}`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{a: {b: [string]}}` and `{a: {b: [number | string]}}`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(a: number) => string` and `(b: number) => string`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(a: number) => string` and `(a: string) => string`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(a: number | string) => string` and `(a: string) => string`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`E.X` (defined in an enum `enum E {X = ''X''}`) and `F.X` (defined in an enum
    `enum F {X = ''X''}`)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have an object type `type O = {a: {b: {c: string}}}`, what’s the type
    of `keyof O`? What about `O[''a''][''b'']`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an `Exclusive<T, U>` type that computes the types that are in either `T`
    or `U`, but not both. For example, `Exclusive<1 | 2 | 3, 2 | 3 | 4>` should resolve
    to `1 | 4`. Write out step by step how the typechecker evaluates `Exclusive<1
    | 2, 2 | 4>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite the example (from [“Definite Assignment Assertions”](#definite-assignment-assertions))
    to avoid the definite assignment assertion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ^([1](ch06.html#idm46304967500104-marker)) Symbolic execution is a form of program
    analysis where you use a special program called a symbolic evaluator to run your
    program the same way a runtime would, but without assigning definite values to
    variables; instead, each variable is modelled as a *symbol* whose value gets constrained
    as the program runs. Symbolic execution lets you say things like “this variable
    is never used,” or “this function never returns,” or “in the positive branch of
    the `if` statement on line 102, variable `x` is guaranteed not to be `null`.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.html#idm46304967497288-marker)) Flow-based type inference is supported
    by a handful of languages, including TypeScript, Flow, Kotlin, and Ceylon. It’s
    a way to refine types within a block of code, and is an alternative to C/Java-style
    explicit type annotations and Haskell/OCaml/Scala-style pattern matching. The
    idea is to take a symbolic execution engine and embed it right in the typechecker,
    in order to give feedback to the typechecker and reason through a program in a
    way that is closer to how a human programmer might do it.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch06.html#idm46304967201672-marker)) JavaScript has seven falsy values:
    `null`, `undefined`, `NaN`, `0`, `-0`, `""`, and of course, `false`. Everything
    else is truthy.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch06.html#idm46304963799608-marker)) [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)
    is the open source repository for type declarations for third-party JavaScript.
    To learn more, jump ahead to [“JavaScript That Has Type Declarations on DefinitelyTyped”](ch11.html#third-party-js-with-dt-typings).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch06.html#idm46304962931080-marker)) In some languages, these are also
    called *opaque types*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch06.html#idm46304962666696-marker)) There are other reasons why you might
    want to avoid extending the prototype, like code portability, making your dependency
    graphs more explicit, or improving performance by only loading those methods that
    you actually use. However, safety is no longer one of those reasons.
  prefs: []
  type: TYPE_NORMAL
