<html><head></head><body><section class="praise" data-pdf-bookmark="Chapter 1. Getting to Know TypeScript" data-type="chapter" epub:type="chapter"><div class="praise" id="ch-intro">
<h1 class="calibre14"><span class="calibre">Chapter 1. </span>Getting to Know TypeScript</h1>


<p class="author1">Before we dive into the details, this chapter helps you understand the big picture of TypeScript. What is it and how should you think about it? How does it relate to JavaScript? Are its types nullable or are they not? What’s this about <code class="calibre18">any</code>? And ducks?</p>

<p class="author1">TypeScript<a data-primary="Java" data-secondary="versus TypeScript" data-type="indexterm" id="idm45331688898024" class="calibre9"/> is a bit unusual as a language in that it neither runs in an interpreter (as Python and Ruby do) nor<a data-primary="compiling" data-secondary="in TypeScript" data-secondary-sortas="TypeScript" data-type="indexterm" id="idm45331688896776" class="calibre9"/> compiles down to a lower-level language (as Java and C do). Instead, it compiles to another high-level language, JavaScript. It is this JavaScript that runs, not your TypeScript. So TypeScript’s relationship with JavaScript is essential, but it can also be a source of confusion. Understanding this relationship will help you be a more effective TypeScript developer.</p>

<p class="author1">TypeScript’s type system also has some unusual aspects that you should be aware of. Later chapters cover the type system in much greater detail, but this one will alert you to some of the surprises that it has in store.</p>






<section data-pdf-bookmark="Item 1: Understand the Relationship Between TypeScript and JavaScript" data-type="sect1" class="praise"><div class="praise" id="ts-vs-js">
<h1 class="calibre16">Item 1: Understand the Relationship Between TypeScript and JavaScript</h1>

<p class="author1">If<a data-primary="TypeScript" data-secondary="relationship to JavaScript" data-type="indexterm" id="TSjava01" class="calibre9"/><a data-primary="JavaScript" data-secondary="relationship to TypeScript" data-type="indexterm" id="JStype01" class="calibre9"/> you use TypeScript for long, you’ll inevitably hear the phrase “TypeScript is a superset of JavaScript” or “TypeScript is a typed superset of JavaScript.” But what does this mean, exactly? And what is the relationship between TypeScript and JavaScript? Since these languages are so closely linked, a strong understanding of how they relate to each is the foundation for using TypeScript well.</p>

<p class="author1">TypeScript is a superset of JavaScript in a syntactic sense: so long as your JavaScript program doesn’t have any syntax errors then it is also a TypeScript program. It’s quite likely that TypeScript’s type checker will flag some issues with your code. But this is an independent problem. TypeScript will still parse your code and emit JavaScript. (This is another key part of the relationship. We’ll explore this more in <a href="#independent" class="calibre9">Item 3</a>.)</p>

<p class="author1">TypeScript<a data-primary=".ts/.tsx extension" data-type="indexterm" id="idm45331688886040" class="calibre9"/><a data-primary=".js/.jsx extension" data-type="indexterm" id="idm45331688885304" class="calibre9"/> files use a <em class="calibre3">.ts</em> (or <em class="calibre3">.tsx</em>) extension, rather than the <em class="calibre3">.js</em> (or <em class="calibre3">.jsx</em>) extension of a JavaScript file. This doesn’t mean that TypeScript is a completely different language! Since TypeScript is a superset of JavaScript, the code in your <em class="calibre3">.js</em> files is already TypeScript. Renaming <em class="calibre3">main.js</em> to <em class="calibre3">main.ts</em> doesn’t change that.</p>

<p class="author1">This<a data-primary="JavaScript" data-secondary="migrating to TypeScript" data-type="indexterm" id="idm45331688880984" class="calibre9"/><a data-primary="TypeScript" data-secondary="migrating to" data-type="indexterm" id="idm45331688879976" class="calibre9"/> is enormously helpful if you’re migrating an existing JavaScript codebase to TypeScript. It means that you don’t have to rewrite any of your code in another language to start using TypeScript and get the benefits it provides. This<a data-primary="Java" data-secondary="rewriting code in" data-type="indexterm" id="idm45331688878648" class="calibre9"/> would not be true if you chose to rewrite your JavaScript in a language like Java. This gentle migration path is one of the best features of TypeScript. There will be much more to say about this topic in <a data-type="xref" href="ch08.html#ch-migrate" class="calibre9">Chapter 8</a>.</p>

<p class="author1">All JavaScript programs are TypeScript programs, but the converse is not true: there are TypeScript programs which are not JavaScript programs. This is because TypeScript adds additional syntax for specifying types. (There are some other bits of syntax it adds, largely for historical reasons. See <a href="ch07.html#avoid-non-ecma" class="calibre9">Item 53</a>.)</p>

<p class="author1">For instance, this is a valid TypeScript program:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">greet</code><code class="p">(</code><code class="nx">who</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Hello'</code><code class="p">,</code> <code class="nx">who</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">But when you run this through a program like <code class="calibre18">node</code> that expects JavaScript, you’ll get an error:</p>

<pre data-type="programlisting" class="calibre17">function greet(who: string) {
                  ^

SyntaxError: Unexpected token :</pre>

<p class="author1">The <code class="calibre18">: string</code> is a type annotation that is specific to TypeScript. Once you use one, you’ve gone beyond plain JavaScript (see <a data-type="xref" href="#ts-vs-js-venn" class="calibre9">Figure 1-1</a>).</p>

<figure class="calibre28"><div class="figure" id="ts-vs-js-venn">
<h6 class="calibre29"><span class="calibre">Figure 1-1. </span>All JavaScript is TypeScript, but not all TypeScript is JavaScript</h6>
</div></figure>

<p class="author1">This is not to say that TypeScript doesn’t provide value for plain JavaScript programs. It does! For example, this JavaScript program:</p>

<pre data-code-language="js" data-type="programlisting" id="toupper-js" class="calibre17"><code class="kd">let</code> <code class="nx">city</code> <code class="o">=</code> <code class="s">'new york city'</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">city</code><code class="p">.</code><code class="nx">toUppercase</code><code class="p">());</code></pre>

<p class="author1">will throw an error when you run it:</p>

<pre data-type="programlisting" id="toupper-js-output" class="calibre17">TypeError: city.toUppercase is not a function</pre>

<p class="author1">There are no type annotations in this program, but TypeScript’s type checker is still able to spot the problem:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">city</code> <code class="o">=</code> <code class="s">'new york city'</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">city</code><code class="p">.</code><code class="nx">toUppercase</code><code class="p">());</code>
              <code class="c">// ~~~~~~~~~~~ Property 'toUppercase' does not exist on type</code>
              <code class="c">//             'string'. Did you mean 'toUpperCase'?</code></pre>

<p class="author1">You didn’t have to tell TypeScript that the type of <code class="calibre18">city</code> was <code class="calibre18">string</code>: it inferred it from the initial value. Type inference is a key part of TypeScript and <a data-type="xref" href="ch03.html#ch-inference" class="calibre9">Chapter 3</a> explores how to use it well.</p>

<p class="author1">One of the goals of TypeScript’s type system is to detect code that will throw an exception at runtime, without having to run your code. When you hear TypeScript described as a “static” type system, this is what it refers to. The type checker cannot always spot code that will throw exceptions, but it will try.</p>

<p class="author1">Even if your code doesn’t throw an exception, it still might not do what you intend. TypeScript tries to catch some of these issues, too. For example, this JavaScript <span class="calibre">program:</span></p>

<pre data-code-language="js" data-type="programlisting" id="capitol-js" class="calibre17"><code class="kd">const</code> <code class="nx">states</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
  <code class="c">// ...</code>
<code class="p">];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="kd">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capitol</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">will log:</p>

<pre data-type="programlisting" id="capitol-js-output" class="calibre17">undefined
undefined
undefined</pre>

<p class="author1">Whoops! What went wrong? This program is valid JavaScript (and hence TypeScript). And it ran without throwing any errors. But it clearly didn’t do what you intended. Even without adding type annotations, TypeScript’s type checker is able to spot the error (and offer a helpful suggestion):</p>

<pre data-code-language="ts" data-type="programlisting" id="capitol-ts" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="nx">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capitol</code><code class="p">);</code>
                 <code class="c">// ~~~~~~~ Property 'capitol' does not exist on type</code>
                 <code class="c">//         '{ name: string; capital: string; }'.</code>
                 <code class="c">//         Did you mean 'capital'?</code>
<code class="p">}</code></pre>

<p class="author1">While TypeScript can catch errors even if you don’t provide type annotations, it’s able to do a much more thorough job if you do. This is because type annotations tell TypeScript what your <em class="calibre3">intent</em> is, and this lets it spot places where your code’s behavior does not match your intent. For example, what if you’d reversed the <code class="calibre18">capital</code>/<code class="calibre18">capitol</code> spelling mistake in the previous example?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">states</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
  <code class="c">// ...</code>
<code class="p">];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="nx">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capital</code><code class="p">);</code>
                 <code class="c">// ~~~~~~~ Property 'capital' does not exist on type</code>
                 <code class="c">//         '{ name: string; capitol: string; }'.</code>
                 <code class="c">//         Did you mean 'capitol'?</code>
<code class="p">}</code></pre>

<p class="author1">The error that was so helpful before now gets it exactly wrong! The problem is that you’ve spelled the same property two different ways, and TypeScript doesn’t know which one is right. It can guess, but it may not always be correct. The solution is to clarify your intent by explicitly declaring the type of <code class="calibre18">states</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">states</code>: <code class="nx">State</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~~~~~</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known</code>
                 <code class="c">//         properties, but 'capitol' does not exist in type</code>
                 <code class="c">//         'State'.  Did you mean to write 'capital'?</code>
  <code class="c">// ...</code>
<code class="p">];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="nx">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capital</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">Now the errors match the problem and the suggested fix is correct. By spelling out our intent, you’ve also helped TypeScript spot other potential problems. For instance, had you only misspelled <code class="calibre18">capitol</code> once in the array, there wouldn’t have been an error before. But with the type annotation, there is:</p>

<pre data-code-language="ts" data-type="programlisting" id="capitol-one" class="calibre17"><code class="kd">const</code> <code class="nx">states</code>: <code class="nx">State</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~ Did you mean to write 'capital'?</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
  <code class="c">// ...</code>
<code class="p">];</code></pre>

<p class="author1">In terms of the Venn diagram, we can add in a new group of programs: TypeScript programs which pass the type checker (see <a data-type="xref" href="#ts-js-typecheck-venn" class="calibre9">Figure 1-2</a>).</p>

<figure class="calibre28"><div class="figure" id="ts-js-typecheck-venn">
<img alt="efts 0102" src="assets/efts_0102.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 1-2. </span>All JavaScript programs are TypeScript programs. But only some JavaScript (and TypeScript) programs pass the type checker.</h6>
</div></figure>

<p class="author1">If the statement that “TypeScript is a superset of JavaScript” feels wrong to you, it may be because you’re thinking of this third set of programs in the diagram. In practice, this is the most relevant one to the day-to-day experience of using TypeScript. Generally when you use TypeScript, you try to keep your code passing all the type checks.</p>

<p class="author1">TypeScript’s type system <em class="calibre3">models</em> the runtime behavior of JavaScript. This may result in some surprises if you’re coming from a language with stricter runtime checks. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">+</code> <code class="s">'3'</code><code class="p">;</code>  <code class="c">// OK, type is string</code>
<code class="kd">const</code> <code class="nx">y</code> <code class="o">=</code> <code class="s">'2'</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code>  <code class="c">// OK, type is string</code></pre>

<p class="author1">These statements both pass the type checker, even though they are questionable and do produce runtime errors in many other languages. But this does model the runtime behavior of JavaScript, where both expressions result in the string <code class="calibre18">"23"</code>.</p>

<p class="author1">TypeScript does draw the line somewhere, though. The type checker flags issues in all of these statements, even though they do not throw exceptions at runtime:</p>

<pre data-code-language="ts" data-type="programlisting" id="null-arithmetic" class="calibre17"><code class="kd">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="kd">null</code> <code class="o">+</code> <code class="mi">7</code><code class="p">;</code>  <code class="c">// Evaluates to 7 in JS</code>
       <code class="c">// ~~~~ Operator '+' cannot be applied to types ...</code>
<code class="kd">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[]</code> <code class="o">+</code> <code class="mi">12</code><code class="p">;</code>  <code class="c">// Evaluates to '12' in JS</code>
       <code class="c">// ~~~~~~~ Operator '+' cannot be applied to types ...</code>
<code class="nx">alert</code><code class="p">(</code><code class="s">'Hello'</code><code class="p">,</code> <code class="s">'TypeScript'</code><code class="p">);</code>  <code class="c">// alerts "Hello"</code>
            <code class="c">// ~~~~~~~~~~~~ Expected 0-1 arguments, but got 2</code></pre>

<p class="author1">The guiding principle of TypeScript’s type system is that it should model JavaScript’s runtime behavior. But in all of these cases, TypeScript considers it more likely that the odd usage is the result of an error than the developer’s intent, so it goes beyond simply modeling the runtime behavior. We saw another example of this in the <code class="calibre18">capital</code>/<code class="calibre18">capitol</code> example, where the program didn’t throw (it logged <code class="calibre18">undefined</code>) but the type checker still flagged an error.</p>

<p class="author1">How does TypeScript decide when to model JavaScript’s runtime behavior and when to go beyond it? Ultimately this is a matter of taste. By adopting TypeScript you’re trusting the judgment of the team that builds it. If you enjoy adding <code class="calibre18">null</code> and <code class="calibre18">7</code> or <code class="calibre18">[]</code> and <code class="calibre18">12</code>, or calling functions with superfluous arguments, then TypeScript might not be for you!</p>

<p class="author1">If your program type checks, could it still throw an error at runtime? The answer is “yes.” Here’s an example:</p>

<pre data-code-language="ts" data-type="programlisting" id="typecheck-but-throw-no-any" class="calibre17"><code class="kd">const</code> <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Alice'</code><code class="p">,</code> <code class="s">'Bob'</code><code class="p">];</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">names</code><code class="p">[</code><code class="mi">2</code><code class="p">].</code><code class="nx">toUpperCase</code><code class="p">());</code></pre>

<p class="author1">When you run this, it throws:</p>

<pre data-type="programlisting" id="typecheck-but-throw-no-any-output" class="calibre17">TypeError: Cannot read property 'toUpperCase' of undefined</pre>

<p class="author1">TypeScript assumed the array access would be within bounds, but it was not. The result was an exception.</p>

<p class="author1">Uncaught errors also frequently come up when you use the <code class="calibre18">any</code> type, which we’ll discuss in <a href="#any" class="calibre9">Item 5</a> and in more detail in <a data-type="xref" href="ch05.html#ch-any" class="calibre9">Chapter 5</a>.</p>

<p class="author1">The root cause of these exceptions is that TypeScript’s understanding of a value’s type and reality have diverged. A type system which can guarantee the accuracy of its static types is said to be <em class="calibre3">sound</em>. TypeScript’s type system is very much not sound, nor was it ever intended to be. If soundness is important to you, you may want to look at other languages like Reason or Elm. While these do offer more guarantees of runtime safety, this comes at a cost: neither is a superset of JavaScript, so migration will be more complicated.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331686762648">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">TypeScript is a superset of JavaScript. In other words, all JavaScript programs are already TypeScript programs. TypeScript has some syntax of its own, so TypeScript programs are not, in general, valid JavaScript programs.</p>
</li>
<li class="calibre12">
<p class="author1">TypeScript adds a type system that models JavaScript’s runtime behavior and tries to spot code which will throw exceptions at runtime. But you shouldn’t expect it to flag every exception. It is possible for code to pass the type checker but still throw at runtime.</p>
</li>
<li class="calibre12">
<p class="author1">While TypeScript’s type system largely models JavaScript behavior, there are some constructs that JavaScript allows but TypeScript chooses to bar, such as calling functions with the wrong number of arguments. This is largely a matter of taste.<a data-primary="" data-startref="TSjava01" data-type="indexterm" id="idm45331686757896" class="calibre9"/><a data-primary="" data-startref="JStype01" data-type="indexterm" id="idm45331686756920" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 2: Know Which TypeScript Options You’re Using" data-type="sect1" class="praise"><div class="praise" id="which-ts">
<h1 class="calibre16">Item 2: Know Which TypeScript Options You’re Using</h1>

<p class="author1">Does<a data-primary="TypeScript" data-secondary="configuration settings" data-type="indexterm" id="TSconfig01" class="calibre9"/><a data-primary="configuration settings" data-type="indexterm" id="config01" class="calibre9"/><a data-primary="tsconfig.json" data-secondary="knowing which options you’re using" data-type="indexterm" id="tsconfig01" class="calibre9"/><a data-primary="noImplicitAny" data-type="indexterm" id="noimp01" class="calibre9"/><a data-primary="strictNullChecks" data-type="indexterm" id="strict01" class="calibre9"/> this code pass the type checker?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">add</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="kd">null</code><code class="p">);</code></pre>

<p class="author1">Without knowing which options you’re using, it’s impossible to say! The TypeScript compiler has an enormous set of these, nearly 100 at the time of this writing.</p>

<p class="author1">They can be set via the command line:</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">tsc --noImplicitAny program.ts</strong></pre>

<p class="author1">or via a configuration file, <em class="calibre3">tsconfig.json</em>:</p>

<pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"noImplicitAny"</code><code class="p">:</code> <code class="kd">true</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">You should prefer the configuration file. It ensures that your coworkers and tools all know exactly how you plan to use TypeScript. You can create one by running <code class="calibre18">tsc --init</code>.</p>

<p class="author1">Many of TypeScript’s configuration settings control where it looks for source files and what sort of output it generates. But a few control core aspects of the language itself. These are high-level design choices that most languages do not leave to their users. TypeScript can feel like a very different language depending on how it is configured. To use it effectively, you should understand the most important of these settings: <span class="calibre"><code class="calibre18">noImplicitAny</code></span> and <code class="calibre18">strictNullChecks</code>.</p>

<p class="author1"><code class="calibre18">noImplicitAny</code> controls whether variables must have known types. This code is valid when <code class="calibre18">noImplicitAny</code> is off:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">If you mouse over the <code class="calibre18">add</code> symbol in your editor, it will reveal what TypeScript has inferred about the type of that function:</p>

<pre data-type="programlisting" class="calibre17">function add(a: any, b: any): any</pre>

<p class="author1">The <code class="calibre18">any</code> types effectively disable the type checker for code involving these parameters. <code class="calibre18">any</code> is a useful tool, but it should be used with caution. For much more on <code class="calibre18">any</code>, see <a href="#any" class="calibre9">Item 5</a> and <a data-type="xref" href="ch03.html#ch-inference" class="calibre9">Chapter 3</a>.</p>

<p class="author1">These<a data-primary="implicit anys" data-type="indexterm" id="idm45331687702808" class="calibre9"/> are called <em class="calibre3">implicit <code class="calibre23">any</code>s</em> because you never wrote the word “any” but still wound up with dangerous <code class="calibre18">any</code> types. This becomes an error if you set the <code class="calibre18">noImplicitAny</code> option:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
          <code class="c">// ~    Parameter 'a' implicitly has an 'any' type</code>
          <code class="c">//    ~ Parameter 'b' implicitly has an 'any' type</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">These errors can be fixed by explicitly writing type declarations, either <code class="calibre18">: any</code> or a more specific type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript is the most helpful when it has type information, so you should be sure to set <code class="calibre18">noImplicitAny</code> whenever possible. Once you grow accustomed to all variables having types, TypeScript without <code class="calibre18">noImplicitAny</code> feels almost like a different <span class="calibre">language.</span></p>

<p class="author1">For new projects, you should start with <code class="calibre18">noImplicitAny</code> on, so that you write the types as you write your code. This will help TypeScript spot problems, improve the readability of your code, and enhance your development experience (see <a href="ch02_split_000.html#editor" class="calibre9">Item 6</a>). Leaving <code class="calibre18">noImplicitAny</code> off is only appropriate if you’re transitioning a project from JavaScript to TypeScript (see <a data-type="xref" href="ch08.html#ch-migrate" class="calibre9">Chapter 8</a>).</p>

<p class="author1"><code class="calibre18">strictNullChecks</code> controls whether <code class="calibre18">null</code> and <code class="calibre18">undefined</code> are permissible values in every type.</p>

<p class="author1">This code is valid when <code class="calibre18">strictNullChecks</code> is off:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>  <code class="c">// OK, null is a valid number</code></pre>

<p class="author1">but triggers an error when you turn <code class="calibre18">strictNullChecks</code> on:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>
<code class="c">//    ~ Type 'null' is not assignable to type 'number'</code></pre>

<p class="author1">A similar error would have occurred had you used <code class="calibre18">undefined</code> instead of <code class="calibre18">null</code>.</p>

<p class="author1">If you mean to allow <code class="calibre18">null</code>, you can fix the error by making your intent explicit:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code></pre>

<p class="author1">If you do not wish to permit <code class="calibre18">null</code>, you’ll need to track down where it came from and add either a check or an assertion:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17">   <code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'status'</code><code class="p">);</code>
   <code class="nx">el</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Ready'</code><code class="p">;</code>
<code class="c">// ~~ Object is possibly 'null'</code>

   <code class="kd">if</code> <code class="p">(</code><code class="nx">el</code><code class="p">)</code> <code class="p">{</code>
     <code class="nx">el</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Ready'</code><code class="p">;</code>  <code class="c">// OK, null has been excluded</code>
   <code class="p">}</code>
   <code class="nx">el</code><code class="o">!</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Ready'</code><code class="p">;</code>  <code class="c">// OK, we've asserted that el is non-null</code></pre>

<p class="author1"><code class="calibre18">strictNullChecks</code> is tremendously helpful for catching errors involving <code class="calibre18">null</code> and <code class="calibre18">undefined</code> values, but it does increase the difficulty of using the language. If you’re starting a new project, try setting <code class="calibre18">strictNullChecks</code>. But if you’re new to the language or migrating a JavaScript codebase, you may elect to leave it off. You should certainly set <code class="calibre18">noImplicitAny</code> before you set <code class="calibre18">strictNullChecks</code>.</p>

<p class="author1">If you choose to work without <code class="calibre18">strictNullChecks</code>, keep an eye out for the dreaded “undefined is not an object” runtime error. Every one of these is a reminder that you should consider enabling stricter checking. Changing this setting will only get harder as your project grows, so try not to wait too long before enabling it.</p>

<p class="author1">There<a data-primary="noImplicitThis" data-type="indexterm" id="idm45331679804104" class="calibre9"/> are many other settings that affect language semantics (e.g., <code class="calibre18">noImplicitThis</code> and <code class="calibre18">strictFunctionTypes</code>), but these are minor compared to <code class="calibre18">noImplicitAny</code> and <code class="calibre18">strictNullChecks</code>. To enable all of these checks, turn on the <code class="calibre18">strict</code> setting. TypeScript is able to catch the most errors with <code class="calibre18">strict</code>, so this is where you eventually want to wind up.</p>

<p class="author1">Know<a data-primary="compiling" data-secondary="compiler options" data-type="indexterm" id="idm45331679800296" class="calibre9"/> which options you’re using! If a coworker shares a TypeScript example and you’re unable to reproduce their errors, make sure your compiler options are the same.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331679798856">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">The TypeScript compiler includes several settings which affect core aspects of the language.</p>
</li>
<li class="calibre12">
<p class="author1">Configure TypeScript using <em class="calibre3">tsconfig.json</em> rather than command-line options.</p>
</li>
<li class="calibre12">
<p class="author1">Turn on <code class="calibre18">noImplicitAny</code> unless you are transitioning a JavaScript project to <span class="calibre">TypeScript.</span></p>
</li>
<li class="calibre12">
<p class="author1">Use <code class="calibre18">strictNullChecks</code> to prevent “undefined is not an object”-style runtime errors.</p>
</li>
<li class="calibre12">
<p class="author1">Aim to enable <code class="calibre18">strict</code> to get the most thorough checking that TypeScript can offer.<a data-primary="" data-startref="strict01" data-type="indexterm" id="idm45331679790472" class="calibre9"/><a data-primary="" data-startref="noimp01" data-type="indexterm" id="idm45331679789496" class="calibre9"/><a data-primary="" data-startref="config01" data-type="indexterm" id="idm45331679788552" class="calibre9"/><a data-primary="" data-startref="TSconfig01" data-type="indexterm" id="idm45331679787608" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 3: Understand That Code Generation Is Independent of Types" data-type="sect1" class="praise"><div class="praise" id="independent">
<h1 class="calibre16">Item 3: Understand That Code Generation Is Independent of Types</h1>

<p class="author1">At<a data-primary="TypeScript compiler (tsc)" data-secondary="functions of" data-type="indexterm" id="idm45331679784808" class="calibre9"/><a data-primary="code generation, independent of types" data-type="indexterm" id="DGtype01" class="calibre9"/><a data-primary="transpiling" data-seealso="compiling" data-type="indexterm" id="idm45331679782776" class="calibre9"/> a high level, <code class="calibre18">tsc</code> (the TypeScript compiler) does two things:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">It converts next-generation TypeScript/JavaScript to an older version of JavaScript that works in browsers (“transpiling”).</p>
</li>
<li class="calibre12">
<p class="author1">It checks your code for type errors.</p>
</li>
</ul>

<p class="author1">What’s surprising is that these two behaviors are entirely independent of one another. Put another way, the types in your code cannot affect the JavaScript that TypeScript emits. Since it’s this JavaScript that gets executed, this means that your types can’t affect the way your code runs.</p>

<p class="author1">This has some surprising implications and should inform your expectations about what TypeScript can and cannot do for you.</p>








<section class="praise" data-pdf-bookmark="Code with Type Errors Can Produce Output" data-type="sect2"><div class="praise" id="idm45331679777560">
<h2 class="calibre31">Code with Type Errors Can Produce Output</h2>

<p class="author1">Because<a data-primary="compiling" data-secondary="compiling versus type checking" data-type="indexterm" id="CCcheck01" class="calibre9"/><a data-primary="TypeScript compiler (tsc)" data-secondary="code generation and type checking" data-type="indexterm" id="TSCcode01" class="calibre9"/> code output is independent of type checking, it follows that code with type errors can produce output!</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">cat test.ts</strong>
let x = 'hello';
x = 1234;
$ <strong class="calibre32">tsc test.ts</strong>
test.ts:2:1 - error TS2322: Type '1234' is not assignable to type 'string'

2 x = 1234;
  ~

$ <strong class="calibre32">cat test.js</strong>
var x = 'hello';
x = 1234;</pre>

<p class="author1">This can be quite surprising if you’re coming from a language like C or<a data-primary="Java" data-secondary="type checking and output in" data-type="indexterm" id="idm45331679770408" class="calibre9"/> Java where type checking and output go hand in hand. You can think of all TypeScript errors as being similar to warnings in those languages: it’s likely that they indicate a problem and are worth investigating, but they won’t stop the build.</p>
<aside class="less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45331679768856">
<h5 class="calibre33">Compiling and Type Checking</h5>
<p class="author1">This is likely the source of some sloppy language that is common around TypeScript. You’ll often hear people say that their TypeScript “doesn’t compile” as a way of saying that it has errors. But this isn’t technically correct! Only the code generation is “compiling.” So long as your TypeScript is valid JavaScript (and often even if it isn’t), the TypeScript compiler will produce output. It’s better to say that your code has errors, or that it “doesn’t type check.”</p>
</div></aside>

<p class="author1">Code emission in the presence of errors is helpful in practice. If you’re building a web application, you may know that there are problems with a particular part of it. But because TypeScript will still generate code in the presence of errors, you can test the other parts of your application before you fix them.</p>

<p class="author1">You should aim for zero errors when you commit code, lest you fall into the trap of having to remember what is an expected or unexpected error. If you want to disable output on errors, you can use the <code class="calibre18">noEmitOnError</code> option in <em class="calibre3">tsconfig.json</em>, or the equivalent in your build tool.<a data-primary="" data-startref="tsconfig01" data-type="indexterm" id="idm45331679736280" class="calibre9"/></p>
</div></section>













<section class="praise" data-pdf-bookmark="You Cannot Check TypeScript Types at Runtime" data-type="sect2"><div class="praise" id="idm45331679735304">
<h2 class="calibre31">You Cannot Check TypeScript Types at Runtime</h2>

<p class="author1">You<a data-primary="runtime" data-secondary="inability to check TypeScript at" data-type="indexterm" id="idm45331679733496" class="calibre9"/> may be tempted to write code like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Rectangle</code> <code class="kd">extends</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Rectangle</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c">// ~~~~~~~~~ 'Rectangle' only refers to a type,</code>
                    <code class="c">//           but is being used as a value here</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
                    <code class="c">//         ~~~~~~ Property 'height' does not exist</code>
                    <code class="c">//                on type 'Shape'</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">instanceof</code> check happens at runtime, but <code class="calibre18">Rectangle</code> is a type and so it cannot affect the runtime behavior of the code. TypeScript types are “erasable”: part of compilation to JavaScript is simply removing all the <code class="calibre18">interface</code>s, <code class="calibre18">type</code>s, and type annotations from your code.</p>

<p class="author1">To ascertain the type of shape you’re dealing with, you’ll need some way to reconstruct its type at runtime. In this case you can check for the presence of a <code class="calibre18">height</code> property:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="s">'height'</code> <code class="kd">in</code> <code class="nx">shape</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Rectangle</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Square</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">This works because the property check only involves values available at runtime, but still allows the type checker to refine <code class="calibre18">shape</code>’s type to <code class="calibre18">Rectangle</code>.</p>

<p class="author1">Another way would have been to introduce a “tag” to explicitly store the type in a way that’s available at runtime:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="nx">kind</code><code class="o">:</code> <code class="s">'square'</code><code class="p">;</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Rectangle</code> <code class="p">{</code>
  <code class="nx">kind</code><code class="o">:</code> <code class="s">'rectangle'</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code> <code class="o">===</code> <code class="s">'rectangle'</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Rectangle</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Square</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The<a data-primary="tagged unions" data-secondary="example of" data-type="indexterm" id="idm45331679634024" class="calibre9"/> <code class="calibre18">Shape</code> type here is an example of a “tagged union.” Because they make it so easy to recover type information at runtime, tagged unions are ubiquitous in TypeScript.</p>

<p class="author1">Some constructs introduce both a type (which is not available at runtime) and a value (which is). The <code class="calibre18">class</code> keyword is one of these. Making <code class="calibre18">Square</code> and <code class="calibre18">Rectangle</code> classes would have been another way to fix the error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">width</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{}</code>
<code class="p">}</code>
<code class="kd">class</code> <code class="nx">Rectangle</code> <code class="kd">extends</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">width</code>: <code class="nx">number</code><code class="p">,</code> <code class="kd">public</code> <code class="nx">height</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">super</code><code class="p">(</code><code class="nx">width</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Rectangle</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Rectangle</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Square</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>  <code class="c">// OK</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">This works because <code class="calibre18">class Rectangle</code> introduces both a type and a value, whereas <code class="calibre18">interface</code> only introduced a type.</p>

<p class="author1">The <code class="calibre18">Rectangle</code> in <code class="calibre18">type Shape = Square | Rectangle</code> refers to the <em class="calibre3">type</em>, but the <code class="calibre18">Rectangle</code> in <code class="calibre18">shape instanceof Rectangle</code> refers to the <em class="calibre3">value</em>. This distinction is important to understand but can be quite subtle. See <a href="ch02_split_000.html#type-value-space" class="calibre9">Item 8</a>.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Type Operations Cannot Affect Runtime Values" data-type="sect2"><div class="praise" id="idm45331679734712">
<h2 class="calibre31">Type Operations Cannot Affect Runtime Values</h2>

<p class="author1">Suppose<a data-primary="runtime" data-secondary="type operations and runtime values" data-type="indexterm" id="idm45331679302232" class="calibre9"/> you have a value that could be a string or a number and you’d like to normalize it so that it’s always a number. Here’s a misguided attempt that the type checker accepts:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">asNumber</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">val</code> <code class="kd">as</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Looking at the generated JavaScript makes it clear what this function really does:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">asNumber</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">There is no conversion going on whatsoever. The <code class="calibre18">as number</code> is a type operation, so it cannot affect the runtime behavior of your code. To normalize the value you’ll need to check its runtime type and do the conversion using JavaScript constructs:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">asNumber</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">typeof</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="o">===</code> <code class="s">'string'</code> <code class="o">?</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="o">:</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">(<code class="calibre18">as number</code> is<a data-primary="type assertion" data-secondary="example of" data-type="indexterm" id="idm45331679152504" class="calibre9"/> a <em class="calibre3">type assertion</em>. For more on when it’s appropriate to use these, see <a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>.)</p>
</div></section>













<section class="praise" data-pdf-bookmark="Runtime Types May Not Be the Same as Declared Types" data-type="sect2"><div class="praise" id="idm45331679150264">
<h2 class="calibre31">Runtime Types May Not Be the Same as Declared Types</h2>

<p class="author1">Could<a data-primary="runtime" data-secondary="runtime types versus declared types" data-type="indexterm" id="idm45331679148264" class="calibre9"/> this function ever hit the final <code class="calibre18">console.log</code>?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">setLightSwitch</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">switch</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">case</code> <code class="kd">true</code><code class="o">:</code>
      <code class="nx">turnLightOn</code><code class="p">();</code>
      <code class="kd">break</code><code class="p">;</code>
    <code class="kd">case</code> <code class="kd">false</code><code class="o">:</code>
      <code class="nx">turnLightOff</code><code class="p">();</code>
      <code class="kd">break</code><code class="p">;</code>
    <code class="kd">default</code><code class="o">:</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`I'm afraid I can't do that.`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript usually flags dead code, but it does not complain about this, even with the <code class="calibre18">strict</code> option. How could you hit this branch?</p>

<p class="author1">The<a data-primary="declared types" data-type="indexterm" id="idm45331679074168" class="calibre9"/> key is to remember that <code class="calibre18">boolean</code> is the <em class="calibre3">declared</em> type. Because it is a TypeScript type, it goes away at runtime. In JavaScript code, a user might inadvertently call <code class="calibre18">setLightSwitch</code> with a value like <code class="calibre18">"ON"</code>.</p>

<p class="author1">There are ways to trigger this code path in pure TypeScript, too. Perhaps the function is called with a value which comes from a network call:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">LightApiResponse</code> <code class="p">{</code>
  <code class="nx">lightSwitchValue</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">setLight() {</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">'/light'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">result</code>: <code class="nx">LightApiResponse</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
  <code class="nx">setLightSwitch</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">lightSwitchValue</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">You’ve declared that the result of the <code class="calibre18">/light</code> request is <code class="calibre18">LightApiResponse</code>, but nothing enforces this. If you misunderstood the API and <code class="calibre18">lightSwitchValue</code> is really a <code class="calibre18">string</code>, then a string will be passed to <code class="calibre18">setLightSwitch</code> at runtime. Or perhaps the API changed after you deployed.</p>

<p class="author1">TypeScript can get quite confusing when your runtime types don’t match the declared types, and this is a situation you should avoid whenever you can. But be aware that it’s possible for a value to have types other than the ones you’ve declared.</p>
</div></section>













<section class="praise" data-pdf-bookmark="You Cannot Overload a Function Based on TypeScript Types" data-type="sect2"><div class="praise" id="idm45331679149768">
<h2 class="calibre31">You Cannot Overload a Function Based on TypeScript Types</h2>

<p class="author1">Languages<a data-primary="C++" data-type="indexterm" id="idm45331679010392" class="calibre9"/><a data-primary="functions" data-secondary="overloading" data-type="indexterm" id="idm45331679009656" class="calibre9"/><a data-primary="overloading functions" data-type="indexterm" id="idm45331679008712" class="calibre9"/> like C++ allow you to define multiple versions of a function that differ only in the types of their parameters. This is called “function overloading.” Because the runtime behavior of your code is independent of its TypeScript types, this construct isn’t possible in TypeScript:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
      <code class="c">// ~~~ Duplicate function implementation</code>
<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">b</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
      <code class="c">// ~~~ Duplicate function implementation</code></pre>

<p class="author1">TypeScript <em class="calibre3">does</em> provide a facility for overloading functions, but it operates entirely at the type level. You can provide multiple declarations for a function, but only a single implementation:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">b</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">three</code> <code class="o">=</code> <code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code>  <code class="c">// Type is number</code>
<code class="kd">const</code> <code class="nx">twelve</code> <code class="o">=</code> <code class="nx">add</code><code class="p">(</code><code class="s">'1'</code><code class="p">,</code> <code class="s">'2'</code><code class="p">);</code>  <code class="c">// Type is string</code></pre>

<p class="author1">The first two declarations of <code class="calibre18">add</code> only provide type information. When TypeScript produces JavaScript output, they are removed, and only the implementation remains. (If you use this style of overloading, take a look at <a href="ch06.html#conditional-overload" class="calibre9">Item 50</a> first. There are some subtleties to be aware of.)</p>
</div></section>













<section class="praise" data-pdf-bookmark="TypeScript Types Have No Effect on Runtime Performance" data-type="sect2"><div class="praise" id="idm45331678865736">
<h2 class="calibre31">TypeScript Types Have No Effect on Runtime Performance</h2>

<p class="author1">Because<a data-primary="runtime" data-secondary="effect of TypeScript types on performance" data-type="indexterm" id="idm45331678863960" class="calibre9"/> types and type operations are erased when you generate JavaScript, they cannot have an effect on runtime performance. TypeScript’s static types are truly zero cost. The next time someone offers runtime overhead as a reason to not use TypeScript, you’ll know exactly how well they’ve tested this claim!</p>

<p class="author1">There are two caveats to this:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">While there is no <em class="calibre3">runtime</em> overhead, the TypeScript compiler will introduce <em class="calibre3">build time</em> overhead. The TypeScript team takes compiler performance seriously and compilation is usually quite fast, especially for incremental builds. If the overhead becomes significant, your build tool may have a “transpile only” option to skip the type checking.</p>
</li>
<li class="calibre12">
<p class="author1">The code that TypeScript emits to support older runtimes <em class="calibre3">may</em> incur a performance overhead vs. native implementations. For example, if you use generator functions and<a data-primary="ES5" data-secondary="generator functions" data-type="indexterm" id="idm45331678858424" class="calibre9"/> target ES5, which predates generators, then <code class="calibre18">tsc</code> will emit some helper code to make things work. This may have some overhead vs. a native implementation of generators. In any case, this has to do with the emit target and language levels and is still independent of the <em class="calibre3">types</em>.</p>
</li>
</ul>
</div></section>













<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331678855832">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Code generation is independent of the type system. This means that TypeScript types cannot affect the runtime behavior or performance of your code.</p>
</li>
<li class="calibre12">
<p class="author1">It is possible for a program with type errors to produce code (“compile”).</p>
</li>
<li class="calibre12">
<p class="author1">TypeScript types are not available at runtime. To query a type at runtime, you need some way to reconstruct it. Tagged unions<a data-primary="tagged unions" data-secondary="querying at runtime using" data-type="indexterm" id="idm45331678851528" class="calibre9"/><a data-primary="property checking" data-type="indexterm" id="idm45331678850584" class="calibre9"/> and property checking are common ways to do this. Some constructs, such as <code class="calibre18">class</code>, introduce both a TypeScript type and a value that is available at runtime.<a data-primary="" data-startref="TSCcode01" data-type="indexterm" id="idm45331678849400" class="calibre9"/><a data-primary="" data-startref="DGtype01" data-type="indexterm" id="idm45331678848424" class="calibre9"/><a data-primary="" data-startref="CCcheck01" data-type="indexterm" id="idm45331678847480" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 4: Get Comfortable with Structural Typing" data-type="sect1" class="praise"><div class="praise" id="structural">
<h1 class="calibre16">Item 4: Get Comfortable with Structural Typing</h1>

<p class="author1">JavaScript<a data-primary="TypeScript" data-secondary="structural typing" data-type="indexterm" id="TSstruct01" class="calibre9"/><a data-primary="structural typing" data-type="indexterm" id="struc01" class="calibre9"/><a data-primary="JavaScript" data-secondary="duck typing" data-type="indexterm" id="JSduck01" class="calibre9"/><a data-primary="duck typing" data-type="indexterm" id="duck01" class="calibre9"/> is inherently duck typed: if you pass a function a value with all the right properties, it won’t care how you made the value. It will just use it. (“If it walks like a duck and talks like a duck…”) TypeScript models this behavior, and it can sometimes lead to surprising results because the type checker’s understanding of a type may be broader than what you had in mind. Having a good grasp of structural typing will help you make sense of errors and non-errors and help you write more robust code.</p>

<p class="author1">Say you’re working on a physics library and have a 2D vector type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You write a function to calculate its length:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateLength</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">v</code><code class="p">.</code><code class="nx">y</code> <code class="o">*</code> <code class="nx">v</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">Now you introduce the notion of a named vector:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">NamedVector</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">calculateLength</code> function will work with <code class="calibre18">NamedVector</code>s because they have <code class="calibre18">x</code> and <code class="calibre18">y</code> properties, which are <code class="calibre18">number</code>s. TypeScript is smart enough to figure this out:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">v</code>: <code class="nx">NamedVector</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s">'Zee'</code> <code class="p">};</code>
<code class="nx">calculateLength</code><code class="p">(</code><code class="nx">v</code><code class="p">);</code>  <code class="c">// OK, result is 5</code></pre>

<p class="author1">What is interesting is that you never declared the relationship between <code class="calibre18">Vector2D</code> and <code class="calibre18">NamedVector</code>. And you did not have to write an alternative implementation of <span class="calibre"><code class="calibre18">calculateLength</code></span> calculateLength for <code class="calibre18">NamedVector</code>s. TypeScript’s type system is modeling JavaScript’s runtime behavior (<a href="#ts-vs-js" class="calibre9">Item 1</a>). It allowed <code class="calibre18">calculateLength</code> to be called with a <code class="calibre18">NamedVector</code> because its <em class="calibre3">structure</em> was compatible with <code class="calibre18">Vector2D</code>. This is where the term “structural typing” comes from.</p>

<p class="author1">But this can also lead to trouble. Say you add a 3D vector type:</p>

<pre data-code-language="ts" data-type="programlisting" id="vector3d-normalize" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">and write a function to normalize them (make their length 1):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">normalize</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector3D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="nx">calculateLength</code><code class="p">(</code><code class="nx">v</code><code class="p">);</code>
  <code class="kd">return</code> <code class="p">{</code>
    <code class="nx">x</code>: <code class="nx">v.x</code> <code class="o">/</code> <code class="nx">length</code><code class="p">,</code>
    <code class="nx">y</code>: <code class="nx">v.y</code> <code class="o">/</code> <code class="nx">length</code><code class="p">,</code>
    <code class="nx">z</code>: <code class="nx">v.z</code> <code class="o">/</code> <code class="nx">length</code><code class="p">,</code>
  <code class="p">};</code>
<code class="p">}</code></pre>

<p class="author1">If you call this function, you’re likely to get something longer than unit length:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">normalize({x: 3, y: 4, z: 5})</strong>
{ x: 0.6, y: 0.8, z: 1 }</pre>

<p class="author1">So what went wrong and why didn’t TypeScript catch the error?</p>

<p class="author1">The bug is that <code class="calibre18">calculateLength</code> operates on 2D vectors but <code class="calibre18">normalize</code> operates on 3D vectors. So the <code class="calibre18">z</code> component is ignored in the normalization.</p>

<p class="author1">What’s perhaps more surprising is that the type checker does not catch this issue. Why are you allowed to call <code class="calibre18">calculateLength</code> with a 3D vector, despite its type declaration saying that it takes 2D vectors?</p>

<p class="author1">What worked so well with named vectors has backfired here. Calling <code class="calibre18">calculateLength</code> with an <code class="calibre18">{x, y, z}</code> object doesn’t throw an error. So the type checker doesn’t complain, either, and this behavior has led to a bug. (If you want this to be an error, you have some options. We’ll return to this example in <a href="ch04.html#brands" class="calibre9">Item 37</a>.)</p>

<p class="author1">As you write functions, it’s easy to imagine that they will be called with arguments having the properties you’ve declared <em class="calibre3">and no others</em>. This is known as a “sealed” or “precise” type, and it cannot be expressed in TypeScript’s type system. Like it or not, your types are “open.”</p>

<p class="author1">This<a data-primary="Object.keys" data-type="indexterm" id="idm45331678535192" class="calibre9"/> can sometimes lead to surprises:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateLengthL1</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector3D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">axis</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">v</code><code class="p">))</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">coord</code> <code class="o">=</code> <code class="nx">v</code><code class="p">[</code><code class="nx">axis</code><code class="p">];</code>
               <code class="c">// ~~~~~~~ Element implicitly has an 'any' type because ...</code>
               <code class="c">//         'string' can't be used to index type 'Vector3D'</code>
    <code class="nx">length</code> <code class="o">+=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">coord</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Why is this an error? Since <code class="calibre18">axis</code> is one of the keys of <code class="calibre18">v</code>, which is a <code class="calibre18">Vector3D</code>, it should be either <code class="calibre18">"x"</code>, <code class="calibre18">"y"</code>, or <code class="calibre18">"z"</code>. And according to the declaration of <code class="calibre18">Vector3D</code>, these are all <code class="calibre18">number</code>s, so shouldn’t the type of <code class="calibre18">coord</code> be <code class="calibre18">number</code>?</p>

<p class="author1">Is this error a false positive? No! TypeScript is correct to complain. The logic in the previous paragraph assumes that <code class="calibre18">Vector3D</code> is sealed and does not have other properties. But it could:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">vec3D</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">1</code><code class="p">,</code> <code class="nx">address</code><code class="o">:</code> <code class="s">'123 Broadway'</code><code class="p">};</code>
<code class="nx">calculateLengthL1</code><code class="p">(</code><code class="nx">vec3D</code><code class="p">);</code>  <code class="c">// OK, returns NaN</code></pre>

<p class="author1">Since <code class="calibre18">v</code> could conceivably have any properties, the type of <code class="calibre18">axis</code> is <code class="calibre18">string</code>. TypeScript has no reason to believe that <code class="calibre18">v[axis]</code> is a number because, as you just saw, it might not be. Iterating over objects can be tricky to type correctly. We’ll return to this topic in <a href="ch07.html#iterate-objects" class="calibre9">Item 54</a>, but in this case an implementation without loops would be better:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateLengthL1</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector3D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">x</code><code class="p">)</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">z</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">Structural typing can also lead to surprises with <code class="calibre18">class</code>es, which are compared structurally for assignability:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">C</code> <code class="p">{</code>
  <code class="nx">foo</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">foo</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">(</code><code class="s">'instance of C'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">d</code>: <code class="nx">C</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">foo</code><code class="o">:</code> <code class="s">'object literal'</code> <code class="p">};</code>  <code class="c">// OK!</code></pre>

<p class="author1">Why is <code class="calibre18">d</code> assignable to <code class="calibre18">C</code>? It has a <code class="calibre18">foo</code> property that is a <code class="calibre18">string</code>. In addition, it has a <code class="calibre18">constructor</code> (from <code class="calibre18">Object.prototype</code>) that can be called with one argument (though it is usually called with zero). So the structures match. This<a data-primary="C++" data-type="indexterm" id="idm45331678256280" class="calibre9"/> might lead to surprises if you have logic in <code class="calibre18">C</code>’s constructor and write a function that assumes it’s run. This is quite different from languages like C++ or Java, where<a data-primary="Java" data-secondary="declaring parameters in" data-type="indexterm" id="idm45331678254920" class="calibre9"/> declaring a parameter of type <code class="calibre18">C</code> guarantees that it will be either <code class="calibre18">C</code> or a subclass of it.</p>

<p class="author1">Structural typing is beneficial when you’re writing tests. Say you have a function that runs a query on a database and processes the results:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Author</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">getAuthors</code><code class="p">(</code><code class="nx">database</code>: <code class="nx">PostgresDB</code><code class="p">)</code><code class="o">:</code> <code class="nx">Author</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">authorRows</code> <code class="o">=</code> <code class="nx">database</code><code class="p">.</code><code class="nx">runQuery</code><code class="p">(</code><code class="s">`SELECT FIRST, LAST FROM AUTHORS`</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">authorRows</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">row</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">first</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">last</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">1</code><code class="p">]}));</code>
<code class="p">}</code></pre>

<p class="author1">To test this, you could create a mock <code class="calibre18">PostgresDB</code>. But a better approach is to use structural typing and define a narrower interface:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">DB</code> <code class="p">{</code>
  <code class="nx">runQuery</code><code class="o">:</code> <code class="p">(</code><code class="nx">sql</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">[];</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">getAuthors</code><code class="p">(</code><code class="nx">database</code>: <code class="nx">DB</code><code class="p">)</code><code class="o">:</code> <code class="nx">Author</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">authorRows</code> <code class="o">=</code> <code class="nx">database</code><code class="p">.</code><code class="nx">runQuery</code><code class="p">(</code><code class="s">`SELECT FIRST, LAST FROM AUTHORS`</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">authorRows</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">row</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">first</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">last</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">1</code><code class="p">]}));</code>
<code class="p">}</code></pre>

<p class="author1">You can still pass <code class="calibre18">getAuthors</code> a <code class="calibre18">PostgresDB</code> in production since it has a <code class="calibre18">runQuery</code> method. Because of structural typing, the <code class="calibre18">PostgresDB</code> doesn’t need to say that it implements <code class="calibre18">DB</code>. TypeScript will figure out that it does.</p>

<p class="author1">When you write your tests, you can pass in a simpler object instead:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">test</code><code class="p">(</code><code class="s">'getAuthors'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">authors</code> <code class="o">=</code> <code class="nx">getAuthors</code><code class="p">({</code>
    <code class="nx">runQuery</code><code class="p">(</code><code class="nx">sql</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="p">[[</code><code class="s">'Toni'</code><code class="p">,</code> <code class="s">'Morrison'</code><code class="p">],</code> <code class="p">[</code><code class="s">'Maya'</code><code class="p">,</code> <code class="s">'Angelou'</code><code class="p">]];</code>
    <code class="p">}</code>
  <code class="p">});</code>
  <code class="nx">expect</code><code class="p">(</code><code class="nx">authors</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">([</code>
    <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Toni'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Morrison'</code><code class="p">},</code>
    <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Maya'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Angelou'</code><code class="p">}</code>
  <code class="p">]);</code>
<code class="p">});</code></pre>

<p class="author1">TypeScript will verify that our test <code class="calibre18">DB</code> conforms to the interface. And your tests don’t need to know anything about your production database: no mocking libraries necessary! By introducing an abstraction (<code class="calibre18">DB</code>), we’ve freed our logic (and tests) from the details of a specific implementation (<code class="calibre18">PostgresDB</code>).</p>

<p class="author1">Another advantage of structural typing is that it can cleanly sever dependencies between libraries. For more on this, see <a href="ch06.html#mirror-types-for-deps" class="calibre9">Item 51</a>.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331677999832">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Understand that JavaScript is duck typed and TypeScript uses structural typing to model this: values assignable to your interfaces might have properties beyond those explicitly listed in your type declarations. Types are not “sealed.”</p>
</li>
<li class="calibre12">
<p class="author1">Be aware that classes also follow structural typing rules. You may not have an instance of the class you expect!</p>
</li>
<li class="calibre12">
<p class="author1">Use structural typing to facilitate unit testing.<a data-primary="" data-startref="duck01" data-type="indexterm" id="idm45331677995288" class="calibre9"/><a data-primary="" data-startref="JSduck01" data-type="indexterm" id="idm45331677994312" class="calibre9"/><a data-primary="" data-startref="struc01" data-type="indexterm" id="idm45331677993368" class="calibre9"/><a data-primary="" data-startref="TSstruct01" data-type="indexterm" id="idm45331677992424" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 5: Limit Use of the any Type" data-type="sect1" class="praise"><div class="praise" id="any">
<h1 class="calibre16">Item 5: Limit Use of the any Type</h1>

<p class="author1">TypeScript’s<a data-primary="TypeScript" data-secondary="any type drawbacks" data-type="indexterm" id="TSany01" class="calibre9"/><a data-primary="any types" data-secondary="drawbacks of" data-type="indexterm" id="ATdraw01" class="calibre9"/> type system is <em class="calibre3">gradual</em> and <em class="calibre3">optional</em>: <em class="calibre3">gradual</em> because you can add types to your code bit by bit and <em class="calibre3">optional</em> because you can disable the type checker whenever you like. The key to these features is the <code class="calibre18">any</code> type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17">   <code class="kd">let</code> <code class="nx">age</code>: <code class="nx">number</code><code class="p">;</code>
   <code class="nx">age</code> <code class="o">=</code> <code class="s">'12'</code><code class="p">;</code>
<code class="c">// ~~~ Type '"12"' is not assignable to type 'number'</code>
   <code class="nx">age</code> <code class="o">=</code> <code class="s">'12'</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">The type checker is right to complain here, but you can silence it just by typing <code class="calibre18">as any</code>. As you start using TypeScript, it’s tempting to use <code class="calibre18">any</code> types and<a data-primary="type assertion" data-secondary="misuse of" data-type="indexterm" id="idm45331677966760" class="calibre9"/> type assertions (<code class="calibre18">as any</code>) when you don’t understand an error, think the type checker is incorrect, or simply don’t want to take the time to write out type declarations. In some cases this may be OK, but be aware that <code class="calibre18">any</code> eliminates many of the advantages of using TypeScript. You should at least understand its dangers before you use it.</p>








<section class="praise" data-pdf-bookmark="There’s No Type Safety with any Types" data-type="sect2"><div class="praise" id="idm45331677964584">
<h2 class="calibre31">There’s No Type Safety with any Types</h2>

<p class="author1">In<a data-primary="type safety" data-secondary="lack of with any types" data-type="indexterm" id="idm45331677962792" class="calibre9"/> the preceding example, the type declaration says that <code class="calibre18">age</code> is a <code class="calibre18">number</code>. But <code class="calibre18">any</code> lets you assign a <code class="calibre18">string</code> to it. The type checker will believe that it’s a <code class="calibre18">number</code> (that’s what you said, after all), and the chaos will go uncaught:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">age</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>  <code class="c">// OK; at runtime, age is now "121"</code></pre>
</div></section>













<section class="praise" data-pdf-bookmark="any Lets You Break Contracts" data-type="sect2"><div class="praise" id="idm45331677868168">
<h2 class="calibre31">any Lets You Break Contracts</h2>

<p class="author1">When<a data-primary="contracts, breaking with any type" data-type="indexterm" id="idm45331677866616" class="calibre9"/> you write a function, you are specifying a contract: if the caller gives you a certain type of input, you’ll produce a certain type of output. But with an <code class="calibre18">any</code> type you can break these contracts:</p>

<pre data-code-language="ts" data-type="programlisting" id="calculate-age" class="calibre17"><code class="kd">function</code> <code class="nx">calculateAge</code><code class="p">(</code><code class="nx">birthDate</code>: <code class="nx">Date</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">birthDate</code>: <code class="nx">any</code> <code class="o">=</code> <code class="s">'1990-01-19'</code><code class="p">;</code>
<code class="nx">calculateAge</code><code class="p">(</code><code class="nx">birthDate</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">The birth date parameter should be a <code class="calibre18">Date</code>, not a <code class="calibre18">string</code>. The <code class="calibre18">any</code> type has let you break the contract of <code class="calibre18">calculateAge</code>. This can be particularly problematic because JavaScript is often willing to implicitly convert between types. A <code class="calibre18">string</code> will sometimes work where a <code class="calibre18">number</code> is expected, only to break in other circumstances.</p>
</div></section>













<section class="praise" data-pdf-bookmark="There Are No Language Services for any Types" data-type="sect2"><div class="praise" id="idm45331677832040">
<h2 class="calibre31">There Are No Language Services for any Types</h2>

<p class="author1">When<a data-primary="language services" data-secondary="drawbacks of any types" data-type="indexterm" id="idm45331677830072" class="calibre9"/> a symbol has a type, the TypeScript language services are able to provide intelligent autocomplete and contextual documentation (as shown in <a data-type="xref" href="#efts-01in01" class="calibre9">Figure 1-3</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-01in01">
<img alt="efts 01in01" src="assets/efts_01in01.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 1-3. </span>The TypeScript Language Service is able to provide contextual autocomplete for symbols with types.</h6>
</div></figure>

<p class="author1">but for symbols with an <code class="calibre18">any</code> type, you’re on your own (<a data-type="xref" href="#efts-01in02" class="calibre9">Figure 1-4</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-01in02">
<img alt="efts 01in02" src="assets/efts_01in02.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 1-4. </span>There is no autocomplete for properties on symbols with any types.</h6>
</div></figure>

<p class="author1">Renaming is another such service. If you have a Person type and functions to format a person’s name:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">formatName</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">first</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">formatNameAny</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">first</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code></pre>

<p class="author1">then you can select <code class="calibre18">first</code> in your editor, choose “Rename Symbol,” and change it to <code class="calibre18">firstName</code> (see Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#efts-01in03" class="calibre9">1-5</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#efts-01in04" class="calibre9">1-6</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-01in03">
<img alt="efts 01in03" src="assets/efts_01in03.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 1-5. </span>Renaming a symbol in vscode.</h6>
</div></figure>

<figure class="calibre28"><div class="figure" id="efts-01in04">
<img alt="img { width: 50% !important; }" src="assets/efts_01in04.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 1-6. </span>Choosing the new name. The TypeScript language service ensures that all uses of the symbol in the project are also renamed.</h6>
</div></figure>

<p class="author1">This changes the <code class="calibre18">formatName</code> function but not the <code class="calibre18">any</code> version:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">formatName</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">firstName</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">formatNameAny</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">first</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code></pre>

<p class="author1">TypeScript’s motto is “JavaScript that scales.” A key part of “scales” is the language services, which are a core part of the TypeScript experience (see <a href="ch02_split_000.html#editor" class="calibre9">Item 6</a>). Losing them will lead to a loss in productivity, not just for you but for everyone else working with your code.</p>
</div></section>













<section class="praise" data-pdf-bookmark="any Types Mask Bugs When You Refactor Code" data-type="sect2"><div class="praise" id="idm45331677831416">
<h2 class="calibre31">any Types Mask Bugs When You Refactor Code</h2>

<p class="author1">Suppose<a data-primary="debugging" data-secondary="any type drawbacks" data-type="indexterm" id="idm45331677659144" class="calibre9"/> you’re building a web application in which users can select some sort of item. One of your components might have an <code class="calibre18">onSelectItem</code> callback. Writing a type for an Item seems like a hassle, so you just use <code class="calibre18">any</code> as a stand-in:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ComponentProps</code> <code class="p">{</code>
  <code class="nx">onSelectItem</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Here’s code that manages that component:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">renderSelector</code><code class="p">(</code><code class="nx">props</code>: <code class="nx">ComponentProps</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="kd">let</code> <code class="nx">selectedId</code>: <code class="nx">number</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">handleSelectItem</code><code class="p">(</code><code class="nx">item</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">selectedId</code> <code class="o">=</code> <code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">renderSelector</code><code class="p">({</code><code class="nx">onSelectItem</code>: <code class="nx">handleSelectItem</code><code class="p">});</code></pre>

<p class="author1">Later you rework the selector in a way that makes it harder to pass the whole <code class="calibre18">item</code> object through to <code class="calibre18">onSelectItem</code>. But that’s no big deal since you just need the ID. You change the signature in <code class="calibre18">ComponentProps</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ComponentProps</code> <code class="p">{</code>
  <code class="nx">onSelectItem</code><code class="o">:</code> <code class="p">(</code><code class="nx">id</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You update the component and everything passes the type checker. Victory!</p>

<p class="author1">…or is it? <code class="calibre18">handleSelectItem</code> takes an <code class="calibre18">any</code> parameter, so it’s just as happy with an Item as it is with an ID. It produces a runtime exception, despite passing the type checker. Had you used a more specific type, this would have been caught by the type checker.</p>
</div></section>













<section class="praise" data-pdf-bookmark="any Hides Your Type Design" data-type="sect2"><div class="praise" id="idm45331677660584">
<h2 class="calibre31">any Hides Your Type Design</h2>

<p class="author1">The<a data-primary="type design" data-secondary="any type drawbacks" data-type="indexterm" id="idm45331677535272" class="calibre9"/> type definition for complex objects like your application state can get quite long. Rather than writing out types for the dozens of properties in your page’s state, you may be tempted to just use an <code class="calibre18">any</code> type and be done with it.</p>

<p class="author1">This is problematic for all the reasons listed in this item. But it’s also problematic because it hides the design of your state. As <a data-type="xref" href="ch04.html#ch-design" class="calibre9">Chapter 4</a> explains, good type design is essential for writing clean, correct, and understandable code. With an <code class="calibre18">any</code> type, your type design is implicit. This makes it hard to know whether the design is a good one, or even what the design is at all. If you ask a coworker to review a change, they’ll have to reconstruct whether and how you changed the application state. Better to write it out for everyone to see.</p>
</div></section>













<section class="praise" data-pdf-bookmark="any Undermines Confidence in the Type System" data-type="sect2"><div class="praise" id="idm45331677525352">
<h2 class="calibre31">any Undermines Confidence in the Type System</h2>

<p class="author1">Every time you make a mistake and the type checker catches it, it boosts your confidence in the type system. But when you see a type error at runtime, that confidence takes a hit. If you’re introducing TypeScript on a larger team, this might make your coworkers question whether TypeScript is worth the effort. <code class="calibre18">any</code> types are often the source of these uncaught errors.</p>

<p class="author1">TypeScript aims to make your life easier, but TypeScript with lots of <code class="calibre18">any</code> types can be harder to work with than untyped JavaScript because you have to fix type errors <em class="calibre3">and</em> still keep track of the real types in your head. When your types match reality, it frees you from the burden of having to keep type information in your head. TypeScript will keep track of it for you.</p>

<p class="author1">For the times when you must use <code class="calibre18">any</code>, there are better and worse ways to do it. For much more on how to limit the downsides of <code class="calibre18">any</code>, see <a data-type="xref" href="ch05.html#ch-any" class="calibre9">Chapter 5</a>.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331677518760">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">The <code class="calibre18">any</code> type effectively silences the type checker and TypeScript language services. It can mask real problems, harm developer experience, and undermine confidence in the type system. Avoid using it when you can!<a data-primary="" data-startref="TSany01" data-type="indexterm" id="idm45331677515720" class="calibre9"/><a data-primary="" data-startref="ATdraw01" data-type="indexterm" id="idm45331677514744" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>







</div></section></body></html>