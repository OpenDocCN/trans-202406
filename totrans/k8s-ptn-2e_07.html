<html><head></head><body><section data-pdf-bookmark="Chapter 5. Managed Lifecycle" data-type="chapter" epub:type="chapter"><div class="chapter" id="ManagedLifecycle">&#13;
<h1><span class="label">Chapter 5. </span>Managed Lifecycle</h1>&#13;
&#13;
&#13;
<p>Containerized applications<a data-primary="Managed Lifecycle" data-type="indexterm" id="manlife05"/> managed by cloud native platforms have no control over their lifecycle, and to be good cloud native citizens, they have to listen to the events emitted by the managing platform and adapt their lifecycles accordingly.&#13;
The <em>Managed Lifecycle</em> pattern describes how applications can and should react to these lifecycle events.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902104209056">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>In<a data-primary="problems" data-secondary="lifecycle events, reacting to" data-type="indexterm" id="idm45902104207728"/> <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.html#HealthProbe">Chapter 4, “Health Probe”</a>, we<a data-primary="Health Probe" data-secondary="Managed Lifecycle" data-type="indexterm" id="idm45902104205344"/><a data-primary="Health Probe" data-type="indexterm" id="idm45902104204336"/> explained why containers have to provide APIs for the different health checks. Health-check APIs are read-only endpoints the platform is continually probing to get application insight. It is a mechanism for the platform to extract information from the application.</p>&#13;
&#13;
<p>In<a data-primary="lifecycle events" data-secondary="reacting to" data-type="indexterm" id="idm45902104203152"/> addition to monitoring the state of a container, the platform sometimes may issue commands and expect the application to react to them. Driven by policies and external factors, a cloud native platform may decide to start or stop the applications it is managing at any moment. It is up to the containerized application to determine which events are important to react to and how to react. But in effect, this is an API that the platform is using to communicate and send commands to the application. Also, applications are free to either benefit from lifecycle management or ignore it if they don’t need this service.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902104201760">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>We saw that checking only the process status is not a good enough indication of the health of an application. That is why there are different APIs for monitoring the health of a container. Similarly, using only the process model to run and stop a process is not good enough. Real-world applications require more fine-grained interactions and lifecycle management capabilities. Some applications need help to warm up, and some applications need a gentle and clean shutdown procedure. For this and other use cases, some events, as shown in <a data-type="xref" href="#img-events">Figure 5-1</a>, are emitted by the platform that the container can listen to and react to if desired.</p>&#13;
&#13;
<figure class="width-60"><div class="figure" id="img-events">&#13;
<img alt="Managed container lifecycle" src="assets/kup2_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>Managed container lifecycle</h6>&#13;
</div></figure>&#13;
&#13;
<p>The deployment unit of an application is a Pod. As you already know, a Pod is composed of one or more containers. At the Pod level, there are other constructs such as init containers, which we cover<a data-primary="Init Container" data-type="indexterm" id="idm45902104196752"/><a data-primary="Init Container" data-secondary="Managed Lifecycle" data-type="indexterm" id="idm45902104196048"/> in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch15.html#InitContainer">Chapter 15, “Init Container”</a>, that can help manage the container lifecycle. The events and hooks we describe in this chapter are all applied at an individual container level rather than the Pod level.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SIGTERM Signal" data-type="sect2"><div class="sect2" id="idm45902100368464">&#13;
<h2>SIGTERM Signal</h2>&#13;
&#13;
<p>Whenever Kubernetes decides to shut down a container, whether that is because the Pod it belongs to is shutting down or simply because a failed liveness probe causes the container to be restarted, the container receives a SIGTERM signal. SIGTERM is a gentle poke for the container to shut down cleanly before Kubernetes sends a more abrupt SIGKILL signal. Once a SIGTERM signal has been received, the application should shut down as quickly as possible. For some applications, this might be a quick termination, and some other applications may have to complete their in-flight requests, release open connections, and clean up temp files, which can take a slightly longer time. In all cases, reacting to SIGTERM is the right moment to shut down a container in a clean way.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SIGKILL Signal" data-type="sect2"><div class="sect2" id="idm45902100366880">&#13;
<h2>SIGKILL Signal</h2>&#13;
&#13;
<p>If a container process has not shut down after a SIGTERM signal, it is shut down forcefully by the following SIGKILL signal. Kubernetes does not send the SIGKILL signal immediately but waits 30 seconds by default after it has issued a SIGTERM signal. This grace period can be defined per Pod via the <code>.spec.terminationGrace​Per⁠iodSeconds</code> field, but it cannot be guaranteed as it can be overridden while issuing commands to Kubernetes. The aim should be to design and implement containerized applications to be ephemeral with quick startup and shutdown &#13;
<span class="keep-together">processes.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="PostStart Hook" data-type="sect2"><div class="sect2" id="idm45902100364352">&#13;
<h2>PostStart Hook</h2>&#13;
&#13;
<p>Using<a data-primary="postStart hooks" data-type="indexterm" id="idm45902100362560"/> only process signals for managing lifecycles is somewhat limited. That is why additional lifecycle hooks such as <code>postStart</code> and <code>preStop</code> are provided by Kubernetes. A Pod manifest containing a <code>postStart</code> hook looks like the one in <a data-type="xref" href="#ex-post-start">Example 5-1</a>.</p>&#13;
<div data-type="example" id="ex-post-start">&#13;
<h5><span class="label">Example 5-1. </span>A container with <code>postStart</code> hook</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">post-start-hook</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">lifecycle</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">postStart</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">exec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">command</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_managed_lifecycle_CO1-1" id="co_managed_lifecycle_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">sh</code><code class="w">&#13;
</code><code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">-c</code><code class="w">&#13;
</code><code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">sleep</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">30</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">&amp;&amp;</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">echo</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">"Wake</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">up!"</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">&gt;</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">/tmp/postStart_done</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO1-1" id="callout_managed_lifecycle_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>postStart</code> command waits 30 seconds. <code>sleep</code> is just a simulation for any lengthy startup code that might run at this point. Also, it uses a trigger file to sync with the main application, which starts in parallel.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The <code>postStart</code> command is executed after a container is created, asynchronously with the primary container’s process. Even if much of the application initialization and warm-up logic can be implemented as part of the container startup steps, <code>postStart</code> still covers some use cases. The <code>postStart</code> action is a blocking call, and the container status remains <em>Waiting</em> until the <code>postStart</code> handler completes, which in turn keeps the Pod status in the <em>Pending</em> state. This nature of <code>postStart</code> can be used to delay the startup state of the container while allowing time for the main container process to initialize.</p>&#13;
&#13;
<p>Another use of <code>postStart</code> is to prevent a container from starting when the Pod does not fulfill certain preconditions. For example, when the <code>postStart</code> hook indicates an error by returning a nonzero exit code, Kubernetes kills the main container process.</p>&#13;
&#13;
<p class="pagebreak-before">The <code>postStart</code> and <code>preStop</code> hook invocation mechanisms are<a data-primary="Health Probe" data-secondary="Managed Lifecycle" data-type="indexterm" id="idm45902105453920"/><a data-primary="Health Probe" data-type="indexterm" id="idm45902105840368"/> similar to the health probes described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.html#HealthProbe">Chapter 4, “Health Probe”</a>, and support these handler types:</p>&#13;
<dl>&#13;
<dt>exec</dt>&#13;
<dd>&#13;
<p>Runs a command directly in the container</p>&#13;
</dd>&#13;
<dt>httpGet</dt>&#13;
<dd>&#13;
<p>Executes an HTTP GET request against a port opened by one Pod container</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>You have to be very careful what critical logic you execute in the <code>postStart</code> hook as there are no guarantees for its execution. Since the hook is running in parallel with the container process, it is possible that the hook may be executed before the container has started. Also, the hook is intended to have at-least-once semantics, so the implementation has to take care of duplicate executions. Another aspect to keep in mind is that the platform does not perform any retry attempts on failed HTTP requests that didn’t reach the handler.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="PreStop Hook" data-type="sect2"><div class="sect2" id="idm45902105834416">&#13;
<h2>PreStop Hook</h2>&#13;
&#13;
<p>The<a data-primary="preStop hooks" data-type="indexterm" id="idm45902105833088"/> <code>preStop</code> hook is a blocking call sent to a container before it is terminated. It has the same semantics as the SIGTERM signal and should be used to initiate a graceful shutdown of the container when reacting to SIGTERM is not possible. The <code>preStop</code> action in <a data-type="xref" href="#ex-pre-stop">Example 5-2</a> must complete before the call to delete the container is sent to the container runtime, which triggers the SIGTERM notification.</p>&#13;
<div data-type="example" id="ex-pre-stop">&#13;
<h5><span class="label">Example 5-2. </span>A container with a <code>preStop</code> hook</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pre-stop-hook</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">lifecycle</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">preStop</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">httpGet</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_managed_lifecycle_CO2-1" id="co_managed_lifecycle_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/shutdown</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO2-1" id="callout_managed_lifecycle_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Call out to a <code>/shutdown</code> endpoint running within the application.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p class="pagebreak-before">Even though <code>preStop</code> is blocking, holding on it or returning an unsuccessful result does not prevent the container from being deleted and the process killed. The <code>preStop</code> hook is only a convenient alternative to a SIGTERM signal for graceful application shutdown and nothing more. It also offers the same handler types and guarantees as the <code>postStart</code> hook we covered previously.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Lifecycle Controls" data-type="sect2"><div class="sect2" id="idm45902100135120">&#13;
<h2>Other Lifecycle Controls</h2>&#13;
&#13;
<p>In<a data-primary="lifecycle events" data-secondary="lifecycle controls" data-type="indexterm" id="idm45902100133376"/> this chapter, so far we have focused on the hooks that allow you to execute commands when a container lifecycle event occurs. But another mechanism that is not at the container level but at the Pod level allows you to execute initialization instructions.</p>&#13;
&#13;
<p>We<a data-primary="Init Container" data-type="indexterm" id="idm45902100131856"/><a data-primary="Init Container" data-secondary="Managed Lifecycle" data-type="indexterm" id="idm45902100131120"/> describe the <em>Init Container</em> pattern in <a data-type="xref" href="ch15.html#InitContainer">Chapter 15</a> in depth, but here we describe it briefly to compare it with lifecycle hooks. Unlike regular application containers, init containers run sequentially, run until completion, and run before any of the application containers in a Pod start up. These guarantees allow you to use init containers for Pod-level initialization tasks. Both lifecycle hooks and init containers operate at a different granularity (at the container level and Pod level, respectively) and can be used interchangeably in some instances, or complement one another in other cases. <a data-type="xref" href="#table-lifecycle-hooks">Table 5-1</a> summarizes the main differences between the two.</p>&#13;
<table id="table-lifecycle-hooks">&#13;
<caption><span class="label">Table 5-1. </span>Lifecycle hooks and init containers</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Aspect</th>&#13;
<th>Lifecycle hooks</th>&#13;
<th>Init containers</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Activates on</p></td>&#13;
<td><p>Container lifecycle phases.</p></td>&#13;
<td><p>Pod lifecycle phases.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Startup phase action</p></td>&#13;
<td><p>A <code>postStart</code> command.</p></td>&#13;
<td><p>A list of <code>initContainers</code> to execute.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Shutdown phase action</p></td>&#13;
<td><p>A <code>preStop</code> command.</p></td>&#13;
<td><p>No equivalent feature.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Timing guarantees</p></td>&#13;
<td><p>A <code>postStart</code> command is executed at the same time as the container’s <code>ENTRYPOINT</code>.</p></td>&#13;
<td><p>All init containers must be completed successfully before any application container can start.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Use cases</p></td>&#13;
<td><p>Perform noncritical startup/shutdown cleanups specific to a container.</p></td>&#13;
<td><p>Perform workflow-like sequential operations using containers; reuse containers for task executions.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>If even more control is required to manage the lifecycle of your application containers, there is an advanced technique for rewriting the container entrypoints, sometimes also referred to as the <a href="https://oreil.ly/CVZX6"><em>Commandlet</em> pattern</a><a data-primary="Commandlet" data-type="indexterm" id="idm45902100075472"/>. This pattern is especially useful when the main containers within a Pod have to be started in a certain order and need an extra level of control.&#13;
Kubernetes-based pipeline platforms like Tekton and Argo CD require the sequential execution of containers that share data and support the inclusion of additional sidecar containers running in parallel (we talk more about sidecars in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch16.html#Sidecar">Chapter 16, “Sidecar”</a>).</p>&#13;
&#13;
<p>For these scenarios, a sequence of init containers is not good enough because init containers don’t allow sidecars.&#13;
As an alternative, an advanced technique called &#13;
<span class="keep-together"><em>entrypoint</em></span> <em>rewriting</em> <a data-primary="entrypoint rewriting" data-type="indexterm" id="idm45902100071328"/>can be used to allow fine-grained lifecycle control for the Pod’s main containers. Every container image defines a command that is executed by default when the container starts. In a Pod specification, you can also define this command directly in the Pod spec. The idea of entrypoint rewriting is to replace this command with a generic wrapper command that calls the original command and takes care of lifecycle concerns. This generic command is injected from another container image before the application container starts.</p>&#13;
&#13;
<p>This concept is best explained by an example.&#13;
<a data-type="xref" href="#ex-entrypoint-rewriting-before">Example 5-3</a> shows a typical Pod declaration that starts a single container with the given arguments.</p>&#13;
<div data-type="example" id="ex-entrypoint-rewriting-before">&#13;
<h5><span class="label">Example 5-3. </span>Simple Pod starting an image with a command and arguments</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">simple-random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">random-generator-runner</code><code class="s">"</code><code class="w">  </code><a class="co" href="#callout_managed_lifecycle_CO3-1" id="co_managed_lifecycle_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w">                        </code><a class="co" href="#callout_managed_lifecycle_CO3-2" id="co_managed_lifecycle_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">--seed</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">42</code><code class="s">"</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO3-1" id="callout_managed_lifecycle_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The command executed when the container starts.</p></dd>&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO3-2" id="callout_managed_lifecycle_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Additional arguments provided to the entrypoint command.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The trick is now to wrap the given command <code>random-generator-runner</code> with a generic supervisor program that takes care of lifecycle aspects, like reacting on <code>SIGTERM</code> or other external signals. <a data-type="xref" href="#ex-entrypoint-rewriting">Example 5-4</a> demonstrates a Pod declaration that includes an init container for installing a supervisor, which is then started to monitor the main application.</p>&#13;
<div class="less_space pagebreak-before" data-type="example" id="ex-entrypoint-rewriting">&#13;
<h5><span class="label">Example 5-4. </span>Pod that wraps the original entrypoint with a supervisor</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">wrapped-random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">wrapper</code><code class="w">                   </code><a class="co" href="#callout_managed_lifecycle_CO4-1" id="co_managed_lifecycle_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="w"> </code><code class="p-Indicator">}</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">initContainers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">copy-supervisor</code><code class="w">           </code><a class="co" href="#callout_managed_lifecycle_CO4-2" id="co_managed_lifecycle_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/supervisor</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/run/wrapper</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">wrapper</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="nv">cp</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="nv">supervisor</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">/var/run/wrapper/supervisor</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/run/wrapper</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">wrapper</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">/var/run/wrapper/supervisor</code><code class="s">"</code><code class="w"> </code><a class="co" href="#callout_managed_lifecycle_CO4-3" id="co_managed_lifecycle_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w">                           </code><a class="co" href="#callout_managed_lifecycle_CO4-4" id="co_managed_lifecycle_CO4-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">random-generator-runner</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">--seed</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">42</code><code class="s">"</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO4-1" id="callout_managed_lifecycle_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>A fresh <code>emptyDir</code> volume is created to share the supervisor daemon.</p></dd>&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO4-2" id="callout_managed_lifecycle_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Init container used for copying the supervisor daemon to the application &#13;
<span class="keep-together">containers.</span></p></dd>&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO4-3" id="callout_managed_lifecycle_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The original command <code>randomGenerator</code> as defined in <a data-type="xref" href="#ex-entrypoint-rewriting-before">Example 5-3</a> is replaced with supervisor daemon from the shared volume.</p></dd>&#13;
<dt><a class="co" href="#co_managed_lifecycle_CO4-4" id="callout_managed_lifecycle_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The original command specification becomes the arguments for the supervisor commands.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p class="pagebreak-before">This entrypoint rewriting<a data-primary="entrypoint rewriting" data-type="indexterm" id="idm45902101445056"/> is especially useful for Kubernetes-based applications that create and manage Pods programmatically, like Tekton, which creates Pods when running a continuous integration (CI) pipeline.&#13;
That way, they gain much better control of when to start, stop, or chain containers within a Pod.</p>&#13;
&#13;
<p>There are no strict rules about which mechanism to use except when you require a specific timing guarantee. We could skip lifecycle hooks and init containers entirely and use a bash script to perform specific actions as part of a container’s startup or shutdown commands. That is possible, but it would tightly couple the container with the script and turn it into a maintenance nightmare.&#13;
We could also use Kubernetes lifecycle hooks to perform some actions, as described in this chapter. Alternatively, we could go even further and run containers that perform individual actions using init containers or<a data-primary="daemons" data-secondary="supervisor daemons" data-type="indexterm" id="idm45902103923936"/> inject supervisor daemons for even more sophisticated control.&#13;
In this sequence, the options require increasingly more effort, but at the same time offer stronger guarantees and enable reuse.</p>&#13;
&#13;
<p>Understanding the stages and available hooks of containers and Pod lifecycles is crucial for creating applications that benefit from being managed by Kubernetes.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902103922320">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>One of the main benefits the cloud native platform provides is the ability to run and scale applications reliably and predictably on top of potentially unreliable cloud infrastructure. These platforms provide a set of constraints and contracts for an application running on them. It is in the interest of the application to honor these contracts to benefit from all of the capabilities offered by the cloud native platform. Handling and reacting to these events ensures that your application can gracefully start up and shut down with minimal impact on the consuming services. At the moment, in its basic form, that means the containers should behave as any well-designed<a data-primary="POSIX" data-type="indexterm" id="idm45902103920992"/> POSIX process should. In the future, there might be even more events giving hints to the application when it is about to be scaled up or asked to release resources to prevent being shut down. It is essential to understand that the application lifecycle is no longer in the control of a person but is fully automated by the platform.</p>&#13;
&#13;
<p>Besides managing the application lifecycle, the other big duty of orchestration platforms like Kubernetes is to distribute containers over a fleet of nodes.&#13;
The next pattern, <em>Automated Placement</em>, explains the options to influence the scheduling decisions from the outside.<a data-primary="" data-startref="manlife05" data-type="indexterm" id="idm45902103919360"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902103918128">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2T2jc">Managed Lifecycle Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/xzeMi">Container Lifecycle Hooks</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/NTi1h">Attach Handlers to Container Lifecycle Events</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/j-5yl">Kubernetes Best Practices: Terminating with Grace</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/TgjCp">Graceful Shutdown of Pods with Kubernetes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/CVZX6">Argo and Tekton: Pushing the Boundaries of the Possible on Kubernetes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/iBhoQ">Russian Doll: Extending Containers with Nested Processes</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>