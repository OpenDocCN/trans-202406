<html><head></head><body><section data-pdf-bookmark="Chapter 11. User Preferences" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_preferences">&#13;
<h1><span class="label">Chapter 11. </span>User Preferences</h1>&#13;
&#13;
&#13;
<p>Allowing personalization of an app is a great way to help the user experience and provide a way for users to tailor an application to suit their needs. Android and iOS provide a set of frameworks, along with a set of patterns, in order to achieve this goal. There are, of course, heavy-handed and cumbersome technologies one could use—and often must—for more complex scenarios. However, most developers can get by with reading and writing user preferences in a simple and out-of-the-box method.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177221058968">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="user preferences" data-secondary="task overview" data-type="indexterm" id="idm46177221057640"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Write user preferences.</p>&#13;
</li>&#13;
<li>&#13;
<p>Read user preferences.</p>&#13;
</li>&#13;
<li>&#13;
<p>Work with user preferences in a multiple user application.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177221018440">&#13;
<h1>Android</h1>&#13;
&#13;
<p>In<a data-primary="user preferences" data-secondary="Android" data-tertiary="SharedPreferences API" data-type="indexterm" id="idm46177221016872"/><a data-primary="Android" data-secondary="user preferences" data-tertiary="SharedPreferences API" data-type="indexterm" id="idm46177221015592"/><a data-primary="SharedPreferences API" data-type="indexterm" id="idm46177221014376"/> Android, it’s possible to use the filesystem, or a database, to store user preferences if you prefer to roll your own, but Android does provide the <code>SharedPreferences</code> API out of the box. While this API is generally encouraged for constancy, it’s not rigorously required or even referenced, and if you find that your requirements make other approaches easier for you, feel free.</p>&#13;
&#13;
<p>From <a href="https://oreil.ly/Bw8Eq">the Android developer docs</a>:</p>&#13;
<blockquote>&#13;
<p>If you don’t need to store a lot of data and it doesn’t require structure, you should use SharedPreferences. The SharedPreferences APIs allow you to read and write persistent key-value pairs of primitive data types: booleans, floats, ints, longs, and strings.</p></blockquote>&#13;
&#13;
<p><code>SharedPreferences</code> is not secure by default—values are stored in an XML file in the application’s file directory. The framework-provided <code>KeyStore</code> API does provide some security, but there are issues on older operating systems that may complicate that statement. There are third-party libraries that (claim to) provide a similar API to that of <code>SharedPreferences</code>, with some level of security.</p>&#13;
&#13;
<p>Whatever its limitations, the <code>SharedPreferences</code> API is simple, easy to use, and provides built-in background threading, so give it a shot!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Write User Preferences" data-type="sect2"><div class="sect2" id="idm46177220993736">&#13;
<h2>Write User Preferences</h2>&#13;
&#13;
<p>To<a data-primary="user preferences" data-secondary="Android" data-tertiary="writing" data-type="indexterm" id="idm46177220992136"/><a data-primary="Android" data-secondary="user preferences" data-tertiary="writing" data-type="indexterm" id="idm46177220990952"/><a data-primary="key-value pairs" data-type="indexterm" id="idm46177220989704"/> write a key-value pair, we first need a <code>SharedPreference</code> object instance—Android provides a preconfigured one by calling the<a data-primary="Android commands and methods" data-secondary="getSharedPreferences(String fileName, Context.MODE_PRIVATE);" data-type="indexterm" id="idm46177220988520"/> method <code>getSharedPreferences(String fileName, Context.MODE_PRIVATE);</code> from any <code>Context</code> instance. Alternatively, <code>Activity</code> instances have a <code>getPreferences</code> method that returns the default preferences file and allows you to omit the first parameter (<code>fileName</code>).</p>&#13;
&#13;
<p>From there, you’ll need an <code>Editor</code> instance, which is available by calling the <code>edit</code> method<a data-primary="Java" data-secondary="user preferences" data-tertiary="writing" data-type="indexterm" id="idm46177220984040"/><a data-primary="Kotlin" data-secondary="user preferences" data-tertiary="writing" data-type="indexterm" id="idm46177220982760"/> from that <code>SharedPreferences</code> instance:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177220980872">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">SharedPreferences</code> <code class="n">preferences</code> <code class="o">=</code> <code class="n">myContext</code><code class="o">.</code><code class="na">getSharedPreferences</code><code class="o">(</code><code class="s">"prefs"</code><code class="o">,</code>&#13;
  <code class="n">Context</code><code class="o">.</code><code class="na">MODE_PRIVATE</code><code class="o">);</code>&#13;
<code class="n">SharedPreferences</code><code class="o">.</code><code class="na">Editor</code> <code class="n">editor</code> <code class="o">=</code> <code class="n">preferences</code><code class="o">.</code><code class="na">edit</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">val</code> <code class="n">preferences</code> <code class="o">=</code> <code class="n">myContext</code><code class="o">.</code><code class="na">getSharedPreferences</code><code class="o">(</code><code class="s">"prefs"</code><code class="o">,</code>&#13;
  <code class="n">Context</code><code class="o">.</code><code class="na">MODE_PRIVATE</code><code class="o">)</code>&#13;
<code class="n">val</code> <code class="n">editor</code> <code class="o">=</code> <code class="n">preferences</code><code class="o">.</code><code class="na">edit</code><code class="o">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>At this point, you can <code>put</code> key-value pairs using methods like <code>putBoolean(String key, boolean value)</code> and <code>putString(String key, String value)</code>. When you’re done, you can either call <code>commit</code> on the <code>Editor</code> instance to have the changes saved synchronously, or call <code>apply</code>, which saves them asynchronously:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177220949704">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">SharedPreferences</code> <code class="n">preferences</code> <code class="o">=</code> <code class="n">myContext</code><code class="o">.</code><code class="na">getSharedPreferences</code><code class="o">(</code><code class="s">"prefs"</code><code class="o">,</code>&#13;
<code class="n">Context</code><code class="o">.</code><code class="na">MODE_PRIVATE</code><code class="o">);</code>&#13;
<code class="n">SharedPreferences</code><code class="o">.</code><code class="na">Editor</code> <code class="n">editor</code> <code class="o">=</code> <code class="n">preferences</code><code class="o">.</code><code class="na">edit</code><code class="o">();</code>&#13;
<code class="n">editor</code><code class="o">.</code><code class="na">putBoolean</code><code class="o">(</code><code class="s">"night mode"</code><code class="o">,</code> <code class="kc">false</code><code class="o">);</code>&#13;
<code class="n">editor</code><code class="o">.</code><code class="na">apply</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">preferences</code> <code class="p">=</code> <code class="n">myContext</code><code class="p">.</code><code class="n">getSharedPreferences</code><code class="p">(</code><code class="s">"prefs"</code><code class="p">,</code> <code class="n">Context</code><code class="p">.</code><code class="n">MODE_PRIVATE</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">editor</code> <code class="p">=</code> <code class="n">preferences</code><code class="p">.</code><code class="n">edit</code><code class="p">()</code>&#13;
<code class="n">editor</code><code class="p">.</code><code class="n">putBoolean</code><code class="p">(</code><code class="s">"night mode"</code><code class="p">,</code> <code class="k">false</code><code class="p">)</code>&#13;
<code class="n">editor</code><code class="p">.</code><code class="n">apply</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>As mentioned, <code>SharedPreferences</code> is meant for simple, primitive values, and can only accept basic data types like <code>boolean</code>, <code>int</code>, <code>long</code>, <code>float</code>, and <code>String</code>, although it also can manage a <code>Set&lt;String&gt;</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read User Preferences" data-type="sect2"><div class="sect2" id="idm46177220773208">&#13;
<h2>Read User Preferences</h2>&#13;
&#13;
<p>Reading<a data-primary="user preferences" data-secondary="Android" data-tertiary="reading" data-type="indexterm" id="idm46177220771608"/><a data-primary="Android" data-secondary="user preferences" data-tertiary="reading" data-type="indexterm" id="idm46177220770328"/> a user preference from <code>SharedPreferences</code> is even easier than writing—and you don’t need the <code>Editor</code> instance or need to worry about threading since a copy is saved in memory (which also makes it fast).</p>&#13;
&#13;
<p>To<a data-primary="Java" data-secondary="user preferences" data-tertiary="reading" data-type="indexterm" id="idm46177220767656"/><a data-primary="Kotlin" data-secondary="user preferences" data-tertiary="reading" data-type="indexterm" id="idm46177220766376"/> read back the <code>boolean</code> we saved in the preceding example, it’s as simple as:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177220764488">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">SharedPreferences</code> <code class="n">preferences</code> <code class="o">=</code> <code class="n">myContext</code><code class="o">.</code><code class="na">getSharedPreferences</code><code class="o">(</code><code class="s">"prefs"</code><code class="o">,</code>&#13;
  <code class="n">Context</code><code class="o">.</code><code class="na">MODE_PRIVATE</code><code class="o">);</code>&#13;
<code class="kt">boolean</code> <code class="n">isNightMode</code> <code class="o">=</code> <code class="n">preferences</code><code class="o">.</code><code class="na">getBoolean</code><code class="o">(</code><code class="s">"night mode"</code><code class="o">,</code> <code class="kc">false</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">preferences</code> <code class="p">=</code> <code class="n">myContext</code><code class="p">.</code><code class="n">getSharedPreferences</code><code class="p">(</code><code class="s">"prefs"</code><code class="p">,</code> <code class="n">Context</code><code class="p">.</code><code class="n">MODE_PRIVATE</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">isNightMode</code> <code class="p">=</code> <code class="n">preferences</code><code class="p">.</code><code class="n">getBoolean</code><code class="p">(</code><code class="s">"night mode"</code><code class="p">,</code> <code class="k">false</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>That’s all there is to it!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Work with User Preferences in a Multiple User Application" data-type="sect2"><div class="sect2" id="idm46177220710824">&#13;
<h2>Work with User Preferences in a Multiple User Application</h2>&#13;
&#13;
<p>So<a data-primary="user preferences" data-secondary="Android" data-tertiary="multiple user applications" data-type="indexterm" id="idm46177220709464"/><a data-primary="Android" data-secondary="user preferences" data-tertiary="multiple user applications" data-type="indexterm" id="idm46177220667432"/> this becomes a little trickier. Technically, <code>SharedPreferences</code> is meant for the entire application—one file, <em>shared</em> by anyone who uses the app. However, it’s become a relatively common practice to use different <code>SharedPreference</code> files for different users—you just need to supply unique file names to the getter. It’s entirely up to you how you determine that, but it’s conceivable<a data-primary="Java" data-secondary="user preferences" data-tertiary="multiple user applications" data-type="indexterm" id="idm46177220664488"/><a data-primary="Kotlin" data-secondary="user preferences" data-tertiary="multiple user applications" data-type="indexterm" id="idm46177220663272"/> that you might just grab a <code>sha</code> of their user ID:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177220661576">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">userId</code> <code class="o">=</code> <code class="c1">// some secret user id...</code>&#13;
<code class="n">String</code> <code class="n">sha</code> <code class="o">=</code> <code class="c1">// do something to protect the user id</code>&#13;
<code class="n">SharedPreferences</code> <code class="n">preferences</code> <code class="o">=</code> <code class="n">myContext</code><code class="o">.</code><code class="na">getSharedPreferences</code><code class="o">(</code><code class="n">sha</code><code class="o">,</code>&#13;
  <code class="n">Context</code><code class="o">.</code><code class="na">MODE_PRIVATE</code><code class="o">);</code>&#13;
<code class="n">editor</code><code class="o">.</code><code class="na">putBoolean</code><code class="o">(</code><code class="s">"night-mode"</code><code class="o">,</code> <code class="kc">false</code><code class="o">);</code>&#13;
<code class="n">editor</code><code class="o">.</code><code class="na">commit</code><code class="o">();</code>&#13;
<code class="c1">// read it back out the same way</code>&#13;
<code class="kt">boolean</code> <code class="n">isNightMode</code> <code class="o">=</code> <code class="n">preferences</code><code class="o">.</code><code class="na">getBoolean</code><code class="o">(</code><code class="s">"night-mode"</code><code class="o">,</code> <code class="kc">false</code><code class="o">);</code>&#13;
<code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"night mode="</code> <code class="o">+</code> <code class="n">isNightMode</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">userId</code> <code class="p">=</code> <code class="c1">// some secret user id...</code>&#13;
<code class="k">val</code> <code class="py">sha</code> <code class="p">=</code> <code class="c1">// do something to protect the user id</code>&#13;
<code class="k">val</code> <code class="py">preferences</code> <code class="p">=</code> <code class="n">myContext</code><code class="p">.</code><code class="n">getSharedPreferences</code><code class="p">(</code><code class="n">sha</code><code class="p">,</code> <code class="n">Context</code><code class="p">.</code><code class="n">MODE_PRIVATE</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">editor</code> <code class="p">=</code> <code class="n">preferences</code><code class="p">.</code><code class="n">edit</code><code class="p">()</code>&#13;
<code class="n">editor</code><code class="p">.</code><code class="n">putBoolean</code><code class="p">(</code><code class="s">"night-mode"</code><code class="p">,</code> <code class="k">false</code><code class="p">)</code>&#13;
<code class="n">editor</code><code class="p">.</code><code class="n">commit</code><code class="p">()</code>&#13;
<code class="k">val</code> <code class="py">isNightMode</code> <code class="p">=</code> <code class="n">preferences</code><code class="p">.</code><code class="n">getBoolean</code><code class="p">(</code><code class="s">"night-mode"</code><code class="p">,</code> <code class="k">false</code><code class="p">)</code>&#13;
<code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"night mode="</code> <code class="p">+</code> <code class="n">isNightMode</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177220523688">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>There<a data-primary="user preferences" data-secondary="iOS" data-tertiary="UserDefaults" data-type="indexterm" id="idm46177220526584"/><a data-primary="iOS" data-secondary="user preferences" data-tertiary="UserDefaults" data-type="indexterm" id="idm46177220525304"/><a data-primary="UserDefaults" data-secondary="storing user data" data-type="indexterm" id="idm46177220493880"/> are multiple ways to store user data in iOS: user defaults, filesystem, Core Data, or the<a data-primary="Keychain (iOS)" data-type="indexterm" id="idm46177220492696"/> Keychain. Often, an application needs to persist bits of information that are unique to a particular user, but not necessarily private or secure information. The best place for data like this is user defaults—it’s a great place to store things like a user’s locale, UI styling preferences, or choices regarding unit of measurements a user wants used for displaying data.</p>&#13;
&#13;
<p>Thankfully, iOS (and macOS) provide a battled-tested way to store this data at an app level: <code>UserDefaults</code>. Let’s dive in!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Write User Preferences" data-type="sect2"><div class="sect2" id="idm46177220490456">&#13;
<h2>Write User Preferences</h2>&#13;
&#13;
<p>Before<a data-primary="user preferences" data-secondary="iOS" data-tertiary="writing" data-type="indexterm" id="UPioswrite11"/><a data-primary="iOS" data-secondary="user preferences" data-tertiary="writing" data-type="indexterm" id="IOSuserwrite11"/> we can read data, it’s important that we learn to store data first. Persisting preferences for users through <code>UserDefaults</code> is fairly straightforward. Here’s a simple example of how to persist a basic string value:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
<code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="s">"some string value"</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"someKey"</code><code class="p">)</code></pre>&#13;
&#13;
<p>First, we’re grabbing the shared <code>UserDefaults</code> instance, and then we’re pairing a string that equals “some string value” to a key named <code>someKey</code>. This key is what we use for looking up that data, as shown later in this chapter.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What’s happening under the hood" data-type="sect3"><div class="sect3" id="idm46177220478248">&#13;
<h3>What’s happening under the hood</h3>&#13;
&#13;
<p>Within the app folder of every iOS application there is a <code>Library</code> folder that contains a <code>Preferences</code> folder. Under the hood, iOS is creating or updating a property list file whenever an application writes a value to <code>UserDefaults.standard</code>. The individual types stored conform<a data-primary="Core Data" data-secondary="NSCoding protocol" data-type="indexterm" id="idm46177220475448"/> to the <code>NSCoding</code> protocol, which allows them to be serialized and deserialized. It’s possible to make custom classes conform to this protocol as well—more on that later!</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This property list file is updated and managed by <code>UserDefaults</code>. It should be considered an implementation detail left up to the underlying subsystem as it’s possible it could change in a future version of iOS.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data types" data-type="sect3"><div class="sect3" id="idm46177220463544">&#13;
<h3>Data types</h3>&#13;
&#13;
<p><code>UserDefaults</code> is capable of storing multiple types of data including booleans, numbers, strings, URLs, dictionaries, arrays, and custom objects. Here’s a more complex example that demonstrates a wider variety of usage:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
&#13;
<code class="c1">// Boolean</code>&#13;
<code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="kc">true</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"nightMode"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Number</code>&#13;
<code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="mf">2.0</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"playbackSpeed"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// String</code>&#13;
<code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="s">"en-US"</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"locale"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// URL</code>&#13;
<code class="kd">let</code> <code class="nv">url</code> <code class="p">=</code> <code class="nb">URL</code><code class="p">(</code><code class="n">string</code><code class="p">:</code> <code class="s">"https://www.example.com/api"</code><code class="p">)</code>&#13;
<code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"apiURL"</code><code class="p">)</code></pre>&#13;
&#13;
<p>Swift provides a number of convenience methods to pass specific data type values into <code>UserDefault</code>. Each value is mapped to a <code>String</code> key. Using standard Swift objects will provide sufficient functionality most of the time. But what about those times when you would like to persist a custom class?</p>&#13;
&#13;
<p>Thankfully, there is a solution: <code>NSCoding</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="NSCoding conformance" data-type="sect3"><div class="sect3" id="idm46177220322920">&#13;
<h3>NSCoding conformance</h3>&#13;
&#13;
<p>Objects that wish to be eligible for persistence with <code>UserDefault</code> need to conform to the <code>NSCoding</code> protocol. This protocol consists of two methods: <code>init(coder:)</code> and <code>encode(with:)</code>. Each of these methods plays a role in the encoding and decoding functionality of storing an object. Let’s take a look at a simple example.</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kr">@objc</code><code class="p">(</code><code class="n">SomeObject</code><code class="p">)</code>&#13;
<code class="kd">class</code> <code class="nc">SomeObject</code><code class="p">:</code> <code class="bp">NSObject</code><code class="p">,</code> <code class="bp">NSCoding</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nv">someProperty</code><code class="p">:</code> <code class="nb">String</code>&#13;
&#13;
    <code class="kd">init</code><code class="p">(</code><code class="n">someProperty</code><code class="p">:</code> <code class="nb">String</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kc">self</code><code class="p">.</code><code class="n">someProperty</code> <code class="p">=</code> <code class="n">someProperty</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// </code><code class="cs">MARK:</code><code class="c1"> NSCoding protocol conformance</code>&#13;
&#13;
    <code class="kr">required</code> <code class="kr">convenience</code> <code class="kd">init</code><code class="p">?(</code><code class="n">coder</code> <code class="n">aDecoder</code><code class="p">:</code> <code class="bp">NSCoder</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">guard</code> <code class="kd">let</code> <code class="nv">someProperty</code> <code class="p">=</code> <code class="n">aDecoder</code><code class="p">.</code><code class="n">decodeObject</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code>&#13;
        <code class="s">"someProperty"</code><code class="p">)</code> <code class="k">as</code><code class="p">?</code> <code class="nb">String</code> <code class="k">else</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="kc">nil</code>&#13;
        <code class="p">}</code>&#13;
        <code class="kc">self</code><code class="p">.</code><code class="kd">init</code><code class="p">(</code><code class="n">someProperty</code><code class="p">:</code> <code class="n">someProperty</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">encode</code><code class="p">(</code><code class="n">with</code> <code class="n">aCoder</code><code class="p">:</code> <code class="bp">NSCoder</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">aCoder</code><code class="p">.</code><code class="n">encode</code><code class="p">(</code><code class="n">someProperty</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"someProperty"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">someObject</code> <code class="p">=</code> <code class="n">SomeObject</code><code class="p">(</code><code class="n">someProperty</code><code class="p">:</code> <code class="s">"some value"</code><code class="p">)</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
<code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="n">someObject</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"myObject"</code><code class="p">)</code></pre>&#13;
&#13;
<p>First, we declare an explicit <code>@objc</code> name to a class. This is done because of the importance of the class name in unarchiving the object. We also declare that the class conforms to <code>NSCoding</code> conformance. Next, we have a string property named <code>someProperty</code> that is set in an initializer of the class. Further in the class, in the <code>encode(with:)</code> method, we use the given <code>NSCoder</code> passed into the method to encode the <code>someProperty</code> value for the key <code>someProperty</code>. This is the method that is called under the hood whenever we call <code>set(value:forKey:)</code> on <code>UserDefaults</code>.</p>&#13;
&#13;
<p>Later, whenever we need to decode that object, <code>UserDefaults</code> instantiates the object by calling the <code>init?(coder:)</code> initializer. Inside that method, we attempt to set each property that’s encoded by first decoding the property for the given key and then passing that into our default object initializer. Because we are deciding what properties to encode and decode manually, it’s possible to exclude certain properties that are initialized based on different data or that get set by other objects.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This<a data-primary="Core Data" data-secondary="NSKeyedUnarchiver" data-type="indexterm" id="idm46177220160520"/> is a “stringly typed” example that is easy to break if the key names are mistyped, or change between versions of your app. There are ways around this using enums and some built-in <code>NSKeyedUnarchiver</code> functionality like <code>NSKeyedUnarchiver.setClass(SomeObject.self, forClassName: "SomeObject")</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use Codable instead of NSCoding" data-type="sect3"><div class="sect3" id="idm46177220158088">&#13;
<h3>Use Codable instead of NSCoding</h3>&#13;
&#13;
<p>It’s possible to skip <code>NSCoding</code> conformance for custom objects that need persisting in <code>UserDefaults</code> and just use <code>Codable</code> conformance to encode and decode the object as JSON. One of the benefits of using <code>Codable</code> over <code>NSCoding</code> is that you skip the entire<a data-primary="Objective-C" data-type="indexterm" id="idm46177220154136"/> Objective-C runtime. Here’s an example:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">struct</code> <code class="nc">SomeObject</code><code class="p">:</code> <code class="n">Codable</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nv">someProperty</code><code class="p">:</code> <code class="nb">String</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">someObject</code> <code class="p">=</code> <code class="n">SomeObject</code><code class="p">(</code><code class="n">someProperty</code><code class="p">:</code> <code class="s">"some value"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Store the object</code>&#13;
<code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
<code class="k">if</code> <code class="kd">let</code> <code class="nv">json</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">JSONEncoder</code><code class="p">().</code><code class="n">encode</code><code class="p">(</code><code class="n">someObject</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="n">json</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="s">"myObject"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For a given type that conforms to <code>Codable</code>, we can encode it using <code>JSONEncoder</code> and then set the <code>Data</code> generated directly to a key (<code>myObject</code> in our example).</p>&#13;
&#13;
<p>Decoding the JSON is straightforward. It can be accomplished with the following code:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Read the value</code>&#13;
<code class="kd">let</code> <code class="nv">json</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">value</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"myObject"</code><code class="p">)</code> <code class="k">as</code><code class="p">!</code> <code class="n">Data</code>&#13;
<code class="kd">let</code> <code class="nv">someObject</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">JSONDecoder</code><code class="p">().</code><code class="n">decode</code><code class="p">(</code><code class="n">SomeObject</code><code class="p">.</code><code class="kc">self</code><code class="p">,</code> <code class="n">from</code><code class="p">:</code> <code class="n">json</code><code class="p">)</code></pre>&#13;
&#13;
<p>First, we grab the object from <code>UserDefaults</code> as <code>Data</code> (with a force unwrap to keep this example simple). Then, we decode it using <code>JSONDecoder</code> and explicitly declare it as a type of <code>SomeObject</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deleting keys" data-type="sect3"><div class="sect3" id="idm46177220106856">&#13;
<h3>Deleting keys</h3>&#13;
&#13;
<p>It’s possible that you might create a key and then decide in a future version of the app that you no longer want that key around. Deleting a key in <code>UserDefaults</code> is nothing more than a call like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
<code class="n">defaults</code><code class="p">.</code><code class="n">removeObject</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"someKey"</code><code class="p">)</code></pre>&#13;
&#13;
<p>Now that we’ve written (and deleted) data, let’s take a look at reading it so we can use it in our apps!<a data-primary="" data-startref="UPioswrite11" data-type="indexterm" id="idm46177219957512"/><a data-primary="" data-startref="IOSuserwrite11" data-type="indexterm" id="idm46177219911528"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read User Preferences" data-type="sect2"><div class="sect2" id="idm46177219910360">&#13;
<h2>Read User Preferences</h2>&#13;
&#13;
<p>Reading<a data-primary="user preferences" data-secondary="iOS" data-tertiary="reading" data-type="indexterm" id="idm46177219908664"/><a data-primary="iOS" data-secondary="user preferences" data-tertiary="reading" data-type="indexterm" id="idm46177219907384"/> data from <code>UserDefaults</code> can be done with a call like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
<code class="kd">let</code> <code class="nv">someValue</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">value</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"someKey"</code><code class="p">)</code></pre>&#13;
&#13;
<p>This creates an object named <code>someValue</code> that holds our data. <code>UserDefaults</code> unfortunately doesn’t explicitly know what type our data is being decoded to, so it defaults to <code>Any?</code>. It’s possible, however, to change the method we’re calling to get our data slightly with some special-built methods for a set of common types. Here’s some code to show a few of these methods in action:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
&#13;
<code class="c1">// Boolean</code>&#13;
<code class="kd">let</code> <code class="nv">nightMode</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">bool</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"nightMode"</code><code class="p">)</code> <code class="c1">// true</code>&#13;
&#13;
<code class="c1">// Number</code>&#13;
<code class="kd">let</code> <code class="nv">playbackSpeed</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">double</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"playbackSpeed"</code><code class="p">)</code> <code class="c1">// 2.0</code>&#13;
&#13;
<code class="c1">// String</code>&#13;
<code class="kd">let</code> <code class="nv">locale</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">string</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"locale"</code><code class="p">)</code> <code class="c1">// "en-US"</code>&#13;
&#13;
<code class="c1">// URL</code>&#13;
<code class="kd">let</code> <code class="nv">apiURL</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"apiURL"</code><code class="p">)</code> <code class="c1">// https://www.example.com/api</code></pre>&#13;
&#13;
<p>Iterating through the list of methods called here, we can see <code>bool(forKey:)</code> returns a <code>Boolean</code> type, <code>double(forKey:)</code> returns a <code>Double</code>, <code>string(forKey:)</code> returns a <code>String</code>, and <code>url(forKey:)</code> returns a URL instance. There are some other types available, namely, other number types like <code>Int</code> and <code>Float</code>. Check out the <a href="https://oreil.ly/uIDX_">Apple developer docs</a> for more information on the types available for decoding for <code>UserDefaults</code>.</p>&#13;
&#13;
<p>That being said, there is one type conspicuously missing: the <code>SomeObject</code> class type we declared earlier in the chapter! In order to get a <code>SomeObject</code> returned, we need to use the <code>object(forKey:)</code> method like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// SomeObject NSCoding example</code>&#13;
<code class="kd">let</code> <code class="nv">someObject</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">object</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="s">"someObject"</code><code class="p">)</code> <code class="k">as</code><code class="p">?</code> <code class="n">SomeObject</code></pre>&#13;
&#13;
<p>Notice that we explicitly cast the object returned by <code>UserDefaults</code> to <code>SomeObject</code>. This can be skipped if there aren’t explicit type requirements and <code>Any?</code> will suffice.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177219763544">&#13;
<h5>Security of UserDefaults</h5>&#13;
<p>To<a data-primary="user preferences" data-secondary="iOS" data-tertiary="UserDefaults" data-type="indexterm" id="idm46177219762024"/><a data-primary="iOS" data-secondary="user preferences" data-tertiary="UserDefaults" data-type="indexterm" id="idm46177219753400"/><a data-primary="UserDefaults" data-secondary="security of" data-type="indexterm" id="idm46177219752184"/><a data-primary="Keychain (iOS)" data-type="indexterm" id="idm46177219751240"/><a data-primary="iOS" data-secondary="Keychain programming" data-type="indexterm" id="idm46177219750568"/> put it simply, <code>UserDefaults</code> is <em>not</em> secure. It’s possible to read the data saved because user defaults are stored as a plain-text XML file. To store secure data, it’s best to use the built-in Keychain in iOS.</p>&#13;
&#13;
<p>Unfortunately, Keychain programming is complex and error-prone unless a suitable wrapper is used. There are a number of third-party libraries available to make operating with the Keychain much easier. In addition, Apple has a recent, but no longer maintained, library called GenericKeychain as an example to help understand how to build a Keychain wrapper. You can find this code at <a href="https://oreil.ly/v9LXr">the sample code page</a> on Apple’s developer portal.</p>&#13;
&#13;
<p>There are too many third-party Keychain wrappers to recommend a specific one. It’s outside the scope of this book. The authors recommend you check out GitHub and find one of the popular Keychain wrapper libraries available for use and add it to your project.</p>&#13;
</div></aside>&#13;
&#13;
<p>So far, we’ve only talked about how to store data for a single user. Let’s talk about multiple users using your app and how we manage them in <code>UserDefaults</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Work with User Preferences in a Multiple User Application" data-type="sect2"><div class="sect2" id="idm46177219909768">&#13;
<h2>Work with User Preferences in a Multiple User Application</h2>&#13;
&#13;
<p>Unfortunately, this<a data-primary="user preferences" data-secondary="iOS" data-tertiary="multiple user applications" data-type="indexterm" id="idm46177219743752"/><a data-primary="iOS" data-secondary="user preferences" data-tertiary="multiple user applications" data-type="indexterm" id="idm46177219742504"/> is not a piece of out-of-the-box functionality provided by iOS, despite some tantalizingly close functionality available for macOS. That being said, it’s possible to work through this by storing user preferences in a separate file and restoring whenever it’s necessary to switch users. Here’s an example of how this might be accomplished:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">defaults</code> <code class="p">=</code> <code class="n">UserDefaults</code><code class="p">.</code><code class="n">standard</code>&#13;
&#13;
<code class="c1">// Get a dictionary representation of the current UserDefaults</code>&#13;
<code class="kd">let</code> <code class="nv">dictionary</code> <code class="p">=</code> <code class="n">defaults</code><code class="p">.</code><code class="n">dictionaryRepresentation</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Store the dictionary to disk</code>&#13;
<code class="kd">let</code> <code class="nv">oldData</code> <code class="p">=</code> <code class="k">try</code><code class="p">!</code> <code class="bp">NSKeyedArchiver</code><code class="p">.</code><code class="n">archivedData</code><code class="p">(</code>&#13;
    <code class="n">withRootObject</code><code class="p">:</code> <code class="n">dictionary</code><code class="p">,</code> <code class="n">requiringSecureCoding</code><code class="p">:</code> <code class="kc">true</code><code class="p">)</code>&#13;
<code class="k">try</code><code class="p">!</code> <code class="n">oldData</code><code class="p">.</code><code class="n">write</code><code class="p">(</code><code class="n">to</code><code class="p">:</code> <code class="nb">URL</code><code class="p">(</code><code class="n">fileURLWithPath</code><code class="p">:</code> <code class="s">"user1.plist"</code><code class="p">))</code>&#13;
&#13;
<code class="c1">// Remove all the data</code>&#13;
<code class="n">dictionary</code><code class="p">.</code><code class="n">keys</code><code class="p">.</code><code class="n">forEach</code> <code class="p">{</code> <code class="n">key</code> <code class="k">in</code>&#13;
    <code class="n">defaults</code><code class="p">.</code><code class="n">removeObject</code><code class="p">(</code><code class="n">forKey</code><code class="p">:</code> <code class="n">key</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Get the new user preferences</code>&#13;
<code class="kd">let</code> <code class="nv">newData</code> <code class="p">=</code> <code class="k">try</code><code class="p">!</code> <code class="n">Data</code><code class="p">(</code><code class="n">contentsOf</code><code class="p">:</code> <code class="nb">URL</code><code class="p">(</code><code class="n">fileURLWithPath</code><code class="p">:</code> <code class="s">"user2.plist"</code><code class="p">))</code>&#13;
<code class="k">if</code> <code class="kd">let</code> <code class="nv">newDictionary</code> <code class="p">=</code>&#13;
  <code class="k">try</code><code class="p">?</code> <code class="bp">NSKeyedUnarchiver</code><code class="p">.</code><code class="n">unarchiveTopLevelObjectWithData</code><code class="p">(</code><code class="n">newData</code><code class="p">)</code> <code class="k">as</code><code class="p">?</code> <code class="p">[</code><code class="nb">String</code><code class="p">:</code> <code class="nb">Any</code><code class="p">]</code> <code class="p">{</code>&#13;
    <code class="c1">// Update UserDefaults with the new data</code>&#13;
    <code class="n">newDictionary</code><code class="p">.</code><code class="n">forEach</code> <code class="p">{</code> <code class="p">(</code><code class="n">keyValue</code><code class="p">)</code> <code class="k">in</code>&#13;
        <code class="kd">let</code> <code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">)</code> <code class="p">=</code> <code class="n">keyValue</code>&#13;
        <code class="n">defaults</code><code class="p">.</code><code class="kr">set</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">forKey</code><code class="p">:</code> <code class="n">key</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s walk through what’s happening.</p>&#13;
&#13;
<p>First, we get a <code>Dictionary</code> representation of our <code>UserDefaults</code> data. This is used to back up our existing user’s data. Let’s call this user “User 1.” We take that dictionary and use <code>NSKeyedArchiver</code> to transform that dictionary into a <code>Data</code> instance that can then be written to a shared area of the app, most likely inside the app’s <em>Library/Preferences</em> folder, but that is an exercise left to the reader. In our example, we store it to a file path of <em>user1.plist</em>.</p>&#13;
&#13;
<p>Going further in the code, we iterate through each key inside the dictionary and then call <code>removeObject(forKey:)</code> on <code>UserDefaults</code> to clear out all that data from <code><span class="keep-together">UserDefaults</span></code>.</p>&#13;
&#13;
<p>Finally, it’s time to start using the new user’s data; let’s call this user “User 2.” User 2 has a preferences file stored at <em>user2.plist</em>, so we take that file’s <code>Data</code> representation, pass it to <code>NSKeyedUnarchiver</code>, and decode it to a dictionary object as <code>[String: Any]</code>, which is the same type that it was originally written from. To add the data to <code>UserDefaults</code>, we iterate over each key in our new dictionary and manually set it to <code>UserDefaults</code> directly.</p>&#13;
&#13;
<p>This is not the cleanest, simplest process, but it works. Future versions of iOS could offer support for multiple user accounts. For now, this solution is workable. It’s possible that a large user preferences list could take some time to write. Thankfully, <code><span class="keep-together">UserDefaults</span></code> is thread-safe, so all this work could easily be done in a background thread.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177219568280">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>There are few things to take away from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Using an out-of-the-box technology provided by the operating system is a great way to get started storing user preferences. In fact, it’s possible to build powerful systems and processes that apps can follow just using this approach.</p>&#13;
</li>&#13;
<li>&#13;
<p>Both Android and iOS have similar approaches to storing and reading back user preferences. Android uses <code>SharedPreferences</code>, and iOS uses <code>UserDefaults</code>. The both provide a key-value store in which to save data between sessions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We’ve talked mostly about storing data on-device with regards to user preferences. There are other standard formats, such as XML and JSON, that both platforms have excellent support for as well. Let’s learn about more advanced serialization of data in the next chapter on serialization and transports.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>