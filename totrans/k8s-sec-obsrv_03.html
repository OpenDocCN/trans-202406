<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Workload Deployment Controls"><div class="chapter" id="workload_deployment_controls">
    <h1><span class="label">Chapter 3. </span>Workload Deployment Controls</h1>
    
    
<p class="byline plain">With contributions from Manoj Ahuje,</p> 
<p class="byline">Senior Threat Intelligence Research Engineer at Tigera</p> 
    
    <p>Once you decide on a strategy for infrastructure security, next in line is workload deployment controls. In this
        chapter we will look at image building and scanning strategy, CI/CD (integrating image scanning into builds),
        and Kubernetes role-based access control (RBAC), which is a widely used authorization system that allows you <span class="keep-together">to
        define</span> access control based on user roles, and secrets management for your <span class="keep-together">applications.</span></p>
    <section data-type="sect1" data-pdf-bookmark="Image Building and Scanning"><div class="sect1" id="image_building_and_scanning">
        <h1>Image Building and Scanning</h1>
        <p>In this section we will explore best practices for image building and scanning.<a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deployment controls" data-tertiary="image building and scanning" id="ch03-ibs"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="deployment controls" data-tertiary="image building and scanning" id="ch03-ibs2"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image scanning" data-tertiary="workload deployment controls" id="ch03-ibs3"/><a contenteditable="false" data-type="indexterm" data-primary="image building" id="ch03-ibs4"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image building" id="ch03-ibs5"/><a contenteditable="false" data-type="indexterm" data-primary="attack surface" data-secondary="base image choice" id="ch03-choi"/> These include choosing a base image to
            reduce attack surface and using scratch images and image hardening best practices to deter adversaries.
            Image scanning dives into the nuances of choosing an image scanning solution, privacy concerns, and an
            overview of container threat analysis solutions.</p>
        <section data-type="sect2" data-pdf-bookmark="Choice of a Base Image"><div class="sect2" id="choice_of_a_base_image">
            <h2>Choice of a Base Image</h2>
            <p>As discussed in the previous chapter, you can choose modern Linux distributions<a contenteditable="false" data-type="indexterm" data-primary="image building" data-secondary="base image choice" id="ch03-ibis"/><a contenteditable="false" data-type="indexterm" data-primary="Linux distributions" data-secondary="base image choice" id="idm45326833053856"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image building" data-tertiary="base image choice" id="idm45326833052480"/><a contenteditable="false" data-type="indexterm" data-primary="base container image" data-secondary="choosing" id="idm45326833050832"/> like Bottlerocket as base images for containers. The minimal
                version of traditional Linux distributions, like Ubuntu, Red Hat, and Alpine, are available too.</p>
            <p>Though it’s a good starting point to begin with a minimal image, the minimal image approach doesn’t stop
                vulnerabilities being discovered in OS packages that are present in the OS. <a contenteditable="false" data-type="indexterm" data-primary="scratch images" id="ch03-scr"/><a contenteditable="false" data-type="indexterm" data-primary="Dockerfile-based container images" data-secondary="scratch images" id="ch03-scr2"/><a contenteditable="false" data-type="indexterm" data-primary="distroless images" id="idm45326833045456"/>In this case distroless or scratch
                images turn out to be a better option. These types of images only contain the application and its
                specific runtime dependencies.</p>
            <p>Here are the benefits of distroless or scratch images:</p>
            <ul>
                <li>
                    <p>This strategy reduces size, attack surface, and vulnerabilities significantly, which results in
                        better security posture.</p>
                </li>
                <li>
                    <p>Distroless images are production ready. Kubernetes itself uses distroless images for various
                        components like kublet, scheduler, etc.</p>
                </li>
                <li>
                    <p>In case you are going for a scratch base image for your application, a multistage Dockerfile can
                        be used to build a scratch image. The first stage involves building your application. The second
                        stage involves moving runtime dependencies and applications to scratch.</p>
                </li>
            </ul>
            <p>The most popular example of a distroless image project<a contenteditable="false" data-type="indexterm" data-primary="distroless images" data-secondary="example project" id="idm45326833039472"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="distroless image example" id="idm45326833038096"/> is <a href="https://oreil.ly/UIzu0">distroless from Google</a>, which provides images for various runtimes like Java, Python, or C++.</p>
            <p>A scratch image starts with the Dockerfile instruction FROM:scratch, which signifies an empty filesystem.
                The following instruction in Dockerfile creates the first filesystem layer of the container image. Here,
                the first filesystem layer needs to be compiled with the application and dependencies. <a contenteditable="false" data-type="indexterm" data-primary="Dockerfile-based container images" data-secondary="scratch images" data-tertiary="multistage builds documentation link" id="idm45326833035088"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="Dockerfile multistage builds documentation" id="idm45326833033408"/>Since it’s nonproductive and
                nonintuitive to build applications outside of the container, Docker introduced <a href="https://oreil.ly/K161o">multistage
                builds</a>. With a multistage build, multiple FROM instructions are allowed in a Dockerfile. Each FROM
                instruction creates a separate stage, and the filesystem artifact from a previous stage can be copied in
                a later stage of the build. This mechanism enabled developers to build and compile applications in an
                earlier stage (builder image) with all dependencies available, and eventually only copy the filesystem
                artifacts required to run the production application in a later stage. The last stage of the build can
                be a scratch image where only application binaries and dependencies are required to be present on the
                resulting image.</p>
            <p>Following is an example of a scratch-based image for a bash script, where the goal is to run a script
                within a container. Here you can create a two-stage Dockerfile where the second stage is a scratch image
                containing only the dependencies for the script.</p>
            <p>You can use this template to containerize even complex applications built with Node.js, Python, and Go.
                Go additionally provides an option to compile all the runtime libraries into the binary. In the
                following example, you can use Alpine as the base image to construct a scratch image for a container
                that runs a script:</p>
            <pre data-code-language="yaml" class="less_space pagebreak-before"><code class="c1"># use alpine 3 as base image</code>
<code class="l-Scalar-Plain">FROM alpine:3 as builder</code>

<code class="l-Scalar-Plain"># upgrade all alpine packages</code>
<code class="l-Scalar-Plain">RUN apk update &amp;&amp; apk upgrade</code>

<code class="l-Scalar-Plain"># add your script into container fs</code>
<code class="l-Scalar-Plain">ADD your_init_script.sh your_init_script.sh</code>
<code class="l-Scalar-Plain">RUN chmod u+x your_init_script.sh</code>

<code class="l-Scalar-Plain"># stage 2</code>
<code class="l-Scalar-Plain">FROM scratch</code>

<code class="l-Scalar-Plain"># shell</code>
<code class="l-Scalar-Plain">COPY --from=builder /bin/sh /bin/sh</code>

<code class="l-Scalar-Plain"># dependent linux shared libraries</code>
<code class="l-Scalar-Plain">COPY --from=builder /lib/ld-musl-x86_64.so.1 /lib/ld-musl-x86_64.so.1</code>

<code class="l-Scalar-Plain">ENV PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin</code><code class="p-Indicator">:</code>
<code class="l-Scalar-Plain">/sbin:/bin</code>

<code class="l-Scalar-Plain">ENTRYPOINT ["./your_init_script.sh"]</code>
<code class="l-Scalar-Plain">In this example, only two files are copied into scratch images (second stage).</code> 
<code class="l-Scalar-Plain">Hence, the alpine base image containing more than five thousand files is minimized</code> 
<code class="l-Scalar-Plain">to two files, reducing the attack surface significantly.</code></pre>
            <p>Now that we have reviewed how to choose a base image for your container, let’s explore container image
                hardening.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-ibis" id="idm45326833008880"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-scr" id="idm45326833007664"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-scr2" id="idm45326833006288"/></p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Container Image Hardening"><div class="sect2" id="container_image_hardening">
            <h2>Container Image Hardening</h2>
            <p>Container image hardening is the process of building images to reduce<a contenteditable="false" data-type="indexterm" data-primary="image building" data-secondary="container image hardening" id="idm45326833003120"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image building" data-tertiary="container image hardening" id="idm45326833001680"/><a contenteditable="false" data-type="indexterm" data-primary="Dockerfile-based container images" data-secondary="container image hardening" id="idm45326833000016"/> security weaknesses and attack surface. At the
                same time, it is used to add defensive layers to run applications securely within the container.</p>
            <p>If you use a nonhardened container image, it can be prone to abuse, information disclosure, or easier
                privilege escalation to the container host. You should leverage the following tools and best practices
                to build hardened container images for your <span class="keep-together">applications:</span><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-choi" id="idm45326832967376"/></p>
            <ul>
                <li>
                    <p>Only use base images from trusted sources, such as official Ubuntu and Red Hat release channels,
                        and double-check the image hash with released information, as it’s relatively easy to embed
                        malicious code like cryptominers into an image and make that image available on a repository
                        like Docker Hub.</p>
                </li>
                <li>
                    <p>Minimize your base images to only contain runtime dependencies for your <span class="keep-together">application.</span><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="minimizing base image" id="idm45326832962912"/><a contenteditable="false" data-type="indexterm" data-primary="base container image" data-secondary="minimizing" id="idm45326832961536"/><a contenteditable="false" data-type="indexterm" data-primary="Dockerfile-based container images" data-secondary="minimizing base image" id="idm45326832960160"/></p>
                </li>
                <li>
                    <p>Follow the principle of least privilege access and run containers <a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="Principle of Least Privileges strategy" id="idm45326832957952"/><a contenteditable="false" data-type="indexterm" data-primary="Principle of Least Privileges strategy" id="idm45326832956592"/>with
                        the minimum required permissions. For example, run containers as nonroot unless root privileges
                        are necessary. This makes it difficult for the attackers to escape the container and provides
                        protection from <a contenteditable="false" data-type="indexterm" data-primary="common vulnerability enumerations (CVEs)" data-secondary="root user escaping container" id="idm45326832955040"/>vulnerabilities like <em><a href="https://oreil.ly/txXJL">CVE-2020-15257</a></em>,
                        where the root user was able to escape the container.</p>
                </li>
                <li>
                    <p>Do not use tags for Docker images; rather, pin the base image <a contenteditable="false" data-type="indexterm" data-primary="Dockerfile-based container images" data-secondary="tags not used" id="idm45326832951600"/><a contenteditable="false" data-type="indexterm" data-primary="base container image" data-secondary="pinning base image version" id="idm45326832950208"/><a contenteditable="false" data-type="indexterm" data-primary="tags for Docker images" id="idm45326832948816"/>version in the Dockerfile (i.e., ubuntu:20.08).
                        Mutable tags like <em>latest</em> or <em>master</em> are updated constantly with features and
                        fixes, which can cause issues while scanning images as a part of your CI/CD pipeline.
                        Additionally, they can cause stability issues for an application (where the underlying dependant
                        library is updated/removed or changed).</p>
                </li>
                <li>
                    <p>Compress Docker image layers into one single layer. Container<a contenteditable="false" data-type="indexterm" data-primary="Dockerfile-based container images" data-secondary="compressing image layers" id="idm45326832945392"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="compressing image layers" id="idm45326832943984"/> images built with tools like Docker or
                        buildah often have multiple layers. These layers show a development history and sometimes end up
                        leaking sensitive information. The best way to compress existing layers is to use a multistage
                        build; there is also an experimental Docker feature (i.e., option <a href="https://oreil.ly/U5RaL"><code>--squash</code></a>
                        available in Docker API 1.25+).</p>
                </li>
                <li>
                    <p>Use container image signing to trust the image. Natively, Kubernetes doesn’t have container image
                        verification. Docker Notary can be used to sign images, and by using the Kubernetes admission
                        controller, it is possible to verify an image signature and determine if an image was tampered
                        with by a malicious actor (e.g., if the image is changed while it is seated at the registry).
                    </p>
                </li>
            </ul>
            <p>In the next section, we will review container image scanning.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Container Image Scanning Solution"><div class="sect2" id="container_image_scanning_solution">
            <h2>Container Image Scanning Solution</h2>
            <p>Container image scanning tools examine the container filesystem to <a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="deployment controls" id="idm45326832937376"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="container image scanning" id="idm45326832935920"/><a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="CI/CD" data-tertiary="about" id="idm45326832934560"/>get the
                metadata to know if there are vulnerable components present in the image. There are many open source and
                commercial enterprise solutions available in the market that you can use for this purpose. They come
                with CI/CD integrations and a rich set of scanning features. The solution you choose should answer some of these basic <span class="keep-together">questions:</span></p>
            <ul>
                <li>
                    <p>Can the image scanner scan OS packages present in a container image for your selected base image?
                    </p>
                </li>
                <li>
                    <p>Can it scan your application dependencies (does it understand languages used by your application,
                        e.g., Go, Python, Node.js)?</p>
                </li>
                <li>
                    <p>Can the image scanner detect sensitive files present in the filesystem (certificates, passwords)?
                    </p>
                </li>
                <li>
                    <p>What is the false positive rate?</p>
                </li>
                <li>
                    <p>Can it scan binaries (.elf or .exe)?</p>
                </li>
                <li>
                    <p>What data will be collected by the scanning solution? Does the scanning solution upload your
                        image to its SaaS service, or does the solution only collect package metadata? It is important
                        to understand this due to the risk of data exposure.</p>
                </li>
                <li>
                    <p>Where will the collected data be stored? On-prem or cloud SaaS? Please review this and choose the
                        option that works with the guidelines set by your security/compliance teams.</p>
                </li>
                <li>
                    <p>Does the image scanner have an integration with your CI/CD system?</p>
                </li>
            </ul>
            <p>Most scanners collect metadata from filesystems and try to match it with <a contenteditable="false" data-type="indexterm" data-primary="National Vulnerability Database" data-secondary="container image scanning" id="idm45326832922944"/><a contenteditable="false" data-type="indexterm" data-primary="common vulnerability enumerations (CVEs)" data-secondary="container image scanning" id="idm45326832921536"/>vulnerability information gathered from sources
                such as the National Vulnerability Database or private intelligence sources to determine the presence of
                vulnerability. Please note that you should expect both false positives and negatives as a part of
                scanning. For images with confirmed vulnerabilities, the application and the security team need to work
                together to analyze the impact and the risk of the CVE to your operation. Remediation steps involve
                implementing workarounds and patching the image when an update is available.</p>
            <p>Many public cloud providers and container registry service providers offer container scanning services.
                However, there are limitations to the OS versions they support, and most of them don’t scan application
                dependencies. <a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="container image scanning tools" id="idm45326832918672"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image scanning" data-tertiary="open source tools" id="idm45326832917280"/><a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="open source tools" id="idm45326832915632"/>Here the open source
                world has more to offer. Notable examples of open source tools that can scan application dependencies
                are <a href="https://oreil.ly/QNdyU">Anchore</a>, which lets users define policy, and
                <a href="https://oreil.ly/CYP4B">Trivy</a>, which is easy to integrate in CI.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Privacy Concerns"><div class="sect2" id="privacy_concerns">
            <h2>Privacy Concerns</h2>
            <p>Security vulnerabilities and associated information in your product is highly classified data,<a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="privacy concerns" id="idm45326832910736"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image scanning" data-tertiary="privacy concerns" id="idm45326832909360"/><a contenteditable="false" data-type="indexterm" data-primary="privacy and container image scanning" id="idm45326832907712"/> and in the wrong hands it could be a
                big liability to the organization. That’s why before you choose any solution, it’s good practice to
                verify what data is being collected by a scanning solution and where that data is stored (e.g., within
                the enterprise on-premise or in the cloud as a part of an SaaS service). If you are buying a commercial
                solution, it is important to check the contract to know the clauses for damages in case of data breach.
                Often these clauses can help you understand how serious an organization is about data security. In case
                you are using an open source solution, please review the documentation to understand the risks of data
                leakage.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Container Threat Analysis"><div class="sect2" id="container_threat_analysis">
            <h2>Container Threat Analysis</h2>
            <p>In addition to traditional image scanning, the area of container threat analysis<a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="container threat analysis" id="idm45326832903600"/><a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="container threat analysis" id="idm45326832902208"/> using sandbox-based solutions is gaining
                popularity. It is a relatively new area, and we recommend you watch it. These sandbox-based solutions
                can run Docker images and monitor for container system calls, processes, memory, network traffic (HTTP,
                DNS, SSL, TCP), and overall behavior of the container, using machine learning and other techniques to
                determine any malicious activity. Additionally, they can scan container filesystems to check for
                vulnerabilities as well as malicious binaries. <a contenteditable="false" data-type="indexterm" data-primary="advanced persistent threats (APTs)" id="idm45326832900096"/>These can be used to detect advanced
                persistent threats (APTs) and malware.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-ibs" id="idm45326832898736"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-ibs2" id="idm45326832897360"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-ibs3" id="idm45326832895984"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-ibs4" id="idm45326832894608"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-ibs5" id="idm45326832893232"/></p>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="CI/CD"><div class="sect1" id="cisoliduscd">
        <h1>CI/CD</h1>
        <p>In this section we will cover various strategies to integrate image scanning<a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deployment controls" data-tertiary="CI/CD" id="idm45326832889728"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="deployment controls" data-tertiary="CI/CD" id="idm45326832888080"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image scanning" data-tertiary="CI/CD" id="idm45326832886432"/>
            solutions into your CI/CD pipeline, best practices to secure your CI/CD pipelines, and techniques to implement
            organizational policies for CI/CD and vulnerability scanning.</p>
        <p>Continuous integration (CI) is a development practice in which each<a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="about" id="idm45326832884032"/><a contenteditable="false" data-type="indexterm" data-primary="continuous integration and continuous delivery" data-see="CI/CD" id="idm45326832882544"/> developer’s
            check-in is verified by an automated build, allowing teams to detect problems early. And continuous
            deployment (CD) is the extension of CI where changes are released for downstream consumers once they pass
            all release checks.</p>
        <p>Integrating security at each step of the development and release process is the goal of CI/CD, which is an
            integral part of shift-left strategy in DevOps processes. <a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="container image scanning" id="idm45326832880112"/><a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="CI/CD" data-tertiary="about" id="idm45326832878736"/>By integrating
            image scanning into your CI/CD pipeline (see <a data-type="xref" href="#integrating_image_scanning_into_the_cis">Figure 3-1</a>),
            development teams can have a verdict available as soon as a check-in from a developer is committed to the
            repository. The main advantage of this approach is that new security vulnerabilities or threats can be
            detected at build time. Once an issue is found, all stakeholders and DevOps teams can be notified, typically
            by failing the CI job. Then respective teams can start working on remediation immediately.</p>
        <figure><div id="integrating_image_scanning_into_the_cis" class="figure">
            <img src="Images/ksao_0301.png" alt="" width="925" height="890"/>
            <h6><span class="label">Figure 3-1. </span>Integrating image scanning into the CI/CD process</h6>
        </div></figure>
        <p>As shown in <a data-type="xref" href="#integrating_image_scanning_into_the_cis">Figure 3-1</a>, the scanning should be integrated at each step of the development cycle, from
            the developer check-in to continuous delivery to production. The rest of this section will be focused on the
            CI part of the integration to show the <span class="keep-together">granularity</span> of the image scanning process. The following strategies
            can be applied to each step shown in <a data-type="xref" href="#integrating_image_scanning_into_the_cis">Figure 3-1</a> (i.e.,
            code, build [CI], and CD pipeline).</p>
        <p>The choice of the specific CI/CD build infrastructure is secondary and can be chosen according to wider
            requirements. <a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="provider links" id="idm45326832868992"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="CI/CD providers" id="idm45326832867520"/><a contenteditable="false" data-type="indexterm" data-primary="CircleCI CI/CD provider" id="idm45326832866144"/><a contenteditable="false" data-type="indexterm" data-primary="Jenkins CI/CD provider" id="idm45326832865040"/><a contenteditable="false" data-type="indexterm" data-primary="Semaphore CI/CD provider" id="idm45326832863936"/>Popular CI/CD providers include
            but are not limited to <a href="https://oreil.ly/ge9Q1">Jenkins</a>, <a href="https://oreil.ly/xpiFH">Semaphore</a>, and <a href="https://circleci.com">CircleCI</a>. There
            are four main ways to integrate image scanning into your CI/CD pipeline and build infrastructure, as shown in
            <a data-type="xref" href="#image_scanning_integrated_as_a_part_of">Figure 3-2</a>.</p>
                <figure><div id="image_scanning_integrated_as_a_part_of" class="figure">
                <img src="Images/ksao_0302.png" alt="" width="1247" height="691"/>
                <h6><span class="label">Figure 3-2. </span>Image scanning integrated as a part of the image registry</h6>
            </div></figure>
        <section data-type="sect2" data-pdf-bookmark="Scan Images by Registry Scanning Services"><div class="sect2" id="scan_images_by_registry_scanning_servic">
            <h2>Scan Images by Registry Scanning Services</h2>
<p>As illustrated in <a data-type="xref" href="#image_scanning_integrated_as_a_part_of">Figure 3-2</a>, in this
 approach as soon<a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="CI/CD" data-tertiary="registry scanning services" id="idm45326832854448"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="container image scanning" data-tertiary="registry scanning services" id="idm45326832852768"/><a contenteditable="false" data-type="indexterm" data-primary="registry scanning services" id="idm45326832851056"/>
 as a check-in is available from the developer, CI builds and pushes images to the registry. Then images are periodically scanned by the services integrated within the registry. There are many downsides to
 this approach; registry providers usually limit themselves to scanning the operating system package layer (e.g., GCR and Quay). Since they show limited information, using vulnerability whitelisting, classification, and tracking timelines to fix various issues can be really cumbersome. Also, most of the time there is no option to write policy tailored to your organization’s needs.</p>
            
<p>When the image scanner finds an issue, the image may have already been consumed or delivered using CD. The registry doesn’t keep track of which consumed images consumed and who deployed them. Users using those images may be at risk of compromise and not even know about the vulnerabilities identified by the registry scanning service. Vulnerability remediation only comes after notification, which can be an alert or email to the development team and other stakeholders. It can be anything from a simple update from the upstream provider to complex code and a configuration fix. This kind of
                remediation effort tends to lag behind the development process.</p>
            <p><a data-type="xref" href="#image_scanning_as_a_part_of_the_build_p">Figure 3-3</a> shows
                how images are built and scanned as a part of the CI process, but images are pushed to the internal
                registry without considering a verdict from the scanner. If you are an agile DevOps team, you may be
                building and pushing images to your internal registry every day or every hour as soon as a check-in is
                available on multiple branches. In this case, you don’t want every build to be failing as a part of CI
                if there is a vulnerability present in the image. Rather, you would get a notification for a
                vulnerability, and the developer can fix that vulnerability before CD kicks in.</p>
                <figure class="width-90"><div id="image_scanning_as_a_part_of_the_build_p" class="figure">
                <img src="Images/ksao_0303.png" alt="" width="1300" height="689"/>
                <h6><span class="label">Figure 3-3. </span>Image scanning as a part of the build process</h6>
            </div></figure>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Scan Images After Builds"><div class="sect2" id="scan_images_after_builds">
            <h2>Scan Images After Builds</h2>
            <p>The drawback of the approach is that even though every image<a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="CI/CD" data-tertiary="after builds" id="idm45326832841984"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="container image scanning" data-tertiary="after builds" id="idm45326832840256"/> is scanned right
                after it is built, there is no mechanism to force developers to fix found issues immediately.
                Additionally, images are available for internal consumption from the registry even if vulnerability is
                detected, and therefore it could be a weak link in the organization, which can lead to the compromise.
            </p>
            
            <p>As illustrated in <a data-type="xref" href="#image_scanning_inline_as_a_part_of_the">Figure 3-4</a>, a CI job
                kicks in with a check-in from the developer, which builds and subsequently scans the images. Once the
                scan is complete, a verdict from the image scanner is evaluated. If it passes, then images are pushed to
                the registry for internal consumption. If it fails, the developer needs to remediate the issue
                immediately, as they won’t have the latest build available with their changes.</p>
                <figure class="width-90"><div id="image_scanning_inline_as_a_part_of_the" class="figure">
                <img src="Images/ksao_0304.png" alt="" width="1380" height="681"/>
                <h6><span class="label">Figure 3-4. </span>Image scanning inline as a part of the CI/CD process</h6>
            </div></figure>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Inline Image Scanning"><div class="sect2" id="inline_image_scanning">
            <h2>Inline Image Scanning</h2>
            <p>This pipeline can be difficult to manage initially, depending on the size<a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="CI/CD" data-tertiary="inline image scanning" id="idm45326832831824"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="container image scanning" data-tertiary="inline image scanning" id="idm45326832830080"/> and
                velocity of your organization, but once it is mastered, the organization gets much better control over
                its security posture. The same pipeline design can be utilized in your CD jobs so that your applications are the most secure at
                the time of release/deployment.</p>
            <p>Kubernetes admission controllers can intercept pod creation requests from the Kubernetes API (see <a data-type="xref" href="#_image_scanning_as_a_part_of_pod_creati">Figure 3-5</a>). This
                mechanism can be used as a last-minute check by triggering a CI job to scan an image that is being
                deployed on the cluster. Depending on the verdict of the scan, the admission controller can admit or
                kick out the pod.</p>
                <figure class="width-90"><div id="_image_scanning_as_a_part_of_pod_creati" class="figure">
                <img src="Images/ksao_0305.png" alt="" width="1442" height="744"/>
                <h6><span class="label">Figure 3-5. </span>Image scanning as a part of pod creation</h6>
            </div></figure>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Kubernetes Admission Controller"><div class="sect2" id="kubernetes_admission_controller">
            <h2>Kubernetes Admission Controller</h2>
            <p>This method usually needs a custom or off-the-shelf admission controller<a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="CI/CD" data-tertiary="admission controller" id="idm45326832822144"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="container image scanning" data-tertiary="admission controller" id="idm45326832820304"/><a contenteditable="false" data-type="indexterm" data-primary="admission controllers" data-secondary="container image scanning" id="idm45326832818496"/><a contenteditable="false" data-type="indexterm" data-primary="admission controllers" data-secondary="container image scanning" data-tertiary="failing open or failing closed" id="idm45326832817104"/> that is able to talk to admission servers
                that respond with a verdict for the scan performed. From a fault tolerance point of view, it’s worth
                noting that if the admission server fails for some reason, then it can impact pod creation in the
                entire cluster. Whether you want the admission controller to “fail open” (i.e., go ahead with pod
                creation) or “fail close” (i.e., prevent all pod creation) in the event of admission server failure is
                the organization’s decision; weigh the security risks against the fault tolerance risks.</p>
            
            <p>Since admission controllers are a last-minute check, usually development teams are unaware of the found
                security vulnerabilities until they look at what is being scanned and rejected at the moment. So it is
                recommended that this approach be used in combination with earlier methods as a part of your defense
                strategy.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Securing the CI/CD Pipeline"><div class="sect2" id="securing_the_cisoliduscd_pipeline">
            <h2>Securing the CI/CD Pipeline</h2>
            <p>CI/CD pipelines’ autonomous nature and minimum human interaction<a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="securing the pipeline" id="idm45326832811760"/><a contenteditable="false" data-type="indexterm" data-primary="best practices" data-secondary="securing CI/CD pipeline" id="idm45326832810336"/> makes CI/CD an
                attractive target for attackers. Additionally, the development environment can be overly permissive with
                a minimum focus on security. Following are the best practices to secure your CI/CD pipelines.</p>
            <section data-type="sect3" data-pdf-bookmark="Zero-trust policy for CI/CD environment"><div class="sect3" id="zero_trust_policy_for_cisoliduscd_envir">
                <h3>Zero-trust policy for CI/CD environment</h3>
                <p>Every connection to and from your CI/CD pipeline needs to be scrutinized<a contenteditable="false" data-type="indexterm" data-primary="policies" data-secondary="zero-trust policy in CI/CD security" id="idm45326832806816"/><a contenteditable="false" data-type="indexterm" data-primary="zero-trust policy in CI/CD pipeline security" id="idm45326832805280"/>
                    with a zero-trust policy in place for underlying hosts, infrastructure, and any supporting processes
                    according to your threat model. This will ensure that egress and ingress access to the CI/CD
                    pipeline is managed through a secure policy.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Secure secrets"><div class="sect3" id="secure_secrets">
                <h3>Secure secrets</h3>
                <p>Review each secret required by your CI/CD pipeline and make sure<a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="CI/CD pipeline security" id="idm45326832801840"/>
                    passwords, access tokens, and encryption keys are called only when required. The design of secrets
                    management needs to consider fine-grained access to secrets, secret usage and changelog
                    capabilities, automated secret rotation, and deactivation and deprecation. We will discuss more
                    about secrets management in the upcoming section of this chapter to help you choose the right
                    strategy.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Access control"><div class="sect3" id="access_control">
                <h3>Access control</h3>
                <p>Tight access control to CI/CD resources and the separation of user <a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="CI/CD pipeline security" id="idm45326832797904"/>responsibilities is the key to a secure CI/CD
                    pipeline, whether you have a role-based, time-based, or task-based approach. Access control needs to
                    segment the access to the pipeline so that in case of compromise, the blast radius is reduced
                    significantly. Also, use a strong authentication mechanism with two-factor authentication
                    enabled by default.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Audit and monitoring"><div class="sect3" id="audit_and_monitoring">
                <h3>Audit and monitoring</h3>
                <p>Access to CI/CD resources needs continuous auditing and monitoring<a contenteditable="false" data-type="indexterm" data-primary="audit logs" data-secondary="CI/CD pipeline security" id="idm45326832794016"/><a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="audit logs" data-tertiary="CI/CD pipeline security" id="idm45326832792560"/><a contenteditable="false" data-type="indexterm" data-primary="monitoring" data-secondary="CI/CD pipeline security" id="idm45326832790912"/> to determine excessive access, access
                    deprecation in case a user leaves the organization or changes job roles, abuse, or suspicious user
                    behavior.</p>
            </div></section>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Organization Policy"><div class="sect1" id="organization_policy">
        <h1>Organization Policy</h1>
        <p>To tackle challenges presented by CI/CD pipelines and scanning,<a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deployment controls" data-tertiary="organization policy" id="ch03-org"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="deployment controls" data-tertiary="organization policy" id="ch03-org2"/><a contenteditable="false" data-type="indexterm" data-primary="organization policy on deployment controls" id="ch03-org3"/><a contenteditable="false" data-type="indexterm" data-primary="policies" data-secondary="organization policies on deployment controls" id="ch03-org4"/><a contenteditable="false" data-type="indexterm" data-primary="policies" data-secondary="network policies" data-see="network policies" id="idm45326832780160"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="container image scanning" data-tertiary="organization policy" id="ch03-org5"/>
            a global organization policy is required. The policy needs to call out access requirements to CI/CD
            resources, separation of user responsibilities, secret management, logging and monitoring requirements, and
            audit policy.</p>
        <p>Vulnerability scans can overwhelm teams initially. Hence, development, DevOps, and security teams need clear
            directives on product vulnerability discovery and assessment, risk, remediation, and timelines to close the
            issues based on the organization’s threat model.</p>
        <p>Vulnerability scanning solutions can have codified policies where images can be admitted or rejected based on
            scan results and the risk tolerance of the organization.</p>
        <p>The process to build an effective policy needs to be iterative and based on continuous feedback to achieve a
            tailored policy, balancing security and performance according to your industry, size, workflows, and
            compliance requirements.</p>
        <section data-type="sect2" data-pdf-bookmark="Secrets Management"><div class="sect2" id="secrets_management">
            <h2>Secrets Management</h2>
            <p>A secret can be anything that is used to authenticate and authorize<a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="organization policy" id="idm45326832772448"/> users,
                groups, or entities. It can be a username/passwords, API token, or TLS certificate. When an application
                or microservice is moved to Kubernetes, the early design choice developers need to make is where to
                store these secrets and how to retrieve them and make them available in an application as needed without
                compromising the security posture of the application. Following are the top methods to achieve this
                objective.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="etcd to Store Secrets"><div class="sect2" id="etcd_to_store_secrets">
            <h2>etcd to Store Secrets</h2>
            <p>A common scenario for an application moving to Kubernetes is to store<a contenteditable="false" data-type="indexterm" data-primary="etcd datastore" data-secondary="organization policy" id="idm45326832768304"/>
                a secret in a Base64-encoded format in etcd as a key-value pair. Etcd is a supported datastore in
                Kubernetes deployments. These secrets can be made available inside the container as a volume mount or an
                environment variable from within Kubernetes deployment specs. Since environment variables are stored in
                memory, it’s hard to extract secrets, compared with volume mounts, which store secrets on a container
                filesystem. The access to etcd is backed by Kubernetes RBAC, which brings needed security and
                <span class="keep-together">flexibility.</span></p>
            <p>Etcd provides strong concurrency primitives, linearizable reads, and APIs to manage secrets at scale. The
                downside of this approach is secrets are stored in plain text (Base64 encoding) and are retrieved and
                sent in plain text unless etcd is configured to encrypt communication using TLS. In <a data-type="xref" href="ch02.xhtml#infrastructure_security">Chapter 2</a>, you learned the strategy to encrypt
                data at rest, where secrets can be encrypted while they are stored in etcd.</p>
            <p>Additionally, secrets stored in etcd are not versioned or recoverable once deleted, and access to etcd is
                not audited, so anyone who has access to etcd can access all secrets. Since etcd is a Kubernetes
                datastore, the broader secrets management requirements of the organization are not fulfilled.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Secrets Management Service"><div class="sect2" id="secrets_management_service">
            <h2>Secrets Management Service</h2>
            <p>To solve the organization’s encryption and secrets management<a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management services" id="idm45326832761088"/><a contenteditable="false" data-type="indexterm" data-primary="cloud environments" data-secondary="secrets management services" id="idm45326832759632"/> requirement, secrets management services can
                be utilized from cloud providers. All major public cloud providers provide secrets management services.
            </p>
            <p>The most popular cloud providers’ secrets management<a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="secrets management services" id="idm45326832757232"/><a contenteditable="false" data-type="indexterm" data-primary="AWS (Amazon Web Services)" data-secondary="Secrets Manager" id="idm45326832755888"/><a contenteditable="false" data-type="indexterm" data-primary="Google Secret Manager" id="idm45326832754496"/><a contenteditable="false" data-type="indexterm" data-primary="Azure Key Vault" id="idm45326832753392"/> services are <a href="https://oreil.ly/7tuNL">AWS Secrets Manager</a>, <a href="https://oreil.ly/JnfOA">Google Secret Manager</a>, and <a href="https://oreil.ly/MaMgd">Azure Key Vault</a>.</p>
            <p>A notable third-party example is <a href="https://oreil.ly/xDMd3">HashiCorp Vault</a>, <a contenteditable="false" data-type="indexterm" data-primary="HashiCorp Vault" id="idm45326832748992"/>which can be
                used as a centralized secrets manager. It provides many features to fulfill an organization’s
                end-to-end secrets management requirements (key management, encryption, rotation, PKI, storage,
                replication, revocation, logging, monitoring, audit, etc.). This tool can be used in conjunction with a
                cloud provider’s secrets management services—for example, when the vault is initialized, initial keys can
                be encrypted and stored into Cloud KMS so that the operator won’t have to handle plain-text keys.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Kubernetes Secrets Store CSI Driver"><div class="sect2" id="kubernetes_secrets_store_csi_driver">
            <h2>Kubernetes Secrets Store CSI Driver</h2>
            <p>The secret store <a href="https://oreil.ly/kOio7">Container Storage Interface (CSI)
                    driver</a> integrates<a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management services" data-tertiary="Container Storage Interface driver" id="idm45326832744512"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="secrets management services" data-tertiary="Container Storage Interface driver" id="idm45326832742768"/><a contenteditable="false" data-type="indexterm" data-primary="Azure Key Vault" data-secondary="Container Storage Interface driver" id="idm45326832741088"/><a contenteditable="false" data-type="indexterm" data-primary="AWS (Amazon Web Services)" data-secondary="Secrets Manager" data-tertiary="Container Storage Interface driver" id="idm45326832739696"/><a contenteditable="false" data-type="indexterm" data-primary="Amazon Web Services" data-see="AWS" id="idm45326832738016"/><a contenteditable="false" data-type="indexterm" data-primary="Google Secret Manager" data-secondary="Container Storage Interface driver" id="idm45326832736640"/><a contenteditable="false" data-type="indexterm" data-primary="HashiCorp Vault" data-secondary="Container Storage Interface driver" id="idm45326832735248"/><a contenteditable="false" data-type="indexterm" data-primary="Container Storage Interface (CSI) driver" id="idm45326832733856"/> external
                secret stores like Azure, GCP, AWS, and Vault from HashiCorp into Kubernetes using CSI, which is
                generally available since version 1.13.</p>
            <p>In a nutshell, the CSI driver authenticates with your secret store service using volume attributes and mounts
                needed secrets into the pod seamlessly. This approach avoids the use of the Kubernetes etcd datastore and
                allows you to scale and manage the organization’s secrets effectively.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Secrets Management Best Practices"><div class="sect2" id="secrets_management_best_practices">
            <h2>Secrets Management Best Practices</h2>
            <p>Following are the best practices to consider when managing secrets in Kubernetes.<a contenteditable="false" data-type="indexterm" data-primary="best practices" data-secondary="secrets management" id="idm45326832729520"/><a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" id="idm45326832728144"/></p>
            <section data-type="sect3" data-pdf-bookmark="Avoid secrets sprawl"><div class="sect3" id="avoid_secrets_sprawl">
                <h3>Avoid secrets sprawl</h3>
                <p>The main motive of secrets management is to avoid secrets sprawl, <a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" data-tertiary="secrets sprawl" id="idm45326832724976"/>where your application secrets are spread across places
                    like config files, yamls, and Git repositories. This is usually a sign of the lack of a secrets
                    management workflow in the organization. The only way to mitigate secrets sprawl is to have a
                    centralized secrets management strategy in place, one where credentials can be stored and retrieved
                    securely from a single point and used by the entire organization with proper authorization, logging,
                    and monitoring mechanisms in place.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Use anti-affinity rules"><div class="sect3" id="use_anti_affinity_rules">
                <h3>Use anti-affinity rules</h3>
                <p>Ideally, a secrets management solution should be a single process on a small number of dedicated VMs
                    or dedicated hosts. Since you may need to run this solution on Kubernetes as a microservice, it will
                    be a process running in a dedicated pod. But the issue becomes on which nodes these pods should be
                    running. Here anti-affinity helps by distributing pods on required nodes, which are classified to
                    run a secrets management solution.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Data encryption (transit and rest)"><div class="sect3" id="data_encryption_left_parenthesistransit">
                <h3>Data encryption (transit and rest)</h3>
                <p>By default, Kubernetes insecurely stores and transmits secrets.<a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" data-tertiary="encryption" id="idm45326832718192"/> It is paramount to configure or have a solution that can
                    use end-to-end TLS encryption where secrets are encrypted in transit. At the same time, have a
                    mechanism in place to store secrets in encrypted form. See <a data-type="xref" href="ch02.xhtml#infrastructure_security">Chapter 2</a> for options on how to achieve this.
                </p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Use automated secret rotation"><div class="sect3" id="use_automated_secret_rotation">
                <h3>Use automated secret rotation</h3>
                <p>Organizations follow different time frames for different secrets for rotation,<a contenteditable="false" data-type="indexterm" data-primary="rotation of credentials" data-secondary="secrets management" id="idm45326832713168"/><a contenteditable="false" data-type="indexterm" data-primary="credential rotation" data-secondary="secrets management" id="idm45326832711696"/><a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" data-tertiary="rotating secrets" id="idm45326832710320"/> but with
                    the advent of automated secret rotation, you can do it daily or even on an hourly basis. Cloud
                    secrets management services and external third-party solutions both can help to rotate and manage
                    secrets in an automated fashion.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Ephemeral or dynamic secret"><div class="sect3" id="ephemeral_or_dynamic_secret">
                <h3>Ephemeral or dynamic secret</h3>
                <p>Ephemeral or dynamic secrets are temporary, on-demand generated <a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" data-tertiary="ephemeral or dynamic" id="idm45326832706336"/><a contenteditable="false" data-type="indexterm" data-primary="ephemeral secrets" id="idm45326832704544"/><a contenteditable="false" data-type="indexterm" data-primary="dynamic secrets" id="idm45326832703440"/>secrets that typically have a short time to live and
                    are destroyed after that time interval. These secrets can be made available to the class of the
                    application or to the operations team as needed. If a secret is discovered by an attacker (for
                    example, if leaked via debug logs, application code, or accidentally exposed via GitHub), the
                    secrets would have been changed in a short window of time, protecting applications. Additionally,
                    they can help trace the attacker’s footsteps in the infrastructure, since it becomes easy to
                    determine the time frame in which the secret was discovered by the attacker. HashiCorp Vault and
                    CyberArk Conjur are some of the third-party secrets providers that provide such features.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Enable audit log"><div class="sect3" id="enable_audit_log">
                <h3>Enable audit log</h3>
                <p>Having an audit log in your secrets management solution provides <a contenteditable="false" data-type="indexterm" data-primary="audit logs" data-secondary="secrets management" id="idm45326832699472"/><a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="audit logs" data-tertiary="secrets management" id="idm45326832698016"/><a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" data-tertiary="audit logs" id="idm45326832696368"/>visibility into secrets and their uses by the organization.
                    An audit log can be critical for determining intentional or unintentional compromises, the blast
                    radius of the attack, and related forensic steps.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Store secrets in container memory"><div class="sect3" id="store_secrets_in_container_memory">
                <h3>Store secrets in container memory</h3>
                <p>When a containerized application receives a secret, <a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" data-tertiary="stored in container memory" id="idm45326832692480"/>don’t store the secret on disk (or in
                    volumeMount available in the host). Rather, store it in memory so that in case of a compromise,
                    those secrets are not easily available to the attacker.</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Secret zero problem"><div class="sect3" id="secret_zero_problem">
                <h3>Secret zero problem</h3>
                <p>Many secrets management solutions follow envelope encryption<a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="management best practices" data-tertiary="secret zero problem" id="idm45326832688528"/><a contenteditable="false" data-type="indexterm" data-primary="key encryption key (KEK)" data-secondary="secret zero problem" id="idm45326832686784"/><a contenteditable="false" data-type="indexterm" data-primary="data encryption key (DEK)" data-secondary="secret zero problem" id="idm45326832685392"/><a contenteditable="false" data-type="indexterm" data-primary="data encryption" data-secondary="data encryption key" data-tertiary="secret zero problem" id="idm45326832684000"/><a contenteditable="false" data-type="indexterm" data-primary="encryption" data-secondary="data encryption key" data-tertiary="secret zero problem" id="idm45326832682352"/> where DEKs are protected by a KEK. The KEK is
                    considered secret zero. If an attacker compromises the KEK, then they can decrypt the DEK and
                    subsequently the data encrypted by the DEK. The combination of cloud providers’ IAM and KMS can be
                    used to help protect secret zero. (Though, of course, these in turn effectively have their own
                    secret zero further up the trust chain, which you must treat as highly sensitive.)</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Use your Certificate Authority"><div class="sect3" id="use_your_ca_left_parenthesiscertificate">
                <h3>Use your Certificate Authority</h3>
                <p>As part of defense-in-depth, end-to-end TLS implementation can <a contenteditable="false" data-type="indexterm" data-primary="certificate authority (CA)" data-secondary="secrets management" id="idm45326832678224"/>be done using a custom Certificate Authority (CA). Here an organization
                    can choose to sign its certificate using its own CA. In this case, the service can only be accessed
                    by presenting a certificate signed by the organization.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-org" id="idm45326832676288"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-org2" id="idm45326832674912"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-org3" id="idm45326832673536"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-org4" id="idm45326832672160"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-org5" id="idm45326832670784"/></p>
            </div></section>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Authentication"><div class="sect1" id="authentication">
        <h1>Authentication</h1>
        <p>Once you are ready with your hardened images, CI/CD pipeline, <a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deployment controls" data-tertiary="authentication" id="idm45326832667488"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="deployment controls" data-tertiary="authentication" id="idm45326832665840"/><a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="deployment controls" id="idm45326832664192"/>and secrets management
            strategy, it’s time for Kubernetes’ authentication and authorization strategy. Kubernetes allows numerous
            authentication mechanisms; in simplest form; authentication is done with certificates, tokens, or basic
            authentication (username and password). Additionally, webhooks can be used to verify bearer tokens, and
            external OpenID providers can be integrated.</p>
        <p>Let’s take a closer look at each authentication method available in Kubernetes. Configuration for
            authentication methods is out of scope for this book.</p>
        <section data-type="sect2" data-pdf-bookmark="X509 Client Certificates"><div class="sect2" id="xfivezeronine_client_certificates">
            <h2>X509 Client Certificates</h2>
            <p>There are two ways to sign a client certificate so that it can be used to <a contenteditable="false" data-type="indexterm" data-primary="X509 client certificates" id="idm45326832659936"/><a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="X509 client certificates" id="idm45326832658672"/><a contenteditable="false" data-type="indexterm" data-primary="certificate signing request (CSR)" id="idm45326832657280"/>authenticate with the Kubernetes API.
                First is internally signing the certificate using the Kubernetes API. It involves the creation of a
                certificate signing request (CSR) by a client. Administrators can approve or deny the CSR. Once
                approved, the administrator can extract and provide a signed certificate to the requesting client or
                user. This method cannot be scaled for large organizations as it requires manual intervention.</p>
            <p>The second method is to use enterprise PKI, which <a contenteditable="false" data-type="indexterm" data-primary="Public Key Infrastructure (PKI)" data-secondary="authentication" id="idm45326832655104"/><a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="Public Key Infrastructure" id="idm45326832653712"/>can sign the client-submitted CSR.
                Additionally, the signing authority can send signed certificates back to clients. This approach requires
                the private key to be managed by an external solution.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Bearer Token"><div class="sect2" id="bearer_token">
            <h2>Bearer Token</h2>
            <p>Kubernetes service accounts use bearer tokens to<a contenteditable="false" data-type="indexterm" data-primary="bearer tokens" id="idm45326832649856"/><a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="bearer tokens" id="idm45326832648752"/> authenticate with Kubernetes
                API. The simplest way to use a bearer token is to create a new service account. Kubernetes API
                automatically issues a random token associated with the service account, which can be retrieved and used
                to authenticate that account.</p>
            <p>Bearer tokens can be verified using a webhook, which involves API configuration with option
                <code>--authentication-token-webhook-config-file</code>, which includes the details of the remote webhook service.
            </p>
            <p>Kubernetes internally uses Bootstrap and Node authentication tokens to initialize the cluster.
                Also, there'’s a less secure option available using a static token file that can be provided
                using the <code>--token-auth-file</code> option while configuring Kubernetes API.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="OIDC Tokens"><div class="sect2" id="oidc_tokens">
            <h2>OIDC Tokens</h2>
            <p>The <a href="https://oreil.ly/8t476">OpenID Connect protocol</a><a contenteditable="false" data-type="indexterm" data-primary="OIDC (OpenID Connect) tokens" id="idm45326832642240"/><a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="OIDC tokens" id="idm45326832641168"/> is built by expanding the existing OAuth2 protocol.
                Kubernetes does not provide an OpenID Connect identity provider. You can use identity providers like
                Google or Azure or run your own identity provider using <a href="https://oreil.ly/Rd2sg">dex</a>,
                <a href="https://oreil.ly/ah3IY">keycloak</a>, or <a href="https://oreil.ly/oMhzC">UAA</a>. These external identity providers can easily be
                integrated with your authentication workflows as required, as well as support native identity provider
                capabilities (e.g., enterprise using lightweight directory access protocol).</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Authentication Proxy"><div class="sect2" id="authentication_proxy">
            <h2>Authentication Proxy</h2>
            <p>A proxy can be used to establish a trust connection with Kubernetes API. <a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="proxy" id="idm45326832635280"/>Kubernetes API
                can identify users from request headers such as X-Remote-User, which is set by authentication proxy as
                it authenticates users on behalf of the Kubernetes API. Authentication proxy can authenticate users as
                needed according to your workflow.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Anonymous Requests"><div class="sect2" id="anonymous_requests">
            <h2>Anonymous Requests</h2>
            <p>If a request to Kubernetes API is not rejected by any configured <a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="anonymous requests" id="idm45326832631504"/><a contenteditable="false" data-type="indexterm" data-primary="anonymous requests" id="idm45326832630048"/><a contenteditable="false" data-type="indexterm" data-primary="bearer tokens" data-secondary="anonymous requests" id="idm45326832628944"/>authentication method, then it is treated as an anonymous
                request (i.e., a request without a bearer token).</p>
            <p>It is important to note that for Kubernetes version 1.6 and above, anonymous access is enabled by default
                for an authorization mode other than <code>AlwaysAllow</code>. It can be disabled by adding the option
                <code>--anonymous-auth=false</code> while configuring Kubernetes API.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="User Impersonation"><div class="sect2" id="user_impersonation">
            <h2>User Impersonation</h2>
            <p>This is a subtle authentication mechanism where a user with certain <a contenteditable="false" data-type="indexterm" data-primary="authentication" data-secondary="user impersonation" id="idm45326832623936"/><a contenteditable="false" data-type="indexterm" data-primary="user impersonation" id="idm45326832622480"/>access to
                Kubernetes can impersonate another user by setting additional headers in the request to Kubernetes API
                with the details of the impersonated user.</p>
            <p>This mechanism allows Kubernetes API to process requests as per the impersonated user’s privileges and
                context. Additionally, Kubernetes API can log who has impersonated whom and other relevant details from
                a request as necessary, which can be useful during monitoring and audit.</p>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Authorization"><div class="sect1" id="authorization">
        <h1>Authorization</h1>
        <p>In this section we will cover available authorization methods, RBAC in Kubernetes, namespaced RBAC, and
            caveats.<a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deployment controls" data-tertiary="authorization" id="ch03-auth"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="deployment controls" data-tertiary="authorization" id="ch03-auth2"/></p>
        <p>Kubernetes has multiple authorization mechanisms such as Node, ABAC, RBAC, and AlwaysDeny/AlwaysAllow, though
            RBAC is the industry standard in Kubernetes.</p>
        <section data-type="sect2" data-pdf-bookmark="Node"><div class="sect2" id="node">
            <h2>Node</h2>
            <p>Node authorization is used by Kubernetes internally. <a contenteditable="false" data-type="indexterm" data-primary="authorization" data-secondary="node authorization" id="idm45326832611888"/><a contenteditable="false" data-type="indexterm" data-primary="node authorization" id="idm45326832610512"/><a contenteditable="false" data-type="indexterm" data-primary="kubelets and node authorization" id="idm45326832609408"/>It’s a special-purpose authorization mode
                that specifically authorizes API requests made by kubelets. It enables read, write, and auth-related
                operations by kubelet. In order to successfully make a request, kubelet must use a credential that
                identifies it as being in the system:nodes group.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="ABAC"><div class="sect2" id="abac">
            <h2>ABAC</h2>
            <p>Kubernetes defines attribute-based access control (ABAC) <a contenteditable="false" data-type="indexterm" data-primary="authorization" data-secondary="attribute-based access control" id="idm45326832605728"/><a contenteditable="false" data-type="indexterm" data-primary="attribute-based access control (ABAC)" id="idm45326832604304"/><a contenteditable="false" data-type="indexterm" data-primary="access control" data-see="authentication; authorization" id="idm45326832603184"/><a contenteditable="false" data-type="indexterm" data-primary="ABAC (attribute-based access control)" id="idm45326832601792"/>as “an access control paradigm
                whereby access rights are granted to users through the use of policies which combine attributes
                together.” ABAC can be enabled by providing a <em>.json</em> file to <span class="keep-together"><code>--authorization-policy-file</code></span> and
                <code>--authorization-mode=ABAC</code> options in Kubernetes API configurations. The .<em>json</em> file needs to be
                present before Kubernetes API can be invoked.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="AlwaysDeny/AlwaysAllow"><div class="sect2" id="alwaysdenysolidusalwaysallow">
            <h2>AlwaysDeny/AlwaysAllow</h2>
            <p>The  AlwaysDeny  or  AlwaysAllow  authorization  mode  is  usually  used  in  <a contenteditable="false" data-type="indexterm" data-primary="authorization" data-secondary="AlwaysDeny/AlwaysAllow" id="idm45326832596288"/><a contenteditable="false" data-type="indexterm" data-primary="AlwaysDeny/AlwaysAllow authorization" id="idm45326832594816"/>development  environments  where  all 
 requests  to  the  Kubernetes  API  need  to  be  allowed  or denied. AlwaysDeny or AlwaysAllow mode can be enabled using option <span class="keep-together"><code>--authorization-mode=AlwaysDeny/AlwaysAllow</code></span> while configuring Kubernetes API. This mode is considered insecure and hence is not recommended in production environments.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="RBAC"><div class="sect2" id="rbac">
            <h2>RBAC</h2>
            <p>Role-based access control is the most secure and recommended authorization<a contenteditable="false" data-type="indexterm" data-primary="authorization" data-secondary="role-based access control" data-see="role-based access control" id="idm45326832589952"/><a contenteditable="false" data-type="indexterm" data-primary="RBAC" data-see="role-based access control" id="idm45326832588320"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="authorization" id="idm45326832586928"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="Principle of Least Privileges strategy" id="idm45326832585536"/><a contenteditable="false" data-type="indexterm" data-primary="Principle of Least Privileges strategy" id="idm45326832584128"/> mechanism in
                Kubernetes. It is an approach to restrict system access based on the roles of users within your cluster.
                It allows organizations to enforce the principle of least privileges. <a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="declarative nature" data-tertiary="security architecture" id="idm45326832582640"/>Kubernetes RBAC
                follows a declarative nature with clear permissions (operations), API objects (resources), and subjects
                (users, groups, or ServiceAccounts) declared in authorization requests. Applying an RBAC in Kubernetes
                is a two-step process. First is to create a Role or ClusterRole. The latter is a
                global object where the former is a namespace object. A Role or ClusterRole is made up of verbs, resources,
                and subjects, which provide a capability (verb) on a resource, as shown in <a data-type="xref" href="#kubernetes_role_and_role_binding">Figure 3-6</a>. The second step is to
                create a ClusterRoleBinding where the privileges defined in step 1 are assigned to the user or group.</p>
            <p>Let’s take an example where a dev-admins group needs to have read access to all the secrets in the
                cluster. Step 1 is to create a ClusterRole secret-reader, which allows the reading of the secrets via
                various operations (get, list), and step 2 is binding it to a subject (i.e., users, groups, or
                ServiceAccounts) to provide access. In this case the group dev-admins allows group users to read secrets
                globally.</p>
            <p><a data-type="xref" href="#kubernetes_role_and_role_binding">Figure 3-6</a> is an
                example of how you can create a ClusterRole that allows you to define access to resources. The example
                on the right shows how you can bind the ClusterRole to a group of users.</p>
            <figure><div id="kubernetes_role_and_role_binding" class="figure">
                <img src="Images/ksao_0306.png" alt="" width="1429" height="593"/>
                <h6><span class="label">Figure 3-6. </span>Kubernetes role and role binding</h6>
            </div></figure>
            <p class="pagebreak-before"><a data-type="xref" href="#rbac_for_kubernetes_resources">Figure 3-7</a> shows an
                overview of RBAC; you can use any combination of operation, resource, or subject as required.</p>
                <p>Apart from these resources, there are Kubernetes nonresources like /healths or <span class="keep-together">/version</span> APIs that can be
                controlled using RBAC as well if needed.</p>
            <figure><div id="rbac_for_kubernetes_resources" class="figure">
                <img src="Images/ksao_0307.png" alt="" width="1432" height="429"/>
                <h6><span class="label">Figure 3-7. </span>RBAC for Kubernetes resources</h6>
            </div></figure>
            
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Namespaced RBAC"><div class="sect2" id="namespaced_rbac">
            <h2>Namespaced RBAC</h2>
            <p>In earlier examples you saw an RBAC that was applied globally<a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="namespaced RBAC" id="idm45326832475024"/><a contenteditable="false" data-type="indexterm" data-primary="namespaced role-based access control" id="idm45326832473504"/> in the cluster. It is possible to
                apply a similar RBAC to namespaces where resources within a namespace can be subject to this RBAC
                policy. The namespaced resources Role and RoleBinding should be used for configuring a namespace policy.
            </p>
            <p>There are few caveats you should be aware of while using namespaced RBAC:</p>
            <ul>
                <li>
                    <p>Roles and RoleBindings are the only namespaced resources.</p>
                </li>
                <li>
                    <p>ClusterRoleBindings (global resource) cannot be used with Roles, which is a namespaced resource.
                    </p>
                </li>
                <li>
                    <p>RoleBindings (namespaced resource) cannot be used with ClusterRoles, which are global resources.
                    </p>
                </li>
                <li>
                    <p>Only ClusterRoles can be aggregated.</p>
                </li>
            </ul>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Privilege Escalation Mitigation"><div class="sect2" id="privilege_escalation_mitigation">
            <h2>Privilege Escalation Mitigation</h2>
            <p>Kubernetes RBAC reduces an attacker’s ability to escalate their own <a contenteditable="false" data-type="indexterm" data-primary="authorization" data-secondary="privilege escalation" data-tertiary="mitigation" id="idm45326832465392"/><a contenteditable="false" data-type="indexterm" data-primary="privilege escalation" data-secondary="mitigation" id="idm45326832463664"/>privileges by editing
                roles or role bindings. This behavior is enforced at the API level in Kubernetes and even applies when
                the RBAC authorizer is not in use:</p>
            <ul>
                <li>
                    <p>If user user-no-secret doesn’t have the ability to list secrets cluster-wide, they cannot create
                        a ClusterRole or ClusterRoleBinding containing that permission.</p>
                </li>
                <li>
                    <p>For user user-no-secret to get a list of secret privileges, they will need one of the following:</p>
                    <ul>
                        <li>
                            <p>Grant them a role that allows them to create/update Roles, ClusterRoles, RoleBindinsg, or
                                ClusterRoleBindings.</p>
                        </li>
                        <li>
                            <p>Provide them explicit permission with the verb escalate on these resources.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-auth" id="idm45326832457264"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch03-auth2" id="idm45326832455696"/></p>
                        </li>
                    </ul>
                </li>
            </ul>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000008">
        <h1>Conclusion</h1>
        <p>In this chapter we covered the following key concepts that will help you understand security tools and best
            practices to build and deploy workloads:</p>
        <ul>
            <li>
                <p>It is insufficient to use available base images from Docker as they are for your containers; you must
                    spend time ensuring that your container images are hardened and built with security in mind. Just
                    like in software development, finding vulnerabilities at build time is far cheaper than finding
                    vulnerabilities after software is deployed.</p>
            </li>
            <li>
                <p>There are several ways to add image scanning to your CI/CD process. We explored various
                    well-known approaches like registry scan, build time or inline scan, and using Kubernetes admission
                    controller to help you add image scanning to your CI/CD pipelines. We also looked at securing CI/CD
                    pipelines and adding organization policy to effectively craft a workflow for your organization.</p>
            </li>
            <li>
                <p>We covered the approaches and best practices to secret management.</p>
            </li>
            <li>
                <p>Finally, we covered available Kubernetes authentication and authorization mechanisms. We recommend
                    you use RBAC to mitigate privilege escalation.</p>
            </li>
        </ul>
    </div></section>
</div></section></div></body></html>