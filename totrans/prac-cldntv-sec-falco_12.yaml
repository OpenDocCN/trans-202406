- en: Chapter 9\. Installing Falco
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [Part III](part03.xhtml#iii_running_falco_in_production) of this
    book, which will walk you through using Falco in the real world. Now that you
    know how Falco and its architecture work, the next step is to start using it to
    protect your applications and systems. In this chapter, you will learn what you
    need to know to install Falco in production. We will show you different scenarios
    and common best practices so that you can find the right instructions for your
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by giving you an overview of common usage scenarios, then we’ll
    describe different installation methods for each of them. We strongly recommend
    reading about all of the installation methods, even if you need only some of them,
    to get a complete picture of the possibilities and choose which fits your needs
    best.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Your Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Falco Project officially supports three ways to run Falco in production:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Falco directly on a host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Falco in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Falco to a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each option has a different installation method, and there are a few important
    differences between the first option and the others. Installing Falco directly
    on the host is your *only* choice when your environment does not include a container
    runtime or Kubernetes. It is also the most secure way to run Falco, because it’s
    isolated from the container system (and thus difficult to breach in case of compromise).
    However, installing Falco directly on the host is usually the most difficult solution
    to maintain. It’s also not always possible (for example, when your applications
    live in a managed Kubernetes cluster and you don’t have full access to the host
    machines). The other options are usually more straightforward and easier to manage.
    Especially if your applications run on a Kubernetes cluster, deploying Falco to
    Kubernetes is a common choice. Consider the pros and cons of each and your requirements
    before making your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Before installing Falco with any of these methods, you need to decide how you’re
    going to use Falco, which can have a significant impact on the installation process
    and configuration. The two most common scenarios are monitoring syscalls and working
    with data sources provided by plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The default scenario is instrumenting the system to monitor syscalls. In this
    case you will need to deploy a Falco sensor on each machine or cluster node, as
    well as installing a driver on each underlying host.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with data sources provided by plugins, you will likely need to
    install only one Falco sensor (or one for each event producer), and you won’t
    need a driver. Although there may be small differences in the actual setup of
    each data source, for simplicity we can treat this as a single installation scenario
    because the overall process is very similar. Generally, this latter scenario has
    fewer requirements and is simpler to implement.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to satisfy more than one scenario at the same time, you will need
    more Falco installations. You can then aggregate the notifications coming from
    each sensor by using other tools, like Falcosidekick (discussed in [Chapter 12](ch12.xhtml#consuming_falco_events)).
  prefs: []
  type: TYPE_NORMAL
- en: Your final setup will depend on your needs and choices. The following sections
    provide instructions for each installation method in the two scenarios mentioned
    above (monitoring syscalls and working with data sources provided by plugins).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Directly on the Host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Falco directly on a host is a straightforward task—you learned the
    essential aspects in [Chapter 2](ch02.xhtml#getting_started_with_falco). This
    installation method is mainly intended for the default scenario where Falco uses
    system calls to secure and monitor a system, so it also installs the driver and
    configures Falco to use it. (In [Chapter 10](ch10.xhtml#configuring_and_running),
    we’ll discuss how to change the Falco configuration and set it up for other data
    sources.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This method installs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The user-space program *falco*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The driver (the kernel module, by default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default configuration file and the default ruleset files in */etc/falco*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *falco-driver-loader* utility (you can use this to manage the driver)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few bundled plugins (these may vary from version to version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install Falco, you will use one of the following artifacts provided by [Falco’s
    “Download” page](https://oreil.ly/sOLzu):'
  prefs: []
  type: TYPE_NORMAL
- en: '*.rpm* package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.deb* package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.tar.gz* (binary) package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should use one of the first two packages if you intend to install Falco
    via a compatible package manager; otherwise, use the binary package. Read on for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following subsections include various commands that you need to run on your
    system. Ensure that you have sufficient privileges to execute them (for example,
    using `sudo`).
  prefs: []
  type: TYPE_NORMAL
- en: Using a Package Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This installation method is for Linux distributions with a package manager that
    supports *.deb* or *.rpm* packages. The setup process for a *.deb* or *.rpm* package
    will also install a systemd unit to use Falco as a service on your system, as
    well as the kernel module—the default driver—via Dynamic Kernel Module Support
    (dkms).
  prefs: []
  type: TYPE_NORMAL
- en: '*apt* and *yum* are the most popular package managers that allow installing,
    respectively, *.deb* and *.rpm* packages. If you’re using a different package
    manager that supports *.deb* or *.rpm* packages, the installation procedure will
    be very similar, though the exact instructions may vary. Refer to its documentation
    for further details.'
  prefs: []
  type: TYPE_NORMAL
- en: Using apt (.deb package)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'apt is the default package manager for Debian and Debian-based distributions
    like Ubuntu. It allows you to install software applications distributed as *.deb*
    packages. To install Falco using apt, you first need to trust The Falco Project’s
    [GPG key](https://oreil.ly/Egkoo) and configure the apt repository that holds
    Falco packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then update the apt package list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this installation method will also install Falco’s kernel module, you
    must install the Linux kernel headers as a precondition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, install Falco:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using yum (.rpm package)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'yum is a command-line utility for Linux distributions that use the RPM Package
    Manager, such as CentOS, RHEL, Fedora, and Amazon Linux. It allows you to install
    software applications distributed as *.rpm* packages. Before installing Falco
    with yum, you must ensure that the make package and the dkms package are present
    on your system. You can check that by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If they are not present, install them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, trust The Falco Project’s [GPG key](https://oreil.ly/t5WaG) and configure
    the RPM repository that holds Falco packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this installation method will also install Falco’s kernel module, you
    must install the Linux kernel headers as a precondition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If `yum -y install kernel-devel-$(uname -r)` does not find the kernel headers
    package, run `yum distro-sync` and then reboot the system. After the reboot, try
    the preceding command again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, install Falco:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Completing the installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should now have the kernel module installed via dkms and a systemd unit
    installed to run Falco as a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start using Falco, you need to enable the Falco systemd service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Your installation is now complete. The service will automatically start running
    at the next reboot. If you want to start it immediately, just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From now on, you can manage the Falco service through the functions provided
    by systemd.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to the eBPF probe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Falco packages use the kernel module by default, and this is usually the best
    choice when installing Falco directly on the host. However, if you have particular
    requirements or other reasons not to use the kernel module, you can easily switch
    to the eBPF probe.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure you have an eBPF probe installed on your system. You can install
    it using the *falco-driver-loader* script, as explained in [“Managing the Driver”](#managing_the_driver).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you need to edit the systemd unit file, located at */usr/lib/systemd/user/falco­.ser⁠vice*
    (the path may vary depending on your distro). You can use `systemctl edit falco`
    to modify it. You need to add an option to set the `FALCO_BPF_PROBE` environment
    variable in the `[Service]` section of that file. Also, in the same section, comment
    (or remove) the `ExecStartPre` and `ExecStartPost` options, so the Falco service
    will not load the kernel module anymore. The changes are highlighted in the following
    excerpt from the *falco.service* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’re done, don’t forget to restart the Falco service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Falco should now start using the eBPF probe.
  prefs: []
  type: TYPE_NORMAL
- en: Using a plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Falco packages come configured for the syscalls instrumentation scenario, so
    the included systemd unit loads the kernel module when Falco starts. However,
    if you’re not using syscalls, you don’t need to load the driver. As described
    in the previous section, to prevent the Falco service from loading the kernel
    module, edit the */usr/lib/systemd/user/falco.service* file and remove (or comment
    out) the `ExecStartPre` and `ExecStartPost` options. Optionally, you can also
    configure the service to run Falco with a less privileged user by modifying the
    value of the `User` option.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need to configure Falco to use the plugin of your choice (we’ll
    explain how to do this in [Chapter 10](ch10.xhtml#configuring_and_running)) and
    restart the Falco service. Falco will then run using the new configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Without Using a Package Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing Falco without using a package manager is quick and easy. This installation
    method is intended for distributions that do not support a compatible package
    manager. We walked through the steps in detail in [Chapter 2](ch02.xhtml#getting_started_with_falco),
    but we’ll give you a short refresher here.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do is grab the link to the latest available version of the
    binary package from the [Falco “Download” page](https://oreil.ly/HEvdB), and download
    it into a local folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then extract the package and copy its content to your filesystem’s root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you’re planning to use system calls as your data source, install
    the driver manually before using Falco (you’ll find instructions in the following
    section). You don’t need to install the driver if you want to use a plugin. Also
    note that the binary package does not provide a systemd unit or any other mechanism
    to run Falco when your system starts automatically, so whether to execute Falco
    or run it as a service is entirely up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use syscalls as a data source, you will likely need to manage the driver.
    If you installed Falco without a package manager, you’ll have to install the driver
    before using Falco manually. All the available packages provide a helpful script
    called *falco-driver-loader* (introduced in [Chapter 2](ch02.xhtml#getting_started_with_falco))
    that you can use for this purpose. If you followed the instructions earlier in
    this chapter, you should already have it installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our suggestion is to familiarize yourself with the script by using `--help`
    to get its command-line usage. To do that, just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The script allows you to perform several actions, including installing a driver
    (either the kernel module or the eBPF probe) by compiling it or downloading it.
    It also allows you to remove a previously installed driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the script without any options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: by default it will try to install a kernel module via dkms. To be precise, it
    will first try to download a prebuilt driver, if one is available for your distribution
    and kernel version. Otherwise, it will try to compile the driver locally. The
    script will also inform you if any required dependencies are missing (for example,
    if dkms or make is not present on your system).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to install the eBPF probe instead, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running Falco in a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Falco Project provides several container images that you can use to run
    Falco in a container. Although the Falco container images described in this section
    will work with almost any container runtime, we’ll use Docker in our examples
    for simplicity. If you want to use a different tool, including Kubernetes, you
    can apply the same concepts. Even if you are only interested in deploying Falco
    on Kubernetes, we still advise you to read this section as it presents some essential
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](Images/#falco_container_images_hosted_by_the_do) lists the main
    available images, which you can get from the [Falco “Download” page](https://oreil.ly/rkZoV).
    These images contain all the necessary components to install the driver and run
    Falco. Later in this section, we’ll discuss how to use them to support some common
    use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Falco container images hosted by the docker.io registry
  prefs: []
  type: TYPE_NORMAL
- en: '| Image name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *falcosecurity/falco* | This is the default Falco image. It contains Falco,
    the *falco-driver-loader* script, and the building toolchain (required to build
    the driver on the fly). The entry point of this image will call the *falco-driver-loader*
    script to automatically install the driver on the host before running Falco in
    the container. |'
  prefs: []
  type: TYPE_TB
- en: '| *falcosecurity/falco-driver-loader* | This image is similar to the default
    one, but it will not run Falco. The image entry point will only run the *falco-driver-loader*
    script. You can use it when you want to install the driver at a different moment
    or when using the principle of least privilege (see [“Least privileged mode”](#least_privileged_mode)).
    Since this image alone cannot run Falco, use it in combination with another image,
    like *falcosecurity/falco-no-driver*. |'
  prefs: []
  type: TYPE_TB
- en: '| *falcosecurity/falco-no-driver* | This alternative to the default image only
    contains Falco, so it cannot install the driver. Use it when using the principle
    of least privilege or when your data source does not need a driver (for example,
    when using a plugin). |'
  prefs: []
  type: TYPE_TB
- en: 'Different tags are available for each distributed image. Tags allow you to
    choose a specific Falco version: for example, *falcosecurity/falco:0.32.0* contains
    Falco’s 0.32.0 release. The *:latest* tag points to the latest released version
    of Falco.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to experiment with a not-yet-released version of Falco, the *:master*
    tag ships the latest available development version. An automatic process builds
    and publishes images with this tag every time new code changes are merged into
    the master branch of Falco’s GitHub repository. This means it is not a stable
    release—don’t use it in production unless you want to try an experimental feature
    or debug a particular issue. Generally, we suggest always using the *:latest*
    tag, since it ships the latest Falco version and ruleset updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will describe how to use these images in the two common scenarios
    we’ve been discussing: syscall instrumentation, which requires a driver, and using
    a plugin as a data source, which does not.'
  prefs: []
  type: TYPE_NORMAL
- en: Syscall Instrumentation Scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Falco driver (either a kernel module or an eBPF probe) installed directly
    on the host is required for syscall instrumentation. Falco needs to run with enough
    privileges to interact with the driver; of course, if you want to use a container
    image to install the driver, that image needs to run with full privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Falco Project provides two modes for installing the driver on the fly and
    then running Falco in a container. The first and simplest mode uses just one container
    image with full privileges. The second uses two images: one image that temporarily
    runs with full privileges just to install the driver, and another image that then
    runs Falco with lesser privileges. The second approach allows enhanced security
    since the long-running container gets a restricted set of privileges, making life
    harder for a possible attacker. We recommend using least privileged mode to run
    Falco in a container.'
  prefs: []
  type: TYPE_NORMAL
- en: Fully privileged mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Falco in Docker with full privileges is quite straightforward. You
    just have to pull the default image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run Falco with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command will install the driver on the fly before running Falco. The container
    image uses the kernel module by default. If you want to use the eBPF probe instead,
    just add the `-e FALCO_BPF_PROBE=""` option and remove `-v /dev:/host/dev` (only
    the kernel module requires */dev*).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, aside from the `--privileged` option, the preceding command
    mounts a set of paths from the host into the container (each `-v` option is a
    bind mount).
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, the `-v /var/run/docker.sock:/host/var/run/docker.sock` option
    shares the Docker socket, so Falco can use Docker to obtain container metadata
    (as described in [Chapter 5](ch05.xhtml#data_enrichment), where we discussed Falco’s
    data enrichment techniques). You can add similar options for each container runtime
    available on your system. For example, if you also have containerd, include `-v
    /run/containerd/contain⁠erd​.sock:/host/run/containerd/containerd.sock`.
  prefs: []
  type: TYPE_NORMAL
- en: Falco requires sharing */dev* and */proc* to interface with the driver and the
    system, respectively. Other shared paths are needed to install the driver.
  prefs: []
  type: TYPE_NORMAL
- en: Least privileged mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This running mode follows the [principle of least privilege](https://oreil.ly/PKosx)
    for enhanced security. Although this mode is the recommended way to run Falco
    in a container, it might not necessarily work for all systems and configurations.
    We advise you to give it a try anyway and fall back to the fully privileged mode
    only if this does not fit your environment.
  prefs: []
  type: TYPE_NORMAL
- en: As noted, this approach uses two different container images. The first step,
    which requires full privileges, is to install the driver using the *falcosecurity/falco-driver-loader*
    image. You’ll need to do this before running Falco for the first time, and if
    you want to upgrade the driver at any point. (Alternatively, as explained earlier,
    you can install the driver directly on the host using the *falco-driver-loader*
    script shipped with the binary package. If you did so, skip this step.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the driver using a container image, pull the image first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the installation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command installs the kernel module by default. If you want to use the eBPF
    probe instead, just add the `-e FALCO_BPF_PROBE=""` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to run Falco. Since the driver is already installed, you will
    just need to use the *falcosecurity/falco-no-driver* image. So, pull it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run Falco:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you use another container runtime, customize this command by adding a `-v`
    option accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are some caveats when using the eBPF probe. You cannot use least
    privileged mode unless you have at least kernel version 5.8\. This is because,
    with previous kernel versions, loading the eBPF probe required the `--privileged`
    flag. If you are running a kernel version equal to or greater than 5.8, you can
    use the `SYS_BPF` capability to overcome this issue by customizing the command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that on systems with the AppArmor Linux Security Module (LSM) enabled,
    you will also need to pass the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Depending on the Falco version you are using and your environment, you might
    need to customize the commands described in this section; refer to the [online
    documentation](https://oreil.ly/TXTge).
  prefs: []
  type: TYPE_NORMAL
- en: Plugin Scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re using a plugin as your data source, there’s no need to install a
    driver, nor will Falco need full privileges to run, so we recommend you use the
    *falcosecur⁠ity/​falco-no-driver* image for this scenario. Whatever container
    image you choose, the default Falco configuration it contains won’t work out of
    the box; you’ll have to give Falco the required configuration for the plugin.
    You can do that by using an external configuration file and mounting it in the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: As a preparation step, you’ll have to create a local copy of [*falco.yaml*](https://oreil.ly/E31wy)
    and modify it according to your plugin configuration. We will explain how to do
    that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve prepared your custom *falco.yaml*, to run Falco, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use a plugin not shipped in the default Falco distribution,
    you will have to mount the plugin file and its rules file in the container, too.
    For example, to mount *libmyplugin.so* and *myplugin_rules.yaml*, add the following
    options to the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Deploying to a Kubernetes Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common Falco use cases is securing clusters, so deploying Falco
    to Kubernetes is perhaps the most important installation method to be aware of.
    The Falco Project recommends two approaches for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Helm
  prefs: []
  type: TYPE_NORMAL
- en: The first installation method uses Helm, a very popular tool to install and
    manage software built for Kubernetes. The Falco community provides and maintains
    a Helm chart for Falco and other tools that integrate with Falco. Installing Falco
    using the provided chart is straightforward and mostly automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes manifest files
  prefs: []
  type: TYPE_NORMAL
- en: The other installation method, geared toward flexibility, is based on a set
    of Kubernetes manifest files. These files provide default installation settings,
    which users can customize based on their needs. Although this approach requires
    a bit more effort, it permits the installation of Falco on virtually any Kubernetes
    cluster without the need for extra tools.
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches are solid, and you should select the one that best suits your
    environment and your organization’s requirements. In the following subsections,
    we will walk you through each of them. The only requirement is having a Kubernetes
    cluster installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The installation methods for Kubernetes described in this section use the default
    Falco container image discussed in [“Running Falco in a Container”](#running_falco_in_a_container).
  prefs: []
  type: TYPE_NORMAL
- en: Using Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer a fully automated installation process or are already using Helm
    in your environment, this installation method is for you. Having [Helm](https://helm.sh)
    installed is a prerequisite; for instructions, see the [online documentation](https://oreil.ly/YCiLB).
  prefs: []
  type: TYPE_NORMAL
- en: Falco’s Helm chart will add Falco to all nodes in your cluster using a DaemonSet.
    Then each deployed Falco Pod will try to install the driver on its own node. That
    is the default configuration that reflects the most common scenario, syscall instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Falco Pods internally use *falco-driver-loader*, which tries to download a prebuilt
    driver; failing that, it will build the driver on the fly. Usually, no action
    is required. If you notice that the Falco Pods are continuously restarting after
    being deployed, the process was probably unable to install the driver. This issue
    usually happens when a prebuilt driver is unavailable for your distribution or
    kernel and no kernel headers are available on the host. To build the driver, kernel
    headers must be installed on the host. You can fix the issue by manually installing
    the kernel headers and then deploying Falco again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm uses the Kubernetes context provided by [kubectl](https://oreil.ly/S7tqe)
    to access your cluster. Before installing Falco with Helm, ensure that your local
    configuration points to the proper context. You can check that by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the context is not pointing to your targeted cluster or kubectl cannot access
    your cluster, you will have to address this issue. Otherwise, you can proceed
    with the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before installing the chart, add Falco’s Helm repository so that your local
    Helm installation can find the Falco chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command is usually a one-time operation. To get the latest information
    about the Falco chart, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Execute this command whenever you want to install and update Falco with Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next and final step is actually to install the chart by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The chart installs the kernel module by default. If you want to use the eBPF
    probe instead, just append `--set ebpf.enabled=true` to this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'And you’re done! After a while, Falco’s Pods will show up in your cluster.
    You can use the following command to check whether they are ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The chart installs Falco for the default scenario (syscall instrumentation),
    as per the default settings. The Helm installation process for other scenarios
    is very similar; just provide the appropriate configuration. We will discuss how
    to customize your Falco deployment in [Chapter 10](ch10.xhtml#configuring_and_running).
    You can find more information about Falco’s chart configuration in its [online
    documentation](https://oreil.ly/pcJWP).
  prefs: []
  type: TYPE_NORMAL
- en: Using Manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes manifests are JSON or YAML files (mainly YAML) that contain the specifications
    for one or more Kubernetes API objects and describe your application and its configurations.
    The kubectl command-line utility lets you deploy your workload in Kubernetes using
    these files. Projects often provide almost-ready-to-use example manifests, but
    you’ll usually need to adapt them to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Since Falco supports very different scenarios and environments, The Falco Project
    does not officially provide manifests for all use cases. However, for the syscall
    instrumentation scenario, you can use the [Falco example manifests](https://oreil.ly/qWW1w)
    (listed in [Table 9-2](#example_manifest_files_for_falco)) as a starting point
    to make your customized manifests.^([1](ch09.xhtml#ch01fn10))
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2\. Example manifest files for Falco
  prefs: []
  type: TYPE_NORMAL
- en: '| Filename | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *daemonset.yaml* | Specifies a [DaemonSet](https://oreil.ly/9YwAV) so that
    a copy of the Falco Pod will run on each node (required by the syscall instrumentation
    scenario). The [Pod specification](https://oreil.ly/WRtRb) uses the *falcosecurity/falco*
    container image. It also includes all settings needed to run the image in this
    scenario, similar to those described in [“Running Falco in a Container”](#running_falco_in_a_container).
    |'
  prefs: []
  type: TYPE_TB
- en: '| *configmap.yaml* | Specifies a [ConfigMap](https://oreil.ly/vTAdd) containing
    the default *falco.yaml* file and rules files. Modify it according to your needs.
    |'
  prefs: []
  type: TYPE_TB
- en: '| *serviceaccount.yaml* | Specifies a [ServiceAccount](https://oreil.ly/sXkl9)
    for running Falco’s Pods. Falco requires this to talk with the Kubernetes API.
    You usually don’t need to alter it, unless you want to change the service account
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| *clusterrole.yaml* | Specifies a [ClusterRole](https://oreil.ly/gWjN4), including
    the role-based access control (RBAC) authorizations required by Falco to talk
    with the Kubernetes API. Don’t change the list of permissions needed, or Falco
    will not enrich the Kubernetes metadata correctly. |'
  prefs: []
  type: TYPE_TB
- en: '| *clusterrolebinding.yaml* | Specifies a [ClusterRoleBinding](https://oreil.ly/PTEcU)
    that grants the permissions defined in *clusterrole.yaml* to the service account
    defined in *serviceaccount.yaml*. You usually won’t need to change this, unless
    you’ve changed the service account or the cluster role name in the other files.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Once you’ve modified the manifest files according to your needs, to apply them
    to Kubernetes (that is, to deploy Falco to Kubernetes) just run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Falco’s Pods should show up in your cluster after a while. To check whether
    they are ready, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If everything went well, Falco is now up and running in your production cluster—and
    you have learned how to customize your Falco deployment. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the different installation methods available for Falco
    and explained the difference between the two most common installation scenarios.
    However, in some cases, your installation will need specific configurations or
    customizations. The next chapter gives you all the complementary information you
    need to finally run Falco in production and completely control your Falco installation.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch09.xhtml#ch01fn10-marker)) The actual URLs of the Falco manifest example
    files for Kubernetes may change from time to time, but you can always find links
    to them in the [official documentation](https://oreil.ly/P5BUa). Falco’s Helm
    chart can generate those files, too. Surprisingly, The Falco Project uses this
    Helm functionality to automatically publish up-to-date manifest example files
    under the [Falcosecurity GitHub organization](https://oreil.ly/6QhH3).
  prefs: []
  type: TYPE_NORMAL
