["```\nval mutableList = mutableListOf(1, 2, 4, 5)\nval immutableList = listOf(1, 2, 4, 5)\nmutableList.add(4)    // compiles\n\n// doesn't compile: ImmutableList has no `add` method.\nimmutableList.add(2)\n```", "```\nval deeplist = listOf(mutableListOf(1, 2), mutableListOf(3, 4))\n\n// Does not compile: \"Unresolved reference: add\"\ndeeplist.add(listOf(3))\n\ndeeplist[1][1] = 5      // works\ndeeplist[1].add(6)      // works\n```", "```\nimplementation \\\n'org.jetbrains.kotlinx:kotlinx-collections-immutable:$IC_VERSION'\n```", "```\nfun naiveConversion(intList: List<Int>): List<Double> {\n    var ints = intList\n    var doubles = listOf<Double>()\n    while (!ints.isEmpty()) {\n        val item = ints[0]\n        ints = ints - item\n        doubles = doubles + item.toDouble()\n    }\n    return doubles\n}\n```", "```\n(listOf(1, 2) + 3)\n    .equals(listOf(1, 2, 3))    // true\n(listOf(1, 2) + listOf(3, 4))\n    .equals(listOf(1, 2, 3, 4)) // true\n```", "```\nval map = mapOf(1 to 2, 4 to 5)\n```", "```\nval map = mutableMapOf(\"Earth\" to 3, \"Venus\" to 4)\n```", "```\nval list = listOf(1L, 3.14)\n```", "```\nval list = mutablelistOf(1L, 3.14, \"e\")\n```", "```\nlist.add(null)  // Error: Null cannot be a value of a non-null type Any\n```", "```\nval list: MutableList<Any?> = mutablelistOf(1L, 3.14, \"e\")\n```", "```\nfun forAll() {\n    for (x in collection) { doSomething(x) }\n}\n```", "```\nfun forAll() = collection.forEach(::doSomething)\n```", "```\nval nums = listOf(10, 20, 100, 5)\nval isAny = nums.any()                 // true\nval isAnyOdd = nums.any { it % 1 > 0 } // true\nval isAnyBig = nums.any { it > 1000}   // false\n```", "```\nval nums = listOf(10, 20, 100, 5)\nval isAny = nums.all { it % 1 > 0 } // false\n```", "```\nval nums = listOf(10, 20, 100, 5)\nval isAny = nums.none()              // false\nval isAny4 = nums.none { it == 4 }   // true\n```", "```\nval nums = listOf(10, 20, 100, 5)\nval numbers = nums.filter { it > 20 }\n```", "```\nval nums = listOf(10, 20, 100, 5)\nval numbers = nums.filterNot { it > 20 }\n```", "```\nval nums = listOf(null, 20, null, 5)\nval numbers = nums.filterNotNull() // { 20, 5 }\n```", "```\ninline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R>\n```", "```\ndata class Hire(\n    val name: String,\n    val position: String,\n    val startDate: String\n)\n\nfun List<Hire>.getStartDates(): List<Date> {\n    val formatter\n        = SimpleDateFormat(\"yyyy-MM-d\", Locale.getDefault())\n    return map {\n        try {\n            formatter.parse(it.startDate)\n        } catch (e: Exception) {\n            Log.d(\n                \"getStartDates\",\n                \"Unable to format first date. $e\")\n            Date()\n        }\n    }\n}\n```", "```\nval doubles: List<Double?> = listOf(1.0, 2.0, 3.0, null, 5.0)\nval squares: List<Double?> = doubles.map { it?.pow(2) }\n```", "```\nval doubles: List<Double?> = listOf(1.0, 2.0, 3.0, null, 5.0)\nval squares: List<Double?> = doubles.mapNotNull { it?.pow(2) }\n```", "```\nfun <T, R> CON<T>.flatMap(transform: (T) -> KON<R>): KON<R>\n```", "```\nfun <T, R> CON<T>.map(transform: (T) -> KON<R>): CON<KON<R>>\n```", "```\nval list: List<List<Int>> = listOf(listOf(1, 2, 3, 4), listOf(5, 6))\nval flatList: List<Int> = list.flatMap { it }\n```", "```\ninline fun <T, K> Array<out T>\n    .groupBy(keySelector: (T) -> K): Map<K, List<T>>\n```", "```\nval numbers = listOf(1, 20, 18, 37, 2)\nval groupedNumbers = numbers.groupBy {\n    when {\n        it < 20 -> \"less than 20\"\n        else -> \"greater than or equal to 20\"\n    }\n}\n```", "```\nval deskColor = generateSequence(\"burnt umber\") {\n    buyAnotherPaintSample(it)\n}.first { looksGreat(it) }\n\nprintln(\"Start painting with ${deskColor}!\")\n```", "```\nval catPage = listOf(\n    \"http://ragdollies.com\",\n    \"http://dogs.com\",\n    \"http://moredogs.com\")\n    .map { fetchPage(it) }\n    .first { hasCat(it) }\n```", "```\nval catPage = sequenceOf(\n    \"http://ragdollies.com\",\n    \"http://dogs.com\",\n    \"http://moredogs.com\")\n    .map { fetchPage(it) }\n    .first { hasCat(it) }\n```", "```\nval nums = generateSequence(1) { it + 1 }\n    .map { it * 7 }                 // that's fine\n    .filter { it mod 10000 = 0 }    // still ok\n    .asList()                       // FAIL!\n```", "```\ndata class Attr(val name: String, val tolerance: Tolerance)\n\nenum class Tolerance {\n    CRITICAL,\n    IMPORTANT,\n    REGULAR\n}\n```", "```\ndata class Point(\n    val serial: String,\n    val date: LocalDateTime,\n    val value: Double)\n```", "```\ndata class TimeSeries(val points: List<Point>, val attr: Attr)\n```", "```\nfun createCsv(timeSeries: List<TimeSeries>): String {\n    val distinctAttrs = timeSeries\n        .distinctBy { it.attr } ![1](assets/1.png)\n        .map { it.attr }        ![2](assets/2.png)\n        .sortedBy { it.name }   ![3](assets/3.png)\n\n    val csvHeader = \"date;serial;\" +\n        distinctAttrs.joinToString(\";\") { it.name } +\n        \"\\n\"\n\n    /* Code removed for brevity */\n}\n```", "```\nfun createCsv(timeSeries: List<TimeSeries>): String {\n    /* Code removed for brevity */\n\n    data class PointWithAttr(val point: Point, val attr: Attr)\n\n    // First merge and flatten so we can work with a list of PointWithAttr\n    val pointsWithAttrs = timeSeries.flatMap { ts ->\n        ts.points.map { point -> PointWithAttr(point, ts.attr) }\n\n   /* Code removed for brevity */\n}\n```", "```\nfun createCsv(timeSeries: List<TimeSeries>): String {\n    /* Code removed for brevity */\n\n    val rows = importantPointsWithAttrs.groupBy { it.point.date }  ![1](assets/1.png)\n    .toSortedMap()                                     ![2](assets/2.png)\n    .map { (date, ptsWithAttrs1) ->\n        ptsWithAttrs1\n            .groupBy { it.point.serial }             ![3](assets/3.png)\n            .map { (serial, ptsWithAttrs2) ->\n                listOf(                                        ![4](assets/4.png)\n                    date.format(DateTimeFormatter.ISO_LOCAL_DATE),\n                    serial\n                ) + distinctAttrs.map { attr ->\n                    val value = ptsWithAttrs2.firstOrNull { it.attr == attr }\n                    value?.point?.value?.toString() ?: \"\"\n                }\n            }.joinToString(separator = \"\") {        ![5](assets/5.png)\n                it.joinToString(separator = \";\", postfix = \"\\n\")\n            }\n    }.joinToString(separator = \"\")\n\n    return csvHeader + rows                               ![6](assets/6.png)\n}\n```", "```\nfun createCsv(timeSeries: List<TimeSeries>): String {\n    /* Code removed for brevity */\n\n    val pointsWithAttrs2 = timeSeries.filter {\n        it.attr.tolerance == Tolerance.CRITICAL\n                || it.attr.tolerance == Tolerance.IMPORTANT\n    }.map { series ->\n        series.points.map { point ->\n            PointWithAttr(point, series.attr)\n        }\n    }.flatten()\n\n    /* Code removed for brevity */\n\n    return csvHeader + rows\n}\n```", "```\nfun main() {\n    val dates = listOf<LocalDateTime>(\n        LocalDateTime.parse(\"2020-07-27T15:15:00\"),\n        LocalDateTime.parse(\"2020-07-27T15:25:00\"),\n        LocalDateTime.parse(\"2020-07-27T15:35:00\"),\n        LocalDateTime.parse(\"2020-07-27T15:45:00\")\n    )\n    val seriesExample = listOf(\n        TimeSeries(\n            points = listOf(\n                Point(\"HC11\", dates[3], 15.1),\n                Point(\"HC12\", dates[2], 15.05),\n                Point(\"HC13\", dates[1], 15.11),\n                Point(\"HC14\", dates[0], 15.08)\n            ),\n            attr = Attr(\"AngleOfAttack\", Tolerance.CRITICAL)\n        ),\n        TimeSeries(\n            points = listOf(\n                Point(\"HC11\", dates[3], 0.68),\n                Point(\"HC12\", dates[2], 0.7),\n                Point(\"HC13\", dates[1], 0.69),\n                Point(\"HC14\", dates[0], 0.71)\n            ),\n            attr = Attr(\"ChordLength\", Tolerance.IMPORTANT)\n        ),\n        TimeSeries(\n            points = listOf(\n                Point(\"HC11\", dates[3], 0x2196F3.toDouble()),\n                Point(\"HC14\", dates[0], 0x795548.toDouble())\n            ),\n            attr = Attr(\"PaintColor\", Tolerance.REGULAR)\n        )\n    )\n    val csv = createCsv(seriesExample)\n    println(csv)\n}\n```"]