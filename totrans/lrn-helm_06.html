<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Advanced Chart Features"><div class="chapter" id="advanced_charts">
<h1><span class="label">Chapter 6. </span>Advanced Chart Features</h1>


<p>There is more to charts than metadata about the chart and a collection of templates. Charts can have dependencies, values can have schemas, Helm has life cycle hooks, you can sign charts, and more. In this chapter you will learn about other elements of charts, moving beyond templates.</p>

<p>These features provide powerful solutions to common problems that arise when building packages. The chapter starts by covering dependencies. <a data-type="indexterm" data-primary="dependencies between charts" data-secondary="about" id="idm46125990831256"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="package management and" id="idm46125990792456"/><a data-type="indexterm" data-primary="package managers" data-secondary="dependencies and" id="idm46125990791240"/>Dependencies are a critical part of virtually every package management solution because they let you leverage existing packages in your solution and build on the work of others. It then goes on to cover schemas and validation, which are useful when you want to help chart users avoid issues before covering ways you can hook into processes Helm performs to execute custom actions. This chapter covers tests and testing as well—tests are vital in development because they ensure your software is running as expected. Helm provides security features that aid in mitigating some common threat paths, which are covered next. The chapter concludes by looking at how charts can be used to extend the Kubernetes API.</p>

<p>Throughout this chapter, you will see charts as examples you can reference at <a href="https://github.com/masterminds/learning-helm/blob/main/chapter6"><em class="hyperlink">https://github.com/masterminds/learning-helm/blob/main/chapter6</em></a>. They showcase different features covered in the chapter along with a Helm repository.<a data-type="indexterm" data-primary="resources for learning" data-secondary="charts from chapter 6 of book" id="idm46125990787976"/><a data-type="indexterm" data-primary="charts" data-secondary="online resource for chapter 6 charts" id="idm46125990787096"/></p>






<section data-type="sect1" data-pdf-bookmark="Chart Dependencies"><div class="sect1" id="chart_dependencies">
<h1>Chart Dependencies</h1>

<p>Dependencies are a common element of package managers and their packages. <a data-type="indexterm" data-primary="charts" data-secondary="dependencies" id="ch06-depen"/><a data-type="indexterm" data-primary="dependencies between charts" id="ch06-depen2"/>Charts can have dependencies on other charts. This enables the encapsulation of a service in a chart, the reuse of charts, and the use of multiple charts together.</p>

<p>To illustrate dependencies, consider a chart to install WordPress, the popular <a data-type="indexterm" data-primary="WordPress and chart dependencies" data-secondary="MySQL dependency" id="idm46125990780984"/><a data-type="indexterm" data-primary="MySQL and chart dependencies" id="idm46125990779992"/><a data-type="indexterm" data-primary="manifests" data-secondary="MySQL manifests in WordPress chart" id="idm46125990779304"/>blogging software. WordPress depends on a MySQL-compliant database to store the blog content, users, and other configuration. A MySQL-compliant database can be used by other applications and can be consumed as a service. One way to handle the use of MySQL with WordPress is to put the manifests for it in the WordPress chart. Another way to handle it is to have a MySQL chart that stands alone while the WordPress chart has a dependency on it. Having a MySQL-compliant database as an independent chart enables it to be used by more than one application, and the database can be built and tested independently.</p>

<p>Dependencies are specified in the <em>Chart.yaml</em> file. The following is the <a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="chart dependencies" id="idm46125990763560"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="Chart.yaml file" id="idm46125990762712"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="Chart.yaml file" id="idm46125990761864"/><a data-type="indexterm" data-primary="charts" data-secondary="versions" data-tertiary="dependencies" id="idm46125990760776"/><a data-type="indexterm" data-primary="charts" data-secondary="versions" data-tertiary="Chart.yaml file" id="idm46125990759560"/><code>dependencies</code> section in the <em>Chart.yaml</em> file for a chart named <em>rocket</em>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">dependencies</code><code class="p">:</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">booster</code><code> </code><a class="co" id="co_advanced_chart_features_CO1-1" href="#callout_advanced_chart_features_CO1-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code>    </code><code class="nt">version</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">^1.0.0</code><code> </code><a class="co" id="co_advanced_chart_features_CO1-2" href="#callout_advanced_chart_features_CO1-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code>    </code><code class="nt">repository</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">https://raw.githubusercontent.com/Masterminds/learning-helm/main/</code><code>
</code><code>      </code><code class="l-Scalar-Plain">chapter6/repository/</code><code> </code><a class="co" id="co_advanced_chart_features_CO1-3" href="#callout_advanced_chart_features_CO1-3"><img src="Images/3.png" alt="3"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_chart_features_CO1-1" href="#co_advanced_chart_features_CO1-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The name of the dependent chart within the repository.</p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO1-2" href="#co_advanced_chart_features_CO1-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>A version range string for the chart.</p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO1-3" href="#co_advanced_chart_features_CO1-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>The repository to retrieve the chart from.</p></dd>
</dl>

<p>Helm charts use semantic versions as their versioning scheme. The <code>version</code> field <a data-type="indexterm" data-primary="charts" data-secondary="versions" data-tertiary="Semantic Versioning" id="idm46125990723016"/><a data-type="indexterm" data-primary="versions of Helm" data-secondary="Semantic Versioning" data-tertiary="version field for dependencies" id="idm46125990695512"/><a data-type="indexterm" data-primary="Semantic Versioning" data-secondary="version field for dependencies" id="idm46125990694296"/><a data-type="indexterm" data-primary="version field for dependencies" id="idm46125990693336"/><a data-type="indexterm" data-primary="Helm" data-secondary="versions" data-tertiary="Semantic Versioning" id="idm46125990692648"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="semantic versions" id="idm46125990691432"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="semantic versions" id="idm46125990690216"/>used for dependencies accepts a version range, and there are some shorthand syntaxes for those ranges. For example, <code>^1.2.3</code> is shorthand for <code>&gt;= 1.2.3, &lt; 2.0.0</code>. Helm supports ranges including <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>⇐</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>^</code>, <code>~</code>, and <code>-</code>. Different ranges can be combined together using a space or comma to support logical <em>and</em> combinations and <code>|</code> to support logical <em>or</em> combinations. Helm also supports using a wildcard character of either <code>X</code> or <code>*</code>. If you omit a section of a version, such as omitting the patch portion, Helm will assume the missing part is a wildcard.</p>

<p>Ranges are the preferred manner to specify the desired version. In a moment you’ll learn how to lock to a specific dependency version from the specified range. By specifying a range, it is possible to use Helm commands to automatically update to the latest release within that range. This is useful if you want to pull in bug fixes or security updates to dependencies.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125990681464">
<h5>Shorthand Range Syntaxes</h5>
<p>While semantic versions are defined from a specification, the range syntaxes<a data-type="indexterm" data-primary="versions of Helm" data-secondary="Semantic Versioning" data-tertiary="range syntaxes" id="idm46125990680056"/><a data-type="indexterm" data-primary="version field for dependencies" data-secondary="range syntaxes" id="idm46125990678808"/><a data-type="indexterm" data-primary="Semantic Versioning" data-secondary="range syntaxes" id="idm46125990677800"/> in use to specify semantic version ranges have no specification. Different tools will use different algorithms for the same shorthand syntaxes of <code>^</code> and <code>~</code>. Helm follows the same syntax used by JavaScript with npm and Rust with Cargo.</p>

<p>For major versions greater than 0, when you use <code>^</code> it does a range that is greater than or equal to the number you set and less than the next major version. When the major version is less than 1, Helm typically treats the minor version as the range it works in instead of the major version. The following are examples of the ranges and equivalent meanings:</p>

<ul>
<li>
<p><code>^1.2.3</code> is equivalent to <code>&gt;= 1.2.3 &lt; 2.0.0</code></p>
</li>
<li>
<p><code>^1.2.x</code> is equivalent to <code>&gt;= 1.2.0 &lt; 2.0.0</code></p>
</li>
<li>
<p><code>^2.3</code> is equivalent to <code>&gt;= 2.3 &lt; 3</code></p>
</li>
<li>
<p><code>^2.x</code> is equivalent to <code>&gt;= 2.0.0 &lt; 3</code></p>
</li>
<li>
<p><code>^0.2.3</code> is equivalent to <code>&gt;= 0.2.3 &lt; 0.3.0</code></p>
</li>
<li>
<p><code>^0.2</code> is equivalent to <code>&gt;= 0.2.0 &lt; 0.3.0</code></p>
</li>
<li>
<p><code>^0.0.3</code> is equivalent to <code>&gt;= 0.0.3 &lt; 0.0.4</code></p>
</li>
<li>
<p><code>^0.0</code> is equivalent to <code>&gt;= 0.0.0 &lt; 0.1.0</code></p>
</li>
<li>
<p><code>^0</code> is equivalent to <code>&gt;= 0.0.0 &lt; 1.0.0</code></p>
</li>
</ul>

<p><code>~</code> is used for specifying patch ranges. Where <code><code>^</code></code> typically rounds up to the latest within a major version range, <code><code>~</code></code> rounds up within a minor version range as long as the minor version is specified. The following examples illustrate <code><code>~</code></code>:</p>

<ul>
<li>
<p><code>~1.2.3</code> is equivalent to <code>&gt;= 1.2.3 &lt; 1.3.0</code></p>
</li>
<li>
<p><code>~1</code> is equivalent to <code>&gt;= 1 &lt; 2</code></p>
</li>
<li>
<p><code>~2.3</code> is equivalent to <code>&gt;= 2.3 &lt; 2.4</code></p>
</li>
<li>
<p><code>~1.2.x</code> is equivalent to <code>&gt;= 1.2.0 &lt; 1.3.0</code></p>
</li>
<li>
<p><code>~1.x</code> is equivalent to <code>&gt;= 1 &lt; 2</code></p>
</li>
</ul>
</div></aside>

<p>The <code>repository</code> field is where you specify the chart repository location to pull<a data-type="indexterm" data-primary="chart repositories" data-secondary="repository field of Chart.yaml file" id="idm46125990649368"/><a data-type="indexterm" data-primary="repository field in Chart.yaml file" id="idm46125990648344"/><a data-type="indexterm" data-primary="repositories" data-see="chart repositories" id="idm46125990647704"/> the dependency from. You can specify this in one of the following two ways:</p>

<ul>
<li>
<p>A URL to the Helm repository.</p>
</li>
<li>
<p>To the name of a repository you have set up using the <code>helm repo add</code> command. This name needs to be preceded by an @ and wrapped in quotes (e.g., 
<span class="keep-together"><code>"@myrepo"</code></span>).</p>
</li>
</ul>

<p>A full URL is typically used to specify the location. This will ensure the same dependency is retrieved in every environment the chart is used in.</p>

<p>Once you have the dependencies with their requested version ranges specified, you need to use Helm to lock those dependencies to specific versions and retrieve the dependencies. <a data-type="indexterm" data-primary="packages" data-secondary="packaging a chart" data-tertiary="dependencies" id="idm46125990641560"/><a data-type="indexterm" data-primary="charts" data-secondary="packaging" data-tertiary="dependencies" id="idm46125990640312"/><a data-type="indexterm" data-primary="archive file from packaging chart" data-secondary="dependencies" id="idm46125990639096"/><a data-type="indexterm" data-primary="charts" data-secondary="versions" data-tertiary="distribution of charts" id="idm46125990638184"/>If you are going to package up your chart as a chart archive as covered in <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>, you need to lock and fetch dependencies before packaging.</p>

<p>To resolve the latest version of the dependency within the specified range and to retrieve it, you can use the following command:<a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="chart dependencies" data-tertiary="helm dependency command" id="idm46125990635432"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="helm dependency command" id="idm46125990634184"/><a data-type="indexterm" data-primary="dependency command" id="idm46125990632968"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="helm dependency command" id="idm46125990632296"/><a data-type="indexterm" data-primary="chart repositories" data-secondary="chart dependencies" id="idm46125990631336"/></p>

<pre data-type="programlisting">$ helm dependency update .</pre>

<p>After running the command you will see the following output:</p>

<pre data-type="programlisting">Saving 1 charts
Downloading booster from repo https://raw.githubusercontent.com/Masterminds/
  learning-helm/main/chapter6/repository/
Deleting outdated charts</pre>

<p>Running this command caused a few steps to happen.</p>

<p>First, Helm resolved the latest version of the <em>booster</em> chart. It used the metadata in the repository to know which versions of the chart were available. From the metadata and the specified version range, Helm found the best match.</p>

<p>The resolved information is written to the <em>Chart.lock</em> file. Instead <a data-type="indexterm" data-primary="Chart.lock file" id="idm46125990625768"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="Chart.lock file" id="idm46125990625032"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="Chart.lock file" id="idm46125990624072"/>of a version range, the <em>Chart.lock</em> file contains the specific version of the dependencies to be used. This is important for reproducibility. The <em>Chart.lock</em> file is managed by Helm. Changes from users will be overwritten the next time <code>helm dep up</code> (the shorthand syntax) is run. This is similar to lock files for dependency managers on other platforms.</p>

<p>Once Helm knows the specific version to use, it downloads the dependent <a data-type="indexterm" data-primary="directory structure from create command" data-secondary="charts subdirectory for dependent charts" id="idm46125990620776"/><a data-type="indexterm" data-primary="templates" data-secondary="charts subdirectory" id="idm46125990619688"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="charts subdirectory" id="idm46125990618712"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="charts subdirectory" id="idm46125990617496"/>chart and puts it into the <em>charts</em> subdirectory. It is important for the dependent charts to be in the <em>charts</em> directory because this is where Helm will get their contents from to render the templates. Charts can be in the <em>charts</em> directory in either their archive or directory form. When Helm downloads them from a repository, it stores them in their archive form.</p>

<p>If you have a <em>Chart.lock</em> file but no contents in the <em>charts</em> directory, <a data-type="indexterm" data-primary="dependency command" data-secondary="rebuilding charts directory" id="idm46125990613544"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="helm dependency command" data-tertiary="rebuilding charts directory" id="idm46125990612472"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="helm dependency build command" id="idm46125990611224"/>you can rebuild the <em>charts</em> directory by running the command <code>helm dependency build</code>. This will use the lock file to retrieve the dependencies at their already determined versions.</p>

<p>Once you have dependencies, Helm will render their resources when you run commands like <code>helm install</code> or <code>helm upgrade</code>.</p>

<p>When you specify a dependency, you may also want to pass configuration<a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="configuration via values.yaml" id="idm46125990607208"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="configuration via values.yaml" id="idm46125990605864"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="dependent chart configuration" id="idm46125990604888"/><a data-type="indexterm" data-primary="configuration" data-secondary="dependent charts via values.yaml" id="idm46125990603928"/><a data-type="indexterm" data-primary="WordPress and chart dependencies" data-secondary="passing configuration" id="idm46125990602968"/> from the parent or main chart to the dependent chart. If we look back at the WordPress example, this could be used to set the name of the database to use. Helm provides a method to do this within the parent chart’s values.</p>

<p>In the main chart’s <em>values.yaml</em> file, you can create a new section with the name of the dependent chart. In this section you can set the values you want passed in. You only need to set the ones you want changed because the dependent charts included in the <em>values.yaml</em> file will serve as the default values.</p>

<p>In the <em>values.yaml</em> file for the <em>rocket</em> chart there is a section that reads:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">booster</code><code class="p">:</code>
  <code class="nt">image</code><code class="p">:</code>
    <code class="nt">tag</code><code class="p">:</code> <code class="l-Scalar-Plain">9.17.49</code></pre>

<p>Helm knows this section is for the <em>booster</em> chart. In this case it sets the image tag to a specific value. Any of the values in the dependent chart can be set this way. When commands like <code>helm install</code> are run, you can use the flags to set values (e.g., <code>--set</code>) of the dependencies as well as those of the main chart.</p>

<p>If you have two dependencies on the same chart you can optionally <a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="alias property" id="idm46125990579896"/><a data-type="indexterm" data-primary="alias property in Chart.yaml file" id="idm46125990578952"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="Chart.yaml file" data-tertiary="alias property" id="idm46125990578312"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="Chart.yaml file alias property" id="idm46125990577128"/><a data-type="indexterm" data-primary="names" data-secondary="alias property in Chart.yaml file" id="idm46125990591128"/>use the <code>alias</code> property in the <em>Chart.yaml</em> file. This property goes on each dependency you want to use an alternative name for next to the <code>name</code>, <code>version</code>, and other properties. With <code>alias</code> you can give each dependency a unique name that you can reference elsewhere, such as in the <em>values.yaml</em> file.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125990587304">
<h5>Tightly Versus Loosely Coupled Dependencies</h5>
<p>When you have dependencies, you can tightly couple or loosely couple them.<a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="tightly versus loosely coupled" id="idm46125990576776"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="tightly versus loosely coupled" id="idm46125990575480"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="chart dependencies" data-tertiary="tightly versus loosely coupled" id="idm46125990574504"/><a data-type="indexterm" data-primary="tight coupling between charts" id="idm46125990573272"/> Using the <em>Chart.yaml</em> file to specify dependencies causes a tight coupling between charts. You can see this in the way upgrades work. To upgrade one chart you must upgrade the whole group. There are benefits to tight coupling, such as a single Helm command being able to install the whole collection of charts. A tight coupling is useful when you want to distribute charts to others, outside your company or organization.</p>

<p>In a loose coupling situation you can install each chart independently<a data-type="indexterm" data-primary="loose coupling between charts" id="idm46125990571208"/> from the rest. Each chart will run as its own instance. In this setup, each instance acts as a service that other services can connect to. With a loose coupling you can change and upgrade each chart independently from the rest. This method is sometimes used when you create and run charts within your own organization.</p>
</div></aside>








<section data-type="sect2" data-pdf-bookmark="Conditional Flags for Enabling Dependencies"><div class="sect2" id="idm46125990569768">
<h2>Conditional Flags for Enabling Dependencies</h2>

<p>Helm provides the ability for you to enable or disable dependencies through configuration.<a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="conditional dependencies" id="idm46125990549944"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="conditional dependencies" id="idm46125990548728"/><a data-type="indexterm" data-primary="conditional dependencies" id="idm46125990547752"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="chart dependencies" data-tertiary="conditional" id="idm46125990547064"/><a data-type="indexterm" data-primary="WordPress and chart dependencies" data-secondary="conditional dependencies" id="idm46125990545848"/> To illustrate this idea, consider the case where you want to provide a WordPress blogging solution but give the option to the personnel installing WordPress to either use a database as a service or an included database. If the person installing the chart chooses to use a database as a service, they would provide a URL to that service and not need to have a database installed. This can be accomplished through configuration in two different ways.</p>

<p>When you want to control if a single feature is enabled or disabled through a dependency, you can use the <code>condition</code> property on a dependency. To illustrate this we will look at the <code>dependencies</code> section in the <em>Chart.yaml</em> file for the conditional chart:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">dependencies</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">booster</code>
    <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">^1.0.0</code>
    <code class="nt">condition</code><code class="p">:</code> <code class="l-Scalar-Plain">booster.enabled</code>
    <code class="nt">repository</code><code class="p">:</code> <code class="l-Scalar-Plain">https://raw.githubusercontent.com/Masterminds/learning-helm/main/</code>
      <code class="l-Scalar-Plain">chapter6/repository/</code></pre>

<p>The dependency has a <code>condition</code> key with a value that tells Helm where to look in the values to know if it should be enabled or disabled. In the <em>values.yaml</em> file the corresponding section is:<a data-type="indexterm" data-primary="values.yaml file" data-secondary="dependent chart configuration" data-tertiary="conditional dependencies" id="idm46125990523640"/></p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">booster</code><code class="p">:</code>
  <code class="nt">enabled</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code></pre>

<p>The default value, in this case, is to disable the dependency. When someone installs the chart they can enable the dependency by passing in a value to enable it.</p>

<p>When you have multiple features you want to enable or disable that involve <a data-type="indexterm" data-primary="dependencies between charts" data-secondary="tags property" id="idm46125990520040"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="tags property" id="idm46125990519192"/><a data-type="indexterm" data-primary="tags property in dependencies" id="idm46125990516568"/>dependencies, you can use the <code>tags</code> property. Like <code>condition</code>, this property sits alongside the <code>name</code> and <code>version</code> when describing a dependency. It contains a list of tags for a dependency. To illustrate this we can look at the dependencies of another chart named <em>tag</em>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">dependencies</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">booster</code>
    <code class="nt">tags</code><code class="p">:</code>
      <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">faster</code>
    <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">^1.0.0</code>
    <code class="nt">repository</code><code class="p">:</code> <code class="l-Scalar-Plain">https://raw.githubusercontent.com/Masterminds/learning-helm/main/</code>
      <code class="l-Scalar-Plain">chapter6/repository/</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">rocket</code>
    <code class="nt">tags</code><code class="p">:</code>
      <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">faster</code>
    <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">^1.0.0</code>
    <code class="nt">repository</code><code class="p">:</code> <code class="l-Scalar-Plain">https://raw.githubusercontent.com/Masterminds/learning-helm/main/</code>
      <code class="l-Scalar-Plain">chapter6/repository/</code></pre>

<p>Here you will see two dependencies with a <code>tags</code> section. The tags are a list of related tags. In the chart’s <em>values.yaml</em> file you use a <code>tags</code> property:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">tags</code><code class="p">:</code>
  <code class="nt">faster</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code></pre>

<p><code>tags</code> is a property with a special meaning. The values here tell Helm to disable dependencies with the tag <em>faster</em> by default. They can be enabled when the chart’s user passes a true value into the chart as it’s being installed or upgraded.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Importing Values from Child to Parent Charts"><div class="sect2" id="idm46125990551032">
<h2>Importing Values from Child to Parent Charts</h2>

<p>There are times where you may want to import or pull values from a child to a parent chart. Helm provides two methods to do this. One is for the case where a child chart explicitly exported a value to be imported by a parent, and the other is for the case in which the child chart did not export a value.</p>










<section data-type="sect3" data-pdf-bookmark="The exports property"><div class="sect3" id="idm46125990390760">
<h3>The exports property</h3>

<p>The <code>exports</code> property is a special top-level property in a <em>values.yaml</em> file.<a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="child chart exporting value" id="idm46125990388104"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="child chart exporting value" id="idm46125990410328"/><a data-type="indexterm" data-primary="export property in dependencies" id="idm46125990409448"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="dependent chart configuration" data-tertiary="child chart exporting value" id="idm46125990408808"/><a data-type="indexterm" data-primary="YAML" data-secondary="values.yaml file" data-tertiary="child chart exporting value" id="idm46125990407560"/> When a child chart has declared an <code>export</code> property, its contents can be imported directly into a parent chart.</p>

<p>For example, consider the following from a child chart’s <em>values.yaml</em> file:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">exports</code><code class="p">:</code>
  <code class="nt">types</code><code class="p">:</code>
    <code class="nt">foghorn</code><code class="p">:</code> <code class="l-Scalar-Plain">rooster</code></pre>

<p>When the parent chart declares the child as a dependency, it can import from the exports like the following:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">dependencies</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example-child</code>
    <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">^1.0.0</code>
    <code class="nt">repository</code><code class="p">:</code> <code class="l-Scalar-Plain">https://charts.example.com/</code>
    <code class="nt">import-values</code><code class="p">:</code>
      <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">types</code></pre>

<p>Within the parent’s calculated values the types are now accessible at the top level. In YAML that would be equivalent to:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">foghorn</code><code class="p">:</code> <code class="l-Scalar-Plain">rooster</code></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="The child-parent format"><div class="sect3" id="idm46125990292392">
<h3>The child-parent format</h3>

<p>When a parent chart wants to import a value from a child but the child chart<a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="child chart value without export" id="idm46125990315320"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="child chart value without export" id="idm46125990314104"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="dependent chart configuration" data-tertiary="child chart value without export" id="idm46125990272584"/><a data-type="indexterm" data-primary="import-values property in dependencies" id="idm46125990271384"/> hasn’t exported the value, there is a way to tell Helm to pull the child value into the parent chart.</p>

<p>To illustrate this, consider a child chart with the following values specified in its 
<span class="keep-together"><em>values.yaml</em></span> file:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">types</code><code class="p">:</code>
  <code class="nt">foghorn</code><code class="p">:</code> <code class="l-Scalar-Plain">rooster</code></pre>

<p>These values are not exported, but the parent chart can import them anyway. When the dependency is declared in the parent, it can import the values using <code>child</code> and <code>parent</code> files, like the following example:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">dependencies</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example-child</code>
    <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">^1.0.0</code>
    <code class="nt">repository</code><code class="p">:</code> <code class="l-Scalar-Plain">https://charts.example.com/</code>
    <code class="nt">import-values</code><code class="p">:</code>
      <code class="p-Indicator">-</code> <code class="nt">child</code><code class="p">:</code> <code class="l-Scalar-Plain">types</code>
        <code class="nt">parent</code><code class="p">:</code> <code class="l-Scalar-Plain">characters</code></pre>

<p>In both methods of importing it’s the <code>import-values</code> property that’s used on the dependency. Helm knows how to differentiate between the different formats, and you can mix the two.</p>

<p>In the child chart the top-level property of <code>types</code> will not be available in the parent chart under the top-level property of <code>characters</code> in its calculated values. That would be represented in YAML as:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">characters</code><code class="p">:</code>
  <code class="nt">foghorn</code><code class="p">:</code> <code class="l-Scalar-Plain">rooster</code></pre>

<p>This format does allow for accessing nested values in addition to top-level properties using a period as a separator. For example, if the child chart had the following format, the <code>child</code> property on <code>import-values</code> could read <code>data.types</code>:<a data-type="indexterm" data-startref="ch06-depen" id="idm46125990164568"/><a data-type="indexterm" data-startref="ch06-depen2" id="idm46125990163832"/></p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">data</code><code class="p">:</code>
  <code class="nt">types</code><code class="p">:</code>
    <code class="nt">foghorn</code><code class="p">:</code> <code class="l-Scalar-Plain">rooster</code></pre>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Library Charts"><div class="sect1" id="idm46125990785144">
<h1>Library Charts</h1>

<p>You may run into the situation where you are creating multiple similar charts—charts that share a lot of the same templates. For these situations, there are library charts.<a data-type="indexterm" data-primary="charts" data-secondary="library charts" id="ch06-lib"/><a data-type="indexterm" data-primary="library charts" id="ch06-lib3"/><a data-type="indexterm" data-primary="templates" data-secondary="library charts" id="ch06-lib2"/></p>

<p>Library charts are conceptually similar to software libraries. They provide reusable functionality that can be imported and used by other charts but cannot be installed themselves.</p>

<p>If you use <code>helm create</code> to create a new library chart, the first step is to <a data-type="indexterm" data-primary="create command" data-secondary="library charts" id="idm46125990197224"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="library chart creation" id="idm46125990146952"/>remove the contents of the <em>templates</em> directory and the <em>values.yaml</em> file because neither of these will be used. <a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="type property" data-tertiary="library chart creation" id="idm46125990144984"/><a data-type="indexterm" data-primary="type property" data-secondary="library chart creation" id="idm46125990143736"/>Then, you need to tell Helm that this is a library chart. In the <em>Chart.yaml</em> file set the <code>type</code> to <code>library</code>. To illustrate this, here is the <em>Chart.yaml</em> file from a chart named <em>mylib</em>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v2</code>
<code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">mylib</code>
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">library</code>
<code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">an example library chart</code>
<code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">0.1.0</code></pre>

<p>The default value for <code>type</code>, when not set, is application. You only <a data-type="indexterm" data-primary="type property" data-secondary="application default" id="idm46125990104600"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="type property" data-tertiary="application default" id="idm46125990103832"/>need to set it when your chart is a library.</p>

<p>Files in the <em>templates</em> directory that start with an underscore (i.e., <code><code>_</code></code>) are not expected to render manifests<a data-type="indexterm" data-primary="_ (underscore) before file names" data-primary-sortas="_ underscore" id="idm46125990100728"/><a data-type="indexterm" data-primary="underscore (_) before file names" id="idm46125990099816"/><a data-type="indexterm" data-primary="templates" data-secondary="about" data-tertiary="_ (underscore) before file names" data-tertiary-sortas="underscore" id="idm46125990099176"/><a data-type="indexterm" data-primary="snippets in _*.yaml files" id="idm46125990097672"/><a data-type="indexterm" data-primary="YAML" data-secondary="snippets in _*.yaml files" id="idm46125990096984"/> to send to Kubernetes. The convention is that helper templates and snippets are in _<em>*.tpl</em> and _<em>*.yaml</em> files.</p>

<p>To illustrate how reusable templates work, the following is the template to <a data-type="indexterm" data-primary="library charts" data-secondary="how reusable templates work" id="idm46125990094520"/><a data-type="indexterm" data-primary="charts" data-secondary="library charts" data-tertiary="how reusable templates work" id="idm46125990093576"/><a data-type="indexterm" data-primary="templates" data-secondary="library charts" data-tertiary="how reusable templates work" id="idm46125990092392"/><a data-type="indexterm" data-primary="ConfigMaps (Kubernetes)" data-secondary="library chart use example" id="idm46125990091160"/><a data-type="indexterm" data-primary="YAML" data-secondary="library chart" id="idm46125990090200"/>create a <code>ConfigMap</code> in the <em>mylib</em> chart file named <em>_configmap.yaml</em>:</p>

<pre data-type="programlisting">{{- define "mylib.configmap.tpl" -}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "mylib.fullname" . }} <a class="co" id="co_advanced_chart_features_CO2-1" href="#callout_advanced_chart_features_CO2-1"><img src="Images/1.png" alt="1"/></a>
  labels:
    {{- include "mylib.labels" . | nindent 4 }} <a class="co" id="co_advanced_chart_features_CO2-2" href="#callout_advanced_chart_features_CO2-2"><img src="Images/2.png" alt="2"/></a>
data: {}
{{- end -}}
{{- define "mylib.configmap" -}} <a class="co" id="co_advanced_chart_features_CO2-3" href="#callout_advanced_chart_features_CO2-3"><img src="Images/3.png" alt="3"/></a>
{{- template "mylib.util.merge" (append . "mylib.configmap.tpl") -}}
{{- end -}}</pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_chart_features_CO2-1" href="#co_advanced_chart_features_CO2-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The <code>fullname</code> function is the same as the one generated by <code>helm create</code>.</p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO2-2" href="#co_advanced_chart_features_CO2-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>The <code>labels</code> function generates the common labels Helm recommends to use in charts.<a data-type="indexterm" data-primary="labels" data-secondary="labels function" id="idm46125990055272"/></p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO2-3" href="#co_advanced_chart_features_CO2-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>A special template is defined that knows how to merge templates together.<a data-type="indexterm" data-primary="merge function" id="idm46125990051848"/></p></dd>
</dl>

<p>Most of this definition looks similar to other templates you would put into the <em>templates</em> directory.<a data-type="indexterm" data-primary="define function" id="idm46125990050152"/> <code>define</code> is a function used to define a template that is used elsewhere. There are two templates defined in this file. <em>mylib.configmap.tpl</em> contains a template for a resource. This will look similar to other templates. It provides a blueprint that is meant to be overridden by the caller in a chart that includes this library. <em>mylib.configmap</em> is a special template. This is the template another chart will use. It takes <em>mylib.configmap.tpl</em> along with another template, yet to be defined, containing overrides, and merges them into one output. <em>mylib.configmap</em> uses a utility function that handles the merging and is handy to reuse. That function is:</p>

<pre data-type="programlisting">{{- /*
mylib.util.merge will merge two YAML templates and output the result.
This takes an array of three values:
- the top context
- the template name of the overrides (destination)
- the template name of the base (source)
*/ -}}
{{- define "mylib.util.merge" -}}
{{- $top := first . -}}
{{- $overrides := fromYaml (include (index . 1) $top) | default (dict ) -}}
{{- $tpl := fromYaml (include (index . 2) $top) | default (dict ) -}}
{{- toYaml (merge $overrides $tpl) -}}
{{- end -}}</pre>

<p>This function takes a context (think about the <code>.</code> data covered in <a data-type="xref" href="ch05.xhtml#developing_templates">Chapter 5</a>), a template containing overrides, and the base template function to be overridden. The function will become more clear when you see how it is used.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The concept of library charts was developed prior to their official inclusion in Helm. <a data-type="indexterm" data-primary="merge function" data-secondary="creator Adnan Abdulhussein" id="idm46125990042488"/><a data-type="indexterm" data-primary="Abdulhussein, Adnan" id="idm46125990041448"/>The <code>merge</code> function was created by Adnan Abdulhussein as part of his work developing the idea through a chart named <em>Common</em>.</p>
</div>

<p>To illustrate using this library function, the following template is from another chart named <em>mychart</em>. Prior to using the resources it defines, it needs to be added as a dependency, just like any other. A template is included in <em>mychart</em> to create a <code>ConfigMap</code>:</p>

<pre data-type="programlisting">{{- include "mylib.configmap" (list . "mychart.configmap") -}} <a class="co" id="co_advanced_chart_features_CO3-1" href="#callout_advanced_chart_features_CO3-1"><img src="Images/1.png" alt="1"/></a>
{{- define "mychart.configmap" -}} <a class="co" id="co_advanced_chart_features_CO3-2" href="#callout_advanced_chart_features_CO3-2"><img src="Images/2.png" alt="2"/></a>
data: <a class="co" id="co_advanced_chart_features_CO3-3" href="#callout_advanced_chart_features_CO3-3"><img src="Images/3.png" alt="3"/></a>
  myvalue: "Hello Bosko"
{{- end -}}</pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_chart_features_CO3-1" href="#co_advanced_chart_features_CO3-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>Including and using the function from the library chart for the <code>ConfigMap</code>.</p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO3-2" href="#co_advanced_chart_features_CO3-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>A new template is defined with just the parts to override the template provided by the library.</p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO3-3" href="#co_advanced_chart_features_CO3-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>The <code>data</code> section is provided for use in the <code>ConfigMap</code>.</p></dd>
</dl>

<p>This template may appear to be confusing at first because there is a lot going on.</p>

<p>The first line includes the <code>ConfigMap</code> template from the library chart. A new list is passed to it with two items. The first is the current data object, and the second is the name of another template containing elements to override those provided by the library chart.</p>

<p>The rest of the file is the template containing overrides. In the template provided by the library chart no content was provided for the <code>data</code> section. It is empty. The function <code>mychart.configmap</code> provides a <code>data</code> section.</p>

<p>The Helm rendered output from this template is:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ConfigMap</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="nt">app.kubernetes.io/instance</code><code class="p">:</code> <code class="l-Scalar-Plain">example</code>
    <code class="nt">app.kubernetes.io/managed-by</code><code class="p">:</code> <code class="l-Scalar-Plain">Helm</code>
    <code class="nt">app.kubernetes.io/name</code><code class="p">:</code> <code class="l-Scalar-Plain">mychart</code>
    <code class="nt">helm.sh/chart</code><code class="p">:</code> <code class="l-Scalar-Plain">mychart-0.1.0</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example-mychart</code>
<code class="nt">data</code><code class="p">:</code>
  <code class="nt">myvalue</code><code class="p">:</code> <code class="l-Scalar-Plain">Hello Bosko</code></pre>

<p>This output is the merged output from the library and the chart consuming the library. The same concept can be extended to other resources including those that are longer and more complex.<a data-type="indexterm" data-startref="ch06-lib" id="idm46125989943112"/><a data-type="indexterm" data-startref="ch06-lib2" id="idm46125989984024"/><a data-type="indexterm" data-startref="ch06-lib3" id="idm46125989983416"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Schematizing Values Files"><div class="sect1" id="idm46125990190248">
<h1>Schematizing Values Files</h1>

<p>The values defined by a <em>values.yaml</em> file are schemaless. There is no set structure<a data-type="indexterm" data-primary="Values" data-secondary="schematizing" id="idm46125989980776"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="schematizing" id="idm46125989979800"/><a data-type="indexterm" data-primary="schematizing values.yaml files" id="idm46125989978856"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="schematizing values.yaml files" id="idm46125989978168"/><a data-type="indexterm" data-primary="YAML" data-secondary="values.yaml file" data-tertiary="schematizing" id="idm46125989977192"/> that all <em>values.yaml</em> files need to follow. Different charts have different structures. This enables you to structure the values to the application or workload you’re deploying with the chart.</p>

<p>Schemas provide numerous useful benefits including the ability to validate content,<a data-type="indexterm" data-primary="schematizing values.yaml files" data-secondary="benefits of schemas" id="idm46125989974952"/> and you can do things such as generate user interfaces from them.</p>

<p>Helm provides the optional ability for each chart to provide its own <a data-type="indexterm" data-primary="JSON (JavaScript Object Notation)" data-secondary="JSON Schema" id="idm46125989973496"/><a data-type="indexterm" data-primary="schematizing values.yaml files" data-secondary="JSON Schema" id="idm46125989972504"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="schematizing" data-tertiary="JSON Schema" id="idm46125989971544"/>schema for its values using <a href="https://json-schema.org">JSON Schema</a>. JSON Schema provides a vocabulary to describe JSON files. YAML is a superset of JSON, and you can transform content between the two file formats. This makes it possible to use a JSON Schema to validate the content of a YAML file.<a data-type="indexterm" data-primary="resources for learning" data-secondary="JSON Schema" id="idm46125989969304"/></p>

<p>When you run the commands <code>helm install</code>, <code>helm upgrade</code>, <code>helm lint</code>, and <code>helm template</code>, <a data-type="indexterm" data-primary="values.schema.json file" id="idm46125989965960"/>Helm will validate the values against what it finds in the <em>values.schema.json</em> file. The values Helm validates are the computed values. They include the values provided by the chart as well as the values passed in by the person installing the chart. The <em>values.schema.json</em> file lives next to the <em>values.yaml</em> file in the root of a chart. The file can describe all or part of the values.</p>

<p>Consider the following section from a <em>values.yaml</em> file:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">image</code><code class="p">:</code>
  <code class="nt">repository</code><code class="p">:</code> <code class="l-Scalar-Plain">ghcr.io/masterminds/learning-helm/anvil-app</code>
  <code class="nt">pullPolicy</code><code class="p">:</code> <code class="l-Scalar-Plain">IfNotPresent</code>
  <code class="nt">tag</code><code class="p">:</code> <code class="s">""</code></pre>

<p>A JSON Schema to check this would be:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code>
    </code><code class="nt">"$schema"</code><code class="p">:</code><code> </code><code class="s2">"http://json-schema.org/schema#"</code><code class="p">,</code><code>
    </code><code class="nt">"type"</code><code class="p">:</code><code> </code><code class="s2">"object"</code><code class="p">,</code><code>
    </code><code class="nt">"properties"</code><code class="p">:</code><code> </code><code class="p">{</code><code>
        </code><code class="nt">"image"</code><code class="p">:</code><code> </code><code class="p">{</code><code>
            </code><code class="nt">"type"</code><code class="p">:</code><code> </code><code class="s2">"object"</code><code class="p">,</code><code> </code><a class="co" id="co_advanced_chart_features_CO4-1" href="#callout_advanced_chart_features_CO4-1"><img src="Images/1.png" alt="1"/></a><code>
            </code><code class="nt">"properties"</code><code class="p">:</code><code> </code><code class="p">{</code><code>
                </code><code class="nt">"pullPolicy"</code><code class="p">:</code><code> </code><code class="p">{</code><code>
                    </code><code class="nt">"type"</code><code class="p">:</code><code> </code><code class="s2">"string"</code><code class="p">,</code><code> </code><a class="co" id="co_advanced_chart_features_CO4-2" href="#callout_advanced_chart_features_CO4-2"><img src="Images/2.png" alt="2"/></a><code>
                    </code><code class="nt">"enum"</code><code class="p">:</code><code> </code><code class="p">[</code><code class="s2">"Always"</code><code class="p">,</code><code> </code><code class="s2">"IfNotPresent"</code><code class="p">]</code><code> </code><a class="co" id="co_advanced_chart_features_CO4-3" href="#callout_advanced_chart_features_CO4-3"><img src="Images/3.png" alt="3"/></a><code>
                </code><code class="p">}</code><code class="p">,</code><code>
                </code><code class="nt">"repository"</code><code class="p">:</code><code> </code><code class="p">{</code><code>
                    </code><code class="nt">"type"</code><code class="p">:</code><code> </code><code class="s2">"string"</code><code>
                </code><code class="p">}</code><code class="p">,</code><code>
                </code><code class="nt">"tag"</code><code class="p">:</code><code> </code><code class="p">{</code><code>
                    </code><code class="nt">"type"</code><code class="p">:</code><code> </code><code class="s2">"string"</code><code>
                </code><code class="p">}</code><code>
            </code><code class="p">}</code><code>
        </code><code class="p">}</code><code>
    </code><code class="p">}</code><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_chart_features_CO4-1" href="#co_advanced_chart_features_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p><code>image</code> is an object. If <code>image</code> is passed to Helm as something other than an object, an error will be thrown.</p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO4-2" href="#co_advanced_chart_features_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p><code>pullPolicy</code> is a string. When other types, such as an integer, are passed in, an error will be thrown. This can catch subtle problems.</p></dd>
<dt><a class="co" id="callout_advanced_chart_features_CO4-3" href="#co_advanced_chart_features_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <code>pullPolicy</code> must be one of the listed values. When another value, even a misspelling, is passed in to Helm, an error will be thrown.</p></dd>
</dl>

<p>To illustrate this, we can use the <em>booster</em> chart. If you run the command from the root of the chart, you’ll see an error:</p>

<pre data-type="programlisting">$ helm lint . --set image.pullPolicy=foo</pre>

<p>The following error tells you where the values don’t match the schema:</p>

<pre data-type="programlisting">==&gt; Linting .
[ERROR] templates/: values don't meet the specifications of the schema(s) in the
following chart(s):
booster:
- image.pullPolicy: image.pullPolicy must be one of the following: "Always",
  "IfNotPresent"


Error: 1 chart(s) linted, 1 chart(s) failed</pre>

<p>JSON Schemas provide several ways to describe properties. The most flexible method (a catch-all) is the use of regular expressions for strings. For example, instead of an <code>enum</code> a <code>pattern</code> of <code>^(Always|IfNotPresent)$</code> could have been used. The pattern would not have been as descriptive. The error would have noted the value didn’t fit the pattern. Patterns are great to use when there is no other method to describe a property’s value.</p>

<p>Schemas are a useful addition to charts that can catch and correct <a data-type="indexterm" data-primary="schematizing values.yaml files" data-secondary="benefits of schemas" id="idm46125989906920"/>subtle issues someone may have when installing a chart.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Hooks"><div class="sect1" id="idm46125989738472">
<h1>Hooks</h1>

<p>Helm provides a means to hook into events in the release process and take action.<a data-type="indexterm" data-primary="releases" data-secondary="hooking into events" id="idm46125989224056"/><a data-type="indexterm" data-primary="hooks" id="idm46125989223080"/><a data-type="indexterm" data-primary="releases" data-secondary="actions bundled as part of" id="idm46125989222408"/> This is useful if you want to bundle actions as part of a release—for example, building in the ability to back up a database as part of the upgrade process while ensuring that the backup occurs prior to upgrading the Kubernetes resources.</p>

<p>Hooks are like regular templates and the functionality they encapsulate is <a data-type="indexterm" data-primary="resources" data-secondary="hooks" id="idm46125986350536"/>provided through containers running in Kubernetes clusters alongside the other resources for your application. What distinguishes hooks from other resources is when a special annotation is set. When Helm sees the <code>helm.sh/hook</code> annotation, it uses the resource as a hook instead of a resource to be installed as part of the application installed by the chart. <a data-type="xref" href="#table_6-1">Table 6-1</a> contains a list of hooks and when they are executed.</p>
<table id="table_6-1">
<caption><span class="label">Table 6-1. </span>Helm hooks</caption>
<thead>
<tr>
<th>Annotation value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>pre-install</p></td>
<td><p>Execution happens after resources are rendered but prior to those resources being uploaded to Kubernetes.</p></td>
</tr>
<tr>
<td><p>post-install</p></td>
<td><p>Execution happens after resources have been uploaded to Kubernetes.</p></td>
</tr>
<tr>
<td><p>pre-delete</p></td>
<td><p>Execution happens on a deletion request prior to any resources being deleted from Kubernetes.</p></td>
</tr>
<tr>
<td><p>post-delete</p></td>
<td><p>Execution happens after all resources have been deleted from Kubernetes.</p></td>
</tr>
<tr>
<td><p>pre-upgrade</p></td>
<td><p>Execution happens after resources are rendered but prior to resources being updated in Kubernetes.</p></td>
</tr>
<tr>
<td><p>post-upgrade</p></td>
<td><p>Execution happens after resources have been upgraded in Kubernetes.</p></td>
</tr>
<tr>
<td><p>pre-rollback</p></td>
<td><p>Execution happens after resources have been rendered but prior to any resources in Kubernetes being rolled back.</p></td>
</tr>
<tr>
<td><p>post-rollback</p></td>
<td><p>Execution happens after resources have been rolled back in Kubernetes.</p></td>
</tr>
<tr>
<td><p>test</p></td>
<td><p>Execution occurs when the <code>helm test</code> command is run. Tests are covered in the next section.</p></td>
</tr>
</tbody>
</table>

<p>A single resource can implement more than one hook by listing them as a comma-separated list. For example:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">annotations</code><code class="p">:</code>
  <code class="s">"helm.sh/hook"</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">pre-install,pre-upgrade</code></pre>

<p>Hooks can be weighted and specify a deletion policy for the resources<a data-type="indexterm" data-primary="deletion policies of hooks" id="idm46125986321256"/> after they have run. The weight enables more than one hook for the same event to be specified while providing an order in which they will run. This gives you the ability to ensure a deterministic order. Because Kubernetes resources are used for the execution of hooks, the resources are stored in Kubernetes even after execution has completed. The deletion policy provides you with some additional control on when to delete these resources from Kubernetes.</p>

<p>The following code provides example annotations specifying all three values:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">annotations</code><code class="p">:</code>
  <code class="s">"helm.sh/hook"</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">pre-install,pre-upgrade</code>
  <code class="s">"helm.sh/hook-weight"</code><code class="p-Indicator">:</code> <code class="s">"1"</code>
  <code class="s">"helm.sh/hook-delete-policy"</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">before-hook-creation,hook-succeeded</code></pre>

<p>The weight, specified by the <code>helm.sh/hook-weight</code> annotation key, is a number represented as a string. It should always be a string. The weight can be a positive or negative number and has a default value of <code>0</code>. Prior to executing hooks, Helm sorts them in ascending order.</p>

<p>The deletion policy, set using the annotation key <code>helm.sh/hook-delete-policy</code>, is a comma-separated list of policy options. The three possible deletion policies are found in <a data-type="xref" href="#table_6-2">Table 6-2</a>.</p>
<table id="table_6-2">
<caption><span class="label">Table 6-2. </span>Helm hook deletion policies</caption>
<thead>
<tr>
<th>Policy value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>before-hook-creation</p></td>
<td><p>The previous resource is deleted before a new instance of this hook is launched. This is the default.</p></td>
</tr>
<tr>
<td><p>hook-succeeded</p></td>
<td><p>Delete the Kubernetes resource after the hook is successfully run.</p></td>
</tr>
<tr>
<td><p>hook-failed</p></td>
<td><p>Delete the Kubernetes resource if the hook failed while executing.</p></td>
</tr>
</tbody>
</table>

<p>By default, Helm keeps the Kubernetes resources used for hooks until the hook is run again. This provides the ability to inspect the logs or look at other information about a hook after it is run. A common policy to set is the one used in the previous example. This will keep hook resources around unless they complete successfully. When hooks fail, the resources and their logs are still available for inspection, but otherwise they are deleted.</p>

<p>The following <code>Pod</code> is an example of a hook running post-install:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="s">"{{</code><code class="nv"> </code><code class="s">include</code><code class="nv"> </code><code class="s">"</code><code class="l-Scalar-Plain">mychart.fullname" . }}-post-install"</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="p-Indicator">{{</code><code class="nv">- include "mychart.labels" . | nindent 4</code> <code class="p-Indicator">}}</code>
  <code class="nt">annotations</code><code class="p">:</code>
    <code class="s">"helm.sh/hook"</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">post-install</code>
    <code class="s">"helm.sh/hook-weight"</code><code class="p-Indicator">:</code> <code class="s">"-1"</code>
    <code class="s">"helm.sh/hook-delete-policy"</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">before-hook-creation,hook-succeeded</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">containers</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">wget</code>
      <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">busybox</code>
      <code class="nt">command</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"/bin/sleep"</code><code class="p-Indicator">,</code><code class="s">"{{</code><code class="nv"> </code><code class="s">default</code><code class="nv"> </code><code class="s">"</code><code class="nv">10" .Values.sleepTime</code> <code class="err">}}</code><code class="s">"]</code>
  <code class="s">restartPolicy:</code><code class="nv"> </code><code class="s">Never</code></pre>

<p>If you are running a Helm command, such as <code>helm install</code>, and want to <a data-type="indexterm" data-primary="hooks" data-secondary="no-hooks flag" id="idm46125986265928"/><a data-type="indexterm" data-primary="releases" data-secondary="hooking into events" data-tertiary="no-hooks flag" id="idm46125986188696"/>skip running hooks, the <code>--no-hooks</code> flag can be used. This flag is available on commands that have hooks and will cause Helm to skip executing them. Hooks are an opt-out 
<span class="keep-together">feature</span>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Adding Tests to Charts"><div class="sect1" id="idm46125989905592">
<h1>Adding Tests to Charts</h1>

<p>Testing is an integral part of software development, and Helm provides the <a data-type="indexterm" data-primary="charts" data-secondary="tests added to" data-tertiary="about" id="idm46125986184792"/><a data-type="indexterm" data-primary="testing" data-secondary="chart testing" data-tertiary="about" id="idm46125986183544"/><a data-type="indexterm" data-primary="hooks" data-secondary="helm test command" id="idm46125986182328"/><a data-type="indexterm" data-primary="releases" data-secondary="hooking into events" data-tertiary="tests added to charts" id="ch06-test"/>ability to test charts through the use of the <em>test</em> hook and Kubernetes resources. That means tests run in a Kubernetes cluster right alongside the workloads with access to the components installed by the chart. In addition to the chart testing built into Helm, the Helm project provides an additional testing tool named Chart Testing. Since Chart Testing builds upon the features in the Helm client, we will first look at the functionality built into the Helm client.</p>








<section data-type="sect2" data-pdf-bookmark="Helm Test"><div class="sect2" id="idm46125986178760">
<h2>Helm Test</h2>

<p>Helm has a <code>helm test</code> command that executes test hooks on a running <a data-type="indexterm" data-primary="testing" data-secondary="chart testing" data-tertiary="helm test command" id="idm46125986176584"/><a data-type="indexterm" data-primary="charts" data-secondary="tests added to" data-tertiary="helm test command" id="idm46125986175336"/><a data-type="indexterm" data-primary="test command" id="idm46125986174120"/><a data-type="indexterm" data-primary="testing" data-secondary="exit codes" data-tertiary="helm test command" id="idm46125986173448"/><a data-type="indexterm" data-primary="exit codes" data-secondary="helm test command" id="idm46125986172232"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="helm test command" id="idm46125986171288"/>instance of a chart. The resources implementing those hooks can check database access, that database schemas are properly in place, for working connections between workloads, and other operational details.</p>

<p>If a test fails, Helm will exit with a nonzero exit code and provide you with the name of the Kubernetes resource that failed. The nonzero exit code is useful when paired with some automation testing systems that detect failures this way. When you have the name of the Kubernetes resource, you can look at the logs to see what failed.</p>

<p>Tests typically live in the <em>tests</em> subdirectory of the <em>templates</em> directory. Putting the tests in this directory provides a useful separation. This is a convention and not required for tests to run.</p>

<p>To illustrate a test, we will look at the <a href="https://oreil.ly/COJ7w"><em>booster</em> chart</a>. <a data-type="indexterm" data-primary="test command" data-secondary="example" id="idm46125986166184"/><a data-type="indexterm" data-primary="charts" data-secondary="tests added to" data-tertiary="example" id="idm46125986165176"/><a data-type="indexterm" data-primary="YAML" data-secondary="test-connection.yaml example file" id="idm46125986163960"/>In the <em>templates/tests</em> directory, there is a single test in the file <em>test-connection.yaml</em> that contains the following test hook:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="s">"{{</code><code class="nv"> </code><code class="s">include</code><code class="nv"> </code><code class="s">"</code><code class="l-Scalar-Plain">booster.fullname" . }}-test-connection"</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="p-Indicator">{{</code><code class="nv">- include "booster.labels" . | nindent 4</code> <code class="p-Indicator">}}</code>
  <code class="nt">annotations</code><code class="p">:</code>
    <code class="s">"helm.sh/hook"</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">test</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">containers</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">wget</code>
      <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">busybox</code>
      <code class="nt">command</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">'wget'</code><code class="p-Indicator">]</code>
      <code class="nt">args</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">'{{</code><code class="nv"> </code><code class="s">include</code><code class="nv"> </code><code class="s">"booster.fullname"</code><code class="nv"> </code><code class="s">.</code><code class="nv"> </code><code class="s">}}:{{</code><code class="nv"> </code><code class="s">.Values.service.port</code><code class="nv"> </code><code class="s">}}'</code><code class="p-Indicator">]</code>
  <code class="nt">restartPolicy</code><code class="p">:</code> <code class="l-Scalar-Plain">Never</code></pre>

<p>This test is the one created by default for Nginx when <code>helm create</code> is run.<a data-type="indexterm" data-primary="Nginx" data-secondary="helm create command" data-tertiary="test created by default" id="idm46125986158792"/><a data-type="indexterm" data-primary="create command" data-secondary="test created by default" id="idm46125986057000"/> It happens to work to test connectivity to the booster application, as well. This simple test illustrates the structure of a test.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you look at tests in some existing charts you might find the hook <a data-type="indexterm" data-primary="versions of Helm" data-secondary="test versus test-success" id="idm46125986054584"/><a data-type="indexterm" data-primary="Helm" data-secondary="versions" data-tertiary="test versus test-success" id="idm46125986053640"/><a data-type="indexterm" data-primary="test command" data-secondary="test-success versus" id="idm46125986052456"/>they use is <code>test-success</code> instead of <code>test</code>. In Helm version 2 there was a hook named <code>test-success</code> for running tests. Helm version 3 provides backward compatibility and will run this hook name as a test.</p>
</div>

<p>There are two steps to run tests. The first step is to install the chart <a data-type="indexterm" data-primary="test command" data-secondary="steps to running tests" id="idm46125986049496"/><a data-type="indexterm" data-primary="charts" data-secondary="tests added to" data-tertiary="steps to running tests" id="idm46125986048520"/><a data-type="indexterm" data-primary="testing" data-secondary="chart testing" data-tertiary="steps to running tests" id="idm46125986047304"/><a data-type="indexterm" data-primary="install command" data-secondary="testing process" id="idm46125986046088"/>so that an instance of it is running. You can use the <code>helm install</code> command to do this. The following command installs the <em>booster</em> chart and assumes you are running it from the root directory of the chart:</p>

<pre data-type="programlisting">$ helm install boost .</pre>

<p>Once the instance of the chart is running, you run the <code>helm test</code> command to execute the tests:</p>

<pre data-type="programlisting">$ helm test boost</pre>

<p>Helm will output the status of the test as it executes and then information about the test and the release when complete. For the previous test it would return:</p>

<pre data-type="programlisting">Pod boost-booster-test-connection pending
Pod boost-booster-test-connection pending
Pod boost-booster-test-connection running
Pod boost-booster-test-connection succeeded
NAME: boost
LAST DEPLOYED: Tue Jul 21 06:47:05 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE:     boost-booster-test-connection
Last Started:   Tue Jul 21 06:47:12 2020
Last Completed: Tue Jul 21 06:47:17 2020
Phase:          Succeeded
NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l
    "app.kubernetes.io/name=booster,app.kubernetes.io/instance=boost"
    -o jsonpath="{.items[0].metadata.name}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace default port-forward $POD_NAME 8080:80</pre>

<p>When charts have dependencies that have tests, those will be run, as well.<a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="tests included in dependencies" id="idm46125986039320"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="tests included in dependencies" id="idm46125986038008"/> For example, if the tests in the <em>rocket</em> chart used earlier in the chapter are run, the <em>booster</em> chart tests and the <em>rocket</em> chart tests will be run.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you need to have configuration installed as part of a test, you can put <a data-type="indexterm" data-primary="install command" data-secondary="configuration at installation" data-tertiary="testing charts and" id="idm46125986034536"/><a data-type="indexterm" data-primary="configuration" data-secondary="chart installation" data-tertiary="testing charts and" id="idm46125986033224"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="configuration at installation" data-tertiary="testing charts and" id="idm46125986032008"/>the test hook on a Kubernetes <code>Secret</code> or ConfigMap to have it installed with other test resources.</p>
</div>

<p>Testing charts is a great way to ensure the contents of a chart are able to get the workload running in Kubernetes and catch changes that may break that.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Chart Testing Tool"><div class="sect2" id="idm46125986178136">
<h2>Chart Testing Tool</h2>

<p>The Helm project provides an additional testing tool, built on the foundation<a data-type="indexterm" data-primary="test command" data-secondary="Chart Testing tool" id="idm46125986027848"/><a data-type="indexterm" data-primary="charts" data-secondary="tests added to" data-tertiary="Chart Testing tool" id="idm46125986026872"/><a data-type="indexterm" data-primary="testing" data-secondary="chart testing" data-tertiary="Chart Testing tool" id="idm46125986025656"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="Chart Testing tool" id="idm46125986024440"/><a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="linting charts" id="idm46125986023480"/><a data-type="indexterm" data-primary="Chart Testing tool" id="idm46125986022264"/> of <code>helm test</code>, that provides more advanced testing capabilities. Some of the additional features it includes are:</p>

<ul>
<li>
<p>The ability to test different—mutually exclusive—configuration options at install time for a chart.</p>
</li>
<li>
<p><em>Chart.yaml</em> schema validation that includes custom schema rules.<a data-type="indexterm" data-primary="schema validation of Chart.yaml" id="idm46125986018296"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="schema validation" id="idm46125986017624"/></p>
</li>
<li>
<p>Additional YAML linting that includes configurable rules. For example, <a data-type="indexterm" data-primary="linting charts" data-secondary="Chart Testing tool" id="idm46125986015848"/><a data-type="indexterm" data-primary="building charts" data-secondary="linting" data-tertiary="Chart Testing tool" id="idm46125986014872"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="linting" id="idm46125986013656"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="linting charts" data-tertiary="Chart Testing tool" id="idm46125986012440"/>you can make sure indentation in the YAML files is consistent.</p>
</li>
<li>
<p>When the source is stored in Git, the ability to check if the <code>version</code> property in a <em>Chart.yaml</em> file has been properly incremented.</p>
</li>
<li>
<p>The ability to work with collections of charts and only test those that have changed.</p>
</li>
</ul>

<p>The Chart Testing tool was designed to use in continuous integration system workflows, and some of the features directly target this situation.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125986007688">
<h5>History of Chart Testing</h5>
<p>When Helm was in its early days, the project maintainers started a repository<a data-type="indexterm" data-primary="testing" data-secondary="chart testing" data-tertiary="history of" id="idm46125986006152"/><a data-type="indexterm" data-primary="charts" data-secondary="tests added to" data-tertiary="history of" id="idm46125986004904"/><a data-type="indexterm" data-primary="chart repositories" data-secondary="history of" id="idm46125986003688"/><a data-type="indexterm" data-primary="test command" data-secondary="Chart Testing tool" data-tertiary="history of" id="idm46125986002744"/> with some charts to showcase what you could do with charts. Helm repositories were designed to be distributed from the start—with different organizations running their own repositories—and the Helm project provided an example of how to do this.</p>

<p>This chart repository grew to have many charts and became a form of central repository. To aid in maintaining the many charts, automation scripts were created to help automatically provide feedback to proposed pull requests to the charts.</p>

<p>The automation scripts proved to be useful to more than the Helm project. To enable the chart repositories hosted by others to have the same testing capabilities, the scripts used by the Helm project were broken out into a separate tool and rewritten with portability in mind.</p>

<p>The Chart Testing tool is now used by a variety of companies and organizations to aid in the testing of their hosted charts.</p>
</div></aside>

<p>The ability for Chart Testing to test a chart with different, mutually exclusive, configurations requires knowing those configurations. These are bundled in the <em>ci</em> directory of a chart.</p>

<p>In the <em>ci</em> directory you can create a values file for each situation to test. You need to use the glob naming pattern <em>*-values.yaml</em> when you name each file. For example, you can use file names like <em>minimal-values.yaml</em> and <em>full-values.yaml</em>.</p>

<p>Chart Testing will test each of these configurations separately. For example, when the chart is being linted, each case will be linted separately. The custom values will be passed to <code>helm lint</code> using the <code>--values</code> flag. The same idea and flag applies when the chart is being runtime tested. The values are passed to Helm using the <code>--values</code> flag beacuse this is how end users, who install the chart, provide their custom 
<span class="keep-together">configuration</span>.</p>

<p>If you want to test using various configurations but do not want to ship those configurations as part of the chart archive, you can put the <em>ci</em> directory in the <em>.helmignore</em> file. When Helm packages the chart, the <em>ci</em> directory will be ignored.</p>

<p>Chart Testing can be installed and used in various ways. For example, you can use it as a binary application on a development system or in a container within a continuous integration system. <a data-type="indexterm" data-primary="resources for learning" data-secondary="Chart Testing tool" id="idm46125985990472"/>Learn more about <a href="https://oreil.ly/sJXpR">using and setting it up for your situation on the project page</a>.<a data-type="indexterm" data-startref="ch06-test" id="idm46125985988680"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Security Considerations"><div class="sect1" id="idm46125985987848">
<h1>Security Considerations</h1>

<p>Some of the biggest and most trusted technology organizations have <a data-type="indexterm" data-primary="charts" data-secondary="security" id="ch06-secur"/><a data-type="indexterm" data-primary="security" data-secondary="chart security" id="ch06-secur2"/>had their users be attacked through software updates. Software changes and the mechanisms used to update and even install software provide a channel of attack.</p>

<p>Helm provides an opt-in means to check the provenance and integrity of <a data-type="indexterm" data-primary="chart repositories" data-secondary="provenance file" data-tertiary="provenance of charts" id="ch06-prov6"/><a data-type="indexterm" data-primary="provenance of charts" id="ch06-prov"/><a data-type="indexterm" data-primary="integrity of charts" id="idm46125985956808"/><a data-type="indexterm" data-primary="charts" data-secondary="integrity of" id="idm46125985956136"/><a data-type="indexterm" data-primary="security" data-secondary="chart security" data-tertiary="provenance feature" id="ch06-prov2"/><a data-type="indexterm" data-primary="charts" data-secondary="security" data-tertiary="provenance feature" id="ch06-prov3"/><a data-type="indexterm" data-primary="Helm" data-secondary="security" data-tertiary="provenance of packages" id="ch06-prov4"/><a data-type="indexterm" data-primary="packages" data-secondary="provenance feature of Helm" id="ch06-prov5"/>charts. <em>Provenance</em> provides a means to verify the origin, such as a company or person, of a chart while <em>integrity</em> provides a way to check that you received what you expected without alterations. This functionality enables you and those who use your charts to verify who they came from and that the contents have not changed.</p>

<p>To accomplish this Helm uses Pretty Good Privacy (PGP), hashes,<a data-type="indexterm" data-primary="security" data-secondary="Pretty Good Privacy signing" id="ch06-pgp2"/><a data-type="indexterm" data-primary="Pretty Good Privacy (PGP)" id="ch06-pgp3"/><a data-type="indexterm" data-primary="charts" data-secondary="security" data-tertiary="Pretty Good Privacy" id="ch06-pgp"/> and a provenance file that sits alongside the chart archive file. For example, if you have a chart archive named <em>mylib-1.0.0.tgz</em>, you can have a provenance file named <em>mylib-1.0.0.tgz.prov</em>. This file contains a PGP message with the contents of the <em>Chart.yaml</em> file along with the hash of the chart archive. Helm can generate these files for you. The following example is the provenance file for <em>mylib-1.0.0.tgz</em>:</p>

<pre data-type="programlisting">-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

apiVersion: v2
description: an example library chart
name: mylib
type: library
version: 0.1.0

...
files:
  mylib-0.1.0.tgz: sha256:d312aea39acf7026f39edebd315a11a52d29a9
                          6a8d68737ead110ac0c0a1163d
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEEcR8o1RDh4Ly9X2v+lDboC/ukaQkFAl8yiesACgkQlDboC/uk
aQkG2BAAlIEgGI7uu9Kr8j4ZIxDseLmgphhPM1kgnIMPriLieBxFXSJQxciN3+dx
OQpIfdsFQvW98EnJ4781Pm+leHY2iI/L08O1cQWUtzKhfPEWC65YQJPXkTKpHnC2
wXYVUVYWvhx6BJ77RiS/f+hoXiC+i1aBqqS0TAG+AqXuwARO2tY/L7cF6EHjsUwD
pPuTNpYZ/OEWqh1KEYZYVDvLm6uN6QjV4pNTFfAgnvMckfoDLQ+kOPQVqCeUWG3F
tZO3sBzUg+Ak2dDviSTOFQ7TCifc3tOOaWS1XtcooSOkUENmTeeWV56jZnhK1rT4
yaIGT16zXZIdmkZ1t5o9VccuAhQ1Us2FhipdGqpD8yDoJABVz/ee9d2zoX8anfR7
LZ7fwecgQ/THnj54RroyQlzf2aottFiL9ZV4MjUqs0CSoA9+SZ/CcJDd/rxBGI8C
yxRqo0VoNdjT8Kr9hha13krfwD8IpLH8bv4kWt3Ckh6rgphjUL19xyTHJY7w2toY
bAeZMl3Y05Ca76EA7XDdoltE57SUS1Zzd+wDRzRD0IZO8KVk+Z5/PzzvV4l9lnDJ
X63fptInbJpyk0xYKLMFquOY7Yy5mlI9de7424CScePo9Nua3GAakfi4zk3i4Auz
2eaoU/S5uXt605OydkSLLz99BAyJwmazzf/qPyYcPWMw/b+gHxw=
=pRcC
-----END PGP SIGNATURE-----</pre>

<p>A provenance file is a PGP signed message with a particular structure in the message. That hash in the message is used by Helm to validate integrity, and the PGP signature is used to validate who it came from.</p>

<p>There are two steps to using provenance files. First, you need to generate them. In order to do that you need to have a PGP key pair.</p>

<p>When creating a package using the <code>helm package</code> command, you can tell Helm to sign the package:<a data-type="indexterm" data-primary="package command" data-secondary="Pretty Good Privacy signature" id="idm46125985938168"/><a data-type="indexterm" data-primary="packages" data-secondary="packaging a chart" data-tertiary="Pretty Good Privacy signature" id="idm46125985937128"/><a data-type="indexterm" data-primary="charts" data-secondary="packaging" data-tertiary="Pretty Good Privacy signature" id="idm46125985935896"/></p>

<pre data-type="programlisting">$ helm package --sign --key 'bugs@acme.example.com' \
  --keyring path/to/keyring mychart</pre>

<p>The additional flags will tell Helm to create the provenance file. The <code>--sign</code> flag opts-in to signing, the <code>--key</code> flag specifies the name of the private key to use, and the 
<span class="keep-together"><code>--keyring</code></span> flag specifies the location of the keyring to use that contains the private key to use for signing. When Helm creates the archive of the chart, it will also create the <em>.prov</em> file alongside it.</p>

<p>The provenance file should then be uploaded alongside the chart archive and made available for download from a chart repository.</p>

<p>Verifying happens in reverse and is built into commands such as <code>helm install</code>, <code>helm upgrade</code>, and <code>helm pull</code> along with being available in the <code>helm verify</code> command.<a data-type="indexterm" data-primary="verify command" id="idm46125985927928"/><a data-type="indexterm" data-primary="security" data-secondary="Pretty Good Privacy signing" data-tertiary="helm verify command" id="idm46125985927192"/><a data-type="indexterm" data-primary="Pretty Good Privacy (PGP)" data-secondary="helm verify command" id="idm46125985925912"/><a data-type="indexterm" data-primary="charts" data-secondary="security" data-tertiary="helm verify command" id="idm46125985924952"/></p>

<p>Helm can handle the situation where you have both the archive and provenance file locally available and when you have the chart in a remote repository.</p>

<p>To illustrate the situation of having both files locally, we can use the <code>helm verify</code> command:</p>

<pre data-type="programlisting">$ helm verify --keyring path/to/keyring mychart-0.1.0.tgz</pre>

<p>The <code>verify</code> command will tell Helm to check the hash and signature. The <code>--keyring</code> flag tells Helm where a PGP keyring exists with the public key that matches the private key the chart was signed with. This can be either a keyring or a non-ASCII-Armored version of the public key. Helm will look for the <em>mychart-0.1.0.tgz.prov</em> file and use that to perform the check.</p>

<p>Running the <code>verify</code> command on the <em>mylib</em> chart would look like:</p>

<pre data-type="programlisting">$ helm verify mylib-0.1.0.tgz --keyring public.key</pre>

<p>This would output:</p>

<pre data-type="programlisting">Signed by: Matthew Farina
Using Key With Fingerprint: 672C657BE06B4B30969C4A57461449C25E36B98E
Chart Hash Verified: sha256:d312aea39acf7026f39edebd315a11a52d29a96a8d68737ead11
                            0ac0c0a1163d</pre>

<p>If you have a chart in a Helm repository, Helm will download the provenance file<a data-type="indexterm" data-primary="chart repositories" data-secondary="provenance file" id="idm46125985915720"/><a data-type="indexterm" data-primary="install command" data-secondary="provenance file" id="idm46125985914744"/> when it downloads the chart. For example:</p>

<pre data-type="programlisting">$ helm install --verify --keyring public.key myrepo/mychart</pre>

<p>When Helm fetches the chart archive, it will also download the provenance file, verify the signature, and verify the hash.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The public key should be shared through a different channel<a data-type="indexterm" data-primary="Pretty Good Privacy (PGP)" data-secondary="public key sharing" id="idm46125985911208"/><a data-type="indexterm" data-primary="security" data-secondary="Pretty Good Privacy signing" data-tertiary="public key sharing" id="idm46125985910184"/><a data-type="indexterm" data-primary="public key for Pretty Good Privacy" id="idm46125985908952"/> from the chart and provenance file.</p>
</div>

<p>If there is a problem during the verification process, Helm will provide an error and exit with a nonzero exit code.<a data-type="indexterm" data-primary="exit codes" data-secondary="chart verification" id="idm46125985907496"/><a data-type="indexterm" data-primary="testing" data-secondary="exit codes" data-tertiary="chart verification" id="idm46125985906520"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125985905176">
<h5>GNU Privacy Guard</h5>
<p>Starting in GNU Privacy Guard (GPG) 2.1, keys were stored in a new <a data-type="indexterm" data-primary="security" data-secondary="GNU Privacy Guard" id="idm46125985903544"/><a data-type="indexterm" data-primary="GNU Privacy Guard (GPG)" id="idm46125985902488"/><a data-type="indexterm" data-primary="charts" data-secondary="security" data-tertiary="GNU Privacy Guard" id="idm46125985901816"/><a data-type="indexterm" data-primary="Pretty Good Privacy (PGP)" data-secondary="public key sharing" data-tertiary="GNU Privacy Guard" id="idm46125985900600"/><a data-type="indexterm" data-primary="security" data-secondary="Pretty Good Privacy signing" data-tertiary="public key and GNU Privacy Guard" id="idm46125985899320"/><a data-type="indexterm" data-primary="public key for Pretty Good Privacy" data-secondary="GNU Privacy Guard" id="idm46125985898072"/>keybox format. This new format is incompatible with PGP specifications and formats. That means there are some extra steps to working with keys if you use GPG. The following commands provide a reference you can use when working with GPG.</p>

<p>You can export your secret keys from GPG into a PGP format with:</p>

<pre data-type="programlisting">gpg --export-secret-keys &gt; secring.gpg</pre>

<p>You can export public keys from GPG into a PGP format with:</p>

<pre data-type="programlisting">gpg --export &gt; pubring.gpg</pre>

<p>You can convert a public key in ASCII-Armor format to binary format with:<a data-type="indexterm" data-primary="ASCII-Armor public key format" id="idm46125985893928"/><a data-type="indexterm" data-primary="public key for Pretty Good Privacy" data-secondary="ASCII-Armor public key format" id="idm46125985893160"/></p>

<pre data-type="programlisting">gpg --dearmor &lt; pgp_key.asc &gt; public.key</pre>

<p><em>pgp_key.asc</em> is the name of the ASCII-Armored key file and <em>public.key</em> is the name of the same key in binary format. This <em>public.key</em> file can be passed to Helm as a keyring for verification.</p>

<p>If you use a password or a hardware security device with GPG, you may not be able to export your private key. In that case, there is the <a href="https://oreil.ly/pEJh3">Helm GPG plugin</a>. It provides commands and a means to directly work with provenance files through GPG. Plugins are covered in more detail in <a data-type="xref" href="ch08.xhtml#helm_plugins_and_starters">Chapter 8</a>.</p>
</div></aside>

<p>Verifying that a chart came from who you expected and that the content hasn’t changed is a useful step in securing your software supply chain.<a data-type="indexterm" data-startref="ch06-secur" id="idm46125985886728"/><a data-type="indexterm" data-startref="ch06-secur2" id="idm46125985886024"/><a data-type="indexterm" data-startref="ch06-pgp" id="idm46125985885352"/><a data-type="indexterm" data-startref="ch06-pgp2" id="idm46125985884680"/><a data-type="indexterm" data-startref="ch06-pgp3" id="idm46125985884008"/><a data-type="indexterm" data-startref="ch06-prov" id="idm46125985883336"/><a data-type="indexterm" data-startref="ch06-prov2" id="idm46125985882664"/><a data-type="indexterm" data-startref="ch06-prov3" id="idm46125985881992"/><a data-type="indexterm" data-startref="ch06-prov4" id="idm46125985881320"/><a data-type="indexterm" data-startref="ch06-prov5" id="idm46125985880648"/><a data-type="indexterm" data-startref="ch06-prov6" id="idm46125985879976"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Custom Resource Definitions"><div class="sect1" id="idm46125985986936">
<h1>Custom Resource Definitions</h1>

<p>Kubernetes custom resource definitions (CRDs) provide a means<a data-type="indexterm" data-primary="custom resource definitions (CRDs)" id="ch06-crd"/><a data-type="indexterm" data-primary="resources" data-secondary="custom resource definitions" id="ch06-crd2"/> to extend the Kubernetes API, and Helm provides methods to install them as part of the chart.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125985875592">
<h5>Custom Resource Definitions, the Kubernetes API, and Some Gotchas</h5>
<p>CRDs provide a method to extend the Kubernetes API for all users of a cluster.<a data-type="indexterm" data-primary="custom resource definitions (CRDs)" data-secondary="Kubernetes API and" id="idm46125985874072"/><a data-type="indexterm" data-primary="resources" data-secondary="custom resource definitions" data-tertiary="Kubernetes API and" id="idm46125985873080"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="API server" data-tertiary="custom resource definitions and" id="idm46125985871848"/> They add new resource types, known as custom resources, that can be uploaded to a cluster alongside the resource types that ship with Kubernetes. CRDs provide a schema and can describe multiple versions of the same resource. They are a shared global resource.</p>

<p>CRDs in a cluster can be updated to change an API. This can be to change or update the schema for an existing version of an API or to add new versions to the API. The Kubernetes community recommends that the API version be incremented anytime there is a breaking change to an API, but backward compatible changes are acceptable. There is no enforcement of this recommendation within Kubernetes. For example, adding an optional field to an API is backward compatible, but a new mandatory field is not. Changes to CRDs affect all users of the cluster.</p>

<p>When a CRD is deleted from a cluster, all of the custom resources based on it are deleted as well. This applies to all users of the cluster because CRDs are cluster-wide resources. In multitenant clusters, when one tenant deletes a CRD the custom resources described by that CRD for all tenants are deleted.</p>

<p>CRDs work this way because they were designed to be cluster-level extensions. In a retrospective on CRDs, Brendan Burns, one of Kubernetes’ founders, described their three goals as:</p>
<ol>
<li>
<p>An easy method to dynamically add new API types to Kubernetes.</p>
</li>
<li>
<p>To enable API extensibility without significant additional load on operators of Kubernetes clusters.</p>
</li>
<li>
<p>Enable an ecosystem of value add extensions to end-user clusters.</p>
</li>

</ol>

<p>When Kubernetes API extensions were being developed, another method to extend the API was developed that required a lot more work from cluster operators and those developing extensions. CRDs simplified the experience.</p>

<p>CRDs are conceptually similar to kernel modules and extensions in operating 
<span class="keep-together">systems</span>.</p>
</div></aside>

<p>There are two Helm-based methods to managing the CRDs used by a chart. Choosing between the methods to use often depends on the requirements and environment configurations of those who need to install your charts.</p>

<p>First, the <em>crds</em> directory is a special directory you can add to a chart to hold your CRDs.<a data-type="indexterm" data-primary="custom resource definitions (CRDs)" data-secondary="crds directory" id="idm46125985861128"/><a data-type="indexterm" data-primary="resources" data-secondary="custom resource definitions" data-tertiary="crds directory" id="idm46125985860184"/> Helm will install CRDs prior to installing other resources. This ensures that CRDs are available for any custom resources or controllers that may leverage them in the chart.</p>

<p>CRDs in the <em>crds</em> directory are different from other resources installed by Helm. These files are not templated. This is useful for the CRD management workflows we will cover in a moment. Helm will not upgrade or delete CRDs like it does other resources. Upgrading CRDs changes the API surface for all instances of the custom resources in the cluster, and deleting CRDs removes all of the custom resources for all users. When it comes to handling these cluster-wide changes you will need to use a companion tool, like <code>kubectl</code>, the command-line tool for Kubernetes.</p>

<p>Because CRDs change the Kubernetes API, whoever is installing your chart may not have permission to install, upgrade, or delete them. This is the case if you are bundling an application for distribution to other companies or the general public. Some cluster administrators restrict access to these functions as part of their access controls for security.</p>

<p>The CRDs in the <em>crds</em> directory can be extracted from a chart and used directly with tools like <code>kubectl</code>. This enables the CRDs to be passed to someone with permission to install them, if the person installing the chart doesn’t have permission. The extracted CRDs can also be used to upgrade the CRDs within a cluster using other tools.</p>

<p>A second, Helm-based, way to manage CRDs <a data-type="indexterm" data-primary="custom resource definitions (CRDs)" data-secondary="second chart for" id="idm46125985853944"/><a data-type="indexterm" data-primary="resources" data-secondary="custom resource definitions" data-tertiary="second chart for" id="idm46125985852904"/>while providing an ordering that installs CRDs before using them through custom resources is to use a second chart that holds the CRDs. This method provides more nuanced control through Helm.</p>

<p>Using a second chart will let you:</p>
<ol>
<li>
<p>Use Helm templates and the normal <em>templates</em> directory for CRDs.</p>
</li>
<li>
<p>Helm will manage the life cycle of the CRDs. That includes uninstalling and upgrades. If you want to keep the CRD installed after the chart is uninstalled, you can set the annotation <code>"helm.sh/resource-policy": keep</code> to tell Helm to skip uninstalling the resource.</p>
</li>
<li>
<p>If you have issues with an application and use the uninstall and reinstall method to try to fix issues, the CRDs in the separate chart will not be deleted.</p>
</li>

</ol>

<p>This second chart can be installed with either a loose coupling, where the directions tell people to install it first, or a tight coupling, where it is set as a dependency. If the chart holding the CRDs is set as a dependency the use case should be that it is only installed once as it is setting cluster-wide resources.</p>

<p>When Helm is managing the CRDs, special care needs to be given for handling <a data-type="indexterm" data-primary="upgrades" data-secondary="custom resource definitions and" id="idm46125985845192"/><a data-type="indexterm" data-primary="charts" data-secondary="versions" data-tertiary="custom resource definitions and" id="idm46125985844152"/>upgrade and delete cases. For example, if two versions of the CRD installing chart are installed, as you need to ensure an older version doesn’t overwrite a newer version and that a newer version doesn’t break the functionality for someone else in the cluster using the older version. This can happen if two people install different versions of the chart that installs CRDs. In multitenant clusters different users of the cluster may not know about each other, and it’s important to ensure that one user of the cluster does not break the workloads of another user of the cluster.</p>

<p>When installing and working with CRDs, the Helm developers recommend taking special care in all of the life cycle steps to make sure that users of charts don’t run into situations that accidentally break production workloads.<a data-type="indexterm" data-startref="ch06-crd" id="idm46125985841560"/><a data-type="indexterm" data-startref="ch06-crd2" id="idm46125985840856"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46125985879176">
<h1>Conclusion</h1>

<p>Helm charts are more than a collection of templates. They handle dependencies, can include schemas, provide an event hook mechanism, can include tests, and have features for security. These features are part of what make Helm a robust and reliable solution to the package management problem.</p>
</div></section>







</div></section></div></body></html>