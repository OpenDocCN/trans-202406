- en: Chapter 14\. Validating and Reformatting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 14.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter, [Chapter 13](ch13.xhtml#nch-xfer), focused on methods
    for moving data into and out of MySQL, by reading lines and breaking them into
    separate columns. In this chapter, we’ll focus on the content rather than structure
    issues. For example, if you don’t know whether the values contained in a file
    or recieved via web form are legal, preprocess them to check or reformat them:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s often a good idea to validate data values to make sure they’re legal for
    the data types into which you store them. For example, you can make sure that
    values intended for `INT`, `DATE`, and `ENUM` columns are integers, dates in ISO
    format (*`YYYY-MM-DD`* ), and legal enumeration values, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data values may need reformatting. You might store credit card values as a string
    of digits but permit users of a web application to separate blocks of digits by
    spaces or dashes. These values must be rewritten before storing them. Rewriting
    dates from one format to another is especially common; for example, if a program
    writes dates in *`MM-DD-YY`* format to ISO format for import into MySQL. If a
    program understands only date and time formats and not a combined date-and-time
    format (such as MySQL uses for the `DATETIME` and `TIMESTAMP` data types), you
    must split date-and-time values into separate date and time values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter deals with formatting and validation issues primarily within the
    context of checking entire files, but many of the techniques discussed here can
    be applied to one-time validations as well. Consider a web-based application that
    presents a form for a user to fill in and then processes its contents to create
    a new row in the database. Web APIs generally make form contents available as
    a set of already parsed discrete values, so the application may not need to deal
    with record and column delimiters. On the other hand, validation issues remain
    paramount. You really have no idea what kind of values a user is sending your
    script, so it’s important to check them.
  prefs: []
  type: TYPE_NORMAL
- en: First three recipes introduce you data validation capabilities, available in
    MySQL. Starting from [Recipe 14.4](#nch-format-format-validate-input-loop) we
    focus on validating and pre-processing data on the application side. We introduce
    technicques that allow to process large bulks of data effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Source code for program fragments and scripts discussed in this chapter is located
    in the *transfer* directory of the `recipes` distribution, with the exception
    that some utility functions are contained in library files located in the *lib*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Using the SQL Mode to Reject Bad Input Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL accepts data values that are invalid, out of range, or otherwise unsuitable
    for the data types of the columns into which you insert them. You want the server
    to be more restrictive and not accept bad data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check the SQL mode and make sure it is not empty. There are several modes that
    you can use to control how strict the server is on data values. Some modes apply
    generally to all input values. Others apply to specific data types such as dates.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the SQL mode is not setor is set to an empty value, MySQL allows all input
    values for your table columns, even if the input data types do not match the column’s
    data type. Consider the following table, which has integer, string, and date columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inserting a row with unsuitable data values into the table causes warnings
    (which you can see with `SHOW` `WARNINGS`), but the server loads the values into
    the table after converting them to some value that fits the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to prevent these converstions to happen is to check the input data
    on the client side to make sure that it’s legal. This is a reasonable strategy
    in certain circumstances (see the sidebar in [Recipe 14.0](#nch-format-format-intro)),
    but there is an alternative: let the server check data values on the server side
    and reject them with an error if they’re invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, set the `sql_mode` system variable to enable server restrictions
    on input data acceptance. With the proper restrictions in place, data values that
    would otherwise result in conversions and warnings result in errors instead. Try
    the `INSERT` statement from the previous example again after enabling <q>strict</q>
    SQL mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here the statement doesn’t even progress to the second and third data values
    because the first is invalid for an integer column and the server raises an error.
  prefs: []
  type: TYPE_NORMAL
- en: Without input restrictions enabled, the server checks that the month part of
    date values is in the range from 1 to 12 and that the day value is legal for the
    given month. This means that `'2005-02-31'` generates a warning by default (with
    conversion to zero date `'0000-00-00'`). In strict mode, an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL still permits dates such as `''1999-11-00''` or `''1999-00-00''` that
    have zero parts, or the <q>zero</q> date (`''0000-00-00''`). To restrict these
    kinds of date values, enable the `NO_ZERO_IN_DATE` and `NO_ZERO_DATE` SQL modes
    to cause warnings, or errors in strict mode. For example, to prohibit dates with
    zero parts or <q>zero</q> dates, set the SQL mode like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A simpler way to enable these restrictions, and a few more besides, is to enable
    `TRADITIONAL` SQL mode. `TRADITIONAL` mode is actually a constellation of modes,
    as you can see by setting and displaying the `sql_mode` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about the various SQL modes in the [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples shown set the session value of the `sql_mode` system variable,
    so they change the SQL mode only for your current session. To set the mode globally
    for all clients, start the server with a `--sql_mode=`*`mode_value`* option. Alternatively,
    if you have the `SYSTEM_VARIABLES_ADMIN` or `SUPER` privilege, you can set the
    global mode at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before MySQL 5.7, the SQL mode was forgiving by default. Newer versions are
    much more restrictive, and SQL mode is set to `ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES,
    NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER,
    NO_ENGINE_SUBSTITUTION`. Therefore, if you want to have a restrictive server,
    you don’t need to do anything extra, unless you intentionally relaxed the SQL
    mode earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 Using CHECK Constraints to Reject Invalid Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to validate data so it follows business logic of your application and
    rejects values if they do not satisfy requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `CHECK` constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a value matches the MySQL data type format, it does not mean it matches logic
    of the application. For example, if you want to store only even numbers you cannot
    simply use data type integer, because both odd and even numbers are valid integers.
  prefs: []
  type: TYPE_NORMAL
- en: '`CHECK` constraints, introduced in version 8.0, allow to setup a custom condition
    on the table column and rejects the statement if value does not satisfy it. Thus,
    to create a table that will store only even values, you would need to use `CHECK`
    to check if the number can be divided by two without a reminder.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we can successfully insert even numbers into this table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Odd values would be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can also create multiple `CHECK` constraints for a single column. For example,
    to accept only even values that are less than 100 create two constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, MySQL will check the first condition and if it is satisfied it
    will process the second one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you specify a `CHECK` constraint when defining a column it will validate
    only this column. If you want to check two or more columns in the single constraint
    you will need to specify it separately.
  prefs: []
  type: TYPE_NORMAL
- en: A common validation task is to check if the departure date is later than the
    arrival date. We can add such a check to the `patients` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, it will not allow you to insert records where departure date is earlier
    than the arrival date.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 14.3 Using Triggers to Reject Input Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to validate if data to be inserted into the table follows business
    logic, but your logic is more complicated than `CHECK` constraints can handle.
    You may also need to rewrite the data instead of rejecting it. Or you are using
    an earlier version of MySQL where `CHECK` constraints are not available.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `BEFORE` triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CHECK` constraints have certain limitations. They do not allow you to use
    stored or user-defined functions, subqueries, or user-defined variables. They
    also do not allow you to modify inserted data. If you want to format inserted
    value to satisfy your business standards you may want to explore another solution,
    such as validation on the application side or `BEFORE` triggers on MySQL side.'
  prefs: []
  type: TYPE_NORMAL
- en: To perform more complicated validation on MySQL side create a trigger and raise
    a SQL exception in it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at an example. Suppose that a groceries table stores details
    about the products in a supermarket. In some countries, it is forbidden to sell
    alcohol in supermarkets between certain hours. For example, in Turkey, you wouldn’t
    be able to buy alcohol in a supermarket between 10 pm and 6 am. If you are working
    with such limitations, you may want to limit times when users can place orders.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that a `groceries` table stores details about groceries in the supermarket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Columns `forbidden_after` and `forbidden_before` define time range when it is
    not allowed to sell particular item.
  prefs: []
  type: TYPE_NORMAL
- en: Another table, named `groceries_order_items`, contains information about purchases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To disallow the purchase of items during certain times, you could create a trigger
    that checks the current time and if there are any restrictions to a selected product.
    If restrictions exist the purchase will be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-format-format-triggers_declare_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare variables to store time range when the purchase is forbidden, the name
    of the product, and an error message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-format-format-triggers_select_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Select restricted time range and name of the product into variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-format-format-triggers_check_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if current time fails into forbidden range for the selected product.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-format-format-triggers_message_co)'
  prefs: []
  type: TYPE_NORMAL
- en: If the time fails into forbidden range craft a message, explaining restrictions
    for the product.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_nch-format-format-triggers_signal_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Raise an error and reject the insert.
  prefs: []
  type: TYPE_NORMAL
- en: As a result you can purchase cheese or water at 3 am, but you cannot purchase
    beer or wine at that time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The purchase limitation is relaxed during day time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about using triggers to reject or modify invalid
    values, see [Recipe 11.11](ch11.xhtml#nch-routines-preprocess-reject).
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 Writing an Input-Processing Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make sure that the data values in a file are legal.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write an input process loop that will check them, possibly rewriting them into
    a more suitable format.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the validation recipes shown in this chapter are typical of those that
    you perform within the context of a program that reads a file and checks individual
    column values. The general framework for such a file-processing utility looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `for()` loop reads each input line. Within the loop, each line is broken
    into fields. The inner `for()` loop iterates through the fields, enabling each
    to be processed in sequence. If you don’t apply a given test uniformly to all
    the fields, replace the `for()` loop with separate column-specific tests.
  prefs: []
  type: TYPE_NORMAL
- en: This loop assumes tab-delimited, linefeed-terminated input, an assumption shared
    by most of the utilities discussed throughout this chapter. To use these utilities
    with datafiles in other formats, you may be able to convert such files to tab-delimited
    format using the *cvt_file.pl* script, available in the recipes distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5 Putting Common Tests in Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to do repeated validation operations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Package validation operations as library routines.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s not unusual for certain validation operations to occur repeatedly, in
    which case you’ll probably find it useful to construct a library of functions.
    By packaging validation operations as library routines, it is easier to write
    utilities based on them, and the utilities make it easier to perform command-line
    operations on entire files so that you can avoid editing them yourself. This also
    gives the operation a name that’s likely to make the meaning of it clearer than
    the comparison code itself. The following test in Python language performs a pattern
    match to check that `val` consists entirely of digits (optionally preceded by
    a plus sign), and then makes sure the value is greater than zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the test looks for strings that represent positive integers.
    To make the test easier to use and its intent clearer, package it as a function
    that is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now put the function definition into a library file so that multiple scripts
    can use it easily. The *cookbook_utils.py* module file in the *lib* directory
    of the `recipes` distribution is an example of a library file that contains a
    number of validation functions. Take a look through it to see which functions
    may be useful in your own programs (or as a model for writing your own library
    files). To gain access to this module from within a script, include a `use` statement
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You must of course install the module file in a directory where Python will
    find it (see [Recipe 4.3](ch04.xhtml#nch-api-api-library)).
  prefs: []
  type: TYPE_NORMAL
- en: A significant benefit of putting a collection of utility routines into a library
    file is that you can use it for all kinds of programs. It’s rare for a data manipulation
    problem to be completely unique. If you can pick and choose at least a few validation
    routines from a library, it reduces the amount of code you must write, even for
    highly specialized programs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To avoid writing your own library routines, look around to see if someone else
    has already written suitable routines that you can use. For example, if you check
    the Perl CPAN (*cpan.perl.org*), you’ll find a Data::Validate module hierarchy.
    The modules there provide library routines that standardize a number of common
    validation tasks. Data::Validate::MySQL deals specifically with MySQL data types.
  prefs: []
  type: TYPE_NORMAL
- en: 14.6 Using Pattern Matching to Validate Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to compare a value to a set of values that is difficult to specify
    without writing a really ugly expression.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching is a powerful validation tool that enables you to test entire
    classes of values with a single expression. You can also use pattern tests to
    break matched values into subparts for further individual testing or in substitution
    operations to rewrite matched values. For example, you might break a matched date
    into pieces to verify that the month is in the range from 1 to 12, and the day
    is within the number of days in the month. You might use a substitution to reorder
    *`MM-DD-YYYY`* or *`DD-MM-YYYY`* values into *`YYYY-MM-DD`* format.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections describe how to use patterns to test several types of
    values, but first let’s review some general pattern-matching principles. The following
    discussion focuses on Python’s regular-expression capabilities. Pattern matching
    in Ruby, PHP, Go, and Perl is similar, although you should consult the relevant
    documentation for any differences. For Java, use the `java.util.regex` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, regular expressions are part of the module `re`. The pattern constructor
    is `re.compile(`*`pat`*`)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To find if a value matches a pattern use method `match`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can construct regular expression in the method `match`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Put a flag `re.I` as the second argument to the regular expression constructor
    to make the pattern match case insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To look for a nonmatch, replace the `=` operator with the combination of the
    `=` and `not` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a substitution in `val` based on a pattern match, use `re.sub(/`*`pat`*`,`
    *`replacement`*`, val)`*`replacement`*`/`. If *`pat`* occurs within `val`, it’s
    replaced by *`replacement`*. For a case-insensitive match, put an `re.I` flag.
    To conduct a substitution that replaces only few instances of *`pat`* rather than
    all of them, add an option `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The [Table 14-1](#nch-format-format-pattern-special) shows some of the special
    pattern elements available in Python regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-1\. Pattern elements in Python regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | What the pattern matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Beginning of string |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of string |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any character except a newline |'
  prefs: []
  type: TYPE_TB
- en: '| `\s`, `\S` | Whitespace or nonwhitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `\d`, `\D` | Digit or nondigit character |'
  prefs: []
  type: TYPE_TB
- en: '| `\w`, `\W` | Word (alphanumeric or underscore) or nonword character |'
  prefs: []
  type: TYPE_TB
- en: '| `[...]` | Any character listed between the square brackets |'
  prefs: []
  type: TYPE_TB
- en: '| `[^...]` | Any character not listed between the square brackets |'
  prefs: []
  type: TYPE_TB
- en: '| *`p1`*`&#124;`*`p2`*`&#124;`*`p3`* | Alternation; matches any of the patterns
    *`p1`*, *`p2`*, or *`p3`* |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more instances of preceding element |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more instances of preceding element |'
  prefs: []
  type: TYPE_TB
- en: '| `{`*`n`*`}` | *`n`* instances of preceding element |'
  prefs: []
  type: TYPE_TB
- en: '| `{`*`m`*`,`*`n`*`}` | *`m`* through *`n`* instances of preceding element
    |'
  prefs: []
  type: TYPE_TB
- en: Many of these pattern elements are the same as those available for MySQL’s `REGEXP`
    regular-expression operator (see [Recipe 7.11](ch07.xhtml#nch-strings-strings-pat-regexp)).
  prefs: []
  type: TYPE_NORMAL
- en: To match a literal instance of a character that is special within patterns,
    such as `*`, `^`, or `$`, precede it with a backslash. Similarly, to include a
    character within a character class construction that is special in character classes
    (`[`, `]`, or `-`), precede it with a backslash. To include a literal `^` in a
    character class, list it somewhere other than as the first character between the
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the validation patterns shown in the following recipes are of the form
    `^`*`pat`*`$`. Beginning and ending a pattern with `^` and `$` has the effect
    of requiring *`pat`* to match the entire string that you test. This is common
    in data validation contexts because it’s generally desirable to know that a pattern
    matches an entire input value, not only part of it. (To be sure that a value represents
    an integer, for example, it does no good to know only that it contains an integer
    somewhere.) This is not a hard-and-fast rule, however, and sometimes it’s useful
    to perform a more relaxed test by omitting the `^` and `$` characters as appropriate.
    For example, if you want to strip leading and trailing whitespace from a value,
    use one pattern anchored only to the beginning of the string, and another anchored
    only to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s such a common operation, in fact, that it’s a good candidate for being
    written as a utility function. The *cookbook_utils.py* file contains a function
    `trim_whitespace()` that performs both substitutions and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To remember subsections of a string matched by a pattern, use parentheses around
    the relevant pattern parts. After a successful match, you can refer to the matched
    substrings using the variables `\1`, `\2`, and so forth inside the regular expression
    or using match number as an argument of the method `group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to indicate that an element within a pattern is optional, follow
    it with a `?` character. To match values consisting of a sequence of digits, optionally
    beginning with a minus sign, and optionally ending with a period, use this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Use parentheses to group alternations within a pattern. The following pattern
    matches time values in *`hh:mm`* format, optionally followed by `AM` or `PM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of parentheses in that pattern also has the side effect of remembering
    the optional part in `\1`. To suppress that side effect, use `(?:`*`pat`* `)`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You now have sufficient background in Python pattern matching to enable construction
    of useful validation tests for several types of data values. The following recipes
    provide patterns that can be used to test for broad content types, numbers, temporal
    values, and email addresses or URLs.
  prefs: []
  type: TYPE_NORMAL
- en: The *transfer* directory of the `recipes` distribution contains a *test_pat.py*
    script that reads input values, matches them against several patterns, and reports
    which patterns each value matches. The script is easily extensible, so you can
    use it as a test harness to try your own patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 14.7 Using Patterns to Match Broad Content Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to classify values into categories.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a pattern that uses a similarly broad categories.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check whether values are empty or nonempty, or consist only of certain types
    of characters, the patterns listed in the [Table 14-2](#nch-format-format-pat-broad-chars)
    may suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-2\. Commonly used categories of characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Type of value the pattern matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^$` | Empty value |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Nonempty value |'
  prefs: []
  type: TYPE_TB
- en: '| `^\s*$` | Whitespace, possibly empty |'
  prefs: []
  type: TYPE_TB
- en: '| `^\s+$` | Nonempty whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | Nonempty, and not whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d+$` | Digits only, nonempty |'
  prefs: []
  type: TYPE_TB
- en: '| `^[a-zA-Z]+$` | Alphabetic characters only (case insensitive), nonempty |'
  prefs: []
  type: TYPE_TB
- en: '| `^\w+$` | Alphanumeric or underscore characters only, nonempty |'
  prefs: []
  type: TYPE_TB
- en: 14.8 Using Patterns to Match Numeric Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make sure a string looks like a number.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a pattern that matches the type of number you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Patterns can be used to classify values into several types of numbers, as shown
    in the [Table 14-3](#nch-format-format-pat-numeric-int)
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-3\. Patterns that match numbers
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Type of value the pattern matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d+$` | Unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `^-?\d+$` | Negative or unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `^[-+]?\d+$` | Signed or unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `^[-+]?(\d+(\.\d*)?&#124;\.\d+)$` | Floating-point number |'
  prefs: []
  type: TYPE_TB
- en: 'The pattern `^\d+$` matches unsigned integers by requiring a nonempty value
    that consists only of digits from the beginning to the end of the value. If you
    care only that a value begins with an integer, you can match an initial numeric
    part and extract it. To do this, match only the initial part of the string (omit
    the `$` that requires the pattern to match to the end of the string) and place
    parentheses around the `\d+` part. Then refer to the matched number as `group(1)`
    after a successful match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Some kinds of numeric values have a special format or other unusual constraints.
    Here are a few examples and how to deal with them:'
  prefs: []
  type: TYPE_NORMAL
- en: ZIP codes
  prefs: []
  type: TYPE_NORMAL
- en: 'ZIP and ZIP+4 codes are postal codes used for mail delivery in the United States.
    They have values like `12345` or `12345-6789` (that is, five digits, possibly
    followed by a dash and four more digits). To match one form or the other, or both
    forms, use the patterns shown in the [Table 14-4](#nch-format-format-pat-numeric-zips):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-4\. Patterns that match ZIP codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Type of value the pattern matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d{5}$` | ZIP code, five digits only |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d{5}-\d{4}$` | ZIP+4 code |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d{5}(-\d{4})?$` | ZIP or ZIP+4 code |'
  prefs: []
  type: TYPE_TB
- en: Credit card numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'Credit card numbers typically consist of digits, but it’s common for values
    to be written with spaces, dashes, or other characters between groups of digits.
    For example, the following numbers are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To match such values, use this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '(Python permits the `\d` digit specifier within character classes.) However,
    that pattern doesn’t identify values of the wrong length, and it may be useful
    to remove extraneous characters before storing values in MySQL. To require credit
    card values to contain 16 digits, use a substitution that removes all nondigits,
    then check the length of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 14.9 Using Patterns to Match Dates or Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make sure a string looks like a date or time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a pattern that matches the type of temporal value you expect. Be sure to
    consider issues such as how strict to be about delimiters between subparts and
    the lengths of the subparts.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dates are a validation headache because they come in so many formats. Pattern
    tests are extremely useful for weeding out illegal values, but often insufficient
    for full verification: a date might have a number where you expect a month, but
    the date isn’t valid if the number is 13\. This section introduces some patterns
    that match a few common date formats. [Recipe 14.14](#nch-format-format-date-part)
    revisits this topic in more detail and discusses combining pattern tests with
    content verification.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To require values to be dates in ISO (*`YYYY-MM-DD`*) format, use this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern requires the `-` character as the delimiter between date parts.
    To permit either `-` or `/` as the delimiter, use a character class between the
    numeric parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This pattern will match dates in format *`YYYY-MM-DD`*, *`YYYY/MM/DD`*, *`YYYY/MM-DD`*,
    and *`YYYY-MM/DD`*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To permit any nondigit delimiter (which corresponds to how MySQL operates when
    it interprets strings as dates), use this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To permit leading zeros in values like `03` to be missing, just look for three
    nonempty digit sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, that pattern is so general that it also matches other values such
    as US Social Security numbers (which have the format 012-34-5678). To constrain
    the subpart lengths by requiring two to four digits in the year part and one or
    two digits in the month and day parts, use this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For dates in other formats such as *`MM-DD-YY`* or *`DD-MM-YY`*, similar patterns
    apply, but the subparts are arranged in a different order. This pattern matches
    both of those formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the values of individual date parts, use parentheses in the pattern
    and extract the substrings after a successful match. If you expect dates to be
    in ISO format, for example, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The library file *lib/cookbook_utils.py* in the `recipes` distribution contains
    several of these pattern tests, packaged as function calls. If the date doesn’t
    match the pattern, they return `None`. Otherwise, they return a reference to an
    array containing the broken-out values for the year, month, and day. This can
    be useful for performing further checking on the components of the date. For example,
    `is_iso_date()` looks for dates that match ISO format. It’s defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The function could be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You’ll often find additional processing necessary with dates because date-matching
    patterns help to weed out values that are syntactically malformed, but don’t assess
    whether the individual components contain legal values. To do that, some range
    checking is necessary. [Recipe 14.14](#nch-format-format-date-part) covers that
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re willing to skip subpart testing and just want to rewrite the pieces,
    use a substitution. For example, to rewrite values assumed to be in *`MM-DD-YY`*
    format into *`YY-MM-DD`* format, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Time values are somewhat more orderly than dates, usually being written with
    hours first and seconds last, with two digits per part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To be more lenient, permit the hours part to have a single digit, or the seconds
    part to be missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Mark parts of the time with parentheses if you want to range-check the individual
    parts, or perhaps to reformat the value to include a seconds part of `00` if it
    happens to be missing. However, this requires some care with the parentheses and
    the `?` characters in the pattern if the seconds part is optional. You want to
    permit the entire `:\d{2}` at the end of the pattern to be optional, but not to
    save the `:` character in `\3` if the third time section is present. To accomplish
    that, use `(?:`*`pat`*`)`, a grouping notation that doesn’t save the matched substring.
    Within that notation, use parentheses around the digits to save them. Then `\3`
    is `None` if the seconds part is not present, and contains the seconds digits
    otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To rewrite times from 12-hour format with AM and PM suffixes to 24-hour format,
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The time parts are placed into groups `1`, `2`, and `3`, with `3` set to `None`
    if the seconds part is missing. The suffix goes into group `4` if it’s present.
    If the suffix is `AM` or missing (`None`), the value is interpreted as an AM time.
    If the suffix is `PM`, the value is interpreted as a PM time.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe shows just the beginning of what you can do when processing dates
    for data-transfer purposes. Date and time testing and conversion can be highly
    idiosyncratic, and the sheer number of issues to consider is mind-boggling:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the basic date format? Dates come in several common styles, such as
    ISO (*`YYYY-MM-DD`*), US (*`MM-DD-YY`*), and British (*`DD-MM-YY`*) formats. And
    these are just some of the more standard formats. Many more are possible. For
    example, a datafile may contain dates written as `June` `17,` `1959` or as `17`
    `Jun` `'59`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are trailing times permitted on dates, or perhaps required? When times are expected,
    is the full time required or just the hour and minute?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you permit special values like `now` or `today`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are date parts required to be delimited by a particular character, such as `-`
    or `/`, or are other delimiters permitted?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are date parts required to have a specific number of digits? Or are leading
    zeros on month and year values permitted to be missing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are months written numerically, or represented as month names like `January`
    or `Jan`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How two-digit year values should be converted to have four digits? What is the
    transition point within the range `00` to `99` at which values change from one
    century to another?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should date parts be checked to ensure their validity? Patterns can recognize
    strings that look like dates or times, but while they’re extremely useful for
    detecting malformed values, they may not be sufficient. A value like `1947-15-99`
    may match a pattern but isn’t a legal date. Pattern testing is thus most useful
    in conjunction with range checks on the individual parts of the date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prevalence of these issues in data-transfer problems means that you’ll probably
    end up writing some of your own validators on occasion to handle very specific
    date formats. Other sections of this chapter can provide additional assistance.
    For example, [Recipe 14.13](#nch-format-format-year) covers conversion of two-digit
    year values to four-digit form, and [Recipe 14.14](#nch-format-format-date-part)
    discusses how to perform validity checking on components of date or time values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be able to save yourself some work by using existing date-checking
    modules for your API language. Some possibilities: the Perl `Date` module; the
    Ruby `date` module; the Python `datetime` module; the PHP `DateTime` class; the
    Java `GregorianCalendar` and `SimpleDateTime` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.10 Using Patterns to Match Email Addresses or URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to determine if a value looks like an email address or a URL.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your application use a pattern, tuned to the desired level of strictness
    on which addresses you accept and which do not.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The immediately preceding recipes use patterns to identify classes of values
    such as numbers and dates, which are fairly typical applications for regular expressions.
    But pattern matching has much more widespread applicability for data validation.
    To give some idea of a few other types of values for which pattern matching can
    be used, this recipe shows a few tests for email addresses and URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check values that are expected to be email addresses, the pattern should
    require at least an `@` character with nonempty strings on either side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Full email address specification defined by [RFC5322](https://www.ietf.org/rfc/rfc5322.txt)
    and contains of many parts. Regular expression that rejects all invalid addresses
    and accepts all valid is pretty complicated to write. Check [*http://emailregex.com/*](http://emailregex.com/)
    for examples for popular programming languages to have an idea.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will show you a pretty minimal test that still is sufficient
    to help correcting most of innocent user errors, such as typos when they enter
    addresses into a web form.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s difficult to come up with a fully general pattern that covers all the
    legal values and rejects all the illegal ones, but it’s easy to write a pattern
    that’s at least a little more restrictive. For example, in addition to being nonempty,
    the username and the domain name should consist entirely of characters other than
    `@` characters or spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also want to require that the domain name part contain at least two
    parts separated by a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To look for URL values that begin with a protocol specifier of `http://`, `https://`,
    `ftp://`, or `mailto:`, use an alternation that matches any of them at the beginning
    of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The alternatives in the pattern are grouped within parentheses because otherwise
    the `^` anchors only the first of them to the beginning of the string. The `re.I`
    flag follows the pattern because protocol specifiers in URLs are not case sensitive.
    The pattern is otherwise fairly unrestrictive because it permits anything to follow
    the protocol specifier. Add further restrictions as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 14.11 Using Table Metadata to Validate Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check input values against the legal members of an `ENUM` or `SET`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get the column definition, extract the list of members from it, and check data
    values against the list.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some forms of validation involve checking input values against information stored
    in a database. This includes values to be stored in an `ENUM` or `SET` column,
    which can be checked against the valid members stored in the column definition.
    Database-backed validation also applies to values that must match those listed
    in a lookup table to be considered legal. For example, input records that contain
    customer IDs can be required to match a row in a `customers` table, and state
    abbreviations in addresses can be verified against a table that lists each state.
    This recipe describes `ENUM`- and `SET`-based validation, and [Recipe 14.12](#nch-format-format-lookup)
    discusses how to use lookup tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to check input values that correspond to the legal values of `ENUM`
    or `SET` columns is to get the list of legal column values into an array using
    the information in `INFORMATION_SCHEMA`, then perform an array membership test.
    For example, the favorite-color column `color` from the `profile` table is an
    `ENUM` defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you extract the list of enumeration members from the `COLUMN_TYPE` value
    and store them in a list `members`, you can perform the membership test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can convert the list `members` and `val` to upper case to perform a case-insensitive
    comparison because the default collation is `utf8mb4_0900_ai_ci`, which is case-insensitive.
    (If you have a column with a different collation, adjust accordingly. We discussed
    how to change column collation in [Recipe 7.5](ch07.xhtml#nch-strings-strings-charset-checking-changing))
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Recipe 12.6](ch12.xhtml#nch-meta-meta-enum), we wrote a function `get_enumorset_info()`
    that returns `ENUM` or `SET` column metadata. This includes the list of members,
    so it’s easy to use that function to write another utility routine, `check_enum_value()`,
    that gets the legal enumeration values and performs the membership test. The routine
    takes four arguments: a database handle, the table name and column name for the
    `ENUM` column, and the value to check. It returns true or false to indicate whether
    the value is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For single-value testing, such as to validate a value submitted in a web form,
    list lookup for each value works well. However, to test a lot of values (like
    an entire column in a datafile), it’s better to read the enumeration values into
    memory once, then use them repeatedly to check each data value. Furthermore, it’s
    a lot more efficient to perform dictionary lookups than list lookups (in Python
    at least). To do so, retrieve the legal enumeration values and store them as keys
    of a dictionary. Then test each input value by checking whether it exists as a
    dictionary key. It’s a little more effort to construct the dictionary, which is
    why `check_enum_value()` doesn’t do so. But for bulk validation, the improved
    lookup speed more than makes up for the dictionary construction overhead. (To
    check for yourself the relative efficiency of list membership tests versus dictionary
    lookups, try the *lookup_time.py* script in the *transfer* directory of the `recipes`
    distribution.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by getting the metadata for the column and convert the list of legal
    enumeration members to a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop makes each enumeration member exist as the key of a dictionary
    element. The dictionary key is what’s important here; the value associated with
    it is irrelevant. (The example shown sets the value to `1`, but you could use
    `None`, `0`, or any other value.) Note that the code converts the dictionary keys
    to lowercase before storing them. This is done because dictionary key lookups
    in Python are case sensitive. That’s fine if the values that you check also are
    case sensitive, but `ENUM` columns by default are not. By converting the enumeration
    values to a given lettercase before storing them in the dictionary, and then converting
    the values you want to check similarly, you perform, in effect, a case-insensitive
    key existence test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The example converts enumeration values and input values to lowercase. You could
    just as well use uppercase, as long as you do so for all values consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the existence test may fail if the input value is the empty string.
    You must decide how to handle that case on a column-by-column basis. For example,
    if the column permits `NULL` values, you might interpret the empty string as equivalent
    to `NULL` and thus as being a legal value.
  prefs: []
  type: TYPE_NORMAL
- en: The validation procedure for `SET` values is similar to that for `ENUM` values,
    except that an input value might consist of any number of `SET` members, separated
    by commas. For the value to be legal, each element in it must be legal. In addition,
    because <q>any number of members</q> includes <q>none,</q> the empty string is
    a legal value for any `SET` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'For one-shot testing of individual input values, use a utility routine `check_set_value()`
    that is similar to `check_enum_value()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For bulk testing, construct a dictionary from the legal `SET` members. The procedure
    is the same as shown previously for producing a dictionary from `ENUM` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate a given input value against the `SET` member dictionary, convert
    it to the same lettercase as the hash keys, split it at commas to get a list of
    the individual elements of the value, and then check each one. If any of the elements
    are invalid, the entire value is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: After the loop terminates, `valid` is true if the value is legal for the `SET`
    column, and false otherwise. Empty strings are always legal `SET` values, but
    this code performs no special-case test for an empty string. No such test is necessary
    because in that case the `split()` operation returns an empty list, the loop never
    executes, and `valid` remains true.
  prefs: []
  type: TYPE_NORMAL
- en: 14.12 Using a Lookup Table to Validate Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check values to make sure they’re listed in a lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Issue statements to check whether the values are in the table. The best way
    to do this depends on the number of input values and the table size. In this recipe
    we will start our discussion from issuing individual statements, then create a
    hash from the entire lookup table and, finally, improve our algorithm by remembering
    already seen values to avoid querying database several times for large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To validate input values against the contents of a lookup table, the techniques
    are somewhat similar to those shown in [Recipe 14.11](#nch-format-format-meta)
    for checking `ENUM` and `SET` columns. However, whereas `ENUM` and `SET` columns
    usually have a small number of member values, a lookup table can have an essentially
    unlimited number of values. You might not want to read them all into memory.
  prefs: []
  type: TYPE_NORMAL
- en: Validation of input values against the contents of a lookup table can be done
    several ways, as illustrated in the following discussion. The tests shown in the
    examples perform comparisons against values exactly as they are stored in the
    lookup table. To perform case-insensitive comparisons, convert all values to a
    consistent lettercase. (See the discussion of case conversion in [Recipe 14.11](#nch-format-format-meta).)
  prefs: []
  type: TYPE_NORMAL
- en: Issue individual statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For one-shot operations, test a value by checking whether it’s listed in the
    lookup table. The following query returns true (nonzero) for a value that is present
    and false otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This kind of test may be suitable for purposes such as checking a value submitted
    in a web form, but is inefficient for validating large datasets. It has no memory
    for the results of previous tests for values that have been seen before; consequently,
    you execute a query for every input value.
  prefs: []
  type: TYPE_NORMAL
- en: Construct a hash from the entire lookup table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To validate a large number of values, it’s better to pull the lookup values
    into memory, save them in a data structure, and check each input value against
    the contents of that structure. Using an in-memory lookup avoids the overhead
    of executing a query for each value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run a query to retrieve all the lookup table values and construct a
    dictionary from them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, perform a dictionary key existence test to check a given value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This technique reduces database traffic to a single query. However, for a large
    lookup table, that could still be a lot of traffic, and you might not want to
    hold the entire table in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Remember already seen values to avoid database lookups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another lookup technique mixes individual statements with a dictionary that
    stores lookup value existence information. This approach can be useful if you
    have a very large lookup table. Begin with an empty dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for each value to be tested, check whether it’s present in the dictionary.
    If not, execute a query to check whether the value is present in the lookup table,
    and record the result of the query in the dictionary. The validity of the input
    value is determined by the value associated with the key, not by the existence
    of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: For this method, the dictionary acts as a cache, so that you execute a lookup
    query for any given value only once, no matter how many times it occurs in the
    input. For datasets that have repeated values, this approach avoids issuing a
    separate query for every single test, while requiring an entry in the dictionary
    only for each unique value. It thus stands between the other two approaches in
    terms of the trade-off between database traffic and program memory requirements
    for the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the dictionary is used in a different manner for this method than
    for the previous method. Previously, the existence of the input value as a key
    in the dictionary determined the validity of the value, and the value associated
    with the dictionary key was irrelevant. For the dictionary-as-cache method, the
    meaning of key existence in the dictionary changes from <q>it’s valid</q> to <q>it’s
    been tested before.</q> For each key, the value associated with it indicates whether
    the input value is present in the lookup table. (If you store as keys only those
    values that are found to be in the lookup table, you issue a query for each instance
    of an invalid value in the input dataset, which is inefficient.)
  prefs: []
  type: TYPE_NORMAL
- en: 14.13 Converting Two-Digit Year Values to Four-Digit Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert years in date values from two digits to four digits.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let MySQL do this for you, or perform the operation yourself if MySQL’s conversion
    rules aren’t appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two-digit year values are a problem because the century is not explicit in the
    data values. If you know the range of years spanned by your input, you can add
    the century without ambiguity. Otherwise, you can only guess. For example, the
    date 10/2/69 would be interpreted by most people in the US as as October 2, 1969\.
    But if it represents Mahatma Gandhi’s birth date, the year is actually 1869.
  prefs: []
  type: TYPE_NORMAL
- en: One way to convert years to four digits is to let MySQL do it. If you try to
    insert ino `YEAR` column a date containing a two-digit year, MySQL automatically
    converts it to four-digit form. MySQL uses a transition point of 1970; it interprets
    values from 00 to 69 as the years 2000 to 2069, and values from 70 to 99 as the
    years 1970 to 1999\. These rules are appropriate for year values in the range
    from 1970 to 2069\. If your values lie outside this range, add the proper century
    yourself before storing them into MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]69[PRE71],`'
  prefs: []
  type: TYPE_NORMAL
- en: -> `CAST``(``70` `AS` `YEAR``)` `AS` `` ` [PRE72] ` [PRE73]22[PRE74];`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: +------+------+------+ | 69   | 70   | 22   |
  prefs: []
  type: TYPE_NORMAL
- en: +------+------+------+ | 2069 | 1970 | 2022 |
  prefs: []
  type: TYPE_NORMAL
- en: +------+------+------+
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'def yy_to_yyyy(year, transition_point = 70):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if year < 100:'
  prefs: []
  type: TYPE_NORMAL
- en: year += 1900 if year >= transition_point else 2000
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return year
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'val = yy_to_yyyy (60)         # returns 2060'
  prefs: []
  type: TYPE_NORMAL
- en: 'val = yy_to_yyyy (1960)       # returns 1960 (no conversion done)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 00 .. 49 -> 2000 .. 2049
  prefs: []
  type: TYPE_NORMAL
- en: 50 .. 99 -> 1950 .. 1999
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'val = yy_to_yyyy (60, 50)     # returns 1960'
  prefs: []
  type: TYPE_NORMAL
- en: 'val = yy_to_yyyy (1960, 50)   # returns 1960 (no conversion done)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: valid = is_valid_date(ref[0], ref[1], ref[2])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'def is_valid_date(year, month, day):'
  prefs: []
  type: TYPE_NORMAL
- en: print(year, month, day)
  prefs: []
  type: TYPE_NORMAL
- en: 'if year < 0: # or (month < 0) or (day < 1):'
  prefs: []
  type: TYPE_NORMAL
- en: return 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if year > 9999 or month > 12 or day > days_in_month(year, month):'
  prefs: []
  type: TYPE_NORMAL
- en: return 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return 1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'def is_leap_year(year):'
  prefs: []
  type: TYPE_NORMAL
- en: return ((year % 4 == 0) and ((year % 100 != 0) or (year % 400 == 0) ) )
  prefs: []
  type: TYPE_NORMAL
- en: 'def days_in_month(year, month):'
  prefs: []
  type: TYPE_NORMAL
- en: day_tbl = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  prefs: []
  type: TYPE_NORMAL
- en: days = day_tbl[month - 1]
  prefs: []
  type: TYPE_NORMAL
- en: 'if month == 2 and is_leap_year(year):'
  prefs: []
  type: TYPE_NORMAL
- en: days += 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return days
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'def is_24hr_time(val):'
  prefs: []
  type: TYPE_NORMAL
- en: m = re.match('^(\d{1,2})\D(\d{2})\D(\d{2})$', val)
  prefs: []
  type: TYPE_NORMAL
- en: 'if m is None:'
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return[int(m.group(1)), int(m.group(2)), int(m.group(3))]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'def is_ampm_time(val):'
  prefs: []
  type: TYPE_NORMAL
- en: m = re.match('^(\d{1,2})\D(\d{2})\D(\d{2})(?:\s*(AM|PM))?$', val, flags = re.I)
  prefs: []
  type: TYPE_NORMAL
- en: 'if m is None:'
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (hour, min, sec) = (int(m.group(1)), (m.group(2)), (m.group(3)))
  prefs: []
  type: TYPE_NORMAL
- en: '# supply missing seconds'
  prefs: []
  type: TYPE_NORMAL
- en: sec = '00' if sec is None else sec
  prefs: []
  type: TYPE_NORMAL
- en: 'if hour == 12 and (m.group(4) is None or m.group(4).upper() == "AM"):'
  prefs: []
  type: TYPE_NORMAL
- en: 'hour = ''00'' # 12:xx:xx AM times are 00:xx:xx'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elif int(hour) < 12 and (m.group(4) is not None) and m.group(4).upper() ==
    "PM":'
  prefs: []
  type: TYPE_NORMAL
- en: 'hour = hour + 12 # PM times other than 12:xx:xx'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return [hour, min, sec] # return hour, minute, second'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '#!/usr/bin/python3'
  prefs: []
  type: TYPE_NORMAL
- en: 'isoize_date.py: Read input data, look for values that match'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a date pattern, convert them to ISO format. Also converts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2-digit years to 4-digit years, using a transition point of 70.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, this looks for dates in MM-DD-[CC]YY format.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does not check whether dates actually are valid (for example,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: won't complain about 13-49-1928).
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assumes tab-delimited, linefeed-terminated input lines.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import re
  prefs: []
  type: TYPE_NORMAL
- en: import fileinput
  prefs: []
  type: TYPE_NORMAL
- en: transition point at which 2-digit XX year values are assumed to be
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 19XX (below that, they are treated as 20XX)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: transition = 70
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in fileinput.input(sys.argv[1:]):'
  prefs: []
  type: TYPE_NORMAL
- en: 'val = line.split("\t", 10000);  # split, preserving all fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, len(val)):'
  prefs: []
  type: TYPE_NORMAL
- en: look for strings in MM-DD-[CC]YY format
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: m = re.match('^(\d{1,2})\D(\d{1,2})\D(\d{2,4})$', val[i])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not m:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (month, day, year) = (int(m.group(1)), int(m.group(2)), int(m.group(3)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to interpret dates as DD-MM-[CC]YY instead, replace preceding
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'line with the following one:'
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: (day, month, year) = (int(m.group(1)), int(m.group(2)), int(m.group(3)))
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: convert 2-digit years to 4 digits, then update value in array
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if year < 100:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: year += 1900 if year >= transition else 2000
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: val[i] = "%04d-%02d-%02d" % (year, month, day)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print("\t".join (val))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Sybil   04-13-70
  prefs: []
  type: TYPE_NORMAL
- en: Nancy   09-30-69
  prefs: []
  type: TYPE_NORMAL
- en: Ralph   11-02-73
  prefs: []
  type: TYPE_NORMAL
- en: Lothair 07-04-63
  prefs: []
  type: TYPE_NORMAL
- en: Henry   02-14-65
  prefs: []
  type: TYPE_NORMAL
- en: Aaron   09-17-68
  prefs: []
  type: TYPE_NORMAL
- en: Joanna  08-20-52
  prefs: []
  type: TYPE_NORMAL
- en: Stephen 05-01-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Sybil   1970-04-13
  prefs: []
  type: TYPE_NORMAL
- en: Nancy   2069-09-30
  prefs: []
  type: TYPE_NORMAL
- en: Ralph   1973-11-02
  prefs: []
  type: TYPE_NORMAL
- en: Lothair 2063-07-04
  prefs: []
  type: TYPE_NORMAL
- en: Henry   2065-02-14
  prefs: []
  type: TYPE_NORMAL
- en: Aaron   2068-09-17
  prefs: []
  type: TYPE_NORMAL
- en: Joanna  2052-08-20
  prefs: []
  type: TYPE_NORMAL
- en: Stephen 2060-05-01
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: name1   01/01/99    38
  prefs: []
  type: TYPE_NORMAL
- en: name2   12/31/00    40
  prefs: []
  type: TYPE_NORMAL
- en: name3   02/28/13    42
  prefs: []
  type: TYPE_NORMAL
- en: name4   01/02/18    44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: $ `cvt_date.pl --iformat=us --add-century newdata.txt`
  prefs: []
  type: TYPE_NORMAL
- en: name1   1999-01-01  38
  prefs: []
  type: TYPE_NORMAL
- en: name2   2000-12-31  40
  prefs: []
  type: TYPE_NORMAL
- en: name3   2013-02-28  42
  prefs: []
  type: TYPE_NORMAL
- en: name4   2018-01-02  44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: $ `cvt_date.pl --iformat=us --oformat=br newdata.txt`
  prefs: []
  type: TYPE_NORMAL
- en: name1   01-01-99    38
  prefs: []
  type: TYPE_NORMAL
- en: name2   31-12-00    40
  prefs: []
  type: TYPE_NORMAL
- en: name3   28-02-13    42
  prefs: []
  type: TYPE_NORMAL
- en: name4   02-01-18    44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Delaware        Dec. 7, 1787
  prefs: []
  type: TYPE_NORMAL
- en: Pennsylvania    Dec 12, 1787
  prefs: []
  type: TYPE_NORMAL
- en: New Jersey      Dec. 18, 1787
  prefs: []
  type: TYPE_NORMAL
- en: Georgia         Jan. 2, 1788
  prefs: []
  type: TYPE_NORMAL
- en: Connecticut     Jan. 9, 1788
  prefs: []
  type: TYPE_NORMAL
- en: Massachusetts   Feb. 6, 1788
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Delaware        1787-12-07
  prefs: []
  type: TYPE_NORMAL
- en: Pennsylvania    1787-12-12
  prefs: []
  type: TYPE_NORMAL
- en: New Jersey      1787-12-18
  prefs: []
  type: TYPE_NORMAL
- en: Georgia         1788-01-02
  prefs: []
  type: TYPE_NORMAL
- en: Connecticut     1788-01-09
  prefs: []
  type: TYPE_NORMAL
- en: Massachusetts   1788-02-06
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '#!/usr/bin/python3'
  prefs: []
  type: TYPE_NORMAL
- en: 'monddyyyy_to_iso.py: Convert dates from mon[.] dd, yyyy to ISO format.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assumes tab-delimited, linefeed-terminated input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import re
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import fileinput
  prefs: []
  type: TYPE_NORMAL
- en: import warnings
  prefs: []
  type: TYPE_NORMAL
- en: 'map = {"jan": 1, "feb": 2, "mar": 3, "apr": 4, "may": 5, "jun": 6,'
  prefs: []
  type: TYPE_NORMAL
- en: '"jul": 7, "aug": 8, "sep": 9, "oct": 10, "nov": 11, "dec": 12'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '} # map 3-char month abbreviations to numeric month'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for line in fileinput.input(sys.argv[1:]):'
  prefs: []
  type: TYPE_NORMAL
- en: 'values = line.rstrip().split("\t", 10000)    # split, preserving all fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, len(values)):'
  prefs: []
  type: TYPE_NORMAL
- en: reformat the value if it matches the pattern, otherwise assume
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: that it's not a date in the required format and leave it alone
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: m = re.match('^([^.]+)\.? (\d+), (\d+)$', values[i])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if m:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# use lowercase month name'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (month, day, year) = (m.group(1).lower(), int(m.group(2)), int(m.group(3)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#@ _CHECK_VALIDITY_'
  prefs: []
  type: TYPE_NORMAL
- en: 'if month in map:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#@ _CHECK_VALIDITY_'
  prefs: []
  type: TYPE_NORMAL
- en: values[i] = "%04d-%02d-%02d" % (year, map[month], day)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: warn, but don't reformat
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: warnings.warn("%s bad date?" % (values[i]))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print("\t".join(values))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: from cookbook_utils import *
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'if month in map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'if month in map and is_valid_date(year, map[month], day)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: name1   01/01/99    38
  prefs: []
  type: TYPE_NORMAL
- en: name2   12/31/00    40
  prefs: []
  type: TYPE_NORMAL
- en: name3   02/28/13    42
  prefs: []
  type: TYPE_NORMAL
- en: name4   01/02/18    44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: $ `cvt_date.py --iformat=us --add-century newdata.txt > tmp.txt`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: mysql> `LOAD DATA LOCAL INFILE 'newdata.txt'`
  prefs: []
  type: TYPE_NORMAL
- en: -> `INTO TABLE t (name,@date,value)`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -> `SET date = STR_TO_DATE(@date,'%m/%d/%y');`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: +-------+------------+-------+
  prefs: []
  type: TYPE_NORMAL
- en: '| name  | date       | value |'
  prefs: []
  type: TYPE_TB
- en: +-------+------------+-------+
  prefs: []
  type: TYPE_NORMAL
- en: '| name1 | 1999-01-01 |    38 |'
  prefs: []
  type: TYPE_TB
- en: '| name2 | 2000-12-31 |    40 |'
  prefs: []
  type: TYPE_TB
- en: '| name3 | 2013-02-28 |    42 |'
  prefs: []
  type: TYPE_TB
- en: '| name4 | 2018-01-02 |    44 |'
  prefs: []
  type: TYPE_TB
- en: +-------+------------+-------+
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: mysql> `LOAD DATA LOCAL INFILE 'newdata.txt'`
  prefs: []
  type: TYPE_NORMAL
- en: -> `INTO TABLE t (name,@date,value)`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -> `SET date = my_date_interp(@date);`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: CREATE TABLE datetbl
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: i   INT,
  prefs: []
  type: TYPE_NORMAL
- en: c   CHAR(10),
  prefs: []
  type: TYPE_NORMAL
- en: d   DATE,
  prefs: []
  type: TYPE_NORMAL
- en: dt  DATETIME,
  prefs: []
  type: TYPE_NORMAL
- en: ts  TIMESTAMP,
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY(i)
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: SELECT
  prefs: []
  type: TYPE_NORMAL
- en: i,
  prefs: []
  type: TYPE_NORMAL
- en: c,
  prefs: []
  type: TYPE_NORMAL
- en: DATE_FORMAT(d, '%m-%d-%Y') AS d,
  prefs: []
  type: TYPE_NORMAL
- en: DATE_FORMAT(dt, '%m-%d-%Y %T') AS dt,
  prefs: []
  type: TYPE_NORMAL
- en: DATE_FORMAT(ts, '%m-%d-%Y %T') AS ts
  prefs: []
  type: TYPE_NORMAL
- en: FROM datetbl;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 3       abc     2005-12-31      2005-12-31 12:05:03     2005-12-31 12:05:03
  prefs: []
  type: TYPE_NORMAL
- en: 4       xyz     2006-01-31      2006-01-31 12:05:03     2006-01-31 12:05:03
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 3       abc     12-31-2005      12-31-2005 12:05:03     12-31-2005 12:05:03
  prefs: []
  type: TYPE_NORMAL
- en: 4       xyz     01-31-2006      01-31-2006 12:05:03     01-31-2006 12:05:03
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: $ `cvt_file.pl --iformat=csv somedata.csv \`
  prefs: []
  type: TYPE_NORMAL
- en: '`| yank_col.pl --columns=2,11,5,9 \`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`| cvt_date.py --columns=2 --iformat=us --add-century > tmp`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '#!/usr/bin/python3'
  prefs: []
  type: TYPE_NORMAL
- en: 'validate_htwt.py: Height/weight validation example.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assumes tab-delimited, linefeed-terminated input lines.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Input columns and the actions to perform on them are as follows:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1: name; echo as given'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2: birth; echo as given'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3: height; validate as positive integer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4: weight; validate as positive integer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import fileinput
  prefs: []
  type: TYPE_NORMAL
- en: import warnings
  prefs: []
  type: TYPE_NORMAL
- en: from cookbook_utils import *
  prefs: []
  type: TYPE_NORMAL
- en: line_num = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in fileinput.input(sys.argv[1:]):'
  prefs: []
  type: TYPE_NORMAL
- en: line_num += 1
  prefs: []
  type: TYPE_NORMAL
- en: (name, birth, height, weight) = line.rstrip().split ("\t", 4)
  prefs: []
  type: TYPE_NORMAL
- en: 'if not is_positive_integer(height):'
  prefs: []
  type: TYPE_NORMAL
- en: warnings.warn(f"line {line_num}:height {height} is not a positive integer")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not is_positive_integer(weight):'
  prefs: []
  type: TYPE_NORMAL
- en: warnings.warn(f"line {line_num}:weight {weight} is not a positive integer")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: mysql> `LOAD DATA LOCAL INFILE 'tmp' INTO TABLE` *`tbl_name`*`;`
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
