- en: Chapter 7\. Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why only use the
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Boring built-in type shapes when
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can make our own!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I mentioned back in [Chapter 4, “Objects”](ch04.xhtml#objects) that although
    type aliases for `{ ... }` object types are a way to describe object shapes, TypeScript
    also includes an “interface” feature many developers prefer. Interfaces are another
    way to declare an object shape with an associated name. Interfaces are in many
    ways similar to aliased object types but are generally preferred for their more
    readable error messages, speedier compiler performance, and better interoperability
    with classes.
  prefs: []
  type: TYPE_NORMAL
- en: Type Aliases Versus Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a quick recap of the syntax for how an aliased object type would describe
    an object with a `born: number` and `name: string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the equivalent syntax for an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The two syntaxes are almost identical.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TypeScript developers who prefer semicolons generally put them after type aliases
    and not after interfaces. This preference mirrors the difference between declaring
    a variable with a `;` versus declaring a class or function without.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript’s assignability checking and error messages for interfaces also
    work and look just about the same as they do for object types. The following assignability
    errors for assigning to the `valueLater` variable would be roughly the same if
    `Poet` was an interface or type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are a few key differences between interfaces and type aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see later in this chapter, interfaces can “merge” together to be augmented—a
    feature particularly useful when working with third-party code such as built-in
    globals or npm packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you’ll see in the next chapter, [Chapter 8, “Classes”](ch08.xhtml#classes),
    interfaces can be used to type check the structure of class declarations while
    type aliases cannot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interfaces are generally speedier for the TypeScript type checker to work with:
    they declare a named type that can be cached more easily internally, rather than
    a dynamic copy-and-paste of a new object literal the way type aliases do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because interfaces are considered named objects rather than an alias for an
    unnamed object literal, their error messages are more likely to be readable in
    hard edge cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the latter two reasons and to maintain consistency, the rest of this book
    and its associated projects default to using interfaces over aliased object shapes.
    I generally recommend using interfaces whenever possible (i.e., until you need
    features such as union types from type aliases).
  prefs: []
  type: TYPE_NORMAL
- en: Types of Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript objects can be wild and wacky in real-world usage, including getters
    and setters, properties that only sometimes exist, or accepting any arbitrary
    property names. TypeScript provides a set of type system tools for interfaces
    to help us model that wackiness.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because interfaces and type aliases behave so similarly, the following types
    of properties introduced in this chapter are all also usable with aliased object
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with object types, interface properties don’t all have to be required in
    the object. You can indicate an interface’s property is optional by including
    a `?` before the `:` in its type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Book` interface requires only a `required` property and optionally allows
    an `optional`. Objects adhering to it may provide `optional` or leave it out as
    long as they provide `required`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The same caveats around the difference between optional properties and properties
    whose type happens to include `undefined` in a type union apply to interfaces
    as well as object types. [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options)
    will describe TypeScript’s strictness settings around optional properties.
  prefs: []
  type: TYPE_NORMAL
- en: Read-Only Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may sometimes wish to block users of your interface from reassigning properties
    of objects adhering to an interface. TypeScript allows you to add a `readonly`
    modifier before a property name to indicate that once set, that property should
    not be set to a different value. These `readonly` properties can be read from
    normally, but not reassigned to anything new.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `text` property in the below `Page` interface gives back a
    `string` when accessed, but causes a type error if assigned a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that `readonly` modifiers exist only in the type system, and only apply
    to the usage of that interface. It won’t apply to an object unless that object
    is used in a location that declares it to be of that interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this continuation of the `exclaim` example, the `text` property is allowed
    to be modified outside of the function because its parent object isn’t explicitly
    used as a `Text` until inside the function. `pageIsh` is allowed to be used as
    a `Page` because a writable property is assignable to a `readonly` property (mutable
    properties can be read from, which is all a `readonly` property needs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring the variable `pageIsh` with the explicit type annotation `: Page`
    would have indicated to TypeScript that its `text` property was `readonly`. Its
    inferred type, however, was not `readonly`.'
  prefs: []
  type: TYPE_NORMAL
- en: Read-only interface members are a handy way to make sure areas of code don’t
    unexpectedly modify objects they’re not meant to. However, remember that they’re
    a type system construct only and don’t exist in the compiled JavaScript output
    code. They only protect from modification during development with the TypeScript
    type checker.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s very common in JavaScript for object members to be functions. TypeScript
    therefore allows declaring interface members as being the function types previously
    covered in [Chapter 5, “Functions”](ch05.xhtml#functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript provides two ways of declaring interface members as functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Method* syntax: declaring that a member of the interface is a function intended
    to be called as a member of the object, like `member(): void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Property* syntax: declaring that a member of the interface is equal to a standalone
    function, like `member: () => void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two declaration forms are an analog for the two ways you can declare a JavaScript
    object as having a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `method` and `property` members shown here are functions that may be called
    with no parameters and return a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Both forms can receive the `?` optional modifier to indicate they don’t need
    to be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Method and property declarations can mostly be used interchangeably. The main
    differences between them that I’ll cover in this book are:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods cannot be declared as `readonly`; properties can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface merging (covered later in this chapter) treats them differently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the operations performed on types covered in [Chapter 15, “Type Operations”](ch15.xhtml#type_operations)
    treat them differently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future versions of TypeScript may add the option to be more strict about the
    differences between methods and property functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the general style guide I recommend is:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a method function if you know the underlying function may refer to `this`,
    most commonly for instances of classes (covered in [Chapter 8, “Classes”](ch08.xhtml#classes)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a property function otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t sweat it if you mix up these two, or don’t understand the difference.
    It’ll rarely impact your code unless you’re being intentional about `this` scoping
    and which form you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Call Signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces and object types can declare *call signatures*, which is a type system
    description of how a value may be called like a function. Only values that may
    be called in the way the call signature declares will be assignable to the interface—i.e.,
    a function with assignable parameters and return type. A call signature looks
    similar to a function type, but with a `:` colon instead of an `=>` arrow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `FunctionAlias` and `CallSignature` types both describe the same
    function parameters and return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Call signatures can be used to describe functions that additionally have some
    user-defined property on them. TypeScript will recognize a property added to a
    function declaration as adding to that function declaration’s type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `keepsTrackOfCalls` function declaration is given a `count` property
    of type `number`, making it assignable to the `FunctionWithCount` interface. It
    can therefore be assigned to the `hasCallCount` argument of type `FunctionWithCount`.
    The function at the end of the snippet was not given a `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Index Signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some JavaScript projects create objects meant to store values under any arbitrary
    `string` key. For these “container” objects, declaring an interface with a field
    for every possible key would be impractical or impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript provides a syntax called an *index signature* to indicate that an
    interface’s objects are allowed to take in any key and give back a certain type
    under that key. They’re most commonly used with string keys because JavaScript
    object property lookups convert keys to strings implicitly. An index signature
    looks like a regular property definition but with a type after the key, and array
    brackets surrounding them, like `{ [i: string]: ... }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `WordCounts` interface is declared as allowing any `string` key with a
    `number` value. Objects of that type aren’t bound to receiving any particular
    key—as long as the value is a `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Index signatures are convenient for assigning values to an object but aren’t
    completely type safe. They indicate that an object should give back a value no
    matter what property is being accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `publishDates` value safely gives back `Frankenstein` as a `Date` but
    tricks TypeScript into thinking its `Beloved` is defined even though it’s `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When possible, if you’re looking to store key-value pairs and the keys aren’t
    known ahead of time, it is generally safer to use a `Map`. Its `.get` method always
    returns a type with `| undefined` to indicate that the key might not exist. [Chapter 9,
    “Type Modifiers”](ch09.xhtml#type_modifiers_chapter) will discuss working with
    generic container classes such as `Map` and `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing properties and index signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interfaces are able to include explicitly named properties and catchall `string`
    index signatures, with one catch: each named property’s type must be assignable
    to its catchall index signature’s type. You can think of mixing them as telling
    TypeScript that named properties give a more specific type, and any other property
    falls back to the index signature’s type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `HistoricalNovels` declares that all properties are type `number`, and
    additionally the `Oroonoko` property must exist to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: One common type system trick with mixed properties and index signatures is to
    use a more specific property type literal for the named property than an index
    signature’s primitive. As long as the named property’s type is assignable to the
    index signature’s—which is true for a literal and a primitive, respectively—TypeScript
    will allow it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `ChapterStarts` declares that a property under `preface` must be `0`
    and all other properties have the more general `number`. That means any object
    adhering to `ChapterStarts` must have a `preface` property equal to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Numeric index signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although JavaScript implicitly converts object property lookup keys to strings,
    it is sometimes desirable to only allow numbers as keys for an object. TypeScript
    index signatures can use a `number` type instead of `string` but with the same
    catch as named properties that their types must be assignable to the catchall
    `string` index signature’s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `MoreNarrowNumbers` interface would be allowed because `string`
    is assignable to `string | undefined`, but `MoreNarrowStrings` would not because
    `string | undefined` is not assignable to `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Nested Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like object types can be nested as properties of other object types, interface
    types can also have properties that are themselves interface types (or object
    types).
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Novel` interface contains an `author` property that must satisfy an inline
    object type and a `setting` property that must satisfy the `Setting` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Interface Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you may end up with multiple interfaces that look similar to each
    other. One interface may contain all the same members of another interface, with
    a few extras added on.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript allows an interface to *extend* another interface, which declares
    it as copying all the members of another. An interface may be marked as extending
    another interface by adding the `extends` keyword after its name (the “derived”
    interface), followed by the name of the interface to extend (the “base” interface).
    Doing so indicates to TypeScript that all objects adhering to the derived interface
    must also have all the members of the base interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `Novella` interface extends from `Writing` and
    thus requires objects to have at least both `Novella`’s `pages` and `Writing`’s
    `title` members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Interface extensions are a nifty way to represent that one type of entity in
    your project is a superset (it includes all the members of) another entity. They
    allow you to avoid having to type out the same code repeatedly across multiple
    interfaces to represent that relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Overridden Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Derived interfaces may *override*, or replace, properties from their base interface
    by declaring the property again with a different type. TypeScript’s type checker
    will enforce that an overridden property must be assignable to its base property.
    It does so to ensure that instances of the derived interface type stay assignable
    to the base interface type.
  prefs: []
  type: TYPE_NORMAL
- en: Most derived interfaces that redeclare properties do so either to make those
    properties a more specific subset of a type union or to make the properties a
    type that extends from the base interface’s type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `WithNullableName` type is properly made non-nullable in
    `WithNonNullableName`. `WithNumericName`, however, is not allowed as `number |
    string` and is not assignable to `string | null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Extending Multiple Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces in TypeScript are allowed to be declared as extending multiple other
    interfaces. Any number of interface names separated by commas may be used after
    the `extends` keyword following the derived interface’s name. The derived interface
    will receive all members from all base interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `GivesBothAndEither` has three methods: one on its own, one from
    `GivesNumber`, and one from `GivesString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By marking an interface as extending multiple other interfaces, you can both
    reduce code duplication and make it easier for object shapes to be reused across
    different areas of code.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important features of interfaces is their ability to *merge* with
    each other. Interface merging means if two interfaces are declared in the same
    scope with the same name, they’ll join into one bigger interface under that name
    with all declared fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet declares a `Merged` interface with two properties: `fromFirst`
    and `fromSecond`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Interface merging isn’t a feature used very often in day-to-day TypeScript development.
    I would recommend avoiding it when possible, as it can be difficult to understand
    code where an interface is declared in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, interface merging is particularly useful for augmenting interfaces
    from external packages or built-in global interfaces such as `Window`. For example,
    when using the default TypeScript compiler options, declaring a `Window` interface
    in a file with a `myEnvironmentVariable` property makes a `window.myEnvironmentVariable`
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I’ll cover type definitions more deeply in [Chapter 11, “Declaration Files”](ch11.xhtml#declaration_files)
    and TypeScript global type options in [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options).
  prefs: []
  type: TYPE_NORMAL
- en: Member Naming Conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that merged interfaces may not declare the same name of a property multiple
    times with different types. If a property is already declared in an interface,
    a later merged interface must use the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this `MergedProperties` interface, the `same` property is allowed because
    it is the same in both declarations, but `different` is an error for being a different
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Merged interfaces may, however, define a method with the same name and a different
    signature. Doing so creates a function overload for the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `MergedMethods` interface creates a `different` method that has two overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced how object types may be described by interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Using interfaces instead of type aliases to declare object types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various interface property types: optional, read-only, function, and method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using index signatures for catchall object properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing interfaces using nested interfaces and `extends` inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How interfaces with the same name can merge together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next up will be a native JavaScript syntax for setting up multiple objects
    to have the same properties: classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/objects-and-interfaces*](https://learningtypescript.com/objects-and-interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: Why are interfaces good drivers?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They’re great at merging.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
