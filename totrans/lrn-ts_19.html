<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 15. Type Operations"><div class="chapter" id="type_operations">
<h1><span class="label">Chapter 15. </span>Type Operations</h1>

<blockquote>
<p>Conditionals, maps</p>

<p>With great power over types</p>

<p>comes great confusion</p></blockquote>

<p>TypeScript gives us awesome levels of power to define types in the type system.
Even the logical modifiers from <a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.xhtml#generics_chapter">Chapter 10, “Generics”</a> pale in comparison to the capabilities of the type operations in this chapter.
Once you’ve completed this chapter, you’ll be able to mix, match, and modify types based on other types—giving you powerful ways to represent types in the type system.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Most of these fancy types are techniques you generally don’t want to use very frequently.
You’ll want to understand them for the cases where they are useful, but beware: they can be difficult to read through when overused.
Have fun!</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Mapped Types"><div class="sect1" id="idm45584665604192">
<h1>Mapped Types</h1>

<p>TypeScript <a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="purpose of" id="type-mapped-purpose"/><a data-type="indexterm" data-primary="mapped types" data-secondary="purpose of" id="mapped-purpose"/><a data-type="indexterm" data-primary="type operations" data-secondary="mapped types" id="typeop-mapped"/>provides syntax for creating a new type based on the properties of another type: in other words, <em>mapping</em> from one type to another.
A <em>mapped type</em> in TypeScript is a type that takes in another type and performs some operation on each property of that type.</p>

<p>Mapped types create a new type by creating a new property under each key in a set of keys.
They use a syntax similar to index signatures, but instead of using a static key type with <code>:</code> like <code>[i: string]</code>, they use a computed type from the other type with <code>in</code> like <code>[K in OriginalType]</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">NewType</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">OriginalType</code><code class="p">]</code><code class="o">:</code> <code class="nx">NewProperty</code><code class="p">;</code>
<code class="p">};</code></pre>

<p>One common use case for mapped types is to create an object whose keys are each of the string literals in an existing union type.
This <code>AnimalCounts</code> type creates a new object type where the keys are each of the values from the <code>Animals</code> union type and each of the values is <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Animals</code> <code class="o">=</code> <code class="s2">"alligator"</code> <code class="o">|</code> <code class="s2">"baboon"</code> <code class="o">|</code> <code class="s2">"cat"</code><code class="p">;</code>

<code class="kr">type</code> <code class="nx">AnimalCounts</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Animals</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   alligator: number;</code>
<code class="c1">//   baboon: number;</code>
<code class="c1">//   cat: number;</code>
<code class="c1">// }</code></pre>

<p>Mapped types based on existing literals of unions are a convenient way to save space in declaring big interfaces.
But mapped types really shine when they can act on other types and even add or remove modifiers from <a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="purpose of" data-startref="type-mapped-purpose" id="idm45584665516000"/><a data-type="indexterm" data-primary="mapped types" data-secondary="purpose of" data-startref="mapped-purpose" id="idm45584665567680"/>members.</p>








<section data-type="sect2" data-pdf-bookmark="Mapped Types from Types"><div class="sect2" id="idm45584665566208">
<h2>Mapped Types from Types</h2>

<p>Mapped types<a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="from existing types" id="type-mapped-exist"/><a data-type="indexterm" data-primary="mapped types" data-secondary="from existing types" id="mapped-exist"/><a data-type="indexterm" data-primary="keyof type operator" data-secondary="mapped types" id="keyof-mapped"/> commonly act on existing types using the <code>keyof</code> operator to grab the keys of that existing type.
By instructing a type to map over the keys of an existing type, we can <em>map</em> from that existing type to a new one.</p>

<p>This <code>AnimalCounts</code> type ends up being the same as the <code>AnimalCounts</code> type from before by mapping from the <code>AnimalVariants</code> type to a new equivalent one:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">AnimalVariants</code> <code class="p">{</code>
    <code class="nx">alligator</code>: <code class="nx">boolean</code><code class="p">;</code>
    <code class="nx">baboon</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">cat</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">AnimalCounts</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">AnimalVariants</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   alligator: number;</code>
<code class="c1">//   baboon: number;</code>
<code class="c1">//   cat: number;</code>
<code class="c1">// }</code></pre>

<p>The new type keys mapped over a <code>keyof</code>—named <code>K</code> in the previous snippets—are known to be keys of the original type. That means each mapped type member value is allowed to reference the original type’s corresponding member value under the same key.</p>

<p>If the original object is <code>SomeName</code> and the mapping is <code>[K in keyof SomeName]</code>, then each member in the mapped type would be able to refer to the equivalent <code>SomeName</code> member’s value as <code>SomeName[K]</code>.</p>

<p>This <code>NullableBirdVariants</code> type takes an original <code>BirdVariants</code> type and adds <code>| null</code> to each member:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">BirdVariants</code> <code class="p">{</code>
    <code class="nx">dove</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">eagle</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">NullableBirdVariants</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">BirdVariants</code><code class="p">]</code><code class="o">:</code> <code class="nx">BirdVariants</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="o">|</code> <code class="kc">null</code><code class="p">,</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   dove: string | null;</code>
<code class="c1">//   eagle: boolean | null;</code>
<code class="c1">// }</code></pre>

<p>Instead of painstakingly copying each field from an original type to any number of other types, mapped types let you define a set of members once and re-create new versions of them en masse as many times as you <a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="from existing types" data-startref="type-mapped-exist" id="idm45584665350832"/><a data-type="indexterm" data-primary="mapped types" data-secondary="from existing types" data-startref="mapped-exist" id="idm45584665412224"/><a data-type="indexterm" data-primary="keyof type operator" data-secondary="mapped types" data-startref="keyof-mapped" id="idm45584665411008"/>need.</p>










<section data-type="sect3" data-pdf-bookmark="Mapped types and signatures"><div class="sect3" id="idm45584665409536">
<h3>Mapped types and signatures</h3>

<p>In <a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.xhtml#interfaces">Chapter 7, “Interfaces”</a>, I <a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="signatures and" id="type-mapped-signature"/><a data-type="indexterm" data-primary="mapped types" data-secondary="signatures and" id="mapped-signature"/><a data-type="indexterm" data-primary="methods" data-secondary="mapped types" id="method-mapped"/><a data-type="indexterm" data-primary="properties" data-secondary="mapped types" id="property-mapped"/>introduced that TypeScript provides two ways of declaring interface members as functions:</p>

<ul>
<li>
<p><em>Method</em> syntax, like <code>member(): void</code>: declaring that a member of the interface is a function intended to be called as a member of the object</p>
</li>
<li>
<p><em>Property</em> syntax, like <code>member: () =&gt; void</code>: declaring that a member of the interface is equal to a standalone function</p>
</li>
</ul>

<p>Mapped types don’t distinguish between method and property syntaxes on object types.
Mapped types treat methods as properties on original types.</p>

<p>This <code>ResearcherProperties</code> type contains both the <code>property</code> and <code>method</code> members of <code>Researcher</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Researcher</code> <code class="p">{</code>
    <code class="nx">researchMethod</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>
    <code class="nx">researchProperty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">JustProperties</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">ResearcherProperties</code> <code class="o">=</code> <code class="nx">JustProperties</code><code class="o">&lt;</code><code class="nx">Researcher</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   researchMethod: () =&gt; void;</code>
<code class="c1">//   researchProperty: () =&gt; string;</code>
<code class="c1">// }</code></pre>

<p>The distinction between methods and properties does not show up very often in most practical TypeScript code.
It’s rare to find a practical use of a mapped type that takes in a <a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="signatures and" data-startref="type-mapped-signature" id="idm45584665318800"/><a data-type="indexterm" data-primary="mapped types" data-secondary="signatures and" data-startref="mapped-signature" id="idm45584665306000"/><a data-type="indexterm" data-primary="methods" data-secondary="mapped types" data-startref="method-mapped" id="idm45584665304784"/><a data-type="indexterm" data-primary="properties" data-secondary="mapped types" data-startref="property-mapped" id="idm45584665303568"/>class type.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Changing Modifiers"><div class="sect2" id="idm45584665565584">
<h2>Changing Modifiers</h2>

<p>Mapped types <a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="changing access control modifiers" id="type-mapped-modify"/><a data-type="indexterm" data-primary="mapped types" data-secondary="changing access control modifiers" id="mapped-modify"/><a data-type="indexterm" data-primary="access control modifiers, changing" id="access-control-modify-change"/><a data-type="indexterm" data-primary="modifiers, changing" id="modify-change"/>can also change the access control modifiers—<code>readonly</code> and <code>?</code> optionality—on the original type’s members.
<code>readonly</code> or <code>?</code> can be placed on members of mapped types using the same syntax as typical interfaces.</p>

<p>The following <code>ReadonlyEnvironmentalist</code> type makes a version of the <code>Environmentalist</code> interface with all members given <code>readonly</code>, while <code>OptionalReadonlyConservationist</code> goes one step further and makes another version that adds <code>?</code> to all the <code>ReadonlyEnvironmentalist</code> members:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Environmentalist</code> <code class="p">{</code>
    <code class="nx">area</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">ReadonlyEnvironmentalist</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">readonly</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">Environmentalist</code><code class="p">]</code><code class="o">:</code> <code class="nx">Environmentalist</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   readonly area: string;</code>
<code class="c1">//   readonly name: string;</code>
<code class="c1">// }</code>

<code class="kr">type</code> <code class="nx">OptionalReadonlyEnvironmentalist</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">ReadonlyEnvironmentalist</code><code class="p">]</code><code class="o">?:</code> <code class="nx">ReadonlyEnvironmentalist</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   readonly area?: string;</code>
<code class="c1">//   readonly name?: string;</code>
<code class="c1">// }</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>OptionalReadonlyEnvironmentalist</code> type could alternately 
<span class="keep-together">be written</span> with <code>readonly [K in keyof Environmentalist]?: Environmentalist[K]</code>.</p>
</div>

<p>Removing modifiers is done by adding a <code>-</code> before the modifier in a new type.
Instead of writing <code>readonly</code> or <code>?:</code>, you can write <code>-readonly</code> or <code>-?:</code>, respectively.</p>

<p>This <code>Conservationist</code> type contains <code>?</code> optional and/or <code>readonly</code> members that are made writable in <code>WritableConservationist</code> and then also required in 
<span class="keep-together"><code>RequiredWritableConservationist</code>:</span></p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Conservationist</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">catchphrase?</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">readonly</code> <code class="nx">born</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">readonly</code> <code class="nx">died?</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">WritableConservationist</code> <code class="o">=</code> <code class="p">{</code>
    <code class="o">-</code><code class="nx">readonly</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">Conservationist</code><code class="p">]</code><code class="o">:</code> <code class="nx">Conservationist</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   name: string;</code>
<code class="c1">//   catchphrase?: string;</code>
<code class="c1">//   born: number;</code>
<code class="c1">//   died?: number;</code>
<code class="c1">// }</code>

<code class="kr">type</code> <code class="nx">RequiredWritableConservationist</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">WritableConservationist</code><code class="p">]</code><code class="o">-?:</code> <code class="nx">WritableConservationist</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   name: string;</code>
<code class="c1">//   catchphrase: string;</code>
<code class="c1">//   born: number;</code>
<code class="c1">//   died: number;</code>
<code class="c1">// }</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>RequiredWritableConservationist</code> type could alternately be written<a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="changing access control modifiers" data-startref="type-mapped-modify" id="idm45584665125536"/><a data-type="indexterm" data-primary="mapped types" data-secondary="changing access control modifiers" data-startref="mapped-modify" id="idm45584665124080"/><a data-type="indexterm" data-primary="access control modifiers, changing" data-startref="access-control-modify-change" id="idm45584665122896"/><a data-type="indexterm" data-primary="modifiers, changing" data-startref="modify-change" id="idm45584665121920"/> with <code>-readonly [K in keyof Conservationist]-?:</code> 
<span class="keep-together"><code>Conservationist[K]</code>.</span></p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Generic Mapped Types"><div class="sect2" id="idm45584665014928">
<h2>Generic Mapped Types</h2>

<p>The <a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="generic" id="type-mapped-generic"/><a data-type="indexterm" data-primary="mapped types" data-secondary="generic" id="mapped-generic"/><a data-type="indexterm" data-primary="generic mapped types" id="generic-mapped"/>full power of mapped types comes from combining them with generics, allowing a single kind of mapping to be reused across different types.
Mapped types are able to access the <code>keyof</code> any type name in their scope, including a type parameter on the mapped type itself.</p>

<p>Generic mapped types are frequently useful for representing how data morphs as it flows through an application.
For example, it may be desirable for an area of the application to be able to take in values of existing types but not be allowed to modify the data.</p>

<p>This <code>MakeReadonly</code> generic type takes in any type and creates a new version with the <code>readonly</code> modifier added to all its members:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">MakeReadonly</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">readonly</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">Species</code> <code class="p">{</code>
    <code class="nx">genus</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">ReadonlySpecies</code> <code class="o">=</code> <code class="nx">MakeReadonly</code><code class="o">&lt;</code><code class="nx">Species</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   readonly genus: string;</code>
<code class="c1">//   readonly name: string;</code>
<code class="c1">// }</code></pre>

<p>Another transform developers commonly need to represent is a function that takes in any amount of an interface and returns a fully filled-out instance of that interface.</p>

<p>The following <code>MakeOptional</code> type and <code>createGenusData</code> function allow for providing any amount of the <code>GenusData</code> interface and getting back an object with the defaults <a data-type="indexterm" data-primary="type operations" data-secondary="mapped types" data-startref="typeop-mapped" id="idm45584664981104"/>filled in:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">GenusData</code> <code class="p">{</code>
    <code class="nx">family</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">MakeOptional</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>
<code class="p">}</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   family?: string;</code>
<code class="c1">//   name?: string;</code>
<code class="c1">// }</code>

<code class="cm">/**</code>
<code class="cm"> * Spreads any {overrides} on top of default values for GenusData.</code>
<code class="cm"> */</code>
<code class="kd">function</code> <code class="nx">createGenusData</code><code class="p">(</code><code class="nx">overrides?</code>: <code class="nx">MakeOptional</code><code class="o">&lt;</code><code class="nx">GenusData</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="nx">GenusData</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">family</code><code class="o">:</code> <code class="s1">'unknown'</code><code class="p">,</code>
        <code class="nx">name</code><code class="o">:</code> <code class="s1">'unknown'</code><code class="p">,</code>
        <code class="p">...</code><code class="nx">overrides</code><code class="p">,</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Some operations done by generic mapped types are so useful that TypeScript provides utility types for them out-of-the-box.
Making all properties optional, for example, is achievable using the built-in <code>Partial&lt;T&gt;</code> type.
You can find a list of those built-in types on <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html"><em class="hyperlink">https://www.typescriptlang.org/docs/handbook/utility-types.html</em></a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conditional Types"><div class="sect1" id="idm45584665603568">
<h1>Conditional Types</h1>

<p>Mapping <a data-type="indexterm" data-primary="types" data-secondary="conditional types" data-tertiary="purpose of" id="idm45584664847472"/><a data-type="indexterm" data-primary="conditional types" data-secondary="purpose of" id="idm45584664846192"/><a data-type="indexterm" data-primary="type operations" data-secondary="conditional types" id="typeop-conditional"/>existing types to other types is nifty, but we haven’t yet added logical conditions into the type system.
Let’s do that now.</p>

<p>TypeScript’s type system is an example of a <em>logic programming language</em>.
It allows creating new constructs (types) based on logically checking previous types.
It does so with the concept of a <em>conditional type</em>: a type that resolves to one of two possible types, based on an existing type.</p>

<p>Conditional type syntax looks like ternaries:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">LeftType</code> <code class="kr">extends</code> <code class="nx">RightType</code> <code class="o">?</code> <code class="nx">IfTrue</code> : <code class="nx">IfFalse</code></pre>

<p>The logical check in a conditional type is always on whether the left type <em>extends</em>, or is assignable to, the right type.</p>

<p>The following <code>CheckStringAgainstNumber</code> conditional type checks whether <code>string extends number</code>—or in other words, whether the <code>string</code> type is assignable to the <code>number</code> type.
It’s not, so the resultant type is the “if false” case: <code>false</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: false</code>
<code class="kr">type</code> <code class="nx">CheckStringAgainstNumber</code> <code class="o">=</code> <code class="kt">string</code> <code class="kr">extends</code> <code class="kt">number</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code></pre>

<p>Much of the rest of this chapter will involve combining other type system features with conditional types.
As the code snippets get more complex, remember: each conditional type is purely a piece of boolean logic.
Each takes in some type and results in one of two possible results.</p>








<section data-type="sect2" data-pdf-bookmark="Generic Conditional Types"><div class="sect2" id="idm45584664759216">
<h2>Generic Conditional Types</h2>

<p>Conditional types<a data-type="indexterm" data-primary="types" data-secondary="conditional types" data-tertiary="generic" id="type-conditional-generic"/><a data-type="indexterm" data-primary="conditional types" data-secondary="generic" id="conditional-generic"/><a data-type="indexterm" data-primary="generic conditional types" id="generic-conditional"/> are able to check any type name in their scope, including a type parameter on the conditional type itself.
That means you can write reusable generic types to create new types based on any other types.</p>

<p>Turning the previous <code>CheckStringAgainstNumber</code> type into a generic <code>CheckAgainstNumber</code> gives a type that is either <code>true</code> or <code>false</code> based on whether the previous type is assignable to <code>number</code>.
<code>string</code> is still not true, while <code>number</code> and <code>0 | 1</code> both are:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">CheckAgainstNumber</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">number</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>

<code class="c1">// Type: false</code>
<code class="kr">type</code> <code class="nx">CheckString</code> <code class="o">=</code> <code class="nx">CheckAgainstNumber</code><code class="o">&lt;</code><code class="s1">'parakeet'</code><code class="o">&gt;</code><code class="p">;</code>

<code class="c1">// Type: true</code>
<code class="kr">type</code> <code class="nx">CheckString</code> <code class="o">=</code> <code class="nx">CheckAgainstNumber</code><code class="o">&lt;</code><code class="mi">1891</code><code class="o">&gt;</code><code class="p">;</code>

<code class="c1">// Type: true</code>
<code class="kr">type</code> <code class="nx">CheckString</code> <code class="o">=</code> <code class="nx">CheckAgainstNumber</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p>The following <code>CallableSetting</code> type is a little more useful.
It takes in a generic <code>T</code> and checks whether <code>T</code> is a function.
If <code>T</code> is, then the resultant type is <code>T</code>—as with <code>GetNumbersSetting</code> where <code>T</code> is <code>() =&gt; number[]</code>.
Otherwise, the resultant type is a function that returns <code>T</code>, as with <code>StringSetting</code> where <code>T</code> is <code>string</code>, and so the resultant type is <code>() =&gt; string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">CallableSetting</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>
    <code class="nx">T</code> <code class="kr">extends</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">any</code>
        <code class="o">?</code> <code class="nx">T</code>
        <code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">T</code>

<code class="c1">// Type: () =&gt; number[]</code>
<code class="kr">type</code> <code class="nx">GetNumbersSetting</code> <code class="o">=</code> <code class="nx">CallableSetting</code><code class="o">&lt;</code><code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>

<code class="c1">// Type: () =&gt; string</code>
<code class="kr">type</code> <code class="nx">StringSetting</code> <code class="o">=</code> <code class="nx">CallableSetting</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p>Conditional types are also able to access members of provided types with the object member lookup syntax.
They can use that information both in their <code>extends</code> clause and/or in the resultant types.</p>

<p>One pattern used by JavaScript libraries that lends itself well to conditional generic types is to change the return type of a function based on an options object provided to the function.</p>

<p>For example, many database functions or equivalents might use a property like <code>throwIfNotFound</code> to change the function to throw an error instead of returning 
<span class="keep-together"><code>undefined</code></span> if a value isn’t found.
The following <code>QueryResult</code> type models that 
<span class="keep-together">behavior</span> by resulting in the more narrow <code>string</code> instead of <code>string | undefined</code> if the options’ <code>throwIfNotFound</code> is specifically known<a data-type="indexterm" data-primary="types" data-secondary="conditional types" data-tertiary="generic" data-startref="type-conditional-generic" id="idm45584664601840"/><a data-type="indexterm" data-primary="conditional types" data-secondary="generic" data-startref="conditional-generic" id="idm45584664600320"/><a data-type="indexterm" data-primary="generic conditional types" data-startref="generic-conditional" id="idm45584664577824"/> to be <code>true</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">QueryOptions</code> <code class="p">{</code>
  <code class="nx">throwIfNotFound</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">QueryResult</code><code class="o">&lt;</code><code class="nx">Options</code> <code class="kr">extends</code> <code class="nx">QueryOptions</code><code class="o">&gt;</code> <code class="o">=</code>
  <code class="nx">Options</code><code class="p">[</code><code class="s2">"throwIfNotFound"</code><code class="p">]</code> <code class="kr">extends</code> <code class="kc">true</code> <code class="o">?</code> <code class="kt">string</code> <code class="o">:</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">;</code>

<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">retrieve</code><code class="o">&lt;</code><code class="nx">Options</code> <code class="kr">extends</code> <code class="nx">QueryOptions</code><code class="o">&gt;</code><code class="p">(</code>
    <code class="nx">key</code>: <code class="nx">string</code><code class="p">,</code>
    <code class="nx">options?</code>: <code class="nx">Options</code><code class="p">,</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">QueryResult</code><code class="o">&lt;</code><code class="nx">Options</code><code class="o">&gt;&gt;</code><code class="p">;</code>

<code class="c1">// Returned type: string | undefined</code>
<code class="kr">await</code> <code class="nx">retrieve</code><code class="p">(</code><code class="s2">"Biruté Galdikas"</code><code class="p">);</code>

<code class="c1">// Returned type: string | undefined</code>
<code class="kr">await</code> <code class="nx">retrieve</code><code class="p">(</code><code class="s2">"Jane Goodall"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">throwIfNotFound</code>: <code class="nx">Math.random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code> <code class="p">});</code>

<code class="c1">// Returned type: string</code>
<code class="kr">await</code> <code class="nx">retrieve</code><code class="p">(</code><code class="s2">"Dian Fossey"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">throwIfNotFound</code>: <code class="nx">true</code> <code class="p">});</code></pre>

<p>By combining a conditional type with a generic type parameter, that <code>retrieve</code> function is more precise in telling the type system how it will change its program’s control flow.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Type Distributivity"><div class="sect2" id="idm45584664758624">
<h2>Type Distributivity</h2>

<p>Conditional<a data-type="indexterm" data-primary="types" data-secondary="conditional types" data-tertiary="distributivity" id="idm45584664522096"/><a data-type="indexterm" data-primary="conditional types" data-secondary="distributivity" id="idm45584664520816"/><a data-type="indexterm" data-primary="unions" data-secondary="distributivity of conditional types" id="idm45584664519872"/><a data-type="indexterm" data-primary="distributivity of conditional types" id="idm45584664518960"/> types <em>distribute</em> over unions, meaning their resultant type will be a union of applying that conditional type to each of the constituents (types in the union type).
In other words, <code>ConditionalType&lt;T | U&gt;</code> is the same as <code>Conditional&lt;T&gt; | Conditional&lt;U&gt;</code>.</p>

<p>Type distributivity is a mouthful to explain but is important for how conditional types behave with unions.</p>

<p>Consider the following <code>ArrayifyUnlessString</code> type that converts its type 
<span class="keep-together">parameter <code>T</code></span> to an array unless <code>T extends string</code>.
<code>HalfArrayified</code> is equivalent to <code>string | number[]</code> because <code>ArrayifyUnlessString&lt;string | number&gt;</code> is the same as <code>ArrayifyUnlessString&lt;string&gt; | ArrayifyUnlessString&lt;number&gt;</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">ArrayifyUnlessString</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="nx">T</code> : <code class="nx">T</code><code class="p">[];</code>

<code class="c1">// Type: string | number[]</code>
<code class="kr">type</code> <code class="nx">HalfArrayified</code> <code class="o">=</code> <code class="nx">ArrayifyUnlessString</code><code class="o">&lt;</code><code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p class="less_space pagebreak-before">If TypeScript’s conditional types didn’t distribute across unions, <code>HalfArrayified</code> would be <code>(string | number)[]</code> because <code>string | number</code> is not assignable to <code>string</code>.
In other words, conditional types apply their logic to each constituent of a union type, not the whole union type.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Inferred Types"><div class="sect2" id="idm45584664415296">
<h2>Inferred Types</h2>

<p>Accessing <a data-type="indexterm" data-primary="types" data-secondary="conditional types" data-tertiary="inferred" id="types-conditional-infer"/><a data-type="indexterm" data-primary="conditional types" data-secondary="inferred" id="conditional-infer"/><a data-type="indexterm" data-primary="inferred types" id="infer-type"/>members of provided types works well for information stored as a member of a type, but it can’t capture other information such as function parameters or return types.
Conditional types are able to access arbitrary portions of their condition by using an <code>infer</code> keyword within their extends clause.
Placing the <code>infer</code> keyword and a new name for a type within an extends clause means that new type will be available inside the conditional type’s true case.</p>

<p>This <code>ArrayItems</code> type takes in a type parameter <code>T</code> and checks whether the <code>T</code> is an array of some new <code>Item</code> type.
If it is, the resultant type is <code>Item</code>; if not, it’s <code>T</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">ArrayItems</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>
    <code class="nx">T</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">infer</code> <code class="nx">Item</code><code class="p">)[]</code>
        <code class="o">?</code> <code class="nx">Item</code>
        : <code class="nx">T</code><code class="p">;</code>

<code class="c1">// Type: string</code>
<code class="kr">type</code> <code class="nx">StringItem</code> <code class="o">=</code> <code class="nx">ArrayItems</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>

<code class="c1">// Type: string</code>
<code class="kr">type</code> <code class="nx">StringArrayItem</code> <code class="o">=</code> <code class="nx">ArrayItems</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>

<code class="c1">// Type: string[]</code>
<code class="kr">type</code> <code class="nx">String2DItem</code> <code class="o">=</code> <code class="nx">ArrayItems</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[][]</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p>Inferred types can work to create recursive conditional types too.
The <code>ArrayItems</code> type seen previously could be extended to retrieve the item type of an array of any dimensionality recursively:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">ArrayItemsRecursive</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>
    <code class="nx">T</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">infer</code> <code class="nx">Item</code><code class="p">)[]</code>
        <code class="o">?</code> <code class="nx">ArrayItemsRecursive</code><code class="o">&lt;</code><code class="nx">Item</code><code class="o">&gt;</code>
        <code class="o">:</code> <code class="nx">T</code><code class="p">;</code>

<code class="c1">// Type: string</code>
<code class="kr">type</code> <code class="nx">StringItem</code> <code class="o">=</code> <code class="nx">ArrayItemsRecursive</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>

<code class="c1">// Type: string</code>
<code class="kr">type</code> <code class="nx">StringArrayItem</code> <code class="o">=</code> <code class="nx">ArrayItemsRecursive</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>

<code class="c1">// Type: string</code>
<code class="kr">type</code> <code class="nx">String2DItem</code> <code class="o">=</code> <code class="nx">ArrayItemsRecursive</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[][]</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p>Note that while <code>ArrayItems&lt;string[][]&gt;</code> resulted in <code>string[]</code>, <code>ArrayItemsRecursive&lt;string[][]&gt;</code> resulted in <code>string</code>.
That ability for generic types to be recursive allows them to keep applying modifications—such as retrieving the element type of an array here.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Mapped Conditional Types"><div class="sect2" id="idm45584664249360">
<h2>Mapped Conditional Types</h2>

<p>Mapped types <a data-type="indexterm" data-primary="types" data-secondary="conditional types" data-tertiary="mapped types and" id="idm45584664247824"/><a data-type="indexterm" data-primary="conditional types" data-secondary="mapped types and" id="idm45584664246544"/><a data-type="indexterm" data-primary="mapped types" data-secondary="conditional types and" id="idm45584664245600"/><a data-type="indexterm" data-primary="type operations" data-secondary="conditional types" data-startref="typeop-conditional" id="idm45584664244656"/>apply a change to every member of an existing type.
Conditional types apply a change to a single existing type.
Put together, they allow for applying conditional logic to each member of a generic template type.</p>

<p>This <code>MakeAllMembersFunctions</code> type turns each nonfunction member of a type into a function:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">MakeAllMembersFunctions</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">any</code>
        <code class="o">?</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code>
        <code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">MemberFunctions</code> <code class="o">=</code> <code class="nx">MakeAllMembersFunctions</code><code class="o">&lt;</code><code class="p">{</code>
    <code class="nx">alreadyFunction</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">,</code>
    <code class="nx">notYetFunction</code>: <code class="nx">number</code><code class="p">,</code>
<code class="p">}</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c1">// Type:</code>
<code class="c1">// {</code>
<code class="c1">//   alreadyFunction: () =&gt; string,</code>
<code class="c1">//   notYetFunction: () =&gt; number,</code>
<code class="c1">// }</code></pre>

<p>Mapped conditional types are a convenient way to modify all properties of an existing type using some logical check.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="never"><div class="sect1" id="idm45584664848576">
<h1>never</h1>

<p>In <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.xhtml#objects">Chapter 4, “Objects”</a>, I <a data-type="indexterm" data-primary="types" data-secondary="never" data-tertiary="purpose of" id="idm45584664120112"/><a data-type="indexterm" data-primary="never type" data-secondary="purpose of" id="idm45584664118832"/><a data-type="indexterm" data-primary="type operations" data-secondary="never type" id="typeop-never"/>introduced the <code>never</code> type, a bottom type, which means it can have no possible values and can’t be reached.
Adding a <code>never</code> type annotation in the right place can tell TypeScript to be more aggressive about detecting never-hit code paths in the type system as well as in the previous examples of runtime code.</p>








<section data-type="sect2" data-pdf-bookmark="never and Intersections and Unions"><div class="sect2" id="idm45584664115600">
<h2>never and Intersections and Unions</h2>

<p>Another way <a data-type="indexterm" data-primary="types" data-secondary="never" data-tertiary="intersections and unions" id="idm45584664092144"/><a data-type="indexterm" data-primary="never type" data-secondary="intersections and unions" id="idm45584664091056"/><a data-type="indexterm" data-primary="intersection types" data-secondary="never type and" id="idm45584664090208"/><a data-type="indexterm" data-primary="unions" data-secondary="never type and" id="idm45584664089296"/>of describing the <code>never</code> bottom type is that it’s a type that can’t exist.
That gives <code>never</code> some interesting behaviors with <code>&amp;</code> intersection and <code>|</code> union types:</p>

<ul>
<li>
<p><code>never</code> in an <code>&amp;</code> intersection type reduces the intersection type to just <code>never</code>.</p>
</li>
<li>
<p><code>never</code> in a <code>|</code> union type is ignored.</p>
</li>
</ul>

<p class="less_space pagebreak-before">These <code>NeverIntersection</code> and <code>NeverUnion</code> types illustrate those behaviors:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">NeverIntersection</code> <code class="o">=</code> <code class="nx">never</code> <code class="o">&amp;</code> <code class="kt">string</code><code class="p">;</code> <code class="c1">// Type: never</code>
<code class="kr">type</code> <code class="nx">NeverUnion</code> <code class="o">=</code> <code class="nx">never</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code> <code class="c1">// Type: string</code></pre>

<p>In particular, the behavior of being ignored in union types makes <code>never</code> useful for filtering out values from conditional and mapped types.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="never and Conditional Types"><div class="sect2" id="idm45584664064928">
<h2>never and Conditional Types</h2>

<p>Generic <a data-type="indexterm" data-primary="types" data-secondary="never" data-tertiary="conditional types and" id="idm45584664063344"/><a data-type="indexterm" data-primary="never type" data-secondary="conditional types and" id="idm45584664062064"/><a data-type="indexterm" data-primary="conditional types" data-secondary="never type and" id="idm45584664059040"/><a data-type="indexterm" data-primary="types" data-secondary="conditional types" data-tertiary="never type and" id="idm45584664058096"/>conditional types commonly use <code>never</code> to filter out types from unions.
Because <code>never</code> is ignored in unions, the result of a generic conditional on a union of types will only be those that are not <code>never</code>.</p>

<p>This <code>OnlyStrings</code> generic conditional type filters out types that aren’t strings, so the <code>RedOrBlue</code> type filters out <code>0</code> and <code>null</code> from the union:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">OnlyStrings</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="nx">T</code> : <code class="nx">never</code><code class="p">;</code>

<code class="kr">type</code> <code class="nx">RedOrBlue</code> <code class="o">=</code> <code class="nx">OnlyStrings</code><code class="o">&lt;</code><code class="s2">"red"</code> <code class="o">|</code> <code class="s2">"blue"</code> <code class="o">|</code> <code class="mi">0</code> <code class="o">|</code> <code class="kc">false</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c1">// Equivalent to: "red" | "blue"</code></pre>

<p><code>never</code> is also commonly combined with inferred conditional types when making type utilities for generic types.
Type inferences with <code>infer</code> have to be in the true case of a conditional type, so if the false case is never meant to be used, <code>never</code> is a suitable type to put there.</p>

<p>This <code>FirstParameter</code> type takes in a function type <code>T</code>, checks if it’s a function with an <code>arg: infer Arg</code>, and returns that <code>Arg</code> if so:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">FirstParameter</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="o">&gt;</code> <code class="o">=</code>
    <code class="nx">T</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">arg</code>: <code class="nx">infer</code> <code class="nx">Arg</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code>
        <code class="o">?</code> <code class="nx">Arg</code>
        : <code class="nx">never</code><code class="p">;</code>

<code class="kr">type</code> <code class="nx">GetsString</code> <code class="o">=</code> <code class="nx">FirstParameter</code><code class="o">&lt;</code>
    <code class="p">(</code><code class="nx">arg0</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>
<code class="o">&gt;</code><code class="p">;</code> <code class="c1">// Type: string</code></pre>

<p>Using <code>never</code> in the false case of the conditional type allowed <code>FirstParameter</code> to extract the type of the function’s first parameter.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="never and Mapped Types"><div class="sect2" id="idm45584663945584">
<h2>never and Mapped Types</h2>

<p>The <code>never</code> behavior<a data-type="indexterm" data-primary="types" data-secondary="never" data-tertiary="mapped types and" id="idm45584663943632"/><a data-type="indexterm" data-primary="never type" data-secondary="mapped types and" id="idm45584663942352"/><a data-type="indexterm" data-primary="mapped types" data-secondary="never type and" id="idm45584663941408"/><a data-type="indexterm" data-primary="types" data-secondary="mapped types" data-tertiary="never type and" id="idm45584663940464"/> in unions makes it useful for filtering out members in mapped types too.
It’s possible to filter out keys of an object using the following three type system features:</p>

<ul class="less_space pagebreak-before">
<li>
<p><code>never</code> is ignored in unions.</p>
</li>
<li>
<p>Mapped types can map members of types.</p>
</li>
<li>
<p>Conditional types can be used to turn types into <code>never</code> if a condition is met.</p>
</li>
</ul>

<p>Putting the three of those together, we can create a mapped type that changes each member of the original type either to the original key or to <code>never</code>.
Asking for the members of that type with <code>[keyof T]</code>, then, produces a union of all those mapped type results, filtering out <code>never</code>.</p>

<p>The following <code>OnlyStringProperties</code> type turns each <code>T[K]</code> member into either the <code>K</code> key if that member is a string, or <code>never</code> if <a data-type="indexterm" data-primary="type operations" data-secondary="never type" data-startref="typeop-never" id="idm45584663878832"/>not:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">OnlyStringProperties</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="nx">K</code> : <code class="nx">never</code><code class="p">;</code>
<code class="p">}[</code><code class="nx">keyof</code> <code class="nx">T</code><code class="p">];</code>

<code class="kr">interface</code> <code class="nx">AllEventData</code> <code class="p">{</code>
    <code class="nx">participants</code>: <code class="nx">string</code><code class="p">[];</code>
    <code class="nx">location</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">year</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">OnlyStringEventData</code> <code class="o">=</code> <code class="nx">OnlyStringProperties</code><code class="o">&lt;</code><code class="nx">AllEventData</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c1">// Equivalent to: "location" | "name"</code></pre>

<p>Another way of reading the <code>OnlyStringProperties&lt;T&gt;</code> type is that it filters out all non-<code>string</code> properties (switches them to <code>never</code>), then gives back all the remaining keys (<code>[keyof T]</code>).</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Template Literal Types"><div class="sect1" id="idm45584663829984">
<h1>Template Literal Types</h1>

<p>We’ve covered a lot on conditional and/or mapped types now.
Let’s switch to less logic-intensive types and focus on strings for a while instead.
So far<a data-type="indexterm" data-primary="types" data-secondary="template literal types" data-tertiary="purpose of" id="type-template-purpose"/><a data-type="indexterm" data-primary="strings, template literal types" data-secondary="purpose of" id="string-template-purpose"/><a data-type="indexterm" data-primary="template literal types" data-secondary="purpose of" id="template-purpose"/><a data-type="indexterm" data-primary="type operations" data-secondary="template literal types" id="typeop-template"/> I’ve brought up two strategies for typing string values:</p>

<ul>
<li>
<p>The primitive <code>string</code> type: for when the value can be any string in the world</p>
</li>
<li>
<p>Literal types such as <code>""</code> and <code>"abc"</code>: for when the value can only be that one type (or a union of them)</p>
</li>
</ul>

<p>Sometimes, however, you may want to indicate that a string matches some string pattern: part of the string is known, but part of it is not.
Enter <em>template literal types</em>, a TypeScript syntax for indicating that a string type adheres to a pattern.
They look like template literal strings—hence their name—but with primitive types or unions of primitive types interpolated.</p>

<p>This template literal type indicates that the string must start with <code>"Hello"</code> but can end with any string (<code>string</code>).
Names that start with <code>"Hello"</code> such as <code>"Hello, world!"</code> match, but not <code>"World! Hello!"</code> or <code>"hi"</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Greeting</code> <code class="o">=</code> <code class="sb">`Hello</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>

<code class="kd">let</code> <code class="nx">matches</code>: <code class="nx">Greeting</code> <code class="o">=</code> <code class="s2">"Hello, world!"</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kd">let</code> <code class="nx">outOfOrder</code>: <code class="nx">Greeting</code> <code class="o">=</code> <code class="s2">"World! Hello!"</code><code class="p">;</code>
<code class="c1">//  ~~~~~~~~~~</code>
<code class="c1">// Error: Type '"World! Hello!"' is not assignable to type '`Hello ${string}`'.</code>

<code class="kd">let</code> <code class="nx">missingAltogether</code>: <code class="nx">Greeting</code> <code class="o">=</code> <code class="s2">"hi"</code><code class="p">;</code>
<code class="c1">//  ~~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Type '"hi"' is not assignable to type '`Hello ${string}`'.</code></pre>

<p>String literal types—and unions of them—may be used in the type interpolation instead of the catchall <code>string</code> primitive to restrict template literal types to more narrow patterns of strings.
Template literal types can be quite useful for describing strings that must match a restricted set of allowed strings.</p>

<p>Here, <code>BrightnessAndColor</code> matches only strings that start with a <code>Brightness</code>, end with a <code>Color</code>, and have a <code>-</code> hyphen in-between:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Brightness</code> <code class="o">=</code> <code class="s2">"dark"</code> <code class="o">|</code> <code class="s2">"light"</code><code class="p">;</code>
<code class="kr">type</code> <code class="nx">Color</code> <code class="o">=</code>  <code class="s2">"blue"</code> <code class="o">|</code> <code class="s2">"red"</code><code class="p">;</code>

<code class="kr">type</code> <code class="nx">BrightnessAndColor</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Brightness</code><code class="si">}</code><code class="sb">-</code><code class="si">${</code><code class="nx">Color</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
<code class="c1">// Equivalent to: "dark-red" | "light-red" | "dark-blue" | "light-blue"</code>

<code class="kd">let</code> <code class="nx">colorOk</code>: <code class="nx">BrightnessAndColor</code> <code class="o">=</code> <code class="s2">"dark-blue"</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kd">let</code> <code class="nx">colorWrongStart</code>: <code class="nx">BrightnessAndColor</code> <code class="o">=</code> <code class="s2">"medium-blue"</code><code class="p">;</code>
<code class="c1">//  ~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Type '"medium-blue"' is not assignable to type</code>
<code class="c1">// '"dark-blue" | "dark-red" | "light-blue" | "light-red"'.</code>

<code class="kd">let</code> <code class="nx">colorWrongEnd</code>: <code class="nx">BrightnessAndColor</code> <code class="o">=</code> <code class="s2">"light-green"</code><code class="p">;</code>
<code class="c1">//  ~~~~~~~~~~~~~</code>
<code class="c1">// Error: Type '"light-green"' is not assignable to type</code>
<code class="c1">// '"dark-blue" | "dark-red" | "light-blue" | "light-red"'.</code></pre>

<p>Without template literal types, we would have had to laboriously write out all four combinations of <code>Brightness</code> and <code>Color</code>.
That would get cumbersome if we added more string literals to either of them!</p>

<p>TypeScript allows template literal types to contain any primitives (other than <code>symbol</code>) or a union thereof: <code>string</code>, <code>number</code>, <code>bigint</code>, <code>boolean</code>, <code>null</code>, or <code>undefined</code>.</p>

<p class="less_space pagebreak-before">This <code>ExtolNumber</code> type allows any string that starts with <code>"much "</code>, includes a string that looks like a number, and ends <a data-type="indexterm" data-primary="types" data-secondary="template literal types" data-tertiary="purpose of" data-startref="type-template-purpose" id="idm45584663652960"/><a data-type="indexterm" data-primary="strings, template literal types" data-secondary="purpose of" data-startref="string-template-purpose" id="idm45584663602896"/><a data-type="indexterm" data-primary="template literal types" data-secondary="purpose of" data-startref="template-purpose" id="idm45584663601808"/>with <code>"wow"</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">ExtolNumber</code> <code class="o">=</code> <code class="sb">`much </code><code class="si">${</code><code class="kt">number</code><code class="si">}</code><code class="sb"> wow`</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">extol</code><code class="p">(</code><code class="nx">extolee</code>: <code class="nx">ExtolNumber</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>

<code class="nx">extol</code><code class="p">(</code><code class="s1">'much 0 wow'</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">extol</code><code class="p">(</code><code class="s1">'much -7 wow'</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">extol</code><code class="p">(</code><code class="s1">'much 9.001 wow'</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">extol</code><code class="p">(</code><code class="s1">'much false wow'</code><code class="p">);</code>
<code class="c1">//    ~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type '"much false wow"' is not</code>
<code class="c1">// assignable to parameter of type '`much ${number} wow`'.</code></pre>








<section data-type="sect2" data-pdf-bookmark="Intrinsic String Manipulation Types"><div class="sect2" id="idm45584663587280">
<h2>Intrinsic String Manipulation Types</h2>

<p>To assist <a data-type="indexterm" data-primary="types" data-secondary="template literal types" data-tertiary="intrinsic types" id="idm45584663578192"/><a data-type="indexterm" data-primary="strings, template literal types" data-secondary="intrinsic types" id="idm45584663576944"/><a data-type="indexterm" data-primary="template literal types" data-secondary="intrinsic types" id="idm45584663576032"/><a data-type="indexterm" data-primary="intrinsic string types" id="idm45584663575088"/>in working with string types, TypeScript provides a small set of intrinsic (meaning: they’re built into TypeScript) generic utility types that take in a string and apply some operation to the string.
As of TypeScript 4.7.2, there are four:</p>

<ul>
<li>
<p><code>Uppercase</code>: Converts a string literal type to uppercase.</p>
</li>
<li>
<p><code>Lowercase</code>: Converts a string literal type to lowercase.</p>
</li>
<li>
<p><code>Capitalize</code>: Converts a first character of string literal type to uppercase.</p>
</li>
<li>
<p><code>Uncapitalize</code>: Converts a first character of string literal type to lowercase.</p>
</li>
</ul>

<p>Each of these can be used as a generic type that takes in a string.
For example, using <code>Capitalize</code> to capitalize the first letter in a string:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">FormalGreeting</code> <code class="o">=</code> <code class="nx">Capitalize</code><code class="o">&lt;</code><code class="s2">"hello."</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// Type: "Hello."</code></pre>

<p>These intrinsic string manipulation types can be quite useful for manipulating property keys on object types.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Template Literal Keys"><div class="sect2" id="idm45584663511504">
<h2>Template Literal Keys</h2>

<p>Template<a data-type="indexterm" data-primary="types" data-secondary="template literal types" data-tertiary="template literal keys" id="idm45584663510336"/><a data-type="indexterm" data-primary="strings, template literal types" data-secondary="template literal keys" id="idm45584663509056"/><a data-type="indexterm" data-primary="template literal keys" id="idm45584663508144"/> literal types are a half-way point between the primitive <code>string</code> and string literals, which means they’re still strings.
They can be used in any other place where you’d be able to use string literals.</p>

<p>For example, you can use them as the index signature in a mapped type.
This 
<span class="keep-together"><code>ExistenceChecks</code></span> type has a key for every string in <code>DataKey</code>, mapped with 
<span class="keep-together"><code>check${Capitalize&lt;DataKey&gt;}</code>:</span></p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">type</code> <code class="nx">DataKey</code> <code class="o">=</code> <code class="s2">"location"</code> <code class="o">|</code> <code class="s2">"name"</code> <code class="o">|</code> <code class="s2">"year"</code><code class="p">;</code>

<code class="kr">type</code> <code class="nx">ExistenceChecks</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="sb">`check</code><code class="si">${</code><code class="nx">Capitalize</code><code class="o">&lt;</code><code class="nx">DataKey</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">`</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kr">boolean</code><code class="p">;</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   checkLocation: () =&gt; boolean;</code>
<code class="c1">//   checkName: () =&gt; boolean;</code>
<code class="c1">//   checkYear: () =&gt; boolean;</code>
<code class="c1">// }</code>

<code class="kd">function</code> <code class="nx">checkExistence</code><code class="p">(</code><code class="nx">checks</code>: <code class="nx">ExistenceChecks</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">checks</code><code class="p">.</code><code class="nx">checkLocation</code><code class="p">();</code> <code class="c1">// Type: boolean</code>
    <code class="nx">checks</code><code class="p">.</code><code class="nx">checkName</code><code class="p">();</code> <code class="c1">// Type: boolean</code>

    <code class="nx">checks</code><code class="p">.</code><code class="nx">checkWrong</code><code class="p">();</code>
    <code class="c1">//     ~~~~~~~~~~</code>
    <code class="c1">// Error: Property 'checkWrong' does not exist on type 'ExistenceChecks'.</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Remapping Mapped Type Keys"><div class="sect2" id="idm45584663403360">
<h2>Remapping Mapped Type Keys</h2>

<p>TypeScript <a data-type="indexterm" data-primary="types" data-secondary="template literal types" data-tertiary="remapping mapped type keys" id="types-template-remap"/><a data-type="indexterm" data-primary="strings, template literal types" data-secondary="remapping mapped type keys" id="strings-template-remap"/><a data-type="indexterm" data-primary="template literal types" data-secondary="remapping mapped type keys" id="template-remap"/><a data-type="indexterm" data-primary="mapped types" data-secondary="remapping keys" id="mapped-remap"/><a data-type="indexterm" data-primary="remapping mapped type keys" id="remap-keys"/>allows you to create new keys for members of mapped types based on the original members using template literal types.
Placing the <code>as</code> keyword followed by a template literal type for the index signature in a mapped typed changes the resultant type’s keys to match the template literal type.
Doing so allows the mapped type to have a different key for each mapped property while still referring to the original value.</p>

<p>Here, <code>DataEntryGetters</code> is a mapped type whose keys are <code>getLocation</code>, <code>getName</code>, and <code>getYear</code>.
Each key is mapped to a new key with a template literal type.
Each mapped value is a function whose return type is a <code>DataEntry</code> using the original <code>K</code> key as a type argument:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">DataEntry</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">T</code><code class="p">;</code>
    <code class="nx">value</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">DataKey</code> <code class="o">=</code> <code class="s2">"location"</code> <code class="o">|</code> <code class="s2">"name"</code> <code class="o">|</code> <code class="s2">"year"</code><code class="p">;</code>

<code class="kr">type</code> <code class="nx">DataEntryGetters</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">DataKey</code> <code class="kr">as</code> <code class="sb">`get</code><code class="si">${</code><code class="nx">Capitalize</code><code class="o">&lt;</code><code class="nx">K</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">`</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">DataEntry</code><code class="o">&lt;</code><code class="nx">K</code><code class="o">&gt;</code><code class="p">;</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   getLocation: () =&gt; DataEntry&lt;"location"&gt;;</code>
<code class="c1">//   getName: () =&gt; DataEntry&lt;"name"&gt;;</code>
<code class="c1">//   getYear: () =&gt; DataEntry&lt;"year"&gt;;</code>
<code class="c1">// }</code></pre>

<p>Key remappings can be combined with other type operations to create mapped types that are based on existing type shapes.
One fun combination is using <code>keyof typeof</code> on an existing object to make a mapped type off that object’s type.</p>

<p>This <code>ConfigGetter</code> type is based on the <code>config</code> type, but each field is a function that returns the original config, and the keys are modified from the original key:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">config</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">location</code><code class="o">:</code> <code class="s2">"unknown"</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"anonymous"</code><code class="p">,</code>
    <code class="nx">year</code>: <code class="nx">0</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">LazyValues</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="k">typeof</code> <code class="nx">config</code> <code class="kr">as</code> <code class="sb">`</code><code class="si">${</code><code class="nx">K</code><code class="si">}</code><code class="sb">Lazy`</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">config</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>
<code class="p">};</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   location: Promise&lt;string&gt;;</code>
<code class="c1">//   name: Promise&lt;string&gt;;</code>
<code class="c1">//   year: Promise&lt;number&gt;;</code>
<code class="c1">// }</code>

<code class="kr">async</code> <code class="kd">function</code> <code class="nx">withLazyValues</code><code class="p">(</code><code class="nx">configGetter</code>: <code class="nx">LazyValues</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">await</code> <code class="nx">configGetter</code><code class="p">.</code><code class="nx">locationLazy</code><code class="p">;</code> <code class="c1">// Resultant type: string</code>

    <code class="kr">await</code> <code class="nx">configGetter</code><code class="p">.</code><code class="nx">missingLazy</code><code class="p">();</code>
    <code class="c1">//                 ~~~~~~~~~~~</code>
    <code class="c1">// Error: Property 'missingLazy' does not exist on type 'LazyValues'.</code>
<code class="p">};</code></pre>

<p>Note that in JavaScript, object keys may be type <code>string</code> or <code>Symbol</code>—and <code>Symbol</code> keys aren’t usable as template literal types because they’re not primitives.
If you try to use a remapped template literal type key in a generic type, TypeScript will issue a complaint that <code>symbol</code> can’t be used in a template literal type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">TurnIntoGettersDirect</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">T</code> <code class="kr">as</code> <code class="sb">`get</code><code class="si">${</code><code class="nx">K</code><code class="si">}</code><code class="sb">`</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code>
    <code class="c1">//                     ~</code>
    <code class="c1">// Error: Type 'keyof T' is not assignable to type</code>
    <code class="c1">// 'string | number | bigint | boolean | null | undefined'.</code>
    <code class="c1">//   Type 'string | number | symbol' is not assignable to type</code>
    <code class="c1">//   'string | number | bigint | boolean | null | undefined'.</code>
    <code class="c1">//     Type 'symbol' is not assignable to type</code>
    <code class="c1">//     'string | number | bigint | boolean | null | undefined'.</code>
<code class="p">};</code></pre>

<p>To get around that restriction, you can use a <code>string &amp;</code> intersection type to enforce that only types that can be strings are used.
Because <code>string &amp; symbol</code> results in <code>never</code>, the whole template string will reduce to <code>never</code> and TypeScript will <a data-type="indexterm" data-primary="types" data-secondary="template literal types" data-tertiary="remapping mapped type keys" data-startref="types-template-remap" id="idm45584663138208"/><a data-type="indexterm" data-primary="strings, template literal types" data-secondary="remapping mapped type keys" data-startref="strings-template-remap" id="idm45584663122880"/><a data-type="indexterm" data-primary="template literal types" data-secondary="remapping mapped type keys" data-startref="template-remap" id="idm45584663121728"/><a data-type="indexterm" data-primary="mapped types" data-secondary="remapping keys" data-startref="mapped-remap" id="idm45584663120544"/><a data-type="indexterm" data-primary="remapping mapped type keys" data-startref="remap-keys" id="idm45584663119328"/><a data-type="indexterm" data-primary="type operations" data-secondary="template literal types" data-startref="typeop-template" id="idm45584663118416"/>ignore it:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">someSymbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>

<code class="kr">interface</code> <code class="nx">HasStringAndSymbol</code> <code class="p">{</code>
    <code class="nx">StringKey</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="p">[</code><code class="nx">someSymbol</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">type</code> <code class="nx">TurnIntoGetters</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">keyof</code> <code class="nx">T</code> <code class="kr">as</code> <code class="sb">`get</code><code class="si">${</code><code class="kt">string</code> <code class="o">&amp;</code> <code class="nx">K</code><code class="si">}</code><code class="sb">`</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">GettersJustString</code> <code class="o">=</code> <code class="nx">TurnIntoGetters</code><code class="o">&lt;</code><code class="nx">HasStringAndSymbol</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//     getStringKey: () =&gt; string;</code>
<code class="c1">// }</code></pre>

<p>TypeScript’s behavior of filtering out <code>never</code> types from unions is proving itself useful yet again!</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Operations and Complexity"><div class="sect1" id="idm45584663829488">
<h1>Type Operations and Complexity</h1>
<blockquote>
<p>Debugging <a data-type="indexterm" data-primary="Kernighan, Brian" id="idm45584663028784"/>is twice as hard as writing the code in the first place.
Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.</p>
<p data-type="attribution">Brian Kernighan</p>
</blockquote>

<p>The <a data-type="indexterm" data-primary="type operations" data-secondary="complexity of" id="idm45584663026496"/>type operations described in this chapter are among the most powerful, cutting-edge type system features in any programming language today.
Most developers are not yet familiar enough with them to be able to debug errors in significantly complex uses of them.
Industry-standard development tools such as IDE features I cover in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch12.xhtml#using_ide_features">Chapter 12, “Using IDE Features”</a> aren’t generally made for visualizing multilayered type operations used with each other.</p>

<p>If you do find a need to use type operations, please—for the sake of any developer who has to read your code, including a future you—try to keep them to a minimum if possible.
Use readable names that help readers understand the code as they read it.
Leave descriptive comments for anything you think future readers might struggle with.</p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584662965808">
<h1>Summary</h1>

<p>In this chapter, you unlocked the true power of TypeScript by operating on types in its type system:</p>

<ul>
<li>
<p>Using mapped types to transform existing types into new ones</p>
</li>
<li>
<p>Introducing logic into type operations with conditional types</p>
</li>
<li>
<p>Learning how <code>never</code> interacts with intersections, unions, conditional types, and mapped types</p>
</li>
<li>
<p>Representing patterns of string types using template literal types</p>
</li>
<li>
<p>Combining template literal types and mapped types to modify type keys</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/type-operations"><em class="hyperlink">https://learningtypescript.com/type-operations</em></a>.</p>
</div>
<blockquote class="joke">
<p>When you’re lost in the type system, what do you use?</p>

<p>A mapped type!</p></blockquote>
</div></section>







</div></section></div></body></html>