<html><head></head><body><section data-pdf-bookmark="Chapter 3. The Virtual DOM" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch03">&#13;
<h1><span class="label">Chapter 3. </span>The Virtual DOM</h1>&#13;
&#13;
&#13;
<p>In this chapter, we’ll dive deep into the concept of virtual DOM<a data-primary="virtual DOM (vDOM)" data-type="indexterm" id="ix_virtualDOMvDOM.03.3.65"/>,&#13;
sometimes called vDOM, and its significance in React. We’ll also explore&#13;
how React uses the virtual DOM to make web development easier and more&#13;
efficient.</p>&#13;
&#13;
<p>As web applications become more complex, it becomes increasingly&#13;
difficult to manage the “real DOM,” which is a complex and error-prone&#13;
process as we’ll see soon enough, and as we crudely covered in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>. React’s virtual DOM provides a solution to this problem.</p>&#13;
&#13;
<p>Throughout this chapter, we’ll explore the workings of React’s virtual&#13;
DOM, its advantages over the real DOM, and how it is implemented. We’ll&#13;
also cover how React optimizes performance around the real DOM using the&#13;
virtual DOM and how it all fits together.</p>&#13;
&#13;
<p>Through a series of code examples and detailed explanations, we’ll&#13;
understand the virtual DOM’s role in React and how to take advantage of&#13;
its benefits to create robust and efficient web applications. Let’s get&#13;
started!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Intro to the Virtual DOM" data-type="sect1"><div class="sect1" id="id33">&#13;
<h1>An Intro to the Virtual DOM</h1>&#13;
&#13;
<p>The virtual DOM, like the DOM, is an HTML document modeled as a&#13;
JavaScript object: this is literally what Document Object Model (DOM)&#13;
means. The <a data-primary="Document Object Model (DOM)" data-seealso="virtual DOM" data-type="indexterm" id="id503"/>DOM itself is the browser runtime’s model of the document.&#13;
The virtual DOM is a lightweight copy of this, with the key difference&#13;
that while the real DOM is made up of <code>Node</code> objects<a data-primary="Node objects, DOM" data-type="indexterm" id="id504"/><a data-primary="Document Object Model (DOM)" data-secondary="Node objects" data-type="indexterm" id="id505"/>, the virtual DOM is&#13;
made up of plain JS<a data-primary="JS objects, virtual DOM" data-type="indexterm" id="id506"/> objects that act as descriptions. It allows web&#13;
developers to create user interfaces in a more efficient and performant&#13;
way, as we’ll discover in this chapter.</p>&#13;
&#13;
<p>In React, whenever we tell it to make a change to the UI via&#13;
<code>setState</code> or some other mechanism, the virtual DOM is updated first,&#13;
and then the real DOM is updated to match the changes in the virtual&#13;
DOM. This process is called <em>reconciliation</em>, the subject of <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>.</p>&#13;
&#13;
<p>The reason for updating the virtual DOM first is that updates to the&#13;
real DOM can be somewhat slow and expensive<a data-primary="Document Object Model (DOM)" data-secondary="performance pitfalls" data-type="indexterm" id="id507"/><a data-primary="performance" data-secondary="DOM pitfalls" data-type="indexterm" id="id508"/>. We’ll cover this in the&#13;
next section, but the gist of it is that every time a change is made to the&#13;
real DOM, the browser has to recalculate the layout of the page, repaint&#13;
the screen, and perform other operations that can be time-consuming.</p>&#13;
&#13;
<p>For example, just reading an <a data-primary="offsetWidth property, DOM versus virtual DOM" data-type="indexterm" id="id509"/><a data-primary="Document Object Model (DOM)" data-secondary="versus virtual DOM" data-secondary-sortas="virtual DOM" data-type="indexterm" id="id510"/><a data-primary="virtual DOM (vDOM)" data-secondary="versus real DOM" data-secondary-sortas="real DOM" data-type="indexterm" id="id511"/>element’s <code>offsetWidth</code> can trigger a&#13;
reflow, which is a process where the browser recalculates the layout of&#13;
all or part of the document, potentially affecting performance and&#13;
making direct DOM interactions less efficient:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">btn</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"myButton"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">width</code> <code class="o">=</code> <code class="nx">btn</code><code class="p">.</code><code class="nx">offsetWidth</code><code class="p">;</code> <code class="c1">// This can trigger a reflow</code></pre>&#13;
&#13;
<p>On the other hand, updating the virtual DOM is much faster because it&#13;
doesn’t involve any changes to the actual page layout. Instead, it is a&#13;
simple JavaScript object that can be manipulated quickly and efficiently&#13;
through various algorithmic approaches that can make the best use of the&#13;
JavaScript engine available and increase its efficiency over time,&#13;
decoupled from the browsers and other host environments.</p>&#13;
&#13;
<p>When updates are made to the virtual DOM<a data-primary="virtual DOM (vDOM)" data-secondary="efficient updates" data-type="indexterm" id="id512"/><a data-primary="efficient updates, virtual DOM" data-type="indexterm" id="id513"/><a data-primary="updates" data-secondary="efficient" data-type="indexterm" id="id514"/>, React uses a diffing algorithm<a data-primary="diffing algorithm" data-type="indexterm" id="id515"/>&#13;
to identify the differences between the old and new versions of the&#13;
virtual DOM. This algorithm then determines the minimal set of changes&#13;
required to update the real DOM, and these changes are applied in a&#13;
batched and optimized way to minimize the performance impact.</p>&#13;
&#13;
<p>In this chapter, we will explore the differences between the virtual DOM&#13;
and the real DOM, the pitfalls of the real DOM, and how the virtual DOM&#13;
helps create better user interfaces. We will also dive into React’s&#13;
implementation of the virtual DOM and the algorithms it uses for&#13;
efficient updates.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Real DOM" data-type="sect1"><div class="sect1" id="id34">&#13;
<h1>The Real DOM</h1>&#13;
&#13;
<p>When an HTML page is loaded into a web browser, it is parsed and&#13;
converted into a tree of nodes and objects—an <em>object model</em>—which is&#13;
the DOM: just a big JavaScript<a data-primary="JavaScript" data-secondary="DOM as object in" data-type="indexterm" id="id516"/> object. The DOM<a data-primary="Document Object Model (DOM)" data-type="indexterm" id="ix_DocumentObjectModelDOM.03.78.47"/> is a live representation&#13;
of the web page, meaning that it is constantly being updated as users&#13;
interact with the page.</p>&#13;
&#13;
<p>Here is an example of the real DOM for a simple HTML page:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>Example Page<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">h1</code> <code class="na">class</code><code class="o">=</code><code class="s">"heading"</code><code class="p">&gt;</code>Welcome to my page!<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>This is an example paragraph.<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 1<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 2<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 3<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In this example, the real DOM is represented by a <a data-primary="tree of HTML elements" data-type="indexterm" id="ix_treeofHTMLelements.03.103.51"/><a data-primary="HTML" data-secondary="tree of elements in DOM" data-type="indexterm" id="ix_HTMLtreeofelementsinDOM.03.103.51"/><a data-primary="elements" data-secondary="tree of HTML elements" data-type="indexterm" id="ix_elementstreeofHTMLelements.03.103.51"/>tree-like structure&#13;
that consists of nodes for each HTML element in the page. This is what&#13;
the tree structure could look like, though it’s oversimplified for the&#13;
purposes of understanding. The actual DOM has far more properties and&#13;
methods per node. Still, this should help us understand how a document&#13;
is modeled as an object:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">dom</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s2">"document"</code><code class="p">,</code>&#13;
  <code class="nx">doctype</code><code class="o">:</code> <code class="s2">"html"</code><code class="p">,</code>&#13;
  <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
      <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"html"</code><code class="p">,</code>&#13;
      <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
        <code class="p">{</code>&#13;
          <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
          <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"head"</code><code class="p">,</code>&#13;
          <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
            <code class="p">{</code>&#13;
              <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
              <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"title"</code><code class="p">,</code>&#13;
              <code class="nx">children</code><code class="o">:</code> <code class="s2">"Example Page"</code><code class="p">,</code>&#13;
            <code class="p">},</code>&#13;
          <code class="p">],</code>&#13;
        <code class="p">},</code>&#13;
        <code class="p">{</code>&#13;
          <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
          <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"body"</code><code class="p">,</code>&#13;
          <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
            <code class="p">{</code>&#13;
              <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
              <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"h1"</code><code class="p">,</code>&#13;
              <code class="nx">innerHTML</code><code class="o">:</code> <code class="s2">"Welcome to my page!"</code><code class="p">,</code>&#13;
              <code class="nx">children</code><code class="o">:</code> <code class="p">[],</code>&#13;
              <code class="nx">className</code><code class="o">:</code> <code class="s2">"heading"</code><code class="p">,</code>&#13;
            <code class="p">},</code>&#13;
            <code class="p">{</code>&#13;
              <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
              <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"p"</code><code class="p">,</code>&#13;
              <code class="nx">children</code><code class="o">:</code> <code class="s2">"This is an example paragraph."</code><code class="p">,</code>&#13;
            <code class="p">},</code>&#13;
            <code class="p">{</code>&#13;
              <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
              <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"ul"</code><code class="p">,</code>&#13;
              <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
                <code class="p">{</code>&#13;
                  <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
                  <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"li"</code><code class="p">,</code>&#13;
                  <code class="nx">children</code><code class="o">:</code> <code class="s2">"Item 1"</code><code class="p">,</code>&#13;
                <code class="p">},</code>&#13;
                <code class="p">{</code>&#13;
                  <code class="nx">type</code><code class="o">:</code> <code class="s2">"element"</code><code class="p">,</code>&#13;
                  <code class="nx">tagName</code><code class="o">:</code> <code class="s2">"li"</code><code class="p">,</code>&#13;
                  <code class="nx">children</code><code class="o">:</code> <code class="s2">"Item 2"</code><code class="p">,</code>&#13;
                <code class="p">},</code>&#13;
                <code class="c1">// ...you can fill in the rest</code>&#13;
              <code class="p">],</code>&#13;
            <code class="p">},</code>&#13;
          <code class="p">],</code>&#13;
        <code class="p">},</code>&#13;
      <code class="p">],</code>&#13;
    <code class="p">},</code>&#13;
  <code class="p">],</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Each node in the tree represents an HTML element, and it contains&#13;
properties and methods that allow it to be manipulated through&#13;
JavaScript. For example, we can use the <code>document.querySelector()</code>&#13;
method to retrieve a specific node from the real DOM and modify its&#13;
contents:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Retrieve the &lt;h1&gt; node</code>&#13;
<code class="kr">const</code> <code class="nx">h1Node</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">".heading"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Modify its contents</code>&#13;
<code class="k">if</code> <code class="p">(</code><code class="nx">h1Node</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">h1Node</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="s2">"Updated Heading!"</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">h1Node</code><code class="p">);</code></pre>&#13;
&#13;
<p>In this example, we retrieve the <code>h1</code> element with the <code>class</code> of&#13;
<code>"heading"</code> using the <code>document.querySelector()</code> method. We then modify&#13;
the contents of the element by setting its <code>innerHTML</code> property to&#13;
<code>"Updated Heading!"</code>. This changes the text displayed on the page from&#13;
<code>"Welcome to my page!"</code> to <code>"Updated Heading!"</code>.</p>&#13;
&#13;
<p>That doesn’t seem too complicated, but there are a few things to note&#13;
here. First, we are using the <code>document.querySelector()</code> method<a data-primary="document.querySelector() method" data-type="indexterm" id="id517"/> to&#13;
retrieve the element from the real DOM. This method accepts a CSS&#13;
selector as an argument and returns the first element that matches the&#13;
selector<a data-startref="ix_treeofHTMLelements.03.103.51" data-type="indexterm" id="id518"/><a data-startref="ix_HTMLtreeofelementsinDOM.03.103.51" data-type="indexterm" id="id519"/><a data-startref="ix_elementstreeofHTMLelements.03.103.51" data-type="indexterm" id="id520"/>. In this case, we are passing in the class selector <code>.heading</code>,&#13;
which matches the <code>h1</code> element with the <code>class</code> of <code>"heading"</code>.</p>&#13;
&#13;
<p>There’s a bit of a danger here, because while the&#13;
<code>document.querySelector</code> method is a powerful tool for selecting&#13;
elements in the real DOM based on CSS selectors, one potential&#13;
performance issue with this method is that it can be slow when working&#13;
with large and complex documents. The method has to start at the&#13;
top of the document and traverse downward to find the desired element,&#13;
which can be a time-consuming process.</p>&#13;
&#13;
<p>When we call <code>document.querySelector()</code> with a CSS selector, the browser&#13;
has to search the entire document tree for matching elements. This means&#13;
that the search can be slow, especially if the document is large and has&#13;
a complex structure. In addition, the browser has to evaluate the&#13;
selector itself, which can be a complex process, depending on the&#13;
complexity of the selector.</p>&#13;
&#13;
<p>In contrast<a data-primary="document.getElementById method" data-type="indexterm" id="id521"/>, <code>document.getElementById</code> does not require validation like&#13;
CSS selectors, and has increased specificity since <code>id</code> attributes are&#13;
expected to be unique, so it is generally more efficient.</p>&#13;
&#13;
<p>In terms of runtime complexity using Big O notation, <code>getElementById</code> is&#13;
often approximated as (O(1)) in modern browsers, given that they likely&#13;
employ hashing mechanisms, such as hash tables, for efficient ID→element&#13;
mapping. While ideal hash table lookups are (O(1)) on average, it’s&#13;
important to consider that worst-case scenarios, like hash collisions,&#13;
can lead to longer lookups. Given that browsers don’t really enforce ID&#13;
uniqueness, these hash collisions can be more than likely.</p>&#13;
&#13;
<p>Nevertheless, with advanced hashing functions and resizing strategies in&#13;
modern browsers, these cases are rare.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For those of us who didn’t go to computer school and maybe don’t&#13;
understand Big O<a data-primary="Big O notation" data-type="indexterm" id="id522"/>, it’s a handy tool used by developers to gauge how fast&#13;
or slow a piece of code will run, especially as the amount of data the&#13;
code has to work with increases. Essentially, Big O notation gives a&#13;
high-level understanding of algorithms in terms of both time complexity&#13;
(how the execution time grows with the size of the input) and space&#13;
complexity (how the amount of memory used grows with the size of the&#13;
input). It’s often expressed using terms like (O(1)), (O(n)), (O(n n)), or (O(n²) ), where (n) is the size of the input. So&#13;
when developers talk about code being “efficient” or&#13;
“scalable,” they’re often referring to these Big O values, aiming for&#13;
algorithms with lower time and space complexity to ensure that their&#13;
software remains performant even as it handles more and more data.</p>&#13;
</div>&#13;
&#13;
<p>Also, since IDs are supposed to be unique, they’re not really well&#13;
suited to having multiple reusable components on a page. This is where&#13;
<code>querySelector</code> shines<a data-primary="document.querySelector() method" data-type="indexterm" id="id523"/>, as it can be used to select multiple elements&#13;
with the same class name, for example.</p>&#13;
&#13;
<p>That said, <code>querySelector</code>, which can accept a broad range of CSS&#13;
selectors, has a variable complexity. In the worst-case scenario, where&#13;
the method may need to &#13;
<span class="keep-together">traverse</span> the entire DOM to ensure a match or the&#13;
absence thereof, its complexity can be (O(n)), where (n) is the number&#13;
of elements in the DOM. However, the actual &#13;
<span class="keep-together">runtime</span> can be less than&#13;
(O(n)) for more specific selectors or if a match is found early in the&#13;
DOM tree. That said, there’s still the added computational cost of&#13;
parsing and &#13;
<span class="keep-together">validating</span> the selectors themselves.</p>&#13;
&#13;
<p>It’s worth noting that the performance difference<a data-primary="document.getElementById method" data-type="indexterm" id="id524"/> between&#13;
<code>document.getElementById</code> and <code>document.querySelector</code> may be negligible&#13;
in small documents or when searching for elements in specific areas of&#13;
the document tree. However, in larger and more complex documents, the&#13;
difference can become more pronounced.</p>&#13;
&#13;
<p>Some would say that this whole “CPU efficiency” argument<a data-primary="virtual DOM (vDOM)" data-secondary="efficient updates" data-type="indexterm" id="id525"/><a data-primary="efficient updates, virtual DOM" data-type="indexterm" id="id526"/><a data-primary="updates" data-secondary="efficient" data-type="indexterm" id="id527"/> is overblown,&#13;
and that it’s not worth worrying about. While this may or may not be&#13;
true, no one can question the additional value that React’s virtual DOM&#13;
provides with being able to componentize logic and avoid worrying&#13;
about managing state in an environment as volatile as the DOM<a data-primary="Document Object Model (DOM)" data-secondary="volatility of" data-type="indexterm" id="id528"/>. We say&#13;
the DOM is volatile because it is affected by so many things, including&#13;
user interactions, network requests, client-side scripts, and other&#13;
events that can cause it to change at any time. React, through the&#13;
virtual DOM, protects us from this environment using the virtual DOM.</p>&#13;
&#13;
<p>We’re diving deep into these nuanced details because to be truly fluent with React, it’s important to understand the overall&#13;
complexity of the DOM. Working intelligently with the DOM is no small&#13;
feat, and with React, we have a choice to either navigate this minefield&#13;
ourselves and occasionally step on landmines, or to use a tool that&#13;
helps us navigate the DOM safely using the virtual DOM.</p>&#13;
&#13;
<p>While we’ve discussed some small nuances in how we select elements here,&#13;
we haven’t had an opportunity to dive deeper into the pitfalls of&#13;
working with the DOM directly. Let’s do this quickly to fully understand&#13;
the value that React’s virtual DOM provides.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pitfalls of the Real DOM" data-type="sect2"><div class="sect2" id="id35">&#13;
<h2>Pitfalls of the Real DOM</h2>&#13;
&#13;
<p>The real DOM has several pitfalls that can make it difficult to build a&#13;
high-performance web application. Some of these pitfalls include&#13;
performance issues, cross-browser compatibility, and security&#13;
vulnerabilities, where manipulating the DOM directly could present&#13;
cross-site scripting (XSS)<a data-primary="cross-site scripting (XSS)" data-type="indexterm" id="id529"/><a data-primary="XSS (cross-site scripting)" data-type="indexterm" id="id530"/> vulnerabilities.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance" data-type="sect3"><div class="sect3" id="id36">&#13;
<h3>Performance</h3>&#13;
&#13;
<p>One of the biggest issues with the real DOM is its performance<a data-primary="Document Object Model (DOM)" data-secondary="performance pitfalls" data-type="indexterm" id="ix_DocumentObjectModelDOMperformancepitfalls.03.304.63"/><a data-primary="performance" data-secondary="DOM pitfalls" data-type="indexterm" id="ix_performanceDOMpitfalls.03.304.63"/>. Whenever&#13;
a change is made to the DOM, such as adding or removing an element, or&#13;
changing the text or attributes of an element, the browser has to&#13;
recalculate the layout and repaint the affected parts of the page. This&#13;
can be a slow and resource-intensive process, especially for large and&#13;
complex web pages.</p>&#13;
&#13;
<p>As mentioned earlier, reading a DOM element’s <code>offsetWidth</code> property may&#13;
seem like a simple operation, but it can actually trigger a costly&#13;
recalculation of the layout by the browser. This is because&#13;
<code>offsetWidth</code> is a computed property that depends on the layout of the&#13;
element and its ancestors, which means that the browser needs to ensure&#13;
that the layout information is up-to-date before it can return an&#13;
accurate value.</p>&#13;
&#13;
<p>In the worst-case scenario, reading an element’s <code>offsetWidth</code> property&#13;
with Big O notation would be estimated as (O(n)). This is because&#13;
accessing this property can potentially trigger a reflow in the browser,&#13;
which involves recalculating layout positions for a number of elements&#13;
on the page. In this context, (n) represents the number of DOM elements&#13;
affected by the reflow. Even though the direct property access is quick,&#13;
the associated side effects, like a reflow, can make the operation scale&#13;
with the number of elements on the page.</p>&#13;
&#13;
<p>If you’re looking to avoid the potential reflow triggered by accessing&#13;
layout properties like <code>offsetWidth</code>, we can employ certain techniques&#13;
to make the operation more performant. Here’s one approach using the&#13;
<code>getBoundingClientRect()</code> method<a data-primary="getBoundingClientRect() method" data-type="indexterm" id="ix_getBoundingClientRecmethod.03.331.33"/>, which can batch layout reads and&#13;
writes:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Accessing layout properties in a more performant way</code>&#13;
<code class="kd">function</code> <code class="nx">getOffsetWidthWithoutTriggeringReflow</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">width</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// Batch all reading operations</code>&#13;
  <code class="kr">const</code> <code class="nx">rect</code> <code class="o">=</code> <code class="nx">element</code><code class="p">.</code><code class="nx">getBoundingClientRect</code><code class="p">();</code>&#13;
  <code class="nx">width</code> <code class="o">=</code> <code class="nx">rect</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// ... any other reading operations</code>&#13;
&#13;
  <code class="c1">// Followed by writing operations, if any</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">width</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">element</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">".myElement"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">width</code> <code class="o">=</code> <code class="nx">getOffsetWidthWithoutTriggeringReflow</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">width</code><code class="p">);</code></pre>&#13;
&#13;
<p>By using <code>getBoundingClientRect()</code>, we retrieve multiple layout&#13;
properties in a single call, reducing the chances of triggering multiple&#13;
reflows. Additionally, by batching reading and writing operations&#13;
separately, we can further minimize <em>layout thrashing</em>, which is the&#13;
repeated and unnecessary recalculations of layout caused by frequent&#13;
interleaved reading and writing of layout properties (see <a data-type="xref" href="#figure3-1">Figure 3-1</a>). This thrashing can&#13;
significantly degrade the performance of a web page, leading to a&#13;
sluggish user experience. By strategically accessing layout properties&#13;
and batching our operations, we can keep our web interactions smooth and&#13;
responsive.</p>&#13;
&#13;
<figure><div class="figure" id="figure3-1">&#13;
<img alt="layout thrashing" src="assets/frea_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>Layout thrashing</h6>&#13;
</div></figure>&#13;
&#13;
<p>However, even <code>getBoundingClientRect()</code> can cause a reflow if there are&#13;
pending layout changes. The key to performance here is to minimize the&#13;
number of times you force the browser to recalculate layout, and when&#13;
you do, try to retrieve as much information as you need in one go<a data-startref="ix_getBoundingClientRecmethod.03.331.33" data-type="indexterm" id="id531"/>.</p>&#13;
&#13;
<p>React handles all of this for us out of the box using the virtual DOM<a data-primary="virtual DOM (vDOM)" data-secondary="versus real DOM" data-secondary-sortas="real DOM" data-type="indexterm" id="id532"/><a data-primary="Document Object Model (DOM)" data-secondary="versus virtual DOM" data-secondary-sortas="virtual DOM" data-type="indexterm" id="id533"/> as&#13;
an intermediate layer between real DOM operations.</p>&#13;
&#13;
<p>Consider the following example, where we have a simple HTML document&#13;
with a single <code>div</code> element:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>Reading offsetWidth example<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">style</code><code class="p">&gt;</code>&#13;
      <code class="nf">#my-div</code> <code class="p">{</code>&#13;
        <code class="k">width</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
        <code class="k">height</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
        <code class="k">background-color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;</code>&#13;
      <code class="p">}</code>&#13;
    <code class="nt">&lt;/style&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">div</code> <code class="na">id</code><code class="o">=</code><code class="s">"my-div"</code><code class="p">&gt;&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="kd">var</code><code class="w"> </code><code class="nx">div</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"my-div"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">div</code><code class="p">.</code><code class="nx">offsetWidth</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>When we load this document in a browser and open the developer console,&#13;
we can see that the <code>offsetWidth</code> property of the <code>div</code> element is&#13;
logged to the console. However, what we don’t see is the&#13;
behind-the-scenes work that the browser has to do to compute the value&#13;
of <code>offsetWidth</code>.</p>&#13;
&#13;
<p>To understand this work, we can use the Performance panel in our&#13;
developer tools to record a timeline of the browser’s activities as it&#13;
loads and renders the page. When we do that, we can see that the browser&#13;
is performing several layout and paint operations as it processes the&#13;
document. In particular, we can see that there are two layout operations&#13;
that correspond to reading <code>offsetWidth</code> in the script.</p>&#13;
&#13;
<p>Each of these layout operations takes some time to complete (in this&#13;
case, about 2 ms), even though they are just reading the value of a&#13;
property. This is because the browser needs to ensure that the layout&#13;
information is up-to-date before it can return an accurate value, which&#13;
requires it to perform a full layout of the document. Although 2 milliseconds might&#13;
not seem like a big deal, at scale it adds up.</p>&#13;
&#13;
<p>In general, we should be careful when reading layout-dependent&#13;
properties like <code>offsetWidth</code>, because they can cause unexpected&#13;
performance problems. If we need to read the value of such properties&#13;
multiple times, we should consider caching the value in a variable to&#13;
avoid triggering unnecessary layout recalculations. Alternatively, we&#13;
can use the <code>requestAnimationFrame</code> API<a data-primary="requestAnimationFrame API" data-type="indexterm" id="id534"/> to defer the reading of the&#13;
property until the next animation frame, when the browser has already&#13;
performed the necessary layout calculations.</p>&#13;
&#13;
<p>To understand more about accidental performance issues with the real&#13;
DOM, let’s take a look at some examples. Consider the following HTML&#13;
document:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>Example<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">ul</code> <code class="na">id</code><code class="o">=</code><code class="s">"list"</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 1<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 2<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 3<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Suppose we want to add a new item to the list using JavaScript. We might&#13;
write the following code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"list"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">newItem</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"li"</code><code class="p">);</code>&#13;
<code class="nx">newItem</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s2">"Item 4"</code><code class="p">;</code>&#13;
<code class="nx">list</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">newItem</code><code class="p">);</code></pre>&#13;
&#13;
<p>Notice we’re <a data-primary="document.getElementById method" data-type="indexterm" id="id535"/>using <code>getElementById</code> instead of <code>querySelector</code> here&#13;
because:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We know the ID</p>&#13;
</li>&#13;
<li>&#13;
<p>We know the performance trade-offs</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s keep going.</p>&#13;
&#13;
<p>This code selects the <code>ul</code> element with the ID <code>"list"</code>, creates a new&#13;
<code>li</code> element, sets its text content to <code>"Item 4"</code>, and appends it to the&#13;
list. When we run this code, the browser has to recalculate the layout&#13;
and repaint the affected parts of the page to display the new item.</p>&#13;
&#13;
<p>This process can be slow and resource intensive, especially for larger&#13;
lists. For example, suppose we have a list with 1,000 items, and we want&#13;
to add a new item to the end of the list. We might write the following&#13;
code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"list"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">newItem</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"li"</code><code class="p">);</code>&#13;
<code class="nx">newItem</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s2">"Item 1001"</code><code class="p">;</code>&#13;
<code class="nx">list</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">newItem</code><code class="p">);</code></pre>&#13;
&#13;
<p>When we run this code, the browser has to recalculate the layout and&#13;
repaint the entire list, even though only one item has been added. This&#13;
can take a significant amount of time and resources, especially on&#13;
slower devices or with larger lists.</p>&#13;
&#13;
<p>To further illustrate this issue, consider the following example:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>Example<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">style</code><code class="p">&gt;</code>&#13;
      <code class="nf">#list</code> <code class="nt">li</code> <code class="p">{</code>&#13;
        <code class="k">background-color</code><code class="o">:</code> <code class="m">#f5f5f5</code><code class="p">;</code>&#13;
      <code class="p">}</code>&#13;
      <code class="nc">.highlight</code> <code class="p">{</code>&#13;
        <code class="k">background-color</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;</code>&#13;
      <code class="p">}</code>&#13;
    <code class="nt">&lt;/style&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">ul</code> <code class="na">id</code><code class="o">=</code><code class="s">"list"</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 1<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 2<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Item 3<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">button</code> <code class="na">onclick</code><code class="o">=</code><code class="s">"highlight()"</code><code class="p">&gt;</code>Highlight Item 2<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="kd">function</code><code class="w"> </code><code class="nx">highlight</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="kd">const</code><code class="w"> </code><code class="nx">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"#list li:nth-child(2)"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">item</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"highlight"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In this example, we have a list with three items and a button that&#13;
highlights the second item when clicked. When the button is clicked, the&#13;
browser has to recalculate the layout and repaint the entire list, even&#13;
though only one item has changed. This can cause a noticeable delay or&#13;
flicker in the UI, which can be frustrating for users.</p>&#13;
&#13;
<p>Overall, the performance issues of the real DOM can be a significant&#13;
challenge for us, especially when dealing with large and complex web&#13;
pages. While there are techniques for mitigating these issues, such as&#13;
optimizing selectors, using event delegation, batching read/write DOM&#13;
operations, or using CSS animations, they can be complex and difficult&#13;
to implement.</p>&#13;
&#13;
<p>As a result, many of us have turned to the virtual DOM as a solution to&#13;
these issues. The virtual DOM allows us to create UIs that are more&#13;
efficient and performant by abstracting away the complexities of the&#13;
real DOM and providing a more lightweight way of representing the UI.</p>&#13;
&#13;
<p>But…is it really necessary to save a few milliseconds? Well,&#13;
CPU/processing performance is a critical factor that can greatly impact&#13;
the success of an application. In today’s digital age, where users&#13;
expect fast and responsive websites, it’s essential for us web&#13;
developers to prioritize CPU efficiency to ensure that our applications&#13;
run smoothly and responsively. An excellent article titled <a href="https://oreil.ly/BtXCh">“Milliseconds make millions”</a> on the Google web develpment blog adds&#13;
further credibility to these claims.</p>&#13;
&#13;
<p>Direct DOM manipulation that triggers layout recalculation (called&#13;
reflows)<a data-primary="layout recalculation, DOM versus virtual DOM" data-type="indexterm" id="id536"/><a data-primary="reflows, DOM versus virtual DOM" data-type="indexterm" id="id537"/> and repaints can lead to increased CPU usage and processing&#13;
times, which can cause delays and even crashes for users. This can be&#13;
particularly problematic for users on low-powered devices, such as&#13;
smartphones or tablets, which may have limited processing power and&#13;
memory. In many parts of the world, users may be accessing our web apps&#13;
on older or less capable devices, which can further compound the&#13;
problem.</p>&#13;
&#13;
<p>By prioritizing CPU efficiency<a data-primary="virtual DOM (vDOM)" data-secondary="efficient updates" data-type="indexterm" id="id538"/><a data-primary="efficient updates, virtual DOM" data-type="indexterm" id="id539"/><a data-primary="updates" data-secondary="efficient" data-type="indexterm" id="id540"/>, we can create applications that are&#13;
accessible to users on a wide range of devices, regardless of their&#13;
processing power or memory. This can lead to increased engagement,&#13;
higher conversion rates, and ultimately, a more successful online&#13;
presence.</p>&#13;
&#13;
<p>React’s virtual DOM has enabled building CPU-efficient web applications;&#13;
using its efficient rendering algorithms can help minimize processing&#13;
times and improve overall performance<a data-startref="ix_DocumentObjectModelDOMperformancepitfalls.03.304.63" data-type="indexterm" id="id541"/><a data-startref="ix_performanceDOMpitfalls.03.304.63" data-type="indexterm" id="id542"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cross-browser compatibility" data-type="sect3"><div class="sect3" id="id37">&#13;
<h3>Cross-browser compatibility</h3>&#13;
&#13;
<p>Another issue with the real DOM is cross-browser compatibility<a data-primary="cross-browser compatibility, DOM" data-type="indexterm" id="ix_crossbrowsercompatibilityDOM.03.579.63"/><a data-primary="Document Object Model (DOM)" data-secondary="cross-browser compatibility pitfall" data-type="indexterm" id="ix_DocumentObjectModelDOMcrossbrowsercompatibilitypitfall.03.579.63"/><a data-primary="browsers" data-secondary="cross-browser compatibility" data-type="indexterm" id="ix_browserscrossbrowsercompatibility.03.579.63"/>.&#13;
Different browsers model documents differently, which can lead to&#13;
inconsistencies and bugs in web applications. This was far more common&#13;
when React was released and is far less common now. Still,&#13;
this can and did make it difficult for developers to create web&#13;
applications that work seamlessly across different browsers and&#13;
platforms.</p>&#13;
&#13;
<p>One of the primary issues with cross-browser compatibility is that&#13;
certain DOM elements and attributes may not be supported by all&#13;
browsers. As a result, we had to spend additional time and&#13;
effort implementing workarounds and fallbacks to ensure that applications function correctly on all target platforms.</p>&#13;
&#13;
<p>This is exactly what React solves using its synthetic event system.&#13;
<code>SyntheticEvent</code> is a wrapper<a data-primary="SyntheticEvent wrapper" data-type="indexterm" id="ix_SyntheticEventwrapper.03.593.38"/> around browsers’ native events,&#13;
designed to ensure consistency across different browsers. It addresses&#13;
inconsistencies between browsers using the following mechanisms:</p>&#13;
<dl>&#13;
<dt>Unified interface</dt>&#13;
<dd>&#13;
<p>In raw JavaScript, handling browser events can be&#13;
tricky due to inconsistencies. For instance, accessing event properties&#13;
might differ across browsers. Some might use <code>event.target</code>, while&#13;
others use <code>event.srcElement</code>. <code>SyntheticEvent</code> abstracts these&#13;
differences, providing a consistent way to interact with events and&#13;
ensuring that developers don’t have to write browser-specific code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Without React, developers might need checks for</code>&#13;
<code class="c1">// browser-specific properties</code>&#13;
<code class="kr">const</code> <code class="nx">targetElement</code> <code class="o">=</code> <code class="nx">event</code><code class="p">.</code><code class="nx">target</code> <code class="o">||</code> <code class="nx">event</code><code class="p">.</code><code class="nx">srcElement</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// In React, thanks to SyntheticEvent, it's consistent</code>&#13;
<code class="kd">function</code> <code class="nx">handleClick</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">;</code>&#13;
  <code class="c1">// ... rest of the code</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>By wrapping native events into the <code>SyntheticEvent</code> system, React&#13;
shields developers from many of the inconsistencies and quirks of the&#13;
native browser event systems.</p>&#13;
</dd>&#13;
<dt>Event delegation</dt>&#13;
<dd>&#13;
<p>Instead of attaching event listeners<a data-primary="event listeners" data-type="indexterm" id="id543"/><a data-primary="event delegation (event bubbling)" data-type="indexterm" id="id544"/> directly to&#13;
elements, React listens for events at the root level. This approach&#13;
sidesteps issues where some events might not be available on certain&#13;
elements in older browsers.</p>&#13;
</dd>&#13;
<dt>Cross-functional enhancements</dt>&#13;
<dd>&#13;
<p>One of the areas where native browser&#13;
events exhibit inconsistencies is in how they handle certain events&#13;
across different input elements. A notable example<a data-primary="onChange event" data-type="indexterm" id="id545"/> is the <code>onChange</code>&#13;
event:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>In raw JavaScript, the behavior of the <code>onChange</code> event differs&#13;
between input types:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>For <code>&lt;input type="text"&gt;</code>, the <code>onChange</code> event in some browsers&#13;
might trigger only after the input loses focus, rather than immediately&#13;
upon value change.</p>&#13;
</li>&#13;
<li>&#13;
<p>For <code>&lt;select&gt;</code>, it might trigger whenever an option is selected, even&#13;
if it’s the same as the previous one.</p>&#13;
</li>&#13;
<li>&#13;
<p>In other cases, especially in older browsers, the <code>onChange</code> event&#13;
might not trigger reliably for all user interactions on certain form&#13;
elements.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>React’s <code>SyntheticEvent</code> system normalizes the behavior of the&#13;
<code>onChange</code> event across these input elements. In React:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>onChange</code> event for a text input (<code>&lt;input type="text"&gt;</code>)&#13;
consistently fires with every keystroke, giving real-time feedback.</p>&#13;
</li>&#13;
<li>&#13;
<p>For <code>&lt;select&gt;</code>, it reliably triggers whenever a new option is chosen.</p>&#13;
</li>&#13;
<li>&#13;
<p>React ensures that <code>onChange</code> provides a consistent experience across&#13;
other form elements as well.</p>&#13;
&#13;
<p>By doing so, React frees developers from dealing with these native&#13;
inconsistencies, allowing them to focus on their application logic&#13;
without worrying about browser-specific quirks.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
</dd>&#13;
<dt>Access to native events</dt>&#13;
<dd>&#13;
<p>If developers need the original browser&#13;
event, it’s available via <code>event.native​Event</code>, ensuring <a data-primary="event.nativeEvent" data-type="indexterm" id="id546"/><a data-primary="native events" data-type="indexterm" id="id547"/>flexibility&#13;
without sacrificing the benefits of the abstraction.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In essence, <code>SyntheticEvent</code> offers a stable event system, ironing out&#13;
the quirks and differences of native browser events. This is just one&#13;
specific way that React uses its virtual DOM to provide conveniences to&#13;
UI development<a data-startref="ix_SyntheticEventwrapper.03.593.38" data-type="indexterm" id="id548"/>.</p>&#13;
&#13;
<p>So far, we’ve been discussing how working with the DOM directly can&#13;
cause performance issues and cross-browser compatibility problems. Let’s&#13;
now explore a way to natively get around these issues in a more&#13;
performant manner using document &#13;
<span class="keep-together">fragments,</span> which can be considered&#13;
something of a native precursor to understanding React’s virtual DOM<a data-startref="ix_crossbrowsercompatibilityDOM.03.579.63" data-type="indexterm" id="id549"/><a data-startref="ix_DocumentObjectModelDOMcrossbrowsercompatibilitypitfall.03.579.63" data-type="indexterm" id="id550"/><a data-startref="ix_browserscrossbrowsercompatibility.03.579.63" data-type="indexterm" id="id551"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Document Fragments" data-type="sect2"><div class="sect2" id="id38">&#13;
<h2>Document Fragments</h2>&#13;
&#13;
<p>As we’ve seen, direct manipulation of the DOM&#13;
can be performance intensive, especially when multiple changes are&#13;
involved. Every time the DOM is updated, the browser may need to perform&#13;
layout recalculations, repaint the UI, and update the view, which can&#13;
slow down the application. This is where document fragments<a data-primary="document fragments" data-type="indexterm" id="ix_documentfragments.03.674.60"/><a data-primary="Document Object Model (DOM)" data-secondary="document fragments" data-type="indexterm" id="ix_DocumentObjectModelDOMdocumentfragments.03.674.60"/> come into&#13;
play.</p>&#13;
&#13;
<p>A <em>document fragment</em> is a lightweight container that holds DOM nodes. It&#13;
acts like a temporary staging area where you can make multiple changes&#13;
without affecting the main DOM. Once you’re done, you can append the&#13;
document fragment to the DOM, triggering a single reflow and repaint.&#13;
Document fragments are very close to React’s virtual DOM in this way.</p>&#13;
&#13;
<p>Because document fragments are lightweight containers that allow us to&#13;
batch updates<a data-primary="batched updates" data-secondary="document fragments" data-type="indexterm" id="id552"/><a data-primary="updates" data-secondary="batching" data-type="indexterm" id="id553"/>, they present a number of performance benefits:</p>&#13;
<dl>&#13;
<dt>Batched updates</dt>&#13;
<dd>&#13;
<p>Instead of making multiple individual updates to&#13;
the live DOM, you can batch all your changes in a document fragment.&#13;
This means only one reflow and repaint occurs, regardless of how many&#13;
elements or changes you’ve made inside the &#13;
<span class="keep-together">fragment.</span></p>&#13;
</dd>&#13;
<dt>Memory efficiency</dt>&#13;
<dd>&#13;
<p>When nodes<a data-primary="memory efficiency, document fragments" data-type="indexterm" id="id554"/> are added to a document fragment,&#13;
they’re removed from their current parent in the DOM. This can help in&#13;
optimizing memory usage, especially when reordering large sections of a&#13;
document.</p>&#13;
</dd>&#13;
<dt>No redundant rendering</dt>&#13;
<dd>&#13;
<p>Since the document fragment is not part of&#13;
the active document tree, changes to it don’t affect the live document,&#13;
and styles and scripts aren’t applied until the fragment is appended to&#13;
the actual DOM. This avoids redundant<a data-primary="redundant rendering, avoiding with document fragments" data-type="indexterm" id="id555"/><a data-primary="rendering" data-secondary="avoiding redundancy with document fragments" data-type="indexterm" id="id556"/> style recalculations and script&#13;
executions.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Consider a scenario where you need to add multiple list items to a list:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">fragment</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createDocumentFragment</code><code class="p">();</code>&#13;
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">100</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">li</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"li"</code><code class="p">);</code>&#13;
  <code class="nx">li</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="sb">`Item </code><code class="si">${</code><code class="nx">i</code> <code class="o">+</code> <code class="mi">1</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
  <code class="nx">fragment</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">li</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
<code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"myList"</code><code class="p">).</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">fragment</code><code class="p">);</code></pre>&#13;
&#13;
<p>In this example, the 100 list items are first appended to the document&#13;
fragment. Only when all items are added does the fragment get appended&#13;
to the main list. This results in a single update to the live DOM&#13;
instead of 100 separate updates.</p>&#13;
&#13;
<p>In this way, document fragments offer a way to efficiently manipulate&#13;
the DOM by batching multiple changes together, thus reducing the number&#13;
of costly reflows and repaints. For developers aiming for optimal&#13;
performance in their web applications, leveraging document fragments can&#13;
lead to smoother interactions and faster render times.</p>&#13;
&#13;
<p>React’s virtual DOM<a data-primary="virtual DOM (vDOM)" data-secondary="implementations similar to document fragments" data-type="indexterm" id="id557"/> can be likened to an advanced implementation of the&#13;
document fragment concept. Here’s a brief connection:</p>&#13;
<dl>&#13;
<dt>Batched updates</dt>&#13;
<dd>&#13;
<p>Similar to document fragments<a data-primary="batched updates" data-secondary="virtual DOM" data-type="indexterm" id="id558"/><a data-primary="updates" data-secondary="batching" data-type="indexterm" id="id559"/>, React’s virtual DOM&#13;
batches multiple changes together. Instead of directly altering the live&#13;
DOM on every state or prop change, React compiles these changes in the&#13;
virtual DOM first.</p>&#13;
</dd>&#13;
<dt>Efficient diffs</dt>&#13;
<dd>&#13;
<p>React then determines the differences<a data-primary="efficient diffs, virtual DOM" data-type="indexterm" id="id560"/> (or&#13;
“diffs”) between the current virtual DOM and the real DOM. This&#13;
diffing process ensures that only the necessary changes are made to the&#13;
real DOM, analogous to how document fragments reduce direct DOM&#13;
manipulations.</p>&#13;
</dd>&#13;
<dt>Single render</dt>&#13;
<dd>&#13;
<p>Once the diffs<a data-primary="rendering" data-secondary="virtual DOM’s single render" data-type="indexterm" id="id561"/> are identified, React updates the&#13;
actual DOM in a single batch, much like appending a fully populated&#13;
document fragment. This minimizes costly reflows and repaints.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In essence, while document fragments offer a way to group and optimize a&#13;
set of changes before updating the live DOM, React’s virtual DOM takes&#13;
this a step further by intelligently diffing and batching updates across&#13;
the entire application’s UI, ensuring maximal efficiency in rendering.&#13;
Moreover, React turns all of this document fragment stuff into an&#13;
implementation detail that we as everyday developers need not concern&#13;
ourselves with, enabling us to build our products with more focus. With&#13;
that, let’s look at how the virtual DOM works in detail<a data-startref="ix_DocumentObjectModelDOM.03.78.47" data-type="indexterm" id="id562"/><a data-startref="ix_documentfragments.03.674.60" data-type="indexterm" id="id563"/><a data-startref="ix_DocumentObjectModelDOMdocumentfragments.03.674.60" data-type="indexterm" id="id564"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How the Virtual DOM Works" data-type="sect1"><div class="sect1" id="id39">&#13;
<h1>How the Virtual DOM Works</h1>&#13;
&#13;
<p>The virtual DOM<a data-primary="virtual DOM (vDOM)" data-secondary="workings of" data-type="indexterm" id="ix_virtualDOMvDOMworkingsof.03.759.16"/> is a technique that helps to mitigate the pitfalls of&#13;
the real DOM. By creating a virtual representation of the DOM in memory,&#13;
changes can be made to the virtual representation without directly&#13;
modifying the real DOM, similar to document fragments. This allows the&#13;
framework or library to update the real DOM in a more efficient and&#13;
performant way, without causing the browser to do any work in&#13;
recomputing the layout of the page and repainting the elements.</p>&#13;
&#13;
<p>The virtual DOM<a data-primary="cross-browser compatibility, DOM" data-type="indexterm" id="id565"/><a data-primary="browsers" data-secondary="cross-browser compatibility" data-type="indexterm" id="id566"/><a data-primary="Document Object Model (DOM)" data-secondary="cross-browser compatibility pitfall" data-type="indexterm" id="id567"/> also helps to improve the authoring experience of&#13;
elements and their updates by providing a consistent API that abstracts&#13;
away the differences between different browser implementations of the&#13;
real DOM. For example, if <code>document.appendChild</code> is different in another&#13;
runtime, it doesn’t matter when using JSX and the virtual DOM. This&#13;
makes it easier for developers to create web applications that work&#13;
seamlessly across different browsers and platforms.</p>&#13;
&#13;
<p>React uses the virtual DOM to build user interfaces. In this section, we&#13;
will explore how React’s implementation of the virtual DOM works.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="React Elements" data-type="sect2"><div class="sect2" id="id40">&#13;
<h2>React Elements</h2>&#13;
&#13;
<p>In React, user interfaces are represented as a <a data-primary="virtual DOM (vDOM)" data-secondary="React elements" data-type="indexterm" id="ix_virtualDOMvDOMReactelements.03.780.48"/><a data-primary="elements" data-secondary="virtual DOM" data-type="indexterm" id="ix_elementsvirtualDOM.03.780.48"/>tree of <em>React elements</em>, which are lightweight representations of a component or HTML&#13;
element. They are created<a data-primary="React.createElement function" data-type="indexterm" id="id568"/> using the <code>React.createElement</code> function and&#13;
can be nested to create complex user interfaces.</p>&#13;
&#13;
<p>Here is an example of a React element:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">element</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
  <code class="s2">"div"</code><code class="p">,</code>&#13;
  <code class="p">{</code> <code class="nx">className</code><code class="o">:</code> <code class="s2">"my-class"</code> <code class="p">},</code>&#13;
  <code class="s2">"Hello, world!"</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>This creates a React element that represents a <code>&lt;div&gt;</code> element with a&#13;
<code>className</code> of <code>my-class</code> and the text content <code>Hello, world!</code>.</p>&#13;
&#13;
<p>From here, we can see the actual created element if we use&#13;
 <code>console.log(element)</code>.<a data-primary="console.log(element)" data-type="indexterm" id="id569"/> It looks like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nx">$$typeof</code><code class="o">:</code> <code class="nx">Symbol</code><code class="p">(</code><code class="nx">react</code><code class="p">.</code><code class="nx">element</code><code class="p">),</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s2">"div"</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">ref</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">className</code><code class="o">:</code> <code class="s2">"my-class"</code><code class="p">,</code>&#13;
    <code class="nx">children</code><code class="o">:</code> <code class="s2">"Hello, world!"</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">_owner</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">_store</code><code class="o">:</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is a representation of a React element. React elements are the&#13;
smallest building blocks of a React application, and they describe what&#13;
should appear on the screen. Each element is a plain JavaScript object&#13;
that describes the component it represents, along with any relevant&#13;
props or attributes.</p>&#13;
&#13;
<p class="pagebreak-before">The React element shown in the code block is represented as an object&#13;
with several properties:</p>&#13;
<dl>&#13;
<dt><code>$$typeof</code></dt>&#13;
<dd>&#13;
<p>This is a symbol<a data-primary="$$typeof property, React element" data-type="indexterm" id="id570"/> used by React to ensure that an object is&#13;
a valid React element. In this case, it is <code>Symbol(react.element)</code>.&#13;
<code>$$typeof</code> can have other values, depending on the type of the element:</p>&#13;
<div class="openblock"><dl>&#13;
<dt><code>Symbol(react.fragment)</code></dt>&#13;
<dd>&#13;
<p>When the element represents a React&#13;
fragment<a data-primary="Symbol(react.fragment)" data-type="indexterm" id="id571"/>.</p>&#13;
</dd>&#13;
<dt><code>Symbol(react.portal)</code></dt>&#13;
<dd>&#13;
<p>When the element represents a React portal<a data-primary="Symbol(react.portal)" data-type="indexterm" id="id572"/>.</p>&#13;
</dd>&#13;
<dt><code>Symbol(react.profiler)</code></dt>&#13;
<dd>&#13;
<p>When the element represents a React&#13;
profiler<a data-primary="Symbol(react.profiler)" data-type="indexterm" id="id573"/>.</p>&#13;
</dd>&#13;
<dt><code>Symbol(react.provider)</code></dt>&#13;
<dd>&#13;
<p>When the element represents a React context&#13;
provider<a data-primary="Symbol(react.provider)" data-type="indexterm" id="id574"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div>&#13;
<div class="openblock">&#13;
<p>In general, <code>$$typeof</code> serves as a type marker that identifies the type&#13;
of the React element. We’ll cover more of these in more detail later in&#13;
the book.</p>&#13;
</div>&#13;
</dd>&#13;
<dt><code>type</code></dt>&#13;
<dd>&#13;
<p>This property represents the type<a data-primary="type property, React element" data-type="indexterm" id="id575"/> of the component that the&#13;
element represents. In this case, it is <code>"div"</code>, indicating that this is&#13;
a <code>&lt;div&gt;</code> DOM element, called a “host component.” The <code>type</code> property&#13;
of a React element can be either a string or a function (or a class, but&#13;
we don’t talk about that because it’s being phased out). If it is a&#13;
string, it represents the HTML tag name, like <code>"div"</code>, <code>"span"</code>,&#13;
<code>"button"</code>, etc. When it is a function, it represents a custom React&#13;
component, which is essentially just a JavaScript function that returns&#13;
JSX.</p>&#13;
&#13;
<p>Here is an example of an element with a custom component type:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;{</code><code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="p">}&lt;/</code><code class="nt">div</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">myElement</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">MyComponent</code> <code class="na">text</code><code class="o">=</code><code class="s">"Hello, world!"</code> <code class="p">/&gt;;</code><code class="w"/></pre>&#13;
&#13;
<p>In this case, the type property of <code>myElement</code> is <code>MyComponent</code>, which&#13;
is a function that defines a custom component. The value of <code>myElement</code> as&#13;
a React element object would be:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nx">$$typeof</code><code class="o">:</code> <code class="nx">Symbol</code><code class="p">(</code><code class="nx">react</code><code class="p">.</code><code class="nx">element</code><code class="p">),</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="nx">MyComponent</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">ref</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">text</code><code class="o">:</code> <code class="s2">"Hello, world!"</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">_owner</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">_store</code><code class="o">:</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that type is set to the <code>MyComponent</code> function, which is the type&#13;
of the component that the element represents, and <code>props</code> contains the&#13;
props passed to the component, in this case <code>{ text: "Hello, world!" }</code>.</p>&#13;
&#13;
<p>When React encounters an element with a function type, it will invoke&#13;
that function with the element’s <code>props</code>, and the return value will be used&#13;
as the element’s <code>children</code>, in this case, a <code>div</code>. This is how&#13;
custom React components are rendered<a data-primary="custom React components, rendering" data-type="indexterm" id="id576"/><a data-primary="rendering" data-secondary="custom React components" data-type="indexterm" id="id577"/>: React continually goes deeper and&#13;
deeper and deeper with elements until scalar values are reached, which&#13;
are then rendered as text nodes, or if <code>null</code> or <code>undefined</code> is reached,&#13;
nothing is rendered.</p>&#13;
&#13;
<p>Here is an example of an element with a string type:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">myElement</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="nx">Hello</code><code class="p">,</code><code class="w"> </code><code class="nx">world</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;;</code><code class="w"/></pre>&#13;
&#13;
<p>In this case, the type property of <code>myElement</code> is <code>"div"</code>, which is a&#13;
string that represents an HTML tag name. When React encounters an&#13;
element with a string type, it will create a corresponding HTML element&#13;
with that tag name and render its children within that element.</p>&#13;
</dd>&#13;
<dt><code>ref</code></dt>&#13;
<dd>&#13;
<p>This property<a data-primary="ref property, React element" data-type="indexterm" id="id578"/> lets the parent component request a reference to&#13;
the underlying DOM node. It is generally used in cases where direct&#13;
manipulation of the DOM is necessary. In this case, the <code>ref</code> is <code>null</code>.</p>&#13;
</dd>&#13;
<dt><code>props</code></dt>&#13;
<dd>&#13;
<p>This property<a data-primary="props property, React element" data-type="indexterm" id="id579"/> is an object that contains all of the&#13;
attributes and props that were passed to the component. In this case, it&#13;
has two properties: <code>className</code> and <code>children</code>. <code>className</code> specifies&#13;
the class name of the element, and <code>children</code> contains the content of&#13;
the element.</p>&#13;
</dd>&#13;
<dt><code>_owner</code></dt>&#13;
<dd>&#13;
<p>This property<a data-primary="owner property, React element" data-type="indexterm" id="id580"/>, only accessible in nonproduction builds of&#13;
React, is used internally by React to track the component that created&#13;
this element. This information is used to determine which component&#13;
should be responsible for updating the element when its props or state&#13;
change.</p>&#13;
&#13;
<p class="pagebreak-before">Here is an example that demonstrates how the <code>_owner</code> property is used:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">Parent</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Child</code> <code class="p">/&gt;;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">Child</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">element</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="nx">Hello</code><code class="p">,</code><code class="w"> </code><code class="nx">world</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">element</code><code class="p">.</code><code class="nx">_owner</code><code class="p">);</code><code class="w"> </code><code class="c1">// Parent</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nx">element</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the <code>Child</code> component creates a React element&#13;
representing a <code>&lt;div&gt;</code> element with the text <code>"Hello, world!"</code>. The&#13;
<code>_owner</code> property of this element is set to the <code>Parent</code> component,&#13;
which is the component that created the <code>Child</code> component.</p>&#13;
&#13;
<p>React uses this information to determine which component should be&#13;
responsible for updating the element when its props or state change. In&#13;
this case, if the <code>Parent</code> component updates its state or receives new&#13;
props, React will update the <code>Child</code> component and its associated&#13;
element.</p>&#13;
&#13;
<p>It’s important to note that the <code>_owner</code> property is an internal&#13;
implementation detail of React and should not be relied upon in&#13;
application code.</p>&#13;
</dd>&#13;
<dt><code>_store</code></dt>&#13;
<dd>&#13;
<p>The <code>_store</code> property<a data-primary="store property, React element" data-type="indexterm" id="id581"/> of a React element object is an object&#13;
that is used internally by React to store additional data about the&#13;
element. The specific properties and values stored in <code>_store</code> are not&#13;
part of the public API and should not be accessed directly.</p>&#13;
&#13;
<p>Here’s an example of what the <code>_store</code> property might look like:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nx">validation</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">originalProps</code><code class="o">:</code> <code class="p">{</code> <code class="nx">className</code><code class="o">:</code> <code class="s1">'my-class'</code><code class="p">,</code> <code class="nx">children</code><code class="o">:</code> <code class="s1">'Hello, world!'</code> <code class="p">},</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="p">{</code> <code class="nx">className</code><code class="o">:</code> <code class="s1">'my-class'</code><code class="p">,</code> <code class="nx">children</code><code class="o">:</code> <code class="s1">'Hello, world!'</code> <code class="p">},</code>&#13;
  <code class="nx">_self</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">_source</code><code class="o">:</code> <code class="p">{</code> <code class="nx">fileName</code><code class="o">:</code> <code class="s1">'MyComponent.js'</code><code class="p">,</code> <code class="nx">lineNumber</code><code class="o">:</code> <code class="mi">10</code> <code class="p">},</code>&#13;
  <code class="nx">_owner</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">_currentElement</code><code class="o">:</code> <code class="p">[</code><code class="nx">Circular</code><code class="p">],</code> <code class="nx">_debugID</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">stateNode</code><code class="o">:</code> <code class="p">[</code><code class="nx">MyComponent</code><code class="p">]</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">_isStatic</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="nx">_warnedAboutRefsInRender</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">As you can see, <code>_store</code> includes various properties such as&#13;
<code>validation</code>, <code>key</code>, &#13;
<span class="keep-together"><code>originalProps</code>,</span> <code>props</code>, <code>_self</code>, <code>_source</code>,&#13;
<code>_owner</code>, <code>_isStatic</code>, and <code>_warned​Abou⁠tRefsInRender</code>. These properties&#13;
are used by React internally to track various aspects of the element’s&#13;
state and context.</p>&#13;
&#13;
<p>For example, <code>_source</code> in development mode is used to track the filename and line number where the element was created, which can be helpful&#13;
for debugging. <code>_owner</code> is used to track the component that created the&#13;
element, as discussed earlier. And <code>props</code> and <code>originalProps</code> are used&#13;
to store the props passed to the component.</p>&#13;
&#13;
<p>Again, it’s important to note that <code>_store</code> is an internal&#13;
implementation detail of React and should not be accessed directly in&#13;
application code, and for this exact reason, we will refrain from going&#13;
deeper here<a data-startref="ix_virtualDOMvDOMReactelements.03.780.48" data-type="indexterm" id="id582"/><a data-startref="ix_elementsvirtualDOM.03.780.48" data-type="indexterm" id="id583"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Virtual DOM Versus Real DOM" data-type="sect2"><div class="sect2" id="id41">&#13;
<h2>Virtual DOM Versus Real DOM</h2>&#13;
&#13;
<p>The <code>React.createElement</code> function<a data-primary="virtual DOM (vDOM)" data-secondary="versus real DOM" data-secondary-sortas="real DOM" data-type="indexterm" id="ix_virtualDOMvDOMversusrealDOM.03.996.39"/><a data-primary="Document Object Model (DOM)" data-secondary="versus virtual DOM" data-secondary-sortas="virtual DOM" data-type="indexterm" id="ix_DocumentObjectModelDOMversusvirtualDOM.03.996.39"/> and the DOM’s built-in <code>createElement</code> method<a data-primary="React.createElement function" data-type="indexterm" id="ix_ReactcreateElementfunction.03.997.23"/><a data-primary="document.createElement function" data-type="indexterm" id="ix_documentcreateElementfunction.03.997.23"/> are similar in that they both create new elements; however, <code>React.createElement</code> creates React elements and <code>document.createElement</code> creates DOM nodes. They’re vastly different in their implementation, but conceptually they’re similar.</p>&#13;
&#13;
<p><code>React.createElement</code> is a function provided by React that creates a new&#13;
virtual element in memory, whereas <code>document.createElement</code> is a method&#13;
provided by the DOM API that creates a new element also in memory until&#13;
it is attached to the DOM with APIs like <code>document.appendChild</code> or&#13;
similar. Both functions take a tag name as their first argument, while&#13;
<code>React.createElement</code> takes additional arguments to specify props and&#13;
children.</p>&#13;
&#13;
<p>For example, let’s compare how we’d create a <code>&lt;div&gt;</code> element&#13;
using both methods:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="c1">// Using React's createElement</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">divElement</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">  </code><code class="s2">"div"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">{</code><code class="w"> </code><code class="nx">className</code><code class="o">:</code><code class="w"> </code><code class="s2">"my-class"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="s2">"Hello, World!"</code><code class="w"/>&#13;
<code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="c1">// Using the DOM API's createElement</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">divElement</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"div"</code><code class="p">);</code><code class="w"/>&#13;
<code class="nx">divElement</code><code class="p">.</code><code class="nx">className</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"my-class"</code><code class="p">;</code><code class="w"/>&#13;
<code class="nx">divElement</code><code class="p">.</code><code class="nx">textContent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"Hello, World!"</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>The virtual DOM in React is similar in concept to the real DOM in that&#13;
both represent a tree-like structure of elements. When a React component&#13;
is rendered, React creates a new virtual DOM tree, compares it to the&#13;
previous virtual DOM tree, and calculates the minimum number of changes&#13;
needed to update the old tree to match the new. This is known as the&#13;
<em>reconciliation process</em>. Here’s an example of how this might work in a React component:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>For clarity, this component can also be expressed like so:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="s2">"div"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="kc">null</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">,</code><code class="w"> </code><code class="kc">null</code><code class="p">,</code><code class="w"> </code><code class="s2">"Count: "</code><code class="p">,</code><code class="w"> </code><code class="nx">count</code><code class="p">),</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">      </code><code class="s2">"button"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="w"> </code><code class="nx">onClick</code><code class="o">:</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">      </code><code class="s2">"Increment"</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">)</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In the <code>createElement</code> calls, the first argument is the name of the HTML&#13;
tag or React component, the second argument is an object of properties&#13;
(or <code>null</code> if no properties are needed), and any additional arguments&#13;
represent child elements.</p>&#13;
&#13;
<p>When the component is first rendered, React creates a virtual DOM tree like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">div</code>&#13;
<code class="err">├─</code> <code class="n">h1</code>&#13;
<code class="err">│</code>  <code class="err">└─</code> <code class="s2">"Count: 0"</code>&#13;
<code class="err">└─</code> <code class="n">button</code>&#13;
   <code class="err">└─</code> <code class="s2">"Increment"</code></pre>&#13;
&#13;
<p>When the button is clicked, React creates a new virtual DOM tree that&#13;
looks like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">div</code>&#13;
<code class="err">├─</code> <code class="n">h1</code>&#13;
<code class="err">│</code>  <code class="err">└─</code> <code class="s2">"Count: 1"</code>&#13;
<code class="err">└─</code> <code class="n">button</code>&#13;
   <code class="err">└─</code> <code class="s2">"Increment"</code></pre>&#13;
&#13;
<p>React then calculates that only the text content of the <code>h1</code> element&#13;
needs to be updated, and updates only that part of the real DOM.</p>&#13;
&#13;
<p>The use of a virtual DOM in React allows for efficient updates to the&#13;
real DOM, as well as allowing React to work seamlessly with other&#13;
libraries that also manipulate the DOM directly<a data-startref="ix_virtualDOMvDOMversusrealDOM.03.996.39" data-type="indexterm" id="id584"/><a data-startref="ix_DocumentObjectModelDOMversusvirtualDOM.03.996.39" data-type="indexterm" id="id585"/><a data-startref="ix_ReactcreateElementfunction.03.997.23" data-type="indexterm" id="id586"/><a data-startref="ix_documentcreateElementfunction.03.997.23" data-type="indexterm" id="id587"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Efficient Updates" data-type="sect2"><div class="sect2" id="id42">&#13;
<h2>Efficient Updates</h2>&#13;
&#13;
<p>When a React component’s state<a data-primary="virtual DOM (vDOM)" data-secondary="efficient updates" data-type="indexterm" id="ix_virtualDOMvDOMefficientupdates.03.1109.31"/><a data-primary="efficient updates, virtual DOM" data-type="indexterm" id="ix_efficientupdatesvirtualDOM.03.1109.31"/><a data-primary="updates" data-secondary="efficient" data-type="indexterm" id="ix_updatesefficient.03.1109.31"/> or props change, React creates a new tree&#13;
of React elements that represents the updated user interface. This new&#13;
tree<a data-primary="tree of React elements" data-secondary="comparing in React for efficient update" data-type="indexterm" id="id588"/> is then compared to the previous tree to determine the minimal set&#13;
of changes required to update the real DOM using a diffing algorithm<a data-primary="diffing algorithm" data-type="indexterm" id="id589"/>.</p>&#13;
&#13;
<p>This algorithm compares the new tree of React elements with the previous&#13;
tree and identifies the differences between the two. It is a recursive&#13;
comparison. If a node has changed, React updates the corresponding node&#13;
in the real DOM. If a node has been added or removed, React adds or&#13;
removes the corresponding node in the real DOM.</p>&#13;
&#13;
<p>Diffing involves comparing the new tree with the old one node by node to&#13;
find out which parts of the tree have changed.</p>&#13;
&#13;
<p>React’s diffing algorithm is highly optimized and aims to minimize the&#13;
number of changes that need to be made to the real DOM. The algorithm&#13;
works as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the nodes at the root level of the two trees are different, React&#13;
will replace the entire tree with the new one.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the nodes at the root level are the same, React will update the&#13;
attributes of the node if they have changed.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the children of a node are different, React will update only the&#13;
children that have changed. React does not re-create the entire subtree;&#13;
it only updates the nodes that have changed.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the children of a node are the same, but their order has changed,&#13;
React will reorder the nodes in the real DOM without actually re-creating&#13;
them.</p>&#13;
</li>&#13;
<li>&#13;
<p>If a node is removed from the tree, React will remove it from&#13;
the real DOM.</p>&#13;
</li>&#13;
<li>&#13;
<p>If a new node has been added to the tree, React will add it to the&#13;
real DOM.</p>&#13;
</li>&#13;
<li>&#13;
<p>If a node’s type has changed (e.g., from a <code>div</code> to a <code>span</code>), React will&#13;
remove the old node and create a new node of the new type.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the node has a <code>key</code> prop, React uses it to know if it should&#13;
replace the node or not. It can be useful when you need to reset the&#13;
state of the components.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>React’s diffing algorithm is efficient and allows React to update the&#13;
real DOM quickly and with minimal changes. This helps to improve the&#13;
performance of React applications and makes it easier to build complex,&#13;
dynamic user interfaces.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Unnecessary rerenders" data-type="sect3"><div class="sect3" id="id43">&#13;
<h3>Unnecessary rerenders</h3>&#13;
&#13;
<p>While React’s diffing algorithm<a data-primary="unnecessary rerenders" data-type="indexterm" id="ix_unnecessaryrerenders.03.1154.32"/><a data-primary="virtual DOM (vDOM)" data-secondary="unnecessary rerenders" data-type="indexterm" id="ix_virtualDOMvDOMunnecessaryrerenders.03.1154.32"/><a data-primary="performance" data-secondary="unnecessary rerenders" data-type="indexterm" id="ix_performanceunnecessaryrerenders.03.1154.32"/> indeed plays a crucial role in&#13;
efficiently updating the real DOM by minimizing the changes needed,&#13;
there’s a common challenge that developers may encounter: unnecessary&#13;
rerenders.</p>&#13;
&#13;
<p>This is the way React works by design: when a component’s state changes,&#13;
React rerenders<a data-primary="rerendering" data-secondary="React’s method" data-type="indexterm" id="id590"/> the component and all of its descendants. By&#13;
rerendering, we mean that React calls each function component&#13;
recursively, passing each function component its props as an argument.&#13;
React does not skip components whose props have not changed, but calls&#13;
all function components that are children of a parent whose state or&#13;
props change. This is because React doesn’t know which components&#13;
depend on the state of the component that changed, so it has to&#13;
rerender all of them to ensure that the UI stays consistent.</p>&#13;
&#13;
<p>This can present some significant performance challenges, especially&#13;
when dealing with large and complex user interfaces. For example,&#13;
<code>ChildComponent</code> in the following snippet will rerender every time the&#13;
<code>ParentComponent</code>’s state changes, even if the props passed to&#13;
<code>ChildComponent</code> do not:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ChildComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">message</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;{</code><code class="nx">message</code><code class="p">}&lt;/</code><code class="nt">div</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ParentComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ChildComponent</code> <code class="na">message</code><code class="o">=</code><code class="s">"This is a static message"</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">ParentComponent</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>ParentComponent</code> has a state variable <code>count</code> that is incremented&#13;
every time the button is clicked.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>ChildComponent</code> receives a static prop called <code>message</code>. Since this&#13;
prop doesn’t change, ideally, we wouldn’t want <code>ChildComponent</code> to&#13;
rerender every time <code>Parent​Component</code>’s state changes.</p>&#13;
</li>&#13;
<li>&#13;
<p>However, due to React’s default behavior, <code>ChildComponent</code> will&#13;
rerender every time the <code>ParentComponent</code> rerenders, which happens on&#13;
every state change.</p>&#13;
</li>&#13;
<li>&#13;
<p>This is inefficient because <code>ChildComponent</code> does not depend on the&#13;
<code>count</code> state from <code>ParentComponent</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Since <code>ChildComponent</code>’s props and state haven’t changed, the render&#13;
was pointless: it presumably returned the same result as last time, so&#13;
this was wasted effort.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This is the problem that we often need to optimize<a data-primary="performance" data-secondary="rerender optimizations" data-type="indexterm" id="id591"/>, especially in larger&#13;
applications where many components might be rerendering unnecessarily,&#13;
leading to potential performance issues. Addressing this issue requires&#13;
a thoughtful approach to managing component rerenders, ensuring that&#13;
changes in state or props at a higher level in the component hierarchy&#13;
do not result in widespread, unnecessary rerenders among descendant&#13;
components. Through mindful structuring of components and judicious use&#13;
of React’s optimization features like <code>memo</code> and <code>useMemo</code>, developers&#13;
can better manage rerenders and maintain high performance in their&#13;
applications<a data-startref="ix_virtualDOMvDOM.03.3.65" data-type="indexterm" id="id592"/><a data-startref="ix_virtualDOMvDOMworkingsof.03.759.16" data-type="indexterm" id="id593"/><a data-startref="ix_virtualDOMvDOMefficientupdates.03.1109.31" data-type="indexterm" id="id594"/><a data-startref="ix_unnecessaryrerenders.03.1154.32" data-type="indexterm" id="id595"/><a data-startref="ix_virtualDOMvDOMunnecessaryrerenders.03.1154.32" data-type="indexterm" id="id596"/><a data-startref="ix_efficientupdatesvirtualDOM.03.1109.31" data-type="indexterm" id="id597"/><a data-startref="ix_performanceunnecessaryrerenders.03.1154.32" data-type="indexterm" id="id598"/><a data-startref="ix_updatesefficient.03.1109.31" data-type="indexterm" id="id599"/>.</p>&#13;
&#13;
<p>We cover this in more detail in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chapter Review" data-type="sect1"><div class="sect1" id="id226">&#13;
<h1>Chapter Review</h1>&#13;
&#13;
<p>Throughout this chapter, we have explored the differences between the&#13;
real DOM and the virtual DOM in web development, as well as the&#13;
advantages of using the latter in React.</p>&#13;
&#13;
<p>We first talked about the real DOM and its limitations, such as slow&#13;
rendering times and cross-browser compatibility issues, which can make&#13;
it difficult for developers to create web applications that work&#13;
seamlessly across different browsers and platforms. To illustrate this,&#13;
we examined how to create a simple web page using the real DOM APIs, and&#13;
how these APIs can quickly become unwieldy and difficult to manage as&#13;
the complexity of the page increases.</p>&#13;
&#13;
<p>Next, we dove into the virtual DOM and how it addresses many of the&#13;
limitations of the real DOM. We explored how React leverages the virtual&#13;
DOM to improve performance by minimizing the number of updates needed to&#13;
the real DOM, which can be expensive in terms of rendering time. We also&#13;
looked at how React uses elements to compare the virtual DOM with the&#13;
previous version and calculate the most efficient way to update the real&#13;
DOM.</p>&#13;
&#13;
<p>To illustrate the benefits of the virtual DOM, we examined how to create&#13;
the same simple web page using React components. We compared this&#13;
approach to the real DOM approach and saw how React components were more&#13;
concise and easier to manage, even as the complexity of the page&#13;
increased.</p>&#13;
&#13;
<p>We also looked at the differences between <code>React.createElement</code> and&#13;
<code>document.createElement</code>, and we saw how we could create components&#13;
using JSX, which provides a syntax similar to HTML, making it easier to&#13;
reason about the structure of the virtual DOM.</p>&#13;
&#13;
<p>Finally, we looked at how React’s diffing algorithm can lead to&#13;
unnecessary rerenders, which can be a significant performance&#13;
challenge, especially when dealing with large and complex user&#13;
interfaces, and alluded to <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, where we’ll explore how we can&#13;
optimize this by using React’s <code>memo</code> and <code>useMemo</code> features.</p>&#13;
&#13;
<p>Overall, we have learned about the benefits of using the virtual DOM in&#13;
web development, and how React leverages this concept to make building&#13;
web applications easier and more efficient.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect1"><div class="sect1" id="id227">&#13;
<h1>Review Questions</h1>&#13;
&#13;
<p>Let’s take a moment to answer the following questions:</p>&#13;
<ol>&#13;
<li>&#13;
<p>What is the DOM, and how does it compare to the virtual DOM?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are document fragments, and how are they similar and different to&#13;
React’s virtual DOM?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are some issues with the DOM?</p>&#13;
</li>&#13;
<li>&#13;
<p>How does the virtual DOM provide a faster way of performing user&#13;
interface updates?</p>&#13;
</li>&#13;
<li>&#13;
<p>How does React rendering work? What potential problems can arise from&#13;
this?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up Next" data-type="sect1"><div class="sect1" id="id228">&#13;
<h1>Up Next</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, we will dive deep into React reconciliation and its&#13;
Fiber &#13;
<span class="keep-together">architecture.</span></p>&#13;
</div></section>&#13;
</div></section></body></html>