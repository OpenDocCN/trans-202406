- en: Chapter 3\. Composing Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned the fundamentals of Vue and how to write
    a Vue component with common directives using Options API. You are now ready to
    deep dive into the next level: composing more complex Vue components with reactivity
    and hooks.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the Vue Single File Component (SFC) standard, component
    lifecycle hooks, and other advanced reactive features such as computed properties,
    watchers, methods, and refs. You will also learn to use slots to dynamically render
    different parts of the component while maintaining the component’s structure with
    styles. By the end of this chapter, you will be able to write complex Vue components
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Vue Single File Component Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vue introduces a new file format standard, Vue SFC, denoted by the `.vue` extension.
    With SFC, you can write the HTML template code, the JavaScript logic, and the
    CSS stylings for a component in the same file, each in its dedicated code section.
    A Vue SFC contains three essential code sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Template
  prefs: []
  type: TYPE_NORMAL
- en: This HTML code block renders the UI view of the component. It should only appear
    *once* per component at the highest level element.
  prefs: []
  type: TYPE_NORMAL
- en: Script
  prefs: []
  type: TYPE_NORMAL
- en: This JavaScript code block contains the component’s main logic and only appears
    *a maximum of once* per component file.
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs: []
  type: TYPE_NORMAL
- en: This CSS code block contains the stylings for the component. It is optional
    and can appear as *many times* as required per component file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-1](#example_03_01) is an example of an SFC file structure for a
    Vue component named `MyFirstComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. SFC structure of `MyFirstComponent` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can also refactor a non-SFC component code into SFC, as shown in [Figure 3-1](#figure_03_01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a Vue component created with single file component concept](assets/lvue_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Refactoring the component from non-SFC format to SFC format
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As [Figure 3-1](#figure_03_01) shows, we perform the following refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the HTML code presented as the string value of the `template` field into
    the `<template>` section of the Single File Component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the rest of `MyFirstComponent` logic into the `<script>` section of the
    Single File Component, as part of the `export default {}` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip for Using TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should add the attribute `lang="ts"` for TypeScript to the `<script>` syntax,
    as `<script lang="ts">` , so the Vue engine knows to handle the code format accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `.vue` file format is a unique extension standard, you need to use
    a special build tool (compiler/transpiler) such as Webpack, Rollup, etc., to pre-compile
    the relevant files into proper JavaScript and CSS for serving on the browser side.
    When creating a new project with Vite, Vite already sets up these tools as part
    of the scaffolding process. You then can import the component as an ES module
    and declare it as internal `components` to use in other component files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of importing `MyFirstComponent` located in the `components`
    directory to use in the `App.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As [Example 3-2](#example_03_04) shows, you can use the imported component
    by referring to its name, either by CamelCase or snake case, in the `template`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. How to use the imported component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code generates the `MyFirstComponent` component’s content twice, as shown
    in [Figure 3-2](#figure_03_02).
  prefs: []
  type: TYPE_NORMAL
- en: '![How the component is rendered with repetitive content from its nested components](assets/lvue_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. `MyFirstComponent` output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A component’s `template` in [Example 3-2](#example_03_04) contains two root
    elements. This fragmentation capability is available only in Vue 3.x onward.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create and use a Vue component using the SFC format. As you
    have noticed, we define `lang="ts"` in the `script` tag to inform the Vue engine
    about our usage of TypeScript. And thus, the Vue engine will apply stricter type
    validation on any code or expressions presented in the `script` and `template`
    sections of the component.
  prefs: []
  type: TYPE_NORMAL
- en: However, to fully enjoy TypeScript’s benefits in Vue, we need to use the `defineComponent()`
    method when defining a component, which we will learn in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using defineComponent() for TypeScript Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `defineComponent()` method is a wrapper function that accepts an object
    of configurations and returns the same thing with type inference for defining
    a component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `defineComponent()` method is available only in Vue 3.x onward and relevant
    only when TypeScript is required.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-3](#example_03_03) illustrates using `defineComponent()` to define
    a component.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. Defining a component with `defineComponent()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you use VSCode as your IDE, and have [Volar extension](https://oreil.ly/lmnvd)
    installed, you will see the type of `message` as `string` when hovering on `message`
    in the `template` section, as shown in [Figure 3-3](#figure_03_03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Type of string generated for the message property of MyMessageComponent when
    hovering on the message word inside the template section](assets/lvue_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Generated type for `message` property of `MyMessageComponent` displayed
    on hover
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should use `defineComponent()` for TypeScript support only in complex components
    such as accessing a component’s properties through `this` instance. Otherwise,
    you can use the standard method for defining an SFC component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this book, you will see a combination of the traditional component definition
    approach and `defineComponent()` when suitable. You are free to decide which method
    works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the lifecycle of a component and its hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Component Lifecycle Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lifecycle of a Vue component starts when Vue instantiates the component
    and ends when destroying the component instance (or unmounting).
  prefs: []
  type: TYPE_NORMAL
- en: Vue divides the component’s lifecycle into the phases ([Figure 3-4](#figure_03_33)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram flowchart of the lifecycle of a Vue component](assets/lvue_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Flow graph of a Vue component lifecycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Initialize phase
  prefs: []
  type: TYPE_NORMAL
- en: The Vue renderer loads the component’s option configurations and prepares for
    the component instance creation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating phase
  prefs: []
  type: TYPE_NORMAL
- en: The Vue renderer creates the component instance. If the template requires compiling,
    there will be an additional step to compile it before moving forward to the next
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: First render phase
  prefs: []
  type: TYPE_NORMAL
- en: The Vue renderer creates and inserts the DOM nodes for the component in its
    DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting phase
  prefs: []
  type: TYPE_NORMAL
- en: The component’s nested elements are already mounted and attached to the component’s
    DOM tree, as seen in [Figure 3-5](#figure_03_04). The Vue renderer then attaches
    the component to its parent container. From this phase onward, you have access
    to the component’s `$el` property, representing its DOM node.
  prefs: []
  type: TYPE_NORMAL
- en: Updating phase
  prefs: []
  type: TYPE_NORMAL
- en: Only relevant if the component’s reactive data changes. Here the Vue renderer
    re-renders the DOM nodes for the component with the new data and performs a patch
    update. Similar to the mounting phase, the update process finishes with the child
    elements first and then the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: Unmounting phase
  prefs: []
  type: TYPE_NORMAL
- en: The Vue renderer detaches the component from the DOM and destroys the instance
    and all its reactive data effects. This phase is the last phase of the lifecycle,
    happening when the component is no longer in use in the application. Similar to
    the updating and mounting stages, a component can only unmount itself after all
    its children are unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing how the mounting order of a component and its children,
    noting from 1 to 3](assets/lvue_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Mounting order for a component and its children
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vue allows you to attach some events to specific transitions between these lifecycle
    phases for better component flow control. We call these events lifecycle hooks.
    The lifecycle hooks available in Vue are described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`setup` is the first event hook before the component’s lifecycle starts. This
    hook runs *once* before Vue instantiates the component. At this phase, no component
    instance exists; hence *there is no access* to `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An alternative to the `setup` hook is adding the `setup` attribute to the `script`
    tag section of the component (`<script setup>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setup` hook is mainly for use with the Composition API (we will learn
    more in [Chapter 5](ch05.html#unique_chapter_id_06)). Its syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`setup()` takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`props`'
  prefs: []
  type: TYPE_NORMAL
- en: An object that contains all the props passed to the component, declared using
    the `props` field of the component’s options object. Each of `props`’s properties
    is reactive data. You don’t need to return `props` as part of the `setup()` return
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '`context`'
  prefs: []
  type: TYPE_NORMAL
- en: A non-reactive object that contains the component’s context, such as `attrs`,
    `slots`, `emit`, and `expose`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use `<script setup>`, you need to use `defineProps()` to define and access
    these props. See [“Declaring Props Using defineProps() and withDefaults()”](ch04.html#declaring-props-defineProps).
  prefs: []
  type: TYPE_NORMAL
- en: '`setup()` returns an object that contains all the references to the component’s
    internal reactive state and methods and any static data. Suppose you use `<script
    setup>`; you don’t need to return anything. In that case, Vue will automatically
    translate all the variables and functions declared within this syntax into the
    appropriate `setup()` return object during compilation. You then can access them
    in the template or other parts of the component’s options object using the `this`
    keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-4](#example_03_37) shows using `setup()` hook to define a component
    that prints out a static message.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. Defining a component with the `setup()` hook
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note here that `message` is not reactive data. To make it reactive, you must
    wrap it with the `ref()` function from the Composition API. We will learn more
    about this in [“Handling Data with ref() and reactive()”](ch05.html#ref_function_06).
    Also, we no longer need to define `message` as part of the `data()` object, reducing
    the amount of undesired reactive data in a component.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, as [Example 3-5](#example_03_38) shows, you can write the previous
    component using the `<script setup>` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. Defining a component with `<script setup>` syntax
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One great thing about using `<script setup>` instead of `setup()` is that it
    has built-in TypeScript support. As a result, there is no need for `defineComponent()`,
    and writing components takes less code.
  prefs: []
  type: TYPE_NORMAL
- en: When using `setup()` hook, you can also combine with the `h()` render function
    to return a renderer for the component based on the `props` and `context` arguments,
    as [Example 3-6](#example_03_39) shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. Defining a component with the `setup()` hook and `h()` render
    function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is helpful to use `setup()` with `h()` when you want to create a component
    that renders a different static DOM structure based on the props passed to it
    or a stateless functional component ([Figure 3-6](#figure_35_03) shows the output
    of [Example 3-6](#example_03_39) in the Vue tab of Chrome Devtools).
  prefs: []
  type: TYPE_NORMAL
- en: '![The output of the stateless component using h() render function](assets/lvue_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. How the stateless component using the `h()` render function looks
    in Vue Devtools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From this point on, we will use `<script setup> syntax` to demonstrate use cases
    component’s `setup()` hook due to its simplicity, whenever applicable.
  prefs: []
  type: TYPE_NORMAL
- en: beforeCreate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`beforeCreate` runs *before* the Vue renderer creates the component instance.
    Here the Vue engine has initialized the component but hasn’t yet triggered the
    `data()` function or calculated any `computed` properties. Thus, there is no reactive
    data available.'
  prefs: []
  type: TYPE_NORMAL
- en: created
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This hook runs *after* the Vue engine creates the component instance. At this
    stage, the component instance exists with reactive data, watchers, computed properties,
    and defined methods. However, the Vue engine hasn’t yet mounted it to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The `created` hook runs *before the first render* of the component. It helps
    perform any task that requires `this` to be available, such as loading data from
    an external resource into the component.
  prefs: []
  type: TYPE_NORMAL
- en: beforeMount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This hook runs after `created`. Here the Vue render has created the component
    instance and compiled its template for rendering before the first render of the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: mounted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This hook runs after the first render of the component. At this phase, the component’s
    rendered DOM node is available for you to access through the ++ property. You
    can use this hook to perform additional side-effect calculations with the component’s
    DOM node.
  prefs: []
  type: TYPE_NORMAL
- en: beforeUpdate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Vue renderer updates the component’s DOM tree when the local data state
    changes. This hook runs *after* the update process starts, and you can still use
    it to modify the component’s state internally.
  prefs: []
  type: TYPE_NORMAL
- en: updated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This hook runs after the Vue renderer updates the component’s DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`updated`, `beforeUpdate`, `beforeMount` and `mounted` hooks are not available
    in server-side rendering (SSR).'
  prefs: []
  type: TYPE_NORMAL
- en: Use this hook with caution *since it runs after any DOM update occurs to the
    component*.
  prefs: []
  type: TYPE_NORMAL
- en: Update local state inside updated hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You *must not* mutate the component’s local data state in this hook.
  prefs: []
  type: TYPE_NORMAL
- en: beforeUnmount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This hook runs before the Vue renderer starts unmounting the component. At this
    point, the component’s DOM node `$el` is still available.
  prefs: []
  type: TYPE_NORMAL
- en: unmounted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This hook runs after the unmounting process completes successfully and the component
    instance is no longer available. This hook can clean up additional observers or
    effects, such as DOM event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Vue 2.x, you should use `beforeDestroy` and `destroyed` in place of `beforeUnmount`
    and `mounted`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeUnmounted` and `unmounted` hooks are not available in server-side rendering
    (SSR).'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we can redraw our component’s lifecycle diagram with the lifecycle
    hooks, as in [Figure 3-7](#figure_03_05).
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram flowchart of the lifecycle of a Vue component with hooks](assets/lvue_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Flowchart of a Vue component lifecycle with hooks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can experiment with the execution order for each lifecycle hook with the
    component in [Example 3-7](#example_03_36).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7\. Console log of lifecycle hooks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we run this code in the browser’s Inspector console, we will see the output
    shown in [Figure 3-8](#figure_03_06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Console log output for the above component in the first render](assets/lvue_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Console log output hook order for `MyFirstComponent` in the first
    render
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When we change the value of the `message` property, the component re-renders,
    and the console outputs as shown in [Figure 3-9](#figure_03_07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Console log output for the above component in the second render](assets/lvue_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. Only `beforeUpdate` and updated hooks are triggered on the second
    render
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can also review this lifecycle order in the Timeline tab—Performance section
    of Vue Devtools, as in [Figure 3-10](#figure_03_08) for the first render.
  prefs: []
  type: TYPE_NORMAL
- en: '![Timeline for the above component in the first render](assets/lvue_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. Timeline for `MyFirstComponent` in the first render
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And when the component re-renders, the Vue Devtools tab displays the timeline
    event records as in [Figure 3-11](#figure_03_09).
  prefs: []
  type: TYPE_NORMAL
- en: '![Timeline for the above component in the second render](assets/lvue_0311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11\. Timeline for `MyFirstComponent` in the second render
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each of the previous lifecycle hooks can be beneficial. In [Table 3-1](#right_hook_for_the_right_table),
    you will find the most common use cases per hook.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Using the right hook for the right purpose
  prefs: []
  type: TYPE_NORMAL
- en: '| Lifecycle hook | Use case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `beforeCreate` | When you need to load external logic *without* modifying
    the component’s data. |'
  prefs: []
  type: TYPE_TB
- en: '| `created` | When you need to load external data into the component. This
    hook is preferable to the `mounted` one for reading or writing data from external
    resources. |'
  prefs: []
  type: TYPE_TB
- en: '| `mounted` | When you need to perform any DOM manipulation or access the component’s
    DOM node `this.$el`. |'
  prefs: []
  type: TYPE_TB
- en: To this point, we have learned the component’s lifecycle order and its available
    hooks. Next, we will look at how to create and organize common component logic
    into methods with the `method` property.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods are logic that does not depend on the component’s data, even though
    we can access the component’s local state using a `this` instance within a method.
    Components’ methods are functions defined within the `methods` property. As [Example 3-8](#example_03_13)
    shows, we can define a method to reverse the `message` property.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-8\. Defining a method to reverse the `message` property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-9](#example_03_14) shows how we can use the `reverseMessage` method
    in the component’s template.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-9\. Output the reversed message on the template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When a user inputs a message’s value in the browser, we see the output in [Figure 3-12](#figure_03_10).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displays a reversed message based on the Hello Vue message](assets/lvue_0312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12\. Reversed message based on the value of `message`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also modify the `reverseMessage` method to accept a string argument,
    making it more reusable and less dependent on `this.message`, as in [Example 3-10](#example_03_15).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-10\. Defining a method to reverse a string
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `template` section, we refactor [Example 3-9](#example_03_14) and
    pass `message` as input parameter for the `reverseMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output stays the same as in [Figure 3-12](#figure_03_10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can trigger a component’s method within its other properties or lifecycle
    hooks using the `this` instance. For example, we can split `reverseMessage` into
    two smaller methods, `reverse()` and `arrToString()`, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Methods are beneficial in keeping your component’s logic organized. Vue triggers
    a method only when it is relevant (such as being called in the template as in
    [Example 3-9](#example_03_14)), allowing us to compute a new data value from local
    data dynamically. However, for methods, Vue does not cache the result of every
    trigger, and it will always rerun the method whenever a re-render occurs. Thus,
    in scenarios where you need to calculate new data, it is better to use computed
    properties, which we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Computed Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties are Vue’s unique features that allow you to calculate new
    reactive data properties from any reactive data of a component. Each computed
    property is a function that returns a value and resides within the `computed`
    property field.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-11](#example_03_05) shows how we define a newly computed property,
    `reversedMessage`, which returns the component’s local data `message` in reversed
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-11\. A computed property that returns the component’s local message
    in reversed order
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can access `reversedMessage` computed with the same approach as any component’s
    local data. [Example 3-12](#example_03_02) shows how we can output the calculated
    `reversed` `Message` based on the input value of `message`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-12\. Computed property example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-12](#example_03_02) has the same output as in [Figure 3-12](#figure_03_10).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also track the computed property in the Components tab of the Vue Devtools
    ([Figure 3-13](#figure_03_11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the computed properties in Components tab of the Vue Devtools](assets/lvue_0313.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13\. Computed properties `reversedMessage` in the Components tab
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similarly, you can access a computed property’s value in the component’s logic
    through the `this` instance as its local data property. You can also calculate
    a new computed property based on the computed property’s value. As [Example 3-13](#example_06_03)
    shows, we can add the length of the `reversedMessage` property value into a new
    property, `reversedMessageLength`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-13\. Adding `reversedMessageLength` computed property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Vue engine automatically caches the value of computed properties and re-computes
    the value only when related reactive data changes. As in [Example 3-12](#example_03_02),
    Vue will update the value of `reversedMessage` computed property only when `message`
    changes. If you want to display or reuse the `reversedMessage` value in another
    location within the component, Vue will not need to recalculate its value.
  prefs: []
  type: TYPE_NORMAL
- en: Using computed properties helps organize complex data modification into reusable
    data blocks. Thus, it reduces the amount of code required and keeps code clean
    while improving your component’s performance. Using computed properties also allows
    you to quickly set up an automatic watcher for any reactive data property, by
    having them appear in the implementation logic of the computed property function.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some scenarios, this automatic watcher mechanism can create overhead
    to keep the component’s performance stable. In such cases, we can consider using
    watchers through the `watch` property field of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Watchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Watchers allow you to programmatically watch for changes in any reactive data
    property of a component and handle them. Each watcher is a function that receives
    two arguments: the new value (`newValue`) and the current value (`oldValue`) of
    the observed data. It then performs any logic based on these two input parameters.
    We define a watcher for reactive data by adding it to the `watch` property field
    of the component’s options, following this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You need to replace the `reactiveDataPropertyName` with the name of the target
    component’s data that we want to observe.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-14](#example_03_07) shows how we define a new watcher to observe
    for changes in the component’s local data `message`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-14\. A watcher that observes for changes in the component’s local
    message
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have defined a `message` watcher that observes changes in
    the `message` property. The Vue engine triggers the watcher whenever the value
    of `message` changes. [Figure 3-14](#figure_03_12) shows the console log output
    for this watcher.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the console log output whenever the message changes, with
    new value first and old value second](assets/lvue_0314.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-14\. Console log output when the message changes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can implement the `reservedMessage` in [Example 3-11](#example_03_05) using
    a watcher on `message` and `data()` field instead of computed properties, as seen
    in [Example 3-15](#example_03_08).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-15\. A watcher that observes for changes in the component’s local
    message and updates the value of `reversedMessage`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output remains the same as in [Figure 3-12](#figure_03_10). However, this
    approach is not recommended in this specific case, as it is less efficient than
    using computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Side effects are any additional logic triggered by the watcher or within the
    computed property. Side effects can impact the component’s performance; you should
    handle them with caution.
  prefs: []
  type: TYPE_NORMAL
- en: You can assign the handler function directly to the watcher name. The Vue engine
    will automatically call the handler with a set of default configurations for watchers.
    However, you can also pass an object to the watcher’s name to customize the watcher’s
    behavior, using the fields in [Table 3-2](#watcher_objects_fields_table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. The watcher object’s fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Watcher’s field | Description | Accepted type | Default value | Required?
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `handler` | The callback function to trigger when the target data’s value
    changes. | function | N/A | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `deep` | Indicates whether Vue should observe for changes in the nested properties
    of the target data (if any). | boolean | `false` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `immediate` | Indicates whether to trigger the handler immediately after
    mounting the component. | boolean | `false` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `flush` | Indicates the timing order of the handler’s execution. By default,
    Vue triggers the handler before updating the Vue component. | pre, post | `pre`
    | No |'
  prefs: []
  type: TYPE_TB
- en: Observing for Changes in Nested Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `deep` option field allows you to observe changes in all nested properties.
    Take a `user` object data in a `UserWatcherComponent` component with two nested
    properties: `name` and `age`, for instance. We define a `user` watcher that observes
    for changes in the `user` object’s nested properties using the `deep` option field,
    as in [Example 3-16](#example_03_09).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-16\. A watcher that observes for changes in the user object’s nested
    properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As [Example 3-17](#example_03_10) shows, in the template section of the `UserWatcherComponent`
    component, we receive the input for the `user` object’s fields, `name` and `age`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-17\. Template section for the `UserWatcherComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the Vue engine triggers the `user` watcher whenever the value
    of `user.name` or `user.age` changes. [Figure 3-15](#figure_03_13) shows the console
    log output for this watcher when we change the value of `user.name`.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the console log output whenever the user object''s nested
    properties change, with new value first and old value second](assets/lvue_0315.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-15\. Console log output when the user object’s nested properties change
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 3-15](#figure_03_13) shows the new and old value of `user` is identical.
    This happens because the `user` object is still the same instance and only its
    `name` field’s value changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, once we turn on the `deep` flag, the Vue engine will traverse all the
    properties of the `user` object and their nested properties, then observe for
    changes in them. Thus, it may cause performance issues when the `user` object
    structure contains a more complex internal data structure. In this case, it’s
    better to specify which nested properties you wish to monitor, as shown in [Example 3-18](#example_03_11).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-18\. A watcher that observes for changes in the user’s name
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we observe changes only in `user.name` property. [Figure 3-16](#figure_03_14)
    shows the console log output for this watcher.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the console log output whenever the user object''s name
    changes, with new value first and old value second](assets/lvue_0316.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-16\. Console log outputs only when the user object’s name changes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can use the dot-delimited path approach to enable watching a specific child
    property, regardless of how deeply nested it is. For example, if the `user` has
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you need to watch for changes in `user.address.city`; you can do so
    by using *“user.address.city”* as the watcher name, and so on. By taking this
    approach, you can avoid undesired performance issues on deep watching and narrow
    the scope of the watcher to only the properties you need.
  prefs: []
  type: TYPE_NORMAL
- en: Using the this.$watch() Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, the `watch` option is enough to handle your watcher needs. However,
    there are scenarios where you don’t want to enable certain watchers when not necessary.
    For instance, you may want to enable the `user.address.city` watcher only when
    the `user` object’s `address` property is not `null`. In this case, you can use
    the `this.$watch()` method to create the watcher upon creating the component conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `this.$watch()` method accepts the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the target data to watch as a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback function as a watcher’s handler to trigger when the target data’s
    value changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.$watch()` returns a function you can call to stop the watcher. The code
    in [Example 3-19](#example_03_12) shows how to use the `this.$watch()` method
    to create a watcher that observes for changes in `user.address.city`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-19\. A watcher that observes for changes in city field in the user’s
    address
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_composing_components_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `stopWatchingAddressCity` property for storing the watcher’s return
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_composing_components_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a watcher for `user.address.city` only when the `user` object’s `address`
    object property is available.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_composing_components_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Before unmounting the component, trigger the `stopWatchingAddressCity` function
    to stop the watcher if relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, we can limit the number of unnecessary watchers created,
    such as the watcher for `user.address.city` when `user.address` doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at another interesting feature of Vue, the `slot` component.
  prefs: []
  type: TYPE_NORMAL
- en: The Power of Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a component is about more than just its data and logic. We often want
    to maintain the current component’s sense and existing design but still allow
    users to modify parts of the UI template. This flexibility is crucial when building
    a customizable component library in any framework. Fortunately, Vue offers the
    `<slot>` component to allow us to dynamically replace the default UI design for
    an element when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s build a layout component `ListLayout` to render a list
    of items, with each item having the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For each item in the list, by default, the layout component should render its
    name and description, as shown in [Example 3-20](#example_03_30).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-20\. The first template implementation of the `ListLayout` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We also define a sample list of items to render for `ListLayout` in its `script`
    section ([Example 3-21](#example_03_33)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-21\. The script section of the `ListLayout` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 3-17](#figure_03_30) shows the default rendered UI of a single item
    using the previous template ([Example 3-20](#example_03_30)) and data ([Example 3-21](#example_03_33)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the sample UI layout of the item in ListLayout component](assets/lvue_0317.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-17\. A sample UI layout of the item in the `ListLayout` component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Based on this default UI, we can then offer users an option to customize each
    item’s UI. To do so, we wrap the code block within a `li` element with a `slot`
    element, as shown in [Example 3-22](#example_03_31).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-22\. `ListLayout` component with `slot`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we bind the `item` variable received for each `v-for` iteration to
    the same `item` prop attribute of the `slot` component using `:` syntax. By doing
    so, we ensure the `slot` provides access to the same `item` data to its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `slot` component doesn’t share the same data context with its host component
    (such as `ListLayout`). If you want to access any data property of the host component,
    you need to pass it as a prop to `slot` using `v-bind` syntax. We will learn more
    about giving props to nested elements in [“Nested Components and Data Flow in
    Vue”](ch04.html#ch04_nested_components).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we need more than having `item` available for the custom template
    content to make it work. In the parent component of `ListLayout`, we add `v-slot`
    directive to `<ListLayout>` tag to get access to the `item` passed to its `slot`
    component, following the syntax below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the object destructuring syntax `{ item }` to create a scoped slot
    reference to the data property we want to access. Then we can use `item` directly
    on our custom template content, as in [Example 3-23](#example_03_32).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-23\. Compose `ProductItemList` from `ListLayout`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 3-23](#example_03_32), we change the UI to display a thumbnail image
    and the item’s name only. You can see the result in [Figure 3-21](#figure_03_16).
  prefs: []
  type: TYPE_NORMAL
- en: This example is the most straightforward use case for the `slot` component when
    we want to enable customization in a single slot in the element. But what about
    more complex scenarios like a product card component containing a thumbnail, the
    main description area, and an area of actions, each of which requires customization?
    For such a case, we still can take advantage of the power of `slot`, with naming
    capability.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the UI layout of ProductItemList component](assets/lvue_0318.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-18\. The UI layout of the `ProductItemList` component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using Named Slots with Template Tag and v-slot Attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Example 3-22](#example_03_31), we only enable customization for the UI of
    the item’s name and description as a single slot. To split the customization into
    several slot sections for a thumbnail, the main description area, and a footer
    of actions, we use `slot` with the attribute `name`, as in [Example 3-24](#example_03_34).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-24\. `ListLayout` component with named slots
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We assigned each slot with the names `thumbnail`, `main`, and `actions`, respectively.
    And for the `main` slot, we add a fallback content template to display the item’s
    name and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to pass the custom content to a specific slot, we wrap the content
    with a `template` tag. Then we pass the name declaring the desired slot (`slot-name`
    for example) to the `v-slot` directive of the `template`, following the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the shorthand syntax `#` instead of `v-slot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From here on, we will use the syntax `#` to denote `v-slot` when using with
    the `template` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like using `v-slot` on the component tag, we can also give access to the slot’s
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using multiple slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For multiple slots, you *must* use the `v-slot` directive for each relevant
    `template` tag, and *not* on the component tag. Otherwise, Vue will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our `ProductItemList` component ([Example 3-23](#example_03_32))
    and refactor the component to render the following custom content sections for
    the product item:'
  prefs: []
  type: TYPE_NORMAL
- en: A thumbnail image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action button for adding the product to the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 3-25](#example_03_35) shows how to implement that using `template`
    and `v-slot`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-25\. Compose `ProductItemList` with named slot
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code results in the output shown in [Figure 3-19](#figure_03_32).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the UI layout of ProductItemList component](assets/lvue_0319.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-19\. Output of `ProductItemList` with customized slot content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And that’s it. You are ready to use slots to customize your UI components. With
    slots, you can now create some basic standard reusable layouts for your application,
    such as a page layout with a header and footer, a side panel layout, or a modal
    component that can be a dialog or notification. You will then find how handy slots
    are in keeping your code organized and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using `slot` also means the browser won’t apply all relevant scoped styles defined
    in the component. To enable this functionality, see [“Applying Scoped Styles to
    Slot Content”](#slotted_style).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to access the mounted component instance or a DOM element
    using refs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Vue typically handles most of the DOM interactions for you, for some scenarios
    you may need to directly access a DOM element within a component for further manipulation.
    For instance, you may want to open a modal dialog when the user clicks a button
    or focus on a specific input field when mounting the component. In such cases,
    you can use the `ref` attribute to access the target DOM element instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `ref` is a Vue built-in attribute that allows you to receive a direct reference
    to a DOM element or a mounted child instance. In the `template` section, you assign
    the value of the `ref` attribute to a string representing the reference name on
    the target element. [Example 3-26](#example_03_27_1) shows how to create a `messageRef`,
    which refers to the DOM element `input`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-26\. An input component with a ref attribute assigned to `messageRef`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can then access the `messageRef` in the `script` section to manipulate the
    `input` element through a `this.$refs.messageRef` instance. The reference instance
    `messageRef` will have all the properties and methods of the `input` element.
    For instance, you can use `this.$refs.messageRef.focus()` to focus on the `input`
    element programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the ref attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ref` attribute is accessible only *after* mounting the component.
  prefs: []
  type: TYPE_NORMAL
- en: The reference instance contains all the properties and methods of a specific
    DOM element or the child component instance, depending on the target element type.
    In a scenario where you use the `ref` attribute on a looped element using `v-for`,
    the reference instance will be the array containing the looped elements without
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Take a list of tasks, for instance. As [Example 3-27](#example_03_16) shows,
    you can use the `ref` attribute to access the list of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-27\. A list of tasks with a ref attribute assigned to `taskListRef`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once Vue mounts the `TaskListComponent`, you can see the `tasksRef` contains
    three `li` DOM elements and nested in `refs` property of the component instance,
    as seen in the Vue Devtools screenshot in [Figure 3-20](#figure_03_15).
  prefs: []
  type: TYPE_NORMAL
- en: You can now use `this.$refs.tasksRef` to access the list of the task elements
    and perform further modification when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`ref` can also accept a function as its value, by adding a prefix, `:`, to
    it (`:ref`). The function accepts the reference instance as its input parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the `ref` attribute and how it can be helpful in many
    real-world challenges, such as building a reusable modal system (see [“Implementing
    a Modal with Teleport and the <dialog> Element”](ch04.html#ch04_modal_teleport)).
    The following section will explore how to create and share standard configurations
    across components with mixins.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue Devtools showing the tasksRef reference instance with three li elements](assets/lvue_0320.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-20\. Vue Devtools showing the `tasksRef` reference instance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sharing Component Configuration with Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In reality, it is not uncommon for some components to share similar data and
    behaviors, such as a cafe and a dining restaurant component. Both elements share
    the logic of making reservations and accepting payments, but each has unique features.
    In such scenarios, you can use the `mixins` property to share the standard functionalities
    across these two components.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you can create a `restaurantMixin` object that contains the standard
    functionalities of the two components, `DiningComponent` and `CafeComponent`,
    as in [Example 3-28](#example_03_17).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-28\. A `restaurantMixin` mixin object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can then use the `restaurantMixin` object in the `mixins` property of `Dining`
    `Component`, as seen in [Example 3-29](#example_03_18).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-29\. Using the `restaurantMixin` mixins property of the `DiningComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-30](#example_03_19) shows the similar `CafeComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-30\. Using the `restaurantMixin` mixins property of the `CafeComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Upon creating the components, the Vue engine will merge the mixin logic into
    the component, with the component’s data declaration taking precedence. In Examples
    [3-29](#example_03_18) and [3-30](#example_03_19), the `DiningComponent` and `CafeComponent`
    will have the same properties, `menu`, `reservations`, `payments`, and `title`,
    but with different values. Also, the methods and hooks declared in `restaurantMixin`
    will be available to both components. It is similar to the inheritance pattern,
    though the component doesn’t override the mixin hooks’ behavior. Instead, the
    Vue engine calls the mixin’s hooks first, then the component’s hooks.
  prefs: []
  type: TYPE_NORMAL
- en: When Vue mounts the `DiningComponent`, you will see the output in [Figure 3-21](#figure_03_16)
    in the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the DiningComponent showing the created hook of restaurantMixin
    called first, then the DiningComponent''s created hook](assets/lvue_0321.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-21\. Output order of console log of the `DiningComponent`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similarly, when Vue mounts the `CafeComponent`, you will see the output in [Figure 3-22](#figure_03_17)
    in the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the CafeComponent showing the created hook of restaurantMixin called
    first, then the CafeComponent''s created hook](assets/lvue_0322.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-22\. Output order of console log of the `CafeComponent`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that `title` value has changed between the two components, while Vue triggers
    the `created` hook of the `restaurantMixin` first, followed by the one declared
    on the element itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The order of merging and triggering the hooks for multiple mixins is according
    to the order of the mixins array. Vue *always* calls the component’s hooks last.
    Consider this order when putting multiple mixins together.
  prefs: []
  type: TYPE_NORMAL
- en: If you open the Vue Devtools, you will see the `restaurantMixin` is not visible,
    and the `DiningComponent` and `CafeComponent` are with their own data properties,
    as shown in Figures [3-23](#figure_03_18) and [3-24](#figure_03_19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue Devtools showing the DiningComponent](assets/lvue_0323.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-23\. Vue Devtools showing the `DiningComponent`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Vue Devtools showing the CafeComponent](assets/lvue_0324.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-24\. Vue Devtools showing the `CafeComponent`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Mixins are great for sharing common logic between components and keeping your
    code organized. However, too many mixins can confuse other developers in understanding
    and debugging, and in most cases, are considered bad practice. We recommend validating
    your use case before choosing mixins over alternatives, such as the Composition
    API ([Chapter 5](ch05.html#unique_chapter_id_06)).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have explored how to compose components’ logic using advanced
    features in `template` and `script` sections. Next, let’s learn how to make your
    component beautiful with Vue’s built-in styling features in the `style` section.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped Styling Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like a regular HTML page structure, we can define CSS stylings for an SFC component
    using the `<style>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `<style>` section usually comes last in the order of a Vue SFC component
    and can appear multiple times. Upon mounting the component to the DOM, the Vue
    engine will apply the CSS styles defined within the `<style>` tag to all the elements
    or matched DOM selectors within the application. In other words, all CSS rules
    that appeared in the `<style>` of a component apply globally once mounted. Take
    the HeadingComponent shown in [Example 3-31](#example_03_28), which renders a
    heading title with some stylings.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-31\. Using the `<style>` tag in `HeadingComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Example 3-31](#example_03_28), we created two CSS class selectors: `heading`
    and `description` for `h1` and `p` elements of the component, respectively. When
    Vue mounts the component, the browser will paint these elements with the appropriate
    styles, as seen in [Figure 3-25](#figure_03_20).'
  prefs: []
  type: TYPE_NORMAL
- en: '![The heading element has a red color and a big font size, while the description
    element has a light gray color and small font size](assets/lvue_0325.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-25\. The `HeadingComponent` with styles applied
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Example 3-32](#example_03_20) shows adding a `span` element with the same
    `heading` class selector outside `HeadingComponent` in the parent component `App.vue`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-32\. Adding the same class selector to the parent component `App.vue`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The browser then still applies the same styles to the `span` element, as shown
    in [Figure 3-26](#figure_03_21).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the span element and h1 element in the browser have red
    color and same font size](assets/lvue_0326.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-26\. The span element in `App.vue` has the same CSS styles as the `h1`
    element in the `HeadingComponent`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But if we don’t use the `HeadingComponent`, or it does not yet exist in the
    application on run-time, the `span` element will not have the CSS rules of the
    `heading` class selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid such a scenario and to have better control of style rules and selectors,
    Vue offers a unique feature, the `scoped` attribute. With the `<style scoped>`
    tag, Vue ensures the CSS rules will apply to relevant elements within the component
    and not leak them to the rest of the application. Vue achieved this mechanism
    by performing these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a randomly generated data attribute on the target element tag with the prefix
    syntax `data-v`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform the CSS selectors defined in the `<style scoped>` tag to include the
    generated data attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s see how this works in practice. In [Example 3-33](#example_03_21), we
    add the `scoped` attribute to the `<style>` tag of the `HeadingComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-33\. Adding the scoped attribute to the `<style>` tag of `HeadingComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `span` element defined in `App.vue` ([Example 3-32](#example_03_20)) will
    not have the same CSS styles as the `h1` element in `HeadingComponent`, as shown
    in [Figure 3-27](#figure_03_22).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the span element and h1 element in the browser have different
    colors and font sizes](assets/lvue_0327.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-27\. The span element in `App.vue` now has default black color
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you open the Elements tab in the browser’s Developer Tools, you can see
    the `h1` and `p` elements now have the `data-v-xxxx` attribute, as shown in [Figure 3-28](#figure_03_23).
  prefs: []
  type: TYPE_NORMAL
- en: '![The h1 and p elements in HeadingComponent have the data-v-xxxx attribute](assets/lvue_0328.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-28\. The `h1` and `p` elements in `HeadingComponent` have the `data-v-xxxx`
    attribute
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And if you select the `h1` element and look at its styles on the right panel,
    you can see that the CSS selector `.heading` has become `.heading[data-v-xxxx]`,
    as shown in [Figure 3-29](#figure_03_24).
  prefs: []
  type: TYPE_NORMAL
- en: '![The CSS selector .heading is transformed to .heading[data-v-xxxx]](assets/lvue_0329.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-29\. The CSS selector `.heading` is transformed to `.heading[data-v-xxxx]`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I strongly recommend you start working with the `scoped` attribute in your components
    as a good coding habit to avoid undesirable CSS bugs when your project grows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The browser follows [the CSS specificity](https://oreil.ly/x4iOg) when deciding
    which order to apply the styles. Because Vue’s scoped mechanism uses attribute
    selectors `[data-v-xxxx]`, using the `.heading` selector solely is not enough
    to override the component’s styles from the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Applying CSS to a Child Component in Scoped Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beginning with Vue 3.x, you can override or extend the styles of a child component
    from the parent with a scoped style by using the `:deep()` pseudo-class. For example,
    as [Example 3-34](#example_03_22) shows, we can override the scoped styles of
    paragraph element `p` in the `HeadingComponent` from its parent `App`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-34\. Overriding the scoped styles of paragraph element `p` in the
    `Heading` `Component` from its parent `App`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `p` element in the `HeadingComponent` will have the color black instead
    of its scoped color, `#b76210`, as shown in [Figure 3-30](#figure_03_25).
  prefs: []
  type: TYPE_NORMAL
- en: '![The p element in HeadingComponent has the color of black instead of its scoped
    color #b76210](assets/lvue_0330.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-30\. The p element in `HeadingComponent` has the color black
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The browser will apply the newly defined CSS rules to any `p` elements nested
    in any child component of `App` and its children.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Scoped Styles to Slot Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By design, any styles defined in the `<style scoped>` tag is relevant only to
    the component’s default `template` itself. Vue won’t be able to transform any
    slotted content to include the `data-v-xxxx` attribute. To style any slotted content,
    you can use the `:slot([CSS selector])` pseudo-class or create a dedicated `style`
    section for them on the parent level and keep the code organized.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a Component’s Data Value in Style Tag with v-bind() Pseudo-Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often need to access the component’s data value and bind that value to a
    valid CSS property, such as changing dark or light mode or theme color for an
    application based on the user’s preference. For such use cases, we use the pseudo-class
    `v-bind()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`v-bind()` accepts the component’s data property and JavaScript expressions
    as a string for its only argument. For example, we can change the color of the
    `h1` element in the `HeadingComponent` based on the value of the `titleColor`
    data property, as shown in [Example 3-35](#example_03_23).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-35\. Changing the color of the `h1` element based on the value of
    the `titleColor`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `v-bind()` pseudo-class then transforms the value of the `titleColor` data
    property into an inline hashed CSS variable, as shown in [Figure 3-31](#figure_03_26).
  prefs: []
  type: TYPE_NORMAL
- en: '![The value of the titleColor data property is now a hashed CSS property in
    inline style](assets/lvue_0331.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-31\. The value of the `titleColor` data property is now a hashed CSS
    property in inline style
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s open the Elements tab in the browser’s Developer Tools and look at the
    element’s styles. You can see the generated color property for the `.heading`
    selector remains static and has the same value as the developed hashed CSS property
    of `titleColor` ([Figure 3-32](#figure_03_27)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The generated color property for the .heading selector has the same value
    as the generated hashed CSS property of titleColor](assets/lvue_0332.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-32\. The generated color property for the .heading selector has the
    same value as the generated hashed CSS property of `titleColor`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`v-bind()` helps retrieve a component’s data value and then bind the desired
    CSS property to that dynamic value. However, this is only one-way binding. If
    you want to retrieve the defined CSS styles in the `template` for binding to the
    template’s elements, you need to use CSS Modules, which we will cover in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Styling Components with CSS Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another alternative for scoping your CSS styles per component is to use CSS
    Modules.^([1](ch03.html#id874)) CSS Modules is an approach that allows you to
    write CSS styles regularly and then consume them as a JavaScript object (*module*)
    in our `template` and `script` sections.
  prefs: []
  type: TYPE_NORMAL
- en: To start using CSS Modules in a Vue SFC Component, you need to add the `module`
    attribute to the `style` tag, as shown in our `HeadingComponent` in [Example 3-36](#example_03_24).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-36\. Using CSS Modules in `HeadingComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now you will have access to these CSS selectors as fields of a `$style` property
    object of the component. We can remove the static class names `heading` and `description`
    assigned for `h1` and `p`, respectively, in the `template` section. Instead, we
    will bind the classes of these elements to the relevant fields of the `$style`
    object ([Example 3-37](#example_03_25)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-37\. Binding classes dynamically with $style object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The output on the browser stays the same as [Figure 3-27](#figure_03_22). However,
    when looking at the relevant elements on the Elements tab in the browser’s Developer
    Tools, you will see Vue has hashed the generated class names to keep the styles
    scoped within the component, as in [Figure 3-33](#figure_03_28).
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue hashes the class names](assets/lvue_0333.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-33\. The generated class names `heading` and `description` are now
    hashed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Additionally, you can rename the CSS style object `$style` by assigning a name
    to the `module` attribute, as shown in [Example 3-38](#example_03_26).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-38\. Renaming the CSS style object $style to `headerClasses`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: And in the `template` section, you can bind the classes of the `h1` and `p`
    elements to the `headerClasses` object instead ([Example 3-39](#example_03_27)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-39\. Binding classes dynamically with `headerClasses` object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are using `<script setup>` or `setup()` function in your component ([Chapter 5](ch05.html#unique_chapter_id_06)),
    you can use the `useCssModule()` hook to access the instance of the style object.
    This function accepts the name of the style object as its only argument.
  prefs: []
  type: TYPE_NORMAL
- en: The component now has a more isolated design than when using the `scoped` attribute
    in the `style` tag. The code looks more organized, and it is more challenging
    to override this component’s styles from outside since Vue hashes the relevant
    CSS selectors randomly. Nevertheless, depending on your project’s requirements,
    one approach may be better than the other, or it might be crucial to combine both
    `scoped` and `module` attributes to achieve the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a Vue component in the SFC standard
    and use `defineComponent()` to enable TypeScript support for the Vue application
    fully. We also learned to use `slots` to create a reusable component with isolated
    styles and shared mixin configurations in different contexts. We have explored
    further composing components using the component’s lifecycle hooks, `computed`,
    `methods`, and `watch` properties in the Options API. Next, we will build on these
    foundations to create custom events and develop the interactions between components
    with the provide/inject patterns.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.html#id874-marker)) [CSS Modules](https://oreil.ly/YQ6IJ) started
    as an open source project for React.
  prefs: []
  type: TYPE_NORMAL
