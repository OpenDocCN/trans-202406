<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Interacting with Kubernetes" class="praise"><div class="dedication" id="interacting_with_kubernetes">
<h1 class="calibre14"><span class="keep-together">Chapter 3. </span>Interacting with Kubernetes</h1>


<p class="author1">As an application developer, you will want to interact with the Kubernetes cluster to manage objects that operate your application. Every call to the cluster is accepted and processed by the API server component. There are various ways to perform a call to the API server. For example, you can use a <a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" class="calibre10">web-based dashboard</a>, a command-line tool like <a href="https://kubernetes.io/docs/reference/kubectl/" class="calibre10"><code class="calibre15">kubectl</code></a>, or a direct HTTPS request to the RESTful API endpoints.</p>

<p class="author1">The exam does not test the use of a visual user interface for interacting with the Kubernetes cluster. Your only client for solving exam questions is <code class="calibre15">kubectl</code>. This chapter will touch on the Kubernetes API primitives and objects, as well as the different ways to manage objects with <code class="calibre15">kubectl</code>.</p>






<section data-type="sect1" data-pdf-bookmark="API Primitives and Objects" class="praise"><div class="dedication" id="id146">
<h1 class="calibre17">API Primitives and Objects</h1>

<p class="author1">Kubernetes primitives are the basic building blocks anchored in the Kubernetes architecture for creating and operating an application on the platform. Even as a beginner to Kubernetes, you might have heard of the terms Pod, Deployment, and Service, all of which are Kubernetes primitives. There are many more that serve a dedicated purpose in the Kubernetes architecture.</p>

<p class="author1">To draw an analogy, think back to the concepts of object-oriented programming. In object-oriented programming languages, a class defines the blueprint of a real-world functionality: its properties and behavior. A Kubernetes primitive is the equivalent of a class. The instance of a class in object-oriented programming is an object, managing its own state and having the ability to communicate with other parts of the system. Whenever you create a Kubernetes object, you produce such an instance.</p>

<p class="author1">For example, a Pod in Kubernetes is the class of which there can be many instances with their own identity. Every Kubernetes object has a system-generated unique identifier (also known as UID) to clearly distinguish between the entities of a system. Later, we’ll look at the properties of a Kubernetes object. <a data-type="xref" href="#kubernetes_object_uid" class="calibre10">Figure 3-1</a> illustrates the relationship between a Kubernetes primitive and an object.</p>

<figure class="calibre35"><div id="kubernetes_object_uid" class="figure">
<img src="Images/ckd2_0301.png" alt="ckd2 0301" class="calibre41"/>
<h6 class="calibre32"><span class="keep-together">Figure 3-1. </span>Kubernetes object identity</h6>
</div></figure>

<p class="author1">Every Kubernetes primitive follows a general structure, which you can observe if you look deeper at a manifest of an object, as shown in <a data-type="xref" href="#kubernetes_object_structure" class="calibre10">Figure 3-2</a>. The primary markup language used for a Kubernetes manifest is YAML.</p>

<figure class="calibre35"><div id="kubernetes_object_structure" class="figure">
<img src="Images/ckd2_0302.png" alt="ckd2 0302" class="calibre42"/>
<h6 class="calibre32"><span class="keep-together">Figure 3-2. </span>Kubernetes object structure</h6>
</div></figure>

<p class="author1">Let’s look at each section and its relevance within the Kubernetes system:</p>
<dl class="calibre18">
<dt class="calibre19">API version</dt>
<dd class="calibre20">
<p class="calibre21">The Kubernetes API version defines the structure of a primitive and uses it to validate the correctness of the data. The API version serves a similar purpose as XML schemas to an XML document or JSON schemas to a JSON document. The version usually undergoes a maturity process—for example, from alpha to beta to final. Sometimes you see different prefixes separated by a slash (<code class="calibre15">apps</code>). You can list the API versions compatible with your cluster version by running the command <code class="calibre15">kubectl api-versions</code>.</p>
</dd>
<dt class="calibre19">Kind</dt>
<dd class="calibre20">
<p class="calibre21">The kind defines the type of primitive—e.g., a Pod or a Service. It ultimately answers the question, “What kinds of resource are we dealing with here?”</p>
</dd>
<dt class="calibre19">Metadata</dt>
<dd class="calibre20">
<p class="calibre21">Metadata describes higher-level information about the object—e.g., its name, what namespace it lives in, or whether it defines labels and annotations. This section also defines the UID.</p>
</dd>
<dt class="calibre19">Spec</dt>
<dd class="calibre20">
<p class="calibre21">The specification (“spec” for short) declares the desired state—e.g., how should this object look after it has been created? Which image should run in the container, or which environment variables should be set?</p>
</dd>
<dt class="calibre19">Status</dt>
<dd class="calibre20">
<p class="calibre21">The status describes the actual state of an object. The Kubernetes controllers and their reconciliation loops constantly try to transition a Kubernetes object from the desired state into the actual state. The object has not yet been materialized if the YAML status shows the value <code class="calibre15">{}</code>.</p>
</dd>
</dl>

<p class="author1">With this basic structure in mind, let’s look at how to create a Kubernetes object with the help of <code class="calibre15">kubectl</code>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Using kubectl" class="praise"><div class="dedication" id="id147">
<h1 class="calibre17">Using kubectl</h1>

<p class="author1"><code class="calibre15">kubectl</code> is the primary tool for interacting with the Kubernetes clusters from the command line. The exam is exclusively focused on the use of <code class="calibre15">kubectl</code>. Therefore, it’s paramount to understand its ins and outs and practice its use heavily.</p>

<p class="author1">This section provides you with a brief overview of its typical usage pattern. Let’s start by looking at the syntax for running commands. A <code class="calibre15">kubectl</code> execution consists of a command, a resource type, a resource name, and optional command line flags:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl</strong> <em class="calibre39">[command] [TYPE] [NAME] [flags]</em>
</pre>

<p class="author1">The command specifies the operation you’re planning to run. Typical commands are verbs like <code class="calibre15">create</code>, <code class="calibre15">get</code>, <code class="calibre15">describe</code>, or <code class="calibre15">delete</code>. Next, you’ll need to provide the resource type you’re working on, either as a full resource type or its short form. For example, you could work on a <code class="calibre15">service</code> here or use the short form, <code class="calibre15">svc</code>.</p>

<p class="author1">The name of the resource identifies the user-facing object identifier, effectively the value of <code class="calibre15">metadata.name</code> in the YAML representation. Be aware that the object name is not the same as the UID. The UID is an autogenerated, Kubernetes-internal object reference that you usually don’t have to interact with. The name of an object has to be unique across all objects of the same resource type within a namespace.</p>

<p class="author1">Finally, you can provide zero to many command line flags to describe additional configuration behavior. A typical example of a command-line flag is the <code class="calibre15">--port</code> flag, which exposes a Pod’s container port.</p>

<p class="author1"><a data-type="xref" href="#kubectl_usage_pattern" class="calibre10">Figure 3-3</a> shows a full <code class="calibre15">kubectl</code> command in action.</p>

<figure class="calibre35"><div id="kubectl_usage_pattern" class="figure">
<img src="Images/ckd2_0303.png" alt="ckd2 0303" class="calibre43"/>
<h6 class="calibre32"><span class="keep-together">Figure 3-3. </span><code class="calibre15">Kubectl</code> usage pattern</h6>
</div></figure>

<p class="author1">Over the course of this book, we’ll explore the <code class="calibre15">kubectl</code> commands that will make you the most productive during the exam. There are many more, however, and they usually go beyond the ones you’d use on a day-to-day basis as an application developer. Next up, we’ll have a deeper look at the <code class="calibre15">create</code> command, the imperative way to create a Kubernetes object. We’ll also compare the imperative object creation approach with the declarative approach.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Managing Objects" class="praise"><div class="dedication" id="managing_objects">
<h1 class="calibre17">Managing Objects</h1>

<p class="author1">You can create objects in a Kubernetes cluster in two ways: imperatively or declaratively. The following sections describe each approach, including their benefits, drawbacks, and use cases.</p>








<section data-type="sect2" data-pdf-bookmark="Imperative Object Management" class="praise"><div class="dedication" id="id149">
<h2 class="calibre33">Imperative Object Management</h2>

<p class="author1">Imperative object management does not require a manifest definition. You’ll use <code class="calibre15">kubectl</code> to drive the creation, modification, and deletion of objects with a single command and one or many command-line options. See the <a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/imperative-command/" class="calibre10">Kubernetes documentation</a> for a more detailed description of imperative object management.</p>










<section data-type="sect3" data-pdf-bookmark="Creating objects" class="praise"><div class="dedication" id="id150">
<h3 class="calibre44">Creating objects</h3>

<p class="author1">Use the <code class="calibre15">run</code> or <code class="calibre15">create</code> command to create an object on the fly. Any configuration needed at runtime is provided by command-line options. The benefit of this approach is the fast turnaround time without the need to wrestle with YAML structures. The following <code class="calibre15">run</code> command creates a Pod named <code class="calibre15">frontend</code> that executes the container image <code class="calibre15">nginx:1.24.0</code> in a container with the exposed port 80:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run frontend --image=nginx:1.24.0 --port=80</strong>
pod/frontend created
</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Updating objects" class="praise"><div class="dedication" id="id151">
<h3 class="calibre44">Updating objects</h3>

<p class="author1">The configuration of live objects can still be modified. <code class="calibre15">kubectl</code> supports this use case by providing the <code class="calibre15">edit</code> or <code class="calibre15">patch</code> command.</p>

<p class="author1">The <code class="calibre15">edit</code> command opens an editor with the raw configuration of the live object. Changes to the configuration will be applied to the live object after exiting the editor. The command will open the editor defined by the <code class="calibre15">KUBE_EDITOR</code>, or <code class="calibre15">EDITOR</code> environment variables, or fall back to <code class="calibre15">vi</code> for Linux or <code class="calibre15">notepad</code> for Windows. This command demonstrates the use of the <code class="calibre15">edit</code> command for the Pod live object named <code class="calibre15">frontend</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl edit pod frontend</strong>
</pre>

<p class="author1">The <code class="calibre15">patch</code> command allows for fine-grained modification of a live object on an attribute level using a JSON merge patch. The following example illustrates the use of <code class="calibre15">patch</code> command to update the container image tag assigned to the Pod created earlier. The <code class="calibre15">-p</code> flag defines the JSON structure used to modify the live object:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl patch pod frontend -p '{"spec":{"containers":[{"name":"frontend",\
"image":"nginx:1.25.1"}]}}'</strong>
pod/frontend patched
</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Deleting objects" class="praise"><div class="dedication" id="imperative-deleting-objects">
<h3 class="calibre44">Deleting objects</h3>

<p class="author1">You can delete a Kubernetes object at any time. During the exam, the need may arise if you made a mistake while solving a problem and want to start from scratch to ensure a clean slate. In a production Kubernetes environment, you’ll want to delete objects that are no longer needed. The following <code class="calibre15">delete</code> command deletes the Pod object by its name <code class="calibre15">frontend</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl delete pod frontend</strong>
pod "frontend" deleted
</pre>

<p class="author1">Upon execution of the <code class="calibre15">delete</code> command, Kubernetes tries to delete the targeted object gracefully so that there’s minimal impact on the end user. If the object cannot be deleted within the default grace period (30 seconds), the kubelet attempts to forcefully kill the object.</p>

<p class="author1">During the exam, end user impact is not a concern. The most important goal is to complete all tasks in the time granted to the candidate. Therefore, waiting on an object to be deleted gracefully is a waste of time. You can force an immediate deletion of an object with the command-line option with the <code class="calibre15">--now</code> option. The following command kills the Pod named <code class="calibre15">nginx</code> using a <code class="calibre15">SIGKILL</code> signal:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl delete pod nginx --now</strong>
</pre>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Declarative Object Management" class="praise"><div class="dedication" id="id153">
<h2 class="calibre33">Declarative Object Management</h2>

<p class="author1">Declarative object management requires one or several manifests in the format of YAML or JSON describing the desired state of an object. You create, update, and delete objects using this approach.</p>

<p class="author1">The benefit of using the declarative method is reproducibility and improved maintenance, as the file is checked into version control in most cases. The declarative approach is the recommended way to create objects in production environments.</p>

<p class="author1">More information on declarative object management can be found in the <a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/" class="calibre10">Kubernetes documentation</a>.</p>










<section data-type="sect3" data-pdf-bookmark="Creating objects" class="praise"><div class="dedication" id="id154">
<h3 class="calibre44">Creating objects</h3>

<p class="author1">The declarative approach creates objects from a manifest (in most cases, a YAML file) using the <code class="calibre15">apply</code> command. The command works by pointing to a file, a directory of files, or a file referenced by an HTTP(S) URL using the <code class="calibre15">-f</code> option. If one or more of the objects already exist, the command will synchronize the changes made to the configuration with the live object.</p>

<p class="author1">To demonstrate the functionality, we’ll assume the following directories and configuration files. The following commands create objects from a single file, from all files within a directory, and from all files in a directory recursively. Refer to files in the book’s GitHub repository if you want to give it a try. Later chapters will explain the purpose of the primitives used here:</p>

<pre data-type="programlisting" class="calibre37">.
├── app-stack
│   ├── mysql-pod.yaml
│   ├── mysql-service.yaml
│   ├── web-app-pod.yaml
│   └── web-app-service.yaml
├── nginx-deployment.yaml
└── web-app
    ├── config
    │   ├── db-configmap.yaml
    │   └── db-secret.yaml
    └── web-app-pod.yaml</pre>

<p class="author1">Creating an object from a single file:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f nginx-deployment.yaml</strong>
deployment.apps/nginx-deployment created
</pre>

<p class="author1">Creating objects from multiple files within a directory:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f app-stack/</strong>
pod/mysql-db created
service/mysql-service created
pod/web-app created
service/web-app-service created
</pre>

<p class="author1">Creating objects from a recursive directory tree containing files:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f web-app/ -R</strong>
configmap/db-config configured
secret/db-creds created
pod/web-app created
</pre>

<p class="author1">Creating objects from a file referenced by an HTTP(S) URL:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f https://raw.githubusercontent.com/bmuschko/\
ckad-study-guide/master/ch03/object-management/nginx-deployment.yaml</strong>
deployment.apps/nginx-deployment created
</pre>

<p class="author1">The <code class="calibre15">apply</code> command keeps track of the changes by adding or modifying the annotation with the key <code class="calibre15">kubectl.kubernetes.io/last-applied-configuration</code>. Here’s an example of the annotation in the output of the <code class="calibre15">get pod</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pod web-app -o yaml</strong>
apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{}, \
      "labels":{"app":"web-app"},"name":"web-app","namespace":"default"}, \
      "spec":{"containers":[{"envFrom":[{"configMapRef":{"name":"db-config"}}, \
      {"secretRef":{"name":"db-creds"}}],"image":"bmuschko/web-app:1.0.1", \
      "name":"web-app","ports":[{"containerPort":3000,"protocol":"TCP"}]}], \
      "restartPolicy":"Always"}}
...
</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Updating objects" class="praise"><div class="dedication" id="id155">
<h3 class="calibre44">Updating objects</h3>

<p class="author1">Updating an existing object is done with the same <code class="calibre15">apply</code> command. All you need to do is to change the configuration file and then run the command against it. <a data-type="xref" href="#modified_configuration_file_deployment" class="calibre10">Example 3-1</a> modifies the existing configuration of a Deployment in the file <code class="calibre15">nginx-deployment.yaml</code>. We added a new label with the key team and changed the number of replicas from 3 to 5.</p>
<div id="modified_configuration_file_deployment" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 3-1. </span>Modified configuration file for a Deployment</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">apps/v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Deployment</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx-deployment</code><code class="w"></code>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code>
<code class="w">    </code><code class="nt">team</code><code class="p">:</code><code class="w"> </code><code class="calibre15">red</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="calibre15">5</code><code class="w"></code>
<code class="p">...</code><code class="w"></code></pre></div>

<p class="author1">The following command applies the changed configuration file. As a result, the number of Pods controlled by the underlying ReplicaSet is 5:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f nginx-deployment.yaml</strong>
deployment.apps/nginx-deployment configured
</pre>

<p class="author1">The Deployment’s <code class="calibre15">kubectl.kubernetes.io/last-applied-configuration</code> annotation reflects the latest change to the configuration:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get deployment nginx-deployment -o yaml</strong>
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"apps/v1","kind":"Deployment","metadata":{"annotations":{}, \
      "labels":{"app":"nginx","team":"red"},"name":"nginx-deployment", \
      "namespace":"default"},"spec":{"replicas":5,"selector":{"matchLabels": \
      {"app":"nginx"}},"template":{"metadata":{"labels":{"app":"nginx"}}, \
      "spec":{"containers":[{"image":"nginx:1.14.2","name":"nginx", \
      "ports":[{"containerPort":80}]}]}}}}
...
</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Deleting objects" class="praise"><div class="dedication" id="id156">
<h3 class="calibre44">Deleting objects</h3>

<p class="author1">While you can delete objects using the <code class="calibre15">apply</code> command by providing the options 
<span class="keep-together"><code class="calibre15">--prune -l &lt;labels&gt;</code>,</span> it is recommended to delete an object using the <code class="calibre15">delete</code> command and point it to the configuration file. The following command deletes a Deployment and the objects it controls (ReplicaSet and Pods):</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl delete -f nginx-deployment.yaml</strong>
deployment.apps "nginx-deployment" deleted
</pre>

<p class="author1">You can use the <code class="calibre15">--now</code> option to forcefully delete Pods, as described in <a data-type="xref" href="#imperative-deleting-objects" class="calibre10">“Deleting objects”</a>.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Hybrid Approach" class="praise"><div class="dedication" id="id157">
<h2 class="calibre33">Hybrid Approach</h2>

<p class="author1">Sometimes you may want to go with a hybrid approach. You can start by using the imperative method to produce a manifest file without actually creating an object. You do so by executing the <code class="calibre15">run</code> or <code class="calibre15">create</code> command with the command-line options <code class="calibre15">-o yaml</code> and <code class="calibre15">--dry-run=client</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run frontend --image=nginx:1.25.1 --port=80 \
  -o yaml --dry-run=client &gt; pod.yaml</strong>
</pre>

<p class="author1">You can now use the generate YAML manifest as a starting point to make further modifications before creating the object. Simply open the file with an editor, change the content, and execute the declarative <code class="calibre15">apply</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ vim pod.yaml</strong>
<strong class="calibre38">$ kubectl apply -f pod.yaml</strong>
pod/frontend created
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Which Approach to Use?" class="praise"><div class="dedication" id="id158">
<h2 class="calibre33">Which Approach to Use?</h2>

<p class="author1">During the exam, using imperative commands is the most efficient and quick way to manage objects. Not all configuration options are exposed through command-line flags, which may force you into using the declarative approach. The hybrid approach can help here.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">GitOps and Kubernetes</h1>
<p class="author1">GitOps is a practice that leverages source code checked into Git repositories to automate infrastructure management, specifically in cloud-native environments powered by Kubernetes. Tools such as <a href="https://argo-cd.readthedocs.io/en/stable/" class="calibre10">Argo CD</a> and <a href="https://fluxcd.io/" class="calibre10">Flux</a> implement GitOps principles to deploy applications to Kubernetes through a declarative approach. Teams responsible for overseeing real-world Kubernetes clusters and the applications within them are highly likely to adopt the declarative approach.</p>
</div>

<p class="author1">While creating objects imperatively can optimize the turnaround time, in a real-world Kubernetes environment you’ll most certainly want to use the declarative approach. A YAML manifest file represents the ultimate source of truth of a Kubernetes object. Version-controlled files can be audited and shared, and they store a history of changes in case you need to revert to a previous revision.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id159">
<h1 class="calibre17">Summary</h1>

<p class="author1">Kubernetes represents its functionality for deploying and operating a cloud-native application with the help of primitives. Each primitive follows a general structure: the API version, the kind, the metadata, and the desired state of the resources, also called the spec. Upon creation or modification of the object, the Kubernetes scheduler automatically tries to ensure that the actual state of the object follows the defined specification. Every live object can be inspected, edited, and deleted.</p>

<p class="author1"><code class="calibre15">Kubectl</code> acts as a CLI-based client to interact with the Kubernetes cluster. You can use its commands and flags to manage Kubernetes objects. The imperative approach provides a fast turnaround time for managing objects with a single command, as long as you memorize the available flags. More complex configuration calls for the use of a YAML manifest to define a primitive. Use the declarative command to instantiate objects from that definition. The YAML manifest is usually checked into version control and offers a way to track changes to the configuration.</p>
</div></section>
</div></section></div></body>
</html>