<html><head></head><body><section data-pdf-bookmark="Chapter 7. Advanced Rendering, Dynamic Components, and Plugin Composition" data-type="chapter" epub:type="chapter"><div class="chapter" id="unique_chapter_id_02_1">&#13;
<h1><span class="label">Chapter 7. </span>Advanced Rendering, Dynamic Components, and Plugin Composition</h1>&#13;
&#13;
&#13;
<p>In the previous chapters, you learned how Vue works, how to compose components with Options API and Composition API, and how to incorporate data from an external resource into your Vue application using Axios.</p>&#13;
&#13;
<p>This chapter will introduce a more advanced aspect of rendering in Vue. We will explore how to compute functional components using the rendering function and JSX and how to dynamically and conditionally render elements using Vue’s component tag. We will also learn how to register a custom plugin for use within the &#13;
<span class="keep-together">application</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Render Function and JSX" data-type="sect1"><div class="sect1" id="render_function">&#13;
<h1>The Render Function and JSX</h1>&#13;
&#13;
<p>With the Vue compiler API, Vue processes and compiles all the HTML templates used for a Vue component into the Virtual DOM upon rendering. When data of a Vue component are updated, Vue triggers the internal render function to send the latest value to the Virtual DOM<a data-primary="Options API" data-secondary="template property" data-type="indexterm" id="id1149"/><a data-primary="rendering" data-secondary="with template" data-secondary-sortas="template" data-type="indexterm" id="id1150"/><a data-primary="template property" data-type="indexterm" id="id1151"/><a data-primary="rendering" data-secondary="with render()" data-secondary-sortas="render()" data-type="indexterm" id="ix-comp-adv1"/><a data-primary="DOM (Document Object Model)" data-secondary="render() and" data-type="indexterm" id="ix-comp-adv1a"/><a data-primary="render()" data-secondary="DOM and" data-type="indexterm" id="ix-comp-adv1b"/>.</p>&#13;
&#13;
<p>Using <code>template</code> is the most common approach to creating a component. However, we need to bypass the HTML template parser process in specific scenarios, such as optimizing performance, working on a server-side rendering application, or working on a dynamic component library. By returning the rendered virtual node from the Virtual DOM directly and skipping the template compiling process, <code>render()</code> is the solution for such cases.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the Render Function" data-type="sect2"><div class="sect2" id="id80">&#13;
<h2>Using the Render Function</h2>&#13;
&#13;
<p>In Vue 2, the <code>render()</code> function property receives a <code>createElement</code> callback parameter. It returns a valid VNode<sup><a data-type="noteref" href="ch07.html#id1152" id="id1152-marker">1</a></sup> by triggering <code>createElement</code> with the appropriate arguments. We usually denote <code>createElement</code> as an <code>h</code> function.<sup><a data-type="noteref" href="ch07.html#id1153" id="id1153-marker">2</a></sup></p>&#13;
&#13;
<p><a data-type="xref" href="#example_render_2">Example 7-1</a> illustrates creating a component in Vue 2 syntax.</p>&#13;
<div data-type="example" id="example_render_2">&#13;
<h5><span class="label">Example 7-1. </span>Use the render function in Vue 2</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">render</code><code class="p">(</code><code class="nx">h</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">h</code><code class="p">(</code>&#13;
   <code class="s1">'div'</code><code class="p">,</code>&#13;
   <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'test-id'</code> <code class="p">},</code>&#13;
   <code class="s1">'This is a render function test with Vue'</code>&#13;
  <code class="p">)</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>This code equals writing the following template code<a data-primary="h()" data-secondary="using" data-type="indexterm" id="ix-comp-adv2"/><a data-primary="VNode" data-secondary="render()" data-type="indexterm" id="ix-comp-adv2a"/><a data-primary="components" data-secondary="render() syntax" data-type="indexterm" id="id1154"/><a data-primary="createElement" data-type="indexterm" id="id1155"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`&lt;div id='test-id'&gt;This is a render function test with Vue&lt;/div&gt;`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In Vue 3, the syntax of <code>render</code> changes significantly. It no longer accepts an <code>h</code> function as a parameter. Instead, the <code>vue</code> package exposes a global function, <code>h</code>, for creating VNodes. Hence, we can rewrite the code in <a data-type="xref" href="#example_render_2">Example 7-1</a> to that shown in <a data-type="xref" href="#example_render_3">Example 7-2</a>.</p>&#13;
<div data-type="example" id="example_render_3">&#13;
<h5><span class="label">Example 7-2. </span>Use the render function in Vue 3</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="nx">h</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">h</code><code class="p">(</code>&#13;
   <code class="s1">'div'</code><code class="p">,</code>&#13;
   <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'test-id'</code> <code class="p">},</code>&#13;
   <code class="s1">'This is a render function test with Vue'</code>&#13;
  <code class="p">)</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>The output stays the same.</p>&#13;
<div data-type="tip"><h1>Supporting Multi-Root Nodes with the Render Function</h1>&#13;
<p>Since Vue 3 supports multiple root nodes for a component template, <code>render()</code> can return an array of VNodes, each of which will be injected into the DOM at the same level as the others<a data-primary="root nodes and render()" data-type="indexterm" id="id1156"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the h Function to Create a VNode" data-type="sect2"><div class="sect2" id="id149">&#13;
<h2>Using the h Function to Create a VNode</h2>&#13;
&#13;
<p>Vue designs the <code>h</code> function to be very flexible with three input parameters in different types, as shown in <a data-type="xref" href="#table_param_render">Table 7-1</a><a data-primary="components" data-secondary="h() function parameter" data-type="indexterm" id="id1157"/><a data-primary="h()" data-secondary="parameters table" data-type="indexterm" id="id1158"/><a data-primary="nested components" data-secondary="h() function parameter" data-type="indexterm" id="id1159"/><a data-primary="props" data-secondary="h() function parameter" data-type="indexterm" id="id1160"/>.</p>&#13;
<table id="table_param_render">&#13;
<caption><span class="label">Table 7-1. </span>Different parameters for the h function</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Parameter</th>&#13;
<th>Required?</th>&#13;
<th>Acceptable data type</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Component</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>String, object, or function</p></td>&#13;
<td><p>It accepts a string as a text or HTML tag element, a component function, or an options object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>props</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>Object</p></td>&#13;
<td><p>This object contains all components’ <code>props</code>, attributes, and events received from its parent, similar to how we write in the <code>template</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Nested children</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>String, array, or object</p></td>&#13;
<td><p>This parameter includes a list of VNodes, or a string for a text-only component, or an object with different <code>slots</code> (see <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a>) as children for the component.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The syntax of the <code>h</code> function is as follows:</p>&#13;
&#13;
<pre data-type="programlisting">h(component, { /*props*/ }, children)</pre>&#13;
&#13;
<p>For example, we want to create a component that uses a <code>div</code> tag as a root element and has a <code>id</code>, an inline border style, and one input child element. We can call <code>h</code> as in this code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">inputElem</code> <code class="o">=</code> <code class="nx">h</code><code class="p">(</code>&#13;
 <code class="s1">'input'</code><code class="p">,</code>&#13;
 <code class="p">{</code>&#13;
  <code class="nx">placeholder</code><code class="o">:</code> <code class="s1">'Enter some text'</code><code class="p">,</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s1">'text'</code><code class="p">,</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="s1">'text-input'</code>&#13;
 <code class="p">})</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">comp</code> <code class="o">=</code> <code class="nx">h</code><code class="p">(</code>&#13;
 <code class="s1">'div'</code><code class="p">,</code>&#13;
 <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="s1">'my-test-comp'</code><code class="p">,</code>&#13;
  <code class="nx">style</code><code class="o">:</code> <code class="p">{</code> <code class="nx">border</code><code class="o">:</code> <code class="s1">'1px solid blue'</code> <code class="p">}</code>&#13;
 <code class="p">},</code>&#13;
 <code class="nx">inputElem</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p class="pagebreak-before">In the actual DOM, the output of the component will be:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code> <code class="na">id</code><code class="o">=</code><code class="s">"my-test-comp"</code> <code class="na">style</code><code class="o">=</code><code class="s">"border: 1px solid blue;"</code><code class="p">&gt;</code>&#13;
 Text input&#13;
 <code class="p">&lt;</code><code class="nt">input</code> <code class="na">placeholder</code><code class="o">=</code><code class="s">"Enter some text"</code> <code class="na">type</code><code class="o">=</code><code class="s">"text"</code> <code class="na">id</code><code class="o">=</code><code class="s">"text-input"</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>You can play with the following complete working code and experiment with different configurations for the <code>h</code> function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="nx">h</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">inputElem</code> <code class="o">=</code> <code class="nx">h</code><code class="p">(</code>&#13;
 <code class="s1">'input'</code><code class="p">,</code>&#13;
 <code class="p">{</code>&#13;
  <code class="nx">placeholder</code><code class="o">:</code> <code class="s1">'Enter some text'</code><code class="p">,</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s1">'text'</code><code class="p">,</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="s1">'text-input'</code>&#13;
 <code class="p">})</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">comp</code> <code class="o">=</code> <code class="nx">h</code><code class="p">(</code>&#13;
 <code class="s1">'div'</code><code class="p">,</code>&#13;
 <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="s1">'my-test-comp'</code><code class="p">,</code>&#13;
  <code class="nx">style</code><code class="o">:</code> <code class="p">{</code> <code class="nx">border</code><code class="o">:</code> <code class="s1">'1px solid blue'</code> <code class="p">}</code>&#13;
 <code class="p">},</code>&#13;
 <code class="nx">inputElem</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">comp</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s2">"#app"</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing JavaScript XML in the Render Function" data-type="sect2"><div class="sect2" id="id81">&#13;
<h2>Writing JavaScript XML in the Render Function</h2>&#13;
&#13;
<p>JavaScript XML (JSX) is a JavaScript extension introduced by the React framework to allow developers to write HTML code within JavaScript. HTML and JavaScript code in a JSX format looks like this<a data-primary="" data-startref="ix-comp-adv2" data-type="indexterm" id="id1161"/><a data-primary="" data-startref="ix-comp-adv2a" data-type="indexterm" id="id1162"/><a data-primary="components" data-secondary="JSX" data-type="indexterm" id="id1163"/><a data-primary="JSX" data-secondary="render() and" data-type="indexterm" id="id1164"/><a data-primary="JavaScript" data-secondary="JSX and render()" data-type="indexterm" id="id1165"/><a data-primary="render()" data-secondary="JSX and" data-type="indexterm" id="id1166"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">JSXComp</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">This</code> <code class="nx">is</code> <code class="nx">a</code> <code class="nx">JSX</code> <code class="nx">component</code><code class="o">&lt;</code><code class="err">/div&gt;</code></pre>&#13;
&#13;
<p>The previous code outputs a component that renders a <code>div</code> tag with the text “This is a JSX component.” All that’s left to do is to return this component in the render function directly:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="nx">h</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">JSXComp</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">This</code> <code class="nx">is</code> <code class="nx">a</code> <code class="nx">JSX</code> <code class="nx">component</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">JSXComp</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s2">"#app"</code><code class="p">)</code></pre>&#13;
&#13;
<p>Vue 3.0 supports writing with JSX out of the box. The syntax for JSX is different from the Vue template. To bind a dynamic data, we use single curly braces <code>{}</code>, as in <a data-type="xref" href="#jsx_ex">Example 7-3</a><a data-primary="{} (curly braces)" data-secondary="binding data with JSX" data-type="indexterm" id="id1167"/><a data-primary="curly braces ({})" data-secondary="binding data with JSX" data-type="indexterm" id="id1168"/><a data-primary="bindings" data-secondary="with JSX and render()" data-secondary-sortas="JSX and render()" data-type="indexterm" id="id1169"/><a data-primary="JSX" data-secondary="syntax" data-type="indexterm" id="id1170"/><a data-primary="data" data-secondary="binding with JSX and render()" data-type="indexterm" id="id1171"/>.</p>&#13;
<div data-type="example" id="jsx_ex">&#13;
<h5><span class="label">Example 7-3. </span>Writing a simple Vue component using JSX</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="nx">h</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s1">'JSX'</code>&#13;
<code class="kr">const</code> <code class="nx">JSXComp</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">This</code> <code class="nx">is</code> <code class="nx">a</code> <code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="nx">component</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">JSXComp</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s2">"#app"</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>We bind dynamic data with the same approach. There is no need to wrap the expression with <code>''</code>. The following example shows how we attach a value to the <code>id</code> attribute of the <code>div</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**... */</code>&#13;
<code class="kr">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="s1">'jsx-comp'</code>&#13;
<code class="kr">const</code> <code class="nx">JSXComp</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">id</code><code class="o">=</code><code class="p">{</code><code class="nx">id</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">This</code> <code class="nx">is</code> <code class="nx">a</code> <code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="nx">component</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
<code class="cm">/**... */</code></pre>&#13;
&#13;
<p>However, unlike JSX in React, we don’t transform attributes such as <code>class</code> to <code>className</code> with Vue. Instead, we keep these attributes’ original syntax. The same goes for elements’ event listeners (<code>onclick</code> instead of <code>onClick</code> in React, etc.).</p>&#13;
&#13;
<p>You can also register a JSX component as part of <code>components</code> like other Vue components written in Options API. It can be handy in combining with the <code>render</code> function in writing dynamic components and offers better readability in many cases<a data-primary="components" data-secondary="registering JSX" data-type="indexterm" id="id1172"/><a data-primary="JSX" data-secondary="registering JSX components" data-type="indexterm" id="id1173"/>.</p>&#13;
&#13;
<p>Next, we will discuss how we can write a functional component<a data-primary="" data-startref="ix-comp-adv1" data-type="indexterm" id="id1174"/><a data-primary="" data-startref="ix-comp-adv1a" data-type="indexterm" id="id1175"/><a data-primary="" data-startref="ix-comp-adv1b" data-type="indexterm" id="id1176"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Component" data-type="sect1"><div class="sect1" id="id82">&#13;
<h1>Functional Component</h1>&#13;
&#13;
<p>A functional component is a stateless component and bypasses the typical component lifecycle. Unlike a standard component, which works with Options API, a functional component is a function, denoting the render function for that component<a data-primary="components" data-secondary="functional" data-type="indexterm" id="ix-comp-adv3"/><a data-primary="functional components" data-type="indexterm" id="ix-comp-adv3a"/><a data-primary="functions" data-secondary="functional components" data-type="indexterm" id="ix-comp-adv3b"/>.</p>&#13;
&#13;
<p>Since it is a stateless component, there is no access to the <code>this</code> instance. Instead, Vue exposes the component’s external <code>props</code> and <code>context</code> as function arguments. The functional component must return a virtual node instance created using the global function <code>h()</code> from the <code>vue</code> package. Hence, the syntax will be<a data-primary="props" data-secondary="functional components and" data-type="indexterm" id="id1177"/><a data-primary="context" data-secondary="functional components and" data-type="indexterm" id="id1178"/><a data-primary="h()" data-secondary="functional components and" data-type="indexterm" id="id1179"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">h</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">MyFunctionComp</code><code class="p">(</code><code class="nx">props</code><code class="p">,</code> <code class="nx">context</code><code class="p">)</code> <code class="p">{</code>&#13;
 <code class="k">return</code> <code class="nx">h</code><code class="p">(</code><code class="cm">/* render function argument */</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>context</code> exposes the component’s context properties, including <code>emits</code> for the component’s event emitters, <code>attrs</code> for passed attributes to the component from the parent, and <code>slots</code> containing the component’s nested elements<a data-primary="emits" data-secondary="functional components and" data-type="indexterm" id="id1180"/><a data-primary="attrs, functional components and" data-type="indexterm" id="id1181"/><a data-primary="emitters, event" data-secondary="functional components and" data-type="indexterm" id="id1182"/><a data-primary="slots" data-secondary="functional components and" data-type="indexterm" id="id1183"/>.</p>&#13;
&#13;
<p>For example, the functional component <code>myHeading</code> displays any text passed to it within a heading element. We give the heading’s level as <code>level</code> props. If we want to display the text “Hello World” as heading level 2 (<code>&lt;h2&gt;</code>), we use <code>myHeading</code> as follows:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">my-heading</code> <code class="na">level</code><code class="o">=</code><code class="s">"2"</code><code class="p">&gt;</code>Hello World<code class="p">&lt;/</code><code class="nt">my-heading</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>And the output should be:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">h2</code><code class="p">&gt;</code>Hello World<code class="p">&lt;/</code><code class="nt">h2</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>To do this, we use the render function <code>h</code> from the <code>vue</code> package and perform the code shown in <a data-type="xref" href="#heading_two">Example 7-4</a>.</p>&#13;
<div data-type="example" id="heading_two">&#13;
<h5><span class="label">Example 7-4. </span>Using the <code>h</code> function to create a custom heading component</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">h</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">MyHeading</code><code class="p">(</code><code class="nx">props</code><code class="p">,</code> <code class="nx">context</code><code class="p">)</code> <code class="p">{</code>&#13;
 <code class="kr">const</code> <code class="nx">heading</code> <code class="o">=</code> <code class="sb">`h</code><code class="si">${</code><code class="nx">props</code><code class="p">.</code><code class="nx">level</code><code class="si">}</code><code class="sb">`</code>&#13;
&#13;
 <code class="k">return</code> <code class="nx">h</code><code class="p">(</code><code class="nx">heading</code><code class="p">,</code> <code class="nx">context</code><code class="p">.</code><code class="nx">$attrs</code><code class="p">,</code> <code class="nx">context</code><code class="p">.</code><code class="nx">$slots</code><code class="p">);</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Vue will skip the template render process for the functional component and add the virtual node declaration directly to its renderer pipeline. This mechanism results in no nested slots or attributes available for functional components<a data-primary="VNode" data-secondary="functional components" data-type="indexterm" id="id1184"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Props and Emits for Functional Component" data-type="sect1"><div class="sect1" id="id83">&#13;
<h1>Defining Props and Emits for Functional Component</h1>&#13;
&#13;
<p>You can explicitly define the functional component’s acceptable <code>props</code> and <code>emits</code> by following the syntax:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">MyFunctionComp</code><code class="p">.</code><code class="nx">props</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'prop-one'</code><code class="p">,</code> <code class="s1">'prop-two'</code><code class="p">]</code>&#13;
<code class="nx">MyFunctionComp</code><code class="p">.</code><code class="nx">emits</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'event-one'</code><code class="p">,</code> <code class="s1">'event-two'</code><code class="p">]</code></pre>&#13;
&#13;
<p>Without defining, <code>context.props</code> will have the same value as <code>context.attrs</code>, containing all the attributes passed to the component.</p>&#13;
&#13;
<p>A functional component is powerful when you want to control how to render your component programmatically, especially for component library authors who need to provide low-level flexibility for their components for users’ requirements.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Vue 3 offers an additional way to write components using <code>&lt;script setup&gt;</code>. This is relevant only if you write components in <em>SFC</em> format, discussed in <a data-type="xref" href="ch03.html#setup_hook_03">“setup”</a><a data-primary="setup hook" data-secondary="functional components" data-type="indexterm" id="id1185"/><a data-primary="SFC (Single-File Component)" data-secondary="functional components" data-type="indexterm" id="id1186"/>.</p>&#13;
</div>&#13;
&#13;
<p>Next, we will explore how to add external functionality to a Vue application using plugins<a data-primary="" data-startref="ix-comp-adv3" data-type="indexterm" id="id1187"/><a data-primary="" data-startref="ix-comp-adv3a" data-type="indexterm" id="id1188"/><a data-primary="" data-startref="ix-comp-adv3b" data-type="indexterm" id="id1189"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding Custom Functionality Globally with Vue Plugins" data-type="sect1"><div class="sect1" id="id84">&#13;
<h1>Adding Custom Functionality Globally with Vue Plugins</h1>&#13;
&#13;
<p>We use plugins to add third-party libraries or extra custom functionality for global usage in our Vue application. A Vue plugin is an object that exposes a single method, <code>install()</code>, containing the logic code, and it is responsible for installing the plugin itself. Here is an example plugin<a data-primary="install()" data-secondary="plugins" data-type="indexterm" id="ix-comp-adv4"/><a data-primary="installing" data-secondary="plugins" data-type="indexterm" id="ix-comp-adv4a"/><a data-primary="plugins" data-secondary="adding" data-type="indexterm" id="ix-comp-adv4b"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/* plugins/samplePlugin.ts */</code>&#13;
<code class="kr">import</code> <code class="nx">type</code> <code class="p">{</code> <code class="nx">App</code>  <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="p">{</code>&#13;
 <code class="nx">install</code><code class="p">(</code><code class="nx">app</code><code class="o">:</code> <code class="nx">App</code><code class="o">&lt;</code><code class="nx">Element</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">options</code><code class="o">:</code> <code class="nb">Object</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Installation logic</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this code, we define our sample plugin code within the <code>samplePlugin</code> file, located in the <code>plugins</code> directory. <code>install()</code> receives two argument: an <code>app</code> instance, and some <code>options</code> as the plugin’s configurations.</p>&#13;
&#13;
<p>For example, let’s compose a <code>truncate</code> plugin that will add a new global function property, <code>$truncate</code>. <code>$truncate</code>  will return a truncated string if its length is over <code>options.limit</code> characters, as shown in <a data-type="xref" href="#truncate_code">Example 7-5</a>.</p>&#13;
<div data-type="example" id="truncate_code">&#13;
<h5><span class="label">Example 7-5. </span>Compose a truncate plugin</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/* plugins/truncate.ts */</code>&#13;
<code class="kr">import</code> <code class="nx">type</code> <code class="p">{</code> <code class="nx">App</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="p">{</code>&#13;
  <code class="nx">install</code><code class="p">(</code><code class="nx">app</code><code class="o">:</code> <code class="nx">App</code><code class="o">&lt;</code><code class="nx">Element</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">options</code><code class="o">:</code> <code class="p">{</code> <code class="nx">limit</code><code class="o">:</code> <code class="nx">number</code> <code class="p">})</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">truncate</code> <code class="o">=</code> <code class="p">(</code><code class="nx">str</code><code class="o">:</code> <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="nx">options</code><code class="p">.</code><code class="nx">limit</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">str</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="nx">options</code><code class="p">.</code><code class="nx">limit</code><code class="p">)</code><code class="si">}</code><code class="sb">...`</code><code class="p">;</code>&#13;
      <code class="p">}</code>&#13;
&#13;
      <code class="k">return</code> <code class="nx">str</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">app</code><code class="p">.</code><code class="nx">config</code><code class="p">.</code><code class="nx">globalProperties</code><code class="p">.</code><code class="nx">$truncate</code> <code class="o">=</code> <code class="nx">truncate</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>To use this plugin in our application, we call the <code>app.use()</code> method on the created <code>app</code> instance in the <code>main.ts</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/* main.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
<code class="kr">import</code> <code class="nx">truncate</code> <code class="nx">from</code> <code class="s1">'./plugins/truncate'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">//1. Create the app instance</code>&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">);</code>&#13;
&#13;
<code class="c1">//2. Register the plugin</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">truncate</code><code class="p">,</code> <code class="p">{</code> <code class="nx">limit</code><code class="o">:</code> <code class="mi">10</code> <code class="p">})</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>The Vue engine will install the <code>truncate</code> plugin and initialize it with a <code>limit</code> of 10 characters. The plugin will be available in every Vue component within the <code>app</code> instance. You can call this plugin using <code>this.$truncate</code> in the <code>script</code> section or just <code>$truncate</code> in the <code>template</code> section<a data-primary="use()" data-secondary="plugins" data-type="indexterm" id="id1190"/><a data-primary="limit and plugins" data-type="indexterm" id="id1191"/><a data-primary="plugins" data-secondary="syntax" data-type="indexterm" id="id1192"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="nx">defineComponent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
<code class="kr">import</code> <code class="nx">truncate</code> <code class="nx">from</code> <code class="s1">'./plugins/truncate'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="nx">defineComponent</code><code class="p">({</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;h1&gt;{{ $truncate('My truncated long text') }}&lt;/h1&gt;</code>&#13;
<code class="sb"> &lt;h2&gt;{{ truncatedText }}&lt;/h2&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">truncatedText</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">$truncate</code><code class="p">(</code><code class="s1">'My 2nd truncated text'</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">);</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">truncate</code><code class="p">,</code> <code class="p">{</code> <code class="nx">limit</code><code class="o">:</code> <code class="mi">10</code> <code class="p">})</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>The output should look like <a data-type="xref" href="#figure_15_1">Figure 7-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_15_1">&#13;
<img alt="Display of two heading texts, both as truncated texts result from the call of the truncate plugin." src="assets/lvue_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Component output texts are truncated</h6>&#13;
</div></figure>&#13;
&#13;
<p>However, <code>$truncate</code> is available only if you use it in the <code>&lt;template&gt;</code> section or as <code>this.$truncate</code> with Options API in the <code>script</code> section. Accessing <code>$truncate</code> inside <code>&lt;script setup&gt;</code> or <code>setup()</code> is <em>not</em> possible. To do so, we need the provide/inject pattern (see <a data-type="xref" href="ch04.html#provide_inject_pattern">“Communicate Between Components with &#13;
<span class="keep-together">provide/inject Pattern</span>”</a>), starting with adding the following code to the plugin’s <code>install</code> function, located in the <code>plugins/truncate.ts</code> file<a data-primary="provide() hook" data-type="indexterm" id="id1193"/><a data-primary="provide/inject pattern" data-type="indexterm" id="id1194"/><a data-primary="inject() hook" data-type="indexterm" id="id1195"/><a data-primary="inject/provide pattern" data-type="indexterm" id="id1196"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/* plugins/truncate.ts */</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="p">{</code>&#13;
  <code class="nx">install</code><code class="p">(</code><code class="nx">app</code><code class="o">:</code> <code class="nx">App</code><code class="o">&lt;</code><code class="nx">Element</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">options</code><code class="o">:</code> <code class="p">{</code> <code class="nx">limit</code><code class="o">:</code> <code class="kt">number</code> <code class="p">})</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
    <code class="nx">app</code><code class="p">.</code><code class="nx">provide</code><code class="p">(</code><code class="s2">"plugins"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">truncate</code> <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Vue will pass <code>truncate</code> as part of the <code>plugins</code> object to all the application’s components. With that, we can use <code>inject</code> to receive our desired plugin <code>truncate</code> and move on to computing the <code>truncatedText</code>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">script</code> <code class="na">setup</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">inject</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s1">'vue'</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">truncate</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">inject</code><code class="p">(</code><code class="s1">'plugins'</code><code class="p">);</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">truncatedText</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">truncate</code><code class="p">(</code><code class="s1">'My 2nd truncated text'</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Plugins are very helpful in organizing global methods and making them available for reuse in other applications. It is also beneficial in writing your logic during an installation of an external library, such as <em>axios</em> for fetching external data, <em>i18n</em> for localization, etc<a data-primary="plugins" data-secondary="uses" data-type="indexterm" id="id1197"/><a data-primary="i18n" data-type="indexterm" id="id1198"/>.</p>&#13;
<div data-type="tip"><h1>Registering Pinia and Vue Router in Our Application</h1>&#13;
<p>During the scaffolding of our application, Vite adds Pinia and Vue Router as application plugins using the same approach reflected in the original generated code in <code>main.ts</code><a data-primary="main.ts file" data-secondary="Pinia plugin" data-type="indexterm" id="id1199"/><a data-primary="Pinia" data-secondary="installing" data-type="indexterm" id="id1200"/><a data-primary="installing" data-secondary="Pinia plugin" data-type="indexterm" id="id1201"/><a data-primary="main.ts file" data-secondary="Vue Router and" data-type="indexterm" id="id1202"/><a data-primary="Vue Router" data-secondary="installing" data-type="indexterm" id="id1203"/><a data-primary="installing" data-secondary="Vue Router" data-type="indexterm" id="id1204"/><a data-primary="Vite.js" data-secondary="Pinia and Vue Router plugins" data-type="indexterm" id="id1205"/>.</p>&#13;
</div>&#13;
&#13;
<p>The next section will look at rendering the dynamic component in run-time using the Vue <code>&lt;component&gt;</code> tag<a data-primary="" data-startref="ix-comp-adv4" data-type="indexterm" id="id1206"/><a data-primary="" data-startref="ix-comp-adv4a" data-type="indexterm" id="id1207"/><a data-primary="" data-startref="ix-comp-adv4b" data-type="indexterm" id="id1208"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dynamic Rendering with the &lt;component&gt; Tag" data-type="sect1"><div class="sect1" id="id85">&#13;
<h1>Dynamic Rendering with the &lt;component&gt; Tag</h1>&#13;
&#13;
<p>The <code>&lt;component&gt;</code> tag acts as the placeholder for rendering a Vue component, according to the component reference name passed to its <code>is</code> props, following this syntax<a data-primary="bindings" data-secondary="dynamic rendering with component tag and" data-type="indexterm" id="id1209"/><a data-primary="components" data-secondary="dynamic rendering with component tag" data-type="indexterm" id="id1210"/><a data-primary="component tag, dynamic rendering with" data-type="indexterm" id="id1211"/><a data-primary="rendering" data-secondary="dynamic rendering with component tag" data-type="indexterm" id="id1212"/><a data-primary="target" data-secondary="dynamic rendering with component tag" data-type="indexterm" id="id1213"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">component</code> <code class="na">is</code><code class="o">=</code><code class="s">"targetComponentName"</code> <code class="p">/&gt;</code></pre>&#13;
&#13;
<p>Suppose your target component is accessible from the Vue instance (registered as a component of the app or the parent component when <code>&lt;component&gt;</code> is nested); the Vue engine will know how to look up the target component based on the name string and replace the tag with the target component. The target component will also inherit all the extra props passed to <code>&lt;component&gt;</code>.</p>&#13;
&#13;
<p>Say we have a <code>HelloWorld</code> component that renders the text “Hello World”:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>Hello World<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>We register this component to the <code>App</code>, then render it dynamically using the &#13;
<span class="keep-together"><code>&lt;component&gt;</code></span> tag, as follows:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">component</code> <code class="na">is</code><code class="o">=</code><code class="s">"HelloWorld"</code> <code class="p">/&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">HelloWorld</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/components/HelloWorld"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">defineComponent</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="nx">defineComponent</code><code class="p">({</code><code class="w"/>&#13;
<code class="w"> </code><code class="nx">components</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">HelloWorld</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>You can also bind the component as a reference to the <code>is</code> props using the <code>v-bind</code> directive (denoted by <code>:</code> short syntax). We can shorten the two previous code blocks into a single <code>App</code> component by rewriting the code as follows<a data-primary="bindings" data-secondary="with v-bind" data-secondary-sortas="v-bind" data-type="indexterm" id="id1214"/><a data-primary="props" data-secondary="dynamic rendering with component tag" data-type="indexterm" id="id1215"/><a data-primary="is prop, dynamic rendering with component tag" data-type="indexterm" id="id1216"/><a data-primary="v-bind" data-secondary="dynamic rendering with component tag" data-type="indexterm" id="id1217"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">component</code> <code class="na">:is</code><code class="o">=</code><code class="s">"myComp"</code> <code class="p">/&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">HelloWorld</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/components/HelloWorld"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">defineComponent</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="nx">defineComponent</code><code class="p">({</code><code class="w"/>&#13;
<code class="w"> </code><code class="nx">data</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="nx">myComp</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">template</code><code class="o">:</code><code class="w"> </code><code class="s1">'&lt;div&gt;Hello World&lt;/div&gt;'</code><code class="w"/>&#13;
<code class="w">   </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Note here the component reference <code>myComp</code> follows Options API syntax. You can also pass an imported SFC component instead. The output of both cases should be the same<a data-primary="SFC (Single-File Component)" data-secondary="dynamic rendering with component tag" data-type="indexterm" id="id1218"/>.</p>&#13;
&#13;
<p>The <code>&lt;component&gt;</code> tag is powerful. For example, if you have a gallery component, you can choose to render each gallery item as a <code>Card</code> component or a <code>Row</code> component, using <code>&lt;component&gt;</code> to switch parts conditionally.</p>&#13;
&#13;
<p>However, switching components means Vue unmounts the current element completely and erases all the component’s current data states. Switching back to that component equals creating a new instance with a new data state. To prevent that behavior and maintain the states of a passive element for a future switch, we use the <code>&lt;keep-alive&gt;</code> component.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Keeping Component Instance Alive with &lt;keep-alive&gt;" data-type="sect1"><div class="sect1" id="id86">&#13;
<h1>Keeping Component Instance Alive with &lt;keep-alive&gt;</h1>&#13;
&#13;
<p><code>&lt;keep-alive&gt;</code> is a built-in Vue component for wrapping around a dynamic element and preserving the component’s states in inactive mode<a data-primary="components" data-secondary="state and keep-alive" data-type="indexterm" id="id1219"/><a data-primary="keep-alive component" data-type="indexterm" id="id1220"/><a data-primary="state" data-secondary="keep-alive component" data-type="indexterm" id="id1221"/>.</p>&#13;
&#13;
<p>Assume we have two components, <code>StepOne</code> and <code>StepTwo</code>. In the <code>StepOne</code> component, there is a string <code>input</code> field that has two-way binding to a local data property <code>name</code> using <code>v-model</code>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!--StepOne.vue--&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">label</code> <code class="na">for</code><code class="o">=</code><code class="s">"name"</code><code class="p">&gt;</code>Step one's input<code class="p">&lt;/</code><code class="nt">label</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">input</code> <code class="na">v-model</code><code class="o">=</code><code class="s">"name"</code> <code class="na">id</code><code class="o">=</code><code class="s">"name"</code> <code class="p">/&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">setup</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">ref</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s1">'vue'</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">ref</code><code class="p">&lt;</code><code class="nt">string</code><code class="p">&gt;(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>While the <code>StepTwo</code> component renders a static string:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!--StepTwo.vue--&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">h2</code><code class="p">&gt;</code>{{ name }}<code class="p">&lt;/</code><code class="nt">h2</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">setup</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"Step 2"</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In the main <code>App</code> template, we will use <code>component</code> tag to render a local data property: <code>activeComp</code> as a component reference. The initial value of <code>activeComp</code> is <code>StepOne</code>, and we have a button to move between <code>StepOne</code> to <code>StepTwo</code>, and vice versa:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">keep-alive</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">component</code> <code class="na">:is</code><code class="o">=</code><code class="s">"activeComp"</code> <code class="p">/&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">keep-alive</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="o">=</code><code class="s">"activeComp = 'StepOne'"</code> <code class="na">v-if</code><code class="o">=</code><code class="s">"activeComp === 'StepTwo'"</code><code class="p">&gt;</code>&#13;
      Go to Step Two&#13;
      <code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="o">=</code><code class="s">"activeComp = 'StepTwo'"</code> <code class="na">v-else</code><code class="p">&gt;</code>Back to Step One<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">defineComponent</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">StepOne</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"./components/StepOne.vue"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">StepTwo</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"./components/StepTwo.vue"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">defineComponent</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">components</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">StepTwo</code><code class="p">,</code><code class="w"> </code><code class="nx">StepOne</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">data</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">activeComp</code><code class="o">:</code><code class="w"> </code><code class="s2">"StepOne"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Whenever you switch between <code>StepOne</code> and <code>StepTwo</code>, Vue preserves any value of the <code>name</code> property received from the input field. When switching back to <code>StepOne</code>, you can continue with the previous value rather than starting from the initial value.</p>&#13;
&#13;
<p>You can also define the maximum instances for <code>keep-alive</code> to the cache using its <code>max</code> props<a data-primary="props" data-secondary="keep-alive component" data-type="indexterm" id="id1222"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">keep-alive</code> <code class="na">max</code><code class="o">=</code><code class="s">"2"</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">component</code> <code class="na">:is</code><code class="o">=</code><code class="s">"activeComp"</code> <code class="p">/&gt;</code>&#13;
 <code class="p">&lt;/</code><code class="nt">keep-alive</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>This code defines the maximum number of instances <code>keep-alive</code> should hold as two by setting <code>max="2"</code>. Once the number of cached instances exceeds the limit, Vue removes the least recently used (LRU) instance from the cached list, allowing for caching new instances.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id361">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter explored how to control the component rendering with JSX and functional components, register Vue custom plugins globally, and dynamically and conditionally render a component using the <code>&lt;component&gt;</code> tag.</p>&#13;
&#13;
<p>The next chapter will introduce Vue Router, the official routing management library for Vue, and discuss how to handle the navigation between different routes in our application using Vue Router.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id1152"><sup><a href="ch07.html#id1152-marker">1</a></sup> Virtual node</p><p data-type="footnote" id="id1153"><sup><a href="ch07.html#id1153-marker">2</a></sup> Stands for hypescript, meaning using JavaScript code to create HTML</p></div></div></section></body></html>