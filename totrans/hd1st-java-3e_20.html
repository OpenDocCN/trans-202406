<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Dealing with Concurrency Issues: Race Conditions and Immutable Data"><div class="chapter" id="dealing_with_concurrency_issues_race_con">
<h1><span class="label">Chapter 18. </span>Dealing with Concurrency Issues: Race Conditions and Immutable Data</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0639-01.png" alt="image" width="704" height="489"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="concurrency" id="idm46038387072544"/><strong>Doing two or more things at once is hard.</strong> Writing multithreaded code is easy. Writing multithreaded code that works the way you expect can be much harder. In this final chapter, we’re going to show you some of the things that can go wrong when two or more threads are working at the same time. You’ll learn about some of the tools in java.util.concurrent that can help you to write multithreaded code that works correctly. You’ll learn how to create immutable objects (objects that don’t change) that are safe for multiple threads to use. By the end of the chapter, you’ll have a lot of different tools in your toolkit for working with concurrency.</p>
<section data-type="sect1" data-pdf-bookmark="What could possibly go wrong?"><div class="sect1" id="what_could_possibly_go_wrongquestion_mar">
<h1>What could possibly go wrong?</h1>
<p>At the end of the last chapter we hinted that things may not all be rainbows and sunshine when you’re working with multithreaded code. Well, actually, we did more than hint! We outright said:</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">“It all comes down to one potentially deadly scenario: two or more threads have access to a single object’s data.”</span></p>
</div>
<figure class="informal"><div class="figure">
<img src="Images/f0640-01.png" alt="image" width="712" height="466"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="brain_barbell-id00010">
<h5>Brain Barbell</h5>
<figure class="informal"><div class="figure">
<img src="Images/f0282-02.png" alt="image" width="150" height="88"/>
<h6/>
</div></figure>
<p><strong><em>Why is it a problem if two threads are both reading and writing?</em></strong></p>
<p>If a thread reads the object’s data before changing it, why is it a problem that another thread might also be writing at the same time?</p>
</div></aside>
<p><a data-type="indexterm" data-primary="concurrency" data-secondary="race conditions" id="idm46038387057056"/><a data-type="indexterm" data-primary="Ryan and Monica concurrency scenario" id="idm46038387054784"/><strong>Marriage in Trouble.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0641-01.png" alt="image" width="134" height="217"/>
<h6/>
</div></figure>
<p><strong>Can this couple be saved?</strong></p>
<p><strong><em>Next, on a very special Dr. Steve Show</em></strong></p>
<p>[Transcript from episode #42]</p>
<p>Welcome to the Dr. Steve show.</p>
<p>We’ve got a story today that’s centered around one of the top reasons why couples split up—finances.</p>
<p>Today’s troubled pair, Ryan and Monica, share a bank account. But not for long if we can’t find a solution. The problem? The classic “two people—one bank account” thing.</p>
<p>Here’s how Monica described it to me:</p>
<p>“Ryan and I agreed that neither of us will overdraw the checking account. So the procedure is, whoever wants to spend money <em>must</em> check the balance in the account <em>before</em> withdrawing cash or spending on a card. It all seemed so simple. But suddenly we’re getting hit with overdraft fees!</p>
<p>I thought it wasn’t possible; I thought our procedure was safe. But then <em>this</em> happened:</p>
<p>Ryan had a full online shopping cart totalling $50. He checked the balance in the account and saw that it was $100. No problem.  So he started the checkout procedure.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0641-02.png" alt="image" width="370" height="409"/>
<h6/>
</div></figure>
<p>And that’s where <em>I</em> come in; while Ryan was filling in the shipping details, <em>I</em> wanted to spend $100. I checked the balance, and it’s $100 (because Ryan hasn’t clicked the “Pay” button yet), so I think, no problem. So I spend the money, and again no problem. But then Ryan finally pays, and we’re suddenly overdrawn! He didn’t know that I was spending money at the same time, so he just went ahead and completed his transaction without checking the balance again. You’ve got to help us, Dr. Steve!”</p>
<p>Is there a solution? Are they doomed? We can’t help them with their online shopping addiction, but can we make sure one of them can’t start spending while the other one is shopping?</p>
<p>Take a moment and think about that while we go to a commercial break.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The Ryan and Monica problem, in code"><div class="sect1" id="the_ryan_and_monica_problemcomma_in_code">
<h1>The Ryan and Monica problem, in code</h1>
<p>The following example shows what can happen when <em>two</em> threads (Ryan and Monica) share a <em>single</em> object (the bank account).</p>
<p>The code has two classes, BankAccount and RyanAndMonicaJob. There’s also a RyanAndMonicaTest with a main method to run everything. The RyanAndMonicaJob class implements Runnable, and represents the behavior that Ryan and Monica both have—checking the balance and spending money.</p>
<p>The RyanAndMonicaJob class has instance variables for the shared BankAccount, the person’s name, and the amount they want to spend. The code works like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0642-01.png" alt="image" width="381" height="418"/>
<h6/>
</div></figure>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1.png" alt="Images" width="20" height="21"/></span> <strong>Make an instance of the shared bank account</strong></p>
<p>Creating a new one will set up all the defaults correctly.</p>
<pre data-type="programlisting"><strong>BankAccount account = new BankAccount();</strong></pre>
</li>
<li><p><span class="inlineimage"><img src="Images/2.png" alt="Images" width="20" height="21"/></span> <strong>Make one instance of RyanAndMonicaJob for each person</strong></p>
<p>We need one job for each person. We also need to give them access to the BankAccount and tell them how  much to spend.</p>
<pre data-type="programlisting"><strong>RyanAndMonicaJob ryan = new RyanAndMonicaJob("Ryan", account, 50);</strong>
<strong>RyanAndMonicaJob monica = new RyanAndMonicaJob("Monica", account, 100);</strong></pre></li>
<li><p><span class="inlineimage"><img src="Images/3.png" alt="Images" width="20" height="21"/></span> <strong>Create an ExecutorService and give it the two jobs</strong></p>
<p>Since we know we have two jobs, one for Ryan and one for Monica, we can create a fixed-sized thread pool with two threads.</p>
<pre data-type="programlisting"><strong>ExecutorService executor = Executors.newFixedThreadPool(2);</strong>
<strong>executor.execute(ryan);</strong>
<strong>executor.execute(monica);</strong></pre></li>
<li><p><span class="inlineimage"><img src="Images/4.png" alt="Images" width="20" height="20"/></span> <strong>Watch both jobs run</strong></p>
<p>One thread represents Ryan, the other represents Monica. Both threads check the balance before spending money. Remember that when more than one thread is running at a time, you can’t assume that your thread is the only one making changes to a shared object (e.g., the BankAccount). Even if there’s only two lines of code related to the shared object, and they’re right next to each other.</p>
<pre data-type="programlisting"><strong>if (account.getBalance() &gt;= amount) {</strong>
  <strong>account.spend(amount);</strong>
<strong>} else {</strong>
  <strong>System.out.println("Sorry, not enough money");</strong>
<strong>}</strong></pre></li>
</ul>
<p><strong>In the goShopping() method, do exactly what Ryan and Monica would do—check the balance and, if there’s enough money, spend.</strong></p>
<p><strong>This should protect against overdrawing the account.</strong></p>
<p><strong>Except...if Ryan and Monica are spending money at the same time, the money in the bank account might be gone before the other one can spend it!</strong></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The Ryan and Monica example"><div class="sect1" id="the_ryan_and_monica_example">
<h1>The Ryan and Monica example</h1>
<p/>
<figure class="informal"><div class="figure">
<img src="Images/f0643-01.png" alt="image" width="987" height="1169"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0644-01.png" alt="image" width="605" height="219"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">This code is not <u>deterministic;</u> it doesn’t always produce the same result every time. You may need to run it a few times before you see the problem.</span></p>
<p><span style="color:#646466;">This is common with multithreaded code, since it depends upon which threads start first and when each thread gets its time on a CPU core.</span></p>
</div>
<figure class="informal"><div class="figure">
<img src="Images/f0644-02.png" alt="image" width="605" height="179"/>
<h6/>
</div></figure>
<p><strong>The goShopping() method always checks the balance before making a withdrawal, but still we went overdrawn.</strong></p>
<p><strong>Here’s one scenario:</strong></p>
<p>Ryan checks the balance, sees that there’s enough money, and goes to check out.</p>
<p>Meanwhile, Monica checks the balance. She, too, sees that there’s enough money. She has no idea that Ryan is about to pay for something.</p>
<p>Ryan completes his purchase.</p>
<p>Monica completes her purchase. Big Problem! In between the time when she checked the balance and spent the money, Ryan had already spent money!</p>
<p><strong>Monica’s check of the account was not valid, because Ryan had already checked and was still in the middle of making a purchase.</strong></p>
<p>Monica must be stopped from getting into the account until Ryan has finished, and vice versa.</p>
<p><a data-type="indexterm" data-primary="access control" data-secondary="object locking for" id="idm46038386999472"/><a data-type="indexterm" data-primary="concurrency" data-secondary="locking" id="idm46038386998832"/><a data-type="indexterm" data-primary="locking" id="idm46038386998192"/><a data-type="indexterm" data-primary="objects" data-secondary="locking" id="idm46038386997680"/><strong>They need a lock for account access!</strong></p>
<p><strong>The lock works like this:</strong></p>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1.png" alt="Images" width="20" height="21"/></span> There’s a lock associated with the bank account transaction (checking the balance and withdrawing money). There’s only one key, and it stays with the lock until somebody wants to access the account.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0645-01.png" alt="image" width="217" height="163"/>
<h6/>
</div></figure>
<p><strong>The bank account transaction is unlocked when nobody is using the account.</strong></p></li>
<li><p><span class="inlineimage"><img src="Images/2.png" alt="Images" width="20" height="21"/></span> When Ryan wants to access the bank account (to check the balance and withdraw money), he locks the lock and puts the key in his pocket. Now nobody else can access the account, since the key is gone.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0645-02.png" alt="image" width="125" height="130"/>
<h6/>
</div></figure>
<p><strong>When Ryan wants to access the account, he secures the lock and takes the key.</strong></p></li>
<li><p><span class="inlineimage"><img src="Images/3.png" alt="Images" width="20" height="21"/></span> <strong>Ryan keeps the key in his pocket until he finishes the transaction.</strong> He has the only key, so Monica can’t access the account until Ryan unlocks the account and returns the key.</p>
<p>Now, even if Ryan gets distracted after he checks the balance, he has a guarantee that the balance will be the same when he spends the money, because he kept the key while he was doing something else!</p>
<figure class="informal"><div class="figure">
<img src="Images/f0645-03.png" alt="image" width="216" height="164"/>
<h6/>
</div></figure>
<p><strong>When Ryan is finished, he unlocks the lock and returns the key. Now the key is available for Monica (or Ryan again) to access the account.</strong></p></li>
</ul>
</div></section>
<section data-type="sect1" data-pdf-bookmark="We need to check the balance and spend the money as one atomic thing"><div class="sect1" id="we_need_to_check_the_balance_and_spend_t">
<h1>We need to check the balance and spend the money as one <span style="color:#646466;"><u>atomic</u></span> thing</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0646-01a.png" alt="image" width="131" height="125"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="atomic transactions, thread concurrency" id="idm46038386981952"/><a data-type="indexterm" data-primary="concurrency" data-secondary="synchronization" id="idm46038386981216"/><a data-type="indexterm" data-primary="Getters and Setters" id="idm46038386980240"/><a data-type="indexterm" data-primary="Ryan and Monica concurrency scenario" id="idm46038386979504"/><a data-type="indexterm" data-primary="synchronization for concurrency in accessing objects" id="idm46038386978768"/><a data-type="indexterm" data-primary="synchronized keyword" id="idm46038386978032"/>We need to make sure that once a thread starts a shopping transaction, <em>it must be allowed to finish</em> before any other thread changes the bank account.</p>
<p>In other words, we need to make sure that once a thread has checked the account balance, that thread has a guarantee that it can spend the money <em>before any other thread can check the account balance!</em></p>
<p>Use the <strong><code>synchronized</code></strong> keyword  on a method, or with an object, to lock an object so only one thread can use it at a time.</p>
<p>That’s how you protect the bank account! We can put a lock on the bank account inside the method that does the banking transaction. That way, one thread gets to complete the whole transaction, start to finish, even if that thread is taken out of the “running” state by the thread scheduler or another thread is trying to make changes at exactly the same time.</p>
<p>On the next couple of pages we’ll look at the different things that we can lock. With the Ryan and Monica example, it’s quite simple—we want to wrap our shopping transaction in a block that locks the bank account:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0646-01.png" alt="image" width="96" height="138"/>
<h6/>
</div></figure>
<blockquote>
<p><strong>The</strong> <code>synchronized</code> <strong>keyword means that a thread needs a key in order to access the synchronized code.</strong></p>
<p><strong>To protect your <em>data</em> (like the bank account), synchronize the code that acts on that data.</strong></p>
</blockquote>
<figure class="informal"><div class="figure">
<img src="Images/f0646-02.png" alt="image" width="676" height="252"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">(Note for you physics-savvy readers: yes, the convention of using the word “ atomic ”  here does not reflect the whole subatomic particle thing. Think Newton, not Einstein, when you hear the word “ atomic ”  in the context of threads or transactions. Hey, it’s not OUR convention. If WE were in charge, we’d apply Heisenberg’s Uncertainty Principle to pretty much everything related to threads.)</span></p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00048">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: Why don’t you just synchronize all the getters and setters from the class with the data you’re trying to protect?</strong></p>
<p><strong>A:</strong> Synchronizing the getters and setters isn’t enough. Remember, the point of synchronization is to make a specific section of code work ATOMICALLY. In other words, it’s not just the individual methods we care about; it’s methods that require <em><strong>more than one step to complete!</strong></em></p>
<p>Think about it. We added a synchronized  block inside the goShopping() method. If getBalance() and spend() were both synchronized instead, it wouldn’t help—Ryan (or Monica) would have checked the balance returned the key! The whole point is to keep the key until <em><strong>both</strong></em> operations are completed.</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using an object’s lock"><div class="sect1" id="using_an_objectapostrophes_lock">
<h1>Using an object’s lock</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0647-01.png" alt="image" width="385" height="500"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="access control" data-secondary="object locking for" id="idm46038387363184"/><a data-type="indexterm" data-primary="synchronized block or methods, threads" id="idm46038387360816"/>Every object has a lock. Most of the time, the lock is unlocked, and you can imagine a virtual key sitting with it. Object locks come into play only when there is a <strong>synchronized block</strong>for an object (like in the last page) or a class has <strong>synchronized methods</strong>. A method is synchronized if it has the synchronized keyword in the method declaration.</p>
<p>When an object has one or more synchronized methods, <strong><em>a thread can enter a synchronized method only if the thread can get the key to the object’s lock!</em></strong></p>
<p>The locks are not per <em>method</em>, they are per <em>object</em>. If an object has two synchronized methods, it doesn’t <em>only</em> mean two threads can’t enter the same method. It means you can’t have two threads entering <em>any</em> of the synchronized methods. If you have two synchronized methods on the same object, method1() and method2(), if one thread is in method1(), a second thread can’t enter method1(), obviously, but it <em>also can’t enter method2()</em>, or any other synchronized method on that object.</p>
<p>Think about it. If you have multiple methods that can potentially act on an object’s instance variables, all those methods need to be protected with synchronized.</p>
<p>The goal of synchronization is to protect critical data. But remember, you don’t lock the data itself; you synchronize the methods that <em>access</em> that data.</p>
<p>So what happens when a thread is cranking through its call stack (starting with the run() method) and it suddenly hits a synchronized method? The thread recognizes that it needs a key for that object before it can enter the method. It looks for the key (this is all handled by the JVM; there’s no API in Java for accessing object locks), and if the key is available, the thread grabs the key and enters the method.</p>
<p>From that point forward, the thread hangs on to that key like the thread’s life depends on it. The thread won’t give up the key until it completes the synchronized method or block. So while that thread is holding the key, no other threads can enter <em>any</em> of that object’s synchronized methods, because the one key for that object won’t be available.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0647-02.png" alt="image" width="389" height="193"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">Every Java object has a lock. A lock has only one key.</span></p>
<p><span style="color:#646466;">Most of the time, the lock is unlocked and nobody cares.</span></p>
<p><span style="color:#646466;">But if an object has synchronized methods, a thread can enter one of the synchronized methods ONLY if the key for the object’s lock is available. In other words, only if another thread hasn’t already grabbed the one key.</span></p>
</div>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using synchronized methods"><div class="sect1" id="using_synchronized_methods">
<h1>Using synchronized methods</h1>
<p>Can we synchronize the goShopping() method to fix Ryan and Monica’s problem?</p>
<pre data-type="programlisting"><strong>private <span style="background-color:#E0E1E2;">synchronized</span> void goShopping(int amount) {</strong>
  <strong>if (account.getBalance() &gt;= amount) {</strong>
    <strong>System.out.println(name + " is about to spend");</strong>
    <strong>account.spend(amount);</strong>
    <strong>System.out.println(name + " finishes spending");</strong>
  <strong>} else {</strong>
    <strong>System.out.println("Sorry, not enough for " + name);</strong>
  <strong>}</strong>
<strong>}</strong></pre>
<p><span style="color:#646466;"><strong>It does <u>NOT</u> work!</strong></span></p>
<figure class="informal"><div class="figure">
<img src="Images/f0648-01.png" alt="image" width="356" height="219"/>
<h6/>
</div></figure>
<p>The synchronized keyword locks an object. The goShopping() method is in RyanAndMonicaJob. Synchronizing an instance method means “lock <em>this</em> RyanAndMonicaJob instance.” However, there are <em>two</em> instances of RyanAndMonicaJob; one is “ryan,” and the other is “monica.” If “ryan” is locked, “monica” can still make changes to the bank account; she doesn’t care that the “ryan” job is locked.</p>
<p>The object that needs locking, the object these two threads are fighting over, is the BankAccount. Putting synchronized on a method in RyanAndMonicaJob (and locking a RyanAndMonicaJob instance) isn’t going to solve anything.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="It’s important to lock the correct object"><div class="sect1" id="itapostrophes_important_to_lock_the_corr">
<h1>It’s important to lock the correct object</h1>
<p><a data-type="indexterm" data-primary="access control" data-secondary="object locking for" id="idm46038388163648"/><a data-type="indexterm" data-primary="static methods" data-secondary="and object locking" id="idm46038387453936"/>Since it’s the BankAccount object that’s shared, you could argue it should be the BankAccount that’s in charge of making sure it is safe for multiple threads to use. The spend() method on BankAccount could make sure there’s enough money <em>and</em> debit the account in a single transaction.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0649-01.png" alt="image" width="950" height="639"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00049">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: What about protecting static variable state? If you have static methods that change the static variable state, can you still use synchronization?</strong></p>
<p><strong>A:</strong> Yes! Remember that static methods run against the class and not against an individual instance of the class. So you might wonder whose object’s lock would be used on a static method? After all, there might not even <em>be</em> any instances of that class. Fortunately, just as each <em>object</em> has its own lock, each loaded <em>class</em> has a lock.  That means if you have three Dog objects on your heap, you have a total of four Dog-related locks; three belonging to the three Dog instances, and one belonging to the Dog class itself. When you synchronize a static method, Java uses the lock of the class itself. So if you synchronize two static methods in a single class, a thread will need the class lock to enter <em>either</em> of the methods.</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The dreaded “Lost Update” problem"><div class="sect1" id="the_dreaded_quotation_marklost_updatequo">
<h1>The dreaded “Lost Update” problem</h1>
<p><a data-type="indexterm" data-primary="concurrency" data-secondary="lost update scenario" id="idm46038387335584"/><a data-type="indexterm" data-primary="race conditions" id="idm46038387343184"/>Here’s another classic concurrency problem. Sometimes you’ll hear them called “race conditions,” where two or more threads are changing the same data at the same time. It’s closely related to the Ryan and Monica story, so we’ll use this example to illustrate a few more points.</p>
<p>The lost update revolves around one process:</p>
<p>Step 1: Get the balance in the account</p>
<pre data-type="programlisting"><strong>int i = balance;</strong></pre>
<p>Step 2: Add 1 to that balance</p>
<figure class="informal"><div class="figure">
<img src="Images/f0650-01.png" alt="image" width="541" height="75"/>
<h6/>
</div></figure>
<p>Even if we used the more common syntax of <strong><code>balance++</code></strong>, there is no guarantee that the compiled bytecode will be an “atomic process.” In fact, it probably won’t—it’s actually multiple operations: a read of the current value and then adding one to that value and setting it back into the original variable.</p>
<p>In the “Lost Update” problem, we have many threads trying to increment the balance. Take a look at the code, and then we’ll look at the real problem:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0650-02.png" alt="image" width="1002" height="627"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Let’s run this code..."><div class="sect1" id="letapostrophes_run_this_codehellip">
<h1>Let’s run this code...</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0651-01.png" alt="image" width="700" height="1110"/>
<h6/>
</div></figure>
<p><strong>We lost the last updates that Thread A made! Thread B had previously done a “read” of the value of balance, and when B woke up, it just kept going as if it never missed a beat.</strong></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Make the increment() method atomic. Synchronize it!"><div class="sect1" id="make_the_incrementleft_parenthesisright">
<h1>Make the increment() method atomic. Synchronize it!</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0646-01a.png" alt="image" width="131" height="125"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="increment(), synchronizing" id="idm46038386921328"/>Synchronizing the increment() method solves the “Lost Update” problem, because it keeps the steps in the method (read of balance and increment of balance) as one unbreakable unit.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0652-01.png" alt="image" width="520" height="203"/>
<h6/>
</div></figure>
<p><strong>Once a thread enters the method, we have to make sure that all the steps in the method complete (as one atomic process) before any other thread can enter the method.</strong></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00050">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: Sounds like it’s a good idea to synchronize everything, just to be thread-safe.</strong></p>
<p><strong>A:</strong> Nope, it’s not a good idea. Synchronization doesn’t come for free. First, a synchronized method has a certain amount of overhead. In other words, when code hits a synchronized method, there’s going to be a performance hit (although typically, you’d never notice it) while the matter of “is the key available?” is resolved.</p>
<p>Second, a synchronized method can slow your program down because synchronization restricts concurrency.  In other words, a synchronized method forces other threads to get in line and wait their turn. This might not be a problem in your code, but you have to consider it.</p>
<p>Third, and most frightening, synchronized methods can lead to deadlock! (We’ll see this in a couple of pages.)</p>
<p>A good rule of thumb is to synchronize only the bare minimum that should be synchronized.  And in fact, you can synchronize at a granularity that’s even smaller than a method. Remember, you can use the synchronized keyword to synchronize at the more fine-grained level of one or more statements, rather than at the whole-method level (we used this in our first solution to Ryan and Monica’s problem).</p>
<figure class="informal"><div class="figure">
<img src="Images/f0652-02.png" alt="image" width="519" height="510"/>
<h6/>
</div></figure>
</div></aside>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1.png" alt="Images" width="20" height="21"/></span> Thread A runs for a while</p>
<ul style="list-style-type:none">
<li><p>Attempt to enter the increment() method.</p></li>
<li><p>The method is synchronized, so <strong>get the key</strong> for this object</p></li>
<li><p>Reads balance: 0</p></li>
<li><p>Set the value of balance to 0 + 1.</p></li>
<li><p>Now balance is 1</p></li>
<li><p><strong>Return the key</strong> (it completed the increment() method).</p></li>
<li><p>Re-enter the increment() method and <strong>get the key</strong>.</p></li>
<li><p>Reads balance: 1</p>
<p><em>[now thread A is sent back to runnable, but since it has not completed the synchronized method, Thread A keeps the key]</em></p></li>
</ul>
<figure class="informal"><div class="figure">
<img src="Images/f0653-01.png" alt="image" width="75" height="177"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/2.png" alt="Images" width="20" height="21"/></span> Thread B is selected to run</p>
<ul style="list-style-type:none">
<li><p>Attempt to enter the increment() method. The method is synchronized, so we need to get the key.</p>
<p><strong>The key is not available.</strong></p>
<p><em>[now thread B is sent into an “object lock not available” lounge]</em></p></li>
</ul>
<figure class="informal"><div class="figure">
<img src="Images/f0653-02.png" alt="image" width="75" height="177"/>
<h6/>
</div></figure>
</li>
<li><p><span class="inlineimage"><img src="Images/3.png" alt="Images" width="20" height="21"/></span> Thread A runs again, picking up where it left off (remember, it still has the key)</p>
<ul style="list-style-type:none">
<li><p>Set the value of balance 1 + 1.</p></li>
<li><p>Now balance is 2</p>
<p><strong>Return the key.</strong></p>
<p><em>[now thread A is sent back to runnable, but since it has completed the increment() method, the thread does NOT hold on to the key]</em></p>
</li></ul>
<figure class="informal"><div class="figure">
<img src="Images/f0653-01.png" alt="image" width="75" height="177"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/4.png" alt="Images" width="20" height="20"/></span> Thread B is selected to run</p>
<figure class="informal"><div class="figure">
<img src="Images/f0653-02.png" alt="image" width="75" height="177"/>
<h6/>
</div></figure>
<ul style="list-style-type:none">
<li><p>Attempt to enter the increment() method. The method is synchronized, so we need to get the key.</p>
<p>This time, the key IS available; get the key.</p>
<p>Reads balance: 2</p>
<p><em>[continues to run...]</em></p></li>
</ul></li>
</ul>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Deadlock, a deadly side of synchronization"><div class="sect1" id="deadlockcomma_a_deadly_side_of_synchroni">
<h1>Deadlock, a deadly side of synchronization</h1>
<p><a data-type="indexterm" data-primary="deadlock, synchronization" id="idm46038386878608"/>Synchronization saved Ryan and Monica from using their bank account at the same time, and has saved us from losing updates. But we also mentioned that we shouldn’t synchronize everything, one reason being that synchronization can slow your program down.</p>
<p>There’s another important consideration: we need to be careful using synchronized code, because nothing will bring your program to its knees like thread deadlock. Thread deadlock happens when you have two threads, both of which are holding a key the other thread wants. There’s no way out of this scenario, so the two threads will simply sit and wait. And wait. And wait.</p>
<p>If you’re familiar with databases or other application servers, you might recognize the problem; databases often have a locking mechanism somewhat like synchronization. But a real transaction management system can sometimes deal with deadlock. It might assume, for example, that deadlock might have occurred when two transactions are taking too long to complete. But unlike Java, the application server can do a “transaction rollback” that returns the state of the rolled-back transaction to where it was before the transaction (the atomic part) began.</p>
<p>Java has no mechanism to handle deadlock. It won’t even <em>know</em> deadlock occurred. So it’s up to you to design carefully. We’re not going to go into more detail about deadlock than you see on this page, so if you find yourself writing multithreaded code, you might want to study <em>Java Concurrency in Practice</em> by Brian Goetz, et al. It goes into a lot of detail about the sorts of problems you can face with concurrency (like deadlock), and approaches to address these problems.</p>
<p><strong>All it takes for deadlock are two objects and two threads.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0654-01.png" alt="image" width="206" height="133"/>
<h6/>
</div></figure>
<p><strong>A simple deadlock scenario:</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0654-02.png" alt="image" width="1003" height="423"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="You don’t always have to use synchronized"><div class="sect1" id="you_donapostrophet_always_have_to_use_sy">
<h1>You don’t always have to use synchronized</h1>
<p><a data-type="indexterm" data-primary="atomic variables" id="idm46038386863216"/><a data-type="indexterm" data-primary="CAS (compare-and-swap) operations" id="idm46038386862432"/><a data-type="indexterm" data-primary="compareAndSet method" id="idm46038386869936"/><a data-type="indexterm" data-primary="compare and swap operations" data-see="CAS" id="idm46038386869104"/><a data-type="indexterm" data-primary="concurrency" data-secondary="atomic variables" id="idm46038386857344"/><a data-type="indexterm" data-primary="Ryan and Monica concurrency scenario" id="idm46038386856240"/>Since synchronization can come with some costs (like performance and potential deadlocks), you should know about other ways to manage data that’s shared between threads. The java.util.concurrent package has lots of classes and utilities for working with multithreaded code.</p>
<section data-type="sect2" data-pdf-bookmark="Atomic variables"><div class="sect2" id="atomic_variables">
<h2>Atomic variables</h2>
<p>If the shared data is an int, long, or boolean, we might be able to replace it with an <em>atomic variable</em>. These classes provide methods that are atomic, i.e., can safely be used by a thread without worrying about another thread changing the object’s values at the same time.</p>
<p>There are few types of atomic variable, e.g., <strong>AtomicInteger</strong>, <strong>AtomicLong</strong>, <strong>AtomicBoolean</strong>, and <strong>AtomicReference</strong>.</p>
<p>We can fix our Lost Update problem with an AtomicInteger, instead of synchronizing the increment method.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0655-01.png" alt="image" width="928" height="620"/>
<h6/>
</div></figure>
<p>Atomic variables get more interesting when you use their <em>compare-and-swap</em> (CAS) operations. CAS is yet another way to make an atomic change to a value. You can use CAS on atomic variables by using the <strong><code>compareAndSet</code></strong> method. Yes, it’s a slightly different name! Gotta love programming, where naming is always the hardest problem to solve.</p>
<p>The compareAndSet method takes a value, which is what you <em>expect</em> the atomic variable to be, compares it to the <em>current</em> value, and if that matches, <em>then</em> the operation will complete.</p>
<p>In fact, we can use this to fix our Ryan and Monica problem, instead of locking the whole bank account with <strong><code>synchronized</code></strong>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Compare-and-swap with atomic variables"><div class="sect1" id="compare-and-swap_with_atomic_variables">
<h1>Compare-and-swap with atomic variables</h1>
<p><a data-type="indexterm" data-primary="access control" data-secondary="object locking for" id="idm46038386849456"/><a data-type="indexterm" data-primary="AtomicInteger" id="idm46038386846544"/><a data-type="indexterm" data-primary="locking" id="idm46038386845712"/><a data-type="indexterm" data-primary="objects" data-secondary="locking" id="idm46038386844880"/><a data-type="indexterm" data-primary="optimistic locking" id="idm46038386843776"/>How could we make use of atomic variables, and CAS (via <strong><code>compareAndSet</code></strong>), to solve Ryan and Monica’s problem?</p>
<p>Since Ryan and Monica were both trying to access an int value, the account balance, we could use an AtomicInteger to store that balance. We could then use <strong><code>compareAndSet</code></strong> to update the balance when someone wants to spend money.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0656-01.png" alt="image" width="1001" height="301"/>
<h6/>
</div></figure>
<p>In plain English:</p>
<blockquote>
<p><span style="color:#646466;"><strong>“Set the balance to this new value <u>only if</u> the current balance is the same as this expected value, and tell me if the balance was actually changed.”</strong></span></p>
</blockquote>
<p>Compare-and-swap uses <em>optimistic locking</em>. Optimistic locking means you don’t stop all threads from getting to the object; you <em>try</em> to make the change, but you embrace the fact that the change <strong><em>might not happen</em></strong>. If it doesn’t succeed, you decide what to do. You might decide to try again, or to send a message letting the user know it didn’t work.</p>
<p>This may be more work than simply locking all other threads out from the object, but it can be faster than locking everything. For example, when the chances of multiple writes happening at the same time are very low or if you have a lot of threads reading and not so many writing, then you may not want to pay the price of a lock on every write.</p>
<blockquote>
<p>When you’re using CAS operations, you have to deal with the times when the operation does NOT succeed.</p>
</blockquote>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Ryan and Monica, going atomic"><div class="sect1" id="ryan_and_monicacomma_going_atomic">
<h1>Ryan and Monica, going atomic</h1>
<p>Let’s see the whole thing in action in Ryan and Monica’s bank account. We’ll put the balance in an AtomicInteger and use compareAndSet to make an <em>atomic</em> change to the balance.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0657-01.png" alt="image" width="998" height="1029"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">java.util.concurrent has lots of useful classes and utilities for working with multithreaded code. Take a look at what’s there!</span></p>
</div>
<figure class="informal"><div class="figure">
<img src="Images/f0658-01.png" alt="image" width="775" height="733"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="classes" data-secondary="for immutable data" id="idm46038386824624"/><a data-type="indexterm" data-primary="concurrency" data-secondary="immutable objects" id="idm46038386823344"/><a data-type="indexterm" data-primary="immutable objects" id="idm46038386822240"/><a data-type="indexterm" data-primary="objects" data-secondary="immutable" id="idm46038386821408"/><strong>Make an object <u>immutable</u> if you’re going to share it between threads and you don’t want the threads to change its data.</strong></p>
<p>The very best way to know <em>for sure</em> that another thread isn’t changing your data is to make it impossible to change the data in the object. When an object’s data cannot be changed, we call it an <strong>immutable object</strong>.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Writing a class for immutable data"><div class="sect1" id="writing_a_class_for_immutable_data">
<h1>Writing a class for immutable data</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0658-02.png" alt="image" width="791" height="482"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="brain_barbell-id00011">
<h5>Brain Barbell</h5>
<figure class="informal"><div class="figure">
<img src="Images/f0282-02.png" alt="image" width="150" height="88"/>
<h6/>
</div></figure>
<p>There are times when adding the final keyword isn’t enough to prevent changes. When do you think that might be the case? We’ll give you a clue....</p>
<figure class="informal"><div class="figure">
<img src="Images/f0658-01a.png" alt="image" width="101" height="179"/>
<h6/>
</div></figure>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using immutable objects"><div class="sect1" id="using_immutable_objects">
<h1>Using immutable objects</h1>
<p>It is terribly convenient to be able to change data on a shared object and assume that all the other threads will be able to see these changes.</p>
<p>However, we’ve also seen that while it’s <em>convenient</em>, it’s not very <em>safe</em>.</p>
<p>On the other hand, when a thread is working with an object that cannot be changed, it can make assumptions about the data in that object; e.g., once the thread has read a value from the object, it knows that data can’t change.</p>
<p>We don’t need to use synchronization or other mechanisms to control who changes the data because it can’t change.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0659-01.png" alt="image" width="617" height="484"/>
<h6/>
</div></figure>
<p><strong>Working with immutable objects means thinking in a different way.</strong></p>
<p>Instead of making changes to the <em>same</em> object, we <em>replace</em> the old object with a new one. The new object has the updated values, and any threads that need the new values need to use the new object.</p>
<p>What happens to the old object? Well, if it’s still being used by something (and it might be—it’s perfectly valid sometimes to work with older data), it will hang around on the heap. If it’s not being used, it’ll be garbage collected, and we don’t have to worry about it anymore.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Changing immutable data"><div class="sect1" id="changing_immutable_data">
<h1>Changing immutable data</h1>
<p><a data-type="indexterm" data-primary="final keyword" id="idm46038386960960"/><a data-type="indexterm" data-primary="final keyword" data-secondary="adding to field declaration" id="idm46038386961936"/>Imagine a system that has customers, and that each Customer object has an Address that represents the street address of a customer. If the customer’s Address is an immutable object (all its fields are final and the data cannot be changed), how do you change the customer’s address when they move?</p>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1-circle.png" alt="Images" width="23" height="22"/></span> <strong>The Customer has a reference to the original Address object containing the customer’s street address data.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0660-01.png" alt="image" width="385" height="217"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/2-circle.png" alt="Images" width="23" height="23"/></span> <strong>When the customer moves, a brand new Address object is created with the new street address for the customer.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0660-02.png" alt="image" width="137" height="126"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/3-circle.png" alt="Images" width="20" height="20"/></span> <strong>The Customer object’s reference to their address is changed to point to the new Address object.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0660-03.png" alt="image" width="415" height="378"/>
<h6/>
</div></figure></li>
</ul>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00051">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: What happens if other parts of the program have a reference to the old Address?</strong></p>
<p><strong>A:</strong> Actually sometimes we want this. Imagine the customer placed an order to be delivered to their original address. We still want the details of that order to have the original address; we don’t want it changed to contain the details of the new address.</p>
<p>Once the customer changes their address (and the Customer contains a reference to the new address object), <em>then</em> we want new orders to use the new Address object.</p>
</div></aside>
<figure class="informal"><div class="figure">
<img src="Images/f0661-01.png" alt="image" width="563" height="484"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="classes" data-secondary="for immutable data" id="idm46038386774000"/>Absolutely right. If your system has data that changes, those changes do have to happen somewhere. The key idea to take away from this discussion is that not all of the classes in your application have to have data that changes. In fact, we’d argue for minimizing the places where things change. Then, there are far fewer places where you have to think about what happens if multiple threads are making changes at the same time.</p>
<p>There are a number of techniques for working effectively with immutable data classes; we’ve just scratched the surface here. It is interesting to note that Java 16 introduced <em>records</em>, which are immutable data classes provided directly by the language.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">Use immutable data classes where you can.</span></p>
<p><span style="color:#646466;">Limit the number of places where data can be changed by multiple threads.</span></p>
</div>
</div></section>
<section data-type="sect1" data-pdf-bookmark="More problems with shared data"><div class="sect1" id="more_problems_with_shared_data">
<h1>More problems with shared data</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0662-01.png" alt="image" width="529" height="531"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="collections" data-secondary="and concurrency" id="idm46038386858976"/><a data-type="indexterm" data-primary="concurrency" data-secondary="collections" id="idm46038386765776"/>We’re nearly there, we promise! Just one last thing to look at.</p>
<p>So far we’ve seen all sorts of problems that can come from many threads writing to the same data. This applies to data in Collections too.</p>
<p>We can even have problems when we have lots of threads <em>reading</em> the same data, even if only one thread is making changes to it.</p>
<p>This code has just one thread writing to a collection, but two threads reading it.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0662-02.png" alt="image" width="958" height="685"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Reading from a changing data structure causes an Exception"><div class="sect1" id="reading_from_a_changing_data_structure_c">
<h1>Reading from a changing data structure causes an Exception</h1>
<p><a data-type="indexterm" data-primary="ConcurrentModificationException" id="idm46038386758096"/><a data-type="indexterm" data-primary="exceptions" data-secondary="concurrency and collections" id="idm46038386757264"/>Running the code on the last page causes an Exception to be thrown, sometimes. By now you know these sorts of issues depend a lot on the whims of the hardware, the operating system, and the JVM.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0663-01.png" alt="image" width="930" height="604"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">If a collection is changed by one thread while another thread is reading that collection, you can get a ConcurrentModificationException.</span></p>
</div>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Use a thread-safe data structure"><div class="sect1" id="use_a_thread-safe_data_structure">
<h1>Use a thread-safe data structure</h1>
<p><a data-type="indexterm" data-primary="thread-safe data structure" id="idm46038386751824"/>Clearly good ol’ ArrayList just isn’t going to cut it if you have threads reading data that’s being changed at the same time. Luckily for us, there are other options. We want a thread-safe data structure, one that can be written to, and read from, by multiple threads at the same time.</p>
<p>The java.util.concurrent package has a number of thread-safe data structures, and we’re going to look at <strong><code>CopyOnWriteArrayList</code></strong> to solve this specific problem.</p>
<p>CopyOnWriteArrayList is a reasonable choice when you have a List that is being <strong>read a lot, but not changed very often</strong>. We’ll see why later.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0664-01.png" alt="image" width="890" height="388"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0664-02.png" alt="image" width="930" height="350"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="CopyOnWriteArrayList"><div class="sect1" id="copyonwritearraylist">
<h1>CopyOnWriteArrayList</h1>
<p><a data-type="indexterm" data-primary="CopyOnWriteArrayList" id="idm46038386744944"/><a data-type="indexterm" data-primary="immutable objects" id="idm46038386743968"/><a data-type="indexterm" data-primary="objects" data-secondary="immutable" id="idm46038386743136"/>CopyOnWriteArrayList uses immutability to provide safe access for reading threads while other threads are writing.</p>
<p>How does it work? Well, it does what it says on the tin: when a thread is writing to the list, it’s actually writing to a <em>copy</em> of the list. When the changes have been made, then the new copy replaces the original. In the meantime, any threads that were reading the list before the change are happily (and safely!) reading the original.</p>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1circle.png" alt="Images" width="20" height="20"/></span> <strong>An instance of CopyOnWriteArrayList contains an ordered set of data, like an array.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0665-03.png" alt="image" width="347" height="88"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/2circle.png" alt="Images" width="23" height="23"/></span> When Thread A reads the CopyOnWriteArrayList, it gets an Iterator that allows it to read a <strong>snapshot</strong> of the list data at that point in time.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0665-04.png" alt="image" width="430" height="176"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/3circle.png" alt="Images" width="23" height="23"/></span> Thread B writes data to the CopyOnWriteArrayList by adding a new element, and the CopyOnWriteArray creates a <strong>copy</strong> of the list data before any changes are made. This is invisible to any of the reading or writing threads.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0665-05.png" alt="image" width="512" height="212"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/4-circle.png" alt="Images" width="20" height="20"/></span> When Thread B makes changes to “the list,” it’s actually making changes to this copy. It’s happy knowing the changes are being made. The reading threads like Thread A are not affected at all; they’re iterating over the snapshot of the original data.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0665-01.png" alt="image" width="512" height="213"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/1circlee.png" alt="Images" width="23" height="23"/></span> Once Thread B has finished its updates, then the original data is replaced with the new data.</p>
<p>If Thread A is still reading, it’s safely reading the old data. If any other threads start reading after the change, they get the new data.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0665-02.png" alt="image" width="423" height="207"/>
<h6/>
</div></figure></li>
</ul>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00052">
<h5>there are no Dumb Questions</h5>
<p><a data-type="indexterm" data-primary="concurrency" data-secondary="trade-offs in" id="idm46038386716864"/><a data-type="indexterm" data-primary="final keyword" data-secondary="adding to field declaration" id="idm46038386716224"/><strong>Q: Doesn’t using CopyOnWriteArrayList mean that some reading threads will be reading old data?</strong></p>
<p><strong>A:</strong> Yes, the reading threads will always be working off data that is a snapshot of the data from when they first started reading. This means that potentially the data might be out of date at some point, but at least it’s not going to throw a ConcurrentModificationException.</p>
<p><strong>Q: Isn’t it bad to be using out of date data?</strong></p>
<p><strong>A:</strong> Not necessarily. In many systems this is “good enough.” Think, for example, about a website that shows live news. Yes, you want it to be pretty up to date, but it doesn’t have to be up to date to the latest millisecond; it’s probably fine if some news is a few seconds old.</p>
<p><strong>Q: But I don’t want my bank statement to be even slightly out of date! How can I make sure that critical shared data is always correct?</strong></p>
<p><strong>A:</strong> CopyOnWriteArrayList is probably not the right choice if all threads need to be working off exactly the same data. Other data structures, like Vector, provide thread-safety by using locks to ensure only one thread at a time has access to the data. This is safe, but can be slow—you’re not getting any benefits of multi-threading if your threads need to wait their turn to get to their data.</p>
<p><strong>Q: So CopyOnWriteArrayList is a fast thread-safe data structure?</strong></p>
<p><strong>A:</strong> Well.. it depends! It’s fast (compared to a locking Collection) if you have lots of reading threads and not many writes. But if there’s a lot of writing going on, it might not be the best data structure. The cost of creating a new copy of the data every time a single write is made might be too high for some applications.</p>
<p><strong>Q: Why isn’t there an easy answer to the best way to do this concurrency stuff?</strong></p>
<p><strong>A:</strong> Concurrent programming is all about trade-offs. You need a good understanding of what your application is doing, how it should work, and the hardware and environment that’s running it.</p>
<p>If you find yourself wondering which approach is better for your application, it’s probably a good time to learn about performance testing so you can measure exactly how each approach impacts the performance in your system.</p>
<p><strong>Q: You never told us about the case where adding final to a field declaration is not enough to make sure that value is never changed. What’s the deal?</strong></p>
<p><strong>A:</strong> Good catch! The “deal” is that if your field is a reference to another object, like a Collection or one of your own objects, using final does not prevent another thread from changing the values inside that object. The only way to make sure that doesn’t happen is to make sure all your fields that are references refer only to immutable objects themselves. Otherwise, your immutable object can have data that changes.</p>
<p>See the LocalDateTime case in <a data-type="xref" href="#more_problems_with_shared_data">“More problems with shared data”</a>.</p>
</div></aside>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">Thread-safe collections in early versions of Java were made safe via locking. For example, java.util.Vector.</span></p>
<p><span style="color:#646466;">Java 5 introduced concurrent data structures in java.util.concurrent. These do NOT use locking.</span></p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-id00020">
<h5>Bullet Points</h5>
<ul>
<li><p>You can have serious problems with threads if two or more threads are trying to change the same data.</p></li>
<li><p>Two or more threads accessing the same object can lead to data corruption if one thread, for example, leaves the running state while still in the middle of manipulating an object’s critical state.</p></li>
<li><p>To make your objects thread-safe, decide which statements should be treated as one atomic process. In other words, decide which methods must run to completion before another thread enters the same method on the same object.</p></li>
<li><p>Use the keyword <strong><code>synchronized</code></strong> to modify a method declaration when you want to prevent two threads from entering that method.</p></li>
<li><p>Every object has a single lock, with a single key for that lock. Most of the time we don’t care about that lock; locks come into play only when an object has synchronized methods or use the synchronized keyword with a specified object.</p></li>
<li><p>When a thread attempts to enter a synchronized method, the thread must get the key for the object (the object whose method the thread is trying to run). If the key is not available (because another thread already has it), the thread goes into a kind of waiting lounge until the key becomes available.</p></li>
<li><p>Even if an object has more than one synchronized method, there is still only one key. Once any thread has entered a synchronized method on that object, no thread can enter any other synchronized method on the same object. This restriction lets you protect your data by synchronizing any method that manipulates the data.</p></li>
<li><p>The synchronized keyword isn’t the only way to safeguard your data from multithreaded changes. Atomic variables, with CAS operations, may be suitable if it’s just one value that is being changed by multiple threads.</p></li>
<li><p>It’s <em>writing</em> data from multiple threads that causes the most problems, not <em>reading</em>, so consider if your data needs to be changed at all or if it can be immutable.</p></li>
<li><p>Make a class immutable by making the class final, making all the fields final, setting the values just once in the constructor or field declaration, and having no setters or other methods that can change the data.</p></li>
<li><p>Having immutable objects in your application doesn’t mean nothing ever changes; it means that you limit the parts of your application where you have to worry about multiple threads changing the data.</p></li>
<li><p>There are thread-safe data structures that let you have multiple threads reading the data while one (or more) threads change the data. Some of these are in java.util.concurrent.</p></li>
<li><p>Concurrent programming is difficult! But there are plenty of tools to help you.</p></li>
</ul>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Exercise"><div class="sect1" id="exercise-id00006">
<h1>Exercise</h1>
<figure class="informal"><div class="figure">
<img src="Images/exercise.png" alt="image" width="150" height="126"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="BE the JVM"><div class="sect2" id="be_the_jvm">
<h2>BE the JVM</h2>
<figure class="informal"><div class="figure">
<img src="Images/f0668-01a.png" alt="image" width="331" height="381"/>
<h6/>
</div></figure>
<p><strong>The Java file on this page represents a complete source file. Your job is to play JVM and determine what the output would be when the program runs.</strong></p>
<p><strong>How might you fix it, making sure the output is correct every time?</strong></p>
<p><span class="inlineimage"><img src="Images/arr1.png" alt="Images" width="137" height="12"/></span> <strong>Answers in <a data-type="xref" href="#be_the_jvm_left_parenthesisfrom_page_668">“BE the JVM”</a>.</strong></p>
<pre data-type="programlisting"><strong>import java.util.*;</strong>
<strong>import java.util.concurrent.*;</strong>

<strong>public class TwoThreadsWriting {</strong>
  <strong>public static void main(String[] args) {</strong>
    <strong>ExecutorService threadPool = Executors.newFixedThreadPool(2);</strong>
    <strong>Data data = new Data();</strong>
    <strong>threadPool.execute(() -&gt; addLetterToData('a', data));</strong>
    <strong>threadPool.execute(() -&gt; addLetterToData('A', data));</strong>
    <strong>threadPool.shutdown();</strong>
  <strong>}</strong>

  <strong>private static void addLetterToData(char letter, Data data) {</strong>
    <strong>for (int i = 0; i &lt; 26; i++) {</strong>
      <strong>data.addLetter(letter++);</strong>
      <strong>try {</strong>
        <strong>Thread.sleep(50);</strong>
      <strong>} catch (InterruptedException ignored) {}</strong>
    <strong>}</strong>
    <strong>System.out.println(Thread.currentThread().getName() + data.getLetters());</strong>
    <strong>System.out.println(Thread.currentThread().getName()</strong>
                               <strong>+ " size = " + data.getLetters().size());</strong>
  <strong>}</strong>
<strong>}</strong>

<strong>final class Data {</strong>
  <strong>private final List&lt;String&gt; letters = new ArrayList&lt;&gt;();</strong>

  <strong>public List&lt;String&gt; getLetters() {return letters;}</strong>

  <strong>public void addLetter(char letter) {</strong>
    <strong>letters.add(String.valueOf(letter));</strong>
  <strong>}</strong>
<strong>}</strong></pre>
<section data-type="sect3" data-pdf-bookmark="Near-miss at the airlock"><div class="sect3" id="near_miss_at_the_airlock">
<h3>Near-miss at the airlock</h3>
<figure class="informal"><div class="figure">
<img src="Images/f0415-01.png" alt="image" width="100" height="67"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="puzzles" data-secondary="Five-Minute Mystery" id="idm46038386656624"/>As Sarah joined the onboard development team’s design review meeting, she gazed out the portal at sunrise over the Indian Ocean. Even though the ship’s conference room was incredibly claustrophobic, the sight of the growing blue and white crescent overtaking night on the planet below filled Sarah with awe and appreciation.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Five-Minute Mystery"><div class="sect2" id="five_minute_mystery-id0001000">
<h2>Five-Minute Mystery</h2>
<figure class="informal"><div class="figure">
<img src="Images/f0415-02.png" alt="image" width="150" height="114"/>
<h6/>
</div></figure>
<p>This morning’s meeting was focused on the control systems for the orbiter’s airlocks. As the final construction phases were nearing their end, the number of spacewalks was scheduled to increase dramatically, and traffic was high both in and out of the ship’s airlocks. “Good morning, Sarah,” said Tom, “Your timing is perfect; we’re just starting the detailed design review.”</p>
<p>“As you all know,” said Tom, “Each airlock is outfitted with space-hardened GUI terminals, both inside and out. Whenever spacewalkers are entering or exiting the orbiter they will use these terminals to initiate the airlock sequences.” Sarah nodded and asked, “Tom, can you tell us what the method sequences are for entry and exit?” Tom rose and floated to the whiteboard, “First, here’s the exit sequence method’s pseudocode.” Tom quickly wrote on the board.</p>
<pre data-type="programlisting">orbiterAirlockExitSequence()

  verifyPortalStatus();

  pressurizeAirlock();

  openInnerHatch();

  confirmAirlockOccupied();

  closeInnerHatch();

  decompressAirlock();

  openOuterHatch();

  confirmAirlockVacated();

  closeOuterHatch();</pre>
<p>“To ensure that the sequence is not interrupted, we have synchronized all of the methods called by the orbiterAirlockExitSequence() method,” Tom explained. “We’d hate to see a returning spacewalker inadvertently catch a buddy with his space pants down!”</p>
<p>Everyone chuckled as Tom erased the whiteboard, but something didn’t feel right to Sarah, and it finally clicked as Tom began to write the entry sequence pseudocode on the whiteboard. “Wait a minute, Tom!” cried Sarah, “I think we’ve got a big flaw in the exit sequence design.</p>
<p>Let’s go back and revisit it; it could be critical!”</p>
<p><strong><em>Why did Sarah stop the meeting? What did she suspect?</em></strong></p>
<p><span class="inlineimage"><img src="Images/arr1.png" alt="Images" width="137" height="12"/></span> <strong>Answers in <a data-type="xref" href="#five-minute_mystery_left_parent-id0002">“Five-Minute Mystery”</a>.</strong></p> 
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Exercise Solution"><div class="sect1" id="exercise_solution-id00005">
<h1>Exercise Solution</h1>
<figure class="informal"><div class="figure">
<img src="Images/exercise.png" alt="image" width="150" height="126"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="BE the JVM"><div class="sect2" id="be_the_jvm_left_parenthesisfrom_page_668">
<h2>BE the JVM</h2>
<p>(from <a data-type="xref" href="#be_the_jvm">“BE the JVM”</a>)</p>
<p>The answer is the output won’t be the same every time. In theory, one might expect the size to always be 52 (2 × 26 letters in the alphabet), but in fact this is one of those lost-update problems.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0670-01.png" alt="image" width="643" height="234"/>
<h6/>
</div></figure>
<p>It can be solved in two different ways; both are valid.</p>
<p><strong>Synchronize the write method</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0670-02.png" alt="image" width="699" height="151"/>
<h6/>
</div></figure>
<p><strong>Use a thread-safe collection</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0670-03.png" alt="image" width="696" height="99"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">Use either solution, you do NOT have to do both!!</span></p>
<p><span style="color:#646466;">With a thread-safe collection, you don’t have to synchronize the writing method.</span></p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Five-Minute Mystery"><div class="sect2" id="five-minute_mystery_left_parent-id0002">
<h2>Five-Minute Mystery</h2>
<p>(from <a data-type="xref" href="#be_the_jvm">“BE the JVM”</a>)</p>
<figure class="informal"><div class="figure">
<img src="Images/f0415-01.png" alt="image" width="100" height="67"/>
<h6/>
</div></figure>
<p><strong>What did Sarah know?</strong></p>
<p>Sarah realized that in order to ensure that the entire exit sequence would run without interruption the <code>orbiterAirlockExitSequence</code>( ) method needed to be synchronized. As the design stood, it would be possible for a returning spacewalker to interrupt the Exit Sequence! The Exit Sequence thread couldn’t be interrupted in the middle of any of the lower-level method calls, but it could be interrupted in <em>between</em> those calls. Sarah knew that the entire sequence should be run as one atomic unit, and if the <code>orbiterAirlockExitSequence()</code> method was synchronized, it could not be interrupted at any point.</p>
</div></section>
</div></section>
</div></section></div></body></html>