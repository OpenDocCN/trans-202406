<html><head></head><body><section data-pdf-bookmark="Chapter 8. Linkerd Policy: Overview  and Server-Based Policy" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="LUAR_server_policy">
<h1 class="calibre7"><span class="calibre">Chapter 8. </span>Linkerd Policy: Overview 
<span class="calibre">and Server-Based Policy</span></h1>


<p class="author1">Microservices applications, as<a data-primary="policy" data-secondary="overview" data-tertiary="about policy" data-type="indexterm" id="id1215" class="calibre4"/> we discussed in <a data-type="xref" href="ch07.html#LUAR_mtls_and_certs" class="calibre4">Chapter 7</a>,
require a different level of network security than more traditional monoliths.
mTLS gives you the secure communications and workload identity that you need to
start tackling this level of network security—but it’s Linkerd’s <em class="hyperlink">policy</em>
mechanisms that provide the ability to use that identity to control how
workloads can talk to each other in your environment.</p>

<p class="author1">Linkerd supports two kinds of policy mechanisms: <em class="hyperlink">Server-based</em> and
<em class="hyperlink">route-based</em>. Since policy is the single most complex area of Linkerd,
we’ll provide an overview and cover Server-based policy in this chapter, then
tackle route-based policy in <a data-type="xref" href="ch09.html#LUAR_route_policy" class="calibre4">Chapter 9</a>.</p>






<section data-pdf-bookmark="Linkerd Policy Overview" data-type="sect1" class="preface"><div class="preface" id="id62">
<h1 class="calibre8">Linkerd Policy Overview</h1>

<p class="author1">All Linkerd policy mechanisms are based<a data-primary="policy" data-secondary="overview" data-type="indexterm" id="id1216" class="calibre4"/><a data-primary="policy" data-secondary="overview" data-tertiary="explicit authorization" data-type="indexterm" id="id1217" class="calibre4"/><a data-primary="explicit authorization of Linkerd policy" data-type="indexterm" id="id1218" class="calibre4"/><a data-primary="authorization" data-secondary="explicit authorization of Linkerd policy" data-type="indexterm" id="id1219" class="calibre4"/> on <em class="hyperlink">explicit authorization</em>: Linkerd starts out
assuming that it should allow nothing and must be explicitly told what
requests should be allowed. This
lines up nicely with the zero trust model and<a data-primary="permissions" data-secondary="explicit authorization of Linkerd policy" data-type="indexterm" id="id1220" class="calibre4"/> makes it straightforward to
reason about permissions, since policy resources are always <em class="hyperlink">permitting</em>
things to happen.</p>

<p class="author1">Don’t panic, though; this doesn’t mean a policy is always a morass of
hundreds of resources. <a data-primary="policy" data-secondary="overview" data-tertiary="default policy versus dynamic policy resources" data-type="indexterm" id="id1221" class="calibre4"/><a data-primary="policy" data-secondary="default policy" data-tertiary="about" data-type="indexterm" id="id1222" class="calibre4"/>Linkerd allows setting a <em class="hyperlink">default policy</em> at the cluster,
namespace, and Pod levels, <a data-primary="Pods" data-secondary="policy" data-tertiary="policy hierarchy" data-type="indexterm" id="id1223" class="calibre4"/><a data-primary="namespaces" data-secondary="policy hierarchy" data-type="indexterm" id="id1224" class="calibre4"/>with policy settings at more specific levels overriding
policy settings at more general levels: Pods override namespaces, which override
cluster-wide settings, as shown in <a data-type="xref" href="#linkerd-policy-default-settings" class="calibre4">Figure 8-1</a>.</p>

<figure class="calibre23"><div class="figure" id="linkerd-policy-default-settings">
<img alt="luar 0801" src="assets/luar_0801.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 8-1. </span>Different Linkerd default policy settings</h6>
</div></figure>

<p class="author1">It may seem strange to talk about defaults overriding defaults. Here,
“default” is in contrast to the other kind of policy setting that Linkerd
supports: using <em class="hyperlink">dynamic policy resources</em>. The default policy is simply the policy
that applies when no dynamic resource is present for a given request.</p>

<p class="author1">Policy is always enforced along<a data-primary="policy" data-secondary="overview" data-tertiary="Pod boundaries" data-type="indexterm" id="id1225" class="calibre4"/><a data-primary="Pods" data-secondary="policy" data-tertiary="enforced on Pod boundaries" data-type="indexterm" id="id1226" class="calibre4"/> Pod boundaries, since the Pod is the basic
unit managed by Linkerd. It’s not possible, for example, to write a policy
that will affect communications with a single container in a Pod.</p>








<section data-pdf-bookmark="Linkerd Default Policy" data-type="sect2" class="preface"><div class="preface" id="id63">
<h2 class="calibre27">Linkerd Default Policy</h2>

<p class="author1">Linkerd has the following default policy options:<a data-primary="policy" data-secondary="default policy" data-type="indexterm" id="ch08-defpo" class="calibre4"/></p>
<dl class="calibre10">
<dt class="calibre11"><code class="calibre14">all-unauthenticated</code></dt>
<dd class="calibre12">
<p class="calibre13">Allow all traffic, whether authenticated or not.</p>
</dd>
<dt class="calibre11"><code class="calibre14">cluster-unauthenticated</code></dt>
<dd class="calibre12">
<p class="calibre13">Allow all traffic from <em class="hyperlink">this cluster</em>.</p>
</dd>
<dt class="calibre11"><code class="calibre14">all-authenticated</code></dt>
<dd class="calibre12">
<p class="calibre13">Allow traffic from all meshed clients.</p>
</dd>
<dt class="calibre11"><code class="calibre14">cluster-authenticated</code></dt>
<dd class="calibre12">
<p class="calibre13">Allow traffic from meshed clients in <em class="hyperlink">this cluster</em>.</p>
</dd>
<dt class="calibre11"><code class="calibre14">deny</code></dt>
<dd class="calibre12">
<p class="calibre13">Deny everything.</p>
</dd>
</dl>

<p class="author1">The distinction between<a data-primary="multicluster setups" data-secondary="default policy" data-type="indexterm" id="id1227" class="calibre4"/> <code class="calibre9">all</code> and <code class="calibre9">cluster</code> is relevant only if you’re using
multicluster (as discussed in <a data-type="xref" href="ch12.html#LUAR_multicluster" class="calibre4">Chapter 12</a>). In a
multicluster setting, <code class="calibre9">all</code> includes clients from other clusters, whereas
<code class="calibre9">cluster</code> does not, as shown in <a data-type="xref" href="#linkerd-all-vs-cluster" class="calibre4">Figure 8-2</a>. If you’re not
using multicluster, the two are equivalent.</p>

<figure class="calibre23"><div class="figure" id="linkerd-all-vs-cluster">
<img alt="luar 0802" src="assets/luar_0802.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 8-2. </span><code class="calibre9">all</code> versus <code class="calibre9">cluster</code></h6>
</div></figure>

<p class="author1">The cluster default policy is set<a data-primary="policy" data-secondary="default policy" data-tertiary="permissiveness of" data-type="indexterm" id="id1228" class="calibre4"/><a data-primary="authentication" data-secondary="default policy all-unauthenticated" data-type="indexterm" id="id1229" class="calibre4"/><a data-primary="deploying Linkerd" data-secondary="configuration" data-tertiary="cluster default policy" data-type="indexterm" id="id1230" class="calibre4"/><a data-primary="all-unauthenticated default policy" data-type="indexterm" id="id1231" class="calibre4"/><a data-primary="configuring Linkerd" data-secondary="cluster default policy" data-type="indexterm" id="id1232" class="calibre4"/><a data-primary="Helm for Linkerd deployment" data-secondary="configuration of Linkerd" data-tertiary="cluster default policy" data-type="indexterm" id="id1233" class="calibre4"/> at install time with the
<code class="calibre9">proxy.defaultInboundPolicy</code> value, as shown in <a data-type="xref" href="#EX10-cluster-default" class="calibre4">Example 8-1</a>. If
not set, the cluster default policy will be <code class="calibre9">all-unauthenticated</code>: this allows
absolutely any request, mirroring Kubernetes’s default wide-open stance.
Linkerd uses this default to ensure that users who don’t want or need
to use policy (or who just haven’t gotten to that point in hardening their
clusters yet) won’t be negatively impacted when they install Linkerd.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Why the Permissive Default Policy?</h1>
<p class="author1">Linkerd’s default <code class="calibre9">all-unauthenticated</code> is obviously not good for security,
and we <em class="hyperlink">strongly</em> advise you to pick a different cluster default for
production installations.</p>

<p class="author1">However, as a practical matter, literally any other base default almost
guarantees that installing Linkerd into a running application would break
things. Ultimately, <code class="calibre9">all-unauthenticated</code> as the base default is the only way
to allow Linkerd to do no harm when first brought into an application, and
that’s <em class="hyperlink">why</em> it’s the base default.</p>
</div>
<div data-type="example" id="EX10-cluster-default" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-1. </span>Setting the cluster default policy</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># We can set the cluster's default policy with Helm...</code>
$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>linkerd-control-plane<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>...<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>--set<code class="w"> </code>proxy.defaultInboundPolicy<code class="o">=</code>all-authenticated<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>...<code class="w"/>

<code class="c"># ...or with the Linkerd CLI.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>install<code class="w"> </code><code class="se">\</code>
<code class="w">        </code>...<code class="w"/>
<code class="w">        </code>--set<code class="w"> </code>proxy.defaultInboundPolicy<code class="o">=</code>all-authenticated<code class="w"> </code><code class="se">\</code>
<code class="w">        </code>...<code class="w"> </code><code class="se">\</code>
<code class="w">    </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>install<code class="w"> </code>-<code class="w"/></pre></div>

<p class="author1">To override the default for a namespace, workload, or Pod, you’ll use the

<span class="calibre"><code class="calibre9">config.linkerd.io/default-inbound-policy</code></span> annotation, setting it to one of the
values listed earlier, as shown here:<a data-startref="ch08-defpo" data-type="indexterm" id="id1234" class="calibre4"/></p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36"><code class="calibre9">$</code><code class="w"> </code><code class="calibre9">kubectl</code><code class="w"> </code><code class="calibre9">annotate</code><code class="w"> </code><code class="calibre9">namespace</code><code class="w"> </code><em class="calibre37"><code class="calibre15">your-namespace</code></em><code class="w"> </code><code class="se">\
</code><code class="w">        </code><code class="calibre9">config.linkerd.io/default-inbound-policy</code><code class="o">=</code><code class="calibre9">all-authenticated</code></pre>
</div></section>








<section data-pdf-bookmark="Linkerd Policy Resources" data-type="sect2" class="preface"><div class="preface" id="id64">
<h2 class="calibre27">Linkerd Policy Resources</h2>

<p class="author1">To override the default policy,<a data-primary="policy" data-secondary="policy resources" data-type="indexterm" id="id1235" class="calibre4"/><a data-primary="policy" data-secondary="default policy" data-tertiary="policy resources overriding" data-type="indexterm" id="id1236" class="calibre4"/><a data-primary="CRDs (custom resource definitions)" data-secondary="policy resources as" data-type="indexterm" id="id1237" class="calibre4"/> you use policy resources, which are CRDs that
configure which requests should be permitted:<a data-primary="policy" data-secondary="policy resources" data-tertiary="Server resource" data-type="indexterm" id="id1238" class="calibre4"/><a data-primary="Server resources" data-type="indexterm" id="id1239" class="calibre4"/><a data-primary="HTTPRoute resource" data-type="indexterm" id="id1240" class="calibre4"/><a data-primary="MeshTLSAuthentication resource" data-type="indexterm" id="id1241" class="calibre4"/><a data-primary="NetworkAuthentication resource" data-type="indexterm" id="id1242" class="calibre4"/><a data-primary="AuthorizationPolicy resources" data-type="indexterm" id="id1243" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="HTTPRoute resource" data-type="indexterm" id="id1244" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="MeshTLSAuthentication resource" data-type="indexterm" id="id1245" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="NetworkAuthentication resource" data-type="indexterm" id="id1246" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="AuthorizationPolicy resources" data-type="indexterm" id="id1247" class="calibre4"/></p>
<dl class="calibre10">
<dt class="calibre11">Server</dt>
<dd class="calibre12">
<p class="calibre13">Describes one or more Pods and one port on those Pods</p>
</dd>
<dt class="calibre11">HTTPRoute</dt>
<dd class="calibre12">
<p class="calibre13">Describes a subset of the HTTP traffic to a given Server</p>
</dd>
<dt class="calibre11">MeshTLSAuthentication</dt>
<dd class="calibre12">
<p class="calibre13">Describes one or more mesh identities</p>
</dd>
<dt class="calibre11">NetworkAuthentication</dt>
<dd class="calibre12">
<p class="calibre13">Describes one or more IP addresses</p>
</dd>
<dt class="calibre11">AuthorizationPolicy</dt>
<dd class="calibre12">
<p class="calibre13">Binds a Server or HTTPRoute to mesh or network authentications</p>
</dd>
</dl>

<p class="author1">These resources work together as shown in <a data-type="xref" href="#linkerd-policy-resources" class="calibre4">Figure 8-3</a>; for
example, an AuthorizationPolicy can link a Server and a MeshTLSAuthentication
to permit a specific set of mesh identities to access the Server.</p>

<figure class="calibre23"><div class="figure" id="linkerd-policy-resources">
<img alt="luar 0803" src="assets/luar_0803.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 8-3. </span>Linkerd policy resources</h6>
</div></figure>

<p class="author1">Let’s take a closer look at each of these resources and how they’re used to configure Linkerd policy.</p>










<section data-pdf-bookmark="Server" data-type="sect3" class="preface"><div class="preface" id="id320">
<h3 class="calibre33">Server</h3>

<p class="author1">We talked about the Server resource briefly in <a data-type="xref" href="ch04.html#LUAR_meshing_workloads" class="calibre4">Chapter 4</a>. Server
resources are specific to Linkerd; they allow describing a single specific
port of a workload. For example, the Server in <a data-type="xref" href="#EX10-server" class="calibre4">Example 8-2</a> describes the
<code class="calibre9">http</code> port of the <code class="calibre9">foo</code> workload, which is the set of Pods with the <code class="calibre9">app:
foo</code> label. This Server also notes that that port carries HTTP/1.1 traffic.</p>
<div data-type="example" id="EX10-server" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-2. </span>A Server resource</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">policy.linkerd.io/v1beta1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">Server</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">foo</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">foo-ns</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre9">foo</code><code class="w"/>
<code class="w">  </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">http</code><code class="w"/>
<code class="w">  </code><code class="nt">proxyProtocol</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HTTP/1</code><code class="w"/></pre></div>

<p class="author1">Note that Server is a namespaced resource that must appear in the same
namespace as the Pods it needs to match.</p>
</div></section>










<section data-pdf-bookmark="HTTPRoute" data-type="sect3" class="preface"><div class="preface" id="id65">
<h3 class="calibre33">HTTPRoute</h3>

<p class="author1">HTTPRoute is a Gateway API resource<a data-primary="HTTPRoute resource" data-type="indexterm" id="id1248" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="HTTPRoute resource" data-type="indexterm" id="id1249" class="calibre4"/><a data-primary="Gateway API" data-secondary="HTTPRoute resource" data-type="indexterm" id="id1250" class="calibre4"/><a data-primary="APIs" data-secondary="Gateway API" data-tertiary="HTTPRoute" data-type="indexterm" id="id1251" class="calibre4"/> that describes specific HTTP requests. We’ll discuss HTTPRoute more in <a data-type="xref" href="ch09.html#LUAR_route_policy" class="calibre4">Chapter 9</a>.</p>
</div></section>










<section data-pdf-bookmark="MeshTLSAuthentication" data-type="sect3" class="preface"><div class="preface" id="id66">
<h3 class="calibre33">MeshTLSAuthentication</h3>

<p class="author1">MeshTLSAuthentication describes<a data-primary="MeshTLSAuthentication resource" data-type="indexterm" id="id1252" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="MeshTLSAuthentication resource" data-type="indexterm" id="id1253" class="calibre4"/> a particular set of mesh identities. Any
workload running with one of the listed identities will match the
MeshTLSAuthentication. For example, <a data-type="xref" href="#EX10-4" class="calibre4">Example 8-3</a> shows a
MeshTLSAuthentication for the single identity
<code class="calibre9">foo.foo-ns.serviceaccount.identity.linkerd.cluster.local</code>.</p>
<div data-type="example" id="EX10-4" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-3. </span>A MeshTLSAuthentication resource</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">policy.linkerd.io/v1alpha1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">MeshTLSAuthentication</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">foo</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">foo-ns</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">identities</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="s">"foo.foo-ns.serviceaccount.identity.linkerd.cluster.local"</code><code class="w"/></pre></div>

<p class="author1">MeshTLSAuthentication is a namespaced resource. It will typically be placed in
the same namespace as the workloads it’s associated with, although this isn’t
a strict requirement.</p>
</div></section>










<section data-pdf-bookmark="NetworkAuthentication" data-type="sect3" class="preface"><div class="preface" id="id67">
<h3 class="calibre33">NetworkAuthentication</h3>

<p class="author1">A NetworkAuthentication resource<a data-primary="NetworkAuthentication resource" data-type="indexterm" id="id1254" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="NetworkAuthentication resource" data-type="indexterm" id="id1255" class="calibre4"/> describes a set of IP address CIDR ranges.
Any request coming from one of the listed ranges will match the
NetworkAuthentication.</p>

<p class="author1">Given that Linkerd makes such a big deal about using workload identity rather
than network identity, it may seem strange that the NetworkAuthentication
resource exists at all; however, as a practical matter, it can be useful at
times when managing unmeshed clients.</p>

<p class="author1">NetworkAuthentication is a namespaced resource. It will typically be placed in
the same namespace as the workloads it’s associated with, although this isn’t
a strict requirement.</p>
</div></section>










<section data-pdf-bookmark="AuthorizationPolicy" data-type="sect3" class="preface"><div class="preface" id="id68">
<h3 class="calibre33">AuthorizationPolicy</h3>

<p class="author1">Linkerd AuthorizationPolicy resources<a data-primary="AuthorizationPolicy resources" data-type="indexterm" id="id1256" class="calibre4"/><a data-primary="policy" data-secondary="policy resources" data-tertiary="AuthorizationPolicy resources" data-type="indexterm" id="id1257" class="calibre4"/> <em class="hyperlink">permit access</em> to a <em class="hyperlink">target</em> for some
<em class="hyperlink">required authentications</em>. The target, at present, must be a Server or an
HTTPRoute. The required authentications must be one or more
MeshTLSAuthentication or NetworkAuthentication resources.</p>

<p class="author1">AuthorizationPolicy is a namespaced resource. It will typically be placed in
the same namespace as the workloads it’s associated with, although this isn’t
a strict 
<span class="calibre">requirement.</span></p>

<p class="author1">We’ll go deeper into the individual objects as we begin actually using policy
to lock down our cluster.</p>
</div></section>
</div></section>








<section data-pdf-bookmark="Server-Based Policy Versus Route-Based Policy" data-type="sect2" class="preface"><div class="preface" id="id153">
<h2 class="calibre27">Server-Based Policy Versus Route-Based Policy</h2>

<p class="author1">Server-based policy gets its name<a data-primary="policy" data-secondary="Server-based versus route-based" data-type="indexterm" id="id1258" class="calibre4"/><a data-primary="Server resources" data-secondary="Server-based versus route-based policy" data-type="indexterm" id="id1259" class="calibre4"/><a data-primary="policy" data-secondary="route-based policy overview" data-tertiary="Server-based versus route-based" data-type="indexterm" id="id1260" class="calibre4"/> because it relies on Linkerd Server
resources. You’ll note that while the Server resource describes a workload
and port, it does <em class="hyperlink">not</em> describe anything about requests. This means that
Server-based policy can’t differentiate separate requests to a given Server,
instead requiring every request going to a Server to adhere to the same
policy.</p>

<p class="author1">Route-based policy (which we’ll discuss in <a data-type="xref" href="ch09.html#LUAR_route_policy" class="calibre4">Chapter 9</a>), on
the other hand, <em class="hyperlink">does</em> get to take request details into account. It is a more
powerful—and also more complex—mechanism.</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Server-Based Policy with the emojivoto Application" data-type="sect1" class="preface"><div class="preface" id="id154">
<h1 class="calibre8">Server-Based Policy with the emojivoto Application</h1>

<p class="author1">We’ll use the <a href="https://oreil.ly/g7fDb" class="calibre4">emojivoto sample
application</a> to illustrate<a data-primary="emojivoto application" data-secondary="download URL" data-type="indexterm" id="id1261" class="calibre4"/><a data-primary="policy" data-secondary="Server-based with emojivoto application" data-type="indexterm" id="id1262" class="calibre4"/><a data-primary="emojivoto application" data-secondary="Server-based policy" data-type="indexterm" id="id1263" class="calibre4"/><a data-primary="applications" data-secondary="Server-based policy with" data-type="indexterm" id="id1264" class="calibre4"/><a data-primary="Server resources" data-secondary="Server-based policy with emojivoto application" data-type="indexterm" id="id1265" class="calibre4"/><a data-primary="resources online" data-secondary="emojivoto application" data-type="indexterm" id="id1266" class="calibre4"/> working with policy in Linkerd. For reference,
<a data-type="xref" href="#emojivoto-policy-overview" class="calibre4">Figure 8-4</a> shows our end goal: the entire emojivoto
application will be protected from accesses that shouldn’t happen.</p>

<figure class="calibre23"><div class="figure" id="emojivoto-policy-overview">
<img alt="luar 0804" src="assets/luar_0804.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 8-4. </span>emojivoto policy overview</h6>
</div></figure>

<p class="author1">In this chapter, we’ll guide you through a few different patterns you can
adopt for your cluster, each of which will progressively lock down your
applications and what they can communicate with.</p>








<section data-pdf-bookmark="Configuring the Default Policy" data-type="sect2" class="preface"><div class="preface" id="id211">
<h2 class="calibre27">Configuring the Default Policy</h2>

<p class="author1">The first step we can take to<a data-primary="policy" data-secondary="Server-based with emojivoto application" data-tertiary="configuring default policy" data-type="indexterm" id="ch08-defpolcon" class="calibre4"/><a data-primary="Server resources" data-secondary="Server-based policy with emojivoto application" data-tertiary="configuring default policy" data-type="indexterm" id="ch08-defpolcon2" class="calibre4"/><a data-primary="emojivoto application" data-secondary="Server-based policy" data-tertiary="configuring default policy" data-type="indexterm" id="ch08-defpolcon3" class="calibre4"/><a data-primary="policy" data-secondary="default policy" data-tertiary="configuring" data-type="indexterm" id="ch08-defpolcon4" class="calibre4"/> lock down our clusters is also one of the most
impactful and wide-ranging. Linkerd provides a straightforward mechanism for
setting the default inbound policy for all of our proxies. In this section
we’re going to show you how to set the default inbound policy at the cluster
and namespace level.</p>










<section data-pdf-bookmark="Cluster default policy" data-type="sect3" class="preface"><div class="preface" id="id155">
<h3 class="calibre33">Cluster default policy</h3>

<p class="author1">Let’s start by setting the <a data-primary="policy" data-secondary="Server-based with emojivoto application" data-tertiary="cluster default policy" data-type="indexterm" id="id1267" class="calibre4"/><a data-primary="policy" data-secondary="default policy" data-tertiary="cluster default policy" data-type="indexterm" id="id1268" class="calibre4"/><a data-primary="authentication" data-secondary="default policy all-unauthenticated" data-tertiary="cluster default policy" data-type="indexterm" id="id1269" class="calibre4"/><a data-primary="all-unauthenticated default policy" data-secondary="cluster default policy" data-type="indexterm" id="id1270" class="calibre4"/><a data-primary="emojivoto application" data-secondary="Server-based policy" data-tertiary="cluster default policy" data-type="indexterm" id="id1271" class="calibre4"/>default policy for the entire cluster. Remember, when you
install Linkerd, the default policy for the whole cluster is
<code class="calibre9">all-unauthenticated</code>, which allows absolutely any request, mirroring
Kubernetes’s default wide-open stance.</p>

<p class="author1">We’ll start by switching the default policy for the cluster to
<code class="calibre9">all-authenticated</code>. This will require that all connections to meshed Pods
come from other Pods that are in the mesh. This is good for security, but adds
some operational overhead since you’ll need to carve out exceptions for any
nonmeshed applications that you want to continue being able to talk to meshed
Pods. For example, imagine that you have a nonmeshed monitoring tool: when
you flip the default to <code class="calibre9">all-authenticated</code>, it will suddenly be unable to
talk to your meshed Pods, and you’ll either need to mesh the monitoring tool
or add an exception to your Linkerd policy for it.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">To Deny or Not to Deny</h1>
<p class="author1">In a perfect world, your entire cluster<a data-primary="policy" data-secondary="default policy" data-tertiary="deny as default policy" data-type="indexterm" id="id1272" class="calibre4"/><a data-primary="production" data-secondary="all-unauthenticated cluster default policy" data-type="indexterm" id="id1273" class="calibre4"/><a data-primary="all-unauthenticated default policy" data-secondary="cluster default policy" data-tertiary="production environment" data-type="indexterm" id="id1274" class="calibre4"/><a data-primary="authentication" data-secondary="default policy all-unauthenticated" data-tertiary="production environment" data-type="indexterm" id="id1275" class="calibre4"/> would have its default policy set to
<code class="calibre9">deny</code>. This is absolutely the best practice from a security perspective,
but if you’re starting with an existing application, adding Linkerd with the
default set to <code class="calibre9">deny</code> is very likely to break things unless you know <em class="hyperlink">all</em> of
the different traffic that you’ll need to permit. In practice, that’s rare if
you weren’t already working with fine-grained security tools.</p>

<p class="author1">An effective and practical compromise can be to start with
<code class="calibre9">all-unauthenticated</code>, then use Linkerd’s observability tools to determine
what traffic should be permitted before gradually tightening security via
<code class="calibre9">all-authenticated</code> or <code class="calibre9">cluster-authenticated</code> on the way to <code class="calibre9">deny</code>. Also
remember that you can switch specific namespaces to <code class="calibre9">deny</code> as steps toward
getting the whole cluster to <code class="calibre9">deny</code>.</p>

<p class="author1">In a <em class="hyperlink">nonproduction</em> environment, of course, the broad stroke of just
flipping everything to <code class="calibre9">deny</code> and watching what breaks is a <em class="hyperlink">great</em> way to see
exactly what communications are happening that you haven’t thought of yet.
Just don’t go there in production!</p>
</div>

<p class="author1">Because the cluster-wide policy<a data-primary="Helm for Linkerd deployment" data-secondary="cluster-wide policy" data-type="indexterm" id="id1276" class="calibre4"/> is a global setting, we’ll configure it using
Helm. In <a data-type="xref" href="#EX10-5" class="calibre4">Example 8-4</a>, we’ll use <code class="calibre9">helm upgrade</code> to change Linkerd’s settings
without changing the version of Linkerd you have installed. This example
assumes you’re using Linkerd 2.13.4.</p>
<div data-type="example" id="EX10-5" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-4. </span>Cluster policy</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Use helm upgrade to set the global inbound policy to all-authenticated.</code>
$<code class="w"> </code>helm<code class="w"> </code>upgrade<code class="w"> </code>linkerd-control-plane<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--set<code class="w"> </code>proxy.defaultInboundPolicy<code class="o">=</code>all-authenticated<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--version<code class="w">  </code><code class="m">1</code>.12.4<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--reuse-values<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>linkerd/linkerd-control-plane<code class="w"/>

<code class="c"># Now we can install the emojivoto app in our cluster to validate that it</code>
<code class="c"># can operate normally while meshed.</code>
$<code class="w"> </code>curl<code class="w"> </code>--proto<code class="w"> </code><code class="s">'=https'</code><code class="w"> </code>--tlsv1.2<code class="w"> </code>-sSfL<code class="w"> </code>https://run.linkerd.io/emojivoto.yml<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>linkerd<code class="w"> </code>inject<code class="w"> </code>-<code class="w"> </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># Once your Pods are up and running, test the emojivoto application to see</code>
<code class="c"># if it's still working.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>port-forward<code class="w"> </code>svc/web-svc<code class="w"> </code><code class="m">8080</code>:80<code class="w"/>

<code class="c"># Now browse to localhost:8080 and look at the emojivoto app. You should</code>
<code class="c"># see the normal voting page.</code></pre></div>
</div></section>










<section data-pdf-bookmark="Namespace default policy" data-type="sect3" class="preface"><div class="preface" id="id69">
<h3 class="calibre33">Namespace default policy</h3>

<p class="author1">Going further, we can flip<a data-primary="policy" data-secondary="default policy" data-tertiary="namespace default policy" data-type="indexterm" id="id1277" class="calibre4"/><a data-primary="policy" data-secondary="Server-based with emojivoto application" data-tertiary="namespace default policy" data-type="indexterm" id="id1278" class="calibre4"/><a data-primary="namespaces" data-secondary="default policy" data-type="indexterm" id="id1279" class="calibre4"/><a data-primary="emojivoto application" data-secondary="Server-based policy" data-tertiary="namespace default policy" data-type="indexterm" id="id1280" class="calibre4"/> the <code class="calibre9">emojivoto</code> namespace to <code class="calibre9">deny</code> to further
protect our application, as shown in <a data-type="xref" href="#EX10-namespace" class="calibre4">Example 8-5</a>. Once we do this,
<em class="hyperlink">all</em> traffic in the namespace will be denied unless we explicitly authorize
it.</p>
<div data-type="example" id="EX10-namespace" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-5. </span>Namespace policy</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Start by using kubectl to annotate the namespace. We're going to set it</code>
<code class="c"># to deny all traffic that hasn't been explicitly authorized.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>annotate<code class="w"> </code>namespace<code class="w"> </code>emojivoto<code class="w"> </code>config.linkerd.io/default-inbound-policy<code class="o">=</code>deny<code class="w"/>

<code class="c"># With that done, the policy changes won't have any impact on the Pods that</code>
<code class="c"># are already running. You will need to perform a rollout restart for the</code>
<code class="c"># new default policy to take effect.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>rollout<code class="w"> </code>restart<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>

<code class="c"># Once your Pods are up and running, test the emojivoto application to see</code>
<code class="c"># if it's still working.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>port-forward<code class="w"> </code>svc/web-svc<code class="w"> </code><code class="m">8080</code>:80<code class="w"/>

<code class="c"># Now browse to localhost:8080 and look at the emojivoto app. You should now</code>
<code class="c"># see the page load, but all the emojis are gone. That is because the web</code>
<code class="c"># frontend can no longer talk to either of its backends, voting or emoji.</code></pre></div>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Timing Matters</h1>
<p class="author1">Linkerd’s default inbound policy<a data-primary="policy" data-secondary="read by proxies at startup" data-type="indexterm" id="id1281" class="calibre4"/><a data-primary="Pods" data-secondary="policy" data-tertiary="changes taking effect when Pods created" data-type="indexterm" id="id1282" class="calibre4"/><a data-primary="APIs" data-secondary="Kubernetes API" data-tertiary="inbound policy changes" data-type="indexterm" id="id1283" class="calibre4"/><a data-primary="Kubernetes API" data-secondary="inbound policy changes" data-type="indexterm" id="id1284" class="calibre4"/> is read by your proxies at startup time. It is not read dynamically. This is important for operators to be aware of because it means any changes you make only take effect when your Pods are created. If you change the default inbound policy for the cluster or a namespace, those changes will only take effect after the Pods in your namespace are re-created. Pod-level inbound policy changes will take effect when the Kubernetes API restarts the modified Pods, so they will effectively get applied as soon as you modify the Deployments, StatefulSets, or DaemonSets in question.</p>
</div>

<p class="author1">With that, we’ve managed to block communication between our workloads in the

<span class="calibre"><code class="calibre9">emojivoto</code></span> namespace…and <em class="hyperlink">everything</em> is broken. To make the app work again,
we need to start allowing necessary traffic again with <em class="hyperlink">dynamic policy</em>.<a data-startref="ch08-defpolcon" data-type="indexterm" id="id1285" class="calibre4"/><a data-startref="ch08-defpolcon2" data-type="indexterm" id="id1286" class="calibre4"/><a data-startref="ch08-defpolcon3" data-type="indexterm" id="id1287" class="calibre4"/><a data-startref="ch08-defpolcon4" data-type="indexterm" id="id1288" class="calibre4"/></p>
</div></section>
</div></section>








<section data-pdf-bookmark="Configuring Dynamic Policy" data-type="sect2" class="preface"><div class="preface" id="id156">
<h2 class="calibre27">Configuring Dynamic Policy</h2>

<p class="author1">As demonstrated, it’s not very useful<a data-primary="policy" data-secondary="Server-based with emojivoto application" data-tertiary="configuring dynamic policy" data-type="indexterm" id="ch08-dyn" class="calibre4"/><a data-primary="emojivoto application" data-secondary="Server-based policy" data-tertiary="configuring dynamic policy" data-type="indexterm" id="ch08-dyn2" class="calibre4"/><a data-primary="policy" data-secondary="dynamic policy configuration" data-type="indexterm" id="id1289" class="calibre4"/> just to use defaults to block
everything. It’s time to look at how to use our dynamic policy resources to allow useful,
necessary traffic to flow. We’ll start with a fairly simple concept: many
organizations treat namespaces as logical boundaries between applications or
teams, so it often makes sense to allow workloads in the same namespace to
talk to each other. This is commonly called <em class="hyperlink">namespace isolation</em>.</p>










<section data-pdf-bookmark="Namespace isolation" data-type="sect3" class="preface"><div class="preface" id="id70">
<h3 class="calibre33">Namespace isolation</h3>

<p class="author1">With namespace isolation, we can<a data-primary="policy" data-secondary="dynamic policy configuration" data-tertiary="namespace isolation" data-type="indexterm" id="ch08-nam" class="calibre4"/><a data-primary="namespaces" data-secondary="dynamic policy" data-tertiary="namespace isolation" data-type="indexterm" id="ch08-nam2" class="calibre4"/>
easily restrict traffic in a namespace exclusively to those workloads that share that
namespace. In our example, we’ll start by permitting traffic within the
<code class="calibre9">emojivoto</code> namespace as long as the source and destination identities are
<em class="hyperlink">both</em> within this single namespace. This makes sense for the 
<span class="calibre">emojivoto</span>
application because the only things running in its namespace are parts of emojivoto itself: it’s a natural result of the idea that the application is
contained within a single namespace.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Identities, Not IP Addresses</h1>
<p class="author1">Note that we said “source and destination <em class="hyperlink">identities</em>.” <a data-primary="policy" data-secondary="workload certificates for Pod identity" data-tertiary="workload identity, not IP address" data-type="indexterm" id="id1290" class="calibre4"/><a data-primary="Pods" data-secondary="policy" data-tertiary="workload identity, not IP address" data-type="indexterm" id="id1291" class="calibre4"/><a data-primary="Pods" data-secondary="IP addresses" data-tertiary="policy via workload identity" data-type="indexterm" id="id1292" class="calibre4"/>Everything Linkerd
does with policy is based on the workload identity, not the workload’s IP
address or anything else about the network. The workloads don’t even need to
be in the same cluster, as long as the identities line up.</p>
</div>

<p class="author1">We’ll set up namespace isolation for <code class="calibre9">emojivoto</code> in
<a data-type="xref" href="#EX10-namespace-isolation" class="calibre4">Example 8-6</a>. Fair warning: this will look complex. The inline
comments are very important to fully understand exactly what’s going on in
this example.</p>
<div class="calibre40" data-type="example" id="EX10-namespace-isolation">
<h5 class="calibre41"><span class="calibre">Example 8-6. </span>Namespace isolation for <code class="calibre9">emojivoto</code></h5>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># To start applying policies to the emojivoto workloads, we need to create</code>
<code class="c"># Server objects. A Server object selects a single named port on one or more</code>
<code class="c"># Pods.</code>
<code class="c">#</code>
<code class="c"># We'll start by setting up a Server that matches the Linkerd admin port,</code>
<code class="c"># used for metrics, for every Pod in our namespace.</code>
$ kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1beta1</code>
<code class="s">kind: Server</code>
<code class="s">metadata:</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">  name: linkerd-admin</code>
<code class="s">spec:</code>
<code class="s">  podSelector:</code>
<code class="s">    matchLabels: {}</code>
<code class="s">  port: linkerd-admin</code>
<code class="s">  proxyProtocol: HTTP/2</code>
<code class="s">EOF</code><code class="w"/>

<code class="c"># This object, a Server called linkerd, will, due to our matchLabels selector,</code>
<code class="c"># match every Pod in our namespace. On each Pod it will bind to a port named</code>
<code class="c"># linkerd-admin and allow us to apply policy to it.</code>
<code class="c">#</code>
<code class="c"># Next, we will create a Server object for each part of our application,</code>
<code class="c"># starting with the web service (which serves the GUI).</code>
$ kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1beta1</code>
<code class="s">kind: Server</code>
<code class="s">metadata:</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">  name: web-http</code>
<code class="s">  labels:</code>
<code class="s">    app.kubernetes.io/part-of: emojivoto</code>
<code class="s">    app.kubernetes.io/name: web</code>
<code class="s">    app.kubernetes.io/version: v11</code>
<code class="s">spec:</code>
<code class="s">  podSelector:</code>
<code class="s">    matchLabels:</code>
<code class="s">      app: web-svc</code>
<code class="s">  port: http</code>
<code class="s">  proxyProtocol: HTTP/1</code>
<code class="s">EOF</code><code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># The Server web-http matches the HTTP port for Pods that are part of the</code>
<code class="c"># web service by selecting any Pods with the app=web-svc label. It also has</code>
<code class="c"># the added benefit of allowing us to skip protocol detection on this port</code>
<code class="c"># by specifying the protocol as HTTP/1.</code>
<code class="c">#</code>
<code class="c"># Now we'll create the Servers for emojivoto's backing services,</code>
<code class="c"># voting and emoji.</code>
$ kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">---</code>
<code class="s">apiVersion: policy.linkerd.io/v1beta1</code>
<code class="s">kind: Server</code>
<code class="s">metadata:</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">  name: emoji-grpc</code>
<code class="s">  labels:</code>
<code class="s">    app.kubernetes.io/part-of: emojivoto</code>
<code class="s">    app.kubernetes.io/name: emoji</code>
<code class="s">    app.kubernetes.io/version: v11</code>
<code class="s">    app: emoji-svc</code>
<code class="s">    emojivoto/api: internal-grpc</code>
<code class="s">spec:</code>
<code class="s">  podSelector:</code>
<code class="s">    matchLabels:</code>
<code class="s">      app: emoji-svc</code>
<code class="s">  port: grpc</code>
<code class="s">  proxyProtocol: gRPC</code>
<code class="s">---</code>
<code class="s">apiVersion: policy.linkerd.io/v1beta1</code>
<code class="s">kind: Server</code>
<code class="s">metadata:</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">  name: voting-grpc</code>
<code class="s">  labels:</code>
<code class="s">    app: voting-svc</code>
<code class="s">    emojivoto/api: internal-grpc</code>
<code class="s">spec:</code>
<code class="s">  podSelector:</code>
<code class="s">    matchLabels:</code>
<code class="s">      app: voting-svc</code>
<code class="s">  port: grpc</code>
<code class="s">  proxyProtocol: gRPC</code>
<code class="s">EOF</code><code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># These are basically the same idea as the web Server, just with different</code>
<code class="c"># label selectors. Also, since emojivoto uses gRPC for these workloads, we</code>
<code class="c"># set the protocol to gRPC.</code>
<code class="c">#</code>
<code class="c"># With that, all of our Servers have been created, and we are ready to begin</code>
<code class="c"># to allow communication within our namespace. We'll next define a single</code>
<code class="c"># MeshTLSAuthentication resource that matches all service accounts within</code>
<code class="c"># the emojivoto namespace.</code>
$ kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: MeshTLSAuthentication</code>
<code class="s">metadata:</code>
<code class="s">  name: emojivoto-accounts</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  identities:</code>
<code class="s">    - "*.emojivoto.serviceaccount.identity.linkerd.cluster.local"</code>
<code class="s">EOF</code><code class="w"/>

<code class="c"># Then, we will bind that MeshTLSAuthentication to our Servers. We could do it</code>
<code class="c"># individually on a port-by-port basis, but in this case it's simpler to bind</code>
<code class="c"># to every policy object in the namespace.</code>
$ kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: AuthorizationPolicy</code>
<code class="s">metadata:</code>
<code class="s">  name: emojivoto-only</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">  labels:</code>
<code class="s">    app.kubernetes.io/part-of: emojivoto</code>
<code class="s">    project: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  targetRef:</code>
<code class="s">    kind: Namespace</code>
<code class="s">    name: emojivoto</code>
<code class="s">  requiredAuthenticationRefs:</code>
<code class="s">    - name: emojivoto-accounts</code>
<code class="s">      kind: MeshTLSAuthentication</code>
<code class="s">      group: policy.linkerd.io</code>
<code class="s">EOF</code><code class="w"/>

<code class="c"># With that, we should see that the emojivoto workloads are able to communicate</code>
<code class="c"># with each other once again. You can check this by using a port forward to</code>
<code class="c"># look at the emojivoto app's GUI: start this forwarder, then open</code>
<code class="c"># http://localhost:8080/ in your browser.</code>
$ kubectl<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>port-forward<code class="w"> </code>svc/web-svc<code class="w"> </code><code class="m">8080</code>:80<code class="w"/></pre></div>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">What’s in a Name?</h1>
<p class="author1">Linkerd Server objects are the <a data-primary="Server resources" data-secondary="policy applied via" data-type="indexterm" id="id1293" class="calibre4"/><a data-primary="ports" data-secondary="policy application via name" data-type="indexterm" id="id1294" class="calibre4"/>core construct that allows us to apply policy to our applications. They work by matching Pods based on some selection criteria and then selecting a port <em class="hyperlink">by the port’s name</em>. Kubernetes will allow you to create Pods without adding a name to a port, so you must be sure that when using Linkerd policy in your cluster, every port in your applications has a value set for its name.</p>
</div>

<p class="author1">We know that was a lot of YAML! Policy definition is the most labor-intensive task you’ll
need to undertake to use Linkerd. Luckily for all of us, policy is an
opt-in feature that you can prepare for in advance of turning it on. <a data-primary="production" data-secondary="policy objects tested in nonproduction environment" data-type="indexterm" id="id1295" class="calibre4"/><a data-primary="policy" data-secondary="dynamic policy configuration" data-tertiary="testing in nonproduction environment" data-type="indexterm" id="id1296" class="calibre4"/>We
<em class="hyperlink">strongly</em> recommend you thoroughly test all your policy objects in a
nonproduction environment before applying them to a live environment.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Test Early, Test Often</h1>
<p class="author1">This bears repeating. <em class="hyperlink">Policy is complex</em> and easy to get wrong. We
<em class="hyperlink">strongly</em> encourage that you test your policy definitions in a
nonproduction environment before taking them to production.<a data-startref="ch08-nam" data-type="indexterm" id="id1297" class="calibre4"/><a data-startref="ch08-nam2" data-type="indexterm" id="id1298" class="calibre4"/></p>
</div>
</div></section>










<section data-pdf-bookmark="Allowing Linkerd Viz" data-type="sect3" class="preface"><div class="preface" id="id71">
<h3 class="calibre33">Allowing Linkerd Viz</h3>

<p class="author1">At this point, we’ve isolated <a data-primary="policy" data-secondary="dynamic policy configuration" data-tertiary="monitoring from outside the namespace" data-type="indexterm" id="ch08-lv" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="dynamic policy configuration" data-type="indexterm" id="ch08-lv2" class="calibre4"/><a data-primary="namespaces" data-secondary="dynamic policy" data-tertiary="references outside the namespace" data-type="indexterm" id="ch08-lv3" class="calibre4"/>the <code class="calibre9">emojivoto</code> namespace within the cluster:
nothing from outside the namespace gets to speak with anything inside the
namespace. Unfortunately, this will break things like monitoring applications
and ingress controllers. This is decidedly less than ideal: while we’ve done a
lot to secure our <code class="calibre9">emojivoto</code> namespace, we’ve caused other problems. For
example, we’ve left any potential operations folks with little to no ability
to monitor what our emojivoto workloads are doing.</p>

<p class="author1">To fix this, we can use dynamic policy resources that reference identities
from <em class="hyperlink">outside</em> the namespace. In <a data-type="xref" href="#EX10-viz" class="calibre4">Example 8-7</a> we’ll walk you through
installing Linkerd Viz and allowing it to poll your applications, as shown in
<a data-type="xref" href="#emojivoto-allowing-viz" class="calibre4">Figure 8-5</a>.</p>

<figure class="calibre23"><div class="figure" id="emojivoto-allowing-viz">
<img alt="luar 0805" src="assets/luar_0805.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 8-5. </span>emojivoto policy allowing Linkerd Viz</h6>
</div></figure>
<div data-type="example" id="EX10-viz" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-7. </span>Let there be Viz!</h5>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Let's install the Linkerd Viz extension. We'll continue our theme of</code>
<code class="c"># installing things with Helm.</code>
$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>linkerd-viz<code class="w"> </code>linkerd/linkerd-viz<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-n<code class="w"> </code>linkerd-viz<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--create-namespace<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--version<code class="w"> </code><code class="m">30</code>.8.4<code class="w"/>

<code class="c"># This command will install the linkerd 2.13.4 version of Linkerd's Viz</code>
<code class="c"># extension.</code>
<code class="c">#</code>
<code class="c"># Once that's done, wait for Viz to be ready.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>check<code class="w"/>

<code class="c"># We now want to restart our emojivoto workloads so that they start</code>
<code class="c"># collecting Tap data. This is critical for observability.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>rollout<code class="w"> </code>restart<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>

<code class="c"># With that complete, we can now move on to validating that the Linkerd</code>
<code class="c"># Viz extension is unable to talk to our workloads.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>

<code class="c"># You should see all your deployments with no statistics associated with</code>
<code class="c"># them. That's because Linkerd's Prometheus instance is located in the</code>
<code class="c"># linkerd-viz namespace, and it hasn't been given permission to talk to</code>
<code class="c"># anything in the emojivoto namespace.</code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Let's fix that now. First, we define a MeshTLSAuthentication resource</code>
<code class="c"># that matches the identities used by Tap and Prometheus, which are the</code>
<code class="c"># parts of Linkerd Viz that collect data.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: MeshTLSAuthentication</code>
<code class="s">metadata:</code>
<code class="s">  name: linkerd-viz</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  identities:</code>
<code class="s">    - "tap.linkerd-viz.serviceaccount.identity.linkerd.cluster.local"</code>
<code class="s">    - "prometheus.linkerd-viz.serviceaccount.identity.linkerd.cluster.local"</code>
<code class="s">EOF</code><code class="w"/>

<code class="c"># Next, we permit that MeshTLSAuthentication to talk to Pods in the</code>
<code class="c"># emojivoto namespace, using an AuthorizationPolicy as before.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: AuthorizationPolicy</code>
<code class="s">metadata:</code>
<code class="s">  name: allow-viz</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  targetRef:</code>
<code class="s">    kind: Namespace</code>
<code class="s">    name: emojivoto</code>
<code class="s">  requiredAuthenticationRefs:</code>
<code class="s">    - name: linkerd-viz</code>
<code class="s">      kind: MeshTLSAuthentication</code>
<code class="s">      group: policy.linkerd.io</code>
<code class="s">EOF</code><code class="w"/>

<code class="c"># At this point, Tap and Prometheus should be happily collecting data.</code>
<code class="c"># Give them a minute or so to get something substantive, then you should</code>
<code class="c"># be able to see good results from a second "linkerd viz stat" command.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/></pre></div>

<p class="author1">With that complete, we’ve now walked through what you need to do to isolate traffic within a namespace but still allow in an external monitoring tool like the Linkerd Viz extension. You now have the basic knowledge required to begin isolating your own workloads by namespace with Linkerd’s policy tools. Next, we’ll get a little more granular and only allow specific service accounts to access our workloads.<a data-startref="ch08-lv" data-type="indexterm" id="id1299" class="calibre4"/><a data-startref="ch08-lv2" data-type="indexterm" id="id1300" class="calibre4"/><a data-startref="ch08-lv3" data-type="indexterm" id="id1301" class="calibre4"/></p>
</div></section>










<section data-pdf-bookmark="Locking down by port and identity" data-type="sect3" class="preface"><div class="preface" id="id72">
<h3 class="calibre33">Locking down by port and identity</h3>

<p class="author1">Namespace isolation goes<a data-primary="policy" data-secondary="dynamic policy configuration" data-tertiary="specifying port and identity" data-type="indexterm" id="ch08-pi" class="calibre4"/><a data-primary="ports" data-secondary="policy application via name" data-type="indexterm" id="ch08-pi2" class="calibre4"/> a long way to further hardening our environment, but
we can go further than that. With the isolation we’ve applied so far, any
request is allowed as long as the calling workload and the called workload are
both in the <code class="calibre9">emojivoto</code> namespace, but this is probably more permissive than
we really need. To go a little further, we can be explicit about which accounts
are allowed to talk to which workloads—but of course, that requires knowing
exactly which communications are truly required by the application.</p>

<p class="author1">Figuring out those requirements by<a data-primary="Linkerd Viz extension" data-secondary="dynamic policy via" data-type="indexterm" id="id1302" class="calibre4"/> inspecting code is tedious and error-prone,
but fortunately we can do better than that by using tools like Linkerd Viz (or
its commercial cousins from Buoyant) to help us map our application’s
communication and build our policy objects.</p>

<p class="author1">We need only a single Linkerd Viz CLI command to see which workloads are communicating with one another in the <code class="calibre9">emojivoto</code> namespace:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>edges<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/></pre>

<p class="author1">This will produce a list of Deployments that are communicating with one another in this namespace. Deployments listed under the <code class="calibre9">SRC</code> column are the sources (clients) for requests; those listed under <code class="calibre9">DST</code> are the destinations (servers).</p>

<p class="author1">If you’d prefer to investigate using the Viz dashboard rather than its CLI, you can run:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>dashboard<code class="w"/></pre>

<p class="author1">The Viz dashboard is out of scope for this book, but it’s fairly intuitive, and we encourage you to poke around in it if you haven’t had the chance to use it before.</p>

<p class="author1">From the output we can see the connections between our emojivoto workloads, as shown in <a data-type="xref" href="#emojivoto-app-connections" class="calibre4">Figure 8-6</a>.</p>

<figure class="calibre23"><div class="figure" id="emojivoto-app-connections">
<img alt="luar 0806" src="assets/luar_0806.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 8-6. </span>emojivoto inter-workload communications</h6>
</div></figure>

<p class="author1">emojivoto is a very simple application, so there are only three connections:</p>

<ul class="printings">
<li class="calibre6">
<p class="author1"><code class="calibre9">vote-bot</code> talks to the <code class="calibre9">web</code> Deployment.</p>
</li>
<li class="calibre6">
<p class="author1"><code class="calibre9">web</code> communicates with <code class="calibre9">voting</code>.</p>
</li>
<li class="calibre6">
<p class="author1"><code class="calibre9">web</code> communicates with <code class="calibre9">emoji</code>.</p>
</li>
</ul>

<p class="author1">With that, we can begin building policy. We’ll start by gathering the Subject
names on our individual workloads, as shown in <a data-type="xref" href="#EX10-gather-names" class="calibre4">Example 8-8</a>. We’ll need to
gather the names for <code class="calibre9">vote-bot</code> and <code class="calibre9">web</code>. We don’t need to allow <code class="calibre9">voting</code> or <code class="calibre9">emoji</code>
to communicate with any other services, as neither of them act as clients for
any other services.</p>
<div data-type="example" id="EX10-gather-names" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-8. </span>Gathering Subject names</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Start by grabbing the name of the first vote-bot Pod (which should</code>
<code class="c"># be the only vote-bot Pod).</code>
<code class="c">#</code>
<code class="c"># This kubectl command uses -l app=vote-bot to pick all Pods with the</code>
<code class="c"># "app: vote-bot" label, then uses JSONPath to pick the metadata.name</code>
<code class="c"># of the first Pod in the list.</code>
$<code class="w"> </code><code class="nv">VOTEBOTPOD</code><code class="o">=</code><code class="k">$(</code>kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>-l<code class="w"> </code><code class="nv">app</code><code class="o">=</code>vote-bot<code class="w"> </code><code class="se">\</code>
<code class="w">             </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{ .items[0].metadata.name }'</code><code class="k">)</code><code class="w"/>

<code class="c"># Now use the Pod name for vote-bot to get the Subject name.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>identity<code class="w"> </code><code class="nv">$VOTEBOTPOD</code><code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code><code class="p">|</code><code class="w"> </code>grep<code class="w"> </code>Subject:<code class="w"/>

<code class="c"># This will print out the Subject name for the vote-bot Pod, which is</code>
<code class="c"># the name of that Pod's identity. It will look like:</code>
<code class="c">#</code>
<code class="c">#   Subject: CN=default.emojivoto.serviceaccount.identity.linkerd.cluster.local</code>
<code class="c">#</code>
<code class="c"># We only want the part after CN=, so</code>
<code class="c"># default.emojivoto.serviceaccount.identity.linkerd.cluster.local.</code>

<code class="c"># Repeat for the web Pod, which we can find using the "app: web-svc" label.</code>
$<code class="w"> </code><code class="nv">WEBPOD</code><code class="o">=</code><code class="k">$(</code>kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>-l<code class="w"> </code><code class="nv">app</code><code class="o">=</code>web-svc<code class="w"> </code><code class="se">\</code>
<code class="w">         </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{ .items[0].metadata.name }'</code><code class="k">)</code><code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>identity<code class="w"> </code><code class="nv">$WEBPOD</code><code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code><code class="p">|</code><code class="w"> </code>grep<code class="w"> </code>Subject:<code class="w"/>

<code class="c"># It should output a name like:</code>
<code class="c">#    Subject: CN=web.emojivoto.serviceaccount.identity.linkerd.cluster.local</code>
<code class="c">#</code>
<code class="c"># and again, we'll want the part after CN=:</code>
<code class="c"># web.emojivoto.serviceaccount.identity.linkerd.cluster.local</code></pre></div>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">What’s in a Name?</h1>
<p class="author1">Why does the <code class="calibre9">vote-bot</code> workload get<a data-primary="policy" data-secondary="dynamic policy configuration" data-tertiary="ServiceAccount creation" data-type="indexterm" id="id1303" class="calibre4"/><a data-primary="ServiceAccounts for dynamic policy" data-type="indexterm" id="id1304" class="calibre4"/> an identity named “default” while the
<code class="calibre9">web</code> workload gets one named “web”? If you look carefully at the <code class="calibre9">vote-bot</code>
and <code class="calibre9">web</code> Deployments, you’ll find that <code class="calibre9">web</code> specifies which ServiceAccount
to use, but <code class="calibre9">vote-bot</code> does not…so <code class="calibre9">vote-bot</code> gets the default. <em class="hyperlink">This is
not a best practice</em>. In a perfect world, every workload would get its own
ServiceAccount.</p>

<p class="author1">We’re showing this because while it’s not ideal, it’s <em class="hyperlink">very</em> common to see
this default ServiceAccount in use when trying to set up policy for
applications that weren’t designed with zero trust in mind—and you may need
to create new ServiceAccounts in addition to creating policy resources!</p>
</div>

<p class="author1">With those two Subject names, we can update our policy to be much more explicit
about who is allowed to talk to whom in the <code class="calibre9">emojivoto</code> namespace. It’s worth
remembering that in the previous section we created a number of policy objects
that allow the emojivoto workloads to talk to each other. In
<a data-type="xref" href="#EX10-less-permissive" class="calibre4">Example 8-9</a>, we’ll be reusing some and removing others in order
to move from a more permissive to less permissive security posture, as shown
in <a data-type="xref" href="#emojivoto-less-permissive" class="calibre4">Figure 8-7</a>.</p>

<figure class="calibre23"><div class="figure" id="emojivoto-less-permissive">
<img alt="luar 0807" src="assets/luar_0807.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 8-7. </span>emojivoto less permissive model</h6>
</div></figure>
<div class="calibre16" data-type="note" epub:type="note"><h1 class="calibre26">Server-Side Policy</h1>
<p class="author1">In Linkerd, the workload-based policy engine<a data-primary="policy" data-secondary="Server-based and explicitly allowing clients" data-type="indexterm" id="id1305" class="calibre4"/> enforces all policy decisions on the server side. When we configure <code class="calibre9">deny</code> as the default in our environment, we have to go through each server individually to ensure all its clients have been explicitly allowed.</p>
</div>
<div data-type="example" id="EX10-less-permissive" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 8-9. </span>Restricting interapp communication</h5>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># We'll start by creating two new MeshTLSAuthentication objects. The</code>
<code class="c"># first allows only the default identity (currently used by the vote-bot);</code>
<code class="c"># the second allows only the web identity.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: MeshTLSAuthentication</code>
<code class="s">metadata:</code>
<code class="s">  name: default</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  identities:</code>
<code class="s">  - 'default.emojivoto.serviceaccount.identity.linkerd.cluster.local'</code>
<code class="s">---</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: MeshTLSAuthentication</code>
<code class="s">metadata:</code>
<code class="s">  name: web</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  identities:</code>
<code class="s">  - 'web.emojivoto.serviceaccount.identity.linkerd.cluster.local'</code>
<code class="s">EOF</code><code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Each object corresponds to either the vote-bot or web application. We</code>
<code class="c"># inserted the names we gathered in Example 8-8 to populate these</code>
<code class="c"># objects. It's a good practice to name them after the identity they</code>
<code class="c"># represent, rather than the workload -- in particular, the "default"</code>
<code class="c"># identity is probably used by more than just the vote-bot, so we don't</code>
<code class="c"># want to name that MeshTLSAuthentication "vote-bot" as that might give</code>
<code class="c"># the impression that we need only think about the vote-bot when using</code>
<code class="c"># that!</code>

<code class="c"># With that done, we can begin binding those authentications to our servers.</code>
<code class="c"># We'll start with allowing vote-bot (using the default identity) to talk</code>
<code class="c"># to web.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: AuthorizationPolicy</code>
<code class="s">metadata:</code>
<code class="s">  labels:</code>
<code class="s">    app.kubernetes.io/part-of: emojivoto</code>
<code class="s">    project: emojivoto</code>
<code class="s">  name: allow-default-to-web</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  requiredAuthenticationRefs:</code>
<code class="s">  - group: policy.linkerd.io</code>
<code class="s">    kind: MeshTLSAuthentication</code>
<code class="s">    name: default</code>
<code class="s">  targetRef:</code>
<code class="s">    group: policy.linkerd.io</code>
<code class="s">    kind: Server</code>
<code class="s">    name: web-http</code>
<code class="s">EOF</code><code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># This AuthorizationPolicy will allow any workload using the default</code>
<code class="c"># identity to talk to the web workload, using the "web-http" Server we</code>
<code class="c"># already created.</code>

<code class="c"># Now we will give the web application access to emoji and voting. In</code>
<code class="c"># order to accomplish this we will need to create two AuthorizationPolicy</code>
<code class="c"># objects, one for each Server.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: AuthorizationPolicy</code>
<code class="s">metadata:</code>
<code class="s">  labels:</code>
<code class="s">    app.kubernetes.io/part-of: emojivoto</code>
<code class="s">    project: emojivoto</code>
<code class="s">  name: allow-web-to-voting</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  requiredAuthenticationRefs:</code>
<code class="s">  - group: policy.linkerd.io</code>
<code class="s">    kind: MeshTLSAuthentication</code>
<code class="s">    name: web</code>
<code class="s">  targetRef:</code>
<code class="s">    group: policy.linkerd.io</code>
<code class="s">    kind: Server</code>
<code class="s">    name: voting-grpc</code>
<code class="s">---</code>
<code class="s">apiVersion: policy.linkerd.io/v1alpha1</code>
<code class="s">kind: AuthorizationPolicy</code>
<code class="s">metadata:</code>
<code class="s">  labels:</code>
<code class="s">    app.kubernetes.io/part-of: emojivoto</code>
<code class="s">    project: emojivoto</code>
<code class="s">  name: allow-web-to-emoji</code>
<code class="s">  namespace: emojivoto</code>
<code class="s">spec:</code>
<code class="s">  requiredAuthenticationRefs:</code>
<code class="s">  - group: policy.linkerd.io</code>
<code class="s">    kind: MeshTLSAuthentication</code>
<code class="s">    name: web</code>
<code class="s">  targetRef:</code>
<code class="s">    group: policy.linkerd.io</code>
<code class="s">    kind: Server</code>
<code class="s">    name: emoji-grpc</code>
<code class="s">EOF</code><code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Here, the allow-web-to-voting AuthorizationPolicy allows any workload</code>
<code class="c"># using the web identity to talk to the voting workload; allow-web-to-emoji</code>
<code class="c"># does the same for the emoji workload. Again, we're using Servers we created</code>
<code class="c"># earlier.</code>

<code class="c"># Now that we have our new policies in place, we can delete the policies that</code>
<code class="c"># allow all the apps in the emojivoto namespace to talk to one another.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>delete<code class="w"> </code>authorizationpolicies.policy.linkerd.io<code class="w"> </code>emojivoto-only<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>

<code class="c"># Finally, we'll use a port forward to test the emojivoto app and be sure it</code>
<code class="c"># still operates normally.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>port-forward<code class="w"> </code>svc/web-svc<code class="w"> </code><code class="m">8080</code>:80<code class="w"/></pre></div>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Order of Operations</h1>
<p class="author1">As we moved from namespace-wide<a data-primary="policy" data-secondary="dynamic policy configuration" data-tertiary="order of operations" data-type="indexterm" id="id1306" class="calibre4"/><a data-primary="namespaces" data-secondary="dynamic policy" data-tertiary="order of operations" data-type="indexterm" id="id1307" class="calibre4"/> permissions to more specific permissions, we created our new policy objects before removing the namespace-wide permissions. If we had inverted the order, we would have disrupted communication between the emojivoto workloads.</p>
</div>

<p class="author1">You have now further restricted access to the apps in the <code class="calibre9">emojivoto</code> namespace. Now communication between your workloads will occur only if it has been explicitly authorized by your platform team. Every denial is logged by the Linkerd proxy, and your security team can use these logs to identify malicious behavior in your clusters. Hopefully you can see how this sort of hardening dramatically reduces the risk of an intrusion in your environment and, with proper monitoring and logging, dramatically increases the likelihood that suspicious behavior will be caught.<a data-startref="ch08-dyn" data-type="indexterm" id="id1308" class="calibre4"/><a data-startref="ch08-dyn2" data-type="indexterm" id="id1309" class="calibre4"/><a data-startref="ch08-pi" data-type="indexterm" id="id1310" class="calibre4"/><a data-startref="ch08-pi2" data-type="indexterm" id="id1311" class="calibre4"/></p>
</div></section>
</div></section>
</div></section>






<section data-pdf-bookmark="Summary" data-type="sect1" class="preface"><div class="preface" id="id321">
<h1 class="calibre8">Summary</h1>

<p class="author1">Linkerd’s Server-based policy is its oldest policy mechanism, but it’s still
incredibly effective in a great many situations. Server-based policy gives you
the ability to set known, trustworthy defaults while also making it
straightforward to tune everything for your application, and Linkerd’s Tap
ability lets you quickly get a sense of what you need to sort out.</p>
</div></section>
</div></section></body></html>