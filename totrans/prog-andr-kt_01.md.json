["```\nval name: String // error! Nonnullable types must be initialized!\n```", "```\nvar name = \"Jerry\"\nname = null\n```", "```\nval name = Jerry\nfun showNameLength(name: String?) { // Function accepts a nullable parameter\n     // ...\n}\n\nshowNameLength(name)\n```", "```\nval name: String? = null\nfun showNameLength(name: String) { // This function only accepts non-nulls\n    println(name.length)\n}\n\nshowNameLength(name)               // error! Won't compile because \"name\"\n                                   // can be null\n```", "```\nval name: String? = null\nfun showNameLength(name: String?) { // This function now accepts nulls\n    println(name.length)            // error!\n}\n\nshowNameLength(name)                // Compiles\n```", "```\nval name: String? = null\nfun showNameLength(name: String?) {\n    println(if (name == null) 0 else name.length)\n    // we will use an even nicer syntax shortly\n}\n```", "```\nval name: String? = null\nfun showNameLength(name: String?) {\n    println(name?.length ?: 0)\n}\n```", "```\nif (name == null) null else name.length\n```", "```\nif (name?.length == null) 0 else name.length\n```", "```\nif (maybe) doThis() else doThat();\n```", "```\nint n = if (maybe) doThis() else doThat();\n```", "```\nint n = (maybe) ? doThis() : doThat();\n```", "```\nval n = if (maybe) doThis() else doThat()\n```", "```\nval func: (Double) -> Double = { x -> x.pow(2.0) }\n```", "```\nval func = { x: Double -> x.pow(2.0)}\n```", "```\nFunction<Double, Double> func\n    = x -> Math.pow(x, 2.0);\n\nfunc.apply(256.0);\n```", "```\nfun getCurve(\n    surface: (Double, Double) -> Int,\n    x: Double\n): (Double) -> Int {\n    return { y -> surface(x, y) }\n}\n```", "```\nfun <T> simplePair(x: T, y: T) = Pair(x, y)\n```", "```\nval ronDeeLay = \"the night time\"\n```", "```\nval surprising: Double\n    get() = Math.random()\n```", "```\n{ x: Int, y: Int -> x * y }\n```", "```\n{ x: Int, y: Int -> x * y; \"down on the corner\" }\n```", "```\n// The last argument, \"callback\", is a function\nfun apiCall(param: Int, callback: () -> Unit)\n```", "```\napiCall(1, { println(\"I'm called back!\")})\n```", "```\napiCall(1) {\n   println(\"I'm called back!\")\n}\n```", "```\nclass FileUtils {\n    public static String getWordAtIndex(File file, int index) {\n        /* Implementation hidden for brevity */\n    }\n}\n```", "```\n// declared inside FileUtils.kt\nfun File.getWordAtIndex(index: Int): String {\n    val context = this.readText()  // 'this' corresponds to the file\n    return context.split(' ').getOrElse(index) { \"\" }\n}\n```", "```\npublic class FileUtilsKt {\n    public static String getWordAtIndex(\n            File file, int index\n    ) {\n        /* Implementation hidden for brevity */\n    }\n}\n```", "```\n// The Rectangle class has width and height properties\nval Rectangle.area: Double\n    get() = width * height\n```", "```\nclass Point(val x: Int, var y: Int? = 3)\n\nfun demo() {\n    val pt1 = Point(4)\n    assertEquals(3, pt1.y)\n    pt1.y = 7\n    val pt2 = Point(7, 7)\n    assertEquals(pt2.y, pt1.y)\n}\n```", "```\nclass Point(x: Int, y: Int?)\n\nfun demo() {\n    val pt = Point(4)\n    pt.y = 7 // error!  Variable expected\n}\n```", "```\nclass Segment(val start: Point, val end: Point) {\n    val length: Double = sqrt(\n            (end.x - start.x).toDouble().pow(2.0)\n                    + (end.y - start.y).toDouble().pow(2.0))\n\n    init {\n        println(\"Point starting at $start with length $length\")\n    }\n\n    constructor(x1: Int, y1: Int, x2: Int, y2: Int) :\n            this(Point(x1, y1), Point(x2, y2)) {\n        println(\"Secondary constructor\")\n    }\n}\n```", "```\n>>> val s = Segment(1, 2, 3, 4)\n\nPoint starting at Point(x=1, y=2) with length 2.8284271247461903\nSecondary constructor\n```", "```\nclass Rectangle(val l: Int, val w: Int) {\n    val area: Int\n        get() = l * w\n}\n```", "```\nval rect = Rectangle(3, 4)\nassertEquals(12, rect.area)\n```", "```\n// This code doesn't work (we'll see why)\nclass ExpensiveToHash(_summary: String) {\n\n    var summary: String = _summary\n        set(value) {\n            summary = value    // unbounded recursion!!\n            hashCode = computeHash()\n        }\n\n    //  other declarations here...\n    var hashCode: Long = computeHash()\n\n    private fun computeHash(): Long = ...\n}\n```", "```\nclass ExpensiveToHash(_summary: String) {\n\n    var summary: String = _summary\n        set(value) {\n            field = value\n            hashCode = computeHash()\n        }\n\n    //  other declarations here...\n    var hashCode: Long = computeHash()\n\n    private fun computeHash(): Long = ...\n}\n```", "```\nclass MyFragment: Fragment() {\n    private var button: Button? = null // will provide actual value later\n}\n```", "```\nclass MyFragment: Fragment() {\n    private lateinit var button: Button // will initialize later\n}\n```", "```\nclass Lightweight {\n    private Heavyweight heavy;\n\n    public Heavyweight getHeavy() {\n        if (heavy == null) {\n            heavy = new Heavyweight();\n        }\n        return heavy;\n    }\n}\n```", "```\nclass Lightweight {\n    val heavy by lazy { // Initialization block\n        Heavyweight()\n    }\n}\n```", "```\nclass TimeExtensions {\n    //  other code\n\n    companion object {\n        const val TAG = \"TIME_EXTENSIONS\"\n    }\n}\n```", "```\ninterface Formatter {\n    val yearMonthDate: String\n}\n\nclass TimeExtensions {\n    //  other code\n\n    companion object StdTimeExtension : Formatter {\n        const val TAG = \"TIME_EXTENSIONS\"\n        override val yearMonthDate = \"yyyy-MM-d\"\n    }\n}\n```", "```\nval timeExtensionsTag = TimeExtensions.StdTimeExtension.TAG\n```", "```\ndata class Point(var x: Int, var y: Int? = 3)\n```", "```\nclass Point(var x: Int, var y: Int? = 3)\n\nfun main() {\n    val p1 = Point(1)\n    val p2 = Point(1)\n    println(\"Points are equals: ${p1 == p2}\")\n}\n```", "```\noverride fun equals(o: Any?): Boolean {\n    // If it's not a Point, return false\n    // Note that null is not a Point\n    if (o !is Point) return false\n\n    // If it's a Point, x and y should be the same\n    return x == o.x && y == o.y\n}\n```", "```\ndata class Point(var x: Int, var y: Int? = 3)\nval p = Point(1)          // x = 1, y = 3\nval copy = p.copy(y = 2)  // x = 1, y = 2\n```", "```\nenum class GymActivity {\n    BARRE, PILATES, YOGA, FLOOR, SPIN, WEIGHTS\n}\n\nenum class LENGTH(val value: Int) {\n    TEN(10), TWENTY(20), THIRTY(30), SIXTY(60);\n}\n```", "```\nfun requiresEquipment(activity: GymActivity) = when (activity) {\n    GymActivity.BARRE -> true\n    GymActivity.PILATES -> true\n    GymActivity.YOGA -> false\n    GymActivity.FLOOR -> false\n    GymActivity.SPIN -> true\n    GymActivity.WEIGHTS -> true\n}\n```", "```\nval <T> T.exhaustive: T\n    get() = this\n```", "```\nwhen (activity) {\n    GymActivity.BARRE -> true\n    GymActivity.PILATES -> true\n}.exhaustive // error!  when expression is not exhaustive.\n```", "```\ninterface Result\ndata class Success(val data: List<Int>) : Result\ndata class Failure(val error: Throwable?) : Result\n```", "```\nfun getResult(): Result = try {\n    Success(getDataOrExplode())\n} catch (e: Exception) {\n    Failure(e)\n}\n```", "```\nfun processResult(result: Result): List<Int> = when (result) {\n    is Success -> result.data\n    is Failure -> listOf()\n    else -> throw IllegalArgumentException(\"unknown result type\")\n}\n```", "```\nsealed class Result\ndata class Success(val data: List<Int>) : Result()\ndata class Failure(val error: Throwable?) : Result()\n```", "```\nfun processResult(result: Result): List<Int> = when (result) {\n    is Success -> result.data\n    is Failure -> listOf()\n}\n```"]