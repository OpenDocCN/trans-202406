<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Security and Observability Strategy"><div class="chapter" id="security_and_observability_strategy">
<h1><span class="label">Chapter 1. </span>Security and Observability Strategy</h1>
<p>In this chapter, we will cover a high-level overview of how you can build a security and observability strategy for your Kubernetes implementation. Subsequent chapters will cover each of these concepts in more detail. You need to think about a security strategy when you are in the pilot/pre-production phase of your Kubernetes journey, so if you are part of the security team, this chapter is very important. If you are part of the network, platform, or application team, this chapter shows how you can be a part of the security strategy and discuss the importance of collaboration between the security, platform, and application teams.</p>
<p>We will cover the following concepts that will guide you with your security and observability strategy:</p>
<ul>
<li><p>How securing Kubernetes is different from traditional security methods</p></li>
<li><p>The life cycle of deploying applications (workloads) in a Kubernetes cluster and best practices for each stage</p></li>
<li><p>How you should implement observability to help with security</p></li>
<li><p>Well-known security frameworks and how to use them in your security strategy</p></li>
</ul>
<section data-type="sect1" data-pdf-bookmark="Security for Kubernetes: A New and Different World"><div class="sect1" id="security_for_kubernetes_a_new_and_diffe">
<h1>Security for Kubernetes: A New and Different World</h1>
<p>In this section we’ll highlight how Kubernetes is different and why traditional security methods do not work in a Kubernetes implementation.<a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="overview of strategy" data-tertiary="different world of Kubernetes" id="idm45326833797632"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about security" data-tertiary="different world of Kubernetes" id="idm45326833795968"/></p>
<p>As workloads move to the cloud, Kubernetes is the most common<a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="about Kubernetes" id="idm45326833793888"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about workloads" id="idm45326833792432"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="declarative nature" id="idm45326833791056"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="abstracting pod-level details" id="idm45326833789680"/> orchestrator for managing them. The reason Kubernetes is popular is its declarative nature: It abstracts infrastructure details and allows users to specify the workloads they want to run and the desired outcomes. The application team does not need to worry about how workloads are deployed, where workloads are run, or other details like networking; they just need to set up configurations in Kubernetes to deploy their applications.</p>
<p>Kubernetes achieves this abstraction by managing workload creation, shutdown, and restart. In a typical implementation, a workload can be scheduled on any available resource in a network (physical host or virtual machine) based on the workload’s requirements. <a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="about Kubernetes" data-tertiary="clusters" id="idm45326833786800"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about workloads" data-tertiary="clusters" id="idm45326833785152"/><a contenteditable="false" data-type="indexterm" data-primary="clusters" data-secondary="about" id="idm45326833783504"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="about Kubernetes" data-tertiary="pods" id="idm45326833782128"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about workloads" data-tertiary="pods" id="idm45326833780480"/><a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="about" id="idm45326833778832"/>A group of resources that a workload runs on is known as a <em>Kubernetes cluster</em>. Kubernetes monitors the status of workloads (which are deployed as pods in Kubernetes) and takes corrective action as needed (e.g., restarting unresponsive nodes). It also manages all networking necessary for pods and hosts to communicate with each other. <a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="about Kubernetes" id="idm45326833776560"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about networking" id="idm45326833775184"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="about Kubernetes networking" data-seealso="networking" id="idm45326833773808"/>You have the option to decide on the networking technology by selecting from a set of supported network plug-ins. While there are some configuration options for the network plug-in, you will not be able to directly control networking behavior (either for IP address assignment or in typical configurations where the node is scheduled).</p>
<p>Kubernetes is a different world for security teams. Their traditional<a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="security teams" data-tertiary="different world of Kubernetes" id="idm45326833771424"/> method would be to build a “network of machines” and then onboard workloads (applications). As a part of onboarding, the process was to assign IPs, update networking as needed, and define and implement network access control rules. After these steps, the application was ready for users. This process ensured that security teams had a lot of control and could onboard and secure applications with ease. The applications were easy to secure, as applications were static in terms of assigned IPs, where they were deployed, etc.</p>
<p>In the Kubernetes world, workloads are built as container images<a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="about Kubernetes" data-tertiary="container images" id="idm45326833768640"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about workloads" data-tertiary="container images" id="idm45326834017968"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="about" id="idm45326834016320"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="about container images" id="idm45326834014944"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="about container images" id="idm45326834013296"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="about workloads" id="idm45326834011920"/> and are deployed in a Kubernetes cluster using a configuration file (yaml). This is typically integrated in the development process, and most development teams use continuous integration (CI) and continuous delivery (CD) to ensure speedy and reliable delivery of software. What this means is that the security team has limited visibility into the impact of each application change on the security of the cluster. Adding a security-review step to this process is counterproductive, as the only logical place to add that is when the code is being committed. The development process after that point is automated, and disrupting it would conflict with the CI/CD model. So how can you secure workloads in this environment?</p>
<p>In order to understand how to secure workloads in Kubernetes, it is important to understand the various stages that are part of deploying a workload.</p>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Deploying a Workload in Kubernetes: Security at Each Stage"><div class="sect1" id="deploying_a_workload_in_kubernetes_secu">
<h1 class="less_space">Deploying a Workload in Kubernetes: <span class="keep-together">Security at Each Stage</span></h1>
<p>In the previous section, we described the challenge of securing<a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="securing each stage" data-tertiary="about" id="ch01-sec"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="about securing each stage" id="ch01-sec2"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="overview of strategy" data-tertiary="about deployment stages" data-seealso="deploying a workload" id="ch01-sec3"/> applications that are deployed using the CI/CD pipeline. This section describes the life cycle of workload deployment in a Kubernetes cluster and explains how to secure each stage. The three stages of workload deployment are the build, deploy, and runtime stages. Unlike traditional client-server applications where an application existed on a server (or a cluster of servers), applications in a Kubernetes deployment are distributed, and the Kubernetes cluster network is used by applications as a part of normal operation. Here are a few things to consider because of this configuration:</p>
<ul>
<li><p>You need to consider security best practices as workloads and infrastructure are built. This is important due to the fact that applications in Kubernetes are deployed using the CI/CD pipeline.</p></li>
<li><p>You need to consider security best practices when a Kubernetes cluster is deployed and applications are onboarded.</p></li>
<li><p>Finally, applications use the infrastructure and the Kubernetes cluster network for normal operation, and you need to consider security best practices for application runtime.</p></li>
</ul>
<p><a data-type="xref" href="#workload_deployment_stages_and_security">Figure 1-1</a> illustrates the various stages and aspects to consider when securing workloads in a Kubernetes environment.</p>
<figure><div id="workload_deployment_stages_and_security" class="figure">
<img src="Images/ksao_0101.png" alt="" width="1432" height="628"/>
<h6><span class="label">Figure 1-1. </span>Workload deployment stages and security at each stage</h6>
</div></figure>

<p class="pagebreak-before">The boxes below each stage describe various aspects of security that you need to consider for that stage:</p>
<ul>
<li><p>The build stage is where you create (build) software for your workload<a contenteditable="false" data-type="indexterm" data-primary="build stage of deployment" id="idm45326833991552"/><a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="build stage security" id="idm45326833990352"/> (application) and build the infrastructure components (host or virtual machines) to host applications. This stage is part of the development cycle, and in most cases the development team is responsible for it. In this stage you consider security for the CI/CD pipeline, implement security for image repositories, scan images for vulnerabilities, and harden the host operating system. You need to ensure that you implement best practices to secure the image registry and avoid compromising the images in the image registry. This is generally implemented by securing access to the image registry, though a lot of users have private registries and do not allow images from public registries. Finally, you need to consider best practices for secrets management; secrets are like passwords that allow access to resources in your cluster. We will cover these topics in detail in <a data-type="xref" href="ch03.xhtml#workload_deployment_controls">Chapter 3</a>. We recommend that when you consider security for this stage, you should collaborate with the security team so that security at this stage is aligned with your overall security strategy.</p></li>
<li><p>The next stage, deploy, is where you set up the platform that<a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="about deployment stage" id="idm45326833986288"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="about deployment stage" id="idm45326833984832"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="deploying a workload" id="idm45326833983184"/> runs your Kubernetes deployment and deploy workloads. In this stage you need to think about the security best practices for configuring your Kubernetes cluster and providing external access to applications running inside your Kubernetes cluster. You also need to consider security controls like policies to limit access to workloads (pod security policies), network policies to control applications’ access to the platform components, and role-based access control (RBAC) for access to resources (for example, service creation, namespace creation, and adding/changing labels to pods). In most enterprises the platform team is responsible for this stage. As a member of the platform team, you need to collaborate with both the development and the security teams to implement your security strategy.</p></li>
<li><p>The final stage is the runtime stage, where you have deployed<a contenteditable="false" data-type="indexterm" data-primary="runtime security" data-secondary="about runtime stage of deployment" id="idm45326833980256"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="security teams" data-tertiary="runtime stage of deployment" id="idm45326833978784"/> your application and it is operational. In this stage you need to think about network security, which involves controls using network policy, threat defense (using techniques to detect and prevent malicious activity in the cluster), and enterprise security controls like compliance, auditing, and encryption. The security team is responsible for this stage of the deployment. As a member of the security team, you need to collaborate with the platform and development teams as you design and implement runtime security. Collaboration between teams (development, platform, and security) is very important for building an effective security strategy. We recommend that you ensure all these teams are aligned.</p></li>
</ul>
<p class="pagebreak-before">Note that unlike with traditional security strategies, where security is enforced at a vantage point (like the perimeter), in the case of a Kubernetes cluster, you need to implement security at each stage. In addition, all teams involved (application, platform, and security) play a very important role in implementing security, so the key to implementing a successful strategy is collaboration between teams. Remember, security is a shared responsibility. Let’s explore each stage and the techniques you can use to build your strategy.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-sec" id="idm45326830256304"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-sec2" id="idm45326830254928"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-sec3" id="idm45326830253552"/></p>
<section data-type="sect2" data-pdf-bookmark="Build-Time Security: Shift Left"><div class="sect2" id="build_time_security_shift_left">
<h2>Build-Time Security: Shift Left</h2>
<p>This section will guide you through various aspects of build-time security with <span class="keep-together">examples.</span><a contenteditable="false" data-type="indexterm" data-primary="build stage of deployment" data-secondary="security" id="idm45326830249712"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="securing each stage" data-tertiary="build stage" id="idm45326830248272"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="build stage security" id="idm45326830246624"/></p>
<section data-type="sect3" data-pdf-bookmark="Image scanning"><div class="sect3" id="image_scanning">
<h3>Image scanning</h3>
<p>During this stage, you need to ensure that applications do not have <a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="image scanning" data-tertiary="build-time security" id="idm45326830243024"/><a contenteditable="false" data-type="indexterm" data-primary="image scanning" data-secondary="build-time security" id="idm45326830241296"/><a contenteditable="false" data-type="indexterm" data-primary="common vulnerability enumerations (CVEs)" id="idm45326830239920"/><a contenteditable="false" data-type="indexterm" data-primary="National Vulnerability Database" id="idm45326830238848"/><a contenteditable="false" data-type="indexterm" data-primary="shift-left security" id="idm45326830237776"/>any major unpatched issues that are disclosed as common vulnerability enumerations (CVEs) in the National Vulnerability Database, and that the application code and dependencies are scanned for exploits and vulnerable code segments. The images that are built and delivered as containers are then scanned for unpatched critical or major vulnerabilities disclosed as CVEs. This is usually done by checking the base image and all its packages against a database that tracks vulnerable packages. In order to implement scanning, there are several tools, both open source and commercial, that are available to you. For example, Whitesource, Snyk, Trivy, Anchor, and even cloud providers like Google offer scanning of container images. We recommend that you select a scanning solution that understands how containers are built and scans not only the operating system on the host but also base images for containers. Given the dynamic nature of Kubernetes deployments, it is very important for you to secure the CI/CD pipeline; code and image scanning needs to be a part of the pipeline, and images being delivered from the image registry must be checked for compromise. You need to ensure access to the registry is controlled to avoid compromise. The popular term to describe this stage is <em>shifting security left toward the development team</em>, also known as <em>shift-left security</em>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Host operating system hardening"><div class="sect3" id="host_operating_system_hardening">
<h3>Host operating system hardening</h3>
<p>Here you must ensure that the application being deployed is restricted<a contenteditable="false" data-type="indexterm" data-primary="host hardening" data-secondary="build-time security" id="idm45326830232720"/><a contenteditable="false" data-type="indexterm" data-primary="operating system selection" data-secondary="host hardening" data-tertiary="build-time security" id="idm45326830231264"/> to having the required privileges on the host where it is deployed. To achieve this, you should use a hardened host operating system that supports controls to enable restricting applications to only necessary privileges like system calls and file system access. This allows you to effectively mitigate attacks related to <em>privilege escalation</em>, where a vulnerability in the software being deployed in a container is used to gain access to the host operating system.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Minimizing the attack surface: Base container images"><div class="sect3" id="minimizing_the_attack_surface_base_cont">
<h3>Minimizing the attack surface: Base container images</h3>
<p>We recommend you review the composition of the container image<a contenteditable="false" data-type="indexterm" data-primary="attack surface" data-secondary="minimizing" id="idm45326830226624"/><a contenteditable="false" data-type="indexterm" data-primary="container images" data-secondary="minimizing base image" id="idm45326830225168"/><a contenteditable="false" data-type="indexterm" data-primary="base container image" data-secondary="minimizing" id="idm45326830223792"/><a contenteditable="false" data-type="indexterm" data-primary="Dockerfile-based container images" data-secondary="minimizing base image" id="idm45326830222416"/> and minimize software packages that make up the base image to include only packages that are absolutely necessary for your application to run. In Dockerfile-based container images, you can start with a parent image and then add your application to the image to create a container image. For example, you could start by building a base image in Docker using the <code>FROM scratch</code> directive, which will create a minimal image. You can then add your application and required packages, which will give you complete control of the composition of your container images and also help with CVE management, as you do not need to worry about patching CVEs in packages in a container image that aren’t required by your application. In case building a scratch image is not a viable option, you can consider starting with a distroless image (a slimmed-down Linux distribution image) or an Alpine minimal image as the base images for your container.</p>
<p>These techniques will help you design and implement your build-time security strategy. <a contenteditable="false" data-type="indexterm" data-primary="development teams" id="idm45326830219104"/><a contenteditable="false" data-type="indexterm" data-primary="teams" data-secondary="build-time security strategy" id="idm45326830217904"/>As a part of the development team, you will be responsible for designing and implementing build-time security in collaboration with the platform and security teams to ensure it is aligned with the overall security strategy. We caution against believing the myth that shift-left security can be your whole security strategy. It is incorrect, and a naive approach to securing workloads. There are several other important aspects, such as deploy and runtime security, that need to be considered as part of your security strategy as well.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Deploy-Time Security"><div class="sect2" id="deploy_time_security">
<h2>Deploy-Time Security</h2>
<p>The next stage in securing workloads is to secure the deployment.<a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="securing each stage" data-tertiary="deploy stage" id="idm45326830213584"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="deploy-time security" id="idm45326830211856"/><a contenteditable="false" data-type="indexterm" data-primary="trust models" id="idm45326830210208"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="deploying a workload" id="idm45326830209104"/> To accomplish this, you have to harden your Kubernetes cluster where the workloads are deployed. You will need a detailed review of the Kubernetes cluster configuration to ensure that it is aligned with security best practices. Start by building a trust model for various components of your cluster. A trust model is a framework where you review a threat profile and define mechanisms to respond to it. You should leverage tools like role-based access control (RBAC), label taxonomies, label governance, and admission controls to design and implement the trust model. These are mechanisms to control access to resources and controls and validation applied at resource creation time. These topics are covered in detail in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.xhtml#workload_deployment_controls">3</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.xhtml#workload_runtime_security">4</a>, and 
<a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.xhtml#network_policy">7</a>. The other critical components in your cluster are the Kubernetes datastore and Kubernetes API server, and you need to pay close attention to details like access control and data security when you design the trust model for these components. We recommend you use strong credentials, public key infrastructure (PKI) for access, and transport layer security (TLS) for data in transit encryption. Securing the Kubernetes APT and the datastore is covered in detail in <a data-type="xref" href="ch02.xhtml#infrastructure_security">Chapter 2</a>.</p>
<p>You should think of the Kubernetes cluster where mission-critical workloads are deployed as an entity and then design a trust model for the entity. This requires you to review security controls at the perimeter, which will be challenging due to the Kubernetes deployment architectures; we will cover this in the next section. For now, let’s assume the current products that are deployed at the perimeter, like web access control gateways and next-generation firewalls, are not aware of Kubernetes architecture. We recommend you tackle this by building integrations with these devices, which will make them aware of the Kubernetes cluster context so they can be effective in applying security controls at the perimeter. This way you can create a very effective security strategy where the perimeter security devices work in conjunction with security implemented inside your Kubernetes cluster. As an example, say you need to make these devices aware of the identity of your workloads (IP address, TCP/UDP port, etc.). These devices can effectively protect the hosts that make up your Kubernetes cluster, but in most cases they cannot distinguish between workloads running on a single host. If you’re running in a cloud provider environment, you can use security groups, which are virtual firewalls that allow access control to a group of nodes (such as EC2 instances in Amazon Web Services) that host workloads. Security groups are more aligned with the Kubernetes architecture than traditional firewalls and security gateways; however, even security groups are not aware of the context for workloads running inside the cluster.</p>
<p>To summarize, when you consider deploy-time security, you need to implement a trust model for your Kubernetes cluster and build an effective integration with perimeter security devices that protect your cluster.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Runtime Security"><div class="sect2" id="runtime_security">
<h2>Runtime Security</h2>
<p>Now that you have a strategy in place to secure the build and deploy<a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="securing each stage" data-tertiary="runtime security" data-seealso="runtime security" id="ch01-run2"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="runtime security" data-seealso="runtime security" id="ch01-run"/><a contenteditable="false" data-type="indexterm" data-primary="runtime security" id="ch01-run3"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="runtime security" id="ch01-run4"/><a contenteditable="false" data-type="indexterm" data-primary="clusters" data-secondary="runtime security" id="ch01-run5"/> stages, you need to think about runtime security. The term <em>runtime security</em> is used for various aspects of securing a Kubernetes cluster, for example on a host running software, but any configuration that protects the host and workloads from unauthorized activity (e.g., system calls, file access) is also called runtime security. <a data-type="xref" href="ch04.xhtml#workload_runtime_security">Chapter 4</a> will cover host and workload runtime security in detail. In this section we will focus on the security best practices needed to ensure the secure operation of the Kubernetes cluster network. Kubernetes is an orchestrator that deploys workloads and applications across a network of hosts. You must consider network security as a very important aspect of runtime security.</p>
<p>Kubernetes promises increased agility and the more efficient use of compute resources, compared with the static partitioning and provisioning of servers or VMs. It does this by dynamically scheduling workloads across the cluster, taking into account the resource usage on each node, and connecting workloads on a flat network. <a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="IP addresses as ephemeral" id="idm45326830184784"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="pod IP addresses ephemeral" id="idm45326830183344"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="IP addresses of pods ephemeral" id="idm45326830181952"/>By default, when a new workload is deployed, the corresponding pod could be scheduled on any node in the cluster, with any IP address within the pod IP address. If the pod is later rescheduled elsewhere, then it will normally get a different IP address. This means that pod IP addresses need to be treated as ephemeral. There is no long-term or special meaning associated with pod IP addresses or their location within the network.</p>
<p>Now consider traditional approaches to network security. Historically, in enterprise networks, network security was implemented using security appliances (or virtual versions of appliances) such as firewalls and routers. The rules enforced by these appliances were often based on a combination of the physical topology of the network and the allocation of specific IP address ranges to different classes of workloads.</p>
<p>As Kubernetes is based on a flat network, without any special meaning <a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about networking" data-tertiary="flat network" id="idm45326830178720"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="flat network of Kubernetes" id="idm45326830176992"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about security" data-tertiary="different world of Kubernetes" id="idm45326833727600"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="overview of strategy" data-tertiary="different world of Kubernetes" id="idm45326833725936"/>for pod IP addresses, very few of these traditional appliances are able to provide any meaningful workload-aware network security and instead have to treat the whole cluster as a single entity. In addition, in the case of east-west traffic between two pods hosted on the same node, the traffic does not even go via the underlying network. So these appliances won’t see this traffic at all and are essentially limited to north-south security, which secures traffic entering the cluster from external sources and traffic originating inside the cluster headed to sources outside the cluster.</p>
<p>Given all of this, it should be clear that Kubernetes requires a new approach to network security. This new approach needs to cover a broad range of considerations, including:</p>
<ul>
<li><p>New ways to enforce network security (which workloads are allowed to talk to which other workloads) that do not rely on special meanings of IP addresses or network topology and that work even if the traffic does not traverse the underlying network; the Kubernetes network policy is designed to meet these needs.</p></li>
<li><p>New tools to help manage network policies that support new development processes and the desire for microservices to bring increased organizational agility, such as policy recommendations, policy impact previews, and policy staging.</p></li>
<li><p>New ways to monitor and visualize network traffic, covering both cluster-scoped holistic views (e.g., how to easily view the overall network and the cluster’s network security status) and targeted topographic views to drill down across a sequence of microservices to help troubleshoot or diagnose application issues.</p></li>
<li><p>New ways of implementing intrusion detection and threat defense, including policy violation alerting, network anomaly detection, and integrated threat feeds.</p></li>
<li><p>New remediation workflows, so potentially compromised workloads can be quickly and safely isolated during forensic investigation.</p></li>
</ul>
<ul class="less_space pagebreak-before">
<li><p>New mechanisms for auditing configuration and policy changes for compliance.</p></li>
<li><p>New mechanisms for auditing configuration and policy changes, and also Kubernetes-aware network flow logs to meet compliance requirements (since traditional network flow logs are IP-based and have little long-term meaning in the context of Kubernetes).</p></li>
</ul>
<p>We will review an example of a typical Kubernetes deployment<a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="example typical deployment" id="ch01-ex"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="example typical deployment" id="ch01-ex2"/><a contenteditable="false" data-type="indexterm" data-primary="multicloud environment" data-secondary="example typical deployment" id="ch01-ex3"/><a contenteditable="false" data-type="indexterm" data-primary="hybrid cloud environment" data-secondary="example typical deployment" id="ch01-ex4"/> in an enterprise to understand these challenges. <a data-type="xref" href="#example_of_a_kubernetes_deployment_in_a">Figure 1-2</a> is a representation of a common deployment model for Kubernetes and microservices in a multicloud environment. <a contenteditable="false" data-type="indexterm" data-primary="multicloud environment" id="idm45326833707408"/><a contenteditable="false" data-type="indexterm" data-primary="cloud environments" data-secondary="multicloud environment described" id="idm45326833706336"/>A multicloud environment is one where an enterprise deploys Kubernetes in more than one cloud provider (Amazon Web services, Google Cloud, etc.). <a contenteditable="false" data-type="indexterm" data-primary="hybrid cloud environment" id="idm45326833704656"/><a contenteditable="false" data-type="indexterm" data-primary="cloud environments" data-secondary="hybrid cloud environment described" id="idm45326833703536"/>A hybrid cloud environment is one where an enterprise has a Kubernetes deployment in at least one cloud provider environment and a Kubernetes deployment on-premise in its datacenter. Most enterprises have a dual cloud strategy and will have clusters running in Amazon Web Services (AWS), Microsoft Azure, or Google Cloud; more enterprises also have some legacy applications running in their datacenters. Workloads in the datacenter will likely be behind a security gateway that filters traffic coming in through the perimeter. Microservices running in these Kubernetes deployments are also likely to have one or more dependencies on:</p>
<ul>
<li><p>Other cloud services like AWS RDS or Azure DB</p></li>
<li><p>Third-party API endpoints like Twilio</p></li>
<li><p>SaaS services like Salesforce or Zuora</p></li>
<li><p>Databases or legacy apps running inside the datacenter</p></li>
</ul>
<p>Workloads in the datacenter will likely be behind a security gateway that filters traffic coming in through the perimeter.</p>
<p><em>Observability</em> in Kubernetes is the ability to<a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="about" id="idm45326833697424"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="observability" data-seealso="observability" id="idm45326833696048"/><a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="security strategy via" data-tertiary="runtime security" data-seealso="runtime security" id="idm45326833694400"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" data-tertiary="runtime security" data-seealso="runtime security" id="idm45326833692480"/> derive actionable insights about the state of Kubernetes from metrics collected (more on this later). While observability has other applications, like monitoring and troubleshooting, it is important in the context of network security too. Observability concepts applied to flow logs correlated with other Kubernetes metadata (pods labels, policies, namespaces, etc.) are used to monitor (and then secure) communications between pods in a Kubernetes cluster, detect malicious activity by comparing IP addresses with known malicious IP addresses, and use machine learning–based techniques to detect malicious activity. These topics are covered in the next section. As you can see in <a data-type="xref" href="#example_of_a_kubernetes_deployment_in_a">Figure 1-2</a>, the Kubernetes deployment poses challenges due to silos of data in each cluster and the potential loss of visibility from associating a workload in one cluster to a workload in another cluster or to an external service.</p>


<figure><div id="example_of_a_kubernetes_deployment_in_a" class="figure">
<img src="Images/ksao_0102.png" alt="" width="1439" height="1131"/>
<h6><span class="label">Figure 1-2. </span>Example of a Kubernetes deployment in an enterprise</h6>
</div></figure>
<p>As shown in <a data-type="xref" href="#example_of_a_kubernetes_deployment_in_a">Figure 1-2</a>, the footprint of a microservices application typically extends beyond the virtual private cloud (VPC) boundaries, and securing these applications requires a different approach from the traditional perimeter security approach. It is a combination of network security controls, observability, threat defense, and enterprise security controls. We will cover each of these next.</p>



<section data-type="sect3" data-pdf-bookmark="Network security controls"><div class="sect3" id="network_security_controls">
<h3>Network security controls</h3>
<p>Native security controls available from cloud providers (for example,<a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="network security controls" id="idm45326833682528"/><a contenteditable="false" data-type="indexterm" data-primary="runtime security" data-secondary="network security controls" id="idm45326833681008"/> AWS Security Groups or Azure Network Security Groups) or security gateways (for example, next-generation firewalls) on the perimeter of the VPC or datacenter do not understand the identity of a microservice inside a Kubernetes cluster. For example, you cannot filter traffic to or from a Kubernetes pod or service with your security group rules or firewall policies. <a contenteditable="false" data-type="indexterm" data-primary="network security controls" id="idm45326833679104"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="source network address translation" id="idm45326833677984"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="source network address translation" id="idm45326833676592"/>Additionally, by the time traffic from a pod hits a cloud provider’s network or a third-party firewall, the traffic (depending on the cloud provider’s architecture) has a source network address translation (SNAT) applied to it. In other words, the source IP address of traffic from all workloads on the node is set to the node IP, so any kind of allow/deny policies, at best, will have node-level (the node’s IP address) granularity.</p>
<p>Kubernetes workloads are highly dynamic and ephemeral. Let’s say a developer commits a new check-in for a particular workload.<a contenteditable="false" data-type="indexterm" data-primary="CI/CD (continuous integration and continuous delivery)" data-secondary="about workloads" id="idm45326833674064"/> The automated CI/CD workflow will kick in, build a new version of the pod (container), and start deploying this new version of the workload in Kubernetes clusters. Kubernetes orchestrator will do a rolling upgrade and deploy new instances of the workload. All of this happens in an automated fashion, and there is no room for manual or out-of-band workflows to reconfigure the security controls for the newly deployed workload.</p>
<p>You need a new security architecture to secure workloads running in a multi- or hybrid cloud infrastructure. <a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="declarative nature" data-tertiary="security architecture" id="idm45326833671536"/>Just like your workload deployment in a Kubernetes cluster, the security of the workload has to be defined as code, in a declarative model. Security controls have to be portable across Kubernetes distributions, clouds, infrastructures, and/or networks. These security controls have to travel with the workloads, so if a new version of the workload is deployed in a VPC for Amazon Elastic Kubernetes Service (EKS), instead of on-premise clusters, you can be assured that the security controls associated with the service will be seamlessly enforced without you having to rework any network topology, out-of-band configuration of security groups, or VPC/perimeter firewalls.</p>
<p>Network security controls are implemented by using a network <a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="network policies" data-seealso="network policies" id="idm45326833668432"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="about" id="idm45326833666704"/>policy solution that is native to Kubernetes and provides granular access controls. There are several well-known implementations of network policy (such as Calico, Weave Net, Kube-router, Antrea) that you can use. In addition to applying policy at Layer 3/Layer 4 (TCP/IP), we recommend you look at solutions that support <a contenteditable="false" data-type="indexterm" data-primary="Envoy proxy" data-secondary="application-layer policy" id="idm45326833664864"/><a contenteditable="false" data-type="indexterm" data-primary="application layer" data-secondary="network policies" id="idm45326833663520"/>application layer policy (such as HTTP/HTTPS). We also recommend picking a solution that is based on the popular proxy Envoy, as it is widely deployed for application-layer policy. <a contenteditable="false" data-type="indexterm" data-primary="microservices" data-secondary="about" id="idm45326833661824"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="microservices" id="idm45326833660448"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="microservices" id="idm45326833659072"/>Kubernetes supports deploying applications as microservices (small components serving a part of the application functionality) over a network of nodes. The communication between microservices relies on application protocols such as HTTP. Therefore, there is a need for granular application controls that can be implemented by application layer policy. For example, in a three-tier application, the frontend microservice may only be allowed to use HTTP GET-based requests with the backend database microservice (read access) and not allowed to use HTTP POST with the backend database microservice (write access). All these requests can end up using the same TCP connection, so it is essential to add a policy engine that supports application-level controls as described here.</p>
</div></section>
<section data-type="sect3" class="pagebreak-before" data-pdf-bookmark="Enterprise security controls"><div class="sect3" id="enterprise_security_controls">
<h3 class="less_space">Enterprise security controls</h3>
<p>Now that you have the strategy for network access controls and <a contenteditable="false" data-type="indexterm" data-primary="runtime security" data-secondary="enterprise security controls" id="idm45326833654208"/><a contenteditable="false" data-type="indexterm" data-primary="enterprise security controls" id="idm45326833652784"/><a contenteditable="false" data-type="indexterm" data-primary="encryption" data-secondary="data in transit" data-tertiary="enterprise security" id="idm45326833651664"/><a contenteditable="false" data-type="indexterm" data-primary="data encryption" data-secondary="data in transit" data-tertiary="enterprise security" id="idm45326833650016"/>observability defined, you should consider additional security controls that are important and prevalent in enterprises. Encryption of data in transit is a critical requirement for security and compliance. <a contenteditable="false" data-type="indexterm" data-primary="TLS-based encryption" id="idm45326833648016"/><a contenteditable="false" data-type="indexterm" data-primary="mTLS (mutual TLS) encryption" id="idm45326833646912"/><a contenteditable="false" data-type="indexterm" data-primary="mutual TLS (mTLS) encryption" id="idm45326833645792"/><a contenteditable="false" data-type="indexterm" data-primary="VPN-based encryption" id="idm45326833644672"/>There are several options to consider for encryption using traditional approaches, like TLS-based encryption in your workloads; mutual TLS, which is part of a service mesh platform; or a VPN-based approach like Wireguard (which offers a crypto key–based VPN).</p>
<p>We recommend that you leverage the data collection that is part of your <a contenteditable="false" data-type="indexterm" data-primary="compliance" data-secondary="observability data collection" id="idm45326833642880"/><a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="compliance requirements" id="idm45326833641536"/>observability strategy to build the reports needed to help with compliance requirements for <span class="keep-together">standards</span> like PCI, HIPAA, GDPR, and SOC 2. You should also consider the ability to ensure continuous compliance, and you can leverage the declarative nature of Kubernetes to help with the design and implementation of continuous compliance. For example, you can respond to a pod failing a compliance check by using the pod’s compliance status to trigger necessary action to correct the situation (trigger an image update).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Threat defense"><div class="sect3" id="threat_defense">
<h3>Threat defense</h3>
<p>Threat defense in a Kubernetes cluster is the ability to look at malicious <a contenteditable="false" data-type="indexterm" data-primary="runtime security" data-secondary="threat defense" data-seealso="threat defense" id="idm45326833636944"/><a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="about" id="idm45326833635200"/>activity in the cluster and then defend the cluster from it. Malicious activity allows an adversary to gain unauthorized access and manipulate or steal data from a Kubernetes cluster. The malicious activity can occur in many forms, such as exploiting an insecure configuration or exploiting a vulnerability in the application traffic or the application code.</p>
<p>When you build your threat defense strategy, you must consider both intrusion detection and prevention. <a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="intrusion detection" data-tertiary="about observability" id="idm45326833632560"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="about observability" id="idm45326833630912"/><a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="intrusion detection" id="idm45326833629568"/>The key to intrusion detection is observability; you need to review data collected to scan for known threats. In a Kubernetes deployment, data collection is very challenging due to the large amount of data you need to inspect. We have often heard this question: “Do I need a Kubernetes cluster to collect data to defend a Kubernetes cluster?” The answer is “no.” We recommend you align your observability strategy with intrusion detection and leverage smart aggregation to collect and inspect data. For example, you can consider using a tool that aggregates data as groups of “similar” pods talking to each other on a given destination port and protocol, instead of using the traditional method of aggregating by the five-tuple (source IP, source port, destination IP, destination port, protocol). This approach will help significantly reduce data collected without sacrificing effectiveness. Remember, several pods running the same container image and deployed in the same way will generate identical network traffic for a transaction. You may ask, “What if only one instance is infected? How can I detect that?” That’s a good question. There are a few ways. You could pick a tool that supports machine learning based on various metrics collected like connections, bytes, and packets to detect anomalous workloads. Another approach is to have a tool that can detect and match known malicious IPs and domains from well-known threat feeds as a part of collection, or log unaggregated network flows for traffic denied by policy. These are simple techniques that will help you build a strategy. Note that threat defense techniques evolve, and you will need a security research team to work with you to help understand your application and build a threat model to implement your threat defense strategy.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-run" id="idm45326833626224"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-run2" id="idm45326833624848"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-run3" id="idm45326833623472"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-run4" id="idm45326833622096"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-run5" id="idm45326833620720"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-ex" id="idm45326833619344"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-ex2" id="idm45326833617968"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-ex3" id="idm45326833616592"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-ex4" id="idm45326833615216"/></p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Observability"><div class="sect2" id="observability-id000001">
<h2>Observability</h2>
<p>Observability is very useful for monitoring and securing a distributed system like Kubernetes.<a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="security strategy via" id="ch01-obs"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="securing each stage" data-tertiary="observability" id="ch01-obs2"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="observability" id="ch01-obs3"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" id="ch01-obs4"/> Kubernetes abstracts a lot of details, and in order to monitor a system like it, you cannot collect and independently baseline and monitor individual metrics (such as a single network flow, a pod create/destroy event, or a CPU spike on one node). What is needed is a way to monitor these metrics in the context of the Kubernetes. For example, a pod associated with a service or a deployment is restarted and running as a different binary as compared to its peers, or a pod activity (network, filesystem, kernel system calls) is different from other pods in the deployment. This becomes even more complex when you consider an application that comprises several services (microservices) that are in turn backed by several pods.</p>
<p>Observability is useful in troubleshooting and monitoring the security of workloads in Kubernetes. As an example, observability in the context of a service in Kubernetes will allow you to do the following:</p>
<ul>
<li><p>Visualize your Kubernetes cluster as a service graph, which shows how pods are associated with services and the communication flows between services</p></li>
<li><p>Overlay application (Layer 7) and network traffic (Layer 3/Layer 4) on the service graph as separate layers that will allow you to easily determine traffic patterns and traffic load for applications and for the underlying network</p></li>
<li><p>View metadata for the node where a pod is deployed (e.g., CPU, memory, or host OS details).</p></li>
<li><p>View metrics related to the operation of a pod, traffic load, application latency (e.g., HTTP duration), network latency (network round-trip time), or pod operation (e.g., RBAC policies, service accounts, or container restarts)</p></li>
<li><p>View DNS activity (DNS response codes, latency, load) for a given service (pods backing the service)</p></li>
<li><p>Trace a user transaction that needs communication across multiple services; this is also known as <em>distributed tracing</em></p></li>
<li><p>View network communication of a given service to external entities</p></li>
<li><p>View Kubernetes activity logs (e.g., audit logs) for pods and resources associated with a given service.</p></li>
</ul>
<p>We will cover the details of observability and examples of how it can help security in subsequent chapters. For this discussion, we will cover a brief description of how you can use observability as a part of your security strategy.</p>
<section data-type="sect3" data-pdf-bookmark="Network traffic visibility"><div class="sect3" id="network_traffic_visibility">
<h3>Network traffic visibility</h3>
<p>As mentioned, a solution that provides network flows aggregated<a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" data-tertiary="network traffic visibility" data-seealso="networking" id="idm45326833263440"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="observability" data-tertiary="network traffic visibility" id="idm45326833261360"/><a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="security strategy via" data-tertiary="network traffic visibility" data-seealso="networking" id="idm45326833259696"/> at a service level with context like namespaces, labels, service accounts, or network policies is required to adequately monitor activity and access controls applied to the cluster. For example, there is a significant difference between reporting that IP1 communicated with IP2 over port 8080 and reporting that pods labeled “frontend” communicated with pods labeled “backend” on certain ports or traffic patterns between deployments of pods in a Kubernetes cluster. This reporting will allow you to review communication from external entities and apply IP address–based threat feeds to detect activity from known malicious IP addresses or even traffic from unexpected geographical locations. We will cover details for these concepts in <a data-type="xref" href="ch11.xhtml#threat_defense_and_intrusion_detection">Chapter 11</a>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="DNS activity logs"><div class="sect3" id="dns_activity_logs">
<h3>DNS activity logs</h3>
<p>Domain Name System (DNS) is a system used to translate domain<a contenteditable="false" data-type="indexterm" data-primary="DNS activity logs" id="idm45326833254032"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="DNS activity logs" id="idm45326833252848"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" data-tertiary="DNS activity logs" id="idm45326833251472"/> names into IP addresses. In your Kubernetes cluster, it is critical to review DNS activity logs to detect unexpected activity, for example queries to known malicious domains, DNS response codes like NXDOMAIN, and unexpected increases in bytes and packets in DNS queries. We will cover details for these concepts in <a data-type="xref" href="ch11.xhtml#threat_defense_and_intrusion_detection">Chapter 11</a>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Application traffic visibility"><div class="sect3" id="application_traffic_visibility">
<h3>Application traffic visibility</h3>
<p>We recommend you review application traffic flows for suspicious<a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="security strategy via" data-tertiary="application traffic visibility" data-seealso="application layer" id="idm45326833246432"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="observability" data-tertiary="application traffic visibility" id="idm45326833244368"/><a contenteditable="false" data-type="indexterm" data-primary="application layer" data-secondary="observability" data-tertiary="traffic observability" id="idm45326833242704"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" data-tertiary="application traffic visibility" data-seealso="application layer" id="idm45326833241056"/> activity like unexpected response codes and rare or known malicious HTTP headers (user-agent, query parameters). HTTP is the most common protocol used in Kubernetes deployments, so it is important to work with your security research team to monitor HTTP traffic for malicious traffic. In case you use other application protocols (e.g., Kafka, MySQL), you need to do the same for those as well.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Kubernetes activity logs"><div class="sect3" id="kubernetes_activity_logs">
<h3>Kubernetes activity logs</h3>
<p>In addition to network activity logs, you must also monitor Kubernetes<a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="security strategy via" data-tertiary="Kubernetes activity logs" data-seealso="logs" id="idm45326833236720"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="activity logs" id="idm45326833234656"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" data-tertiary="Kubernetes activity logs" data-seealso="logs" id="idm45326833233280"/><a contenteditable="false" data-type="indexterm" data-primary="audit logs" data-secondary="Kubernetes activity logs" id="idm45326833231328"/><a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="Kubernetes activity logs" id="idm45326833229936"/> activity logs to detect malicious activity. For example, review access-denied logs for resources access and service account creation/modification. Review namespace creation/modification logs for unexpected activity. And review the Kubernetes audit logs which record requests to the Kubernetes API.</p>
</div></section>
<section data-type="sect3" class="pagebreak-before" data-pdf-bookmark="Machine learning/anomaly detection"><div class="sect3" id="machine_learningsolidusanomaly_detectio">
<h3 class="less_space">Machine learning/anomaly detection</h3>
<p>Machine learning is a technique where a system is able to derive patterns<a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" data-tertiary="machine learning anomaly detection" data-seealso="machine learning" id="idm45326833225488"/><a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="security strategy via" data-tertiary="machine learning anomaly detection" data-seealso="machine learning" id="idm45326833223536"/><a contenteditable="false" data-type="indexterm" data-primary="machine learning (ML)" data-secondary="anomaly detection" id="idm45326833221600"/><a contenteditable="false" data-type="indexterm" data-primary="anomaly detection via machine learning" data-secondary="about" id="idm45326833220224"/> from data over a period of time. The output is a machine learning model, which can then be used to make predictions and detect deviations in real data based on the prediction. We recommend you consider applying machine learning–based anomaly detection to various metrics to detect strange activity. <a contenteditable="false" data-type="indexterm" data-primary="machine learning (ML)" data-secondary="anomaly detection" data-tertiary="baselining" id="idm45326833218384"/><a contenteditable="false" data-type="indexterm" data-primary="machine learning (ML)" data-secondary="baselining" data-tertiary="about" id="idm45326833216736"/><a contenteditable="false" data-type="indexterm" data-primary="anomaly detection via machine learning" data-secondary="baselining" data-tertiary="about" id="idm45326833215088"/><a contenteditable="false" data-type="indexterm" data-primary="baselining for anomaly detection" data-secondary="about" id="idm45326833213424"/>A simple and effective way is to apply a machine learning technique known as <em>baselining</em> to individual metrics. This way you do not need to worry about applying rules and thresholds for each metric; the system does that for you and reports deviations as anomalies. Applying machine learning techniques to network traffic is a relatively new area and is gaining traction with security teams. We will cover this topic in detail in <a data-type="xref" href="ch06.xhtml#observability_and_security">Chapter 6</a>.</p>
<p>There are many solutions that you can choose for your observability strategy for Kubernetes (Datadog, Calico Enterprise, cloud provider–based solutions from Google, AWS, Azure).<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-obs" id="idm45326833209680"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-obs2" id="idm45326833208208"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-obs3" id="idm45326833206832"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch01-obs4" id="idm45326833205456"/></p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Security Frameworks"><div class="sect2" id="security_frameworks">
<h2>Security Frameworks</h2>
<p>Finally, we want to make you aware of security frameworks that<a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="securing each stage" data-tertiary="security frameworks" id="idm45326833202320"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="security frameworks" id="idm45326833200592"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="frameworks" id="idm45326833198944"/> provide the industry a common methodology and terminology for security best practices. Security frameworks are a great way to understand attack techniques and best practices to defend and mitigate attacks. You should use them to build and validate your security strategy. Please note these frameworks may not be specific to Kubernetes, but they provide insights into techniques used by adversaries in attacks, and security researchers will need to review and see if they are relevant to Kubernetes. We will review two well-known frameworks—MITRE and Threat Matrix for Kubernetes.</p>
<section data-type="sect3" data-pdf-bookmark="MITRE"><div class="sect3" id="mitre">
<h3>MITRE</h3>
<p>MITRE is a knowledge base of adversary tactics and techniques<a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="frameworks" data-tertiary="MITRE knowledge base" id="idm45326833194720"/><a contenteditable="false" data-type="indexterm" data-primary="MITRE security knowledge base" id="idm45326833192992"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="MITRE security knowledge base" id="idm45326833191920"/><a contenteditable="false" data-type="indexterm" data-primary="kill chains of cyber attacks" id="idm45326833190528"/><a contenteditable="false" data-type="indexterm" data-primary="cybersecurity kill chain" id="idm45326833189408"/> based on real-world observations of cyberattacks. The <a href="https://oreil.ly/fxBKB">MITRE ATT&amp;CK® Matrix for Enterprise</a> is useful because it provides the tactics and techniques categorized for each stage of the cybersecurity kill chain. The kill chain is a description of the stages in a cyberattack and is useful for building an effective defense against an attack. <a contenteditable="false" data-type="indexterm" data-primary="cloud environments" data-secondary="MITRE security knowledge base" id="idm45326833187200"/>MITRE also provides an attack matrix tailored for cloud environments like AWS, Google Cloud, and Microsoft Azure.</p>
<p class="pagebreak-before"><a data-type="xref" href="#attack_matrix_for_cloud_environments_in">Figure 1-3</a> describes the <a href="https://oreil.ly/Mvyzz">MITRE ATT&amp;CK® Matrix for AWS.</a> We recommend that you review each of the stages described in the attack matrix as you build your threat model for securing your Kubernetes cluster.</p>
<figure><div id="attack_matrix_for_cloud_environments_in" class="figure">
<img src="Images/ksao_0103.png" alt="" width="3239" height="1698"/>
<h6><span class="label">Figure 1-3. </span>Attack matrix for cloud environments in AWS</h6>
</div></figure>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Threat matrix for Kubernetes"><div class="sect3" id="threat_matrix_for_kubernete">
<h3>Threat matrix for Kubernetes</h3>
<p>The other framework is a <a href="https://oreil.ly/GQery">threat matrix</a> <a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="frameworks" data-tertiary="threat matrix for Kubernetes" id="idm45326833178608"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="threat matrix" id="idm45326833176864"/><a contenteditable="false" data-type="indexterm" data-primary="MITRE security knowledge base" data-secondary="threat matrix for Kubernetes" id="idm45326833175488"/>that is a Kubernetes-specific application of the generic MITRE attack matrix. It was published by the Microsoft team based on security research and real-world attacks. This is another excellent resource to use to build and validate your security strategy. </p>
<p><a data-type="xref" href="#threat_matrix_for_kubernetes">Figure 1-4</a> provides the stages that are relevant to your Kubernetes cluster. They map to the various stages we discussed in this chapter. For example, you should consider the compromised images in the registry in the initial access stage, the access cloud resources in the privilege escalation stage, and the cluster internal network in the lateral movement stage for build, deploy, and runtime security, respectively.</p>
<figure><div id="threat_matrix_for_kubernetes" class="figure">
<img src="Images/ksao_0104.png" alt="" width="2506" height="1302"/>
<h6><span class="label">Figure 1-4. </span>Threat matrix for Kubernetes</h6>
</div></figure>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Security and Observability"><div class="sect1" id="security_and_observability">
<h1>Security and Observability</h1>
<p>In a dynamic environment like Kubernetes, a secure deployment<a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about security" data-tertiary="observability and" id="idm45326833168480"/><a contenteditable="false" data-type="indexterm" data-primary="deploying a workload" data-secondary="securing each stage" data-tertiary="observability" id="idm45326833166752"/><a contenteditable="false" data-type="indexterm" data-primary="workloads" data-secondary="deploying" data-tertiary="observability" id="idm45326833165104"/><a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="security strategy via" id="idm45326833163456"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="overview of strategy" data-tertiary="observability and security" id="idm45326833162080"/><a contenteditable="false" data-type="indexterm" data-primary="security" data-secondary="observability and security" id="idm45326833160416"/> of your applications can be achieved by thinking about security and observability together. As an example, you need to “observe” your cluster to find the optimal way to implement controls to secure the cluster. Kubernetes as an orchestration engine has strong adoption due to the fact that it is declarative in nature, allowing users to specify higher-level outcomes. Kubernetes also has built-in capabilities to ensure that your cluster operates as per the specifications. It does this by monitoring the various attributes and taking action (e.g., a pod restart) if the attribute deviates from the specified value for a period of time. These aspects of Kubernetes make it difficult to implement the visibility and controls needed to secure a cluster. The controls you implement need to be aligned with Kubernetes operations. Therefore, before you think of adding any controls to Kubernetes, it is important to understand the context—for example, you cannot isolate a pod by applying a policy that does not allow it to communicate with anything else. Kubernetes will detect that the pod is not able to communicate with the other elements (e.g., API server), determine that the pod is not operating as specified, and restart and spin up the pod somewhere else in the cluster.</p>

<p class="pagebreak-before">What you have to do is first understand how the pod operates and understand what its expected operation is and then apply controls or detect unexpected events. After that, you determine if the unexpected event is an operations issue or a security issue and then apply the required remediation. In order to do this, observability and security go hand in hand: You observe to understand what is expected and apply controls to ensure expected operation, then observe to detect unexpected events and analyze them, and then add necessary controls to remediate any issue due to the event. Therefore, you need a holistic approach for security and observability when you think about securing your clusters.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000006">
<h1>Conclusion</h1>
<p>By now you should have a high-level overview of what Kubernetes security and observability entails. These are the foundational concepts that underpin this entire book. In short:</p>
<ul>
<li><p>Security for Kubernetes is very different from traditional security and requires a holistic security and observability approach at all the stages of workload deployment—build, deploy, and runtime.</p></li>
<li><p>Kubernetes is declarative and abstracts the details of workload operations, which means workloads can be running anywhere over a network of nodes. Also, workloads can be ephemeral, where they are destroyed and re-created on a different node. Securing such a declarative distributed system requires that you think about security at all stages.</p></li>
<li><p>We hope you understand the importance of collaboration between the application, platform, and security teams when designing and implementing a holistic security approach.</p></li>
<li><p>MITRE and the Threat Matrix for Kubernetes are two security frameworks that are widely adopted by security teams.</p></li>
</ul>
<p>It’s important that you take in all of this together, because a successful security and observability strategy is a holistic one. In the next chapter, we will cover infrastructure security.</p>
</div></section>
</div></section></div></body></html>