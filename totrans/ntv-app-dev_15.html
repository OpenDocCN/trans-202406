<html><head></head><body><section data-pdf-bookmark="Chapter 14. Testing" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_testing">&#13;
<h1><span class="label">Chapter 14. </span>Testing</h1>&#13;
&#13;
&#13;
<p>Developers<a data-primary="testing" data-secondary="benefits of" data-type="indexterm" id="idm46177216187512"/> write code. Often they write a lot of code. The web of dependencies between objects and other services is often complex and not easily discernible; objects depend on other objects to work property. Making a change in even relatively simple codebases in one place can cause a bug or a crash in another part of the codebase. The house of cards that is your app can come quickly crashing down.</p>&#13;
&#13;
<p>Where does testing fit into all this? Testing is a way to provide developers with a level of confidence that the changes being made are not unknowingly affecting other parts of the application. Ideally, these tests would be automated and deterministic so as not to be subject to the unpredictable whims of humanity, in which error and poor judgment often present themselves. Fortunately, most modern platforms have testing built in. Both Android and iOS have full-featured and incredibly powerful testing tools that can be used to assist in developing code. Let’s see how these tools work.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177216184856">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="testing" data-secondary="task overview" data-type="indexterm" id="idm46177216183528"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Set up and run unit tests.</p>&#13;
</li>&#13;
<li>&#13;
<p>Set up and run integration tests.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177216179992">&#13;
<h1>Android</h1>&#13;
&#13;
<p>AOSP<a data-primary="testing" data-secondary="Android" data-tertiary="types of tests" data-type="indexterm" id="idm46177216177944"/><a data-primary="Android" data-secondary="testing" data-tertiary="types of tests" data-type="indexterm" id="idm46177216176664"/> defines and differentiates a few different types of tests:</p>&#13;
<dl>&#13;
<dt>Unit tests</dt>&#13;
<dd>&#13;
<p>These<a data-primary="unit tests" data-secondary="Android" data-type="indexterm" id="unit14"/> are highly focused tests that run on a single class, usually a single method in that class. If a unit test fails, you should know exactly where in your code the issue is. They have low fidelity since in the real world, your app involves much more than the execution of one method or class. They should be fast enough to run every time you change your code.</p>&#13;
</dd>&#13;
<dt>Integration tests</dt>&#13;
<dd>&#13;
<p>These<a data-primary="integration tests" data-secondary="overview of" data-type="indexterm" id="idm46177216170568"/> test the interaction of several classes to make sure they behave as expected when used together. One way to structure integration tests is to have them test a single feature, such as the ability to save a task. They test a larger scope of code than unit tests but are still optimized to run fast versus having full fidelity.</p>&#13;
</dd>&#13;
<dt>End-to-end tests</dt>&#13;
<dd>&#13;
<p>Test<a data-primary="end-to-end tests" data-type="indexterm" id="idm46177216167816"/> a combination of features working together. They are slow because they test large portions of the app and simulate real usage closely. They have the highest fidelity and tell you that your application actually works as a whole.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Testing in Android might be a little different than testing you’ve encountered before. The nomenclature and categorization has some overlap and doesn’t always use the same semantic you might find in other computer sciences.</p>&#13;
&#13;
<p>Let’s start with unit testing. Unit testing in Android is very similar to unit testing you might encounter in any number of frameworks or languages. We generally use a framework called JUnit, but even that’s not strictly necessary. A unit test should be highly focused and identify a very specific point in your code, so a failed unit test should be simple to correct. For example, if you have a method that multiples two numbers and returns the product, a unit test might invoke this method with some predetermined numbers to ensure the output is as expected. Let’s<a data-primary="Java" data-secondary="testing" data-type="indexterm" id="Jtest14"/><a data-primary="Kotlin" data-secondary="testing" data-type="indexterm" id="Ktest14"/> say your class looks like this:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177216162232">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Maths</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kt">int</code> <code class="nf">multiply</code><code class="o">(</code><code class="kt">int</code> <code class="n">a</code><code class="o">,</code> <code class="kt">int</code> <code class="n">b</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">a</code> <code class="o">*</code> <code class="n">b</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">multiply</code><code class="p">(</code><code class="n">a</code><code class="p">:</code><code class="n">Int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code><code class="n">Int</code><code class="p">):</code><code class="n">Int</code> <code class="p">{</code>&#13;
   <code class="k">return</code> <code class="n">a</code> <code class="p">*</code> <code class="n">b</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>You might start with an exceedingly simple test, like so:</p>&#13;
<aside class="java-kotlin pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177216080216">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MathsTests</code> <code class="o">{</code>&#13;
  <code class="nd">@Test</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">testMultiplication</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="kt">int</code> <code class="n">a</code> <code class="o">=</code> <code class="mi">2</code><code class="o">;</code>&#13;
    <code class="kt">int</code> <code class="n">b</code> <code class="o">=</code> <code class="mi">3</code><code class="o">;</code>&#13;
    <code class="kt">int</code> <code class="n">expected</code> <code class="o">=</code> <code class="mi">6</code><code class="o">;</code>&#13;
    <code class="kt">int</code> <code class="n">actual</code> <code class="o">=</code> <code class="n">Maths</code><code class="o">.</code><code class="na">multiply</code><code class="o">(</code><code class="n">a</code><code class="o">,</code> <code class="n">b</code><code class="o">);</code>&#13;
    <code class="n">assertEquals</code><code class="o">(</code><code class="n">expected</code><code class="o">,</code> <code class="n">actual</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">testMultiplication</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">val</code> <code class="py">a</code> <code class="p">=</code> <code class="m">2</code>&#13;
  <code class="k">val</code> <code class="py">b</code> <code class="p">=</code> <code class="m">3</code>&#13;
  <code class="k">val</code> <code class="py">expected</code> <code class="p">=</code> <code class="m">6</code>&#13;
  <code class="k">val</code> <code class="py">actual</code> <code class="p">=</code> <code class="n">Maths</code><code class="p">.</code><code class="n">multiply</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">)</code>&#13;
  <code class="n">assertEquals</code><code class="p">(</code><code class="n">expected</code><code class="p">,</code> <code class="n">actual</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Remember that local tests like these go in the IDE-generated <em>test</em> folder under the <em>src</em> parent directory. Instrumented tests—tests that will run in an actual or emulated device—go in the <em>androidTest</em> subfolder. See <a data-type="xref" href="#figures_android_topics_testing_directories">Figure 14-1</a> and the accompanying text for a little deeper dive.</p>&#13;
&#13;
<p>While this test may seem simple, it is critical in case a refactor is made later by developers who may not even be aware of the class or method. However, it’s pretty obvious that there’s a limit to the usefulness of very basic tests like this. Even for a simple method like <code>Maths.multiply</code>, consider all the possible circumstances that might produce interesting results.</p>&#13;
&#13;
<p>Static typing in Java reduces these outliers by a really impressive amount—since the datatype of both parameters is <code>int</code>, we never need to worry about <code>null</code> values, or values greater or less than a 32-bit signed number.</p>&#13;
&#13;
<p>Using Android testing guidelines, unit tests are also known as “small tests,” and the framework recommends that 70% of your test should be small/unit tests.</p>&#13;
&#13;
<p>Moving up the testing pyramid we find medium and large tests. Medium tests generally correlate with what might otherwise be known as integration tests—tests that rely on multiple logic blocks, classes, or methods to produce some expected result. Android testing guidelines suggest 20% of your tests should be medium tests. A medium, integration test might check login credentials. Are the strings supplied empty? Do they conform to expected patterns, like email formats or password masks? If the user data is local to the device, the integration test might check if authentication is successful, while apps using remote authentication may simply check if the method succeeded enough to issue the login HTTP request and may test that request as well for appropriate headers, body, encryption, and target.</p>&#13;
&#13;
<p>Some<a data-primary="integration tests" data-secondary="instrumented" data-type="indexterm" id="idm46177215915384"/> integration tests may be instrumented. An instrumented test is one that runs on a real device or an emulator, receives gesture events, relies on the system clock, and draws pixels to the screen.</p>&#13;
&#13;
<p>The<a data-primary="Robolectric library" data-type="indexterm" id="idm46177215913656"/> <a href="http://robolectric.org">Robolectric library</a> is very popular with Android developers and is a great option to support integration tests. As of Google I/O 2018, Robolectric 4 was released in conjunction with<a data-primary="AndroidX" data-type="indexterm" id="idm46177215911928"/> AndroidX testing, which replaces much of the Robolectric libraries. Much of this is opaque to the user and shouldn’t cause too much disruption in your existing test code. Start at <a href="https://oreil.ly/Wnp8A">the developer docs for AndroidX texting</a> if you want a complete walk-through of AndroidX versus Robolectic, how they work together, and how to get the most mileage out of each in your specific circumstance.</p>&#13;
&#13;
<p>We suggest you stick to Robolectric 4, and make sure the documentation you’re using is for that version. Robolectric and AndroidX testing do quite a bit of the boilerplate for you, including some mocking of Android framework classes, Activity life cycle emulation, and additional support functionality like the <code>Shadows</code> system, which allows you to easily mock any existing class and reassign logic. For example you could create a <code>ShadowThread</code> class that just runs itself on the main thread when <code>start</code> is called, rather than spinning up a new thread, or a <code>ShadowThreadPoolExecutor</code> that just runs its queue immediately, synchronously and serially, either of which can dramatically reduce the difficulty of testing asynchronous applications.</p>&#13;
&#13;
<p>Integration tests using AndroidX and Robolectric require you to familiarize yourself with some additional libraries. We’ll provide a couple of examples, but a complete tutorial on testing is well outside the scope of this chapter. Make sure you visit the <a href="https://oreil.ly/EpCMX">Android developer docs</a> if you’d like a deep dive into Android testing.</p>&#13;
&#13;
<p>Finally<a data-primary="end-to-end tests" data-type="indexterm" id="idm46177215905432"/> we have large tests, also known as end-to-end tests. End-to-end tests are usually instrumented and might encompass an entire “activity.” For example, consider an app that features postcard functionality, where the user can use the device’s camera to capture an image; the app decorates it with other graphics or graphical information, converts it to a stream, and uploads the image data to a server, where the user is authenticated and the image is saved so the user can retrieve or share it. An end-to-end test might start this process and test that the image is responsive and only available to share operations.</p>&#13;
&#13;
<p>Instrumented testing<a data-primary="UI testing" data-type="indexterm" id="idm46177215903544"/><a data-primary="instrumented testing" data-type="indexterm" id="idm46177215902808"/> is sometimes called “UI testing,” but really integration tests run outside of an instrumented environment could qualify as well. When tests are instrumented, however, you’ll want to engage another toolset: Espresso. Espresso<a data-primary="Espresso UI testing library" data-type="indexterm" id="idm46177215901768"/> has fluent syntax and a functional paradigm. The Espresso UI testing library can emulate clicks and scrolls and text input and even allows you to record user inputs to run and compare UI output to your expectations. If you want to know more about Espresso UI testing, visit <a href="https://oreil.ly/ziFOJ">the documentation</a>.</p>&#13;
&#13;
<p>In the following, you’ll find out how to write and execute both unit and integration tests.</p>&#13;
&#13;
<p>As soon as you create a project in<a data-primary="Android Studio" data-secondary="test directories" data-type="indexterm" id="idm46177215899080"/> Android Studio, you’ll find test directories immediately available. The easiest way to see and interact with those directories is to use the Android view of the project display dropdown.</p>&#13;
&#13;
<p>Open your application module (usually just named “app”) and then the “java” subdirectory. Inside of that, you’ll find at least three directories. The first you’ll see is your main source code, which will have a name identical to your package (e.g., “my.site.appname”). There will be two directories just under that, with the same name, but with an additional label in a dimmed color, in parentheses, indicating “(test)” or “(androidTest)” (<a data-type="xref" href="#figures_android_topics_testing_directories">Figure 14-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figures_android_topics_testing_directories">&#13;
<img alt="Android Studio Test Directories" src="assets/nmdv_1401.png"/>&#13;
<h6><span class="label">Figure 14-1. </span>Android Studio test directories</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first folder will hold all your source code. The folder with the “(test)” label will hold your unit and integration tests. The last folder labeled “(androidTest)” are for Espresso UI tests, which we will not be covering in this chapter.</p>&#13;
&#13;
<p>Whether you set up your initial project configuration to default to Java or Kotlin, you’ll see the same structure. If you later add files of the opposite type (if your project was set up for Kotlin, but you add Java files, or vice versa), you’ll find each of these directories duplicated—one per language for source, unit and integration tests, and UI tests.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Set Up and Run Unit Tests" data-type="sect2"><div class="sect2" id="idm46177215892344">&#13;
<h2>Set Up and Run Unit Tests</h2>&#13;
&#13;
<p>Both<a data-primary="testing" data-secondary="Android" data-tertiary="unit tests" data-type="indexterm" id="idm46177215890600"/><a data-primary="Android" data-secondary="testing" data-tertiary="unit tests" data-type="indexterm" id="idm46177215889320"/> JUnit- and Robolectric-based tests will go in the directory labeled “(test),” which we’ll refer to simply as the “test directory” from here on.</p>&#13;
&#13;
<p>If you open this folder, you’ll find an example test class has already been created, usually named “ExampleUnitTest.” It will also import the basic JUnit <code>assert</code> static methods. It might have something simple already included, like:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177215886696">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ExampleUnitTest</code> <code class="o">{</code>&#13;
  <code class="nd">@Test</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">addition_isCorrect</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">assertEquals</code><code class="o">(</code><code class="mi">4</code><code class="o">,</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">ExampleUnitTest</code> <code class="p">{</code>&#13;
  <code class="n">@Test</code>&#13;
  <code class="k">fun</code> <code class="nf">addition_isCorrect</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">assertEquals</code><code class="p">(</code><code class="m">4</code><code class="p">,</code> <code class="m">2</code> <code class="p">+</code> <code class="m">2</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>This is the most basic implementation of a unit test. A unit test proves out one functional unit of code. The preceding example isn’t terribly useful since all statements are within the test itself, but let’s consider a slightly more useful example:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177215824072">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Calculator</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="nf">add</code><code class="o">(</code><code class="kt">int</code> <code class="n">a</code><code class="o">,</code> <code class="kt">int</code> <code class="n">b</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">add</code><code class="p">(</code><code class="n">a</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">Int</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="n">a</code> <code class="p">+</code> <code class="n">b</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>To test this simple class, we might write a unit test like so:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177215726024">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CalculatorTest</code> <code class="o">{</code>&#13;
  <code class="nd">@Test</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">add_returnsCorrectValue_forPositiveValues</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="kt">int</code> <code class="n">expected</code> <code class="o">=</code> <code class="mi">4</code><code class="o">;</code>&#13;
    <code class="kt">int</code> <code class="n">actual</code> <code class="o">=</code> <code class="n">Calculator</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="mi">2</code><code class="o">,</code> <code class="mi">2</code><code class="o">);</code>&#13;
    <code class="n">assertEquals</code><code class="o">(</code><code class="n">expected</code><code class="o">,</code> <code class="n">actual</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">AddTest</code> <code class="p">{</code>&#13;
  <code class="n">@Test</code>&#13;
  <code class="k">fun</code> <code class="nf">add_returnsCorrectValue_forPositiveValues</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">expected</code> <code class="p">=</code> <code class="m">4</code>&#13;
    <code class="k">val</code> <code class="py">actual</code> <code class="p">=</code> <code class="n">add</code><code class="p">(</code><code class="m">2</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code>&#13;
    <code class="n">assertEquals</code><code class="p">(</code><code class="n">expected</code><code class="p">,</code> <code class="n">actual</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Note that <code>assert</code> methods expect an “actual” value (one produced by your logic) and an “expected” value (what the result of that logic should produce). These are compared, and if they do not match (or if they do not match the implied outcome from specific <code>assert</code> methods like <code>assertTrue</code> or <code>assertFalse</code>), they simply throw an <code>Exception</code>; when the proposition fails, these <code>Exception</code> instances are <code>caught</code> by the testing framework in order to organize and track what tests pass or fail.</p>&#13;
&#13;
<p>For procedural code, where the same inputs always produce the same outputs, unit tests are almost always appropriate and almost always helpful. For state-based environments (in object-oriented programming like much of Java and Kotlin), things can get a little trickier.</p>&#13;
&#13;
<p>When you’re integrating your code into a framework, like AOSP, you’ll rely on certain framework features, classes, and values, and will want to “integrate” your logic. These tests can become more difficult, and when dealing with things like <code>Activity</code> interaction and life cycle, can become extremely difficult to manage from scratch. It’s for this reason that the Robolectric library was created—this provides a way to interact with framework features like those just mentioned in a simple way.</p>&#13;
&#13;
<p>Note that Robolectric is moving to become part of the overall “Android Test” framework, and speakers around both Robolectric and AndroidX testing seemed to indicate at the last Google I/O event before this book was published that the Robolectric pieces will soon be removed in favor of Android-specific APIs, merged with them, or replaced by identical APIs in the new AndroidX packages. So far, it seems like there is some real value in AndroidX testing. Using Espresso syntax for both local and instrumented UI testing could be a huge gain for any team, but at the same time, even a year later we’ve found some nontrivial bugs that are likely being worked on but have prevented our team from migrating fully.</p>&#13;
&#13;
<p>When tests have to be integrated with other code, especially opaque toolsets like the one used by Android to paint pixels on the screen, you might be really limited in the tests that are not only helpful, but feasible. When writing tests, consider<a data-primary="return on investment (ROI)" data-type="indexterm" id="idm46177215542648"/> return on investment (ROI). You’ll often hear the term “coverage”; this generally indicates how much of your code is being tested, but in reality there are a number of ways to compute coverage—some people use the total number of lines that are references, other people consider statements or even logical branching. If 100% coverage is required on a team of one or two, on a new product that needs feature work to succeed, you (and your team) may have to determine the best and most realistic approach to testing for your specific needs. Depending on your definition of coverage, it might be impossible to achieve 100% coverage. In the preceding <code>Calculator.add</code> test, we can assume that one (or a few) tests like the one in the example are sufficient, and we don’t think anyone would propose testing every possible value of adding any two integers, <em>but</em> you might want to test what happens when two integers are added that exceed the maximum integer value on your system, or what happens when negative or null values are passed in. As we said, it’s up to you and your team to define testing scope, requirements, coverage, and best practices, and these can vary wildly between organizations, or even between teams within organizations or individuals  within teams.<a data-primary="" data-startref="unit14" data-type="indexterm" id="idm46177215539736"/><a data-primary="" data-startref="Jtest14" data-type="indexterm" id="idm46177215538760"/><a data-primary="" data-startref="Ktest14" data-type="indexterm" id="idm46177215537816"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Set Up and Run Integration Tests" data-type="sect2"><div class="sect2" id="idm46177215891720">&#13;
<h2>Set Up and Run Integration Tests</h2>&#13;
&#13;
<p>As<a data-primary="testing" data-secondary="Android" data-tertiary="integration tests" data-type="indexterm" id="idm46177215535368"/><a data-primary="Android" data-secondary="testing" data-tertiary="integration tests" data-type="indexterm" id="idm46177215534088"/><a data-primary="integration tests" data-secondary="Android" data-type="indexterm" id="idm46177215532872"/> mentioned, integration tests prove how well your logic functions as logical flow, rather than a single unit. Let’s use an example to touch on the main points; this uses Robolectric shadows and annotations and AndroidX <code>ActivityScenario</code>s for <code>Context</code> references and life cycle:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177215530600">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@RunWith</code><code class="o">(</code><code class="n">AndroidJUnit4</code><code class="o">.</code><code class="na">class</code><code class="o">)</code>&#13;
<code class="nd">@Config</code><code class="o">(</code><code class="n">shadows</code> <code class="o">=</code> <code class="o">{</code><code class="n">ShadowAsyncTask</code><code class="o">.</code><code class="na">class</code><code class="o">})</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">LoginActivityTest</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">private</code> <code class="n">Activity</code> <code class="n">mActivity</code><code class="o">;</code>&#13;
&#13;
  <code class="nd">@Before</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setup</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">Intents</code><code class="o">.</code><code class="na">init</code><code class="o">();</code>&#13;
    <code class="n">ActivityScenario</code> <code class="n">scenario</code> <code class="o">=</code> <code class="n">ActivityScenario</code><code class="o">.</code><code class="na">launch</code><code class="o">(</code><code class="n">MyActivity</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
    <code class="n">scenario</code><code class="o">.</code><code class="na">moveToState</code><code class="o">(</code><code class="n">Lifecycle</code><code class="o">.</code><code class="na">State</code><code class="o">.</code><code class="na">RESUMED</code><code class="o">);</code>&#13;
    <code class="n">scenario</code><code class="o">.</code><code class="na">onActivity</code><code class="o">(</code><code class="n">activity</code> <code class="o">-&gt;</code> <code class="n">mActivity</code> <code class="o">=</code>  <code class="n">activity</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@After</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">teardown</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">Intents</code><code class="o">.</code><code class="na">release</code><code class="o">();</code>&#13;
    <code class="n">mActivity</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Test</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">loginActivity_whenLaunched_shouldShowRequiredControls</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">onView</code><code class="o">(</code><code class="n">withId</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">id</code><code class="o">.</code><code class="na">credentials</code><code class="o">)).</code><code class="na">check</code><code class="o">(</code><code class="n">matches</code><code class="o">(</code><code class="n">isDisplayed</code><code class="o">()));</code>&#13;
    <code class="n">onView</code><code class="o">(</code><code class="n">withId</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">id</code><code class="o">.</code><code class="na">submit</code><code class="o">)).</code><code class="na">check</code><code class="o">(</code><code class="n">matches</code><code class="o">(</code><code class="n">isDisplayed</code><code class="o">()));</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">@RunWith</code><code class="p">(</code><code class="n">AndroidJUnit4</code><code class="o">::</code><code class="k">class</code><code class="p">)</code>&#13;
<code class="n">@Config</code><code class="p">(</code><code class="n">shadows</code> <code class="p">=</code> <code class="p">{</code> <code class="n">ShadowAsyncTask</code><code class="o">::</code><code class="k">class</code> <code class="err">})</code>&#13;
<code class="k">class</code> <code class="nc">LoginActivityTest</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">private</code> <code class="k">var</code> <code class="py">activity</code><code class="p">:</code> <code class="n">Activity</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
&#13;
  <code class="n">@Before</code>&#13;
  <code class="k">fun</code> <code class="nf">setup</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">Intents</code><code class="p">.</code><code class="n">init</code><code class="p">()</code>&#13;
    <code class="k">val</code> <code class="py">scenario</code> <code class="p">=</code> <code class="n">ActivityScenario</code><code class="p">.</code><code class="n">launch</code><code class="p">(</code><code class="n">MyActivity</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">)</code>&#13;
    <code class="n">scenario</code><code class="p">.</code><code class="n">moveToState</code><code class="p">(</code><code class="n">Lifecycle</code><code class="p">.</code><code class="n">State</code><code class="p">.</code><code class="n">RESUMED</code><code class="p">)</code>&#13;
    <code class="n">scenario</code><code class="p">.</code><code class="n">onActivity</code><code class="p">({</code> <code class="n">a</code> <code class="p">-&gt;</code> <code class="n">activity</code> <code class="p">=</code> <code class="n">a</code> <code class="p">})</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="n">@After</code>&#13;
  <code class="k">fun</code> <code class="nf">teardown</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">Intents</code><code class="p">.</code><code class="n">release</code><code class="p">()</code>&#13;
    <code class="n">activity</code> <code class="p">=</code> <code class="k">null</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="n">@Test</code>&#13;
  <code class="k">fun</code> <code class="nf">loginActivity_whenLaunched_shouldShowRequiredControls</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">onView</code><code class="p">(</code><code class="n">withId</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">credentials</code><code class="p">)).</code><code class="n">check</code><code class="p">(</code><code class="n">matches</code><code class="p">(</code><code class="n">isDisplayed</code><code class="p">()))</code>&#13;
    <code class="n">onView</code><code class="p">(</code><code class="n">withId</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">submit</code><code class="p">)).</code><code class="n">check</code><code class="p">(</code><code class="n">matches</code><code class="p">(</code><code class="n">isDisplayed</code><code class="p">()))</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Let’s break down this code:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The <code>@RunWith</code> annotation simply tells the testing system that we’re using the JUnit4 runner.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>@Config</code> annotation can be used for a number of configuration settings, but in this case we’re indicating we want to use the <code>ShadowAsyncTask</code> class. Let’s assume this class overrode the default behavior of the <code>AsyncTask</code> that submits the job to a new <code>Thread</code> to just run the job on the existing thread. That means any asynchronous operations we do using <code>AsyncTask</code> have just become both synchronous and serial, and much easier to predict and control when testing behavior.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>@Before</code> annotation indicates a setup method that fires before any test method is invoked. In our setup method, we initialize the AndroidX <code>Intents</code> class so that we can examine or intercept pending or received intents, so we might determine if a button tap does send an intent to start some <code>Activity</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>@After</code> annotation is the opposite of <code>@Before</code> and is performed after each test returns. Here, we simply release the <code>Intents</code> functionality and dereference the member-level <code>Activity</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Each of your tests should be annotated with <code>@Test</code>. The name of the method may seem unwieldy, but follows the convention of “given-when-then,” so we can differentiate pieces of functionality that may seem very similar at first glance. In these specific tests, we use the fluent style of Espresso APIs to check that a couple <code>View</code> instances are visible, to receive and submit the credentials input by a user.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Note that in the preceding example, we are using Espresso APIs inside a local test—not an instrumented test. Prior to AndroidX, this was not possible, and all Espresso code ran only in devices or emulated device environments.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177216179048">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>There<a data-primary="testing" data-secondary="iOS" data-tertiary="unit tests" data-type="indexterm" id="Tiodunit14"/><a data-primary="iOS" data-secondary="unit tests" data-type="indexterm" id="IOStestunit14"/><a data-primary="unit tests" data-secondary="iOS" data-type="indexterm" id="UTios14"/> are great tools built into Xcode to facilitate testing within iOS. Primarily tests in iOS are segmented into unit and UI tests, with UI testing being a bit like automated integration tests depending on how the tests are run and set up. Without further ado, let’s dive into writing some unit tests.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Set Up and Run Unit Tests" data-type="sect2"><div class="sect2" id="idm46177215184824">&#13;
<h2>Set Up and Run Unit Tests</h2>&#13;
&#13;
<p>In order to write and run unit tests for an iOS app, it’s important to first add a new target to the Xcode project. You can do this by going to File &gt; New &gt; Target in the application menu bar. From there, you can add a new iOS Unit Testing Bundle to create a unit testing target that Xcode can build and run. Follow the prompts (it’s generally all right to use the defaults) and click Finish to add the target to the project. Doing this will create a new folder to contain the unit tests themselves and—depending on how the project has been set up—a new target will be added in the <em>Products</em> folder within the file tree on the left side of Xcode with the extension <em>.xctest</em>. This is the bundle that is built that contains all your unit tests and libraries; it can be targeted just like the <code>.app</code> target that is your application bundle, which means libraries specific to the test bundle can be added, such as third-party libraries that make writing tests easier or have different functionality.</p>&#13;
&#13;
<p>Once the testing target has been added, you can add a new suite of tests to the project by going to File &gt; New &gt; File, selecting Unit Test Case Class, and giving a name for the class and file. The conventional approach to file naming in Xcode is to name the file and class after the object being tested. This isn’t a hard-and-fast rule, but generally it’s adhered to in most projects. For example, an class named <code>Calculator</code> might have a corresponding test suite named <code>CalculatorTests</code> with different tests being ran against it.</p>&#13;
&#13;
<p>Convention over configuration is the name of the game with regards to testing in Xcode, and you’ll see this come up again and again, most prominently in adding tests to be run. Let’s see what that looks like.</p>&#13;
&#13;
<p>In our hypothetical <code>CalculatorTests</code> class, we can add a new test by opening up <em>CalculatorTests.swift</em> and adding a new method to this class that begins with <code>test</code>. For example:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">testExample</code><code class="p">()</code> <code class="p">{</code>&#13;
	<code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The convention part of this is that Xcode recognizes each test in a test case file by the fact that its method name begins with “test.” If you were to run the test suite by going to Product &gt; Test, then that test will run, and it’ll receive a green checkmark beside it in Xcode to indicate that it’s been successful.</p>&#13;
&#13;
<p>Let’s take a look at the whole test case class instead of the individual test. For example, right now, <code>CalculatorTests</code> looks like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">CalculatorTests</code><code class="p">:</code> <code class="n">XCTestCase</code> <code class="p">{</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">setUp</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">tearDown</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">testExample</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There are a few things to note here. To begin, <code>CalculatorTests</code> inherits from <code>XCTestCase</code>, which is the place where all individual tests live as methods on a test case. We also have our <code>testExample</code> test at the bottom of the file. This is a test that will run and requires some type of assertions to check for success or failure.</p>&#13;
&#13;
<p>There are a number of assertions that are possible, such as:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>XCTAssert()</code>, which takes an expression that returns a boolean</p>&#13;
</li>&#13;
<li>&#13;
<p><code>XCTAssertFalse()</code> and <code>XCTAssertTrue()</code>, which check for a specific boolean value</p>&#13;
</li>&#13;
<li>&#13;
<p><code>XCTAssertEquals()</code> and <code>XCTAssertNotEqual()</code>, which check for equality between objects</p>&#13;
</li>&#13;
<li>&#13;
<p><code>XCTAssertNil()</code> and <code>XCTAssertNotNil()</code>, which check for a <code>nil</code> condition</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In order to use these assert macros, just add them within the method body like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">testExample</code><code class="p">()</code> <code class="p">{</code>&#13;
	<code class="kd">let</code> <code class="nv">success</code> <code class="p">=</code> <code class="kc">false</code>&#13;
	<code class="n">XCTAssertTrue</code><code class="p">(</code><code class="n">success</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This will generate a failing test because <code>success</code> is set to <code>false</code> on the preceding line. When the validity is checked and it’s <code>true</code>, that test fails. Assertions are fairly straightforward to use, and you can string them along for multiple assertions within a test.</p>&#13;
&#13;
<p>Within the test case, there are also <code>setUp()</code> and <code>tearDown()</code> methods. These are standard methods that are called every time a test is run within this class to—you guessed it—set up the test and subject under test and tear down the test afterwards. As an example, we could create an instance of our <code>Calculator</code> that’s being tested and store it under a <code>sut</code> variable so that we can reference it easily and tear it down after we’re finished so our test methods are not littered with construction logic. Here’s an <span class="keep-together">example</span>:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">CalculatorTests</code><code class="p">:</code> <code class="n">XCTestCase</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">sut</code><code class="p">:</code> <code class="n">Calculator</code><code class="p">!</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">setUp</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">self</code><code class="p">.</code><code class="n">setUp</code><code class="p">()</code>&#13;
        <code class="n">sut</code> <code class="p">=</code> <code class="n">Calculator</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">tearDown</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">sut</code> <code class="p">=</code> <code class="kc">nil</code>&#13;
        <code class="kc">self</code><code class="p">.</code><code class="n">tearDown</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">testTwoPlusTwoEqualsFour</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kd">let</code> <code class="nv">result</code> <code class="p">=</code> <code class="n">sut</code><code class="p">.</code><code class="n">enter</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="n">add</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>&#13;
        <code class="n">XCTAssertEqual</code><code class="p">(</code><code class="n">result</code><code class="p">,</code> <code class="mi">4</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Occasionally, it’ll be necessary to run tests on asynchronous functionality. This is tough because the test method will return before the test actually runs in the asynchronous code. This can be pretty tough to debug and work around. However, with test expectations in the testing framework, this is not too tough. Here’s an example:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">testAsynchronousCode</code><code class="p">()</code> <code class="p">{</code>&#13;
	<code class="kd">let</code> <code class="nv">expectation</code> <code class="p">=</code> <code class="n">XCTestExpectation</code><code class="p">(</code><code class="n">description</code><code class="p">:</code>&#13;
	  <code class="s">"Asynchronous code will return true."</code><code class="p">)</code>&#13;
&#13;
	<code class="n">sut</code><code class="p">.</code><code class="n">enter</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="n">add</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="n">shareToTwitter</code> <code class="p">{</code> <code class="p">(</code><code class="n">success</code><code class="p">)</code> <code class="k">in</code>&#13;
		<code class="k">if</code> <code class="n">success</code> <code class="p">{</code>&#13;
			<code class="n">expectation</code><code class="p">.</code><code class="n">fulfill</code><code class="p">()</code>&#13;
		<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
			<code class="n">XCTFail</code><code class="p">(</code><code class="s">"Sharing to Twitter did not work."</code><code class="p">)</code>&#13;
		<code class="p">}</code>&#13;
	<code class="p">}</code>&#13;
	<code class="n">waitForExpectations</code><code class="p">(</code><code class="n">timeout</code><code class="p">:</code> <code class="mf">2.0</code><code class="p">)</code> <code class="p">{</code> <code class="p">(</code><code class="n">error</code><code class="p">)</code> <code class="k">in</code>&#13;
		<code class="n">XCTFail</code><code class="p">(</code><code class="s">"Test failed."</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, we first create an expectation to fulfill in the asynchronous code that’s executed. In our fake <code>shareToTwitter(:)</code> method, we are passing a closure in that executes after sharing our calculator’s result to Twitter. We check to see if <code>success</code> is <code>true</code> and if it is, we call <code>fulfill()</code> on that expectation to let Xcode know the test passed or we call <code>XCTFail()</code> to indicate a failure has occurred. Finally, we call <code>waitForExpectations(timeout::)</code> to indicate that we are waiting for expectations to complete with a timeout value of two seconds. If we don’t have expectations completed by then, we call <code>XCTFail()</code> to indicate the test has failed as well.</p>&#13;
&#13;
<p>We hope it’s apparent that unit testing isn’t as scary as maybe you once thought it was in Xcode and iOS. Let’s take a look at another beast, which has been tamed: integration tests through the use of UI testing in iOS.<a data-primary="" data-startref="UTios14" data-type="indexterm" id="idm46177214813688"/><a data-primary="" data-startref="IOStestunit14" data-type="indexterm" id="idm46177214812712"/><a data-primary="" data-startref="Tiodunit14" data-type="indexterm" id="idm46177214811768"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177215183784">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>We’ve looked at our how testing in Android and iOS are both complete systems capable of testing assertions in a way that’s consistent, quick, and painless. Writing unit tests is often overlooked, but you’ll find—over time—that the initial time investment pays dividends in the future as the stability of changes to the application are run against expectations of existing behavior.</p>&#13;
&#13;
<p>Now that we’ve covered how different technologies of Android and iOS interact with each other, let’s do something fun. Let’s build an app. Check out <a data-type="xref" href="part02.html#part_2_app">Part II</a> to get started!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>