<html><head></head><body><section data-pdf-bookmark="Chapter 7. Coroutines Concepts" data-type="chapter" epub:type="chapter"><div class="chapter" id="coroutine_concepts">&#13;
<h1><span class="label">Chapter 7. </span>Coroutines Concepts</h1>&#13;
&#13;
&#13;
<p><a data-primary="coroutines" data-type="indexterm" id="ix_ch07-asciidoc0"/>In the previous chapter, you learned of the pitfalls of the threading model. As an alternative to the threading model, the Kotlin language has a library called &#13;
<span class="keep-together"><em>kotlinx.coroutines</em></span> which aims at&#13;
fixing the previously mentioned limitations. Coroutine-enabled primitives allow developers to write sequential,&#13;
asynchronous code at a low cost.&#13;
The design of coroutines comprises <em>suspending functions</em>, <em>structured concurrency</em>, and other specific&#13;
considerations like <em>coroutine context</em> and <em>coroutine scope</em>. The subjects are closely related to one another. We’ll cover each one&#13;
of these considerations in a way that is incremental and digestible.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Exactly Is a Coroutine?" data-type="sect1"><div class="sect1" id="idm46669751281952">&#13;
<h1>What Exactly Is a Coroutine?</h1>&#13;
&#13;
<p>The official Kotlin documentation qualifies coroutines as “lightweight threads” in an effort to leverage an existing and&#13;
well-known paradigm. You may conceptualize coroutines as <em>blocks of code that can be dispatched to threads&#13;
that are nonblocking</em>.</p>&#13;
&#13;
<p>Coroutines are indeed <em>lightweight</em>, but it is important to note that <em>coroutines aren’t threads</em> themselves.&#13;
In fact, many coroutines can run on a single thread, although each has a lifecycle of its own.&#13;
Rather, you’ll see in this section that they really are just state machines, with each state corresponding to a&#13;
block of code that some thread will eventually execute.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You might be surprised to find that the concept of coroutines goes all the way back to the early 1960s with the&#13;
creation of Cobol’s compiler, which used the idea of suspending and launching functions in assembly language.&#13;
Coroutines can also be spotted in the languages Go, Perl, and Python.</p>&#13;
</div>&#13;
&#13;
<p>The coroutine library offers some facilities to manage those threads out of the box. However, you can configure&#13;
the coroutine builder to manage your threads yourself if you need to.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Your First Coroutine" data-type="sect2"><div class="sect2" id="idm46669751276160">&#13;
<h2>Your First Coroutine</h2>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="example" data-type="indexterm" id="ix_ch07-asciidoc1"/>Throughout this section, we’ll introduce a lot of new vocabulary and concepts from the <code>kotlinx.coroutines</code>&#13;
package. To make this learning smooth, we chose to start with a simple coroutine usage, and explain&#13;
how this works along the way.</p>&#13;
&#13;
<p>The following example, as well as the others in this chapter, uses semantics declared in the <code>kotlinx.coroutines</code> package:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">job</code><code class="p">:</code> <code class="n">Job</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="k">var</code> <code class="py">i</code> <code class="p">=</code> <code class="m">0</code>&#13;
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"$i I'm working"</code><code class="p">)</code>&#13;
            <code class="n">i</code><code class="p">++</code>&#13;
            <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">delay</code><code class="p">(</code><code class="m">30</code><code class="p">)</code>&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">cancel</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The method<a data-primary="runBlocking" data-type="indexterm" id="idm46669751269456"/> <code>runBlocking</code> runs a new coroutine and blocks the current thread until the coroutine work has completed.&#13;
This coroutine builder is typically used in main functions and testing as it serves as a bridge to regular blocking code.</p>&#13;
&#13;
<p>Inside the code block, we create a coroutine with the <code>launch</code> function. Since it creates a coroutine, it’s&#13;
a <em>coroutine builder</em>—you’ll see later that other coroutine builders exist. The method <code>launch</code> returns a reference to&#13;
a <code>Job</code>, which represents the lifecycle of the coroutine launched.</p>&#13;
&#13;
<p>Inside the coroutine, there’s a <code>while</code>-loop that executes indefinitely. Below the <code>job</code> coroutine, you may&#13;
notice that the <code>job</code> is cancelled later on. To demonstrate what this means, we can run our program and the output is as follows:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">0 I'm working&#13;
1 I'm working&#13;
2 I'm working</pre>&#13;
&#13;
<p>It appears that the coroutine ran like clockwork. In tandem, the code continues to execute in the main thread, giving&#13;
us a total of three printed lines within a 30 ms window given to us by the <code>delay</code> call, as shown in <a data-type="xref" href="#cancel_illustration">Figure 7-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="cancel_illustration">&#13;
<img alt="First coroutine" src="assets/pawk_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>First coroutine.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The<a data-primary="delay function" data-type="indexterm" id="idm46669751183472"/> <code>delay</code> function looks suspiciously like <code>Thread.sleep</code> in its usage. The major difference is that <code>delay</code> is <em>nonblocking</em>&#13;
while <code>Thread.sleep(...)</code> is <em>blocking</em>. To demonstrate what we mean, let’s examine our code again, but replace the&#13;
<code>delay</code> call in our coroutine with <code>Thread.sleep</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">job</code><code class="p">:</code> <code class="n">Job</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"I'm working"</code><code class="p">)</code>&#13;
            <code class="n">Thread</code><code class="p">.</code><code class="n">sleep</code><code class="p">(</code><code class="m">10L</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">delay</code><code class="p">(</code><code class="m">30</code><code class="p">)</code>&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">cancel</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Observe what happens when we run the code again. We get the following output:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
I'm working&#13;
.....</pre>&#13;
&#13;
<p>The output seems to run infinitely now. When the coroutine executes, the <code>Thread.sleep(10L)</code> call blocks the&#13;
main thread until the coroutine started by <code>launch</code> completes. As the coroutine started with <code>launch</code> makes the main&#13;
thread either sleep or print, the coroutine never completes, so execution never leaves the coroutine,<sup><a data-type="noteref" href="ch07.html#idm46669751105520" id="idm46669751105520-marker">1</a></sup> as shown in <a data-type="xref" href="#cancel_impossible">Figure 7-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="cancel_impossible">&#13;
<img alt="Never ending program" src="assets/pawk_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Never-ending program.</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s important to remember the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>launch</code> coroutine builder is “fire-and-forget” work—in other words, there is no result to return.</p>&#13;
</li>&#13;
<li>&#13;
<p>Once called, it immediately returns a <code>Job</code> instance, and starts a new coroutine. A <code>Job</code> represents the coroutine itself, like a handle on its lifecycle. The coroutine can be cancelled by calling the <code>cancel</code> method on its <code>Job</code> instance.</p>&#13;
</li>&#13;
<li>&#13;
<p>A coroutine that is started with <code>launch</code> will not return a result, but rather, a reference to the background job.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If, on the other hand, you need to get a result from an asynchronous computation, then you should use the <code>async</code> coroutine&#13;
builder.<a data-startref="ix_ch07-asciidoc1" data-type="indexterm" id="idm46669751093696"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="The async Coroutine Builder" data-type="sect2"><div class="sect2" id="idm46669751275568">&#13;
<h2>The async Coroutine Builder</h2>&#13;
&#13;
<p><a data-primary="async coroutine builder" data-type="indexterm" id="ix_ch07-asciidoc2"/><a data-primary="coroutines" data-secondary="async coroutine builder" data-type="indexterm" id="ix_ch07-asciidoc3"/>The <code>async</code> coroutine builder can be compared to Java’s <code>Future</code>/<code>Promise</code> model to support asynchronous programming:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nf">WorkingClass</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="n">CompletableFuture</code><code class="o">&lt;</code><code class="n">SomeOtherResult</code><code class="o">&gt;</code> <code class="nf">doBothAsync</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="n">somethingAsync</code><code class="o">().</code><code class="na">thenAcceptBoth</code><code class="o">(</code><code class="n">somethingElseAsync</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="n">one</code><code class="o">,</code> <code class="n">two</code> <code class="o">-&gt;</code>&#13;
            <code class="c1">// combine results of both calls here</code>&#13;
        <code class="o">};</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Instead of making a blocking call to get the data, an asynchronous function immediately returns a wrapper&#13;
around the result. Depending on the library you use, this wrapper is called <code>Future</code>, <code>CompletableFuture</code>,&#13;
<code>Promise</code>, etc. This wrapper is like a handle from which you can check if the result is available or not.&#13;
If you wish, you can block a thread until the result is available with the<a data-primary="Future.get()" data-type="indexterm" id="idm46669751063024"/> <code>Future.get()</code> method.</p>&#13;
&#13;
<p>Just like a <code>Future</code>, the <code>async</code> coroutine builder <em>returns a wrapper around a result</em>; and the type of this wrapper&#13;
is <code>Deferred&lt;T&gt;</code> (the generic type is the type of the result), as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">slow</code><code class="p">:</code> <code class="n">Deferred</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code>&#13;
        <code class="k">var</code> <code class="py">result</code> <code class="p">=</code> <code class="m">0</code>&#13;
        <code class="n">delay</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>   <code class="c1">// simulate some slow background work</code>&#13;
        <code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="k">in</code> <code class="m">1.</code><code class="p">.</code><code class="m">10</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">result</code> <code class="p">+=</code> <code class="n">i</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Call complete for slow: $result"</code><code class="p">)</code>&#13;
        <code class="n">result</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">quick</code><code class="p">:</code> <code class="n">Deferred</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code>&#13;
        <code class="n">delay</code><code class="p">(</code><code class="m">100</code><code class="p">)</code>   <code class="c1">// simulate some quick background work</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Call complete for quick: 5"</code><code class="p">)</code>&#13;
        <code class="m">5</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">result</code><code class="p">:</code> <code class="n">Int</code> <code class="p">=</code> <code class="n">quick</code><code class="p">.</code><code class="n">await</code><code class="p">()</code> <code class="p">+</code> <code class="n">slow</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="n">result</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The data types <code>quick</code> and <code>slow</code> are a future result as an implementation of <code>Deferred&lt;Int&gt;</code>, otherwise known as a&#13;
<code>Job</code> with a result. By calling the method <code>await</code> on each <code>Deferred&lt;Int&gt;</code> instance, the program waits for the result&#13;
of each coroutine.</p>&#13;
&#13;
<p>This time, we’ve launched two coroutines using the <code>async</code> coroutine builder. The code itself can give us a good&#13;
guess at what might happen, but let’s run it anyway to see the following output:</p>&#13;
&#13;
<pre data-type="programlisting">Call complete for quick: 5&#13;
Call complete for slow: 55&#13;
60</pre>&#13;
&#13;
<p>The preceding program delays the slow <code>async</code> job delays it by 1,000 ms while the quick <code>async</code> job by 100 ms—the <code>result</code> waits for both&#13;
to complete before printing out the result.</p>&#13;
&#13;
<p>It’s important to remember the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>async</code> coroutine builder is intended for <em>parallel decomposition of work</em>—that is, you <em>explicitly</em> specify&#13;
that some tasks will run concurrently.</p>&#13;
</li>&#13;
<li>&#13;
<p>Once called, an <code>async</code> immediately returns a <code>Deferred</code> instance. <code>Deferred</code> is a specialized <code>Job</code>, with a few extra&#13;
methods like <code>await</code>. It’s a <code>Job</code> with a return value.</p>&#13;
</li>&#13;
<li>&#13;
<p>Very similarly to <code>Future</code>s and <code>Promise</code>s, you invoke the <code>await</code> method on the <code>Deferred</code> instance to get the&#13;
returned value.<sup><a data-type="noteref" href="ch07.html#idm46669750880912" id="idm46669750880912-marker">2</a></sup></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You may have noticed by now that the examples provided with the coroutine builders <code>launch</code> and <code>async</code> are wrapped with a<a data-primary="runBlocking" data-type="indexterm" id="idm46669750878032"/> <code>runBlocking</code> call. We mentioned earlier that <code>runBlocking</code> runs a new coroutine and blocks the current thread until the coroutine work has completed. To better understand the role of <code>runBlocking</code>, we must first give a sneak preview on structured concurrency, a concept which will be explored in detail in the next chapter.<a data-startref="ix_ch07-asciidoc3" data-type="indexterm" id="idm46669750875632"/><a data-startref="ix_ch07-asciidoc2" data-type="indexterm" id="idm46669750874928"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Quick Detour About Structured Concurrency" data-type="sect1"><div class="sect1" id="idm46669751092368">&#13;
<h1>A Quick Detour About Structured Concurrency</h1>&#13;
&#13;
<p><a data-primary="structured concurrency with coroutines" data-type="indexterm" id="ix_ch07-asciidoc4"/>Coroutines aren’t just yet another fancy way to launch background tasks. The coroutines library is built&#13;
around the structured concurrency paradigm. Before going further in your discovery of coroutines, you&#13;
should understand what it is, and the problems the coroutine library aims to solve.</p>&#13;
&#13;
<p>Making development easier is a worthwhile goal. In the case of structured concurrency, it’s almost a happy&#13;
side effect of a response to a more general problem. Consider the simplest construct every developer is&#13;
familiar with: a function.</p>&#13;
&#13;
<p>Functions are predictable in the sense that they are executed from top to bottom. If we put aside the possibility&#13;
that exceptions can be thrown from inside the function,<sup><a data-type="noteref" href="ch07.html#idm46669750870416" id="idm46669750870416-marker">3</a></sup> we know that prior to a function returning a value, execution order is&#13;
serial: each statement executes prior to the next. What if inside the function, your program creates&#13;
and starts another thread? It’s perfectly legal, but now you have two flows of execution, as shown in <a data-type="xref" href="#fig_two_flows">Figure 7-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_two_flows">&#13;
<img alt="Two Flows" src="assets/pawk_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>Two flows.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Calling this function doesn’t only produce one result; it has the side effect of creating a parallel flow of execution. This can be problematic for the following reasons:</p>&#13;
<dl>&#13;
<dt>Exceptions aren’t propagated</dt>&#13;
<dd>&#13;
<p>If an exception is thrown inside the thread, and it isn’t handled, then the JVM calls the thread’s <code>UncaughtExceptionHandler</code>, which is a simple interface:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">UncaughtExceptionHandler</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">uncaughtException</code><code class="p">(</code><code class="n">t</code><code class="p">:</code> <code class="n">Thread</code><code class="p">,</code> <code class="n">e</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can provide a handler using the<a data-primary="Thread.setUncaughtExceptionHandler" data-type="indexterm" id="idm46669750850528"/> <code>Thread.setUncaughtExceptionHandler</code> method on your thread instance. By default, when you create a thread, it doesn’t have a specific <code>UncaughtExceptionHandler</code>. When an exception isn’t caught, <em>and</em> you haven’t set a specific one, the default handler is invoked.</p>&#13;
&#13;
<p>In the Android framework, it’s important to note that the default <code>UncaughtExceptionHandler</code> will cause your app to crash by killing the app’s native process. Android designers made this choice because it’s generally better for an Android application to <em>fail-fast</em>, as the system shouldn’t make decisions on behalf of the developer when it comes to unhandled exceptions. The stacktrace is then relevant to the real&#13;
problem—while recovering from it might produce inconsistent behaviors and problems that are less transparent, because the root cause can be much earlier in the call stack.</p>&#13;
&#13;
<p>In our example, there’s nothing in place to inform our function if something bad happens in the background thread. Sometimes this is just fine because errors can be directly handled from the background thread, but you may have logic that is more complex and requires the calling code to monitor issues to react differently and specifically.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There is a mechanism involved before the default &#13;
<span class="keep-together">handler</span> is invoked. Every thread can belong to a &#13;
<span class="keep-together"><code>ThreadGroup</code></span> which can handle exceptions. Each thread group can also have a parent thread group. Within the Android framework, two groups are statically created: “system,” and a child of the system group known as “main.” The “main” group always delegates exception handling to the “system” group parent, which then delegates to &#13;
<span class="keep-together"><code>Thread.getDefaultUncaughtExceptionHandler()</code></span> if it isn’t null. Otherwise, the “system” group prints the exception name and stacktrace to <code>System.err</code>.</p>&#13;
</div>&#13;
</dd>&#13;
<dt>Execution flow is hard to control</dt>&#13;
<dd>&#13;
<p>Since a thread can be created and started from anywhere, imagine that your background thread instantiates and starts three new threads to delegate some of its work, or performs tasks in reaction to computation performed in the parent thread’s context, as shown in <a data-type="xref" href="#multiple_flows_id">Figure 7-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="multiple_flows_id">&#13;
<img alt="Multiple Flows" src="assets/pawk_0704.png"/>&#13;
<h6><span class="label">Figure 7-4. </span>Multiple flows.</h6>&#13;
</div></figure>&#13;
&#13;
<p>How do you make sure the function returns only when all background processing is done? This can be error-prone: you need to make sure that you wait for all child threads to finish their work.<sup><a data-type="noteref" href="ch07.html#idm46669750810416" id="idm46669750810416-marker">4</a></sup> When using a <code>Future</code>-based implementation (for example, <code>CompletableFuture</code>s), even omitting a <code>Future.get</code> invocation might cause the flow of execution to terminate prematurely.</p>&#13;
&#13;
<p>Later, and while the background thread and all of its children are still running, all this work might have to be cancelled (the user exited the UI, an error was thrown, etc.). In this case, there’s no automatic mechanism to cancel the entire task hierarchy.</p>&#13;
&#13;
<p>When working with threads, it’s really easy to forget about a background task. <em>Structured concurrency is nothing but a concept meant to address this issue</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In the next section, we’ll detail this concept and explain how it relates to coroutines.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Parent-Child Relationship in Structured Concurrency" data-type="sect1"><div class="sect1" id="idm46669750805568">&#13;
<h1>The Parent-Child Relationship in Structured Concurrency</h1>&#13;
&#13;
<p><a data-primary="structured concurrency" data-secondary="parent–child relationship in" data-type="indexterm" id="idm46669750804000"/>Until now, we’ve spoken about threads, which were represented by arrows in the previous illustrations.&#13;
Let’s imagine a higher level of abstraction where some parent entity could create multiple children, as shown in&#13;
<a data-type="xref" href="#fig_parent_child">Figure 7-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_parent_child">&#13;
<img alt="Parent-Child" src="assets/pawk_0705.png"/>&#13;
<h6><span class="label">Figure 7-5. </span>Parent-child.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Those children can run concurrently with each other as well as the parent. If the parent fails or is cancelled, then all&#13;
its children are also cancelled.<sup><a data-type="noteref" href="ch07.html#idm46669750799248" id="idm46669750799248-marker">5</a></sup> Here is the first rule of structured concurrency:</p>&#13;
<ul class="simplelist">&#13;
<li>Cancellation always propagates downward.</li>&#13;
</ul>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>How the failure of one child affects other children of the same level is a parameterization of the parent.</p>&#13;
</div>&#13;
&#13;
<p>Just as a parent entity could fail or be cancelled, this can happen to any of the children.&#13;
In the case of cancellation of one of the children, referencing the first rule, we know that the parent will not be cancelled&#13;
(cancellation propagates downward, not upward). In case of failure, what happens next depends&#13;
on the problem you’re trying to solve. The failure of one child should or should not lead to&#13;
the cancellation of the other children, as shown in <a data-type="xref" href="#fig_cancellation_policy">Figure 7-6</a>. Those two possibilities characterize&#13;
the parent-child failure relationship, and is a parameterization of the parent.</p>&#13;
&#13;
<figure><div class="figure" id="fig_cancellation_policy">&#13;
<img alt="Cancellation policy" src="assets/pawk_0706.png"/>&#13;
<h6><span class="label">Figure 7-6. </span>Cancellation policy.</h6>&#13;
</div></figure>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The parent always waits for all its children to complete.</p>&#13;
</div>&#13;
&#13;
<p>Other rules could be added around exception propagation, but they would be implementation specific,&#13;
and it’s time to introduce some concrete examples.</p>&#13;
&#13;
<p>Structured  concurrency  is  available  in  Kotlin  coroutines  with  <code>CoroutineScope</code>s  and  <code>CoroutineContext</code>s. &#13;
Both  <code>CoroutineScope</code>s  and  <code>CoroutineContext</code>s  play  the  role  of  the parent in previous illustrations, while Coroutines, on play the role of the children.</p>&#13;
&#13;
<p>In the following section, we’ll cover <code>CoroutineScope</code> and <code>CoroutineContext</code> in more detail.<a data-startref="ix_ch07-asciidoc4" data-type="indexterm" id="idm46669750786656"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CoroutineScope and CoroutineContext" data-type="sect1"><div class="sect1" id="idm46669750804944">&#13;
<h1>CoroutineScope and CoroutineContext</h1>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="CoroutineScope and CoroutineContext" data-type="indexterm" id="ix_ch07-asciidoc6"/>We’re about to dive into the details of the<a data-primary="kotlinx.coroutine library" data-type="indexterm" id="idm46669750782048"/> <em>kotlinx.coroutine</em> library. There will be <em>a lot</em> of new concepts in the upcoming section. While those concepts are important if you want to master coroutines, you don’t have to understand everything right now to get started and be productive with coroutines. There will be a lot of examples following this section and in the next chapter, which will give you a good sense of how coroutines work. Therefore, you might find it&#13;
easier to come back to this section after you’ve practiced a bit.</p>&#13;
&#13;
<p>Now that you have an idea of what structured concurrency is, let’s revisit the whole <code>runBlocking</code> thing again.&#13;
Why not just call <code>launch</code> or <code>async</code> outside a <code>runBlocking</code> call?</p>&#13;
&#13;
<p>The following code will not compile:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>&#13;
   <code class="n">launch</code> <code class="p">{</code>&#13;
       <code class="n">println</code><code class="p">(</code><code class="s">"I'm working"</code><code class="p">)</code>       <code class="c1">// will not compile</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The compiler reports: “Unresolved reference: launch.”&#13;
This is because coroutine builders are extension functions of <code>CoroutineScope</code>.</p>&#13;
&#13;
<p>A<a data-primary="CoroutineScope" data-type="indexterm" id="idm46669750766800"/> <code>CoroutineScope</code> controls the lifecycle of a coroutine within a well-defined scope or lifecycle.&#13;
It’s an object that plays the role of the parent in structured concurrency—its purpose is to manage&#13;
and monitor the coroutines you create inside it. You might be surprised to find that in the previous&#13;
example with the <code>async</code> coroutine builder, a <code>CoroutineScope</code> had already been provided to launch&#13;
a new coroutine. That &#13;
<span class="keep-together"><code>CoroutineScope</code></span> was provided by the <code>runBlocking</code> block.&#13;
How? This is the simplified signature of <code>runBlocking</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">runBlocking</code><code class="p">(</code>&#13;
    <code class="c1">// function arguments removed for brevity</code>&#13;
    <code class="n">block</code><code class="p">:</code> <code class="n">suspend</code> <code class="n">CoroutineScope</code><code class="p">.()</code> <code class="p">-&gt;</code> <code class="n">T</code><code class="p">):</code> <code class="n">T</code> <code class="p">{</code> <code class="c1">// impl</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The last argument is a function with a receiver of type <code>CoroutineScope</code>.  Consequently, when you supply a&#13;
function for the block argument, there is a <code>CoroutineScope</code> at your disposal which can invoke extension functions&#13;
of <code>CoroutineScope</code>. As you can see in <a data-type="xref" href="#type_hint_figure_id">Figure 7-7</a>, Android Studio is able to pick up the implicit&#13;
type-referencing in Kotlin so that if you enable “type hints,” you are able to see the type parameter.</p>&#13;
&#13;
<figure><div class="figure" id="type_hint_figure_id">&#13;
<img alt="Type hint in Android Studio" src="assets/pawk_0707.png"/>&#13;
<h6><span class="label">Figure 7-7. </span>Type hint in Android Studio.</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Besides providing a <code>CoroutineScope</code>, what is the purpose of <code>runBlocking</code>? <code>runBlocking</code> blocks the current thread until&#13;
its completion. It can be invoked from regular blocking code as a bridge to code containing suspending functions (we’ll cover suspending functions later in this chapter).</p>&#13;
&#13;
<p>To be able to create coroutines, we have to bridge our code to the “regular” function <code>main</code> in our code.&#13;
However, the following sample won’t compile, as we’re trying to start a coroutine from regular code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"I'm a coroutine"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is because the <code>launch</code> coroutine builder is actually an <em>extension function</em> of &#13;
<span class="keep-together"><code>CoroutineScope</code>:</span></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">launch</code><code class="p">(</code>&#13;
    <code class="n">context</code><code class="p">:</code> <code class="n">CoroutineContext</code> <code class="p">=</code> <code class="n">EmptyCoroutineContext</code><code class="p">,</code>&#13;
    <code class="c1">// other params removed for brevity,</code>&#13;
    <code class="n">block</code><code class="p">:</code> <code class="n">suspend</code> <code class="n">CoroutineScope</code><code class="p">.()</code> <code class="p">-&gt;</code> <code class="n">Unit</code>&#13;
<code class="p">):</code> <code class="n">Job</code> <code class="p">{</code> <code class="cm">/* implementation */</code> <code class="p">}</code></pre>&#13;
&#13;
<p>Since regular code doesn’t provide a <code>CoroutineScope</code> instance, you cannot directly invoke coroutine builders from there.</p>&#13;
&#13;
<p>So what’s this <code>CoroutineContext</code>? To answer this question, you need to understand the details of <code>CoroutineScope</code>.</p>&#13;
&#13;
<p>If you look at the source code, a <code>CoroutineScope</code> is an interface:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">CoroutineScope</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">coroutineContext</code><code class="p">:</code> <code class="n">CoroutineContext</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In other words, a <code>CoroutineScope</code> is a container for a <code>CoroutineContext</code>.</p>&#13;
&#13;
<p>The purpose of a <code>CoroutineScope</code> is to encapsulate concurrent tasks (coroutines and other scopes) by applying&#13;
structured concurrency. Scopes and coroutines form a tree-like architecture with a scope at its root, as shown&#13;
in <a data-type="xref" href="#fig_tree_like_arch">Figure 7-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_tree_like_arch">&#13;
<img alt="Tree-like structure" src="assets/pawk_0708.png"/>&#13;
<h6><span class="label">Figure 7-8. </span>Tree-like relationship (coroutines are represented as rectangles).</h6>&#13;
</div></figure>&#13;
&#13;
<p>A <code>CoroutineContext</code>, which we’ll refer to as a <em>context</em> for future reference, is a broader concept. It’s an immutable&#13;
union set of context elements. For future reference, we’ll use the term “element” to designate <em>context element</em>.</p>&#13;
&#13;
<p>That’s the theory. In practice, you’ll most often use a special context element to control which thread, or which&#13;
thread pool, will execute your coroutine(s). For example, imagine that you have to run CPU-heavy computations inside a&#13;
<code>launch</code>, while not blocking the main thread. This is where the coroutine library is really handy because thread pools&#13;
for most common usages are available out of the box. In the case of CPU-bound tasks, you don’t have to define your own&#13;
thread pool. All you have to do is use the special <code>Dispatchers.Default</code> context element like so:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"I'm executing in ${Thread.currentThread().name}"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output is now:</p>&#13;
&#13;
<pre data-type="programlisting">I'm executing in DefaultDispatcher-worker-2 @coroutine#2</pre>&#13;
&#13;
<p><a data-primary="Dispatchers.Main" data-type="indexterm" id="idm46669750535152"/><code>Dispatchers.Main</code> is a context element. As you’ll see later, different context elements can be combined&#13;
using operators to tweak the behavior of coroutines even more.</p>&#13;
&#13;
<p class="pagebreak-before">As its name suggests, the purpose of a <code>Dispatcher</code> is to dispatch coroutines on a specific thread or&#13;
thread pool. By default, there are four <code>Dispatcher</code>s available out of the box—<code>Main</code>, <code>Default</code>, <code>IO</code>, and <code>Unconfined</code>:</p>&#13;
<dl>&#13;
<dt><code>Dispatchers.Main</code></dt>&#13;
<dd>&#13;
<p>This uses the main thread, or the UI thread, of the platform you’re using.</p>&#13;
</dd>&#13;
<dt><code>Dispatchers.Default</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="Dispatchers.Default" data-type="indexterm" id="idm46669750498912"/>is meant for CPU-bound tasks, and is backed by a thread pool of four threads by default.</p>&#13;
</dd>&#13;
<dt><code>Dispatchers.IO</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="Dispatchers.IO" data-type="indexterm" id="idm46669750496768"/>is meant for IO-bound tasks, and is backed by a thread pool of 64 threads by default.</p>&#13;
</dd>&#13;
<dt><code>Dispatchers.Unconfined</code></dt>&#13;
<dd>&#13;
<p>This isn’t something you should use or even need as you’re learning coroutines. It’s primarily&#13;
used in the internals of the coroutines library.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>By just changing the dispatcher, you can control which thread or thread pool your coroutine will be executed on.&#13;
The context element <code>Dispatcher.Default</code> is a subclass of <code>CoroutineDispatcher</code>, but other context elements&#13;
also exist.</p>&#13;
&#13;
<p>By providing a dispatcher context, you can easily designate where logic flow executes. Thus, it is the developer’s&#13;
responsibility to supply the context to the coroutine builder.</p>&#13;
&#13;
<p>In coroutine framework parlance, a coroutine always runs inside a context. <em>This</em> context is provided by a coroutine scope and is different from the context you supply. To avoid confusion, we’ll call the context of the coroutine the <em>coroutine context</em>, and we’ll call the context you supply to the coroutine builder the <em>supplied context</em>.</p>&#13;
&#13;
<p>The difference is subtle—remember the <code>Job</code> object? A <code>Job</code> instance is a handle on the lifecycle of the&#13;
coroutine—it’s part of the coroutine context too. Every coroutine has a <code>Job</code> instance that represents it,&#13;
and this job is part of the coroutine context.</p>&#13;
&#13;
<p>It’s time to unveil how those contexts are created. Look at <a data-type="xref" href="#listing_runblocking_1">Example 7-1</a>, which differs slightly from the previous example.</p>&#13;
<div data-type="example" id="listing_runblocking_1">&#13;
<h5><span class="label">Example 7-1. </span>Dispatchers example</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Main</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">threadName</code> <code class="p">=</code> <code class="n">Thread</code><code class="p">.</code><code class="n">currentThread</code><code class="p">().</code><code class="n">name</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"I'm executing in $threadName"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>This block of code creates two coroutines with their own respective <code>Job</code> instance: <code>runBlocking</code> starts the first&#13;
coroutine, and the other one is started by <code>launch</code>.</p>&#13;
&#13;
<p>The coroutine created by <code>runBlocking</code> has its own context. Since this is the root coroutine started inside&#13;
the scope, we call this context the <em>scope context</em>. The scope context encompasses the coroutine context, as shown in&#13;
<a data-type="xref" href="#contexts_encapsulation_id">Figure 7-9</a>.</p>&#13;
&#13;
<figure><div class="figure" id="contexts_encapsulation_id">&#13;
<img alt="Contexts" src="assets/pawk_0709.png"/>&#13;
<h6><span class="label">Figure 7-9. </span>Contexts.</h6>&#13;
</div></figure>&#13;
&#13;
<p>You’ve seen that <code>launch</code> is an extension function of <code>CoroutineScope</code> (which holds a context), and that it can receive a context as its first parameter. So there are two contexts at our disposal in this function, as shown in <a data-type="xref" href="#listing_runblocking_1">Example 7-1</a>: one from the receiver type (the scope context), and the other one from the context parameter (the supplied context).</p>&#13;
&#13;
<p>What does <code>launch</code> do in its implementation before calling our provided function? It merges the two contexts so that the&#13;
elements from the context parameter take precedence over the other elements from the scope. From this&#13;
merge operation we obtain the parent context. At this point, the <code>Job</code> of the coroutine isn’t created yet.</p>&#13;
&#13;
<p>At last, a new <code>Job</code> instance is created as a child of the <code>Job</code> from the parent context.&#13;
This new <code>Job</code> is then added to the parent context, replacing the <code>Job</code> instance of the parent context&#13;
to obtain the coroutine context.</p>&#13;
&#13;
<p>These relationships and interactions are represented in <a data-type="xref" href="#context_diagram_id">Figure 7-10</a>, in which a&#13;
 context is represented by a rectangle containing other context elements.</p>&#13;
&#13;
<figure><div class="figure" id="context_diagram_id">&#13;
<img alt="Contexts" src="assets/pawk_0710.png"/>&#13;
<h6><span class="label">Figure 7-10. </span>Representation of a <em>Context</em>.</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#context_diagram_id">Figure 7-10</a> represents a context that contains a <code>Job</code> instance, and a dispatcher which is <code>Dispatchers.Main</code>. With that representation in mind, <a data-type="xref" href="#fig_context_detail">Figure 7-11</a> shows how we would represent the context of <a data-type="xref" href="#listing_runblocking_1">Example 7-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_context_detail">&#13;
<img alt="Context detail" src="assets/pawk_0711.png"/>&#13;
<h6><span class="label">Figure 7-11. </span>Context detail.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Everything you provide in the supplied context to the <code>launch</code> method takes precedence over the scope context. This results in a<a data-primary="parent context" data-type="indexterm" id="idm46669750400352"/> <em>parent context</em>, which inherits elements from the scope context which were not provided in the supplied context (a <code>Job</code>, in this case). Then a new <code>Job</code> instance is created (with a dot in the upper-right corner), as a child of the parent <code>Job</code> which is also, in this case, the <code>Job</code> of the scope context. The resulting coroutine context is made of elements from the parent context except for <code>Job</code> (which is a child <code>Job</code> of the <code>Job</code> in the parent context).</p>&#13;
&#13;
<p>This <em>coroutine context</em> is the context in which the lambda we provide to <code>launch</code> will be executed.</p>&#13;
&#13;
<p>Structured concurrency is possible because the <code>Job</code> in the coroutine context is a child of the <code>Job</code> from the parent context. If the scope is cancelled for any reason, every child coroutine started is then automatically cancelled.<sup><a data-type="noteref" href="ch07.html#idm46669750393056" id="idm46669750393056-marker">6</a></sup></p>&#13;
&#13;
<p>More importantly, the coroutine context inherits context elements from the scope context, which are not overridden by the context supplied as a parameter to launch; the <code>async</code> method behaves identically in this regard.<a data-startref="ix_ch07-asciidoc6" data-type="indexterm" id="idm46669750389696"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Suspending Functions" data-type="sect1"><div class="sect1" id="idm46669750784368">&#13;
<h1>Suspending Functions</h1>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="suspending functions" data-type="indexterm" id="ix_ch07-asciidoc7"/><a data-primary="suspending functions" data-type="indexterm" id="ix_ch07-asciidoc8"/>We’ve examined how to launch a coroutine with the coroutine builders <code>launch</code> and <code>async</code>, and touched on what it means&#13;
for something to be blocking or nonblocking.&#13;
At its core, Kotlin coroutines offer something different that will really reveal how powerful coroutines can be:&#13;
<em>suspending functions</em>.</p>&#13;
&#13;
<p>Imagine that you invoke two tasks serially. The first task completes before the second can proceed with its execution.</p>&#13;
&#13;
<figure><div class="figure">&#13;
<img alt="Contexts" src="assets/pawk_07in01.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>When task A executes, the underlying thread cannot proceed with executing other tasks—task A is then said to be a&#13;
<em>blocking call</em>.</p>&#13;
&#13;
<p>However, task A spending a reasonable amount of time waiting for a longer-running job (e.g., an HTTP request) ends up&#13;
blocking the underlying thread, rendering the waiting task B useless.</p>&#13;
&#13;
<p>So task B waits for task A to complete. The frugal developer may see this scenario as a waste of thread resources,&#13;
since the thread could (and should) proceed with executing another task while task A is waiting for the result of&#13;
its network call.</p>&#13;
&#13;
<p>Using suspending functions, we can split tasks into chunks which can <em>suspend</em>. In the case of our example, task A can be&#13;
suspended when it performs its remote call, leaving the underlying thread free to proceed with another task (or just a part&#13;
of it). When task A gets the result of its remote call, it can be resumed at a later point in time, as shown in <a data-type="xref" href="#figure7_12">Figure 7-12</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure7_12">&#13;
<img alt="Contexts" src="assets/pawk_0712.png"/>&#13;
<h6><span class="label">Figure 7-12. </span>The time saved is represented at the end.</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see, the two tasks complete sooner than in the previous scenario. This interleaving of bits of tasks&#13;
leaves the underlying thread always busy executing a task. Therefore, a suspending mechanism requires fewer threads&#13;
to produce the same overall throughput, and this is quite important, when each thread has its own stack which costs a&#13;
minimum of 64 Kb of memory. Typically, a thread occupies 1 MB of RAM.</p>&#13;
&#13;
<p>Using a suspending mechanism, we can be more frugal by using more of the same resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Suspending Functions Under the Hood" data-type="sect1"><div class="sect1" id="idm46669750783776">&#13;
<h1>Suspending Functions Under the Hood</h1>&#13;
&#13;
<p><a data-primary="suspending functions" data-secondary="lower-level constructs of" data-type="indexterm" id="ix_ch07-asciidoc10"/>So far, we’ve introduced a new concept: the fact that a task can <em>suspend</em>. A task can “pause” its execution without&#13;
blocking the underlying thread. While this might sound like magic to you, it’s important to understand that it all comes&#13;
down to lower-level constructs, which we’ll explain in this section.</p>&#13;
&#13;
<p>A task, or more precisely, a coroutine, can suspend if it makes use of at least one <em>suspending function</em>.&#13;
A suspending function is easily recognizable as it’s declared with the <code>suspend</code> modifier.</p>&#13;
&#13;
<p>When the Kotlin compiler encounters a suspending function, it compiles to a regular function with an additional&#13;
parameter of type <code>Continuation&lt;T&gt;</code>, which is just an interface, as shown in <a data-type="xref" href="#contd">Example 7-2</a>:</p>&#13;
<div data-type="example" id="contd">&#13;
<h5><span class="label">Example 7-2. </span>Interface <code>Continuation&lt;T&gt;</code></h5>&#13;
&#13;
<pre data-type="programlisting">public interface Continuation&lt;in T&gt; {&#13;
    /**&#13;
     * The context of the coroutine that corresponds to this continuation.&#13;
     */&#13;
    public val context: CoroutineContext&#13;
&#13;
    /**&#13;
     * Resumes the execution of the corresponding coroutine passing a successful&#13;
     * or failed [result] as the return value of the last suspension point.&#13;
     */&#13;
    public fun resumeWith(result: Result&lt;T&gt;)&#13;
}</pre></div>&#13;
&#13;
<p>Assuming that you define this suspending function as follows:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">backgroundWork</code><code class="p">():</code> <code class="n">Int</code> <code class="p">{</code>&#13;
    <code class="c1">// some background work on another thread, which returns an Int</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>At compile time, this function is transformed into a regular function (without the <code>suspend</code> modifier), with an&#13;
additional <code>Continuation</code> argument:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">backgroundWork</code><code class="p">(</code><code class="n">callback</code><code class="p">:</code> <code class="n">Continuation</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;):</code> <code class="n">Int</code> <code class="p">{</code>&#13;
    <code class="c1">// some background work on another thread, which returns an Int</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Suspending functions are compiled to regular functions taking an additional <code>Continuation</code> object argument. This is an&#13;
implementation of<a data-primary="Continuation Passing Style (CPS)" data-type="indexterm" id="idm46669750317600"/><a data-primary="CPS (Continuation Passing Style)" data-type="indexterm" id="idm46669750316896"/> <em>Continuation Passing Style</em> (CPS), a style of programming where control flow is passed on in the form of a <code>Continuation</code> object.</p>&#13;
</div>&#13;
&#13;
<p>This <code>Continuation</code> object holds all the code that should be executed in the body of the <code>backgroundWork</code> function.</p>&#13;
&#13;
<p>What does the Kotlin compiler actually generate for this <code>Continuation</code> object?</p>&#13;
&#13;
<p>For efficiency reasons, the Kotlin compiler generates a state machine.<sup><a data-type="noteref" href="ch07.html#idm46669750312528" id="idm46669750312528-marker">7</a></sup> A state-machine implementation&#13;
is all about allocating as few objects as possible, because coroutines being lightweight, thousands of them might be&#13;
running.</p>&#13;
&#13;
<p>Inside this state machine, each state corresponds to a <em>suspension point</em> inside the body of the suspending function.&#13;
Let’s look at an example. Imagine that in an Android project, we use the presenter layer to execute some long-running&#13;
processes surrounding IO and graphics processing, where the following code block has two suspension points with the&#13;
self-managed coroutine launched from the<a data-primary="viewModelScope" data-type="indexterm" id="idm46669750310384"/> <code>viewModelScope</code>:<sup><a data-type="noteref" href="ch07.html#idm46669750309136" id="idm46669750309136-marker">8</a></sup></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">renderImage</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">path</code><code class="p">:</code> <code class="n">String</code> <code class="p">=</code> <code class="n">getPath</code><code class="p">()</code>&#13;
    <code class="k">val</code> <code class="py">image</code> <code class="p">=</code> <code class="n">fetchImage</code><code class="p">(</code><code class="n">path</code><code class="p">)</code>    <code class="c1">// first suspension point (fetchImage is a suspending function)</code>&#13;
    <code class="k">val</code> <code class="py">clipped</code> <code class="p">=</code> <code class="n">clipImage</code><code class="p">(</code><code class="n">image</code><code class="p">)</code>  <code class="c1">// second suspension point (clipImage is a suspending function)</code>&#13;
    <code class="n">postProcess</code><code class="p">(</code><code class="n">clipped</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="cm">/** Here is an example of usage of the [renderImage] suspending function */</code>&#13;
<code class="k">fun</code> <code class="nf">onStart</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">viewModelScope</code><code class="p">.</code><code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">renderImage</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The compiler generates an anonymous class which implements the <code>Continuation</code> interface. To give you a sense of what is&#13;
actually generated, we’ll provide pseudocode of what is generated for the <code>renderImage</code> suspending function.&#13;
The class has a <code>state</code> field holding the current state of the state machine. It also has fields for each variable that are shared between states:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">object</code> <code class="err">: </code><code class="nc">Continuation</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code>  <code class="p">{</code>&#13;
   <code class="c1">// state</code>&#13;
   <code class="k">private</code> <code class="k">var</code> <code class="py">state</code> <code class="p">=</code> <code class="m">0</code>&#13;
&#13;
   <code class="c1">// fields</code>&#13;
   <code class="k">private</code> <code class="k">var</code> <code class="py">path</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
   <code class="k">private</code> <code class="k">var</code> <code class="py">image</code><code class="p">:</code> <code class="n">Image</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
&#13;
   <code class="k">fun</code> <code class="nf">resumeWith</code><code class="p">(</code><code class="n">result</code><code class="p">:</code> <code class="n">Any</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">when</code> <code class="p">(</code><code class="n">state</code><code class="p">)</code> <code class="p">{</code>&#13;
         <code class="m">0</code> <code class="p">-&gt;</code> <code class="p">{</code>&#13;
            <code class="n">path</code> <code class="p">=</code> <code class="n">getPath</code><code class="p">()</code>&#13;
            <code class="n">state</code> <code class="p">=</code> <code class="m">1</code>&#13;
            <code class="c1">// Pass this state machine as Continuation.</code>&#13;
            <code class="k">val</code> <code class="py">firstResult</code> <code class="p">=</code> <code class="n">fetchImage</code><code class="p">(</code><code class="n">path</code><code class="p">,</code> <code class="k">this</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="p">(</code><code class="n">firstResult</code> <code class="p">==</code> <code class="n">COROUTINE_SUSPENDED</code><code class="p">)</code> <code class="k">return</code>&#13;
            <code class="c1">// If we didn't get COROUTINE_SUSPENDED, we received an</code>&#13;
            <code class="c1">// actual Image instance, execution shall proceed to</code>&#13;
            <code class="c1">// the next state.</code>&#13;
            <code class="n">resumeWith</code><code class="p">(</code><code class="n">firstResult</code><code class="p">)</code>&#13;
         <code class="p">}</code>&#13;
         <code class="m">1</code> <code class="p">-&gt;</code> <code class="p">{</code>&#13;
            <code class="n">image</code> <code class="p">=</code> <code class="n">result</code> <code class="k">as</code> <code class="n">Image</code>&#13;
            <code class="n">state</code> <code class="p">=</code> <code class="m">2</code>&#13;
            <code class="k">val</code> <code class="py">secondResult</code> <code class="p">=</code> <code class="n">clipImage</code><code class="p">(</code><code class="n">image</code><code class="p">,</code> <code class="k">this</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="p">(</code><code class="n">secondResult</code> <code class="p">==</code> <code class="n">COROUTINE_SUSPENDED</code><code class="p">)</code> <code class="k">return</code>&#13;
               <code class="n">resumeWith</code><code class="p">(</code><code class="n">secondResult</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
         <code class="m">2</code> <code class="p">-&gt;</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">clipped</code> <code class="p">=</code> <code class="n">result</code> <code class="k">as</code> <code class="n">Image</code>&#13;
            <code class="n">postProcess</code><code class="p">(</code><code class="n">clipped</code><code class="p">)</code>&#13;
         <code class="p">}</code>&#13;
         <code class="k">else</code> <code class="p">-&gt;</code> <code class="k">throw</code> <code class="n">IllegalStateException</code><code class="p">()</code>&#13;
      <code class="p">}</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This state machine is initialized with <code>state = 0</code>. Consequently, when the coroutine started with <code>launch</code> invokes the&#13;
<code>renderImage</code> suspending function, the execution “jumps” to the first case <code>(0)</code>. We retrieve a path, set the next state to&#13;
<code>1</code>, then invoke<a data-primary="fetchImage" data-type="indexterm" id="idm46669749993184"/> <code>fetchImage</code>—which is the first suspending function in the body of <code>renderImage</code>.</p>&#13;
&#13;
<p class="pagebreak-before">At this stage, there are two possible scenarios:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>fetchImage</code> requires some time to return an <code>Image</code> instance, and immediately returns the <code>COROUTINE_SUSPENDED</code> value. By returning this specific value, <code>fetchImage</code> basically says: “I need more time to return&#13;
an actual value, so give me your state-machine object, and I’ll use it when I have a result.” When <code>fetchImage</code> finally has an <code>Image</code> instance, it invokes &#13;
<span class="keep-together"><code>stateMachine.resumeWith(image)</code>.</span> Since at this point <code>state</code> equals <code>1</code>, the execution “jumps” to the second case of the <code>when</code> statement.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>fetchImage</code> immediately returns an <code>Image</code> instance. In this case, execution proceeds with the next state (via <code>resumeWith(image)</code>).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The rest of the execution follows the same pattern, until the code of the last state invokes the <code>postProcess</code> function.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This explanation is not the exact state of the state machine generated in the bytecode, but rather, pseudocode of&#13;
its representative logic to convey the main idea. For everyday use, it’s less important to know the implementation details of the actual finite state machine generated in the Kotlin bytecode than it is to understand what happens under the hood.</p>&#13;
&#13;
<p>Conceptually, when you invoke a suspending function, a callback (<code>Continuation</code>) is created along with generated&#13;
structures so that the rest of the code after the suspending function will be called only when the suspending function&#13;
returns.&#13;
With less time spent on boilerplate code, you can focus on business logic and high-level concepts.</p>&#13;
</div>&#13;
&#13;
<p>So far, we’ve analyzed how the Kotlin compiler restructures our code under the hood, in such a way that we don’t have to&#13;
write callbacks on our own. Of course, you don’t have to be fully aware of finite state-machine code generation to use&#13;
suspending functions. However, the concept is important to grasp! For this purpose, nothing is better than practicing<a data-startref="ix_ch07-asciidoc10" data-type="indexterm" id="idm46669749977952"/>!<a data-startref="ix_ch07-asciidoc8" data-type="indexterm" id="idm46669749977120"/><a data-startref="ix_ch07-asciidoc7" data-type="indexterm" id="idm46669749976416"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Using Coroutines and Suspending Functions: &#10;A Practical Example" data-type="sect1"><div class="sect1" id="idm46669750373824">&#13;
<h1>Using Coroutines and Suspending Functions: &#13;
<span class="keep-together">A Practical Example</span></h1>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="example" data-type="indexterm" id="ix_ch07-asciidoc11"/><a data-primary="suspending functions" data-secondary="example" data-type="indexterm" id="ix_ch07-asciidoc12"/>Imagine that in an Android application you wish to load a user’s profile with an <code>id</code>. When navigating to the profile,&#13;
it might make sense to fetch the user’s data based on the <code>id</code> in a method named <code>fetchAndLoadProfile</code>.</p>&#13;
&#13;
<p>You can use coroutines for that, using what you learned in the previous section. &#13;
<span class="keep-together">For  now,</span>  assume  that  somewhere  in  your  app  (typically  a  controller  in  MVC  architecture, or a <code>ViewModel</code> in MVVM) you have a <code>CoroutineScope</code> which has the &#13;
<span class="keep-together"><code>Dispatchers.Main</code></span> dispatcher in its <code>CoroutineContext</code>. In this case, we say that this scope dispatches coroutines on the main thread, which is identical to default behavior. In the next chapters we will give you detailed explanations and examples of &#13;
<span class="keep-together">coroutine</span> scopes, and how you can access and create them yourself if you need to.</p>&#13;
&#13;
<p>The fact that scope defaults to the main thread isn’t limiting in any way, since you can create coroutines with any&#13;
<code>CoroutineDispatcher</code> you want inside this scope. This implementation of <code>fetchAndLoadProfile</code> illustrates this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">fetchAndLoadProfile</code><code class="p">(</code><code class="n">id</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="n">scope</code><code class="p">.</code><code class="n">launch</code><code> </code><code class="p">{</code><code>                                          </code><a class="co" href="#callout_coroutines_concepts_CO1-1" id="co_coroutines_concepts_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="k">val</code><code> </code><code class="py">profileDeferred</code><code> </code><code class="p">=</code><code> </code><code class="n">async</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code><code> </code><code class="p">{</code><code>  </code><a class="co" href="#callout_coroutines_concepts_CO1-2" id="co_coroutines_concepts_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>            </code><code class="n">fetchProfile</code><code class="p">(</code><code class="n">id</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="k">val</code><code> </code><code class="py">profile</code><code> </code><code class="p">=</code><code> </code><code class="n">profileDeferred</code><code class="p">.</code><code class="n">await</code><code class="p">(</code><code class="p">)</code><code>               </code><a class="co" href="#callout_coroutines_concepts_CO1-3" id="co_coroutines_concepts_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>        </code><code class="n">loadProfile</code><code class="p">(</code><code class="n">profile</code><code class="p">)</code><code>                                </code><a class="co" href="#callout_coroutines_concepts_CO1-4" id="co_coroutines_concepts_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>This is done in four steps:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_coroutines_concepts_CO1-1" id="callout_coroutines_concepts_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Start with a <code>launch</code>. You want the <code>fetchAndLoadProfile</code> to return immediately so that you can proceed serially on the&#13;
main thread. Since the scope defaults to the main thread, a launch without additional context inherits the scope’s&#13;
context, so it runs on the main thread.</p></dd>&#13;
<dt><a class="co" href="#co_coroutines_concepts_CO1-2" id="callout_coroutines_concepts_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Using<a data-primary="async" data-type="indexterm" id="idm46669749899888"/> <code>async</code> and<a data-primary="Dispatchers.Default" data-type="indexterm" id="idm46669749898288"/> <code>Dispatchers.Default</code>, you call <code>fetchProfile</code>, which is a blocking call. As a reminder, using&#13;
<code>Dispatchers.Default</code> results in having <code>fetchProfile</code> executed on a thread pool. You immediately get a&#13;
<code>Deferred&lt;Profile&gt;</code>, which you name <code>profileDeferred</code>. At this point, ongoing background work is being done on one&#13;
of the threads of the thread pool. This is the signature of <code>fetchProfile</code>:&#13;
<code>fun fetchProfile(id: String): Profile { // impl }</code>.&#13;
It’s a blocking call which might perform a database query on a remote server.</p></dd>&#13;
<dt><a class="co" href="#co_coroutines_concepts_CO1-3" id="callout_coroutines_concepts_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>You cannot use <code>profileDeferred</code> right away to load the profile—you need &#13;
<span class="keep-together">to wait for the</span> result of the background&#13;
query. You do this by  using<a data-primary="profileDeferred.await" data-type="indexterm" id="idm46669749854816"/> &#13;
<span class="keep-together"><code>profileDeferred.await()</code></span>, which will generate and return a <code>Profile</code> instance.</p></dd>&#13;
<dt><a class="co" href="#co_coroutines_concepts_CO1-4" id="callout_coroutines_concepts_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Finally, you can invoke <code>loadProfile</code> using the obtained profile. As the outer launch inherits its context from the&#13;
parent scope, <code>loadProfile</code> is invoked on the main thread. We’re assuming that this is expected, as most UI-related&#13;
operations have to be done on the main thread.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Whenever you invoke <code>fetchAndLoadProfile</code>, background processing is done off the UI thread to retrieve a profile. As soon&#13;
as the profile is available, the UI is updated. You can invoke <code>fetchAndLoadProfile</code> from whatever thread you want—it&#13;
won’t change the fact that <code>loadProfile</code> is eventually called on the UI thread.</p>&#13;
&#13;
<p>Not bad, but we can do better.</p>&#13;
&#13;
<p>Notice how this code reads from top to bottom, without indirection or callbacks. You could argue that the&#13;
“profileDeferred” naming and the <code>await</code> calls feel clunky. This could be even more apparent when you fetch a profile,&#13;
wait for it, then load it. This is where suspending functions come into play.</p>&#13;
&#13;
<p>Suspending functions are at the heart of the coroutine framework.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Conceptually, a suspending function is a function which may not return immediately. If it doesn’t&#13;
return right away, it suspends the coroutine that called this suspending function while computation&#13;
occurs. This inner computation <em>should not block</em> the calling thread. Later, the coroutine is resumed&#13;
when the inner computation &#13;
<span class="keep-together">completes.</span></p>&#13;
&#13;
<p>A suspending function can only be called from inside a coroutine or from another suspending function.</p>&#13;
</div>&#13;
&#13;
<p>By “suspend the coroutine,” we mean that the coroutine execution is stopped. Here is an example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">backgroundWork</code><code class="p">():</code> <code class="n">Int</code> <code class="p">{</code>&#13;
    <code class="c1">// some background work on another thread, which returns an Int</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First off, a suspending function isn’t a regular function; it has its own <code>suspend</code> keyword.&#13;
It can have a return type, but notice that in this case it doesn’t return a <code>Deferred&lt;Int&gt;</code>—only bare&#13;
<code>Int</code>.</p>&#13;
&#13;
<p>Second, it can only be invoked from a coroutine, or another suspending function.</p>&#13;
&#13;
<p>Back to our previous example: fetching and waiting for a profile was done with an <code>async</code> block.&#13;
Conceptually, this is exactly the purpose of a suspending function. We’ll borrow the same name as the&#13;
blocking <code>fetchProfile</code> function and rewrite it like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">fetchProfile</code><code class="p">(</code><code class="n">id</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">Profile</code> <code class="p">{</code>&#13;
    <code class="c1">// for now, we’re not showing the implementation</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The two major differences with the original <code>async</code> block are the <code>suspend</code> modifier and the return type.</p>&#13;
&#13;
<p>This allows you to simplify <code>fetchAndLoadProfile</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">fetchAndLoadProfile</code><code class="p">(</code><code class="n">id</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">profile</code> <code class="p">=</code> <code class="n">fetchProfile</code><code class="p">(</code><code class="n">id</code><code class="p">)</code>   <code class="c1">// suspends</code>&#13;
        <code class="n">loadProfile</code><code class="p">(</code><code class="n">profile</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now that <code>fetchProfile</code> is a suspending function, the coroutine started by <code>launch</code> is suspended when invoking <code>fetchProfile</code>.&#13;
Suspended means that the execution of the coroutine is stopped, and that the next line does not execute.&#13;
It will remain suspended until the profile is retrieved, at which point the coroutine started&#13;
by <code>launch</code> resumes. The next line (<code>loadProfile</code>) is then executed.</p>&#13;
&#13;
<p>Notice how this reads like procedural code. Imagine how you would implement complex, asynchronous logic where each&#13;
step requires a result from the previous one. You would call suspending functions like this, one after another, in a&#13;
classic procedural style. Code that is easy to understand is more maintainable. This is one of the most immediately&#13;
helpful aspects of suspending functions.</p>&#13;
&#13;
<p>As a bonus, IntelliJ IDEA and Android Studio help you in spotting suspending calls in one glimpse. In <a data-type="xref" href="#figure7_13">Figure 7-13</a>,&#13;
you can see a symbol in the margin indicating a suspending call.</p>&#13;
&#13;
<figure><div class="figure" id="figure7_13">&#13;
<img alt="suspend call" src="assets/pawk_0713.png"/>&#13;
<h6><span class="label">Figure 7-13. </span>Suspending call.</h6>&#13;
</div></figure>&#13;
&#13;
<p>When you see this symbol in the margin, you know that a coroutine can temporarily suspend at this line.<a data-startref="ix_ch07-asciidoc12" data-type="indexterm" id="idm46669749711184"/><a data-startref="ix_ch07-asciidoc11" data-type="indexterm" id="idm46669749710576"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t Be Mistaken About the suspend Modifier" data-type="sect1"><div class="sect1" id="idm46669749974832">&#13;
<h1>Don’t Be Mistaken About the suspend Modifier</h1>&#13;
&#13;
<p>However impressive it looks, adding the <code>suspend</code> modifier to a regular function doesn’t magically turn it into a&#13;
nonblocking function.&#13;
There’s more to it. Here is an example with the suspending<a data-primary="fetchProfile" data-type="indexterm" id="idm46669749708368"/> <code>fetchProfile</code> function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">fetchProfile</code><code class="p">(</code><code class="n">id</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="c1">// same implementation as the original fetchProfile, which returns a Profile instance</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>fetchProfile(...)</code> uses the <code>withContext</code> function from the coroutines framework, which accepts a <code>CoroutineContext</code>&#13;
as parameter.&#13;
In this case, we provide <code>Dispatchers.Default</code> as the context.&#13;
Almost every single time you use <code>withContext</code>, you’ll only provide a <code>Dispatcher</code>.</p>&#13;
&#13;
<p>The thread that will execute the body of <code>withContext</code> is determined by the provided <code>Dispatcher</code>. For example, using&#13;
<code>Dispatchers.Default</code>, it would be one of the threads of the thread pool dedicated for CPU-bound tasks. In the case of&#13;
<code>Dispatchers.Main</code>, it would be the main thread.</p>&#13;
&#13;
<p>Why and how does <code>fetchProfile</code> suspend?&#13;
This is an implementation detail of <code>withContext</code> and of the coroutine framework in general.</p>&#13;
&#13;
<p>The most important concept to remember is simple: a coroutine calling a suspending function <em>might</em> suspend its&#13;
execution. In coroutine parlance, we say that it reaches a suspension point.</p>&#13;
&#13;
<p>Why did we say that it <em>might</em> suspend? Imagine that inside your implementation of <code>fetchProfile</code>,&#13;
you check whether you have the associated profile in the cache.&#13;
If you have the data in the cache, you may immediately return it.  Then there’s no need to suspend the&#13;
execution of the outer coroutine.<sup><a data-type="noteref" href="ch07.html#idm46669749681488" id="idm46669749681488-marker">9</a></sup></p>&#13;
&#13;
<p>There are several ways to create a suspending function. Using <code>withContext</code> is only one of them, although&#13;
probably the most common.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669749653440">&#13;
<h1>Summary</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Coroutines are always launched from a <code>CoroutineScope</code>. In structured concurrency parlance, the <code>CoroutineScope</code> is&#13;
the parent, and coroutines themselves are children of that scope. A <code>CoroutineScope</code> can be a child of an existing&#13;
<code>CoroutineScope</code>. See the next chapter on how to get a <code>CoroutineScope</code> or make one.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>CoroutineScope</code> can be seen as a root coroutine. In fact, anything that has a <code>Job</code> can technically be considered&#13;
a coroutine. The only difference is the intended usage. A scope is meant to encompass its child coroutines.&#13;
As you’ve seen in the beginning of this chapter, a cancellation of a scope results in the cancellation of all of its&#13;
child coroutines.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>launch</code> is a coroutine builder which returns a <code>Job</code> instance. It is meant for “fire-and-forget.”</p>&#13;
</li>&#13;
<li>&#13;
<p><code>async</code> is a coroutine builder which can return values, very much like <code>Promise</code> and <code>Future</code>. It returns an instance&#13;
of <code>Deferred&lt;T&gt;</code>, which is a specialized <code>Job</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>Job</code> is a handle on the lifecycle of a coroutine.</p>&#13;
</li>&#13;
<li>&#13;
<p>The context of a newly created coroutine started with <code>launch</code> or <code>async</code>, the coroutine context, inherits from the&#13;
scope context and from the context passed in as a parameter (the supplied context)—the latter taking precedence&#13;
over the former. One context element is always freshly created: the <code>Job</code> of the coroutine. For example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Main</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="n">async</code> <code class="p">{</code>&#13;
      <code class="c1">// inherits the context of the parent, so is dispatched on</code>&#13;
      <code class="c1">// the main thread</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>A suspending function denotes a function which might not return immediately. Using <code>withContext</code> and the appropriate&#13;
<code>Dispatcher</code>, any blocking function can be turned into a nonblocking suspending function.</p>&#13;
</li>&#13;
<li>&#13;
<p>A coroutine is typically made of several calls to suspending functions. Every time a suspending function is invoked, a&#13;
suspension point is reached. The execution of the coroutine is stopped at each of those suspension points, until it&#13;
is resumed.<sup><a data-type="noteref" href="ch07.html#idm46669749624320" id="idm46669749624320-marker">10</a></sup></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A final word on this chapter: <em>scope</em> and <em>context</em> are new notions and are just parts of the coroutine machinery.&#13;
Other topics like <em>exception handling</em> and <em>cooperative cancellation</em> will be covered in the next chapter.<a data-startref="ix_ch07-asciidoc0" data-type="indexterm" id="idm46669749621392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669751105520"><sup><a href="ch07.html#idm46669751105520-marker">1</a></sup> In this scenario, <code>job.cancel()</code> has no effect on the coroutine started by <code>launch</code>. We’ll touch on that in the next chapter (a coroutine must be cooperative with cancellation to be cancellable).</p><p data-type="footnote" id="idm46669750880912"><sup><a href="ch07.html#idm46669750880912-marker">2</a></sup> This suspends the calling coroutine until the value is retrieved, or an exception is thrown if the coroutine started with <code>async</code> is cancelled or failed with an exception. More on that later in this chapter.</p><p data-type="footnote" id="idm46669750870416"><sup><a href="ch07.html#idm46669750870416-marker">3</a></sup> We assume that exceptions are handled and don’t interfere with the execution flow.</p><p data-type="footnote" id="idm46669750810416"><sup><a href="ch07.html#idm46669750810416-marker">4</a></sup> The <code>join()</code> method of a thread causes the calling thread to go into a waiting state. It remains in a waiting state until the original thread terminates.</p><p data-type="footnote" id="idm46669750799248"><sup><a href="ch07.html#idm46669750799248-marker">5</a></sup> A failure of an entity corresponds to any abnormal event the entity cannot recover from. This is typically implemented using unhandled or thrown exceptions.</p><p data-type="footnote" id="idm46669750393056"><sup><a href="ch07.html#idm46669750393056-marker">6</a></sup> You may have noticed that nothing prevents you from passing a <code>Job</code> instance inside the “provided context.” What happens then? Following the logic explained, this <code>Job</code> instance becomes the parent of the <code>Job</code> of the coroutine context (e.g., the newly created coroutine). So the scope is no longer the parent of the coroutine; the parent-child relationship is broken. This is the reason why doing this is strongly discouraged, except in specific scenarios which will be explained in the next chapter.</p><p data-type="footnote" id="idm46669750312528"><sup><a href="ch07.html#idm46669750312528-marker">7</a></sup> Actually, when a suspending function only invokes a single suspending function as a tail call, a state machine isn’t required.</p><p data-type="footnote" id="idm46669750309136"><sup><a href="ch07.html#idm46669750309136-marker">8</a></sup> <code>viewModelScope</code> is coming from the AndroidX implementation of <code>ViewModel</code>. A <code>viewModelScope</code> is scoped to the <code>ViewModel</code> lifetime. More on that in the next chapter.</p><p data-type="footnote" id="idm46669749681488"><sup><a href="ch07.html#idm46669749681488-marker">9</a></sup> We’ll show you how to do this in <a data-type="xref" href="ch08.html#coroutines_in_practice_id">Chapter 8</a>.</p><p data-type="footnote" id="idm46669749624320"><sup><a href="ch07.html#idm46669749624320-marker">10</a></sup> The coroutine mechanism resumes a coroutine when the suspending function which caused it to suspend exits.</p></div></div></section></body></html>