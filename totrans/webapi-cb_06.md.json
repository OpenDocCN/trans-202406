["```\n/**\n * Observes an image element for lazy loading\n *\n * @param img A reference to the image DOM node\n * @param url The URL of the image to load\n */\nfunction lazyLoad(img, url) {\n  const observer = new IntersectionObserver(entries => {\n    // isIntersecting becomes true once the image enters the viewport.\n    // At that point, set the src URL and stop listening.\n    if (entries[0].isIntersecting) {\n      img.src = url;\n      observer.disconnect();\n    }\n  });\n\n  // Start observing the image element.\n  observer.observe(img);\n}\n```", "```\n/**\n * Returns a Promise that is resolved once the given element enters the viewport\n */\nfunction waitForElement(element) {\n  return new Promise(resolve => {\n    const observer = new IntersectionObserver(entries => {\n      if (entries[0].isIntersecting) {\n        observer.disconnect();\n        resolve();\n      }\n    });\n\n    observer.observe(element);\n  });\n}\n```", "```\nfunction lazyLoad(img, url) {\n  waitForElement(img)\n    .then(() => img.src = url)\n}\n```", "```\nconst observer = new IntersectionObserver(entries => {\n  if (!entries[0].isIntersecting) {\n    video.pause();\n  } else {\n    video.play()\n      .catch(error => {\n        // In case of a permission error autoplaying the video.\n        // This avoids an unhandled rejection error that could crash your app.\n      });\n  }\n});\n\nobserver.observe(video);\n```", "```\n/**\n * Watches an element for changes to its children. When the height changes\n * due to child changes, animate the change.\n * @param element The element to watch for changes\n */\nfunction animateHeightChanges(element) {\n  // You can't animate an element with 'height: auto', so an explicit\n  // height is needed here.\n  element.style.height = `${details.offsetHeight}px`;\n\n  // Set a few CSS properties needed for the animated transition.\n  element.style.transition = 'height 200ms';\n  element.style.overflow = 'hidden';\n\n  /**\n * This observer will fire when the element's child elements\n * change. It measures the new height, then uses requestAnimationFrame\n * to update the height. The height change will be animated.\n */\n  const observer = new MutationObserver(entries => {\n    // entries is always an array. There may be times where this array has multiple\n    // elements, but in this case, the first and only element is what you need.\n    const element = entries[0].target;\n\n    // The content has changed, and so has the height.\n    // There are a few steps to measure the new explicit height.\n\n    // (1) Remember the current height to use for the animation's starting point.\n    const currentHeightValue = element.style.height;\n\n    // (2) Set the height to 'auto' and read the offsetHeight property.\n    // This is the new height to set.\n    element.style.height = 'auto';\n    const newHeight = element.offsetHeight;\n\n    // (3) Set the current height back before animating.\n    element.style.height = currentHeightValue;\n\n    // On the next animation frame, change the height. This will\n    // trigger the animated transition.\n    requestAnimationFrame(() => {\n      element.style.height = `${newHeight}px`;\n    });\n  });\n\n  // Begin watching the element for changes.\n  observer.observe(element, { childList: true });\n}\n```", "```\n// Look up the element you want to observe.\nconst container = document.querySelector('#resize-container');\n\n// Create a ResizeObserver that will watch the element for size changes.\nconst observer = new ResizeObserver(entries => {\n  // The observer fires immediately, so you can set the initial text.\n  // There's typically only going to be one entry in the arrayâ€”the first element is\n  // the element you're interested in.\n  container.textContent = `My width is ${entries[0].contentRect.width}px`;\n});\n\n// Start watching the element.\nobserver.observe(container);\n```", "```\nconst observer = new IntersectionObserver(entries => {\n  // There are multiple images per row, so there are multiple\n  // entries.\n  entries.forEach(entry => {\n    // Once the element becomes partially visible, apply the animated transition,\n    if (entry.isIntersecting) {\n      // The image is 25% visible, begin the fade-in transition.\n      entry.target.style.opacity = 1;\n\n      // No need to observe this element any further.\n      observer.unobserve(entry.target);\n    }\n  });\n}, { threshold: 0.25 }); // Fires when images become 25% visible\n\n// Observe all images on the page. Only images with the 'animate'\n// class name will be observed, since you might not want to do this to\n// all images on the page.\ndocument.querySelectorAll('img.animate').forEach(image => {\n  observer.observe(image);\n});\n```", "```\nimg.animate {\n  opacity: 0;\n  transition: opacity 500ms;\n}\n```", "```\n/**\n * Observes a placeholder element with an IntersectionObserver.\n * When the placeholder becomes visible, more data is loaded.\n *\n * @param placeholder The Load More placeholder element\n * @param loadMore A function that loads more data\n */\nfunction observeForInfiniteScroll(placeholder, loadMore) {\n  const observer = new IntersectionObserver(entries => {\n    // If the placeholder becomes visible, it means the user\n    // has scrolled to the bottom of the list. In this case, time to\n    // load more data.\n    if (entries[0].isIntersecting) {\n      loadMore();\n    }\n  });\n\n  observer.observe(placeholder);\n}\n```"]