["```\ntype Languages = {\n  de: URL;\n  en: URL;\n  pt: URL;\n  es: URL;\n  fr: URL;\n  ja: URL;\n};\n\nfunction isLanguageAvailable(\n  collection: Languages,\n  lang: string\n): lang is keyof Languages {\n  return lang in collection;\n}\n\nfunction loadLanguage(collection: Languages, lang: string) {\n  if (isLanguageAvailable(collection, lang)) {\n    // lang is keyof Languages\n    collection[lang]; // access ok!\n  }\n}\n```", "```\ntype AllowedElements = {\n  video: HTMLVideoElement;\n  audio: HTMLAudioElement;\n  canvas: HTMLCanvasElement;\n};\n\nfunction isElementAllowed(\n  collection: AllowedElements,\n  elem: string\n): elem is keyof AllowedElements {\n  return elem in collection;\n}\n\nfunction selectElement(collection: AllowedElements, elem: string) {\n  if (isElementAllowed(collection, elem)) {\n    // elem is keyof AllowedElements\n    collection[elem]; // access ok\n  }\n}\n```", "```\nfunction isAvailable(obj, key) {\n  return key in obj;\n}\n```", "```\nfunction isAvailable<Obj>(\n  obj: Obj,\n  key: string | number | symbol\n): key is keyof Obj {\n  return key in obj;\n}\n\nfunction loadLanguage(collection: Languages, lang: string) {\n  if (isAvailable(collection, lang)) {\n    // lang is keyof Languages\n    collection[lang]; // access ok!\n  }\n}\n\nfunction selectElement(collection: AllowedElements, elem: string) {\n  if (isAvailable(collection, elem)) {\n    // elem is keyof AllowedElements\n    collection[elem]; // access ok\n  }\n}\n```", "```\ntype Languages = {\n  de: URL;\n  en: URL;\n  pt: URL;\n  es: URL;\n  fr: URL;\n  ja: URL;\n};\n\nconst languages: Languages = { /* ... */ };\n```", "```\ntype URLList = {\n  [x: string]: URL;\n};\n```", "```\nfunction fetchFile(urls: URLList, key: string) {\n  return fetch(urls[key]).then((res) => res.json());\n}\n\nconst de = fetchFile(languages, \"de\");\nconst it = fetchFile(languages, \"it\");\n```", "```\nfunction fetchFile<List extends URLList>(urls: List, key: keyof List) {\n  return fetch(urls[key]).then((res) => res.json());\n}\n\nconst de = fetchFile(languages, \"de\");\nconst it = fetchFile(languages, \"it\");\n//                               ^\n// Argument of type '\"it\"' is not assignable to\n// parameter of type 'keyof Languages'.(2345)\n```", "```\nfunction fetchFiles<List extends URLList>(urls: List, keys: (keyof List)[]) {\n  const els = keys.map((el) =>\n    fetch(urls[el])\n      .then((res) => res.json())\n      .then((data) => [el, data])\n  );\n  return els;\n}\n\nconst de_and_fr = fetchFiles(languages, [\"de\", \"fr\"]); // Promise<any[]â‰¥[]\nconst de_and_it = fetchFiles(languages, [\"de\", \"it\"]);\n//                                             ^\n//  Type '\"it\"' is not assignable to type 'keyof Languages'.(2322)\n```", "```\nfunction fetchFiles<List extends URLList>(urls: List, keys: (keyof List)[]) {\n  const els = keys.map((el) =>\n    fetch(urls[el])\n      .then((res) => res.json())\n      .then((data) => {\n        const entry: [keyof List, any] = [el, data];\n        return entry;\n      })\n  );\n  return els;\n}\n\nconst de_and_fr = fetchFiles(languages, [\"de\", \"fr\"]);\n```", "```\nfor (const result of de_and_fr) {\n  if (result[0] === \"en\") {\n    // English?\n  }\n}\n```", "```\nfunction fetchFiles<List extends URLList, Keys extends keyof List>(\n  urls: List,\n  keys: Keys[]\n) {\n  const els = keys.map((el) =>\n    fetch(urls[el])\n      .then((res) => res.json())\n      .then((data) => {\n        const entry: [Keys, any] = [el, data];\n        return entry;\n      })\n  );\n  return els;\n}\n\nconst de_and_fr = fetchFiles(languages, [\"de\", \"fr\"]);\n```", "```\nfor (const entry of de_and_fr) {\n  const result = await entry;\n  if (result[0] === \"en\") {\n    //  This condition will always return 'false' since the types\n    //. '\"de\" | \"fr\"' and '\"en\"' have no overlap.(2367)\n  }\n}\n```", "```\nconst de_and_ja = fetchFiles<Languages, \"ja\" | \"de\">(languages, [\"de\"]);\n```", "```\nfunction identity(value: any): any {\n  return value;\n}\n\nlet a = identity(\"Hello!\");\nlet b = identity(false);\nlet c = identity(2);\n```", "```\nfunction identity(value: unknown): unknown {\n  return value;\n}\n\nlet a = identity(\"Hello!\");\nlet b = identity(false);\nlet c = identity(2);\n```", "```\nfunction identity<T>(t: T): T {\n  return t;\n}\n```", "```\nlet a = identity(\"Hello!\"); // a is string\nlet b = identity(2000);     // b is number\nlet c = identity({ a: 2 }); // c is { a: number }\n```", "```\nconst a = identity(\"Hello!\"); // a is \"Hello!\"\nconst b = identity(2000);     // b is 2000\nconst c = identity({ a: 2 }); // c is { a: number }\n```", "```\nconst a = identity<string>(\"Hello!\"); // a is string\nconst b = identity<number>(2000);     // b is number\nconst c = identity<{ a: 2 }>({ a: 2 }); // c is { a: 2 }\n```", "```\nfunction pairs(a: unknown, b: unknown): [unknown, unknown] {\n  return [a, b];\n}\n\nconst a = pairs(1, \"1\"); // [unknown, unknown]\n```", "```\nfunction pairs<T, U>(a: T, b: U): [T, U] {\n  return [a, b];\n}\n\nconst b = pairs(1, \"1\"); // [number, string]\n```", "```\nfunction pairs<T>(a: T, b: T): [T, T] {\n  return [a, b];\n}\n\nconst c = pairs(1, \"1\");\n//                  ^\n// Argument of type 'string' is not assignable to parameter of type 'number'\n```", "```\ntype FilterRule = {\n  field: string;\n  operator: string;\n  value: any;\n};\n\ntype CombinatorialFilter = {\n  combinator: \"and\" | \"or\";\n  rules: FilterRule[];\n};\n\ntype ChainedFilter = {\n  rules: (CombinatorialFilter | FilterRule)[];\n};\n\ntype Filter = CombinatorialFilter | ChainedFilter;\n```", "```\nfunction reset(filter: Filter): Filter {\n  if (\"combinator\" in filter) {\n    // filter is CombinatorialFilter\n    return { combinator: \"and\", rules: [] };\n  }\n  // filter is ChainedFilter\n  return { rules: [] };\n}\n\nconst filter: CombinatorialFilter = { rules: [], combinator: \"or\" };\nconst resetFilter = reset(filter); // resetFilter is Filter\n```", "```\nfunction reset<F extends Filter>(filter: F): F {\n  if (\"combinator\" in filter) {\n    return { combinator: \"and\", rules: [] };\n//  ^ '{ combinator: \"and\"; rules: never[]; }' is assignable to\n//     the constraint of type 'F', but 'F' could be instantiated\n//     with a different subtype of constraint 'Filter'.\n  }\n  return { rules: [] };\n//^ '{ rules: never[]; }' is assignable to the constraint of type 'F',\n//   but 'F' could be instantiated with a different subtype of\n//   constraint 'Filter'.\n}\n\nconst resetFilter = reset(filter); // resetFilter is CombinatorialFilter\n```", "```\nconst onDemandFilter = reset({\n  combinator: \"and\",\n  rules: [],\n  evaluated: true,\n  result: false,\n});\n/* filter is {\n combinator: \"and\";\n rules: never[];\n evaluated: boolean;\n result: boolean;\n}; */\n```", "```\nfunction reset<F extends Filter>(filter: F): F {\n  const result = { ...filter }; // result is F\n  result.rules = [];\n  if (\"combinator\" in result) {\n    result.combinator = \"and\";\n  }\n  return result;\n}\n\nconst resetFilter = reset(filter); // resetFilter is CombinatorialFilter\n```", "```\ntype TreeItem = {\n  id: string;\n  children: TreeItem[];\n  collapsed?: boolean;\n};\n\nfunction createRootItem<T extends TreeItem>(): T {\n  return {\n    id: \"root\",\n    children: [],\n  };\n// '{ id: string; children: never[]; }' is assignable to the constraint\n//   of type 'T', but 'T' could be instantiated with a different subtype\n//   of constraint 'TreeItem'.(2322)\n}\n\nconst root = createRootItem(); // root is TreeItem\n```", "```\nfunction createRootItem(): TreeItem {\n  return {\n    id: \"root\",\n    children: [],\n  };\n}\n```", "```\nfunction attachToRoot(children: TreeItem[]): TreeItem {\n  return {\n    id: \"root\",\n    children,\n  };\n}\n\nconst root = attachToRoot([]); // TreeItem\n```", "```\nfunction attachToRoot<T extends TreeItem>(children: T[]): TreeItem {\n  return {\n    id: \"root\",\n    children,\n  };\n}\n\nconst root = attachToRoot([\n  {\n    id: \"child\",\n    children: [],\n    collapsed: false,\n    marked: true,\n  },\n]); // root is TreeItem\n```", "```\ntype BaseTreeItem = {\n  id: string;\n  children: BaseTreeItem[];\n};\n\ntype TreeItem<Children extends TreeItem = BaseTreeItem> = {\n  id: string;\n  children: Children[];\n  collapsed?: boolean;\n};\n\nfunction attachToRoot<T extends TreeItem>(children: T[]): TreeItem<T> {\n  return {\n    id: \"root\",\n    children,\n  };\n}\n\nconst root = attachToRoot([\n  {\n    id: \"child\",\n    children: [],\n    collapsed: false,\n    marked: true,\n  },\n]);\n/*\nroot is TreeItem<{\n id: string;\n children: never[];\n collapsed: false;\n marked: boolean;\n}>\n*/\n```", "```\ntype ToyBase = {\n  name: string;\n  description: string;\n  minimumAge: number;\n};\n\ntype BoardGame = ToyBase & {\n  kind: \"boardgame\";\n  players: number;\n};\n\ntype Puzzle = ToyBase & {\n  kind: \"puzzle\";\n  pieces: number;\n};\n\ntype Doll = ToyBase & {\n  kind: \"doll\";\n  material: \"plush\" | \"plastic\";\n};\n\ntype Toy = Doll | Puzzle | BoardGame;\n```", "```\ntype GroupedToys = {\n  boardgame: Toy[];\n  puzzle: Toy[];\n  doll: Toy[];\n};\n\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {\n    boardgame: [],\n    puzzle: [],\n    doll: [],\n  };\n  for (let toy of toys) {\n    groups[toy.kind].push(toy);\n  }\n  return groups;\n}\n```", "```\ntype Bricks = ToyBase & {\n  kind: \"bricks\",\n  pieces: number;\n  brand: string;\n}\n\ntype Toy = Doll | Puzzle | BoardGame | Bricks;\n```", "```\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {\n    boardgame: [],\n    puzzle: [],\n    doll: [],\n  };\n  for (let toy of toys) {\n    groups[toy.kind].push(toy);\n//  ^- Element implicitly has an 'any' type because expression\n//     of type '\"boardgame\" | \"puzzle\" | \"doll\" | \"bricks\"' can't\n//     be used to index type 'GroupedToys'.\n//     Property 'bricks' does not exist on type 'GroupedToys'.(7053)\n  }\n  return groups;\n}\n```", "```\ntype GroupedToys = {\n  boardgame: Toy[];\n  puzzle: Toy[];\n  doll: Toy[];\n  bricks: Toy[];\n};\n\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {\n    boardgame: [],\n    puzzle: [],\n    doll: [],\n    bricks: [],\n  };\n  for (let toy of toys) {\n    groups[toy.kind].push(toy);\n  }\n  return groups;\n}\n```", "```\ntype GroupedToys = {\n  boardgame?: Toy[];\n  puzzle?: Toy[];\n  doll?: Toy[];\n  bricks?: Toy[];\n};\n\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {};\n  for (let toy of toys) {\n    // Initialize when not available\n    groups[toy.kind] = groups[toy.kind] ?? [];\n    groups[toy.kind]?.push(toy);\n  }\n  return groups;\n}\n```", "```\ntype GroupedToys = {\n  [k in Toy[\"kind\"]]?: Toy[];\n};\n```", "```\n// How to use it\ntype GroupedToys = Group<Toy, \"kind\">;\n\ntype Group<Collection, Selector extends keyof Collection> = {\n  [x in Collection[Selector]]?: Collection[];\n//     ^ Type 'Collection[Selector]' is not assignable\n//       to type 'string | number | symbol'.\n//       Type 'Collection[keyof Collection]' is not\n//       assignable to type 'string | number | symbol'.\n//       Type 'Collection[string] | Collection[number]\n//        | Collection[symbol]' is not assignable to\n//       type 'string | number | symbol'.\n//       Type 'Collection[string]' is not assignable to\n//       type 'string | number | symbol'.(2322)\n};\n```", "```\n// This type is built-in!\ntype Record<K extends string | number | symbol, T> = { [P in K]: T; };\n```", "```\ntype Group<\n  Collection extends Record<string, any>,\n  Selector extends keyof Collection\n> = {\n  [x in Collection[Selector]]: Collection[];\n};\n```", "```\ntype Group<Collection, Selector extends keyof Collection> = {\n  [k in Collection[Selector] extends string\n    ? Collection[Selector]\n    : never]?: Collection[];\n};\n```", "```\n// This type is built-in!\ntype Partial<T> = { [P in keyof T]?: T[P] };\n```", "```\ntype GroupedToys = Partial<Group<Toy, \"kind\">>;\n```", "```\nfunction check(person: any) {\n  person.checked = true;\n}\n\nconst person = {\n  name: \"Stefan\",\n  age: 27,\n};\n\ncheck(person); // person now has the checked property\n\nperson.checked; // this is true!\n```", "```\n(person as typeof person & { checked: boolean }).checked = true;\n```", "```\nfunction check<T>(obj: T): obj is T & { checked: true } {\n  (obj as T & { checked: boolean }).checked = true;\n  return true;\n}\n\nconst person = {\n  name: \"Stefan\",\n  age: 27,\n};\n\nif (check(person)) {\n  person.checked; // checked is true!\n}\n```", "```\nfunction assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction yell(str: any) {\n  assert(typeof str === \"string\");\n  // str is string\n  return str.toUpperCase();\n}\n```", "```\nfunction assertNumber(val: any): asserts val is number {\n  if (typeof val !== \"number\") {\n    throw Error(\"value is not a number\");\n  }\n}\n\nfunction add(x: unknown, y: unknown): number {\n  assertNumber(x); // x is number\n  assertNumber(y); // y is number\n  return x + y;\n}\n```", "```\nfunction check<T>(obj: T): asserts obj is T & { checked: true } {\n  (obj as T & { checked: boolean }).checked = true;\n}\n\nconst person = {\n  name: \"Stefan\",\n  age: 27,\n};\n\ncheck(person);\n```", "```\n// Using create Element\n\n// a is HTMLAnchorElement\nconst a = createElement(\"a\", { href: \"https://fettblog.eu\" });\n// b is HTMLVideoElement\nconst b = createElement(\"video\", { src: \"/movie.mp4\", autoplay: true });\n// c is HTMLElement\nconst c = createElement(\"my-element\");\n```", "```\ntype AllElements = {\n  a: HTMLAnchorElement;\n  div: HTMLDivElement;\n  video: HTMLVideoElement;\n  //... and ~140 more!\n};\n\n// HTMLAnchorElement\ntype A = AllElements[\"a\"];\n```", "```\ntype AllElements = {\n  a: HTMLAnchorElement;\n  div: HTMLDivElement;\n  video: HTMLVideoElement;\n  //... and ~140 more!\n};\n\n// HTMLAnchorElement | HTMLDivELement\ntype AandDiv = AllElements[\"a\" | \"div\"];\n```", "```\nfunction createElement<T extends keyof AllElements>(tag: T): AllElements[T] {\n  return document.createElement(tag as string) as AllElements[T];\n}\n\n// a is HTMLAnchorElement\nconst a = createElement(\"a\");\n```", "```\ntype Partial<T> = { [P in keyof T]?: T[P] };\n```", "```\nfunction createElement<T extends keyof AllElements>(\n  tag: T,\n  props?: Partial<AllElements[T]>\n): AllElements[T] {\n  const elem = document.createElement(tag as string) as AllElements[T];\n  return Object.assign(elem, props);\n}\n\nconst a = createElement(\"a\", { href: \"https://fettblog.eu\" });\nconst x = createElement(\"a\", { src: \"https://fettblog.eu\" });\n//                           ^--\n// Argument of type '{ src: string; }' is not assignable to parameter\n// of type 'Partial<HTMLAnchorElement>'.\n// Object literal may only specify known properties, and 'src' does not\n// exist in type 'Partial<HTMLAnchorElement>'.(2345)\n```", "```\nfunction createElement<T extends keyof HTMLElementTagNameMap>(\n  tag: T,\n  props?: Partial<HTMLElementTagNameMap[T]>\n): HTMLElementTagNameMap[T] {\n  const elem = document.createElement(tag);\n  return Object.assign(elem, props);\n}\n```", "```\ninterface HTMLElementTagNameMap {\n  [x: string]: HTMLUnknownElement;\n};\n\nfunction createElement<T extends keyof HTMLElementTagNameMap>(\n  tag: T,\n  props?: Partial<HTMLElementTagNameMap[T]>\n): HTMLElementTagNameMap[T] {\n  const elem = document.createElement(tag);\n  return Object.assign(elem, props);\n}\n\n// a is HTMLAnchorElement\nconst a = createElement(\"a\", { href: \"https://fettblog.eu\" });\n// b is HTMLUnknownElement\nconst b = createElement(\"my-element\");\n```", "```\ntype AllElements = HTMLElementTagNameMap &\n  {\n    [x in `${string}-${string}`]: HTMLElement;\n  };\n\nfunction createElement<T extends keyof AllElements>(\n  tag: T,\n  props?: Partial<AllElements[T]>\n): AllElements[T] {\n  const elem = document.createElement(tag as string) as AllElements[T];\n  return Object.assign(elem, props);\n}\n\nconst a = createElement(\"a\", { href: \"https://fettblog.eu\" }); // OK\nconst b = createElement(\"my-element\"); // OK\n\nconst c = createElement(\"thisWillError\");\n//                      ^\n// Argument of type '\"thisWillError\"' is not\n// assignable to parameter of type '`${string}-${string}`\n// | keyof HTMLElementTagNameMap'.(2345)\n```", "```\nfunction createElement<T extends keyof AllElements>(\n  tag: T,\n  props?: Partial<AllElements[T]>\n): AllElements[T];\nfunction createElement(tag: string, props?: Partial<HTMLElement>): HTMLElement {\n  const elem = document.createElement(tag);\n  return Object.assign(elem, props);\n}\n```", "```\nconst instance = create({\n  data() {\n    return {\n      firstName: \"Stefan\",\n      lastName: \"Baumgartner\",\n    };\n  },\n  computed: {\n    fullName() {\n      // has access to the return object of data\n      return this.firstName + \" \" + this.lastName;\n    },\n  },\n  methods: {\n    hi() {\n      // use computed properties just like normal properties\n      alert(this.fullName.toLowerCase());\n    },\n  },\n});\n```", "```\ntype Options<Data> = {\n  data(this: {})?: Data;\n};\n```", "```\ntype Options<Data, Computed> = {\n  data(this: {})?: Data;\n  computed?: Computed & ThisType<Data>;\n};\n```", "```\n// An object of functions ...\ntype FnObj = Record<string, () => any>;\n\n// ... to an object of return types\ntype MapFnToProp<FunctionObj extends FnObj> = {\n  [K in keyof FunctionObj]: ReturnType<FunctionObj[K]>;\n};\n```", "```\ntype Options<Data, Computed extends FnObj, Methods> = {\n  data(this: {})?: Data;\n  computed?: Computed & ThisType<Data>;\n  methods?: Methods & ThisType<Data & MapFnToProp<Computed> & Methods>;\n};\n```", "```\ndeclare function create<Data, Computed extends FnObj, Methods>(\n  options: Options<Data, Computed, Methods>\n): any;\n```", "```\ninterface ComponentConstructor {\n  new(): Component;\n}\n\ninterface Component {\n  render(): HTMLElement;\n}\n```", "```\ntype Route = {\n  path: string;\n  component: ComponentConstructor;\n};\n\nfunction router(routes: Route[]) {\n  return {\n    navigate(path: string) {\n      // ...\n    },\n  };\n}\n```", "```\nconst rtr = router([\n  {\n    path: \"/\",\n    component: Main,\n  },\n  {\n    path: \"/about\",\n    component: About,\n  },\n])\n\nrtr.navigate(\"/faq\");\n```", "```\nfunction router<T extends Route>(routes: T[]) {\n  return {\n    navigate(path: T[\"path\"]) {\n      // ...\n    },\n  };\n}\n```", "```\nfunction getPath<T extends string>(route: T): T {\n  return route;\n}\n\nconst path = getPath(\"/\"); // \"/\"\n```", "```\ntype Routes = {\n  paths: string[];\n};\n\nfunction getPaths<T extends Routes>(routes: T): T[\"paths\"] {\n  return routes.paths;\n}\n\nconst paths = getPaths({ paths: [\"/\", \"/about\"] }); // string[]\n```", "```\nfunction router<T extends Route>(routes: readonly T[]) {\n  return {\n    navigate(path: T[\"path\"]) {\n      history.pushState({}, \"\", path);\n    },\n  };\n}\n\nconst rtr = router([\n  {\n    path: \"/\",\n    component: Main,\n  },\n  {\n    path: \"/about\",\n    component: About,\n  },\n] as const);\n\nrtr.navigate(\"/about\");\n```", "```\nfunction router<const T extends Route>(routes: T[]) {\n  return {\n    navigate(path: T[\"path\"]) {\n      // tbd\n    },\n  };\n}\n```", "```\nconst rtr = router([\n  {\n    path: \"/\",\n    component: Main,\n  },\n  {\n    path: \"/about\",\n    component: About,\n  },\n])\n\nrtr.navigate(\"/about\");\n```", "```\nconst rtr = router([\n  {\n    path: \"/\",\n    component: Main,\n  },\n  {\n    path: \"/about\",\n    component: About,\n  },\n])\n\nrtr.navigate(\"/faq\");\n//             ^\n// Argument of type '\"/faq\"' is not assignable to\n// parameter of type '\"/\" | \"/about\"'.(2345)\n```"]