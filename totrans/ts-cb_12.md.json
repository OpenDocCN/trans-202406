["```\nclass Person {\n  public name; // modifier public is optional\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nconst myName = new Person(\"Stefan\").name; // works\n```", "```\nclass Person {\n  protected name;\n  constructor(name: string) {\n    this.name = name;\n  }\n  getName() {\n    // access works\n    return this.name;\n  }\n}\n\nconst myName = new Person(\"Stefan\").name;\n//                                   ^\n// Property 'name' is private and only accessible within\n// class 'Person'.(2341)\n\nclass Teacher extends Person {\n  constructor(name: string) {\n    super(name);\n  }\n\n  getFullName() {\n    // access works\n    return `Professor ${this.name}`;\n  }\n}\n```", "```\nclass Player extends Person {\n  constructor(name: string) {\n    super(name);\n  }\n\n  pair(p: Player) {\n    // works\n    return `Pairing ${this.name} with ${p.name}`;\n  }\n}\n```", "```\nclass Player extends Person {\n  constructor(name: string) {\n    super(name);\n  }\n\n  pair(p: Person) {\n    return `Pairing ${this.name} with ${p.name}`;\n    //                                    ^\n    // Property 'name' is protected and only accessible through an\n    // instance of class 'Player'. This is an instance of\n    // class 'Person'.(2446)\n  }\n}\n```", "```\nclass Person {\n  private name;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nconst myName = new Person(\"Stefan\").name;\n//                                   ^\n// Property 'name' is protected and only accessible within\n// class 'Person' and its subclasses.(2445)\n\nclass Teacher extends Person {\n  constructor(name: string) {\n    super(name);\n  }\n\n  getFullName() {\n    return `Professor ${this.name}`;\n    //                        ^\n    // Property 'name' is private and only accessible\n    // within class 'Person'.(2341)\n  }\n}\n```", "```\nclass Category {\n  constructor(\n    public title: string,\n    public id: number,\n    private reference: bigint\n  ) {}\n}\n\n// transpiles to\n\nclass Category {\n  constructor(title, id, reference) {\n    this.title = title;\n    this.id = id;\n    this.reference = reference;\n  }\n}\n```", "```\nclass Person {\n  #name: string;\n\n  constructor(name: string) {\n    this.#name = name;\n  }\n\n  // we can use getters!\n  get name(): string {\n    return this.#name.toUpperCase();\n  }\n}\n\nconst me = new Person(\"Stefan\");\nconsole.log(me.#name);\n//              ^\n// Property '#name' is not accessible outside\n// class 'Person' because it has a private identifier.(18013)\n\nconsole.log(me.name); // works\n```", "```\nclass Person {\n  #name;\n\n  constructor(name) {\n    this.#name = name;\n  }\n\n  get name() {\n    return this.#name.toUpperCase();\n  }\n}\n```", "```\ntype Point = {\n  x: number;\n  y: number;\n};\n\nclass Shape {\n  points: Point[];\n  fillStyle: string = \"white\";\n  lineWidth: number = 10;\n\n  constructor(points: Point[]) {\n    this.points = points;\n  }\n\n  set fill(style: string) {\n    this.fillStyle = style;\n  }\n\n  set width(width: number) {\n    this.lineWidth = width;\n  }\n\n  render(ctx: CanvasRenderingContext2D) {\n    if (this.points.length) {\n      ctx.fillStyle = this.fillStyle;\n      ctx.lineWidth = this.lineWidth;\n      ctx.beginPath();\n      let point = this.points[0];\n      ctx.moveTo(point.x, point.y);\n      for (let i = 1; i < this.points.length; i++) {\n        point = this.points[i];\n        ctx.lineTo(point.x, point.y);\n      }\n      ctx.closePath();\n      ctx.stroke();\n    }\n  }\n}\n```", "```\nconst canvas = document.getElementsByTagName(\"canvas\")[0];\nconst ctx = canvas?.getContext(\"2d\");\n\nconst shape = new Shape([\n  { x: 50, y: 140 },\n  { x: 150, y: 60 },\n  { x: 250, y: 140 },\n]);\nshape.fill = \"red\";\nshape.width = 20;\n\nshape.render(ctx);\n```", "```\nclass Rectangle extends Shape {\n  constructor(points: Point[]) {\n    if (points.length !== 2) {\n      throw Error(`Wrong number of points, expected 2, got ${points.length}`);\n    }\n    super(points);\n  }\n\n  render(ctx: CanvasRenderingContext2D) {\n    ctx.fillStyle = this.fillStyle;\n    ctx.lineWidth = this.lineWidth;\n    let a = this.points[0];\n    let b = this.points[1];\n    ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);\n  }\n}\n```", "```\nconst rectangle = new Rectangle([\n  {x: 130, y: 190},\n  {x: 170, y: 250}\n]);\nrectangle.render(ctx);\n```", "```\nclass Shape {\n  // see above\n\n  draw(ctx: CanvasRenderingContext2D) {\n    if (this.points.length) {\n      ctx.fillStyle = this.fillStyle;\n      ctx.lineWidth = this.lineWidth;\n      ctx.beginPath();\n      let point = this.points[0];\n      ctx.moveTo(point.x, point.y);\n      for (let i = 1; i < this.points.length; i++) {\n        point = this.points[i];\n        ctx.lineTo(point.x, point.y);\n      }\n      ctx.closePath();\n      ctx.stroke();\n    }\n  }\n}\n```", "```\nclass Rectangle extends Shape {\n  // see above\n\n  override render(ctx: CanvasRenderingContext2D) {\n//         ^\n// This member cannot have an 'override' modifier because it\n// is not declared in the base class 'Shape'.(4113)\n    ctx.fillStyle = this.fillStyle;\n    ctx.lineWidth = this.lineWidth;\n    let a = this.points[0];\n    let b = this.points[1];\n    ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);\n  }\n}\n```", "```\nclass Rectangle extends Shape {\n  // see above\n\n  draw(ctx: CanvasRenderingContext2D) {\n// ^\n// This member must have an 'override' modifier because it\n// overrides a member in the base class 'Shape'.(4114)\n    ctx.fillStyle = this.fillStyle;\n    ctx.lineWidth = this.lineWidth;\n    let a = this.points[0];\n    let b = this.points[1];\n    ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);\n  }\n}\n```", "```\nabstract class FilterItem {\n  constructor(private property: string) {};\n  someFunction() { /* ... */ };\n  abstract filter(): void;\n}\n\nclass AFilter extends FilterItem {\n  filter() { /* ... */ }\n}\n\nclass BFilter extends FilterItem {\n  filter() { /* ... */ }\n}\n```", "```\nconst some: FilterItem = new AFilter('afilter'); // ok\n```", "```\ndeclare const filterMap: Map<string, typeof FilterItem>;\n\nfilterMap.set('number', AFilter);\nfilterMap.set('stuff', BFilter);\n```", "```\nlet obj: FilterItem;\n// get the constructor\nconst ctor = filterMap.get('number');\n\nif(typeof ctor !== 'undefined') {\n  obj = new ctor();\n//          ^\n// cannot create an object of an abstract class\n}\n```", "```\ninterface IFilter {\n  new(property: string): IFilter;\n  someFunction(): void;\n  filter(): void;\n}\n\ndeclare const filterMap: Map<string, IFilter>;\n```", "```\nabstract class FilterItem implements IFilter { /* ... */ }\n// ^\n// Class 'FilterItem' incorrectly implements interface 'IFilter'.\n// Type 'FilterItem' provides no match for the signature\n// 'new (property: string): IFilter'.\n\nfilterMap.set('number', AFilter);\n//                      ^\n// Argument of type 'typeof AFilter' is not assignable\n// to parameter of type 'IFilter'. Type 'typeof AFilter' is missing\n// the following properties from type 'IFilter': someFunction, filter\n```", "```\nfunction AFilter(property) { // this is part of the static side\n  this.property = property;  // this is part of the instance side\n}\n\n// a function of the instance side\nAFilter.prototype.filter = function() {/* ... */}\n\n// not part of our example, but on the static side\nAfilter.something = function () { /* ... */ }\n```", "```\ninterface FilterConstructor {\n  new (property: string): IFilter;\n}\n\ninterface IFilter {\n  someFunction(): void;\n  filter(): void;\n}\n```", "```\ndeclare const filterMap: Map<string, FilterConstructor>;  /* 1 */\n\nfilterMap.set('number', AFilter);\nfilterMap.set('stuff', BFilter);\n\nlet obj: IFilter;  /* 2 */\nconst ctor = filterMap.get('number');\nif(typeof ctor !== 'undefined') {\n  obj = new ctor('a');\n}\n```", "```\nfilterMap.set('notworking', FilterItem);\n//                          ^\n// Cannot assign an abstract constructor type to a\n// non-abstract constructor type.\n```", "```\nclass Collection<T> {\n  items: T[];\n  constructor() {\n    this.items = [];\n  }\n\n  add(item: T) {\n    this.items.push(item);\n  }\n\n  contains(item: T): boolean {\n    return this.items.includes(item);\n  }\n}\n```", "```\nconst numbers = new Collection<number>();\nnumbers.add(1);\nnumbers.add(2);\n\nconst strings = new Collection<string>();\nstrings.add(\"Hello\");\nstrings.add(\"World\");\n```", "```\nconst unknowns = new Collection();\nunknowns.add(1);\nunknowns.add(\"World\");\n```", "```\nclass Collection<T> {\n  items: T[];\n  constructor(initial: T) {\n    this.items = [initial];\n  }\n\n  add(item: T) {\n    this.items.push(item);\n  }\n\n  contains(item: T): boolean {\n    return this.items.includes(item);\n  }\n}\n\n// T is number!\nconst numbersInf = new Collection(0);\nnumbersInf.add(1);\n```", "```\nclass Collection<T = never> {\n  items: T[];\n  constructor() {\n    this.items = [];\n  }\n\n  add(item: T) {\n    this.items.push(item);\n  }\n\n  contains(item: T): boolean {\n    return this.items.includes(item);\n  }\n}\n```", "```\nconst nevers = new Collection();\nnevers.add(1);\n//     ^\n// Argument of type 'number' is not assignable\n// to parameter of type 'never'.(2345)\nnevers.add(\"World\");\n//     ^\n// Argument of type 'string' is not assignable\n// to parameter of type 'never'.(2345)\n```", "```\n// Environment.ts\n\nexport default class Environment {\n  private static variableList: string[] = []\n  static variables(): string[] { /* ... */ }\n  static setVariable(key: string, value: any): void  { /* ... */ }\n  static getValue(key: string): unknown  { /* ... */ }\n}\n\n// Usage in another file\nimport * as Environment from \"./Environment\";\n\nconsole.log(Environment.variables());\n```", "```\n// Environment.ts\nconst variableList: string = []\n\nexport function variables(): string[] { /* ... */ }\nexport function setVariable(key: string, value: any): void  { /* ... */ }\nexport function getValue(key: string): unknown  { /* ... */ }\n\n// Usage in another file\nimport * as Environment from \"./Environment\";\n\nconsole.log(Environment.variables());\n```", "```\nexport default class Environment {\n  private static variableList: string[] = [];\n  static variables(): string[] {\n    return this.variableList;\n  }\n}\n```", "```\nconst variableList: string = []\n\nexport function variables(): string[] {\n  return variableList;\n}\n```", "```\n// Only the variables function and variableList\n// end up in the bundle\nimport { variables } from \"./Environment\";\n\nconsole.log(variables());\n```", "```\n// file users/models.ts\nnamespace Users {\n  export interface Person {\n    name: string;\n    age: number;\n  }\n}\n\n// file users/controller.ts\n\n/// <reference path=\"./models.ts\" />\nnamespace Users {\n  export function updateUser(p: Person) {\n    // do the rest\n  }\n}\n```", "```\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    \"img\": HTMLAttributes & {\n      alt: string;\n      src: string;\n      loading?: 'lazy' | 'eager' | 'auto';\n    }\n  }\n}\n```", "```\nexport namespace Users {\n  type User = {\n    name: string;\n    age: number;\n  };\n\n  export function createUser(name: string, age: number): User {\n    return { name, age };\n  }\n}\n```", "```\nexport var Users;\n(function (Users) {\n    function createUser(name, age) {\n        return {\n            name, age\n        };\n    }\n    Users.createUser = createUser;\n})(Users || (Users = {}));\n```", "```\nimport * as Users from \"./users\";\n\nUsers.Users.createUser(\"Stefan\", \"39\");\n```", "```\nabstract class Lifeform {\n  age: number;\n  constructor(age: number) {\n    this.age = age;\n  }\n\n  abstract move(): string;\n}\n\nclass Human extends Lifeform {\n  move() {\n    return \"Walking, mostly...\";\n  }\n}\n```", "```\nabstract class Lifeform {\n  age: number;\n  constructor(age: number) {\n    this.age = age;\n  }\n}\n\nconst lifeform = new Lifeform(20);\n//               ^\n// Cannot create an instance of an abstract class.(2511)\n```", "```\ndeclare function moveLifeform(lifeform: Lifeform);\n```", "```\ninterface Lifeform {\n  move(): string;\n}\n\nclass BasicLifeForm {\n  age: number;\n  constructor(age: number) {\n    this.age = age;\n  }\n}\n\nclass Human extends BasicLifeForm implements Lifeform {\n  move() {\n    return \"Walking\";\n  }\n}\n```", "```\n// Anti-Pattern\nexport default class Environment {\n  private static variableList: string[] = []\n  static variables(): string[] { /* ... */ }\n  static setVariable(key: string, value: any): void  { /* ... */ }\n  static getValue(key: string): unknown  { /* ... */ }\n}\n\n// Better: Module-scoped functions and variables\nconst variableList: string = []\n\nexport function variables(): string[] { /* ... */ }\nexport function setVariable(key: string, value: any): void  { /* ... */ }\nexport function getValue(key: string): unknown  { /* ... */ }\n```", "```\nclass Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  distanceTo(point: Point): number {\n    const dx = this.x - point.x;\n    const dy = this.y - point.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}\n\nconst a = new Point(0, 0);\nconst b = new Point(1, 5);\n\nconst distance = a.distanceTo(b);\n```", "```\nclass Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  distanceTo(point: Point): number {\n    const dx = this.x - point.x;\n    const dy = this.y - point.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  static distance(p1: Point, p2: Point): number {\n    return p1.distanceTo(p2);\n  }\n}\n\nconst a = new Point(0, 0);\nconst b = new Point(1, 5);\n\nconst distance = Point.distance(a, b);\n```", "```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.distanceTo = function(p) {\n  const dx = this.x - p.x;\n  const dy = this.y - p.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nPoint.distance = function(a, b) {\n  return a.distanceTo(b);\n}\n```", "```\nclass Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  #distanceTo(point: Point): number {\n    const dx = this.x - point.x;\n    const dy = this.y - point.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  static distance(p1: Point, p2: Point): number {\n    return p1.#distanceTo(p2);\n  }\n}\n```", "```\nclass Task {\n  static #nextId = 0;\n  #id: number;\n\n  constructor() {\n    if (Task.#nextId > 99) {\n      throw \"Max number of tasks reached\";\n    }\n    this.#id = Task.#nextId++;\n  }\n}\n```", "```\ntype Config = {\n  instances: number;\n};\n\nclass Task {\n  static #nextId = 0;\n  static #maxInstances: number;\n  #id: number;\n\n  static {\n    fetch(\"/available-slots\")\n      .then((res) => res.json())\n      .then((result: Config) => {\n        Task.#maxInstances = result.instances;\n      });\n    }\n\n  constructor() {\n    if (Task.#nextId > Task.#maxInstances) {\n      throw \"Max number of tasks reached\";\n    }\n    this.#id = Task.#nextId++;\n  }\n}\n```", "```\ntype State = \"active\" | \"inactive\";\n\nclass Account {\n  id: number;\n  userName: string;\n  state: State;\n  orders: number[];\n}\n```", "```\nclass Account {\n  id: number;\n// ^ Property 'id' has no initializer and is\n// not definitely assigned in the constructor.(2564)\n  userName: string;\n// ^ Property 'userName' has no initializer and is\n// not definitely assigned in the constructor.(2564)\n  state: State;\n// ^ Property 'state' has no initializer and is\n// not definitely assigned in the constructor.(2564)\n  orders: number[];\n// ^ Property 'orders' has no initializer and is\n// not definitely assigned in the constructor.(2564)\n}\n```", "```\nclass Account {\n  id: number; // still errors\n  userName: string; // still errors\n  state: State = \"active\"; // ok\n  orders?: number[]; // ok\n}\n```", "```\nclass Account {\n  id: number;\n  userName: string;\n  state: State = \"active\";\n  orders?: number[];\n\n  constructor(userName: string, id: number) {\n    this.userName = userName;\n    this.id = id;\n  }\n}\n```", "```\nclass Account {\n  state: State = \"active\";\n  orders?: number[];\n\n  constructor(public userName: string, public id: number) {}\n}\n```", "```\nclass Account {\n  constructor(userName, id) {\n    this.userName = userName;\n    this.id = id;\n    this.state = \"active\";\n  }\n}\n```", "```\ntype User = {\n  id: number;\n  userName: string;\n};\n\nclass Account {\n  userName: string;\n// ^ Property 'userName' has no initializer and is\n// not definitely assigned in the constructor.(2564)\n  state: State = \"active\";\n  orders?: number[];\n\n  constructor(public id: number) {\n    fetch(`/api/getName?id=${id}`)\n      .then((res) => res.json())\n      .then((data: User) => (this.userName = data.userName ?? \"not-found\"));\n  }\n}\n```", "```\nclass Account {\n  state: State = \"active\";\n  orders?: number[];\n\n  constructor(public id: number, public userName: string) {}\n\n  static async create(id: number) {\n    const user: User = await fetch(`/api/getName?id=${id}`).then((res) =>\n      res.json()\n    );\n    return new Account(id, user.userName);\n  }\n}\n```", "```\nclass Account {\n  userName!: string;\n  state: State = \"active\";\n  orders?: number[];\n\n  constructor(public id: number) {\n    fetch(`/api/getName?id=${id}`)\n      .then((res) => res.json())\n      .then((data: User) => (this.userName = data.userName));\n  }\n}\n```", "```\nclass User {\n  #id: number;\n  static #nextThreadId: number;\n\n  constructor(id: number) {\n    this.#id = id;\n  }\n\n  equals(user: User): boolean {\n    return this.#id === user.#id;\n  }\n\n  async openThread(title: string, content: string): Promise<number> {\n    const threadId = User.#nextThreadId++;\n    await fetch(\"/createThread\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        content,\n        title,\n        threadId,\n      }),\n    });\n    return threadId;\n  }\n}\n```", "```\nclass Admin extends User {\n  #privileges: string[];\n  constructor(id: number, privileges: string[] = []) {\n    super(id);\n    this.#privileges = privileges;\n  }\n\n  async closeThread(threadId: number) {\n    await fetch(\"/closeThread\", {\n      method: \"POST\",\n      body: \"\" + threadId,\n    });\n  }\n}\n```", "```\nconst user = new User(1);\nconst admin = new Admin(2);\n\nconsole.log(user.equals(admin));\nconsole.log(admin.equals(user));\n```", "```\nclass User {\n  // ...\n\n  equals(user: this): boolean {\n    return this.#id === user.#id;\n  }\n}\n```", "```\nconsole.log(admin.equals(user));\n//                       ^\n// Argument of type 'User' is not assignable to parameter of type 'Admin'.\n```", "```\nclass OptionBuilder<T = string | number | boolean> {\n  #options: Map<string, T> = new Map();\n  constructor() {}\n\n  add(name: string, value: T): OptionBuilder<T> {\n    this.#options.set(name, value);\n    return this;\n  }\n\n  has(name: string) {\n    return this.#options.has(name);\n  }\n\n  build() {\n    return Object.fromEntries(this.#options);\n  }\n}\n```", "```\nconst options = new OptionBuilder()\n  .add(\"deflate\", true)\n  .add(\"compressionFactor\", 10)\n  .build();\n```", "```\nclass StringOptionBuilder extends OptionBuilder<string> {\n  safeAdd(name: string, value: string) {\n    if (!this.has(name)) {\n      this.add(name, value);\n    }\n    return this;\n  }\n}\n```", "```\nconst languages = new StringOptionBuilder()\n  .add(\"en\", \"English\")\n  .safeAdd(\"de\", \"Deutsch\")\n// ^\n// Property 'safeAdd' does not exist on type 'OptionBuilder<string>'.(2339)\n  .safeAdd(\"de\", \"German\")\n  .build();\n```", "```\nclass OptionBuilder<T = string | number | boolean> {\n  // ...\n\n  add(name: string, value: T): this {\n    this.#options.set(name, value);\n    return this;\n  }\n}\n```", "```\nfunction log(value: Function, context: ClassMethodDecoratorContext) {\n  return function (this: any, ...args: any[]) {\n    console.log(`calling ${context.name.toString()}`);\n    return value.call(this, ...args);\n  };\n}\n\nclass Toggler {\n  #toggled = false;\n\n  @log\n  toggle() {\n    this.#toggled = !this.#toggled;\n  }\n}\n\nconst toggler = new Toggler();\ntoggler.toggle();\n```", "```\ntype ClassMethodDecorator = (value: Function, context: {\n  kind: \"method\";\n  name: string | symbol;\n  access: { get(): unknown };\n  static: boolean;\n  private: boolean;\n  addInitializer(initializer: () => void): void;\n}) => Function | void;\n```", "```\ntype ClassMemberDecoratorContext =\n    | ClassMethodDecoratorContext\n    | ClassGetterDecoratorContext\n    | ClassSetterDecoratorContext\n    | ClassFieldDecoratorContext\n    | ClassAccessorDecoratorContext\n    ;\n\n/**\n * The decorator context types provided to any decorator.\n */\ntype DecoratorContext =\n    | ClassDecoratorContext\n    | ClassMemberDecoratorContext\n    ;\n```", "```\nfunction log<This, Args extends any[], Return>(\n  value: (this: This, ...args: Args) => Return,\n  context: ClassMethodDecoratorContext\n): (this: This, ...args: Args) => Return {\n  return function (this: This, ...args: Args) {\n    console.log(`calling ${context.name.toString()}`);\n    return value.call(this, ...args);\n  };\n}\n```", "```\nclass Toggler {\n  @logField #toggled = false;\n\n  @log\n  toggle() {\n    this.#toggled = !this.#toggled;\n  }\n}\n```", "```\ntype ClassFieldDecorator = (value: undefined, context: {\n  kind: \"field\";\n  name: string | symbol;\n  access: { get(): unknown, set(value: unknown): void };\n  static: boolean;\n  private: boolean;\n}) => (initialValue: unknown) => unknown | void;\n```", "```\ntype FieldDecoratorFn = (val: any) => any;\n\nfunction logField<Val>(\n  value: undefined,\n  context: ClassFieldDecoratorContext\n): FieldDecoratorFn {\n  return function (initialValue: Val): Val {\n    console.log(`Initializing ${context.name.toString()} to ${initialValue}`);\n    return initialValue;\n  };\n}\n```", "```\nfunction log<This, Args extends any[], Return>(\n  value: (this: This, ...args: Args) => Return,\n  context: ClassMethodDecoratorContext\n): (this: This, ...args: Args) => Return;\nfunction log<Val>(\n  value: Val,\n  context: ClassFieldDecoratorContext\n): FieldDecoratorFn;\nfunction log(\n  value: any,\n  context: ClassMethodDecoratorContext | ClassFieldDecoratorContext\n) {\n  if (context.kind === \"method\") {\n    return logMethod(value, context);\n  } else {\n    return logField(value, context);\n  }\n}\n```", "```\nfunction log<This, Args extends any[], Return>(\n  value: (this: This, ...args: Args) => Return,\n  context: ClassMethodDecoratorContext\n) {\n  return function (this: This, ...args: Args) {\n    console.log(`calling ${context.name.toString()}`);\n    const val = value.call(this, ...args);\n    console.log(`called ${context.name.toString()}: ${val}`);\n    return val;\n  };\n}\n```", "```\nfunction isPromise(val: any): val is Promise<unknown> {\n  return (\n    typeof val === \"object\" &&\n    val &&\n    \"then\" in val &&\n    typeof val.then === \"function\"\n  );\n}\n```", "```\nfunction logMethod<This, Args extends any[], Return>(\n  value: (this: This, ...args: Args) => Return,\n  context: ClassMethodDecoratorContext\n): (this: This, ...args: Args) => Return {\n  return function (this: This, ...args: Args) {\n    console.log(`calling ${context.name.toString()}`);\n    const val = value.call(this, ...args);\n    if (isPromise(val)) {\n      val.then((p: unknown) => {\n        console.log(`called ${context.name.toString()}: ${p}`);\n        return p;\n      });\n    } else {\n      console.log(`called ${context.name.toString()}: ${val}`);\n    }\n\n    return val;\n  };\n}\n```"]