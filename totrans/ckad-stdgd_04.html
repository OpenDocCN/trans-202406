<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Containers" class="praise"><div class="dedication" id="containers">
<h1 class="calibre14"><span class="keep-together">Chapter 4. </span>Containers</h1>


<p class="author1">Kubernetes is a container orchestrator that uses a container runtime to instantiate containers inside of Pods. Many Kubernetes clusters with version 1.24 or later use the container runtime <a href="https://containerd.io/" class="calibre10">containerd</a>.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Container runtime used on a Kubernetes node</h1>
<p class="author1">You can fetch information about the container runtime used on any node of a Kubernetes cluster. Simply look at the output of the <code class="calibre15">CONTAINER-RUNTIME</code> column produced by running the command <code class="calibre15">kubectl get nodes -o wide</code>. Check the <a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" class="calibre10">Kubernetes documentation</a> to learn more about configuring a container runtime for a 
<span class="keep-together">cluster.</span></p>
</div>

<p class="author1">For the exam, you are expected to understand the practical aspects of defining, building, and publishing container images, which this chapter covers. We’ll also touch on running a container image inside of a container. For all of those operations, we’ll use Docker Engine as the example container runtime though similar functionality is provided by other implementations.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id471">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Define, build, and modify container images</p>
</li>
</ul>
</div></aside>

<p class="author1">The discussion on containers in this book only scratches the surface. There’s a lot more information on this topic if you want to fully immerse yourself. I can recommend the book <a href="https://learning.oreilly.com/library/view/docker-up/9781098131814/" class="calibre10"><em class="calibre3">Docker: Up &amp; Running</em></a> (O’Reilly) by Sean P. Kane and Karl Matthias for a detailed explanation of Docker.</p>






<section data-type="sect1" data-pdf-bookmark="Container Terminology" class="praise"><div class="dedication" id="id160">
<h1 class="calibre17">Container Terminology</h1>

<p class="author1">A <em class="calibre3">container</em> packages an application into a single unit of software including its 
<span class="keep-together">runtime</span> environment and configuration. This unit of software usually includes the operating system, the application’s source code or the binary, its dependencies, and other needed system tools. The declared goal of a container is to decouple the runtime environment from the application to avoid the “but it works on my machine” 
<span class="keep-together">problem.</span></p>

<p class="author1">The <em class="calibre3">container runtime engine</em> is the software component that can run containers on a host operating system. Examples include <a href="https://docs.docker.com/engine/" class="calibre10">Docker Engine</a> or <a href="https://containerd.io/" class="calibre10">containerd</a>. A <em class="calibre3">container orchestrator</em> uses a container runtime engine to instantiate a container while adding sophisticated features like scalability and networking across the workload. Kubernetes is an example of container orchestrators. Other tools like <a href="https://www.nomadproject.io/use-cases/simple-container-orchestration" class="calibre10">Nomad</a> are capable of scheduling various types of workload including containers.</p>

<p class="author1">The process of bundling an application into a container is called <em class="calibre3">containerization</em>. Containerization works based on instructions defined in a <em class="calibre3">container file</em>. The Docker community calls this a Dockerfile. The Dockerfile explicitly spells out what needs to happen when the software is built. The result of the operation is a <em class="calibre3">container image</em>.</p>

<p class="author1">The container image is usually published to a <em class="calibre3">container registry</em> for consumption by other stakeholders. <a href="https://hub.docker.com" class="calibre10">Docker Hub</a> is the primary registry for container images available for public use. Other public registries like GCR and Quay are available. <a data-type="xref" href="#containerization_process" class="calibre10">Figure 4-1</a> illustrates the concepts in the context of containerizing an application.</p>

<figure class="calibre35"><div id="containerization_process" class="figure">
<img src="Images/ckd2_0401.png" alt="ckd2 0401" class="calibre50"/>
<h6 class="calibre32"><span class="keep-together">Figure 4-1. </span>Containerization process</h6>
</div></figure>

<p class="author1">To summarize, the Dockerfile is a blueprint of how the software should be packaged, the image is the artifact produced by the process, and the container is a running instance of the image serving the application. We’ll look at a more concrete example next.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Containerizing a Java-Based Application" class="praise"><div class="dedication" id="id161">
<h1 class="calibre17">Containerizing a Java-Based Application</h1>

<p class="author1">Let’s assume we want to containerize a web application written in Java. The application doesn’t write core functionality from scratch but uses the <a href="https://oreil.ly/Na9Vb" class="calibre10">Spring Boot framework</a> as an external library. In addition, we want to control the runtime behavior with the help of environment variables. For example, you may want to provide URLs and credentials to connect to other services like a database. We’ll talk through the process step by step and execute the relevant Docker commands from the terminal. If you want to follow along, you can download a sample application from the project generator <a href="https://oreil.ly/bXSA4" class="calibre10">Spring Initializr</a>.</p>








<section data-type="sect2" data-pdf-bookmark="Writing a Dockerfile" class="praise"><div class="dedication" id="id162">
<h2 class="calibre33">Writing a Dockerfile</h2>

<p class="author1">Before we can create the image, we have to write a Dockerfile. The Dockerfile can reside in any directory and is a plain-text file. The instructions that follow use the Azul JRE distribution of Java 21 as the base image. A base image contains the operating system and the necessary tooling, in this case Java.</p>

<p class="author1">Moreover, we include the binary file, an executable Java archive (JAR), into the directory <code class="calibre15">/app</code> of the image. Finally, we define the Java command that executes the program and expose the port 8080 to make the application accessible when run in a container. <a data-type="xref" href="#dockerfile_for_building_a_java_application" class="calibre10">Example 4-1</a> outlines a sample Dockerfile.</p>
<div id="dockerfile_for_building_a_java_application" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 4-1. </span>Dockerfile for building a Java application</h5>

<pre data-type="programlisting" data-code-language="docker" class="calibre47"><code class="k">FROM</code><code class="w"> </code><code class="s">azul/zulu-openjdk:21-jre</code><code class="w">                                 </code><a class="calibre10" id="co_containers_CO1-1" href="#callout_containers_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="k">WORKDIR</code><code class="w"> </code><code class="s">/app                                                  </code><a class="calibre10" id="co_containers_CO1-2" href="#callout_containers_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code class="calibre15">target/java-hello-world-0.0.1.jar</code><code class="w"> </code><code class="calibre15">java-hello-world.jar</code><code class="w">   </code><a class="calibre10" id="co_containers_CO1-3" href="#callout_containers_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a><code class="w">
</code><code class="k">ENTRYPOINT</code><code class="w"> </code><code class="p">[</code><code class="s">"java"</code><code class="p">,</code><code class="w"> </code><code class="s">"-jar"</code><code class="p">,</code><code class="w"> </code><code class="s">"/app/java-hello-world.jar"</code><code class="p">]</code><code class="w">      </code><a class="calibre10" id="co_containers_CO1-4" href="#callout_containers_CO1-4"><img src="Images/4.png" alt="4" class="calibre51"/></a><code class="w">
</code><code class="k">EXPOSE</code><code class="w"> </code><code class="s">8080                                                   </code><a class="calibre10" id="co_containers_CO1-5" href="#callout_containers_CO1-5"><img src="Images/5.png" alt="5" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_containers_CO1-1" href="#co_containers_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Defines the base image.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_containers_CO1-2" href="#co_containers_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Sets the working directory of a container. Any <code class="calibre15">RUN</code>, <code class="calibre15">CMD</code>, <code class="calibre15">ADD</code>, <code class="calibre15">COPY</code>, or <code class="calibre15">ENTRYPOINT</code> instruction will be executed in the specified working directory.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_containers_CO1-3" href="#co_containers_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Copies the JAR containing the compiled application code into the working 
<span class="keep-together">directory.</span></p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_containers_CO1-4" href="#co_containers_CO1-4"><img src="Images/4.png" alt="4" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Sets the default command that executes when a container starts from an image.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_containers_CO1-5" href="#co_containers_CO1-5"><img src="Images/5.png" alt="5" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Documents the network port(s) the container should listen on.</p></dd>
</dl>

<p class="author1">While writing Dockerfile looks straightforward to beginners, optimizing the container image for a small footprint and security aspects isn’t. You can find a more detailed list of best practices for writing Dockerfiles in the <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" class="calibre10">Docker documentation</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Building the Container Image" class="praise"><div class="dedication" id="id163">
<h2 class="calibre33">Building the Container Image</h2>

<p class="author1">With the Dockerfile in place, we can create the image. The following command provides the name of the image and the tag. The last argument points to the context directory. A context directory contains the Dockerfile as well as any directories and files to be included in the image. Here, the context directory is the current directory we reside in referenced by “ . ”:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker build -t java-hello-world:1.1.0 .</strong>
[+] Building 2.0s (9/9) FINISHED
 =&gt; [internal] load .dockerignore
 =&gt; =&gt; transferring context: 2B
 =&gt; [internal] load build definition from Dockerfile
 =&gt; =&gt; transferring dockerfile: 284B
 =&gt; [internal] load metadata for docker.io/azul/zulu-openjdk:21-jre
 =&gt; [auth] azul/zulu-openjdk:pull token for registry-1.docker.io
 =&gt; [1/3] FROM docker.io/azul/zulu-openjdk:21-jre@sha256:d1e675cac0e5...
 =&gt; =&gt; resolve docker.io/azul/zulu-openjdk:21-jre@sha256:d1e675cac0e5...
 =&gt; =&gt; sha256:d1e675cac0e5ce9604283df2a6600d3b46328d32d83927320757ca7...
 =&gt; =&gt; sha256:67aa3090031eac26c946908c33959721730e42f9195f4f70409e4ce...
 =&gt; =&gt; sha256:ba408da684370e4d8448bec68b36fadf15c3819b282729df3bc8494...
 =&gt; [internal] load build context
 =&gt; =&gt; transferring context: 19.71MB
 =&gt; [2/3] WORKDIR /app
 =&gt; [3/3] COPY target/java-hello-world-0.0.1.jar java-hello-world.jar
 =&gt; exporting to image
 =&gt; =&gt; exporting layers
 =&gt; =&gt; writing image sha256:4b676060678b63de137536da24a889fc9d2d5fe0c...
 =&gt; =&gt; naming to docker.io/library/java-hello-world:1.1.0

What's Next?
  View a summary of image vulnerabilities and recommendations → ...
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Listing Container Images" class="praise"><div class="dedication" id="id164">
<h2 class="calibre33">Listing Container Images</h2>

<p class="author1">As indicated by the terminal output, the image has been created. You might have noticed that the base image has been downloaded as part of the process. The generated image can be found in your local Docker Engine cache by running the following command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker images</strong>
REPOSITORY         TAG       IMAGE ID       CREATED          SIZE
java-hello-world   1.1.0     4b676060678b   49 seconds ago   342MB
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Running the Container" class="praise"><div class="dedication" id="id165">
<h2 class="calibre33">Running the Container</h2>

<p class="author1">It’s time to run the application in a container. The <code class="calibre15">run</code> command points to an image and executes its logic in a container:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker run -d -p 8080:8080 java-hello-world:1.1.0</strong>
b0ee04accf078ea7c73cfe3be0f9d1ac6a099ac4e0e903773bc6bf6258acbb66
</pre>

<p class="author1">We told the command to forward the port 8080 accessible on localhost to the container port 8080 using the <code class="calibre15">-p</code> CLI option. The <code class="calibre15">-d</code> CLI option runs the container in the background, which means it will detach from the container and return to the terminal prompt. This means we should now be able to resolve the application’s 
<span class="keep-together">endpoint</span> from the local machine. As the following command shows, a simple <code class="calibre15">curl</code> to the root context path renders the message “Hello World!”:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ curl localhost:8080</strong>
Hello World!
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Listing Containers" class="praise"><div class="dedication" id="id166">
<h2 class="calibre33">Listing Containers</h2>

<p class="author1">Any running containers can be listed to display their runtime properties. The following command renders the container started earlier. The output includes the container ID for later reference. Add the flag <code class="calibre15">-a</code> to render terminated containers as well:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker container ls</strong>
CONTAINER ID   IMAGE                    COMMAND                  ...
b0ee04accf07   java-hello-world:1.1.0   "java -jar /app/java…"   ...
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Interacting with the Container" class="praise"><div class="dedication" id="id167">
<h2 class="calibre33">Interacting with the Container</h2>

<p class="author1">Once the container has been started, you can interact with it. All you need is the container ID. Use the <code class="calibre15">logs</code> command to inspect log messages produced by the application. Inspecting logs can be helpful for troubleshooting. The following command renders the log messages produced by Spring Boot upon container startup:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker logs b0ee04accf07</strong>
...
2023-06-19 21:06:27.757  INFO 1 --- [nio-8080-exec-1] \
o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing \
Spring DispatcherServlet 'dispatcherServlet'
2023-06-19 21:06:27.757  INFO 1 --- [nio-8080-exec-1] \
o.s.web.servlet.DispatcherServlet        : Initializing \
Servlet 'dispatcherServlet'
2023-06-19 21:06:27.764  INFO 1 --- [nio-8080-exec-1] \
o.s.web.servlet.DispatcherServlet        : Completed \
initialization in 7 ms
</pre>

<p class="author1">You can dig deeper into the internals of running containers if the container image is packaged with a command-line shell. For example, you may want to inspect files consumed or produced by the application. Use the <code class="calibre15">exec</code> command to run a command in the container. The flag <code class="calibre15">-it</code> allows for iterating with the container until you are ready to exit out of it. The following command opens an iterative bash shell to the running container:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker exec -it b0ee04accf07 bash</strong>
root@b0ee04accf07:/app# pwd
/app
root@b0ee04accf07:/app# exit
exit
</pre>

<p class="author1">To leave the interactive bash shell, run the <code class="calibre15">exit</code> command. You’ll return to the terminal prompt on your host machine.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Publishing the Container Image" class="praise"><div class="dedication" id="id168">
<h2 class="calibre33">Publishing the Container Image</h2>

<p class="author1">To publish an image to a registry, you’ll have to do some prework. Most registries require you to provide a prefix that signifies the username or hostname as part of the container image name, which you can achieve with the <code class="calibre15">tag</code> command.</p>

<p class="author1">For example, Docker Hub requires you to provide the username. My username is <code class="calibre15">bmuschko</code> and therefore I have to retag my image before pushing it:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker tag java-hello-world:1.1.0 bmuschko/java-hello-world:1.1.0</strong>
</pre>

<p class="author1">The <code class="calibre15">tag</code> command does not create a copy of the container image. It simply adds another identifier pointing to the existing container image, as shown in the following output. The image ID and size of the container image is the same for both entries:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker images</strong>
REPOSITORY                  TAG       IMAGE ID       CREATED         SIZE
bmuschko/java-hello-world   1.1.0     4b676060678b   6 minutes ago   342MB
java-hello-world            1.1.0     4b676060678b   6 minutes ago   342MB
</pre>

<p class="author1">If the registry is protected, you’ll also have to provide the credentials. For Docker Hub, we are logging in with username:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker login --username=bmuschko</strong>
Password: *****
Login Succeeded
</pre>

<p class="author1">Finally, you can push the image to the registry using the <code class="calibre15">push</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker push bmuschko/java-hello-world:1.1.0</strong>
The push refers to repository [docker.io/bmuschko/java-hello-world]
a7b86a39983a: Pushed
df1b2befe5f0: Pushed
e4db97f0e9ef: Mounted from azul/zulu-openjdk
8e87ff28f1b5: Mounted from azul/zulu-openjdk
1.1.0: digest: sha256:6a5069bd9396a7eded10bf8e24ab251df434c121f8f4293c2d3ef...
</pre>

<p class="author1">You can discover the published container image through the Docker Hub web page, as shown in <a data-type="xref" href="#dockerhub_ui_image" class="calibre10">Figure 4-2</a>. The “Tags” tab lists all available tags for the image including their details and quick reference to the <code class="calibre15">docker</code> command for pulling the image.</p>

<figure class="calibre35"><div id="dockerhub_ui_image" class="figure">
<img src="Images/ckd2_0402.png" alt="ckd2 0402" class="calibre54"/>
<h6 class="calibre32"><span class="keep-together">Figure 4-2. </span>Discovering container images on Docker Hub</h6>
</div></figure>

<p class="author1">Anyone with access to the registry can now consume the container image using the <code class="calibre15">pull</code> command.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Saving and Loading a Container Image" class="praise"><div class="dedication" id="id169">
<h2 class="calibre33">Saving and Loading a Container Image</h2>

<p class="author1">Instead of publishing a container image to a container registry, you may want to save it to a file. Files can be easily stored and backed up on a shared drive and don’t require a container registry. The <code class="calibre15">save</code> command saves one or many images to a tar archive. The resulting archive file contains all parent layers, and all tags + versions. The following command saves the container image to the file <code class="calibre15">java-hello-world.tar</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker save -o java-hello-world.tar java-hello-world:1.1.0</strong>
</pre>

<p class="author1">To load a container image from a tar archive, use the <code class="calibre15">load</code> command. The command restores both images and tags. The following command loads the container image from the file <code class="calibre15">java-hello-world.tar</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker load --input java-hello-world.tar</strong>
Loaded image: java-hello-world:1.1.0
</pre>

<p class="author1">The image is now available in the cache, as shown by running the <code class="calibre15">images</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ docker images</strong>
REPOSITORY         TAG       IMAGE ID       CREATED         SIZE
java-hello-world   1.1.0     4b676060678b   7 minutes ago   342MB
</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Going Further" class="praise"><div class="dedication" id="id170">
<h1 class="calibre17">Going Further</h1>

<p class="author1">Thus far you have experienced the most common developer workflows: containerizing an application and pushing the image to a registry. There’s far more to learn about building and running containers, but that is outside the scope of this book, and we won’t dive any deeper here. If you’d like to learn more, a good starting point is the <a href="https://docs.docker.com" class="calibre10">Docker documentation</a>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id171">
<h1 class="calibre17">Summary</h1>

<p class="author1">Application developers use containerization to bundle the application code into a container image so that it can be deployed to Kubernetes clusters as a single unit of runnable software. The containerization process defines, builds, runs, and publishes 
<span class="keep-together">a container</span> image using a container runtime engine. In this chapter, we used Docker Engine to demonstrate the process for a Java-based application; however, the steps involved would look similar for applications written in a different programming 
<span class="keep-together">language.</span></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id172">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Gain practical experience with the containerization process</dt>
<dd class="calibre20">
<p class="calibre21">Pods run container images inside of a container. You need to understand how 
<span class="keep-together">to define,</span> build, run, and publish a container image apart from Kubernetes. Practice the use of the container runtime engine’s command-line tool to fulfill the 
<span class="keep-together">workflow.</span></p>
</dd>
<dt class="calibre19">Compare the functionality of different container runtime engines</dt>
<dd class="calibre20">
<p class="calibre21">You should get familiar with Docker Engine specifically for understanding the containerization process. At the time of writing, Docker Engine is still the most widely used container runtime engine. Branch out by playing around with other container runtime engines like containerd or Podman.</p>
</dd>
<dt class="calibre19">Familiarize yourself with other workflows</dt>
<dd class="calibre20">
<p class="calibre21">As an application developer, you will deal with defining, building, and modifying container images daily. Container runtime engine support other, less-known features and workflows. It can’t hurt to read through the container runtime engine’s documentation to gain broader exposure.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id173">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_000.xhtml#appendix_a_containers" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Navigate to the directory <em class="calibre3">app-a/ch04/containerized-java-app</em> of the checked-out GitHub repository <a href="https://github.com/bmuschko/ckad-study-guide" class="calibre10"><em class="calibre3">bmuschko/ckad-study-guide</em></a>. Inspect the <em class="calibre3">Dockerfile</em>.</p>

<p class="author1">Build the container image from the <em class="calibre3">Dockerfile</em> with the tag <code class="calibre15">nodejs-hello-world:1.0.0</code>.</p>

<p class="author1">Run a container with the container image. Make the application available on port 80.</p>

<p class="author1">Execute a <code class="calibre15">curl</code> or <code class="calibre15">wget</code> command against the application’s endpoint.</p>

<p class="author1">Retrieve the container logs.</p>
</li>
<li class="calibre56">
<p class="author1">Modify the <em class="calibre3">Dockerfile</em> from the previous exercise. Change the base image to the tag <code class="calibre15">20.4-alpine</code> and the working directory to <code class="calibre15">/node</code>.</p>

<p class="author1">Build the container image from the <em class="calibre3">Dockerfile</em> with the tag <code class="calibre15">nodejs-hello-world:1.1.0</code>.</p>

<p class="author1">Ensure that container image has been created by listing it.</p>
</li>
<li class="calibre56">
<p class="author1">Pull the container image <code class="calibre15">alpine:3.18.2</code> <a href="https://hub.docker.com/layers/library/alpine/3.18.2/images/sha256-25fad2a32ad1f6f510e528448ae1ec69a28ef81916a004d3629874104f8a7f70?context=explore" class="calibre10">available on Docker Hub</a>.</p>

<p class="author1">Save the container image to the file <em class="calibre3">alpine-3.18.2.tar</em>.</p>

<p class="author1">Delete the container image. Verify the container image is not listable anymore.</p>

<p class="author1">Reinstate the container image from the file <em class="calibre3">alpine-3.18.2.tar</em>.</p>

<p class="author1">Verify that the container image can be listed.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>