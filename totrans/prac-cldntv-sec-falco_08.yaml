- en: Chapter 6\. Fields and Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s finally time to take all the theory you learned in the previous chapters
    and start putting it into practice. In this chapter you will learn about Falco
    filters: what they are, how they work, and how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Filters are at the core of Falco. They are also a powerful investigation instrument
    that can be used in several other tools, such as sysdig. As a consequence, we
    expect that you will come back and consult this chapter often, even after finishing
    the book—so we’ve structured it to be used as a reference. For example, it contains
    tables with all of the operators and data types the filtering language provides,
    designed for quick consultation, as well as a well-documented list of Falco’s
    most useful fields. This chapter’s contents will be handy pretty much every time
    you write a Falco rule, so make sure to bookmark it!
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Filter?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with a semiformal definition:'
  prefs: []
  type: TYPE_NORMAL
- en: A *filter* in Falco is a condition containing a sequence of comparisons that
    are connected by Boolean operators. Each of the comparisons evaluates a field,
    which is extracted from an input event, against a constant, using a relational
    operator. Comparisons in filters are evaluated left to right, but parentheses
    can be used to define precedence. A filter is applied to an input event and returns
    a Boolean result indicating if the event matches the filter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Ouch. That description is extremely dry and somewhat complicated. But if we
    unpack it, with the aid of some examples, you’ll see it’s not too bad. Let’s start
    with the first sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: A *filter* in Falco is a condition containing a sequence of comparisons that
    are connected by Boolean operators.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This just means that a filter looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, if you can write an `if` condition in any programming language,
    the filter syntax will look very familiar. Here’s the next sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the comparisons evaluates a field, which is extracted from an input
    event, against a constant, using a relational operator.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This tells us that Falco’s filtering syntax is based on the concept of *fields*,
    which we will describe in detail later in this chapter. Field names have a dotted
    syntax and appear on the left side of each comparison. On the right side is a
    constant value that will be compared against the field. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons in filters are evaluated left to right, but parentheses can be used
    to define precedence.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This means you can organize your filter using parentheses. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this works exactly the same as using parentheses inside a logical expression
    in your favorite programming language. Now for the final sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: A filter is applied to an input event and returns a Boolean result indicating
    if the event matches the filter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When you specify a filter in a Falco rule, the filter is applied to every input
    event. For example, if you’re using one of Falco’s drivers, filters are applied
    to every system call. The filter evaluates the system call and returns a Boolean
    value: `true` or `false`. `true` means that the event satisfies the filter (we
    say that the filter *matches* the event), while `false` means that the filter
    rejects, or drops, the event. For example, this filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: matches (returns `true` for) every system call generated by processes called
    `emacs` or `vi`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s essentially all you need to know at a high level. Now let’s dive into
    the details.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Syntax Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a syntactical point of view, as we mentioned, writing a Falco filter is
    very similar to writing an `if` condition in any programming language, so if you
    have basic programming experience, you shouldn’t expect any major surprises. However,
    there are some areas that are specific to the type of matching you do in Falco.
    This section takes a look at the syntax in detail, giving you the full picture.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 6-1](#falcoapostrophes_relational_operators) provides a reference of
    all of the available relational operators, including an example for each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Falco’s relational operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `=`, `!=` | General equality/inequality operators. Can be used with all types
    of fields. | `proc.name = emacs` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=`, `<`, `>=`, `>` | Numeric comparison operators. Can be used with numeric
    fields only. | `evt.buflen > 100` |'
  prefs: []
  type: TYPE_TB
- en: '| `contains` | Can be used with string fields only. Performs a case-sensitive
    string search for the given constant inside the field value, and returns `true`
    if the field value contains the constant. | `fd.filename contains passwd` |'
  prefs: []
  type: TYPE_TB
- en: '| `icontains` | Like `contains`, but case-insensitive. | `user.name icontains
    john` |'
  prefs: []
  type: TYPE_TB
- en: '| `bcontains` | Like `contains`, but allows you to perform checks on binary
    buffers. | `evt.buf bcontains DEADBEEF` |'
  prefs: []
  type: TYPE_TB
- en: '| `startswith` | Can be used with string fields only. Returns `true` if the
    given constant matches the beginning of the field value. | `fd.directory startswith
    "/etc"` |'
  prefs: []
  type: TYPE_TB
- en: '| `bstartswith` | Like `startswith`, but allows you to perform checks on binary
    buffers. | `evt.buf bstartswith DEADBEEF` |'
  prefs: []
  type: TYPE_TB
- en: '| `endswith` | Can be used with string fields only. Returns `true` if the given
    constant matches the end of the field value. | `fd.filename endswidth ".key"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Compares the field value to multiple constants and returns `true`
    if one or more of those constants equals the field value. Can be used with all
    fields, including numeric fields and string fields. | `proc.name in (vi, emacs)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `intersects` | Returns `true` when a field with multiple values includes
    at least one value that matches one of the provided constants. | `ka.req.pod.volumes.hostpath
    intersects (/proc, /var/run/docker.sock)` |'
  prefs: []
  type: TYPE_TB
- en: '| `pmatch` | Returns `true` if one of the constants is a prefix of the field
    value. Note: `pmatch` can be used as an alternative to the `in` operator, and
    performs better with large sets of constants because it is implemented internally
    as a trie instead of multiple comparisons. | `fd.name pmatch (/var/run, /etc,
    /lib, /usr/lib)` `fd.name = /var/run/docker` succeeds because `/var/run` is a
    prefix of `/var/run/docker`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fd.name = /boot` does not succeed because no constant is a prefix of `/boot`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fd.name = /var` does not succeed because no constant is a prefix of `/var`.
    |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `exists` | Returns `true` if the given field exists for the input event.
    | `evt.res exists` |'
  prefs: []
  type: TYPE_TB
- en: '| `glob` | Matches the given string against the field value according to Unix
    shell wildcard patterns. For more details, enter `**man 7 glob**` in your terminal.
    | `fd.name glob ''/home/*/.ssh/*''` |'
  prefs: []
  type: TYPE_TB
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logical operators that you can use in Falco filters are straightforward
    and don’t include any surprises. [Table 6-2](#falcoapostrophes_logical_operators)
    lists them and provides examples.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. Falco’s logical operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | `proc.name = emacs and proc.cmdline contains myfile.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | `proc.name = emacs or proc.name = vi` |'
  prefs: []
  type: TYPE_TB
- en: '| `not` | `not proc.name = emacs` |'
  prefs: []
  type: TYPE_TB
- en: Strings and Quoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'String constants can be specified without quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Quotes can, however, be used to enclose strings that include spaces or special
    characters. Both single quotes and double quotes are accepted. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This means you can include quotes in strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, Falco filters are not very complicated. However, they are extremely
    flexible and powerful. This power comes from the fields you can use in filtering
    conditions. Falco gives you access to a variety of fields, each of which exposes
    a property of the input events that Falco captures. Since fields are so important,
    let’s take a look at how they work and how they are organized. Then we’ll discuss
    which ones to use and when.
  prefs: []
  type: TYPE_NORMAL
- en: Argument Fields Versus Enrichment Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields expose properties of input events as typed values. A field, for example,
    can be a string, like the process name, or a number, like the process ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the highest level, Falco offers two categories of fields. The first category
    includes the fields that are obtained by dissecting input events. System call
    arguments, like the filename for an `open` system call or the buffer argument
    for a `read` system call, are examples of such fields. You access these fields
    with the following syntax, where `*X*` is the name of the argument you want to
    access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'or, where `*N*` is the position of the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To find out which arguments a specific event type supports, sysdig is your friend.
    The output line for an event in sysdig will show you all of its arguments and
    their names.
  prefs: []
  type: TYPE_NORMAL
- en: The second category consists of fields that derive from the enrichment process
    that *libsinsp* performs while capturing system calls and other events, described
    in [Chapter 5](ch05.xhtml#data_enrichment). Falco exports many fields that expose
    the content of *libsinsp*’s thread and file descriptor tables, adding rich context
    about the events received from the drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you understand how this works, let’s take the `proc.cwd` field as an
    example. For each system call that Falco captures, this field contains the current
    working directory of the process that issued the system call. This is handy if
    you want to capture all of the system calls generated by processes that are currently
    running inside a specific directory; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The working directory of the process is not part of the system call, so exposing
    this field requires tracking the working directory of a process and attaching
    it to every system call that the process generates. This, in turn, involves four
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect the working directory when a process starts, and store it in the process’s
    entry in the thread table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep track of when the process changes its working directory (by intercepting
    and parsing the `chdir` system call), and update the thread table entry accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resolve the thread ID of every system call to identify the corresponding thread
    table entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the thread table entry’s `cwd` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*libsinsp* does all of this, which means that the `proc.cwd` field is available
    for every system call, not only for directory-related ones like `chdir`. It’s
    impressive how much hard work Falco does to expose this field to you!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enrichment-based filtering is powerful because it allows you to filter system
    calls (and any other events) based on properties that are not included with the
    syscalls themselves, but are of great use for security policies. For example,
    the following filter allows you to capture the system calls that read from or
    write to */etc/passwd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It works even if these system calls originally don’t contain any information
    about the filename (they operate on file descriptors). The hundreds of enrichment-based
    fields available out of the box are the main reason why Falco is so powerful and
    versatile.
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory Fields Versus Optional Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some fields exist for every input event, and you will be guaranteed to find
    them regardless of the event type or family. Examples of such fields are `evt.ts`,
    `evt.dir`, and `evt.type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, most fields are optional and only present in some input event types.
    Typically, you don’t have to worry about this, as fields that don’t exist will
    just evaluate to `false` without generating an error. For example, the following
    check will evaluate to `false` for all events that don’t have an argument called
    `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, though, you might want to explicitly check if a field exists.
    One reason would be to resolve ambiguities like whether the filter `evt.arg.name
    != /etc` returns `true` or `false` for events that don’t have an argument called
    `name`. You can answer questions like this by using the `exists` relational operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Field Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fields have types, which are used to validate values and ensure the syntactic
    correctness of filters. Take the following filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Falco and sysdig will reject this with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This happens because the `proc.pid` field is of type `INT64`, so its value must
    be an integer. The typing system also allows Falco to improve the rendering of
    some fields by understanding the meaning behind them. For example, `evt.arg.res`
    is of type `ERRNO`, which by default is a number. However, when possible, Falco
    will resolve it into an error code string (such as `EAGAIN`), which improves the
    readability and usability of the field.
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at relational operators, we noted how some are very similar to
    the ones in most programming languages, while others are unique to Falco filters.
    The same is true for field types. [Table 6-3](#field_type) lists the types you
    may encounter in Falco filter fields.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3\. Field types
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `INT8`, `INT16`, `INT32`, `INT64`, `UINT8`, `UINT16`, `UINT32`, `UINT64`,
    `DOUBLE` | Numeric types, like in your favorite programming language. |'
  prefs: []
  type: TYPE_TB
- en: '| `CHARBUF` | A printable buffer of characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `BYTEBUF` | A raw buffer of bytes not suitable for printing. |'
  prefs: []
  type: TYPE_TB
- en: '| `ERRNO` | An `INT64` value that, when possible, is resolved to an error code.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FD` | An `INT64` value that, when possible, is resolved to the value of
    the file descriptor. For example, for a file this gets resolved to the filename;
    for a socket it gets resolved to the TCP connection tuple. |'
  prefs: []
  type: TYPE_TB
- en: '| `PID` | An `INT64` value that, when possible, is resolved to the process
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `FSPATH` | A string containing a relative or absolute filesystem path. |'
  prefs: []
  type: TYPE_TB
- en: '| `SYSCALLID` | A 16-bit system call ID. When possible, the value gets resolved
    to the system call name. |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTYPE` | An 8-bit signal number that, when possible, gets resolved to
    the signal name (e.g., `SIGCHLD`). |'
  prefs: []
  type: TYPE_TB
- en: '| `RELTIME` | A relative time, with nanosecond precision, rendered as a human-readable
    string. |'
  prefs: []
  type: TYPE_TB
- en: '| `ABSTIME` | An absolute time interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `PORT` | A TCP/UDP port. When possible, this gets resolved to a protocol
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `L4PROTO` | A 1-byte IP protocol type. When possible, this gets resolved
    to a L4 protocol name (TCP, UDP). |'
  prefs: []
  type: TYPE_TB
- en: '| `BOOL` | A Boolean value. |'
  prefs: []
  type: TYPE_TB
- en: '| `IPV4ADDR` | An IPv4 address. |'
  prefs: []
  type: TYPE_TB
- en: '| `DYNAMIC` | An indication that the field type can vary depending on the context.
    Used for generic fields like `evt.rawarg`. |'
  prefs: []
  type: TYPE_TB
- en: '| `FLAGS8`, `FLAGS16`, `FLAGS32` | A flags word (i.e., a set of flags encoded
    as a number using binary encoding) that, when possible, is converted into a readable
    string (e.g., `O_RDONLY&#124;O_CLOEXEC`). The resolution into the string is dependent
    on the context, as events can register their own flag values. So, for example,
    flags for an lseek system call event will be converted into values like `SEEK_END`,
    `SEEK_CUR`, and `SEEK_SET`, while `sockopt` flags will be converted into `SOL_SOCKET`,
    `SOL_TCP`, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `UID` | A Unix user ID, resolved to a username when possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `GID` | A Unix group ID, resolved to a group name when possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `IPADDR` | An IPv4 or IPv6 address. |'
  prefs: []
  type: TYPE_TB
- en: '| `IPNET` | An IPv4 or IPv6 network. |'
  prefs: []
  type: TYPE_TB
- en: '| `MODE` | A 32-bit bitmask to represent file modes. |'
  prefs: []
  type: TYPE_TB
- en: 'How do you find out the type of a field you want to use? The best way is to
    invoke Falco with the `--list` and `-v` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will print the full list of fields, including type information for each
    entry in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Using Fields and Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve learned about filters and fields, let’s take a look at how you
    can use them in practice. We’ll focus on Falco and sysdig.
  prefs: []
  type: TYPE_NORMAL
- en: Fields and Filters in Falco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields and filters are at the core of Falco rules. Fields are used to express
    rules’ conditions and are part of both conditions and outputs. To demonstrate
    how, we’ll craft our own rule.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we would like Falco to notify us every time there is an attempt to
    change the permissions of a file and make it executable by another user. When
    that happens, we would like to know the name of the file that was changed, the
    new mode of the file, and the name of the user who caused the trouble. We would
    also like to know whether the mode change attempt was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `condition` section is where the rule’s filter is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'File modes, including the executable bit, are changed using the `chmod` system
    call, or one of its variants. Therefore, the first part of the filter selects
    events that are of type `chmod`, `fchmod`, or `fchmodat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the right system calls, we want to accept only the subset
    of them that set the “other” executable bit. Reading the [`chmod` manual page](https://oreil.ly/zuKuC)
    reveals that the flag we need to check is `S_IXOTH`. We determine its presence
    by using the `contains` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Combining the two pieces with an `and` gives us the full filter. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s focus our attention on the `output` section of the rule. This is
    where we tell Falco what to print on the screen when the rule’s condition returns
    `true`. You will notice that this is just a `printf`-like string that mixes regular
    text with fields, whose values will be resolved in the final message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only thing you need to remember is that you need to prefix field names in
    the output string with the `%` character; otherwise, they will just be treated
    as part of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for you to try this! Save the preceding rule in a file called *ch6.yaml*.
    After that, run this command line in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in another terminal, run these two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output you will get in the Falco terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you’ve just performed your very own Falco detection! Note how
    `evt.arg.mode` and `evt.failed` are rendered in a human-readable way, even if
    internally they are numbers. This shows you the power of the filter/fields type
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Fields and Filters in sysdig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An introduction to sysdig was provided in [Chapter 4](ch04.xhtml#data_source)
    (if you need a refresher, see [“sysdig”](ch04.xhtml#sysdig)). Here we will look
    specifically at how filters and fields are used in sysdig.
  prefs: []
  type: TYPE_NORMAL
- en: While Falco is based on the concepts of rules and of notifying the user when
    rules match, sysdig focuses on investigation, troubleshooting, and threat-hunting
    workflows. In sysdig, you use filters to *restrict* the input, and you (optionally)
    use field formatting to *control* the output. The combination of the two provides
    a ton of flexibility during investigations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filters in sysdig are specified at the end of the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Output formatting is provided using the `-p` command-line flag and uses the
    same `printf`-like syntax that we just described when talking about Falco outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'An important thing to keep in mind is that, when the `-p` flag is used, sysdig
    will only print an output line for the events in which *all* of the specified
    filters exist. So, this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'will print a line only for events that have both a return value *and* a process
    name, skipping, for example, all the system call “enter” events. If you care about
    seeing all of the events, put a star (`*`) at the beginning of the formatting
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When a field is missing, it will be rendered as `<NA>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When no formatting is specified with `-p`, sysdig displays input events in
    a standard format that conveniently includes all of the arguments and argument
    names, for every system call. Here’s an example sysdig output line for an `openat`
    system call, with the system call arguments highlighted in bold for visibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the arguments can be used in a filter with the `evt.arg` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As a more advanced example, let’s convert the *File Becoming Executable by
    Others* rule we created for Falco in the previous section into a sysdig command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This shows how easy it is to use sysdig as a development tool when creating
    new rules.
  prefs: []
  type: TYPE_NORMAL
- en: Falco’s Most Useful Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section presents a curated list of some of the most important Falco fields,
    organized by class. You can use this list as a reference when writing filters.
    For a full list, including all plugin fields, use the following at the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: General
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fields listed in [Table 6-4](#evt_filter_class_fields) apply to every event
    and include general properties of an event.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-4\. `evt` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.num` | The event number. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.time` | The event timestamp as a string that includes the nanosecond
    part. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.dir` | The event direction; can be either `>` for enter events or `<`
    for exit events. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.type` | The name of the event (e.g., `open`). |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.cpu` | The number of the CPU where this event happened. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.args` | All the event arguments, aggregated into a single string. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.rawarg` | One of the event arguments, specified by name (e.g., `evt.rawarg.fd`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.arg` | One of the event arguments, specified by name or by number. Some
    events (such as return codes or file descriptors) will be converted into a text
    representation when possible (e.g., `evt.arg.fd` or `evt.arg[0]`). |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.buffer` | The binary data buffer for events that have one, like read,
    recvfrom, etc. Use this field in filters with `contains` to search in I/O data
    buffers. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.buflen` | The length of the binary data buffer for events that have
    one, like `read`, `recvfrom`, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.res` | The event return value, as a string. If the event failed, the
    result is an error code string (e.g., `ENOENT`); otherwise, the result is the
    string `SUCCESS`. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.rawres` | The event return value, as a number (e.g., `-2`). Useful for
    range comparisons. |'
  prefs: []
  type: TYPE_TB
- en: '| `evt.failed` | `true` for events that returned an error status. |'
  prefs: []
  type: TYPE_TB
- en: Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fields in this class contain all the information you need about processes
    and threads. The information in [Table 6-5](#proc_filter_class_fields) comes mostly
    from the process table that *libsinsp* constructs in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-5\. `proc` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.pid` | The ID of the process generating the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.exe` | The first command-line argument (usually the executable name
    or a custom one). |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.name` | The name (excluding the path) of the executable generating
    the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.args` | The arguments passed on the command line when starting the
    process generating the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.env` | The environment variables of the process generating the event.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.cwd` | The current working directory of the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.ppid` | The PID of the parent of the process generating the event.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.pname` | The name (excluding the path) of the parent of the process
    generating the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.pcmdline` | The full command line (`proc.name` + `proc.args`) of the
    parent of the process generating the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.loginshellid` | The PID of the oldest shell among the ancestors of
    the current process, if there is one. This field can be used to separate different
    user sessions and is useful in conjunction with chisels like spy_user. |'
  prefs: []
  type: TYPE_TB
- en: '| `thread.tid` | The ID of the thread generating the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `thread.vtid` | The ID of the thread generating the event as seen from its
    current PID namespace. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.vpid` | The ID of the process generating the event as seen from its
    current PID namespace. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.sid` | The session ID of the process generating the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.sname` | The name of the current process’s session leader. This is
    either the process with `pid=proc.sid` or the eldest ancestor that has the same
    session ID as the current process. |'
  prefs: []
  type: TYPE_TB
- en: '| `proc.tty` | The controlling terminal of the process. This is `0` for processes
    without a terminal. |'
  prefs: []
  type: TYPE_TB
- en: File Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 6-6](#fd_filter_class_fields) lists the fields related to file descriptors,
    which are at the base of I/O. Fields containing details about files and directories,
    network connections, pipes, and other types of interprocess communication can
    all be found in this class.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-6\. `fd` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.num` | The unique number identifying the file descriptor. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.typechar` | The type of the file descriptor, as a single character. Can
    be `f` for file, `4` for IPv4 socket, `6` for IPv6 socket, `u` for Unix socket,
    `p` for pipe, `e` for eventfd, `s` for signalfd, `l` for eventpoll, `i` for inotify,
    or `o` for unknown. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.name` | The full name of the file descriptor. If it’s a file, this field
    contains the full path. If it’s a socket, this field contains the connection tuple.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.directory` | If the file descriptor is a file, the directory that contains
    it. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.filename` | If the file descriptor is a file, the filename without the
    path. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.ip` | *(Filter only)* Matches the IP address (client or server) of the
    file descriptor. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.cip` | The client’s IP address. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.sip` | The server’s IP address. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.lip` | The local IP address. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.rip` | The remote IP address. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.port` | *(Filter only)* Matches the port (either client or server) of
    the file descriptor. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.cport` | For TCP/UDP file descriptors, the client’s port. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.sport` | For TCP/UDP file descriptors, the server’s port. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.lport` | For TCP/UDP file descriptors, the local port. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.rport` | For TCP/UDP file descriptors, the remote port. |'
  prefs: []
  type: TYPE_TB
- en: '| `fd.l4proto` | The IP protocol of a socket. Can be `tcp`, `udp`, `icmp`,
    or `raw`. |'
  prefs: []
  type: TYPE_TB
- en: Users and Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 6-7](#user_and_group_filter_class_fields) lists the fields in the `user`
    and `group` filter classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-7\. `user` and `group` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `user.uid` | The user’s ID |'
  prefs: []
  type: TYPE_TB
- en: '| `user.name` | The user’s name |'
  prefs: []
  type: TYPE_TB
- en: '| `group.gid` | The group’s ID |'
  prefs: []
  type: TYPE_TB
- en: '| `group.name` | The group’s name |'
  prefs: []
  type: TYPE_TB
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fields in the `container` class ([Table 6-8](#container_filter_class_fields))
    can be used for everything related to containers, including obtaining IDs, names,
    labels, and mounts.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-8\. `container` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `container.id` | The container ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `container.name` | The container name. |'
  prefs: []
  type: TYPE_TB
- en: '| `container.image` | The container image name (e.g., `falcosecurity/falco:latest`
    for Docker). |'
  prefs: []
  type: TYPE_TB
- en: '| `con⁠tainer.image​.id` | The container image ID (e.g., `6f7e2741b66b`). |'
  prefs: []
  type: TYPE_TB
- en: '| `container​.privi⁠leged` | `true` for containers running as privileged, `false`
    otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `con⁠tainer​.mounts` | A space-separated list of mount information. Each
    item in the list has the format `*<source>*:*<dest>*:*<mode>*:*<rdrw>*:*<propagation>*`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `container.mount` | Information about a single mount, specified by number
    (e.g., `container.mount[0]`) or mount source (e.g., `con⁠tainer.mount[/usr/local]`).
    The pathname can be a glob (e.g., `container.mount[/usr/local/*]`), in which case
    the first matching mount will be returned. The information has the format `*<source>*:*<dest>*:*<mode>*:*<rdrw>*:*<propagation>*`.
    If there is no mount with the specified index or matching the provided source,
    this returns the string `"none"` instead of a NULL value. |'
  prefs: []
  type: TYPE_TB
- en: '| `container.image​.reposi⁠tory` | The container image repository (e.g., `falcosecurity/falco`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `con⁠tainer.image​.tag` | The container image tag (e.g., `stable`, `latest`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `con⁠tainer.image​.digest` | The container image registry digest (e.g., `sha256:d977378f890d445c15e51795296​e4e5062f109ce6da83e0a355fc4ad8699d27`).
    |'
  prefs: []
  type: TYPE_TB
- en: Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Falco is configured to interface with the Kubernetes API server, the fields
    in this class (listed in [Table 6-9](#keights_filter_class_fields)) can be used
    to fetch information about Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-9\. `k8s` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.pod.name` | The Kubernetes Pod name. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.pod.id` | The Kubernetes Pod ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.pod.label` | The Kubernetes Pod label (e.g., `k8s.pod.label.foo`). |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.rc.name` | The Kubernetes ReplicationController name. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.rc.id` | The Kubernetes ReplicationController ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.rc.label` | The Kubernetes ReplicationController label (e.g., `k8s.rc.label.foo`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.svc.name` | The Kubernetes Service name. Can return more than one value,
    concatenated. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.svc.id` | The Kubernetes Service ID. Can return more than one value,
    concatenated. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.svc.label` | The Kubernetes Service label (e.g., `k8s.svc.label.foo)`.
    Can return more than one value, concatenated. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.ns.name` | The Kubernetes namespace name. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.ns.id` | The Kubernetes namespace ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.ns.label` | The Kubernetes namespace label (e.g., `k8s.ns.label.foo`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.rs.name` | The Kubernetes ReplicaSet name. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.rs.id` | The Kubernetes ReplicaSet ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.rs.label` | The Kubernetes ReplicaSet label (e.g., `k8s.rs.label.foo`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.deploy⁠ment​.name` | The Kubernetes Deployment name. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.deployment.id` | The Kubernetes Deployment ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `k8s.deployment.label` | The Kubernetes Deployment label (e.g., `k8s.rs.label.foo`).
    |'
  prefs: []
  type: TYPE_TB
- en: CloudTrail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fields in the `cloudtrail` class (listed in [Table 6-10](#cloudtrail_filter_class_fields))
    are available when the CloudTrail plugin is configured. They allow you to build
    filters and formatters for AWS detections.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-10\. `cloudtrail` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.error` | The error code from the event. Will be `""` if there was no
    error. |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.src` | The source of the CloudTrail event (`eventSource` in the JSON).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.shortsrc` | The source of the CloudTrail event (`eventSource` in the
    JSON), without the `.amazonaws.com` trailer. |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.name` | The name of the CloudTrail event (`eventName` in the JSON). |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.user` | The user of the CloudTrail event (`userIdentity.userName` in
    the JSON). |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.region` | The region of the CloudTrail event (`awsRegion` in the JSON).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.srcip` | The IP address generating the event (`sourceIPAddress` in the
    JSON). |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.useragent` | The user agent generating the event (`userAgent` in the
    JSON). |'
  prefs: []
  type: TYPE_TB
- en: '| `ct.readonly` | `true` if the event only reads information (e.g., `DescribeInstances`),
    `false` if the event modifies the state (e.g., `RunInstances`, `CreateLoadBalancer`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s3.uri` | The S3 URI (`s3://*<bucket>*/*<key>*`). |'
  prefs: []
  type: TYPE_TB
- en: '| `s3.bucket` | The bucket name for S3 events. |'
  prefs: []
  type: TYPE_TB
- en: '| `s3.key` | The S3 key name. |'
  prefs: []
  type: TYPE_TB
- en: '| `ec2.name` | The name of the EC2 instance, typically stored in the instance
    tags. |'
  prefs: []
  type: TYPE_TB
- en: Kubernetes Audit Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields related to Kubernetes audit logs (listed in [Table 6-11](#keightsaudit_filter_class_fields))
    are available when the k8saudit plugin is configured. The k8saudit plugin is responsible
    for interfacing Falco with the Kubernetes audit logs facility. The fields exported
    by the plugin can be used to monitor several types of Kubernetes activities.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-11\. `k8saudit` filter class fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.user.name` | The name of the user performing the request |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.user.groups` | The groups to which the user belongs |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.verb` | The action being performed |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.uri` | The request URI as sent from client to server |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.uri.param` | The value of a given query parameter in the URI (e.g., when
    `uri=/foo?key=val`, `ka.uri.param[key]` is `val`) |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.target.name` | The target object’s name |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.target.namespace` | The target object’s namespace |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.target.resource` | The target object’s resource |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.configmap.name` | When the request object refers to a ConfigMap,
    the ConfigMap name |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.pod.containers.image` | When the request object refers to a Pod,
    the container’s images |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.pod.containers​.privi⁠leged` | When the request object refers to
    a Pod, the value of the `privileged` flag for all containers |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.pod.containers .add_capabilities` | When the request object refers
    to a Pod, all capabilities to add when running the container |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.role.rules` | When the request object refers to a role or cluster
    role, the rules associated with the role |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.role.rules.verbs` | When the request object refers to a role or cluster
    role, the verbs associated with the role’s rules |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.role.rules .resources` | When the request object refers to a role
    or cluster role, the resources associated with the role’s rules |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.req.service.type` | When the request object refers to a service, the
    service type |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.resp.name` | The response object’s name |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.response.code` | The response code |'
  prefs: []
  type: TYPE_TB
- en: '| `ka.response.reason` | The response reason (usually present only for failures)
    |'
  prefs: []
  type: TYPE_TB
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you are now a filtering expert! At this point, you should be
    able to read and understand Falco rules, and you are much closer to being able
    to write your own. In the next chapter, we will devote our attention to Falco’s
    outputs.
  prefs: []
  type: TYPE_NORMAL
