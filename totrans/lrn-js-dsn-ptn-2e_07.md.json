["```\n// Each of the following options will create a new empty object\nconst newObject = {};\n\n// or\nconst newObject = Object.create(Object.prototype);\n\n// or\nconst newObject = new Object();\n```", "```\n// ECMAScript 3 compatible approaches\n\n// 1\\. Dot syntax\n\n// Set properties\nnewObject.someKey = \"Hello World\";\n\n// Get properties\nvar key = newObject.someKey;\n\n// 2\\. Square bracket syntax\n\n// Set properties\nnewObject[\"someKey\"] = \"Hello World\";\n\n// Get properties\nvar key = newObject[\"someKey\"];\n\n// ECMAScript 5 only compatible approaches\n// For more information see: http://kangax.github.com/es5-compat-table/\n\n// 3\\. Object.defineProperty\n\n// Set properties\nObject.defineProperty( newObject, \"someKey\", {\n    value: \"for more control of the property's behavior\",\n    writable: true,\n    enumerable: true,\n    configurable: true\n});\n\n// 4\\. If this feels a little difficult to read, a short-hand could\n// be written as follows:\n\nvar defineProp = function ( obj, key, value ){\n  config.value = value;\n  Object.defineProperty( obj, key, config );\n};\n\n// To use, we then create a new empty \"person\" object\nvar person = Object.create( null );\n\n// Populate the object with properties\ndefineProp( person, \"car\",  \"Delorean\" );\ndefineProp( person, \"dateOfBirth\", \"1981\" );\ndefineProp( person, \"hasBeard\", false );\n\n// 5\\. Object.defineProperties\n\n// Set properties\nObject.defineProperties( newObject, {\n\n  \"someKey\": {\n    value: \"Hello World\",\n    writable: true\n  },\n\n  \"anotherKey\": {\n    value: \"Foo bar\",\n    writable: false\n  }\n\n});\n\n// Getting properties for 3\\. and 4\\. can be done using any of the\n// options in 1\\. and 2.\n```", "```\n// ES2015+ keywords/syntax used: const\n// Usage:\n\n// Create a race car driver that inherits from the person object\nconst driver = Object.create(person);\n\n// Set some properties for the driver\ndefineProp(driver, 'topSpeed', '100mph');\n\n// Get an inherited property (1981)\nconsole.log(driver.dateOfBirth);\n\n// Get the property we set (100mph)\nconsole.log(driver.topSpeed);\n```", "```\nclass Car {\n    constructor(model, year, miles) {\n        this.model = model;\n        this.year = year;\n        this.miles = miles;\n    }\n\n    toString() {\n        return `${this.model} has done ${this.miles} miles`;\n    }\n}\n\n// Usage:\n\n// We can create new instances of the car\nlet civic = new Car('Honda Civic', 2009, 20000);\nlet mondeo = new Car('Ford Mondeo', 2010, 5000);\n\n// and then open our browser console to view the output of\n// the toString() method being called on these objects\nconsole.log(civic.toString());\nconsole.log(mondeo.toString());\n```", "```\nclass Car {\n    constructor(model, year, miles) {\n        this.model = model;\n        this.year = year;\n        this.miles = miles;\n    }\n}\n\n// Note here that we are using Object.prototype.newMethod rather than\n// Object.prototype to avoid redefining the prototype object\n// We still could use Object.prototype for adding new methods,\n// because internally we use the same structure\n\nCar.prototype.toString = function() {\n    return `${this.model} has done ${this.miles} miles`;\n};\n\n// Usage:\nlet civic = new Car('Honda Civic', 2009, 20000);\nlet mondeo = new Car('Ford Mondeo', 2010, 5000);\n\nconsole.log(civic.toString());\nconsole.log(mondeo.toString());\n```", "```\nconst myObjectLiteral = {\n    variableKey: variableValue,\n    functionKey() {\n        // ...\n    }\n};\n```", "```\nconst myModule = {\n    myProperty: 'someValue',\n    // object literals can contain properties and methods.\n    // e.g., we can define a further object for module configuration:\n    myConfig: {\n        useCaching: true,\n        language: 'en',\n    },\n    // a very basic method\n    saySomething() {\n        console.log('Where is Paul Irish debugging today?');\n    },\n    // output a value based on the current configuration\n    reportMyConfig() {\n        console.log(\n            `Caching is: ${this.myConfig.useCaching ? 'enabled' : 'disabled'}`\n        );\n    },\n    // override the current configuration\n    updateMyConfig(newConfig) {\n        if (typeof newConfig === 'object') {\n            this.myConfig = newConfig;\n            console.log(this.myConfig.language);\n        }\n    },\n};\n\n// Outputs: What is Paul Irish debugging today?\nmyModule.saySomething();\n\n// Outputs: Caching is: enabled\nmyModule.reportMyConfig();\n\n// Outputs: fr\nmyModule.updateMyConfig({\n    language: 'fr',\n    useCaching: false,\n});\n\n// Outputs: Caching is: disabled\nmyModule.reportMyConfig();\n```", "```\nlet counter = 0;\n\nconst testModule = {\n  incrementCounter() {\n    return counter++;\n  },\n  resetCounter() {\n    console.log(`counter value prior to reset: ${counter}`);\n    counter = 0;\n  },\n};\n\n// Default export module, without name\nexport default testModule;\n\n// Usage:\n\n// Import module from path\nimport testModule from './testModule';\n\n// Increment our counter\ntestModule.incrementCounter();\n\n// Check the counter value and reset\n// Outputs: counter value prior to reset: 1\ntestModule.resetCounter();\n```", "```\n// A private counter variable\nlet myPrivateVar = 0;\n\n// A private function that logs any arguments\nconst myPrivateMethod = foo => {\n  console.log(foo);\n};\n\nconst myNamespace = {\n  // A public variable\n  myPublicVar: 'foo',\n\n  // A public function utilizing privates\n  myPublicFunction(bar) {\n    // Increment our private counter\n    myPrivateVar++;\n\n    // Call our private method using bar\n    myPrivateMethod(bar);\n  },\n};\n\nexport default myNamespace;\n```", "```\n// privates\n\nconst basket = [];\n\nconst doSomethingPrivate = () => {\n  //...\n};\n\nconst doSomethingElsePrivate = () => {\n  //...\n};\n\n// Create an object exposed to the public\nconst basketModule = {\n  // Add items to our basket\n  addItem(values) {\n    basket.push(values);\n  },\n\n  // Get the count of items in the basket\n  getItemCount() {\n    return basket.length;\n  },\n\n  // Public alias to a private function\n  doSomething() {\n    doSomethingPrivate();\n  },\n\n  // Get the total value of items in the basket\n  // The reduce() method applies a function against an accumulator and each\n  // element in the array (from left to right) to reduce it to a single value.\n  getTotal() {\n    return basket.reduce((currentSum, item) => item.price + currentSum, 0);\n  },\n};\n\nexport default basketModule;\n```", "```\n// Import module from path\nimport basketModule from './basketModule';\n\n// basketModule returns an object with a public API we can use\n\nbasketModule.addItem({\n  item: 'bread',\n  price: 0.5,\n});\n\nbasketModule.addItem({\n  item: 'butter',\n  price: 0.3,\n});\n\n// Outputs: 2\nconsole.log(basketModule.getItemCount());\n\n// Outputs: 0.8\nconsole.log(basketModule.getTotal());\n\n// However, the following will not work:\n\n// Outputs: undefined\n// This is because the basket itself is not exposed as a part of our\n// public API\nconsole.log(basketModule.basket);\n\n// This also won't work as it exists only within the scope of our\n// basketModule closure, not in the returned public object\nconsole.log(basket);\n```", "```\n// utils.js\nexport const min = (arr) => Math.min(...arr);\n\n// privateMethods.js\nimport { min } from \"./utils\";\n\nexport const privateMethod = () => {\n  console.log(min([10, 5, 100, 2, 1000]));\n};\n\n// myModule.js\nimport { privateMethod } from \"./privateMethods\";\n\nconst myModule = () => ({\n  publicMethod() {\n    privateMethod();\n  },\n});\n\nexport default myModule;\n\n// main.js\nimport myModule from \"./myModule\";\n\nconst moduleInstance = myModule();\nmoduleInstance.publicMethod();\n```", "```\n// module.js\nconst privateVariable = \"Hello World\";\n\nconst privateMethod = () => {\n  // ...\n};\n\nconst module = {\n  publicProperty: \"Foobar\",\n  publicMethod: () => {\n    console.log(privateVariable);\n  },\n};\n\nexport default module;\n```", "```\nlet _counter = new WeakMap();\n\nclass Module {\n    constructor() {\n        _counter.set(this, 0);\n    }\n    incrementCounter() {\n        let counter = _counter.get(this);\n        counter++;\n        _counter.set(this, counter);\n\n        return _counter.get(this);\n    }\n    resetCounter() {\n        console.log(`counter value prior to reset: ${_counter.get(this)}`);\n        _counter.set(this, 0);\n    }\n}\n\nconst testModule = new Module();\n\n// Usage:\n\n// Increment our counter\ntestModule.incrementCounter();\n// Check the counter value and reset\n// Outputs: counter value prior to reset: 1\ntestModule.resetCounter();\n```", "```\nconst myPrivateVar = new WeakMap();\nconst myPrivateMethod = new WeakMap();\n\nclass MyNamespace {\n    constructor() {\n        // A private counter variable\n        myPrivateVar.set(this, 0);\n        // A private function that logs any arguments\n        myPrivateMethod.set(this, foo => console.log(foo));\n        // A public variable\n        this.myPublicVar = 'foo';\n    }\n    // A public function utilizing privates\n    myPublicFunction(bar) {\n        let privateVar = myPrivateVar.get(this);\n        const privateMethod = myPrivateMethod.get(this);\n        // Increment our private counter\n        privateVar++;\n        myPrivateVar.set(this, privateVar);\n        // Call our private method using bar\n        privateMethod(bar);\n    }\n}\n```", "```\nconst basket = new WeakMap();\nconst doSomethingPrivate = new WeakMap();\nconst doSomethingElsePrivate = new WeakMap();\n\nclass BasketModule {\n    constructor() {\n        // privates\n        basket.set(this, []);\n        doSomethingPrivate.set(this, () => {\n            //...\n        });\n        doSomethingElsePrivate.set(this, () => {\n            //...\n        });\n    }\n    // Public aliases to a private function\n    doSomething() {\n        doSomethingPrivate.get(this)();\n    }\n    doSomethingElse() {\n        doSomethingElsePrivate.get(this)();\n    }\n    // Add items to our basket\n    addItem(values) {\n        const basketData = basket.get(this);\n        basketData.push(values);\n        basket.set(this, basketData);\n    }\n    // Get the count of items in the basket\n    getItemCount() {\n        return basket.get(this).length;\n    }\n    // Get the total value of items in the basket\n    getTotal() {\n        return basket\n            .get(this)\n            .reduce((currentSum, item) => item.price + currentSum, 0);\n    }\n}\n```", "```\nimport React from \"react\";\nimport Button from \"@material-ui/core/Button\";\n\nconst style = {\n  root: {\n    borderRadius: 3,\n    border: 0,\n    color: \"white\",\n    margin: \"0 20px\"\n  },\n  primary: {\n    background: \"linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)\"\n  },\n  secondary: {\n    background: \"linear-gradient(45deg, #2196f3 30%, #21cbf3 90%)\"\n  }\n};\n\nexport default function CustomButton(props) {\n  return (\n    <Button {...props} style={{ ...style.root, ...style[props.color] }}>\n      {props.children}\n    </Button>\n  );\n}\n```", "```\nlet privateVar = 'Rob Dodson';\nconst publicVar = 'Hey there!';\n\nconst privateFunction = () => {\n  console.log(`Name:${privateVar}`);\n};\n\nconst publicSetName = strName => {\n  privateVar = strName;\n};\n\nconst publicGetName = () => {\n  privateFunction();\n};\n\n// Reveal public pointers to\n// private functions and properties\nconst myRevealingModule = {\n  setName: publicSetName,\n  greeting: publicVar,\n  getName: publicGetName,\n};\n\nexport default myRevealingModule;\n\n// Usage:\nimport myRevealingModule from './myRevealingModule';\n\nmyRevealingModule.setName('Matt Gaunt');\n```", "```\nlet privateCounter = 0;\n\nconst privateFunction = () => {\n    privateCounter++;\n}\n\nconst publicFunction = () => {\n    publicIncrement();\n}\n\nconst publicIncrement = () => {\n    privateFunction();\n}\n\nconst publicGetCount = () => privateCounter;\n\n// Reveal public pointers to\n// private functions and properties\nconst myRevealingModule = {\n    start: publicFunction,\n    increment: publicIncrement,\n    count: publicGetCount\n};\n\nexport default myRevealingModule;\n\n// Usage:\nimport myRevealingModule from './myRevealingModule';\n\nmyRevealingModule.start();\n```", "```\n// Instance stores a reference to the Singleton\nlet instance;\n\n// Private methods and variables\nconst privateMethod = () => {\n    console.log('I am private');\n  };\nconst privateVariable = 'Im also private';\nconst randomNumber = Math.random();\n\n// Singleton\nclass MySingleton {\n  // Get the Singleton instance if one exists\n  // or create one if it doesn't\n  constructor() {\n    if (!instance) {\n      // Public property\n      this.publicProperty = 'I am also public';\n      instance = this;\n    }\n\n    return instance;\n  }\n\n  // Public methods\n  publicMethod() {\n    console.log('The public can see me!');\n  }\n\n  getRandomNumber() {\n    return randomNumber;\n  }\n}\n// [ES2015+] Default export module, without name\nexport default MySingleton;\n\n// Instance stores a reference to the Singleton\nlet instance;\n\n// Singleton\nclass MyBadSingleton {\n    // Always create a new Singleton instance\n    constructor() {\n        this.randomNumber = Math.random();\n        instance = this;\n\n        return instance;\n    }\n\n    getRandomNumber() {\n        return this.randomNumber;\n    }\n}\n\nexport default MyBadSingleton;\n\n// Usage:\nimport MySingleton from './MySingleton';\nimport MyBadSingleton from './MyBadSingleton';\n\nconst singleA = new MySingleton();\nconst singleB = new MySingleton();\nconsole.log(singleA.getRandomNumber() === singleB.getRandomNumber());\n// true\n\nconst badSingleA = new MyBadSingleton();\nconst badSingleB = new MyBadSingleton();\nconsole.log(badSingleA.getRandomNumber() !== badSingleB.getRandomNumber());\n// true\n\n// Note: as we are working with random numbers, there is a mathematical\n// possibility both numbers will be the same, however unlikely.\n// The preceding example should otherwise still be valid.\n```", "```\nconstructor() {\n    if (this._instance == null) {\n        if (isFoo()) {\n            this._instance = new FooSingleton();\n        } else {\n            this._instance = new BasicSingleton();\n        }\n    }\n\n    return this._instance;\n}\n```", "```\n// options: an object containing configuration options for the Singleton\n// e.g., const options = { name: \"test\", pointX: 5};\nclass Singleton {\n    constructor(options = {}) {\n      // set some properties for our Singleton\n      this.name = 'SingletonTester';\n      this.pointX = options.pointX || 6;\n      this.pointY = options.pointY || 10;\n    }\n  }\n\n  // our instance holder\n  let instance;\n\n  // an emulation of static variables and methods\n  const SingletonTester = {\n    name: 'SingletonTester',\n    // Method for getting an instance. It returns\n    // a Singleton instance of a Singleton object\n    getInstance(options) {\n      if (instance === undefined) {\n        instance = new Singleton(options);\n      }\n\n      return instance;\n    },\n  };\n\n  const singletonTest = SingletonTester.getInstance({\n    pointX: 5,\n  });\n\n  // Log the output of pointX just to verify it is correct\n  // Outputs: 5\n  console.log(singletonTest.pointX);\n```", "```\nconst myCar = {\n    name: 'Ford Escort',\n\n    drive() {\n        console.log(\"Weeee. I'm driving!\");\n    },\n\n    panic() {\n        console.log('Wait. How do you stop this thing?');\n    },\n};\n\n// Use Object.create to instantiate a new car\nconst yourCar = Object.create(myCar);\n\n// Now we can see that one is a prototype of the other\nconsole.log(yourCar.name);\n```", "```\nconst vehicle = {\n    getModel() {\n        console.log(`The model of this vehicle is...${this.model}`);\n    },\n};\n\nconst car = Object.create(vehicle, {\n    id: {\n        value: MY_GLOBAL.nextId(),\n        // writable:false, configurable:false by default\n        enumerable: true,\n    },\n\n    model: {\n        value: 'Ford',\n        enumerable: true,\n    },\n});\n```", "```\nclass VehiclePrototype {\n  constructor(model) {\n    this.model = model;\n  }\n\n  getModel() {\n    console.log(`The model of this vehicle is... ${this.model}`);\n  }\n\n  clone() {}\n}\n\nclass Vehicle extends VehiclePrototype {\n  constructor(model) {\n    super(model);\n  }\n\n  clone() {\n    return new Vehicle(this.model);\n  }\n}\n\nconst car = new Vehicle('Ford Escort');\nconst car2 = car.clone();\ncar2.getModel();\n```", "```\nconst beget = (() => {\n    class F {\n        constructor() {}\n    }\n\n    return proto => {\n        F.prototype = proto;\n        return new F();\n    };\n})();\n```", "```\n// Types.js - Classes used behind the scenes\n// A class for defining new cars\nclass Car {\n  constructor({ doors = 4, state = 'brand new', color = 'silver' } = {}) {\n    this.doors = doors;\n    this.state = state;\n    this.color = color;\n  }\n}\n\n// A class for defining new trucks\nclass Truck {\n  constructor({ state = 'used', wheelSize = 'large', color = 'blue' } = {}) {\n    this.state = state;\n    this.wheelSize = wheelSize;\n    this.color = color;\n  }\n}\n\n// FactoryExample.js\n// Define a vehicle factory\nclass VehicleFactory {\n  constructor() {\n    this.vehicleClass = Car;\n  }\n\n  // Our Factory method for creating new Vehicle instances\n  createVehicle(options) {\n    const { vehicleType, ...rest } = options;\n\n    switch (vehicleType) {\n      case 'car':\n        this.vehicleClass = Car;\n        break;\n      case 'truck':\n        this.vehicleClass = Truck;\n        break;\n      // defaults to VehicleFactory.prototype.vehicleClass (Car)\n    }\n\n    return new this.vehicleClass(rest);\n  }\n}\n\n// Create an instance of our factory that makes cars\nconst carFactory = new VehicleFactory();\nconst car = carFactory.createVehicle({\n  vehicleType: 'car',\n  color: 'yellow',\n  doors: 6,\n});\n\n// Test to confirm our car was created using the vehicleClass/prototype Car\n// Outputs: true\nconsole.log(car instanceof Car);\n// Outputs: Car object of color \"yellow\", doors: 6 in a \"brand new\" state\nconsole.log(car);\n```", "```\nconst movingTruck = carFactory.createVehicle({\n    vehicleType: 'truck',\n    state: 'like new',\n    color: 'red',\n    wheelSize: 'small',\n});\n\n// Test to confirm our truck was created with the vehicleClass/prototype Truck\n\n// Outputs: true\nconsole.log(movingTruck instanceof Truck);\n\n// Outputs: Truck object of color \"red\", a \"like new\" state\n// and a \"small\" wheelSize\nconsole.log(movingTruck);\n```", "```\nclass TruckFactory extends VehicleFactory {\n    constructor() {\n        super();\n        this.vehicleClass = Truck;\n    }\n}\nconst truckFactory = new TruckFactory();\nconst myBigTruck = truckFactory.createVehicle({\n    state: 'omg...so bad.',\n    color: 'pink',\n    wheelSize: 'so big',\n});\n\n// Confirms that myBigTruck was created with the prototype Truck\n// Outputs: true\nconsole.log(myBigTruck instanceof Truck);\n\n// Outputs: Truck object with the color \"pink\", wheelSize \"so big\"\n// and state \"omg. so bad\"\nconsole.log(myBigTruck);\n```", "```\nclass AbstractVehicleFactory {\n  constructor() {\n    // Storage for our vehicle types\n    this.types = {};\n  }\n\n  getVehicle(type, customizations) {\n    const Vehicle = this.types[type];\n    return Vehicle ? new Vehicle(customizations) : null;\n  }\n\n  registerVehicle(type, Vehicle) {\n    const proto = Vehicle.prototype;\n    // only register classes that fulfill the vehicle contract\n    if (proto.drive && proto.breakDown) {\n      this.types[type] = Vehicle;\n    }\n    return this;\n  }\n}\n\n// Usage:\nconst abstractVehicleFactory = new AbstractVehicleFactory();\nabstractVehicleFactory.registerVehicle('car', Car);\nabstractVehicleFactory.registerVehicle('truck', Truck);\n\n// Instantiate a new car based on the abstract vehicle type\nconst car = abstractVehicleFactory.getVehicle('car', {\n  color: 'lime green',\n  state: 'like new',\n});\n\n// Instantiate a new truck in a similar manner\nconst truck = abstractVehicleFactory.getVehicle('truck', {\n  wheelSize: 'medium',\n  color: 'neon yellow',\n});\n```", "```\nconst addMyEvent = (el, ev, fn) => {\n    if (el.addEventListener) {\n      el.addEventListener(ev, fn, false);\n    } else if (el.attachEvent) {\n      el.attachEvent(`on${ev}`, fn);\n    } else {\n      el[`on${ev}`] = fn;\n    }\n  };\n```", "```\nfunction bindReady() {\n  // Use the handy event callback\n  document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n  // A fallback to window.onload, that will always work\n  window.addEventListener('load', jQuery.ready, false);\n}\n```", "```\n// privateMethods.js\nconst _private = {\n  i: 5,\n  get() {\n    console.log(`current value: ${this.i}`);\n  },\n  set(val) {\n    this.i = val;\n  },\n  run() {\n    console.log('running');\n  },\n  jump() {\n    console.log('jumping');\n  },\n};\n\nexport default _private;\n\n// module.js\nimport _private from './privateMethods.js';\n\nconst module = {\n  facade({ val, run }) {\n    _private.set(val);\n    _private.get();\n    if (run) {\n      _private.run();\n    }\n  },\n};\n\nexport default module;\n\n// index.js\nimport module from './module.js';\n\n// Outputs: \"current value: 10\" and \"running\"\nmodule.facade({\n  run: true,\n  val: 10,\n});\n```", "```\nclass Person{\n    constructor(firstName, lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.gender = \"male\";\n    }\n}\n// a new instance of Person can then easily be created as follows:\nconst clark = new Person( 'Clark', 'Kent' );\n```", "```\nclass Superhero extends Person {\n    constructor(firstName, lastName, powers) {\n        // Invoke the superclass constructor\n        super(firstName, lastName);\n        this.powers = powers;\n    }\n}\n\n// A new instance of Superhero can be created as follows\n\nconst SuperMan = new Superhero('Clark','Kent', ['flight','heat-vision']);\nconsole.log(SuperMan);\n\n// Outputs Person attributes as well as power\n```", "```\nconst MyMixins = superclass =>\n    class extends superclass {\n        moveUp() {\n            console.log('move up');\n        }\n        moveDown() {\n            console.log('move down');\n        }\n        stop() {\n            console.log('stop! in the name of love!');\n        }\n    };\n```", "```\n// A skeleton carAnimator constructor\nclass CarAnimator {\n    moveLeft() {\n        console.log('move left');\n    }\n}\n// A skeleton personAnimator constructor\nclass PersonAnimator {\n    moveRandomly() {\n        /*...*/\n    }\n}\n\n// Extend MyMixins using CarAnimator\nclass MyAnimator extends MyMixins(CarAnimator) {}\n\n// Create a new instance of carAnimator\nconst myAnimator = new MyAnimator();\nmyAnimator.moveLeft();\nmyAnimator.moveDown();\nmyAnimator.stop();\n\n// Outputs:\n// move left\n// move down\n// stop! in the name of love!\n```", "```\n// Car.js\nclass Car {\n  constructor({ model = 'no model provided', color = 'no color provided' }) {\n    this.model = model;\n    this.color = color;\n  }\n}\n\nexport default Car;\n\n// Mixin.js and index.js remain unchanged\n\n// index.js\nimport Car from './Car.js';\nimport Mixin from './Mixin.js';\n\nclass MyCar extends Mixin(Car) {}\n\n// Create a new Car\nconst myCar = new MyCar({});\n\n// Test to make sure we now have access to the methods\nmyCar.driveForward();\nmyCar.driveBackward();\n\n// Outputs:\n// drive forward\n// drive backward\n\nconst mySportsCar = new MyCar({\n  model: 'Porsche',\n  color: 'red',\n});\n\nmySportsCar.driveSideways();\n\n// Outputs:\n// drive sideways\n```", "```\n// A vehicle constructor\nclass Vehicle {\n    constructor(vehicleType) {\n        // some sane defaults\n        this.vehicleType = vehicleType || 'car';\n        this.model = 'default';\n        this.license = '00000-000';\n    }\n}\n\n// Test instance for a basic vehicle\nconst testInstance = new Vehicle('car');\nconsole.log(testInstance);\n\n// Outputs:\n// vehicle: car, model:default, license: 00000-000\n\n// Let's create a new instance of vehicle, to be decorated\nconst truck = new Vehicle('truck');\n\n// New functionality we're decorating vehicle with\ntruck.setModel = function(modelName) {\n    this.model = modelName;\n};\n\ntruck.setColor = function(color) {\n    this.color = color;\n};\n\n// Test the value setters and value assignment works correctly\ntruck.setModel('CAT');\ntruck.setColor('blue');\n\nconsole.log(truck);\n\n// Outputs:\n// vehicle:truck, model:CAT, color: blue\n\n// Demonstrate \"vehicle\" is still unaltered\nconst secondInstance = new Vehicle('car');\nconsole.log(secondInstance);\n\n// Outputs:\n// vehicle: car, model:default, license: 00000-000\n```", "```\n// The constructor to decorate\nclass MacBook {\n    constructor() {\n        this.cost = 997;\n        this.screenSize = 11.6;\n    }\n    getCost() {\n        return this.cost;\n    }\n    getScreenSize() {\n        return this.screenSize;\n    }\n}\n\n// Decorator 1\nclass Memory extends MacBook {\n    constructor(macBook) {\n        super();\n        this.macBook = macBook;\n    }\n\n    getCost() {\n        return this.macBook.getCost() + 75;\n    }\n}\n\n// Decorator 2\nclass Engraving extends MacBook {\n    constructor(macBook) {\n        super();\n        this.macBook = macBook;\n    }\n\n    getCost() {\n        return this.macBook.getCost() + 200;\n    }\n}\n\n// Decorator 3\nclass Insurance extends MacBook {\n    constructor(macBook) {\n        super();\n        this.macBook = macBook;\n    }\n\n    getCost() {\n        return this.macBook.getCost() + 250;\n    }\n}\n\n// init main object\nlet mb = new MacBook();\n\n// init decorators\nmb = new Memory(mb);\nmb = new Engraving(mb);\nmb = new Insurance(mb);\n\n// Outputs: 1522\nconsole.log(mb.getCost());\n\n// Outputs: 11.6\nconsole.log(mb.getScreenSize());\n```", "```\n// Create interfaces using a predefined Interface\n// constructor that accepts an interface name and\n// skeleton methods to expose.\n\n// In our reminder example summary() and placeOrder()\n// represent functionality the interface should\n// support\nconst reminder = new Interface('List', ['summary', 'placeOrder']);\n\nconst properties = {\n    name: 'Remember to buy the milk',\n    date: '05/06/2040',\n    actions: {\n        summary() {\n            return 'Remember to buy the milk, we are almost out!';\n        },\n        placeOrder() {\n            return 'Ordering milk from your local grocery store';\n        },\n    },\n};\n\n// Now create a constructor implementing these properties\n// and methods\n\nclass Todo {\n    constructor({ actions, name }) {\n        // State the methods we expect to be supported\n        // as well as the Interface instance being checked\n        // against\n\n        Interface.ensureImplements(actions, reminder);\n\n        this.name = name;\n        this.methods = actions;\n    }\n}\n\n// Create a new instance of our Todo constructor\n\nconst todoItem = new Todo(properties);\n\n// Finally test to make sure these function correctly\n\nconsole.log(todoItem.methods.summary());\nconsole.log(todoItem.methods.placeOrder());\n\n// Outputs:\n// Remember to buy the milk, we are almost out!\n// Ordering milk from your local grocery store\n```", "```\nconst MacBook = class {\n    //...\n};\n\nconst MacBookWith4GBRam = class {};\nconst MacBookWith8GBRam = class {};\nconst MacBookWith4GBRamAndEngraving = class {};\nconst MacBookWith8GBRamAndEngraving = class {};\nconst MacBookWith8GBRamAndParallels = class {};\nconst MacBookWith4GBRamAndParallels = class {};\nconst MacBookWith8GBRamAndParallelsAndCase = class {};\nconst MacBookWith4GBRamAndParallelsAndCase = class {};\nconst MacBookWith8GBRamAndParallelsAndCaseAndInsurance = class {};\nconst MacBookWith4GBRamAndParallelsAndCaseAndInsurance = class {};\n```", "```\nconst MacBook = new Interface('MacBook', [\n    'addEngraving',\n    'addParallels',\n    'add4GBRam',\n    'add8GBRam',\n    'addCase',\n]);\n\n// A MacBook Pro might thus be represented as follows:\nclass MacBookPro {\n    // implements MacBook\n}\n\n// ES2015+: We still could use Object.prototype for adding new methods,\n// because internally we use the same structure\n\nMacBookPro.prototype = {\n    addEngraving() {},\n    addParallels() {},\n    add4GBRam() {},\n    add8GBRam() {},\n    addCase() {},\n    getPrice() {\n        // Base price\n        return 900.0;\n    },\n};\n```", "```\n// MacBook decorator abstract decorator class\n\nclass MacBookDecorator {\n    constructor(macbook) {\n        Interface.ensureImplements(macbook, MacBook);\n        this.macbook = macbook;\n    }\n\n    addEngraving() {\n        return this.macbook.addEngraving();\n    }\n\n    addParallels() {\n        return this.macbook.addParallels();\n    }\n\n    add4GBRam() {\n        return this.macbook.add4GBRam();\n    }\n\n    add8GBRam() {\n        return this.macbook.add8GBRam();\n    }\n\n    addCase() {\n        return this.macbook.addCase();\n    }\n\n    getPrice() {\n        return this.macbook.getPrice();\n    }\n}\n```", "```\n// Let's now extend (decorate) the CaseDecorator\n// with a MacBookDecorator\n\nclass CaseDecorator extends MacBookDecorator {\n    constructor(macbook) {\n        super(macbook);\n    }\n\n    addCase() {\n        return `${this.macbook.addCase()}Adding case to macbook`;\n    }\n\n    getPrice() {\n        return this.macbook.getPrice() + 45.0;\n    }\n}\n```", "```\n// Instantiation of the macbook\nconst myMacBookPro = new MacBookPro();\n\n// Outputs: 900.00\nconsole.log(myMacBookPro.getPrice());\n\n// Decorate the macbook\nconst decoratedMacBookPro = new CaseDecorator(myMacBookPro);\n\n// This will return 945.00\nconsole.log(decoratedMacBookPro.getPrice());\n```", "```\n// Utility to simulate implementation of an interface\nclass InterfaceImplementation {\n  static implementsFor(superclassOrInterface) {\n    if (superclassOrInterface instanceof Function) {\n      this.prototype = Object.create(superclassOrInterface.prototype);\n      this.prototype.constructor = this;\n      this.prototype.parent = superclassOrInterface.prototype;\n    } else {\n      this.prototype = Object.create(superclassOrInterface);\n      this.prototype.constructor = this;\n      this.prototype.parent = superclassOrInterface;\n    }\n    return this;\n  }\n}\n```", "```\n// CoffeeOrder interface\nconst CoffeeOrder = {\n  serveCoffee(context) {},\n  getFlavor() {},\n};\n\nclass CoffeeFlavor extends InterfaceImplementation {\n  constructor(newFlavor) {\n    super();\n    this.flavor = newFlavor;\n  }\n\n  getFlavor() {\n    return this.flavor;\n  }\n\n  serveCoffee(context) {\n    console.log(`Serving Coffee flavor ${this.flavor} to\n table ${context.getTable()}`);\n  }\n}\n\n// Implement interface for CoffeeOrder\nCoffeeFlavor.implementsFor(CoffeeOrder);\n\nconst CoffeeOrderContext = (tableNumber) => ({\n  getTable() {\n    return tableNumber;\n  },\n});\n\nclass CoffeeFlavorFactory {\n  constructor() {\n    this.flavors = {};\n    this.length = 0;\n  }\n\n  getCoffeeFlavor(flavorName) {\n    let flavor = this.flavors[flavorName];\n    if (!flavor) {\n      flavor = new CoffeeFlavor(flavorName);\n      this.flavors[flavorName] = flavor;\n      this.length++;\n    }\n    return flavor;\n  }\n\n  getTotalCoffeeFlavorsMade() {\n    return this.length;\n  }\n}\n\n// Sample usage:\nconst testFlyweight = () => {\n  const flavors = [];\n  const tables = [];\n  let ordersMade = 0;\n  const flavorFactory = new CoffeeFlavorFactory();\n\n  function takeOrders(flavorIn, table) {\n    flavors.push(flavorFactory.getCoffeeFlavor(flavorIn));\n    tables.push(CoffeeOrderContext(table));\n    ordersMade++;\n  }\n\n  // Place orders\n  takeOrders('Cappuccino', 2);\n  // ...\n\n  // Serve orders\n  for (let i = 0; i < ordersMade; ++i) {\n    flavors[i].serveCoffee(tables[i]);\n  }\n\n  console.log(' ');\n  console.log(`total CoffeeFlavor objects made:\n    ${flavorFactory.getTotalCoffeeFlavorsMade()}`);\n};\n\ntestFlyweight();\n```", "```\nclass Book {\n  constructor(\n    id,\n    title,\n    author,\n    genre,\n    pageCount,\n    publisherID,\n    ISBN,\n    checkoutDate,\n    checkoutMember,\n    dueReturnDate,\n    availability\n  ) {\n    this.id = id;\n    this.title = title;\n    this.author = author;\n    this.genre = genre;\n    this.pageCount = pageCount;\n    this.publisherID = publisherID;\n    this.ISBN = ISBN;\n    this.checkoutDate = checkoutDate;\n    this.checkoutMember = checkoutMember;\n    this.dueReturnDate = dueReturnDate;\n    this.availability = availability;\n  }\n\n  getTitle() {\n    return this.title;\n  }\n\n  getAuthor() {\n    return this.author;\n  }\n\n  getISBN() {\n    return this.ISBN;\n  }\n\n  // For brevity, other getters are not shown\n  updateCheckoutStatus(\n    bookID,\n    newStatus,\n    checkoutDate,\n    checkoutMember,\n    newReturnDate\n  ) {\n    this.id = bookID;\n    this.availability = newStatus;\n    this.checkoutDate = checkoutDate;\n    this.checkoutMember = checkoutMember;\n    this.dueReturnDate = newReturnDate;\n  }\n\n  extendCheckoutPeriod(bookID, newReturnDate) {\n    this.id = bookID;\n    this.dueReturnDate = newReturnDate;\n  }\n\n  isPastDue(bookID) {\n    const currentDate = new Date();\n    return currentDate.getTime() > Date.parse(this.dueReturnDate);\n  }\n}\n```", "```\n// Flyweight optimized version\nclass Book {\n  constructor({ title, author, genre, pageCount, publisherID, ISBN }) {\n    this.title = title;\n    this.author = author;\n    this.genre = genre;\n    this.pageCount = pageCount;\n    this.publisherID = publisherID;\n    this.ISBN = ISBN;\n  }\n}\n```", "```\n// Book Factory Singleton\nconst existingBooks = {};\n\nclass BookFactory {\n  createBook({ title, author, genre, pageCount, publisherID, ISBN }) {\n    // Find if a particular book + metadata combination already exists\n    // !! or (bang bang) forces a boolean to be returned\n    const existingBook = existingBooks[ISBN];\n    if (!!existingBook) {\n      return existingBook;\n    } else {\n      // if not, let's create a new instance of the book and store it\n      const book = new Book({ title, author, genre, pageCount, publisherID,\n         ISBN });\n      existingBooks[ISBN] = book;\n      return book;\n    }\n  }\n}\n```", "```\n// BookRecordManager Singleton\nconst bookRecordDatabase = {};\n\nclass BookRecordManager {\n  // add a new book into the library system\n  addBookRecord({ id, title, author, genre, pageCount, publisherID, ISBN,\n       checkoutDate, checkoutMember, dueReturnDate, availability }) {\n    const bookFactory = new BookFactory();\n    const book = bookFactory.createBook({ title, author, genre, pageCount,\n       publisherID, ISBN });\n    bookRecordDatabase[id] = {\n      checkoutMember,\n      checkoutDate,\n      dueReturnDate,\n      availability,\n      book,\n    };\n  }\n\n  updateCheckoutStatus({ bookID, newStatus, checkoutDate, checkoutMember,\n     newReturnDate }) {\n    const record = bookRecordDatabase[bookID];\n    record.availability = newStatus;\n    record.checkoutDate = checkoutDate;\n    record.checkoutMember = checkoutMember;\n    record.dueReturnDate = newReturnDate;\n  }\n\n  extendCheckoutPeriod(bookID, newReturnDate) {\n    bookRecordDatabase[bookID].dueReturnDate = newReturnDate;\n  }\n\n  isPastDue(bookID) {\n    const currentDate = new Date();\n    return currentDate.getTime() >\n       Date.parse(bookRecordDatabase[bookID].dueReturnDate);\n  }\n}\n```", "```\n<div id=\"container\">\n    <div class=\"toggle\">More Info (Address)\n      <span class=\"info\">\n        This is more information\n      </span>\n    </div>\n    <div class=\"toggle\">Even More Info (Map)\n      <span class=\"info\">\n        <iframe src=\"MAPS_URL\"></iframe>\n      </span>\n    </div>\n  </div>\n```", "```\n  <script>\n    (function() {\n      const stateManager = {\n        fly() {\n          const self = this;\n          $('#container')\n            .off()\n            .on('click', 'div.toggle', function() {\n              self.handleClick(this);\n            });\n        },\n        handleClick(elem) {\n          $(elem)\n            .find('span')\n            .toggle('slow');\n        },\n      };\n\n      // Initialize event listeners\n      stateManager.fly();\n    })();\n  </script>\n```", "```\nclass ObserverList {\n    constructor() {\n        this.observerList = [];\n    }\n\n    add(obj) {\n        return this.observerList.push(obj);\n    }\n\n    count() {\n        return this.observerList.length;\n    }\n\n    get(index) {\n        if (index > -1 && index < this.observerList.length) {\n            return this.observerList[index];\n        }\n    }\n\n    indexOf(obj, startIndex) {\n        let i = startIndex;\n\n        while (i < this.observerList.length) {\n            if (this.observerList[i] === obj) {\n                return i;\n            }\n            i++;\n        }\n\n        return -1;\n    }\n\n    removeAt(index) {\n        this.observerList.splice(index, 1);\n    }\n}\n```", "```\nclass Subject {\n  constructor() {\n    this.observers = new ObserverList();\n  }\n\n  addObserver(observer) {\n    this.observers.add(observer);\n  }\n\n  removeObserver(observer) {\n    this.observers.removeAt(this.observers.indexOf(observer, 0));\n  }\n\n  notify(context) {\n    const observerCount = this.observers.count();\n    for (let i = 0; i < observerCount; i++) {\n    this.observers.get(i).update(context);\n    }\n  }\n}\n```", "```\n// The Observer\nclass Observer {\n    constructor() {}\n    update() {\n        // ...\n    }\n}\n```", "```\n<button id=\"addNewObserver\">Add New Observer checkbox</button>\n<input id=\"mainCheckbox\" type=\"checkbox\"/>\n<div id=\"observersContainer\"></div>\n```", "```\n// References to our DOM elements\n\n// Concrete Subject\nclass ConcreteSubject extends Subject {\n    constructor(element) {\n      // Call the constructor of the super class.\n      super();\n      this.element = element;\n\n      // Clicking the checkbox will trigger notifications to its observers\n      this.element.onclick = () => {\n        this.notify(this.element.checked);\n      };\n    }\n  }\n\n  // Concrete Observer\n\n  class ConcreteObserver extends Observer {\n    constructor(element) {\n      super();\n      this.element = element;\n    }\n\n    // Override with custom update behavior\n    update(value) {\n      this.element.checked = value;\n    }\n  }\n\n  // References to our DOM elements\n  const addBtn = document.getElementById('addNewObserver');\n  const container = document.getElementById('observersContainer');\n  const controlCheckbox = new ConcreteSubject(\n    document.getElementById('mainCheckbox')\n  );\n\n  const addNewObserver = () => {\n    // Create a new checkbox to be added\n    const check = document.createElement('input');\n    check.type = 'checkbox';\n    const checkObserver = new ConcreteObserver(check);\n\n    // Add the new observer to our list of observers\n    // for our main subject\n    controlCheckbox.addObserver(checkObserver);\n\n    // Append the item to the container\n    container.appendChild(check);\n  };\n\n  addBtn.onclick = addNewObserver;\n}\n```", "```\n<!-- Add this HTML to your page -->\n<div class=\"messageSender\"></div>\n<div class=\"messagePreview\"></div>\n<div class=\"newMessageCounter\"></div>\n// A simple Publish/Subscribe implementation\nconst events = (function () {\n  const topics = {};\n  const hOP = topics.hasOwnProperty;\n\n  return {\n    subscribe: function (topic, listener) {\n      if (!hOP.call(topics, topic)) topics[topic] = [];\n      const index = topics[topic].push(listener) - 1;\n\n      return {\n        remove: function () {\n          delete topics[topic][index];\n        },\n      };\n    },\n    publish: function (topic, info) {\n      if (!hOP.call(topics, topic)) return;\n      topics[topic].forEach(function (item) {\n        item(info !== undefined ? info : {});\n      });\n    },\n  };\n})();\n\n// A very simple new mail handler\n// A count of the number of messages received\nlet mailCounter = 0;\n\n// Initialize subscribers that will listen out for a topic\n// with the name \"inbox/newMessage\".\n// Render a preview of new messages\nconst subscriber1 = events.subscribe('inbox/newMessage', (data) => {\n  // Log the topic for debugging purposes\n  console.log('A new message was received:', data);\n\n  // Use the data that was passed from our subject\n  // to display a message preview to the user\n  document.querySelector('.messageSender').innerHTML = data.sender;\n  document.querySelector('.messagePreview').innerHTML = data.body;\n});\n\n// Here's another subscriber using the same data to perform\n// a different task.\n// Update the counter displaying the number of new\n// messages received via the publisher\nconst subscriber2 = events.subscribe('inbox/newMessage', (data) => {\n  document.querySelector('.newMessageCounter').innerHTML = ++mailCounter;\n});\n\nevents.publish('inbox/newMessage', {\n  sender: 'hello@google.com',\n  body: 'Hey there! How are you doing today?',\n});\n\n// We could then at a later point unsubscribe our subscribers\n// from receiving any new topic notifications as follows:\n// subscriber1.remove();\n// subscriber2.remove();\n```", "```\nclass PubSub {\n    constructor() {\n        // Storage for topics that can be broadcast\n        // or listened to\n        this.topics = {};\n\n        // A topic identifier\n        this.subUid = -1;\n    }\n\n    publish(topic, args) {\n        if (!this.topics[topic]) {\n            return false;\n        }\n\n        const subscribers = this.topics[topic];\n        let len = subscribers ? subscribers.length : 0;\n\n        while (len--) {\n            subscribers[len].func(topic, args);\n        }\n\n        return this;\n    }\n\n    subscribe(topic, func) {\n        if (!this.topics[topic]) {\n            this.topics[topic] = [];\n        }\n\n        const token = (++this.subUid).toString();\n        this.topics[topic].push({\n            token,\n            func,\n        });\n        return token;\n    }\n\n    unsubscribe(token) {\n        for (const m in this.topics) {\n            if (this.topics[m]) {\n                for (let i = 0, j = this.topics[m].length; i < j; i++) {\n                    if (this.topics[m][i].token === token) {\n                        this.topics[m].splice(i, 1);\n\n                        return token;\n                    }\n                }\n            }\n        }\n        return this;\n    }\n}\n\nconst pubsub = new PubSub();\n\npubsub.publish('/addFavorite', ['test']);\npubsub.subscribe('/addFavorite', (topic, args) => {\n    console.log('test', topic, args);\n});\n```", "```\n// Another simple message handler\n\n// A simple message logger that logs any topics and data received through our\n// subscriber\nconst messageLogger = (topics, data) => {\n    console.log(`Logging: ${topics}: ${data}`);\n};\n\n// Subscribers listen for topics they have subscribed to and\n// invoke a callback function (e.g., messageLogger) once a new\n// notification is broadcast on that topic\nconst subscription = pubsub.subscribe('inbox/newMessage', messageLogger);\n\n// Publishers are in charge of publishing topics or notifications of\n// interest to the application. e.g.:\n\npubsub.publish('inbox/newMessage', 'hello world!');\n\n// or\npubsub.publish('inbox/newMessage', ['test', 'a', 'b', 'c']);\n\n// or\npubsub.publish('inbox/newMessage', {\n    sender: 'hello@google.com',\n    body: 'Hey again!',\n});\n\n// We can also unsubscribe if we no longer wish for our subscribers\n// to be notified\npubsub.unsubscribe(subscription);\n\n// Once unsubscribed, this for example won't result in our\n// messageLogger being executed as the subscriber is\n// no longer listening\npubsub.publish('inbox/newMessage', 'Hello! are you still there?');\n```", "```\n// Return the current local time to be used in our UI later\ngetCurrentTime = () => {\n    const date = new Date();\n    const m = date.getMonth() + 1;\n    const d = date.getDate();\n    const y = date.getFullYear();\n    const t = date.toLocaleTimeString().toLowerCase();\n\n    return `${m}/${d}/${y} ${t}`;\n  };\n\n  // Add a new row of data to our fictional grid component\n  const addGridRow = data => {\n    // ui.grid.addRow( data );\n    console.log(`updated grid component with:${data}`);\n  };\n\n  // Update our fictional grid to show the time it was last\n  // updated\n  const updateCounter = data => {\n    // ui.grid.updateLastChanged( getCurrentTime() );\n    console.log(`data last updated at: ${getCurrentTime()} with ${data}`);\n  };\n\n  // Update the grid using the data passed to our subscribers\n  const gridUpdate = (topic, data) => {\n    if (data !== undefined) {\n      addGridRow(data);\n      updateCounter(data);\n    }\n  };\n\n// Create a subscription to the newDataAvailable topic\nconst subscriber = pubsub.subscribe('newDataAvailable', gridUpdate);\n\n// The following represents updates to our data layer. This could be\n// powered by ajax requests that broadcast that new data is available\n// to the rest of the application.\n\n// Publish changes to the gridUpdated topic representing new entries\npubsub.publish('newDataAvailable', {\n  summary: 'Apple made $5 billion',\n  identifier: 'APPL',\n  stockPrice: 570.91,\n});\n\npubsub.publish('newDataAvailable', {\n  summary: 'Microsoft made $20 million',\n  identifier: 'MSFT',\n  stockPrice: 30.85,\n});\n```", "```\n<script id=\"userTemplate\" type=\"text/html\">\n   <li><%- name %></li>\n</script>\n\n<script id=\"ratingsTemplate\" type=\"text/html\">\n   <li><strong><%- title %></strong> was rated <%- rating %>/5</li>\n</script>\n\n<div id=\"container\">\n\n   <div class=\"sampleForm\">\n       <p>\n           <label for=\"twitter_handle\">Twitter handle:</label>\n           <input type=\"text\" id=\"twitter_handle\" />\n       </p>\n       <p>\n           <label for=\"movie_seen\">Name a movie you've seen this year:</label>\n           <input type=\"text\" id=\"movie_seen\" />\n       </p>\n       <p>\n\n           <label for=\"movie_rating\">Rate the movie you saw:</label>\n           <select id=\"movie_rating\">\n                 <option value=\"1\">1</option>\n                  <option value=\"2\">2</option>\n                  <option value=\"3\">3</option>\n                  <option value=\"4\">4</option>\n                  <option value=\"5\" selected>5</option>\n\n          </select>\n        </p>\n        <p>\n\n            <button id=\"add\">Submit rating</button>\n        </p>\n    </div>\n\n    <div class=\"summaryTable\">\n        <div id=\"users\"><h3>Recent users</h3></div>\n        <div id=\"ratings\"><h3>Recent movies rated</h3></div>\n    </div>\n\n </div>\n```", "```\n;($ => {\n    // Pre-compile templates and \"cache\" them using closure\n    const userTemplate = _.template($('#userTemplate').html());\n\n    const ratingsTemplate = _.template($('#ratingsTemplate').html());\n\n    // Subscribe to the new user topic, which adds a user\n    // to a list of users who have submitted reviews\n    $.subscribe('/new/user', (e, data) => {\n      if (data) {\n        $('#users').append(userTemplate(data));\n      }\n    });\n\n    // Subscribe to the new rating topic. This is composed of a title and\n    // rating. New ratings are appended to a running list of added user\n    // ratings.\n    $.subscribe('/new/rating', (e, data) => {\n      if (data) {\n        $('#ratings').append(ratingsTemplate(data));\n      }\n    });\n\n    // Handler for adding a new user\n    $('#add').on('click', e => {\n      e.preventDefault();\n\n      const strUser = $('#twitter_handle').val();\n      const strMovie = $('#movie_seen').val();\n      const strRating = $('#movie_rating').val();\n\n      // Inform the application a new user is available\n      $.publish('/new/user', {\n        name: strUser,\n      });\n\n      // Inform the app a new rating is available\n      $.publish('/new/rating', {\n        title: strMovie,\n        rating: strRating,\n      });\n    });\n  })(jQuery);\n```", "```\n<form id=\"flickrSearch\">\n\n   <input type=\"text\" name=\"tag\" id=\"query\"/>\n\n   <input type=\"submit\" name=\"submit\" value=\"submit\"/>\n\n</form>\n\n<div id=\"lastQuery\"></div>\n\n<ol id=\"searchResults\"></ol>\n\n<script id=\"resultTemplate\" type=\"text/html\">\n    <% _.each(items, function( item ){ %>\n        <li><img src=\"<%= item.media.m %>\"/></li>\n    <% });%>\n</script>\n```", "```\n($ => {\n    // Pre-compile template and \"cache\" it using closure\n    const resultTemplate = _.template($('#resultTemplate').html());\n\n    // Subscribe to the new search tags topic\n    $.subscribe('/search/tags', (e, tags) => {\n      $('#lastQuery').html(`Searched for: ${tags}`);\n    });\n\n    // Subscribe to the new results topic\n    $.subscribe('/search/resultSet', (e, results) => {\n      $('#searchResults')\n        .empty()\n        .append(resultTemplate(results));\n    });\n\n    // Submit a search query and publish tags on the /search/tags topic\n    $('#flickrSearch').submit(function(e) {\n      e.preventDefault();\n      const tags = $(this)\n        .find('#query')\n        .val();\n\n      if (!tags) {\n        return;\n      }\n\n      $.publish('/search/tags', [$.trim(tags)]);\n    });\n\n    // Subscribe to new tags being published and perform a search query\n    // using them. Once data has returned publish this data for the rest\n    // of the application to consume. We used the destructuring assignment\n    // syntax that makes it possible to unpack values from data structures\n    // into distinct variables.\n\n    $.subscribe('/search/tags', (e, tags) => {\n      $.getJSON(\n        'http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?',\n        {\n          tags,\n          tagmode: 'any',\n          format: 'json',\n        },\n        // The destructuring assignment as function parameter\n        ({ items }) => {\n          if (!items.length) {\n            return;\n          }\n          //shorthand property names in object creation,\n          // if variable name equal to object key\n          $.publish('/search/resultSet', { items });\n        }\n      );\n    });\n  })(jQuery);\n```", "```\nimport ReactDOM from \"react-dom\";\nimport { fromEvent, merge } from \"rxjs\";\nimport { sample, mapTo } from \"rxjs/operators\";\n\nimport \"./styles.css\";\n\nmerge(\n  fromEvent(document, \"mousedown\").pipe(mapTo(false)),\n  fromEvent(document, \"mousemove\").pipe(mapTo(true))\n)\n  .pipe(sample(fromEvent(document, \"mouseup\")))\n  .subscribe(isDragging => {\n    console.log(\"Were you dragging?\", isDragging);\n  });\n\nReactDOM.render(\n  <div className=\"App\">Click or drag anywhere and check the console!</div>,\n  document.getElementById(\"root\")\n);\n```", "```\nconst mediator = {};\n```", "```\nconst orgChart = {\n    addNewEmployee() {\n        // getEmployeeDetail provides a view that users interact with\n        const employeeDetail = this.getEmployeeDetail();\n\n        // when the employee detail is complete, the mediator (the 'orgchart'\n        // object) decides what should happen next\n        employeeDetail.on('complete', employee => {\n            // set up additional objects that have additional events, which are\n            // used by the mediator to do additional things\n            const managerSelector = this.selectManager(employee);\n            managerSelector.on('save', employee => {\n                employee.save();\n            });\n        });\n    },\n\n    // ...\n};\n```", "```\nconst MenuItem = MyFrameworkView.extend({\n    events: {\n        'click .thatThing': 'clickedIt',\n    },\n\n    clickedIt(e) {\n        e.preventDefault();\n\n        // assume this triggers \"menu:click:foo\"\n        MyFramework.trigger(`menu:click:${this.model.get('name')}`);\n    },\n});\n\n// ... somewhere else in the app\n\nclass MyWorkflow {\n    constructor() {\n        MyFramework.on('menu:click:foo', this.doStuff, this);\n    }\n\n    static doStuff() {\n        // instantiate multiple objects here.\n        // set up event handlers for those objects.\n        // coordinate all of the objects into a meaningful workflow.\n    }\n}\n```", "```\nconst app = require(\"express\")();\n\napp.use(\"/\", (req, res, next) => {\n  req.headers[\"test-header\"] = 1234;\n  next();\n});\n```", "```\nconst app = require(\"express\")();\nconst html = require(\"./data\");\n\n  app.use(\n    \"/\",\n    (req, res, next) => {\n      req.headers[\"test-header\"] = 1234;\n      next();\n    },\n    (req, res, next) => {\n      console.log(`Request has test header: ${!!req.headers[\"test-header\"]}`);\n      next();\n    }\n  );\n\n  app.get(\"/\", (req, res) => {\n    res.set(\"Content-Type\", \"text/html\");\n    res.send(Buffer.from(html));\n  });\n\n  app.listen(8080, function() {\n    console.log(\"Server is running on 8080\");\n  });\n```", "```\nconst CarManager = {\n        // request information\n        requestInfo(model, id) {\n            return `The information for ${model} with ID ${id} is foobar`;\n        },\n\n        // purchase the car\n        buyVehicle(model, id) {\n            return `You have successfully purchased Item ${id}, a ${model}`;\n        },\n\n        // arrange a viewing\n        arrangeViewing(model, id) {\n            return `You have booked a viewing of ${model} ( ${id} ) `;\n        },\n    };\n```", "```\nCarManager.execute('buyVehicle', 'Ford Escort', '453543');\n```", "```\ncarManager.execute = function(name) {\n    return (\n        carManager[name] &&\n        carManager[name].apply(carManager, [].slice.call(arguments, 1))\n    );\n};\n```", "```\ncarManager.execute('arrangeViewing', 'Ferrari', '14523');\ncarManager.execute('requestInfo', 'Ford Mondeo', '54323');\ncarManager.execute('requestInfo', 'Ford Escort', '34232');\ncarManager.execute('buyVehicle', 'Ford Escort', '34232');\n```"]