<html><head></head><body><section data-pdf-bookmark="Chapter 7. User Accounts and Authentication" data-type="chapter" epub:type="chapter"><div class="chapter" id="api-authentication">&#13;
<h1><span class="label">Chapter 7. </span>User Accounts and Authentication</h1>&#13;
&#13;
&#13;
<p><a data-primary="authentication" data-secondary="user accounts and" data-seealso="user accounts and authentication" data-type="indexterm" id="ix_ch07-asciidoc0"/><a data-primary="user accounts and authentication" data-type="indexterm" id="ix_ch07-asciidoc1"/>Picture yourself walking down a dark alley. You are on your way to join the “Secret Club for Super Cool People” (if you’re reading this, you are a well-deserving member). As you enter the hidden door to the club, you are greeted by a receptionist who hands you a form to complete. On the form, you must enter your name and a password, which will be known only by you and the receptionist.</p>&#13;
&#13;
<p>Once you have completed the form, you hand it back to the receptionist, who goes to the back room of the club. In the back room, the receptionist uses a secret key to encrypt your password and then stores the encrypted password in a locked file vault. The receptionist then stamps a coin, on which is pressed your unique membership ID. Upon returning to the front room, the receptionist hands you the coin, which you tuck away in your pocket. Now each time you return to the club, you need only show your coin to gain entrance.</p>&#13;
&#13;
<p>This interaction may sound like something out of a low-budget spy movie, but it’s nearly identical to the process that is followed each time we sign up for a web application. In this chapter, we’ll learn how to build GraphQL mutations that will allow a user to create an account and sign in to our application. We’ll also learn how to encrypt the user’s password and return a token to the user, which they can use to verify their identity when they interact with our application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Application Authentication Flow" data-type="sect1"><div class="sect1" id="idm45339506225912">&#13;
<h1>Application Authentication Flow</h1>&#13;
&#13;
<p><a data-primary="application authentication flow" data-type="indexterm" id="idm45339506224504"/><a data-primary="user accounts and authentication" data-secondary="application authentication flow" data-type="indexterm" id="idm45339506223736"/>Before we get started, let’s step back and map out the flow users will follow when they sign up for an account and log in to an existing account. If you don’t yet understand all of the concepts covered here, don’t worry: we will approach them bit by bit. First, let’s review the <a data-primary="account creation flow" data-type="indexterm" id="idm45339506222328"/>account creation flow:</p>&#13;
<ol>&#13;
<li>&#13;
<p>A user enters their intended email, username, and password into a field in a <a data-primary="user interfaces (UI)" data-secondary="role of" data-type="indexterm" id="idm45339506220248"/>user interface (UI), such as the GraphQL Playground, a web application, or a mobile application.</p>&#13;
</li>&#13;
<li>&#13;
<p>The UI sends a GraphQL mutation to our server with the user’s information.</p>&#13;
</li>&#13;
<li>&#13;
<p>The server encrypts the password and stores the user’s information in the <span class="keep-together">database.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>The server returns a token to the UI, which contains the user’s ID.</p>&#13;
</li>&#13;
<li>&#13;
<p>The UI stores this token, for a specified period of time, and sends it with every request to the server to verify the user.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Now let’s look at the <a data-primary="user sign-in flow" data-type="indexterm" id="idm45339506154312"/>user sign-in flow:</p>&#13;
<ol>&#13;
<li>&#13;
<p>A user enters their email or username and password into a field in a UI.</p>&#13;
</li>&#13;
<li>&#13;
<p>The UI sends a GraphQL mutation to our server with this information.</p>&#13;
</li>&#13;
<li>&#13;
<p>The server decrypts the password stored in the database and compares it with the one the user entered.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the passwords match, the server returns a token to the UI, which contains the user’s ID.</p>&#13;
</li>&#13;
<li>&#13;
<p>The UI stores this token, for a specified period of time, and sends it with every request to the server.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>As you can see, these flows are very similar to our “secret club” flow. In this chapter we’ll focus on implementing the API portions of these interactions.</p>&#13;
<div data-type="note" epub:type="note"><h1>Password Reset Flow</h1>&#13;
<p><a data-primary="passwords" data-secondary="password reset flow" data-type="indexterm" id="idm45339506146568"/>You’ll notice that our application does not allow users to change their password. We could allow users to reset their password with a single mutation resolver, but it is much more secure to verify the reset request via email first. For brevity’s sake we won’t be implementing password reset functionality in this book, but if you are interested in examples and resources for creating a password reset flow, please visit the <a href="https://spectrum.chat/jseverywhere">JavaScript Everywhere Spectrum community</a>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Encryption and Tokens" data-type="sect1"><div class="sect1" id="idm45339506143976">&#13;
<h1>Encryption and Tokens</h1>&#13;
&#13;
<p><a data-primary="user accounts and authentication" data-secondary="core concepts" data-type="indexterm" id="ix_ch07-asciidoc2"/>In our exploration of the user authentication flow, I mentioned encryption and tokens. These sound like mythological dark arts, so let’s take a moment to look at each of these in more detail.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Encrypting Passwords" data-type="sect2"><div class="sect2" id="idm45339506141096">&#13;
<h2>Encrypting Passwords</h2>&#13;
&#13;
<p><a data-primary="encrypting passwords" data-type="indexterm" id="idm45339506139592"/><a data-primary="passwords" data-secondary="encrypting" data-type="indexterm" id="idm45339506138888"/><a data-primary="user accounts and authentication" data-secondary="encrypting passwords" data-type="indexterm" id="idm45339506137944"/>To effectively encrypt user passwords, we should use a combination of hashing and salting. <a data-primary="hashing" data-type="indexterm" id="idm45339506136792"/><em>Hashing</em> is the act of obscuring a string of text by turning it into a seemingly random string. Hashing functions are “one way,” meaning that once the text is hashed it cannot be reverted to the original string. When a password is hashed, the plain text of the password is never stored in our database. <a data-primary="salting" data-type="indexterm" id="idm45339506135416"/><em>Salting</em> is the act of generating a random string of data that will be used in addition to the hashed password. This ensures that even if two user passwords are the same, the hashed and salted versions will be unique.</p>&#13;
&#13;
<p><a data-primary="bcrypt" data-type="indexterm" id="idm45339506133816"/><code>bcrypt</code> is a popular hashing function based on the <a href="https://oreil.ly/4VjII">blowfish cipher</a> and commonly used within a range of web frameworks. In Node.js development we can use the <a href="https://oreil.ly/t2Ppc">bcrypt module</a> to both salt and hash our passwords.</p>&#13;
&#13;
<p>In our application code we would require the <code>bcrypt</code> module and write a function to handle the salting and hashing.</p>&#13;
<div data-type="note" epub:type="note"><h1>Salting and Hashing Examples</h1>&#13;
<p>The following example is for illustrative purposes. We will integrate password salting and hashing with <code>bcrypt</code> later in the chapter.</p>&#13;
</div>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// require the module</code>&#13;
<code class="kr">const</code> <code class="nx">bcrypt</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'bcrypt'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// the cost of processing the salting data, 10 is the default</code>&#13;
<code class="kr">const</code> <code class="nx">saltRounds</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// function for hashing and salting</code>&#13;
<code class="kr">const</code> <code class="nx">passwordEncrypt</code> <code class="o">=</code> <code class="nx">async</code> <code class="nx">password</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">bcrypt</code><code class="p">.</code><code class="nx">hash</code><code class="p">(</code><code class="nx">password</code><code class="p">,</code> <code class="nx">saltRounds</code><code class="p">)</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>In this example, I could pass a password of <code>PizzaP@rty99</code>, which generates a salt of <code>$2a$10$HF2rs.iYSvX1l5FPrX697O</code> and the hashed and salted password of <code>$2a$10$HF2rs.iYSvX1l5FPrX697O9dYF/O2kwHuKdQTdy.7oaMwVga54bWG</code> (which is the salt plus an encrypted password string).</p>&#13;
&#13;
<p>Now when checking a user’s password against the hashed and salted password, we will use the <code>bcrypt</code>’s <code>compare</code> method:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// password is a value provided by the user</code>&#13;
<code class="c1">// hash is retrieved from our DB</code>&#13;
<code class="kr">const</code> <code class="nx">checkPassword</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">plainTextPassword</code><code class="p">,</code> <code class="nx">hashedPassword</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// res is either true or false</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">bcrypt</code><code class="p">.</code><code class="nx">compare</code><code class="p">(</code><code class="nx">hashedPassword</code><code class="p">,</code> <code class="nx">plainTextPassword</code><code class="p">)</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>With the user passwords encrypted, we are able to safely store them in a database.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JSON Web Tokens" data-type="sect2"><div class="sect2" id="idm45339506140504">&#13;
<h2>JSON Web Tokens</h2>&#13;
&#13;
<p><a data-primary="JSON Web Tokens (JWT)" data-type="indexterm" id="idm45339506075928"/><a data-primary="user accounts and authentication" data-secondary="JSON web tokens" data-type="indexterm" id="idm45339506075224"/>As a user it would be extremely frustrating if we needed to enter our username and password each time we wanted to access a single protected page of a site or application. Instead, we can securely store a user’s ID on their device within a <a href="https://jwt.io">JSON Web Token</a>. With each request the user makes from the client, they can send that token, which the server will use to identify the user.</p>&#13;
&#13;
<p>A JSON Web Token (JWT) consists of three parts:</p>&#13;
<dl>&#13;
<dt>Header</dt>&#13;
<dd>&#13;
<p>General<a data-primary="header" data-type="indexterm" id="idm45339506070984"/> information about the token and type of signing algorithm that is being used</p>&#13;
</dd>&#13;
<dt>Payload</dt>&#13;
<dd>&#13;
<p>The<a data-primary="payload" data-type="indexterm" id="idm45339506022904"/> information that we’ve intentionally stored within the token (such as the username or ID)</p>&#13;
</dd>&#13;
<dt>Signature</dt>&#13;
<dd>&#13;
<p>A<a data-primary="signature" data-type="indexterm" id="idm45339506020648"/> means to verify the token</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>If we were to look at the token, it would appear to be made up of random characters with each part separated by a period: <code>xx-header-xx.yy-payload-yy.zz-signature-zz</code>.</p>&#13;
&#13;
<p>In our application code we can use the <a href="https://oreil.ly/IYxkH"><code>jsonwebtoken</code> module</a> to generate and validate our tokens. To do this we pass in the information we wish to store, along with a secret password, which would typically be stored within our <em>.env</em> file.</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">jwt</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'jsonwebtoken'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// generate a JWT that stores a user id</code>&#13;
<code class="kr">const</code> <code class="nx">generateJWT</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">user</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">jwt</code><code class="p">.</code><code class="nx">sign</code><code class="p">({</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">user</code><code class="p">.</code><code class="nx">_id</code> <code class="p">},</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">JWT_SECRET</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// validate the JWT</code>&#13;
<code class="kr">const</code> <code class="nx">validateJWT</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">token</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">jwt</code><code class="p">.</code><code class="nx">verify</code><code class="p">(</code><code class="nx">token</code><code class="p">,</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">JWT_SECRET</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h1>JWTs Versus Sessions</h1>&#13;
<p>If you’ve worked with user authentication in web applications before, you’ve likely come across user <a data-primary="sessions, JSON Web Tokens vs." data-type="indexterm" id="idm45339505932248"/><em>sessions</em>. Session information is stored locally, typically in a cookie, and verified against an in-memory data store (such as <a href="https://redis.io">Redis</a>, though <a href="https://oreil.ly/Ds-ba">traditional databases</a> can be used as well). There is much debate about which is better, JWTs or sessions, but I’ve found that JWTs offer the most flexibility, particularly when integrating with nonweb environments such as native mobile applications. Though sessions work well with GraphQL, JWTs are also the recommended approach in the <a href="https://oreil.ly/OAcJ_">GraphQL Foundation</a> and <a href="https://oreil.ly/27iIm">Apollo Server</a> <span class="keep-together">documentation.</span></p>&#13;
</div>&#13;
&#13;
<p>By using JWTs, we can securely return and store a user’s ID with the client <span class="keep-together">application.</span><a data-startref="ix_ch07-asciidoc2" data-type="indexterm" id="idm45339505926488"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Integrating Authentication into Our API" data-type="sect1"><div class="sect1" id="idm45339505925528">&#13;
<h1>Integrating Authentication into Our API</h1>&#13;
&#13;
<p><a data-primary="application programming interface (API)" data-secondary="integrating authentication into" data-type="indexterm" id="ix_ch07-asciidoc3"/><a data-primary="user accounts and authentication" data-secondary="integrating authentication into API" data-type="indexterm" id="ix_ch07-asciidoc4"/>Now that you have a solid understanding of the components of user authentication, we’ll implement the ability for users to sign up and sign in to our application. To do this we’ll be updating both our GraphQL and Mongoose schemas, writing <code>signUp</code> and <code>signIn</code> mutation resolvers that generate a user token, and validating the token on each request to the server.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="User Schemas" data-type="sect2"><div class="sect2" id="idm45339505920504">&#13;
<h2>User Schemas</h2>&#13;
&#13;
<p><a data-primary="user accounts and authentication" data-secondary="user schemas" data-type="indexterm" id="ix_ch07-asciidoc5"/><a data-primary="user schemas" data-type="indexterm" id="ix_ch07-asciidoc6"/>To begin we will update our GraphQL schema by adding a <code>User</code> type and updating the <code>Note</code> type’s <code>author</code> field to reference the <code>User</code>. To do so, update the <em>src/schema.js</em> file as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Note</code> <code class="p">{</code>&#13;
 <code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code>&#13;
 <code class="nx">content</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
 <code class="nx">author</code><code class="o">:</code> <code class="nx">User</code><code class="o">!</code>&#13;
 <code class="nx">createdAt</code><code class="o">:</code> <code class="nx">DateTime</code><code class="o">!</code>&#13;
 <code class="nx">updatedAt</code><code class="o">:</code> <code class="nx">DateTime</code><code class="o">!</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">User</code> <code class="p">{</code>&#13;
 <code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code>&#13;
 <code class="nx">username</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
 <code class="nx">email</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
 <code class="nx">avatar</code><code class="o">:</code> <code class="nb">String</code>&#13;
 <code class="nx">notes</code><code class="o">:</code> <code class="p">[</code><code class="nx">Note</code><code class="o">!</code><code class="p">]</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When a user signs up for our application, they will submit a username, email address, and password. When a user signs in to our application, they will send a<a data-primary="mutations" data-secondary="user schemas" data-type="indexterm" id="idm45339505912536"/> mutation containing their username or email address along with a password. If a sign-up or sign-in mutation is successful, the API will return a token as a string. To accomplish this in our schema, we will need to add two new mutations to our <em>src/schema.js</em> file, each of which will return a <code>String</code>, which will be our JWT:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Mutation</code> <code class="p">{</code>&#13;
  <code class="p">...</code>&#13;
  <code class="nx">signUp</code><code class="p">(</code><code class="nx">username</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">,</code> <code class="nx">email</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">,</code> <code class="nx">password</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
  <code class="nx">signIn</code><code class="p">(</code><code class="nx">username</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code> <code class="nx">email</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code> <code class="nx">password</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now that our GraphQL schema has been updated, we also need to update our database models. To do this we’ll create a Mongoose schema file in <em>src/models/user.js</em>. This file will be set up similarly to our <code>note</code> model file, with fields for username, email, password, and avatar. We will also require the username and email fields to be unique in our database by setting <code>index: { unique: true }</code>.</p>&#13;
&#13;
<p>To create the user database model, enter the following in your <em>src/models/user.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">mongoose</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'mongoose'</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">UserSchema</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">(</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">username</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
      <code class="nx">index</code><code class="o">:</code> <code class="p">{</code> <code class="nx">unique</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">email</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
      <code class="nx">index</code><code class="o">:</code> <code class="p">{</code> <code class="nx">unique</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">password</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">avatar</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="c1">// Assigns createdAt and updatedAt fields with a Date type</code>&#13;
    <code class="nx">timestamps</code><code class="o">:</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">User</code> <code class="o">=</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">model</code><code class="p">(</code><code class="s1">'User'</code><code class="p">,</code> <code class="nx">UserSchema</code><code class="p">);</code>&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">User</code><code class="p">;</code></pre>&#13;
&#13;
<p>With our user model file in place, we now must update the <em>src/models/index.js</em> to export the model:<a data-startref="ix_ch07-asciidoc6" data-type="indexterm" id="idm45339505738072"/><a data-startref="ix_ch07-asciidoc5" data-type="indexterm" id="idm45339505737576"/></p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">Note</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./note'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">User</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./user'</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">models</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Note</code><code class="p">,</code>&#13;
  <code class="nx">User</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">models</code><code class="p">;</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authentication Resolvers" data-type="sect2"><div class="sect2" id="idm45339505919880">&#13;
<h2>Authentication Resolvers</h2>&#13;
&#13;
<p><a data-primary="authentication" data-secondary="resolvers" data-type="indexterm" id="ix_ch07-asciidoc7"/><a data-primary="user accounts and authentication" data-secondary="authentication resolvers" data-type="indexterm" id="ix_ch07-asciidoc8"/>With our GraphQL and Mongoose schemas written, we can implement the resolvers that will allow a user to sign up and sign in to our application.</p>&#13;
&#13;
<p>First, we need to add a value to the  <code>JWT_SECRET</code> variable in our <em>.env</em> file. This value should be a string without spaces. It will be used to sign our JWT, which allows us to verify them when they are decoded.</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">JWT_SECRET</code><code class="o">=</code>YourPassphrase</pre>&#13;
&#13;
<p>Once we have created this variable, we can import the required packages within our <em>mutation.js</em> file. We will utilize the third-party <code>bcrypt</code>, <code>jsonwebtoken</code>, <code>mongoose</code>, and <code>dotenv</code> packages as well as importing Apollo Server’s <code>AuthenticationError</code> and <code>ForbiddenError</code> utilities. Additionally, we’ll import the <a data-primary="gravatar utility function" data-type="indexterm" id="idm45339505478936"/><code>gravatar</code> utility function, which I’ve included with the project. This will generate a <a href="https://en.gravatar.com">Gravatar image URL</a> from a user’s email address.</p>&#13;
&#13;
<p>In <em>src/resolvers/mutation.js</em>, enter the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">bcrypt</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'bcrypt'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">jwt</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'jsonwebtoken'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code>&#13;
  <code class="nx">AuthenticationError</code><code class="p">,</code>&#13;
  <code class="nx">ForbiddenError</code>&#13;
<code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
<code class="nx">require</code><code class="p">(</code><code class="s1">'dotenv'</code><code class="p">).</code><code class="nx">config</code><code class="p">();</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">gravatar</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'../util/gravatar'</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now we can write our <a data-primary="signUp mutation" data-type="indexterm" id="idm45339505447304"/><code>signUp</code> mutation. This mutation will accept a username, email address, and password as parameters. We will normalize the email address and username by trimming any whitespace and converting it to all lowercase. Next, we will encrypt the user’s password using the <code>bcrypt</code> module. We will also generate a Gravatar image URL for user avatars by using our helper library. Once we have performed these actions, we will store the user in the database and return a token to the user. We can set this all up within a <code>try</code>/<code>catch</code> block, so that our resolver returns an intentionally vague error to the client if there are any issues with the sign-up process.</p>&#13;
&#13;
<p>To accomplish all of this, write the <code>signUp</code> mutation as follows within the <em>src/</em><span class="keep-together"><em>resolvers</em></span><em>/mutation.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">signUp</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">username</code><code class="p">,</code> <code class="nx">email</code><code class="p">,</code> <code class="nx">password</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
   <code class="c1">// normalize email address</code>&#13;
   <code class="nx">email</code> <code class="o">=</code> <code class="nx">email</code><code class="p">.</code><code class="nx">trim</code><code class="p">().</code><code class="nx">toLowerCase</code><code class="p">();</code>&#13;
   <code class="c1">// hash the password</code>&#13;
   <code class="kr">const</code> <code class="nx">hashed</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">bcrypt</code><code class="p">.</code><code class="nx">hash</code><code class="p">(</code><code class="nx">password</code><code class="p">,</code> <code class="mi">10</code><code class="p">);</code>&#13;
   <code class="c1">// create the gravatar url</code>&#13;
   <code class="kr">const</code> <code class="nx">avatar</code> <code class="o">=</code> <code class="nx">gravatar</code><code class="p">(</code><code class="nx">email</code><code class="p">);</code>&#13;
   <code class="k">try</code> <code class="p">{</code>&#13;
     <code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">User</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code>&#13;
       <code class="nx">username</code><code class="p">,</code>&#13;
       <code class="nx">email</code><code class="p">,</code>&#13;
       <code class="nx">avatar</code><code class="p">,</code>&#13;
       <code class="nx">password</code><code class="o">:</code> <code class="nx">hashed</code>&#13;
     <code class="p">});</code>&#13;
&#13;
     <code class="c1">// create and return the json web token</code>&#13;
     <code class="k">return</code> <code class="nx">jwt</code><code class="p">.</code><code class="nx">sign</code><code class="p">({</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">user</code><code class="p">.</code><code class="nx">_id</code> <code class="p">},</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">JWT_SECRET</code><code class="p">);</code>&#13;
   <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>&#13;
     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>&#13;
     <code class="c1">// if there's a problem creating the account, throw an error</code>&#13;
     <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Error creating account'</code><code class="p">);</code>&#13;
   <code class="p">}</code>&#13;
 <code class="p">},</code></pre>&#13;
&#13;
<p>Now, if we switch over to the GraphQL Playground in our browser, we can try out our <code>signUp</code> mutation. To do so we’ll write a GraphQL mutation with username, email, and password values:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">signUp</code><code class="p">(</code>&#13;
    <code class="nx">username</code><code class="o">:</code> <code class="s2">"BeeBoop"</code><code class="p">,</code>&#13;
    <code class="nx">email</code><code class="o">:</code> <code class="s2">"robot@example.com"</code><code class="p">,</code>&#13;
    <code class="nx">password</code><code class="o">:</code> <code class="s2">"NotARobot10010!"</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When we run the mutation, our server will return a token like this (<a data-type="xref" href="#signup_mutation">Figure 7-1</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="s2">"data"</code><code class="o">:</code> <code class="p">{</code>&#13;
   <code class="s2">"signUp"</code><code class="o">:</code> <code class="s2">"eyJhbGciOiJIUzI1NiIsInR5cCI6..."</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="signup_mutation">&#13;
<img alt="A screenshot of the signUp mutation in the GraphQL Playground" src="assets/jsev_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>The signUp mutation in the GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p>The next step will be to write our <a data-primary="signIn mutation" data-type="indexterm" id="idm45339505224648"/><code>signIn</code> mutation. This mutation will accept the user’s username, email, and password. It will then find the user in the database, based on the username or email address. Once the user is located, it will decrypt the password stored in the database and compare it with the one the user has entered. If the user and password match, our application will return a token to the user. If they don’t match, we’ll want to throw an error.</p>&#13;
&#13;
<p>Write this mutation as follows in the <em>src/resolvers/mutation.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"> <code class="nx">signIn</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">username</code><code class="p">,</code> <code class="nx">email</code><code class="p">,</code> <code class="nx">password</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
   <code class="k">if</code> <code class="p">(</code><code class="nx">email</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="c1">// normalize email address</code>&#13;
      <code class="nx">email</code> <code class="o">=</code> <code class="nx">email</code><code class="p">.</code><code class="nx">trim</code><code class="p">().</code><code class="nx">toLowerCase</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
&#13;
   <code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">User</code><code class="p">.</code><code class="nx">findOne</code><code class="p">({</code>&#13;
     <code class="nx">$or</code><code class="o">:</code> <code class="p">[{</code> <code class="nx">email</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">username</code> <code class="p">}]</code>&#13;
   <code class="p">});</code>&#13;
&#13;
   <code class="c1">// if no user is found, throw an authentication error</code>&#13;
   <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">user</code><code class="p">)</code> <code class="p">{</code>&#13;
     <code class="k">throw</code> <code class="k">new</code> <code class="nx">AuthenticationError</code><code class="p">(</code><code class="s1">'Error signing in'</code><code class="p">);</code>&#13;
   <code class="p">}</code>&#13;
&#13;
   <code class="c1">// if the passwords don't match, throw an authentication error</code>&#13;
   <code class="kr">const</code> <code class="nx">valid</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">bcrypt</code><code class="p">.</code><code class="nx">compare</code><code class="p">(</code><code class="nx">password</code><code class="p">,</code> <code class="nx">user</code><code class="p">.</code><code class="nx">password</code><code class="p">);</code>&#13;
   <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">valid</code><code class="p">)</code> <code class="p">{</code>&#13;
     <code class="k">throw</code> <code class="k">new</code> <code class="nx">AuthenticationError</code><code class="p">(</code><code class="s1">'Error signing in'</code><code class="p">);</code>&#13;
   <code class="p">}</code>&#13;
&#13;
   <code class="c1">// create and return the json web token</code>&#13;
   <code class="k">return</code> <code class="nx">jwt</code><code class="p">.</code><code class="nx">sign</code><code class="p">({</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">user</code><code class="p">.</code><code class="nx">_id</code> <code class="p">},</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">JWT_SECRET</code><code class="p">);</code>&#13;
 <code class="p">}</code></pre>&#13;
&#13;
<p>We can now visit the GraphQL Playground in our browser and try out the <code>signIn</code> mutation, using the account we created with our <code>signUp</code> mutation:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">signIn</code><code class="p">(</code>&#13;
    <code class="nx">username</code><code class="o">:</code> <code class="s2">"BeeBoop"</code><code class="p">,</code>&#13;
    <code class="nx">email</code><code class="o">:</code> <code class="s2">"robot@example.com"</code><code class="p">,</code>&#13;
    <code class="nx">password</code><code class="o">:</code> <code class="s2">"NotARobot10010!"</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Again, if successful, our mutation should resolve with a JWT (<a data-type="xref" href="#signin_mutation">Figure 7-2</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"data"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="s2">"signIn"</code><code class="o">:</code> <code class="s2">"&lt;TOKEN VALUE&gt;"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="signin_mutation">&#13;
<img alt="A screenshot of the signIn mutation in the GraphQL Playground" src="assets/jsev_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>The signIn mutation in the GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p>With these two resolvers in place, users will be able to both sign up for and sign in to our application using JWTs. To experiment with this, try adding more accounts and even intentionally entering incorrect information, such as passwords that do not match, to see what the GraphQL API returns<a data-startref="ix_ch07-asciidoc8" data-type="indexterm" id="idm45339504972344"/><a data-startref="ix_ch07-asciidoc7" data-type="indexterm" id="idm45339504971640"/>.<a data-startref="ix_ch07-asciidoc4" data-type="indexterm" id="idm45339504970840"/><a data-startref="ix_ch07-asciidoc3" data-type="indexterm" id="idm45339504970136"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding the User to the Resolver Context" data-type="sect1"><div class="sect1" id="idm45339505591640">&#13;
<h1>Adding the User to the Resolver Context</h1>&#13;
&#13;
<p><a data-primary="resolvers" data-secondary="adding the user to the" data-type="indexterm" id="ix_ch07-asciidoc9"/><a data-primary="user accounts and authentication" data-secondary="adding the user to the resolver context" data-type="indexterm" id="ix_ch07-asciidoc10"/>Now that a user can use a GraphQL mutation to receive a unique token, we’ll need to verify that token on each request. Our expectation will be that our client, whether it be web, mobile, or desktop, will send the token with the request in an HTTP header named <code>Authorization</code>. We can then read the token from the HTTP header, decode it using our <code>JWT_SECRET</code> variable, and pass along the user’s information with the context to each GraphQL resolver. By doing this, we can determine if a signed-in user is making a request, and if so, which user it is.</p>&#13;
&#13;
<p>First, import the <code>jsonwebtoken</code> module into the <em>src/index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">jwt</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'jsonwebtoken'</code><code class="p">);</code></pre>&#13;
&#13;
<p>With the module imported, we can add a function that will verify the validity of the token:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// get the user info from a JWT</code>&#13;
<code class="kr">const</code> <code class="nx">getUser</code> <code class="o">=</code> <code class="nx">token</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">token</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
      <code class="c1">// return the user information from the token</code>&#13;
      <code class="k">return</code> <code class="nx">jwt</code><code class="p">.</code><code class="nx">verify</code><code class="p">(</code><code class="nx">token</code><code class="p">,</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">JWT_SECRET</code><code class="p">);</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="c1">// if there's a problem with the token, throw an error</code>&#13;
      <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Session invalid'</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now, within each GraphQL request we will grab the token from the header of the request, attempt to verify the validity of the token, and add the user’s information to the context. Once this is done, each GraphQL resolver will have access to the user ID we stored in the token.</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code>&#13;
  <code class="nx">typeDefs</code><code class="p">,</code>&#13;
  <code class="nx">resolvers</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="p">({</code> <code class="nx">req</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// get the user token from the headers</code>&#13;
    <code class="kr">const</code> <code class="nx">token</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">headers</code><code class="p">.</code><code class="nx">authorization</code><code class="p">;</code>&#13;
    <code class="c1">// try to retrieve a user with the token</code>&#13;
    <code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="nx">getUser</code><code class="p">(</code><code class="nx">token</code><code class="p">);</code>&#13;
    <code class="c1">// for now, let's log the user to the console:</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">);</code>&#13;
    <code class="c1">// add the db models and the user to the context</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">models</code><code class="p">,</code> <code class="nx">user</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Though we’re not yet performing user interactions, we can test our user context within the GraphQL Playground. In the lower-left corner of the GraphQL Playground UI, there is a space labeled HTTP Headers. In that portion of the UI, we can add a header that contains a JWT that was returned in either our <code>signUp</code> or <code>signIn</code> mutation as follows (<a data-type="xref" href="#auth_header">Figure 7-3</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"Authorization"</code><code class="o">:</code> <code class="s2">"&lt;YOUR_JWT&gt;"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="auth_header">&#13;
<img alt="A screenshot of the authorization header in the GraphQL Playground" src="assets/jsev_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>The authorization header in the GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can test this authorization header by passing it along with any query or mutation in the GraphQL Playground. To do this, we’ll write a simple <code>notes</code> query and include the <code>Authorization</code> header (<a data-type="xref" href="#auth_query">Figure 7-4</a>).</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">notes</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="auth_query">&#13;
<img alt="A screenshot of the authorization header and a query in the GraphQL Playground" src="assets/jsev_0704.png"/>&#13;
<h6><span class="label">Figure 7-4. </span>The authorization header and query in the GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">If our authentication is successful, we should see an object containing the user’s ID logged to our terminal application’s output, as shown in <a data-type="xref" href="#auth_console">Figure 7-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="auth_console">&#13;
<img alt="A screenshot of the user object in the development console" src="assets/jsev_0705.png"/>&#13;
<h6><span class="label">Figure 7-5. </span>The user object in our terminal’s console.log output</h6>&#13;
</div></figure>&#13;
&#13;
<p>With all of these pieces in place, we are now able to authenticate users in our API.<a data-startref="ix_ch07-asciidoc10" data-type="indexterm" id="idm45339504722888"/><a data-startref="ix_ch07-asciidoc9" data-type="indexterm" id="idm45339504722184"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339504968872">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>User account creation and sign-in flows can feel mysterious and overwhelming, but by taking it piece by piece, we can implement a stable and secure authentication flow in our API. In this chapter, we created both sign-up and sign-in user flows. These are a small fragment of the account management ecosystem, but will provide us with a stable foundation on which to build. In the next chapter we’ll implement user-specific interactions in our API, which will assign ownership to notes and activities within the application.<a data-startref="ix_ch07-asciidoc1" data-type="indexterm" id="idm45339504719672"/><a data-startref="ix_ch07-asciidoc0" data-type="indexterm" id="idm45339504718968"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>