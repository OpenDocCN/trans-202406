["```\nconst MessageList = ({ messages }) => (\n  <ul>\n    {messages.map((message, index) => (\n      <li key={index}>{message}</li>\n    ))}\n  </ul>\n);\n```", "```\nconst MessageInput = ({ onSubmit }) => {\n  const [message, setMessage] = useState(\"\");\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    onSubmit(message);\n    setMessage(\"\");\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={message}\n        onChange={(e) => setMessage(e.target.value)}\n      />\n      <button type=\"submit\">Send</button>\n    </form>\n  );\n};\n```", "```\nconst ChatApp = () => {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() => {\n    // Connect to the server and subscribe to incoming messages\n    const socket = new WebSocket(\"wss://your-websocket-server.com\");\n    socket.onmessage = (event) => {\n      setMessages((prevMessages) => [...prevMessages, event.data]);\n    };\n\n    return () => {\n      socket.close();\n    };\n  }, []);\n\n  const sendMessage = (message) => {\n    // Send the message to the server\n  };\n\n  return (\n    <div>\n      <MessageList messages={messages} />\n      <MessageInput onSubmit={sendMessage} />\n    </div>\n  );\n};\n```", "```\nconst ChatApp = () => {\n  const [messages, setMessages] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  useEffect(() => {\n    // Connect to the server and subscribe to incoming messages\n    const socket = new WebSocket(\"wss://your-websocket-server.com\");\n    socket.onmessage = (event) => {\n      startTransition(() => {\n        setMessages((prevMessages) => [...prevMessages, event.data]);\n      });\n    };\n\n    return () => {\n      socket.close();\n    };\n  }, []);\n\n  const sendMessage = (message) => {\n    // Send the message to the server\n  };\n\n  return (\n    <div>\n      <MessageList messages={messages} />\n      <MessageInput onSubmit={sendMessage} />\n    </div>\n  );\n};\n```", "```\nexport function ensureRootIsScheduled(root: FiberRoot): void {\n  // This function is called whenever a root receives an update. It does two\n  // things 1) it ensures the root is in the root schedule, and 2) it ensures\n  // there's a pending microtask to process the root schedule.\n  //\n  // Most of the actual scheduling logic does not happen until\n  // `scheduleTaskForRootDuringMicrotask` runs.\n\n  // Add the root to the schedule\n  if (root === lastScheduledRoot || root.next !== null) {\n    // Fast path. This root is already scheduled.\n  } else {\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n    } else {\n      lastScheduledRoot.next = root;\n      lastScheduledRoot = root;\n    }\n  }\n\n  // Any time a root received an update, we set this to true until the next time\n  // we process the schedule. If it's false, then we can quickly exit flushSync\n  // without consulting the schedule.\n  mightHavePendingSyncWork = true;\n\n  // At the end of the current event, go through each of the roots and ensure\n  // there's a task scheduled for each one at the correct priority.\n  if (__DEV__ && ReactCurrentActQueue.current !== null) {\n    // We're inside an `act` scope.\n    if (!didScheduleMicrotask_act) {\n      didScheduleMicrotask_act = true;\n      scheduleImmediateTask(processRootScheduleInMicrotask);\n    }\n  } else {\n    if (!didScheduleMicrotask) {\n      didScheduleMicrotask = true;\n      scheduleImmediateTask(processRootScheduleInMicrotask);\n    }\n  }\n\n  if (!enableDeferRootSchedulingToMicrotask) {\n    // While this flag is disabled, we schedule the render task immediately\n    // instead of waiting for a microtask.\n    // TODO: We need to land enableDeferRootSchedulingToMicrotask ASAP to\n    // unblock additional features we have planned.\n    scheduleTaskForRootDuringMicrotask(root, now());\n  }\n\n  if (\n    __DEV__ &&\n    ReactCurrentActQueue.isBatchingLegacy &&\n    root.tag === LegacyRoot\n  ) {\n    // Special `act` case: Record whenever a legacy update is scheduled.\n    ReactCurrentActQueue.didScheduleLegacyUpdate = true;\n  }\n}\n```", "```\nif (nextLane === Sync) {\n  queueMicrotask(processNextLane);\n} else {\n  Scheduler.scheduleCallback(callback, processNextLane);\n}\n```", "```\nimport React, { useState, useTransition } from \"react\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [isPending, startTransition] = useTransition();\n\n  const handleClick = () => {\n    doSomethingImportant();\n    startTransition(() => {\n      setCount(count + 1);\n    });\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment</button>\n      {isPending && <p>Loading...</p>}\n    </div>\n  );\n}\n\nexport default App;\n```", "```\nimport React, { useState, useTransition } from \"react\";\n\nconst PageOne = () => <div>Page One</div>;\nconst PageTwo = () => <div>Page Two</div>;\n\nfunction App() {\n  const [currentPage, setCurrentPage] = useState(\"pageOne\");\n  const [isPending, startTransition] = useTransition();\n\n  const handleNavigation = (page) => {\n    startTransition(() => {\n      setCurrentPage(page);\n    });\n  };\n\n  const renderPage = () => {\n    switch (currentPage) {\n      case \"pageOne\":\n        return <PageOne />;\n      case \"pageTwo\":\n        return <PageTwo />;\n      default:\n        return <div>Unknown page</div>;\n    }\n  };\n\n  return (\n    <div>\n      <nav>\n        <button onClick={() => handleNavigation(\"pageOne\")}>Page One</button>\n        <button onClick={() => handleNavigation(\"pageTwo\")}>Page Two</button>\n      </nav>\n      {isPending && <p>Loading...</p>}\n      {renderPage()}\n    </div>\n  );\n}\n\nexport default App;\n```", "```\nfunction useDeferredValue(value) {\n  const [newValue, setNewValue] = useState(value); // only stores initial value\n  useEffect(() {\n    // update the returned value in a transition whenever it changes,\n    // \"deferring\" it\n    startTransition(() => {\n      setNewValue(value);\n    });\n }, [value]);\n\n return newValue;\n}\n```", "```\nimport React, { memo useState, useDeferredValue } from \"react\";\n\nfunction App() {\n  const [searchValue, setSearchValue] = useState(\"\");\n  const deferredSearchValue = useDeferredValue(searchValue);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={searchValue}\n        onChange={(event) => setSearchValue(event.target.value)}\n      />\n      <SearchResults searchValue={deferredSearchValue} />\n    </div>\n  );\n}\n\nconst SearchResults = memo(({ searchValue }) => {\n  // Perform the search and render the results\n})\n```", "```\nimport React, { memo, useState, useMemo, useDeferredValue } from \"react\";\n\nfunction App() {\n  const [filter, setFilter] = useState(\"\");\n  const deferredFilter = useDeferredValue(filter);\n\n  const items = useMemo(() => generateLargeListOfItems(), []);\n  const filteredItems = useMemo(() => {\n    return items.filter((item) => item.includes(deferredFilter));\n  }, [items, deferredFilter]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={filter}\n        onChange={(event) => setFilter(event.target.value)}\n      />\n      <ItemList items={filteredItems} />\n    </div>\n  );\n}\n\nconst ItemList = memo(({ items }) => {\n  // Render the list of items\n});\n\nfunction generateLargeListOfItems() {\n  // Generate a large list of items for the example\n}\n```", "```\nimport { useState, useSyncExternalStore, useTransition } from \"react\";\n\n// External state\nlet count = 0;\nsetInterval(() => count++, 1);\n\nexport default function App() {\n  const [name, setName] = useState(\"\");\n  const [isPending, startTransition] = useTransition();\n\n  const updateName = (newVal) => {\n    startTransition(() => {\n      setName(newVal);\n    });\n  };\n\n  return (\n    <div>\n      <input value={name} onChange={(e) => updateName(e.target.value)} />\n      {isPending && <div>Loading...</div>}\n      <ul>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n      </ul>\n    </div>\n  );\n}\n\nconst ExpensiveComponent = () => {\n  const now = performance.now();\n\n  while (performance.now() - now < 100) {\n    // Do nothing, just wait.\n  }\n\n  return <>Expensive count is {count}</>;\n};\n```", "```\n<UserDetails id={user.id} />\n```", "```\nconst value = useSyncExternalStore(store.subscribe, store.getSnapshot);\n```", "```\nconst store = {\n  subscribe(rerender) {\n    const newData = getNewData().then(rerender);\n    return () => {\n      // unsubscribe somehow\n    };\n  },\n};\n```", "```\nconst store = {\n  subscribe(rerenderImmediately) {\n    window.addEventListener(\"resize\", rerenderImmediately);\n    return () => {\n      window.removeEventListener(\"resize\", rerenderImmediately);\n    };\n  },\n};\n```", "```\nconst store = {\n  subscribe(immediatelyRerenderSynchronously) {\n    window.addEventListener(\"resize\",\n      immediatelyRerenderSynchronously);\n    return () => {\n      window.removeEventListener(\"resize\",\n        immediatelyRerenderSynchronously);\n    };\n  },\n  getSnapshot() {\n    return {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n  },\n};\n```", "```\nconst store = {\n  subscribe() {},\n  getSnapshot() {\n    return count;\n  },\n};\n```", "```\nimport { useState, useSyncExternalStore, useTransition } from \"react\";\n\nlet count = 0;\nsetInterval(() => count++, 1);\n\nexport default function App() {\n  const [name, setName] = useState(\"\");\n  const [, startTransition] = useTransition();\n\n  const updateName = (newVal) => {\n    startTransition(() => {\n      setName(newVal);\n    });\n  };\n\n  return (\n    <div>\n      <input value={name} onChange={(e) => updateName(e.target.value)} />\n      <ul>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n      </ul>\n    </div>\n  );\n}\n\nconst ExpensiveComponent = () => {\n  // Instead of reading count globally,\n  // we'll use the hook to ensure consistent state\n  const consistentCount = useSyncExternalStore(\n    () => {},\n    () => count\n  );\n\n  const now = performance.now();\n  while (performance.now() - now < 100) {\n    // Do nothing\n  }\n\n  return <>Expensive count is {consistentCount}</>;\n};\n```", "```\nimport { useState, useSyncExternalStore, useTransition } from \"react\";\n\nlet count = 0;\nsetInterval(() => count++, 1);\n\nconst store = {\n  subscribe(forceSyncRerender) {\n    // Whenever count changes,\n    forceSyncRerender();\n  },\n  getSnapshot() {\n    return count;\n  },\n};\n\nexport default function App() {\n  const [name, setName] = useState(\"\");\n  const [, startTransition] = useTransition();\n\n  const updateName = (newVal) => {\n    startTransition(() => {\n      setName(newVal);\n    });\n  };\n\n  return (\n    <div>\n      <input value={name} onChange={(e) => updateName(e.target.value)} />\n      <ul>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n        <li>\n          <ExpensiveComponent />\n        </li>\n      </ul>\n    </div>\n  );\n}\n\nconst ExpensiveComponent = () => {\n  // Instead of reading count globally,\n  // we'll use the hook to ensure consistent state\n  const consistentCount = useSyncExternalStore(\n    store.subscribe,\n    store.getSnapshot\n  );\n\n  const now = performance.now();\n  while (performance.now() - now < 100) {\n    // Do nothing\n  }\n\n  return <>Expensive count is {consistentCount}</>;\n};\n```"]