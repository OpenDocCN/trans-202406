<html><head></head><body><section data-pdf-bookmark="Chapter 10. Security" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_security">&#13;
<h1><span class="label">Chapter 10. </span>Security</h1>&#13;
&#13;
&#13;
<p>Running applications in Kubernetes comes with a shared responsibility between developers and ops folks to ensure <a data-primary="security" data-type="indexterm" id="ix_scrty"/>that attack vectors are minimized, least-privileges principles are followed, and access to resources is clearly defined. In this chapter, we will present recipes that you can, and should, use to make sure your cluster and apps run securely. The recipes in this chapter cover the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The role and usage of service accounts</p>&#13;
</li>&#13;
<li>&#13;
<p>Role-based access control (RBAC)</p>&#13;
</li>&#13;
<li>&#13;
<p>Defining a pod’s security context</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.1 Providing a Unique Identity for an Application" data-type="sect1"><div class="sect1" id="service_accounts">&#13;
<h1>10.1 Providing a Unique Identity for an Application</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id88">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to grant an application access to restricted resources at a fine-grained level.<a data-primary="security" data-secondary="providing unique identity for an application" data-type="indexterm" id="ix_scrtyappID"/><a data-primary="applications, providing unique identity for" data-type="indexterm" id="ix_appID"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id89">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a service account with specific secret access and reference it within a pod specification.<a data-primary="service accounts" data-type="indexterm" id="id1029"/></p>&#13;
&#13;
<p>To begin, create a dedicated namespace for this and the following recipe called <code>sec</code>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create namespace sec</strong>&#13;
namespace/sec created&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">Then, create a new service account called <code>myappsa</code> in that namespace and take a closer look at it:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create serviceaccount myappsa -n sec</strong>&#13;
serviceaccount/myappsa created&#13;
&#13;
$ <strong>kubectl describe sa myappsa -n sec</strong>&#13;
Name:                myappsa&#13;
Namespace:           sec&#13;
Labels:              &lt;none&gt;&#13;
Annotations:         &lt;none&gt;&#13;
Image pull secrets:  &lt;none&gt;&#13;
Mountable secrets:   &lt;none&gt;&#13;
Tokens:              &lt;none&gt;&#13;
Events:              &lt;none&gt;&#13;
</pre>&#13;
&#13;
<p>You can reference this service account in a pod manifest, which we’re calling <em>serviceaccountpod.yaml</em>, as shown next. <a data-primary="pods" data-secondary="creating and referencing service account in manifest" data-type="indexterm" id="id1030"/><a data-primary="service accounts" data-secondary="referencing in pod manifest" data-type="indexterm" id="id1031"/>Notice that we are also placing this pod in the <code>sec</code> namespace:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sec</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myappsa</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">main</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.36</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"bin/sh"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">10000"</code><code class="w"/></pre>&#13;
&#13;
<p>Create the pod:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f serviceaccountpod.yaml</strong>&#13;
pod/myapp created&#13;
</pre>&#13;
&#13;
<p>The service account’s API credentials will be automounted at <em>/var/run/secrets/kubernetes.io/serviceaccount/token</em>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl exec myapp -n sec -- \&#13;
    cat /var/run/secrets/kubernetes.io/serviceaccount/token</strong>&#13;
eyJhbGciOiJSUzI1NiIsImtpZCI6IkdHeTRHOUUwNl ...&#13;
</pre>&#13;
&#13;
<p>Indeed, the <code>myappsa</code> service account token has been mounted in the expected place in the pod and can be used going forward.</p>&#13;
&#13;
<p>While a service account on its own is not super useful, it forms the basis for fine-grained access control; see <a data-type="xref" href="#rbac_intro">Recipe 10.2</a> for more on this.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id90">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Being able to identify an entity is the prerequisite for authentication and authorization. <a data-primary="authorization" data-secondary="ability to identify an entity as prerequisite" data-type="indexterm" id="id1032"/><a data-primary="authentication" data-secondary="of an app" data-secondary-sortas="app" data-type="indexterm" id="id1033"/>From the API server’s point of view, there are two sorts of entities: human users and applications.<a data-primary="entities" data-type="indexterm" id="id1034"/> While user identity (management) is outside of the scope of Kubernetes, there is a first-class resource representing the identity of an app: the service account.<a data-primary="service accounts" data-secondary="representing identity of apps" data-type="indexterm" id="id1035"/></p>&#13;
&#13;
<p>Technically, the authentication of an app is captured by the token available in a file at the location <em>/var/run/secrets/kubernetes.io/serviceaccount/token</em>, which is mounted automatically through a secret. The service accounts are namespaced resources and are represented as follows:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">system:serviceaccount:<code class="nv">$NAMESPACE</code>:<code class="nv">$SERVICEACCOUNT</code><code class="w"/></pre>&#13;
&#13;
<p>Listing the service accounts in a certain namespace gives you something like the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get sa -n sec</strong>&#13;
NAME      SECRETS   AGE&#13;
default   0         3m45s&#13;
myappsa   0         3m2s&#13;
</pre>&#13;
&#13;
<p>Notice the service account called <code>default</code> here. This is created automatically; if you don’t set the service account for a pod explicitly, as was done in the solution, it will be assigned the <code>default</code> service account in its namespace.<a data-primary="default service account" data-type="indexterm" id="id1036"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1037">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/FsNK7">“Managing Service Accounts”</a> in the Kubernetes &#13;
<span class="keep-together">documentation</span></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/mNP_M">“Configure Service Accounts for Pods”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Fg06V">“Pull an Image from a Private Registry”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.2 Listing and Viewing Access Control Information" data-type="sect1"><div class="sect1" id="rbac_intro">&#13;
<h1>10.2 Listing and Viewing Access Control Information</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id91">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to learn what actions you’re allowed to do—​for example, updating a &#13;
<span class="keep-together">deployment</span> or listing secrets.<a data-primary="security" data-secondary="providing unique identity for an application" data-startref="ix_scrtyappID" data-type="indexterm" id="id1038"/><a data-primary="applications, providing unique identity for" data-startref="ix_appID" data-type="indexterm" id="id1039"/><a data-primary="access control" data-secondary="listing and viewing information about" data-type="indexterm" id="ix_ACinfo"/><a data-primary="security" data-secondary="listing and viewing access control information" data-type="indexterm" id="ix_scrtyACinfo"/><a data-primary="role-based access control" data-see="RBAC" data-type="indexterm" id="id1040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id92">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The following solution assumes you’re using RBAC as the <a href="https://oreil.ly/K7y65">authorization mode</a>. <a data-primary="RBAC (role-based access control)" data-type="indexterm" id="ix_RBAC"/>RBAC is the default mode for access control on Kubernetes.</p>&#13;
&#13;
<p>To check if a certain action on a resource is allowed for a specific user, use <code>kubectl auth can-i</code>. For example, you can execute this command to check if the service account called <code>system:serviceaccount:sec:myappsa</code> that you created in the previous recipe is allowed to list pods in the namespace <code>sec</code>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl auth can-i list pods --as=system:serviceaccount:sec:myappsa -n=sec</strong>&#13;
no&#13;
</pre>&#13;
&#13;
<p>You can assign roles to a service account using Kubernetes’s built-in RBAC system. For example, you can give the service account permission to view all resources in a given namespace by assigning it the predefined <code>view</code> cluster role for that namespace:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create rolebinding my-sa-view \&#13;
    --clusterrole=view \&#13;
    --serviceaccount=sec:myappsa \&#13;
    --namespace=sec</strong>&#13;
rolebinding.rbac.authorization.k8s.io/my-sa-view created&#13;
</pre>&#13;
&#13;
<p>Now if you run the same <code>can-i</code> command, you’ll see that the service account now has permission to read pods in the <code>sec</code> namespace:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl auth can-i list pods --as=system:serviceaccount:sec:myappsa -n=sec</strong>&#13;
yes&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For this recipe to work on Minikube, depending on the version you are running, you may need to add the parameter <code class="keep-together">--extra-config=apiserver.authorization-mode=Node,RBAC</code> when starting your Minikube cluster.</p>&#13;
</div>&#13;
&#13;
<p>To list the roles available in a namespace, do this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get roles -n=kube-system</strong>&#13;
extension-apiserver-authentication-reader        2023-04-14T15:06:36Z&#13;
kube-proxy                                       2023-04-14T15:06:38Z&#13;
kubeadm:kubelet-config                           2023-04-14T15:06:36Z&#13;
kubeadm:nodes-kubeadm-config                     2023-04-14T15:06:36Z&#13;
system::leader-locking-kube-controller-manager   2023-04-14T15:06:36Z&#13;
system::leader-locking-kube-scheduler            2023-04-14T15:06:36Z&#13;
system:controller:bootstrap-signer               2023-04-14T15:06:36Z&#13;
system:controller:cloud-provider                 2023-04-14T15:06:36Z&#13;
system:controller:token-cleaner                  2023-04-14T15:06:36Z&#13;
system:persistent-volume-provisioner             2023-04-14T15:06:39Z&#13;
&#13;
$ <strong>kubectl get clusterroles</strong>&#13;
NAME                               CREATED AT&#13;
admin                              2023-04-14T15:06:36Z&#13;
cluster-admin                      2023-04-14T15:06:36Z&#13;
edit                               2023-04-14T15:06:36Z&#13;
kubeadm:get-nodes                  2023-04-14T15:06:37Z&#13;
system:aggregate-to-admin          2023-04-14T15:06:36Z&#13;
system:aggregate-to-edit           2023-04-14T15:06:36Z&#13;
system:aggregate-to-view           2023-04-14T15:06:36Z&#13;
system:auth-delegator              2023-04-14T15:06:36Z&#13;
...&#13;
</pre>&#13;
&#13;
<p>The output shows the predefined roles, which you can use directly for users and service accounts.</p>&#13;
&#13;
<p>To further explore a certain role and understand what actions are allowed, use the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl describe clusterroles/view</strong>&#13;
Name:           view&#13;
Labels:         kubernetes.io/bootstrapping=rbac-defaults&#13;
                rbac.authorization.k8s.io/aggregate-to-edit=true&#13;
Annotations:    rbac.authorization.kubernetes.io/autoupdate=true&#13;
PolicyRule:&#13;
  Resources                                     Non-Resource URLs     ...  ...&#13;
  ---------                                     -----------------     ---  ---&#13;
  bindings                                      []                    ...  ...&#13;
  configmaps                                    []                    ...  ...&#13;
  cronjobs.batch                                []                    ...  ...&#13;
  daemonsets.extensions                         []                    ...  ...&#13;
  deployments.apps                              []                    ...  ...&#13;
  deployments.extensions                        []                    ...  ...&#13;
  deployments.apps/scale                        []                    ...  ...&#13;
  deployments.extensions/scale                  []                    ...  ...&#13;
  endpoints                                     []                    ...  ...&#13;
  events                                        []                    ...  ...&#13;
  horizontalpodautoscalers.autoscaling          []                    ...  ...&#13;
  ingresses.extensions                          []                    ...  ...&#13;
  jobs.batch                                    []                    ...  ...&#13;
  limitranges                                   []                    ...  ...&#13;
  namespaces                                    []                    ...  ...&#13;
  namespaces/status                             []                    ...  ...&#13;
  persistentvolumeclaims                        []                    ...  ...&#13;
  pods                                          []                    ...  ...&#13;
  pods/log                                      []                    ...  ...&#13;
  pods/status                                   []                    ...  ...&#13;
  replicasets.extensions                        []                    ...  ...&#13;
  replicasets.extensions/scale                  []                    ...  ...&#13;
  ...&#13;
</pre>&#13;
&#13;
<p>In addition to the default roles defined in the <code>kube-system</code> namespace, you can define your own; see <a data-type="xref" href="#access_control">Recipe 10.3</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id1041">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>As you can see in <a data-type="xref" href="#rbac-concept">Figure 10-1</a>, there are a couple of moving parts when dealing with RBAC authorization:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An entity—​that is, a group, user, or service account</p>&#13;
</li>&#13;
<li>&#13;
<p>A resource, such as a pod, service, or secret</p>&#13;
</li>&#13;
<li>&#13;
<p>A role, which defines rules for actions on a resource</p>&#13;
</li>&#13;
<li>&#13;
<p>A role binding, which applies a role to an entity</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="rbac-concept">&#13;
<img alt="RBAC Concept" src="assets/kcb2_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>The RBAC concept</h6>&#13;
</div></figure>&#13;
&#13;
<p>The actions on a resource that a role uses in its rules are the so-called verbs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>get</code>, <code>list</code>, <code>watch</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>create</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>update</code>/<code>patch</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>delete</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Concerning the roles, we differentiate between two types:</p>&#13;
<dl>&#13;
<dt>Cluster-wide</dt>&#13;
<dd>&#13;
<p>Cluster roles and their respective cluster role bindings. Note that you can also attach cluster roles to regular role bindings.</p>&#13;
</dd>&#13;
<dt>Namespace-wide</dt>&#13;
<dd>&#13;
<p>Roles and role bindings.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In <a data-type="xref" href="#access_control">Recipe 10.3</a>, we will further discuss how you can create your own rules and apply them to users and resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1042">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/57NdL">“Authorization Overview”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/n0i0c">“Using RBAC Authorization”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.3 Controlling Access to Resources" data-type="sect1"><div class="sect1" id="access_control">&#13;
<h1>10.3 Controlling Access to Resources</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id93">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>For a given user or application, you want to allow or deny a certain action, such as viewing secrets or updating a deployment.<a data-primary="RBAC (role-based access control)" data-startref="ix_RBAC" data-type="indexterm" id="id1043"/><a data-primary="access control" data-secondary="listing and viewing information about" data-startref="ix_ACinfo" data-type="indexterm" id="id1044"/><a data-primary="security" data-secondary="listing and viewing access control information" data-startref="ix_scrtyACinfo" data-type="indexterm" id="id1045"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id94">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Let’s assume you want to restrict an app to be able to view only pods—that is, list pods and get details about pods.<a data-primary="pods" data-secondary="restricting an app to getting information on" data-type="indexterm" id="id1046"/></p>&#13;
&#13;
<p>We’ll work in a namespace called <code>sec</code>, so start by creating that namespace with <code>kubectl create namespace sec</code>.</p>&#13;
&#13;
<p>Then create a pod definition in a YAML manifest, <em>pod-with-sa.yaml</em>, using a dedicated service account, <code>myappsa</code> (see <a data-type="xref" href="#service_accounts">Recipe 10.1</a>):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sec</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myappsa</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">main</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.36</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sh"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">10000"</code><code class="w"/></pre>&#13;
&#13;
<p>Next, define a role—let’s call it <code>podreader</code> in the <a data-primary="podreader role example" data-type="indexterm" id="id1047"/><a data-primary="RBAC (role-based access control)" data-secondary="restricting app to reading information about pods" data-type="indexterm" id="id1048"/>manifest <em>pod-reader.yaml</em>—that defines the allowed actions on resources:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Role</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">podreader</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sec</code><code class="w"/>&#13;
<code class="nt">rules</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"pods"</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"list"</code><code class="p-Indicator">]</code><code class="w"/></pre>&#13;
&#13;
<p>Last but not least, you need to apply the role <code>podreader</code> to the service account <code class="keep-together">myappsa</code>, using a <a data-primary="role bindings" data-type="indexterm" id="id1049"/>role binding in <em>pod-reader-binding.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RoleBinding</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">podreaderbinding</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sec</code><code class="w"/>&#13;
<code class="nt">roleRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Role</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">podreader</code><code class="w"/>&#13;
<code class="nt">subjects</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myappsa</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sec</code><code class="w"/></pre>&#13;
&#13;
<p>When creating the respective resources, you can use the YAML manifests directly (assuming the service account has already been created):</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create -f pod-reader.yaml</strong>&#13;
$ <strong>kubectl create -f pod-reader-binding.yaml</strong>&#13;
$ <strong>kubectl create -f pod-with-sa.yaml</strong>&#13;
</pre>&#13;
&#13;
<p>Rather than creating manifests for the role and the role binding, you can use the following commands:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create role podreader \&#13;
    --verb=get --verb=list \&#13;
    --resource=pods -n=sec</strong>&#13;
&#13;
$ <strong>kubectl create rolebinding podreaderbinding \&#13;
    --role=sec:podreader \&#13;
    --serviceaccount=sec:myappsa \&#13;
    --namespace=sec</strong>&#13;
</pre>&#13;
&#13;
<p>Note that this is a case of namespaced access control setup, since you’re using roles and role bindings.<a data-primary="namespaces" data-secondary="namespaced access control setup" data-type="indexterm" id="id1050"/><a data-primary="clusters" data-secondary="access control" data-type="indexterm" id="id1051"/> For cluster-wide access control, you would use the corresponding <code>create clusterrole</code> and <code>create clusterrolebinding</code> commands.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id95">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Sometimes it’s not obvious whether you should use a role or a cluster role and/or role binding, so here are a few rules of thumb you might find useful:</p>&#13;
&#13;
<ul class="less_space pagebreak-before">&#13;
<li>&#13;
<p>If you want to restrict access to a namespaced resource (like a service or pod) in a certain namespace, use a role and a role binding (as we did in this recipe).<a data-primary="roles and role bindings" data-type="indexterm" id="id1052"/></p>&#13;
</li>&#13;
<li>&#13;
<p>If you want to reuse a role in a couple of namespaces, use a cluster role with a role binding.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you want to restrict access to cluster-wide resources such as nodes or to namespaced resources across all namespaces, use a cluster role with a cluster role binding.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1053">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/n0i0c">Kubernetes documentation on using RBAC authorization</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.4 Securing Pods" data-type="sect1"><div class="sect1" id="securing-pods">&#13;
<h1>10.4 Securing Pods</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id238">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to define the security context for an app on the pod level. <a data-primary="security" data-secondary="securing pods" data-type="indexterm" id="ix_scrtypod"/><a data-primary="pods" data-secondary="defining security context for app at pod level" data-type="indexterm" id="ix_podscrty"/>For example, you want to run the app as a nonprivileged process.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id96">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>To enforce policies on the pod level in Kubernetes, use the <code>securityContext</code> field in a pod specification.<a data-primary="securityContext field" data-type="indexterm" id="id1054"/></p>&#13;
&#13;
<p>Let’s assume you want an app running as a non-root user. <a data-primary="containers" data-secondary="security context on container level" data-type="indexterm" id="id1055"/>For this, you would use the security context on the container level as shown in the following manifest, <em>securedpod.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secpod</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ubuntu:20.04</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"bin/bash"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">10000"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5000</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">Now create the pod and check the user under which the container runs:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f securedpod.yaml</strong>&#13;
pod/secpod created&#13;
&#13;
$ <strong>kubectl exec secpod -- ps aux</strong>&#13;
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND&#13;
5000           1  0.0  0.0   2204   784 ?        Ss   15:56   0:00 sleep 10000&#13;
5000          13  0.0  0.0   6408  1652 ?        Rs   15:56   0:00 ps aux&#13;
</pre>&#13;
&#13;
<p>As expected, it’s running as the user with ID <code>5000</code>. Note that you can also use the <code>securityContext</code> field on the pod level rather than on specific containers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id97">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>A more powerful method to enforce policies on the pod level is to use pod security admission.<a data-primary="pod security admission" data-type="indexterm" id="id1056"/> See <a href="https://oreil.ly/ujeV4">“Pod Security Admission”</a> in the Kubernetes documentation.<a data-primary="security" data-secondary="securing pods" data-startref="ix_scrtypod" data-type="indexterm" id="id1057"/><a data-primary="pods" data-secondary="defining security context for app at pod level" data-startref="ix_podscrty" data-type="indexterm" id="id1058"/><a data-primary="security" data-startref="ix_scrty" data-type="indexterm" id="id1059"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1060">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/ENH8N">“Configure a Security Context for a Pod or Container”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>