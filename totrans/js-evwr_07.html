<html><head></head><body><section data-pdf-bookmark="Chapter 6. CRUD Operations" data-type="chapter" epub:type="chapter"><div class="chapter" id="crud-operations">&#13;
<h1><span class="label">Chapter 6. </span>CRUD Operations</h1>&#13;
&#13;
&#13;
<p><a data-primary="CRUD operations" data-type="indexterm" id="ix_ch06-asciidoc0"/>The first time I heard the term “CRUD application,” I wrongfully assumed&#13;
that it referred to an application that did something dirty or tricky.&#13;
Admittedly, “CRUD” sounds as if it refers to something that would be&#13;
scraped off the bottom of a shoe. In fact, the acronym was first&#13;
popularized in the early 1980s by British technology author James&#13;
Martin in reference to applications that create, read, update, and&#13;
delete data. Though the term has been around for well over a quarter of a century, it still applies to many applications developed today. Consider the applications that you interact with daily—to-do lists, spreadsheets, content management systems, text&#13;
editors, social media websites, and several others—and chances are that&#13;
many of them fall into the CRUD application format. A user creates some&#13;
data, accesses or reads data, and may update or delete that&#13;
data.</p>&#13;
&#13;
<p>Our Notedly application will follow the CRUD pattern. Users will be able to create, read, update, and delete their own notes. In this chapter, we’ll implement the essential CRUD functionality of our API by&#13;
connecting our resolvers and database.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Separating Our GraphQL Schema and Resolvers" data-type="sect1"><div class="sect1" id="idm45339507595784">&#13;
<h1>Separating Our GraphQL Schema and Resolvers</h1>&#13;
&#13;
<p><a data-primary="CRUD operations" data-secondary="separating GraphQL schema and resolvers" data-type="indexterm" id="ix_ch06-asciidoc1"/><a data-primary="GraphQL" data-secondary="CRUD operations" data-type="indexterm" id="ix_ch06-asciidoc2"/><a data-primary="resolvers" data-secondary="CRUD operations separating schemas from" data-type="indexterm" id="ix_ch06-asciidoc3"/><a data-primary="schemas" data-secondary="CRUD operations separating resolvers from" data-type="indexterm" id="ix_ch06-asciidoc4"/>Currently our <em>src/index.js</em> file is home to our Express/Apollo server&#13;
code as well as our API’s schema and resolvers. As you can imagine, this could get a bit unwieldy as our codebase grows. Before this happens, let’s take some time to do a minor refactor that separates our schema, resolvers, and server code.</p>&#13;
&#13;
<p>To begin, let’s move our GraphQL schema to its own file. First, we’ll make a new file called <em>src/schema.js</em> in the <em>src</em> folder and then move our schema content, found in our <code>typeDefs</code> variable, to that file. To do so, we’ll also need to import the <code>gql</code> schema language that comes with the <code>apollo-server-express</code> package and export our schema as a module, using Node’s <a data-primary="module.exports()" data-type="indexterm" id="idm45339507585448"/><code>module.exports</code> method. While we’re at it, we can also remove the <code>hello</code> query, which we won’t need in our final application:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="p">{</code> <code class="nx">gql</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">gql</code><code class="sb">`</code>&#13;
<code class="sb">  type Note {</code>&#13;
<code class="sb">    id: ID!</code>&#13;
<code class="sb">    content: String!</code>&#13;
<code class="sb">    author: String!</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Query {</code>&#13;
<code class="sb">    notes: [Note!]!</code>&#13;
<code class="sb">    note(id: ID!): Note!</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Mutation {</code>&#13;
<code class="sb">    newNote(content: String!): Note!</code>&#13;
<code class="sb">  }</code>&#13;
<code class="sb">`</code><code class="p">;</code></pre>&#13;
&#13;
<p>We can now update our <em>src/index.js</em> file to use this external schema&#13;
file by importing it and removing the <code>gql</code> import from&#13;
<code>apollo-server-express</code> like so:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="p">{</code> <code class="nx">ApolloServer</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">typeDefs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./schema'</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now that we have isolated our GraphQL schema to its own file, let’s do&#13;
something similar for our GraphQL resolver code. Our resolver code will&#13;
encompass the vast majority of our API’s logic, so first we’ll create a&#13;
folder to house this code, called <em>resolvers</em>. Within the&#13;
<em>src/resolvers</em> directory we’ll begin with three files:&#13;
<em>src/resolvers/index.js</em>, <em>src/resolvers/query.js</em>, and&#13;
<em>src/resolvers/mutation.js</em>. Similar to the pattern we followed in our&#13;
database models, the <em>src/resolvers/index.js</em> file will be used to import our resolver code into a single exported module. Go ahead and set up this file like so:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">Query</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./query'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">Mutation</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./mutation'</code><code class="p">);</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="p">,</code>&#13;
  <code class="nx">Mutation</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now you can set up the <em>src/resolvers/query.js</em> for the API query code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">notes</code><code class="o">:</code> <code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">()</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">note</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then move the mutation code to the <em>src/resolvers/mutation.js</em>&#13;
file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code>&#13;
      <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
      <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Next, the server to import the resolver code by adding the&#13;
following line to the <em>src/index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./resolvers'</code><code class="p">);</code></pre>&#13;
&#13;
<p>The final step in refactoring our resolvers is to connect them to our&#13;
database models. As you may have noticed, our resolver modules  reference these models, but have no way of accessing them. To fix this&#13;
problem, we’ll use a concept that Apollo Server calls <a data-primary="context function" data-secondary="CRUD operations and" data-type="indexterm" id="idm45339507249208"/><em>context</em>, which&#13;
allows us to pass specific information along from our server code to an&#13;
individual resolver with each request. For now, this may feel excessive, but it will be useful for incorporating user authentication into our application. To do this, we’ll update our Apollo Server setup code in <em>src/index.js</em> with a <code>context</code> function that will return our database models:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code>&#13;
  <code class="nx">typeDefs</code><code class="p">,</code>&#13;
  <code class="nx">resolvers</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// Add the db models to the context</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">});</code></pre>&#13;
&#13;
<p>Now we’ll update each of our resolvers to make use of this&#13;
context by adding <code>{</code> <span class="keep-together"><code>models</code></span> <code>}</code> as the third parameter in each function.</p>&#13;
&#13;
<p>Do the following in <em>src/resolvers/query.js</em>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">notes</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">()</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">note</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Move the mutation code to the <em>src/resolvers/mutation.js</em>&#13;
file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code>&#13;
      <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
      <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Our <em>src/index.js</em> file will now be simplified as follows:<a data-startref="ix_ch06-asciidoc4" data-type="indexterm" id="idm45339507007352"/><a data-startref="ix_ch06-asciidoc3" data-type="indexterm" id="idm45339507006744"/><a data-startref="ix_ch06-asciidoc2" data-type="indexterm" id="idm45339507006072"/><a data-startref="ix_ch06-asciidoc1" data-type="indexterm" id="idm45339507005400"/></p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">ApolloServer</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
<code class="nx">require</code><code class="p">(</code><code class="s1">'dotenv'</code><code class="p">).</code><code class="nx">config</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Local module imports</code>&#13;
<code class="kr">const</code> <code class="nx">db</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./db'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">models</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./models'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">typeDefs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./schema'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./resolvers'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Run our server on a port specified in our .env file or port 4000</code>&#13;
<code class="kr">const</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">4000</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">DB_HOST</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">DB_HOST</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="nx">db</code><code class="p">.</code><code class="nx">connect</code><code class="p">(</code><code class="nx">DB_HOST</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code>&#13;
  <code class="nx">typeDefs</code><code class="p">,</code>&#13;
  <code class="nx">resolvers</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// Add the db models to the context</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// Apply the Apollo GraphQL middleware and set the path to /api</code>&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">applyMiddleware</code><code class="p">({</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'/api'</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">({</code> <code class="nx">port</code> <code class="p">},</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>&#13;
    <code class="sb">`GraphQL Server running at http://localhost:</code><code class="si">${</code><code class="nx">port</code><code class="si">}${</code><code class="nx">server</code><code class="p">.</code><code class="nx">graphqlPath</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing Our GraphQL CRUD Schema" data-type="sect1"><div class="sect1" id="idm45339507594840">&#13;
<h1>Writing Our GraphQL CRUD Schema</h1>&#13;
&#13;
<p><a data-primary="CRUD operations" data-secondary="writing GraphQL CRUD schema" data-type="indexterm" id="idm45339507001880"/>Now that we’ve refactored our code for flexibility, let’s begin implementing our CRUD operations. We are already able to Create and Read notes, which leaves us with implementing our&#13;
Update and Delete functionality. First, we’ll want to&#13;
update our schema.</p>&#13;
&#13;
<p>Since update and delete operations will make changes to our data, they&#13;
will be mutations. Our update note will require an ID argument to locate the note as well as the new note content. The update query will then return the newly updated note. For our delete operation, our API will return a Boolean value of <code>true</code> to inform us that the note deletion was successful.</p>&#13;
&#13;
<p>Update the <a data-primary="mutations" data-secondary="CRUD operations and" data-type="indexterm" id="idm45339506808968"/><code>Mutation</code> schema in <em>src/schema.js</em> as&#13;
follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Mutation</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code><code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nx">Note</code><code class="o">!</code>&#13;
  <code class="nx">updateNote</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nx">Note</code><code class="o">!</code>&#13;
  <code class="nx">deleteNote</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nb">Boolean</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With these additions, our schema is now ready to perform CRUD&#13;
operations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CRUD Resolvers" data-type="sect1"><div class="sect1" id="idm45339506804744">&#13;
<h1>CRUD Resolvers</h1>&#13;
&#13;
<p><a data-primary="CRUD operations" data-secondary="resolvers" data-type="indexterm" id="ix_ch06-asciidoc5"/><a data-primary="resolvers" data-secondary="CRUD" data-type="indexterm" id="ix_ch06-asciidoc6"/>With our schema in place, we can now update our resolvers to either remove or update a note. Let’s begin with our&#13;
<code>deleteNote</code> mutation. To delete a note, we will use Mongoose’s&#13;
<code>findOneAndRemove</code> method and pass it the <code>id</code> of the item that&#13;
we want to delete. If our item is found and deleted, we’ll return&#13;
<code>true</code> to the client, but if our item fails to delete, we’ll return <code>false</code>.</p>&#13;
&#13;
<p>In <em>src/resolvers/mutation.js</em>, add the following, within the&#13;
<code>module.exports</code> object:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">deleteNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">id</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findOneAndRemove</code><code class="p">({</code> <code class="nx">_id</code><code class="o">:</code> <code class="nx">id</code><code class="p">});</code>&#13;
    <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">},</code></pre>&#13;
&#13;
<p>Now we can run our mutation in the GraphQL Playground. In a new tab in&#13;
the Playground, write the following mutation, being sure to use an ID&#13;
from one of the notes in your database:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">deleteNote</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="s2">"5c7d1aacd960e03928804308"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">If the note was successfully deleted, you should receive a response of&#13;
<code>true</code>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"data"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="s2">"deleteNote"</code><code class="o">:</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you pass a nonexistent ID, you’ll receive a response of <code>"deleteNote": false</code>.</p>&#13;
&#13;
<p>With our delete functionality in place, let’s write our <a data-primary="updateNote mutation" data-type="indexterm" id="idm45339506631208"/><code>updateNote</code> mutation. To do this, we will use Mongoose’s <a data-primary="findOneAndUpdate()" data-type="indexterm" id="idm45339506630296"/><code>findOneAndUpdate</code> method. This method will take an initial parameter of a query to find the correct note in the database, followed by a second parameter where we’ll <code>$set</code> new note content. Lastly, we’ll pass a third parameter of <code>new: true</code>, which instructs the database to return the updated note content to us.</p>&#13;
&#13;
<p>In <em>src/resolvers/mutation.js</em>, add the following within the&#13;
<code>module.exports</code> object:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">updateNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">content</code><code class="p">,</code> <code class="nx">id</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findOneAndUpdate</code><code class="p">(</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nx">_id</code><code class="o">:</code> <code class="nx">id</code><code class="p">,</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nx">$set</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">content</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code>&#13;
      <code class="k">new</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">},</code></pre>&#13;
&#13;
<p>We can now visit the GraphQL Playground in our browser to try out our&#13;
<code>updateNote</code> mutation. In a new tab in the playground, write a&#13;
mutation with the parameters of an <code>id</code> and <code>content</code>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">updateNote</code><code class="p">(</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"5c7d1f0a31191c4413edba9d"</code><code class="p">,</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="s2">"This is an updated note!"</code>&#13;
  <code class="p">){</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">content</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If our mutation worked as intended, the GraphQL response should read as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"data"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="s2">"updateNote"</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="s2">"id"</code><code class="o">:</code> <code class="s2">"5c7d1f0a31191c4413edba9d"</code><code class="p">,</code>&#13;
      <code class="s2">"content"</code><code class="o">:</code> <code class="s2">"This is an updated note!"</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we pass an incorrect ID, the response fails and we will receive an&#13;
internal server error with an <code>Error updating note</code> message.</p>&#13;
&#13;
<p>We are now able to create, read, update, and delete notes. With this we&#13;
have full CRUD functionality in our API.<a data-startref="ix_ch06-asciidoc6" data-type="indexterm" id="idm45339506485800"/><a data-startref="ix_ch06-asciidoc5" data-type="indexterm" id="idm45339506485160"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Date and Time" data-type="sect1"><div class="sect1" id="idm45339506686648">&#13;
<h1>Date and Time</h1>&#13;
&#13;
<p><a data-primary="CRUD operations" data-secondary="date and time" data-type="indexterm" id="ix_ch06-asciidoc7"/><a data-primary="DateTime function" data-type="indexterm" id="ix_ch06-asciidoc8"/><a data-primary="timestamps" data-type="indexterm" id="ix_ch06-asciidoc9"/>When we created our database schema, we requested that Mongoose&#13;
automatically store timestamps to record when entries are created and&#13;
updated in the database. This information will be useful in our&#13;
application, as it will allow us to show the user when a note was created or last edited within our user interface. Let’s add <code>createdAt</code> and <code>updatedAt</code> fields to our schema so we can return these values.</p>&#13;
&#13;
<p>You may recall that GraphQL allows for the default types of <code>String</code>,&#13;
<code>Boolean</code>, <code>Int</code>, <code>Float</code>, and <code>ID</code>. Unfortunately GraphQL does not come with a built-in date scalar type. We <em>could</em> use the <code>String</code> type, but this would mean that we wouldn’t be taking advantage of the type validation that GraphQL offers, ensuring that our dates and times are actually dates and times. Instead, we’ll create a <a data-primary="scalar type, creating custom" data-type="indexterm" id="idm45339506406264"/>custom scalar type. A custom type allows us to define a new type and validate it against every query and mutation that requests data of that type.</p>&#13;
&#13;
<p>Let’s update our GraphQL schema in <em>src/schema.js</em> by adding a custom&#13;
scalar at the top of our <code>GQL</code> string literal:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">gql</code><code class="sb">`</code>&#13;
<code class="sb">  scalar DateTime</code>&#13;
<code class="sb">  ...</code>&#13;
<code class="sb">`</code><code class="p">;</code></pre>&#13;
&#13;
<p>Now, within the <code>Note</code> type, add the <code>createdAt</code> and <code>updatedAt</code> fields:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Note</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code>&#13;
  <code class="nx">content</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
  <code class="nx">author</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
  <code class="nx">createdAt</code><code class="o">:</code> <code class="nx">DateTime</code><code class="o">!</code>&#13;
  <code class="nx">updatedAt</code><code class="o">:</code> <code class="nx">DateTime</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">The last step is to validate this new type. While we can write our own&#13;
validation, for our use case we’ll use the&#13;
<a href="https://oreil.ly/CtmP6"><code>graphql-iso-date</code> package</a>. To do so we’ll add validation to any resolver function that requests a value with a type of <code>DateTime</code>.</p>&#13;
&#13;
<p>In the <em>src/resolvers/index.js</em> file, import the package and add a&#13;
<code>DateTime</code> value to the exported resolvers like so:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">Query</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./query'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">Mutation</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./mutation'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">GraphQLDateTime</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'graphql-iso-date'</code><code class="p">);</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="p">,</code>&#13;
  <code class="nx">Mutation</code><code class="p">,</code>&#13;
  <code class="nx">DateTime</code><code class="o">:</code> <code class="nx">GraphQLDateTime</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now if we visit the GraphQL Playground in our browser and refresh the&#13;
page, we can validate that our custom types work as intended. If we&#13;
consult our schema, we can see that the <code>createdAt</code> and <code>updatedAt</code> fields have a type of <code>DateTime</code>. As <a data-type="xref" href="#crud_datetime">Figure 6-1</a> shows, the documentation of this type states&#13;
that it is a “date-time string at UTC.”</p>&#13;
&#13;
<figure><div class="figure" id="crud_datetime">&#13;
<img alt="The DateTime type as shown in GraphQL Playground" src="assets/jsev_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>Our schema now features DateTime types</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">To test this, let’s write a <code>newNote</code> mutation in the GraphQL&#13;
Playground that includes our date fields:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code> <code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="s2">"This is a note with a custom type!"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="nx">author</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">createdAt</code>&#13;
    <code class="nx">updatedAt</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This will return <code>createdAt</code> and <code>updatedAt</code> values as an ISO-formatted&#13;
date. If we then run an <code>updateNote</code> mutation against the same note, we’ll see an <code>updatedAt</code> value that differs from the <code>createdAt</code> date.</p>&#13;
&#13;
<p>For more information on defining and validating custom scalar types, I&#13;
recommend Apollo Server’s&#13;
<a href="https://oreil.ly/0rWAC">“Custom scalars and enums” documentation</a>.<a data-startref="ix_ch06-asciidoc9" data-type="indexterm" id="idm45339506181016"/><a data-startref="ix_ch06-asciidoc8" data-type="indexterm" id="idm45339506180312"/><a data-startref="ix_ch06-asciidoc7" data-type="indexterm" id="idm45339506179640"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339506483896">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter we added create, read, update, and delete (CRUD) functionality to our API. CRUD applications are an incredibly common pattern used by many applications. I encourage you to look at the applications that you interact with daily and think about how their data may fit into this pattern.  In the next chapter, we will add functionality to our API to create and authenticate user accounts.<a data-startref="ix_ch06-asciidoc0" data-type="indexterm" id="idm45339506233176"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>