- en: Chapter 2\. Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the primary advantages of CSS is its ability to easily apply a set of
    styles to all elements of the same type. Unimpressed? Consider this: by editing
    a single line of CSS, you can change the colors of all your headings. Don’t like
    the blue you’re using? Change that one line of code, and they can all be purple,
    yellow, maroon, or any other color you desire.'
  prefs: []
  type: TYPE_NORMAL
- en: This capability lets you, the author, focus on design and user experience rather
    than tedious find-and-replace operations. The next time you’re in a meeting and
    someone wants to see headings with a different shade of green, just edit your
    style and hit Reload. Voilà! The results are accomplished in seconds and there
    for everyone to see.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Style Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated, a central feature of CSS is its ability to apply certain rules to
    an entire set of element types in a document. For example, let’s say that you
    want to make the text of all `<h2>` elements appear gray. Before we had CSS, you’d
    have to do this by inserting `<font color="gray">...</font>` tags inside all your
    `<h2>` elements. Applying inline styles using the `style` attribute, which is
    also bad practice, would require you to include `style="color: gray;"` in all
    your `<h2>` elements, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will be a tedious process if your document contains a lot of `<h2>` elements.
    Worse, if you later decide that you want all those `<h2>`s to be green instead
    of gray, you’d have to start the manual tagging all over again. (Yes, this is
    really how it used to be done!)
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS allows you to create rules that are simple to change, edit, and apply to
    all the text elements you define (the next section explains how these rules work).
    For example, you can write this rule once to make all your `<h2>` elements gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Type Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *type selector*, previously known as an *element selector*, is most often
    an HTML element, but not always. For example, if a CSS file contains styles for
    an XML document, the type selectors might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the elements of the document are the node types being selected.
    In XML, a selector could be anything because XML allows for the creation of new
    markup languages that can have just about anything as an element name. If you’re
    styling an HTML document, the selector will generally be one of the many defined
    HTML elements such as `<p>`, `<h3>`, `<em>`, `<a>`, or even `<html>` itself. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-1](#simple_styling_of_a_simple_document) shows the results of this
    stylesheet.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0201](assets/css5_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Simple styling of a simple document
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once you’ve globally applied styles directly to elements, you can shift those
    styles from one element to another. Let’s say you decide that the paragraph text,
    not the `<h1>` elements, in [Figure 2-1](#simple_styling_of_a_simple_document)
    should be gray. No problem. Just change the `h1` selector to `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-2](#moving_a_style_from_one_element_to_anoth) shows the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0202](assets/css5_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Moving a style from one element to another
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve seen fairly simple techniques for applying a single style to
    a single selector. But what if you want the same style to apply to multiple elements?
    *Grouping* allows an author to drastically compact certain types of style assignments,
    which makes for a shorter stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you want both `<h2>` elements and paragraphs to have gray text. The
    easiest way to accomplish this is to use the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By placing the `h2` and `p` selectors at the beginning of the rule, before
    the opening curly brace, and separating them with a comma, you’ve defined a rule
    indicating that the style inside the curly braces (`color: gray;`) applies to
    the elements referenced by both selectors. The comma tells the browser that two
    different selectors are involved in the rule. Leaving out the comma would give
    the rule a completely different meaning, which we’ll explore in [“Defining Descendant
    Selectors”](#descendant_selectors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These alternatives produce exactly the same result, but one is a lot easier
    to type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The second alternative, with one grouped selector, is also a lot easier to maintain
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: The universal selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *universal selector*, displayed as an asterisk (`*`), matches any element
    at all, much like a wildcard. For example, to make every single element in a document
    bold, you would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration is equivalent to a grouped selector that lists every element
    contained within the document. The universal selector lets you assign the `font-weight`
    value `bold` to every element in the document in one efficient stroke. Beware,
    however: although the universal selector is convenient because it targets everything
    within its declaration scope, it can have unintended consequences, which are discussed
    in [“Zeroed Selector Specificity”](ch04.html#zeroed_selector_specificity).'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as you can group selectors into a single rule, you can also group declarations.
    Assuming that you want all `<h1>` elements to appear in purple, 18-pixel-high
    Helvetica text on an aqua background (and you don’t mind blinding your readers),
    you could write your styles like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But this method is inefficient—imagine creating such a list for an element
    that will carry 10 or 15 styles! Instead, you can group your declarations together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will have exactly the same effect as the three-line stylesheet just shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that using semicolons at the end of each declaration is crucial when you’re
    grouping them. Browsers ignore whitespace in stylesheets, so the user agent must
    rely on correct syntax to parse the stylesheet. You can fearlessly format styles
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also minimize your CSS, removing all unrequired spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last three examples are treated equally by the server, but the second one
    is generally regarded as the most human-readable, and is the recommended method
    of writing your CSS during development. You might choose to minimize your CSS
    for network-performance reasons, but this is usually automatically handled by
    a build tool, server-side script, caching network, or other service, so you’re
    usually better off writing your CSS in a human-readable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the semicolon is omitted on the second statement, the user agent will interpret
    the stylesheet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `background:` is not a valid value for `color`, a user agent will ignore
    the `color` declaration entirely (including the `background: aqua` part). You
    might think the browser would at least render `<h1>`s as purple text without an
    aqua background, but not so. Instead, they will be the inherited color with a
    transparent background. The declaration `font: 18px Helvetica` will still take
    effect since it was correctly terminated with a semicolon.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although following the last declaration of a rule with a semicolon is not technically
    necessary in CSS, doing so is generally good practice. First, it will keep you
    in the habit of terminating your declarations with semicolons, the lack of which
    is one of the most common causes of rendering errors. Second, if you decide to
    add another declaration to a rule, you won’t have to worry about forgetting to
    insert an extra semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: As with selector grouping, declaration grouping is a convenient way to keep
    your stylesheets short, expressive, and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping Everything
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You now know that you can group selectors and you can group declarations. By
    combining both kinds of grouping in single rules, you can define very complex
    styles using only a few statements. Now, what if you want to assign some complex
    styles to all the headings in a document, and you want the same styles to be applied
    to all of them? Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve grouped the selectors, so the styles inside the curly braces will
    be applied to all the headings listed; grouping the declarations means that all
    of the listed styles will be applied to the selectors on the left side of the
    rule. [Figure 2-3](#grouping_both_selectors_and_rules) shows the result of this
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0203](assets/css5_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Grouping both selectors and rules
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This approach is preferable to the drawn-out alternative, which would begin
    with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: …​and continue for many lines. You *can* write out your styles the long way,
    but we don’t recommend it—editing them would be about as tedious as using `style`
    attributes everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping allows for some interesting choices. For example, all the groups of
    rules in the following example are equivalent—each merely shows a different way
    of grouping both selectors and declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Any of these three approaches to grouping selectors and declarations will yield
    the result shown in [Figure 2-4](#the_result_of_equivalent_style_sheets).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0204](assets/css5_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. The result of equivalent stylesheets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Class and ID Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve been grouping selectors and declarations together in a variety
    of ways, but the selectors we’ve been using are very simple ones that refer only
    to document elements. Type selectors are fine up to a point, but oftentimes you
    need something a little more focused.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to type selectors, CSS has *class selectors* and *ID selectors*,
    which let you assign styles based on HTML attributes but independent of element
    type. These selectors can be used on their own or in conjunction with type selectors.
    However, they work only if you’ve marked up your document appropriately, so using
    them generally involves a little forethought and planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say a document contains multiple warnings. You want each warning
    to appear in boldfaced text so that it will stand out. However, you don’t know
    which element types contain this warning content. Some warnings could be entire
    paragraphs, while others could be a single item within a lengthy list or a few
    words in a section of text. So, you can’t define a rule using type selectors of
    any kind. Suppose you tried this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*All* paragraphs would be red and bold, not just those that contain warnings.
    You need a way to select only the text that contains warnings—or, more precisely,
    a way to select only those elements that are warnings. How do you do it? You apply
    styles to parts of the document that have been marked in a certain way, independent
    of the elements involved, by using class selectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Class Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to apply styles without worrying about the elements involved
    is to use *class selectors*. Before you can use them, however, you need to modify
    your document markup so that the class selectors will work. Enter the `class`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To associate the styles of a class selector with an element, you must assign
    a `class` attribute the appropriate value. In the previous code block, a `class`
    value of `warning` is assigned to two elements: the first paragraph and the `<span>`
    element in the second paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply styles to these classed elements, you can use a compact notation in
    which the name of the class is preceded by a period (`.`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When combined with the example markup shown earlier, this simple rule has the
    effect shown in [Figure 2-5](#using_a_class_selector). The declaration `font-weight:
    bold` will be applied to every element that carries a `class` attribute with a
    value of `warning`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As [Figure 2-5](#using_a_class_selector) illustrates, the class selector works
    by directly referencing a value that will be found in the `class` attribute of
    an element. This reference is *always* preceded by a period (`.`), which marks
    it as a class selector. The period helps keep the class selector separate from
    anything with which it might be combined, such as a type selector. For example,
    you may want boldfaced warning text only when an entire paragraph is a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0205](assets/css5_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Using a class selector
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The selector now matches any `<p>` elements that have a `class` attribute containing
    the word `warning`, but no other elements of any kind, classed or otherwise. Since
    the `<span>` element is not a paragraph, the rule’s selector doesn’t match it,
    and it won’t be displayed using boldfaced text.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to assign different styles to the `<span>` element, you could
    use the selector `span.warning`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the warning paragraph is boldfaced, while the warning `<span>`
    is italicized. Each rule applies only to a specific type of element/class combination,
    so it does not leak over to other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use a combination of a general class selector and an element-specific
    class selector to make the styles even more useful, as in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-6](#using_generic_and_specific_selectors_to) shows the results.'
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, any warning text will be italicized, but only the text within
    a `<span>` element with a `class` of `warning` will be both boldfaced and italicized.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0206](assets/css5_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Using generic and specific selectors to combine styles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice the format of the general class selector used in the previous example:
    it’s a class name preceded by a period, and without an element name or universal
    selector. If you want to select all elements that share a class name, you can
    omit the universal selector from a class selector without any ill effects. Thus,
    `*.warning` and `.warning` will have exactly the same effect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing about class names: they should *never* begin with a number. Browsers
    will allow you to get away with this, but CSS validators will complain, and it’s
    a bad habit to get into. Thus, you should write `.c8675` in your CSS and `class="c8675"`
    in your HTML, rather than `.8675` and `class="8675"`. If you must refer to classes
    that begin with numbers, put a backslash between the period and the first number
    in your class selector, like so: `.\8675`.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we dealt with `class` values that contain a single
    word. In HTML, it’s possible to have a space-separated list of words in a single
    `class` value. For example, if you want to mark a particular element as being
    both urgent and a warning, you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The order of the words doesn’t matter; `warning urgent` would also work and
    would yield precisely the same results no matter how your CSS is written. Unlike
    HTML tags and type selectors, class selectors are case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s say you want all elements with a `class` of `warning` to be boldfaced,
    those with a `class` of `urgent` to be italic, and those elements with both values
    to have a silver background. This would be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By chaining two class selectors together, you can select only those elements
    that have both class names, in any order. As you can see, the HTML source contains
    `class="urgent warning"`, but the CSS selector is written `.warning.urgent`. Regardless,
    the rule will still cause the “When handling plutonium… ” paragraph to have a
    silver background, as illustrated in [Figure 2-7](#selecting_elements_with_multiple_class_n).
    This happens because the order in which the words are written in the source document,
    or in the CSS, doesn’t matter. (This is not to say the order of classes is always
    irrelevant, but we’ll get to that later in the chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0207](assets/css5_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Selecting elements with multiple class names
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If a multiple class selector contains a name that is not in the space-separated
    list, the match will fail. Consider the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect, the selector will match only those `<p>` elements with
    a `class` containing the space-separated words `warning` and `help`. Therefore,
    it will not match a `<p>` element with just the words `warning` and `urgent` in
    its `class` attribute. It would, however, match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ID Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some ways, *ID selectors* are similar to class selectors, but a few crucial
    differences exist. First, ID selectors are preceded by a hash sign (`#`)—formally
    called an octothorpe and also known as a pound sign (in the United States), number
    sign, or tic-tac-toe board—instead of a period. Thus, you might see a rule like
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This rule produces boldfaced text in any element whose `id` attribute has a
    value of `first-para`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is that instead of referencing values of the `class`
    attribute, ID selectors refer, sensibly enough, to values found in `id` attributes.
    Here’s an example of an ID selector in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that the value `lead-para` could have been assigned to any element within
    the document. In this particular case, it is applied to the first paragraph, but
    we could have applied it just as easily to the second or third paragraph. Or an
    unordered list. Or anything.
  prefs: []
  type: TYPE_NORMAL
- en: The third difference is that a document should have only one instance of a given
    ID value. If you find yourself wanting to apply the same ID to multiple elements
    in a document, make it a class instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with class selectors, it is possible (and very much the norm) to omit the
    universal selector from an ID selector. In the previous example, we could also
    have written this with the exact same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful when you know that a certain ID value will appear in a document,
    but you don’t know the element type on which it will appear. For example, you
    may know that in any given document, there will be an element with an ID value
    of `mostImportant`. You don’t know whether that most important thing will be a
    paragraph, a short phrase, a list item, or a section heading. You know only that
    it will exist in each document, occur in an arbitrary element, and appear no more
    than once. In that case, you would write a rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule would match any of the following elements (which, as noted before,
    should *not* appear together in the same document because they all have the same
    ID value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: While HTML standards say each `id` must be unique in a document, CSS doesn’t
    care. If we had erroneously included the HTML shown just now, all three would
    likely be red with a yellow background because all three match the `#mostImportant`
    selector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with class names, IDs should never start with numbers. If you must refer
    to an ID that begins with a number and cannot change the ID value in the markup,
    use a backslash before the first number, as in `#\309`.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding Between Class and ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may assign classes to any number of elements, as demonstrated earlier; the
    class name `warning` was applied to both a `<p>` and a `<span>` element, and it
    could have been applied to many more elements. ID values, on the other hand, should
    be used once, and only once, within an HTML document. Therefore, if you have an
    element with an `id` value of `lead-para`, no other element in that document should
    have an `id` value of `lead-para`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s according to the HTML specification, anyway. As noted previously, CSS
    doesn’t care if your HTML is valid or not: it should find however many elements
    a selector can match. That means that if you sprinkle an HTML document with several
    elements, all of which have the same value for their ID attributes, you should
    get the same styles applied to each.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Having more than one of the same ID value in a document makes DOM scripting
    more difficult, since functions like `getElementById()` depend on there being
    one, and only one, element with a given ID value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike class selectors, ID selectors can’t be combined with other IDs, since
    ID attributes do not permit a space-separated list of words. An ID selector can
    be combined with itself, though: `#warning#warning` will match the element with
    an `id` value of `warning`. This should rarely, if ever, be done, but it is possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between `class` and `id` names is that IDs carry more weight
    when you’re trying to determine which styles should be applied to a given element.
    This is explained in greater detail in [Chapter 4](ch04.html#specificity_comma_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that HTML defines class and ID values to be case-sensitive, so the
    capitalization of your class and ID values must match what’s found in your documents.
    Thus, in the following pairing of CSS and HTML, the element’s text will not be
    boldfaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because of the change in case for the letter *i*, the selector will not match
    the element shown.
  prefs: []
  type: TYPE_NORMAL
- en: On a purely syntactical level, the dot-class notation (e.g., `.warning`) is
    not guaranteed to work for XML documents. As of this writing, the dot-class notation
    works in HTML, Scalar Vector Graphics (SVG), and Mathematical Markup Language
    (MathML), and it may well be permitted in future languages, but it’s up to each
    language’s specification to decide that. The hash-ID notation (e.g., `#lead`)
    should work in any document language that has an attribute whose value is supposed
    to be unique within a document.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With both class and ID selectors, what you’re really doing is selecting values
    of elements’ attributes. The syntax used in the previous two sections is particular
    to HTML, SVG, and MathML documents as of this writing. In other markup languages,
    these class and ID selectors may not be available (as, indeed, those attributes
    may not be present).
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this situation, CSS2 introduced *attribute selectors*, which can
    be used to select elements based on their attributes and the values of those attributes.
    There are four general types of attribute selectors: simple attribute selectors,
    exact attribute value selectors, partial-match attribute value selectors, and
    leading-value attribute selectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Attribute Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to select elements that have a certain attribute, regardless of
    that attribute’s value, you can use a *simple attribute selector*. For example,
    to select all `<h1>` elements that have a `class` attribute with any value and
    make their text silver, write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, given the following markup,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: you get the result shown in [Figure 2-8](#selecting_elements_based_on_their_attrib).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0208](assets/css5_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Selecting elements based on their attributes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This strategy is very useful in XML documents, as XML languages tend to have
    element and attribute names that are specific to their purpose. Consider an XML
    language that is used to describe planets of the solar system (we’ll call it *PlanetML*).
    If you want to select all `<pml-planet>` elements with a `moons` attribute and
    make them boldface, thus calling attention to any planet that has moons, you would
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This would cause the text of the second and third elements in the following
    markup fragment to be boldfaced, but not the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In HTML documents, you can use this feature in creative ways. For example,
    you could style all images that have an `alt` attribute, thus highlighting those
    images that are correctly formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This particular example is generally useful more for diagnostic purposes—determining
    whether images are indeed correctly marked up—than for design purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to boldface any element that includes `title` information, which
    most browsers display as a tool tip when a cursor hovers over the element, you
    could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you could style only those anchors (`<a>` elements) that have an
    `href` attribute, thus applying the styles to any hyperlink but not to any placeholder
    anchors.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to select elements based on the presence of more than one
    attribute. You do this by chaining the attribute selectors together. For example,
    to boldface the text of any HTML hyperlink that has both an `href` and a `title`
    attribute, you would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This would boldface the first link in the following markup, but not the second
    or third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Selection Based on Exact Attribute Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can further narrow the selection process to encompass only those elements
    whose attributes are a certain value. For example, let’s say you want to boldface
    any hyperlink that points to a certain document on the web server. This would
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This will boldface the text of any `a` element that has an `href` attribute
    with *exactly* the value `http://www.css-discuss.org/about.html`. Any change at
    all, even dropping the `www.` part or changing to a secure protocol with `https`,
    will prevent a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any attribute and value combination can be specified for any element. However,
    if that exact combination does not appear in the document, the selector won’t
    match anything. Again, XML languages can benefit from this approach to styling.
    Let’s return to our PlanetML example. Suppose you want to select only those `planet`
    elements that have a value of `1` for the attribute `moons`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This would boldface the text of the second element in the following markup
    fragment, but not the first or third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As with attribute selection, you can chain together multiple attribute value
    selectors to select a single document. For example, to double the size of the
    text of any HTML hyperlink that has both an `href` with a value of `https://www.w3.org/`
    and a `title` attribute with a value of `W3C Home`, you would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This would double the text size of the first link in the following markup,
    but not the second or third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-9](#selecting_elements_based_on_attributes_a) shows the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0209](assets/css5_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. Selecting elements based on attributes and their values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Again, this format requires an *exact* match for the attribute’s value. Matching
    becomes an issue when an attribute selector encounters values that can, in turn,
    contain a space-separated list of values (e.g., the HTML attribute `class`). For
    example, consider the following markup fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way to match this element based on its exact attribute value is to
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to write `planet[type="barren"]`, the rule would not match the
    example markup and thus would fail. This is true even for the `class` attribute
    in HTML. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To select this element based on its exact attribute value, you would have to
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is *not* equivalent to the dot-class notation covered earlier, as you will
    see in the next section. Instead, it selects any `p` element whose `class` attribute
    has *exactly* the value `urgent warning`, with the words in that order and a single
    space between them. It’s effectively an exact string match, whereas when using
    a `class` selector, the class order doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, be aware that ID selectors and attribute selectors that target the `id`
    attribute are not precisely the same. In other words, a subtle but crucial difference
    exists between `h1#page-title` and `h1[id="page-title"]`. This difference is explained
    in [Chapter 4](ch04.html#specificity_comma_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Selection Based on Partial Attribute Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Odds are that you’ll sometimes want to select elements based on portions of
    their attribute values, rather than the full value. For such situations, CSS offers
    a variety of options for matching substrings in an attribute’s value. These are
    summarized in [Table 2-1](#substring_matching_with_attribute_select).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Substring matching with attribute selectors
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[foo~="bar"]` | Selects any element with an attribute `foo` whose value
    contains the word `bar` in a space-separated list of words |'
  prefs: []
  type: TYPE_TB
- en: '| `[foo*="bar"]` | Selects any element with an attribute `foo` whose value
    *contains* the substring `bar` |'
  prefs: []
  type: TYPE_TB
- en: '| `[foo^="bar"]` | Selects any element with an attribute `foo` whose value
    *begins* with `bar` |'
  prefs: []
  type: TYPE_TB
- en: '| `[foo$="bar"]` | Selects any element with an attribute `foo` whose value
    *ends* with `bar` |'
  prefs: []
  type: TYPE_TB
- en: '| `[foo&#124;="bar"]` | Selects any element with an attribute `foo` whose value
    *starts* with `bar` followed by a hyphen (U+002D) or whose value is exactly equal
    to `bar` |'
  prefs: []
  type: TYPE_TB
- en: 'The last of these attribute selectors that match on a partial subset of an
    element’s attribute value is easier to show than it is to describe. Consider the
    following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule will select any element whose `lang` attribute is equal to `en` or
    begins with `en-`. Therefore, the first three elements in the following example
    markup would be selected, but the last two would not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the form `[att|="val"]` can be used for any attribute and its values.
    Let’s say you have a series of figures in an HTML document, each of which has
    a filename like *figure-1.gif* or *figure-3.jpg*. You can match all of these images
    by using the following selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you’re creating a CSS framework or pattern library, instead of creating
    redundant classes like `"btn btn-small btn-arrow btn-active"`, you can declare
    `"btn-small-arrow-active"`, and target the class of elements with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The most common use for this type of attribute selector is to match language
    values, as demonstrated in [“The :lang() and :dir() Pseudo-Classes”](ch03.html#the_colon_lang_pseudo-class).
  prefs: []
  type: TYPE_NORMAL
- en: Matching one word in a space-separated list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For any attribute that accepts a space-separated list of words, you can select
    elements based on the presence of any one of those words. The classic example
    in HTML is the `class` attribute, which can accept one or more words as its value.
    Consider our usual example text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say you want to select elements whose `class` attribute contains the
    word `warning`. You can do this with an attribute selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note the presence of the tilde (`~`) in the selector. It is the key to selection
    based on the presence of a space-separated word within the attribute’s value.
    If you omit the tilde, you would have an exact value-matching attribute selector,
    as discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'This selector construct is equivalent to the dot-class notation discussed in
    [“Deciding Between Class and ID”](#deciding_between_class_and_id). Thus, `p.warning`
    and `p[class~="warning"]` are equivalent when applied to HTML documents. Here’s
    an example that is an HTML version of the PlanetML markup seen earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To italicize all elements with the word `barren` in their `class` attribute,
    you write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule’s selector will match the first two elements in the example markup
    and thus italicize their text, as shown in [Figure 2-10](#selecting_elements_based_on_portions_of).
    This is the same result we would expect from writing `span.barren {font-style:
    italic;}`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0210](assets/css5_0210.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10\. Selecting elements based on portions of attribute values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So why bother with the tilde-equals attribute selector in HTML? Because it
    can be used for any attribute, not just `class`. For example, you might have a
    document that contains numerous images, only some of which are figures. You can
    use a partial-match value attribute selector aimed at the `title` text to select
    only those figures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This rule selects any image whose `title` text contains the word `Figure` (but
    not `figure`, as title attributes are case-sensitive). Therefore, as long as all
    your figures have `title` text that looks something like “Figure 4\. A bald-headed
    elder statesman,” this rule will match those images. For that matter, the selector
    `img[title~="Figure"]` will also match a title attribute with the value “How to
    Figure Out Who’s in Charge.” Any image that does not have a `title` attribute,
    or whose `title` value doesn’t contain the word `Figure`, won’t be matched.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a substring within an attribute value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you want to select elements based on a portion of their attribute
    values, but the values in question aren’t space-separated lists of words. In these
    cases, you can use the asterisk-equals substring matching form `[attr*="val"]`
    to match substrings that appear anywhere inside the attribute values. For example,
    the following CSS matches any `<span>` element whose `class` attribute contains
    the substring `cloud`, so both “cloudy” planets are matched, as shown in [Figure 2-11](#selecting_elements_based_on_substrings_w):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0211](assets/css5_0211.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-11\. Selecting elements based on substrings within attribute values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note the presence of the asterisk (`*`) in the selector. It’s the key to selecting
    elements based on the presence of a substring within an attribute’s value. To
    be clear, it is *not* related to the universal selector, other than it uses the
    same character.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, this particular capability has many useful applications.
    For example, suppose you want to specially style any links to the W3C’s website.
    Instead of classing them all and writing styles based on that class, you could
    instead write the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You aren’t confined to the `class` and `href` attributes. Any attribute is
    up for grabs here (`title`, `alt`, `src`, `id`…); if the attribute has a value,
    you can style based on a substring within that value. The following rule draws
    attention to any image with the string `space` in its source URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the following rule draws attention to `<input>` elements that have
    a title telling the user what to do, along with any other input whose title contains
    the substring `format` in its title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use for the general substring attribute selector is to match a section
    of a class in pattern library class names. Elaborating on the preceding example,
    we can target any class name that starts with `btn` followed by a hyphen, and
    that contains the substring `arrow` preceded by a hyphen, by using the pipe-equals
    attribute selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The matches are exact: if you include whitespace in your selector, whitespace
    must also be present in an attribute’s value. The attribute values are case-sensitive
    when the underlying document language requires case sensitivity. Class names,
    titles, URLs, and ID values are all case-sensitive, but enumerated HTML attribute
    values, such as input type keyword values, are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Matching a substring at the beginning of an attribute value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to select elements based on a substring at the beginning of an
    attribute value, the caret-equals attribute selector pattern `[att^="val"]` is
    what you’re seeking. This can be particularly useful when you want to style types
    of links differently, as illustrated in [Figure 2-12](#selecting_elements_based_on_substrings_t):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0212](assets/css5_0212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-12\. Selecting elements based on substrings that begin attribute values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In another use case, you may want to style all images in an article that are
    also figures, like the figures you see throughout this text. Assuming that the
    `alt` text of each figure begins with text in the pattern “Figure 5”—which is
    an entirely reasonable assumption in this case—you can select only those images
    with the caret-equals attribute selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The potential drawback here is that *any* `<img>` element whose `alt` starts
    with `Figure` will be selected, whether or not it’s meant to be an illustrative
    figure. The likeliness of that occurring depends on the document in question.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is selecting all of the calendar events that occur on Mondays.
    In this case, let’s assume all of the events have a `title` attribute containing
    a date in the format “Monday, March 5th, 2012.” Selecting them all is just a simple
    matter of using `[title^="Monday"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a substring at the end of an attribute value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mirror image of beginning-substring matching is ending-substring matching,
    which is accomplished using the `[att$="val"]` pattern. A very common use for
    this capability is to style links based on the kind of resource they target, such
    as separate styles for PDF documents, as illustrated in [Figure 2-13](#selecting_elements_based_on_substring):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0213](assets/css5_0213.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-13\. Selecting elements based on substrings that end attribute values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Similarly, you could (for whatever reason) select images based on their image
    format with the dollar-equals attribute selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: To continue the calendar example from the previous section, it would be possible
    to select all of the events occurring within a given year by using a selector
    like `[title$="2015"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may have noticed that we’ve quoted all the attribute values in the attribute
    selectors. Quoting is required if the value includes any special characters, begins
    with a hyphen or digit, or is otherwise invalid as an identifier and needs to
    be quoted as a string. To be safe, we recommend always quoting attribute values
    in attribute selectors, even though it is required only to make strings out of
    invalid identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: The Case-Insensitivity Identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Including an `i` before the closing bracket of an attribute selector will allow
    that selector to match attribute values case-insensitively, regardless of document
    language rules. For example, suppose you want to select all links to PDF documents,
    but you don’t know if they’ll end in *.pdf*, *.PDF*, or even *.Pdf*. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Adding that humble little `i` means the selector will match any `a` element
    whose `href` attribute’s value ends in `.pdf`, regardless of the capitalization
    of the letters *P*, *D*, and *F*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This case-insensitivity option is available for all the attribute selectors
    we’ve covered. Note, however, that this applies to only the *values* in the attribute
    selectors. It does not enforce case insensitivity on the attribute names themselves.
    Thus, in a case-sensitive language, `planet[type*="rock" i]` will match all of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It will *not* match the following element, because the attribute `TYPE` isn’t
    matched by `type` in XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This is in languages that enforce case sensitivity in the element and attribute
    syntax. In languages that are case-insensitive, like HTML, this isn’t an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A proposed mirror identifier, `s`, enforces case sensitivity. As of early 2023,
    it is supported by only the Firefox family of browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Document Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS is so capable because it uses the structure of documents to determine appropriate
    styles and how to apply them. Let’s take a moment to discuss structure before
    moving on to more powerful forms of selection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Parent-Child Relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the relationship between selectors and documents, we need to
    once again examine how documents are structured. Consider this very simple HTML
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Much of the power of CSS is based on the *parent-child relationship* of elements.
    HTML documents (and most structured documents of any kind) are based on a hierarchy
    of elements, which is visible in the “tree” view of the document (see [Figure 2-14](#a_document_tree_structure)).
    In this hierarchy, each element fits somewhere into the overall structure of the
    document. Every element in the document is either the *parent* or the *child*
    of another element, and it’s often both. If a parent has more than one child,
    those children are *siblings*.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0214](assets/css5_0214.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-14\. A document tree structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An element is said to be the parent of another element if it appears directly
    above that element in the document hierarchy. For example, in [Figure 2-14](#a_document_tree_structure),
    the first `<p>` element from the left is parent to the `<em>` and `<strong>` elements,
    while `<strong>` is parent to an anchor (`<a>`) element, which is itself parent
    to another `<em>` element. Conversely, an element is the child of another element
    if it is directly beneath the other element. Thus, the anchor element on the far
    right side of [Figure 2-14](#a_document_tree_structure) is the child of a `<p>`
    element, which is in turn child to the `<body>` element, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The terms *parent* and *child* are specific applications of the terms *ancestor*
    and *descendant*, respectively. There is a difference between them: in the tree
    view, if an element is exactly one level above or below another, those elements
    have a *parent-child* relationship. If the path from one element to another is
    traced through two or more levels, the elements have an ancestor-descendant relationship,
    but not a parent-child relationship. (A child is also a descendant, and a parent
    is also an ancestor.) In [Figure 2-14](#a_document_tree_structure), the uppermost
    `<ul>` element is parent to two `<li>` elements, but the uppermost `<ul>` is also
    the ancestor of every element descended from its `<li>` element, all the way down
    to the most deeply nested `<li>` elements. Those `<li>` elements, children of
    the `<ol>`, are siblings.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, in [Figure 2-14](#a_document_tree_structure), there is an anchor that
    is a child of `<strong>`, but also a descendant of the `<p>`, `<body>`, and `<html>`
    elements. The `<body>` element is an ancestor of everything that the browser will
    display by default, and the `<html>` element is ancestor to the entire document.
    For this reason, in an HTML document, the `<html>` element is also called the
    *root element*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Descendant Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first benefit of understanding this model is the ability to define *descendant
    selectors*. Defining descendant selectors is the act of creating rules that operate
    in certain structural circumstances but not others. As an example, let’s say you
    want to style only those `<em>` elements that are descended from `<h1>` elements.
    To do so, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This rule will make gray any text in an `<em>` element that is the descendant
    of an `<h1>` element. Other `<em>` text, such as that found in a paragraph or
    a block quote, will not be selected by this rule. [Figure 2-15](#selecting_an_element_based_on_its_contex)
    illustrates the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0215](assets/css5_0215.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-15\. Selecting an element based on its context
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In a descendant selector, the selector side of a rule is composed of two or
    more space-separated selectors. The space between the selectors is an example
    of a *combinator*. Each space combinator can be translated as “found within,”
    “which is part of,” or “that is a descendant of,” but only if you read the selector
    right to left. Thus, `h1 em` can be translated as, “Any `<em>` element that is
    a descendant of an `<h1>` element.”
  prefs: []
  type: TYPE_NORMAL
- en: To read the selector left to right, you might phrase it like, “Any `<h1>` that
    contains an `<em>` will have the following styles applied to the `<em>`.” That’s
    much more verbose and confusing, and it’s why we, like the browser, read selectors
    from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t limited to two selectors. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this case, as [Figure 2-16](#a_very_specific_descendant_selector) shows,
    any emphasized text that is part of an unordered list that is part of an ordered
    list that is itself part of an unordered list (yes, this is correct) will be gray.
    This is obviously a very specific selection criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0216](assets/css5_0216.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-16\. A very specific descendant selector
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Descendant selectors can be extremely powerful. Let’s consider a common example.
    Assume you have a document with a sidebar and a main area. The sidebar has a blue
    background, the main area has a white background, and both areas include lists
    of links. You can’t set all links to be blue because they’d be impossible to read
    in the sidebar, and you also can’t set all links to white because they’d disappear
    in the main part of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution: descendant selectors. In this case, you give the element that
    contains your sidebar a class of `sidebar` and enclose the main part of the page
    in a `<main>` element. Then, you write styles like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-17](#using_descendant_selectors_to_apply_diff) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0217](assets/css5_0217.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-17\. Using descendant selectors to apply different styles to the same
    type of element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`:any-link` refers to both visited and unvisited links. We’ll talk about it
    in detail in [Chapter 3](ch03.html#pseudo_classes_and_elements).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example: let’s say that you want gray to be the text color of
    any `<b>` (boldfaced) element that is part of a `blockquote` and for any bold
    text that is found in a normal paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The result is that the text within `<b>` elements that are descended from paragraphs
    or block quotes will be gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'One overlooked aspect of descendant selectors is that the degree of separation
    between two elements can be practically infinite. For example, if you write `ul
    em`, that syntax will select any `<em>` element descended from a `<ul>` element,
    no matter how deeply nested the `<em>` may be. Thus, `ul em` would select the
    `<em>` element in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: A more subtle aspect of descendant selectors is that they have no notion of
    element proximity. In other words, the closeness of two elements within the document
    tree has no bearing on whether a rule applies. This is important when it comes
    to specificity (which we’ll cover in the next chapter) and when considering rules
    that might appear to cancel each other out.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following (which contains `:not()`, a selector type
    we’ll discuss in [“The negation pseudo-class”](ch03.html#the_negation_pseudo-class)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: What the CSS says, in effect, is “any `<span>` inside a `<div>` that doesn’t
    have a `class` containing the word `help` should be gray” in the first rule, and
    “any `<span>` inside a `<div>` whose `class` contains the word `help`” in the
    second rule. In the given markup fragment, *both* rules apply to the `<span>`
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the two rules have equal specificity weight and the `red` rule is written
    last, it wins out, and the `<span>` is red. The fact that `div class="aside"`
    is “closer to” `<span>` than `div class="help"` is irrelevant. Again: descendant
    selectors have no notion of element proximity. Both rules match, only one color
    can be applied, and because of the way CSS works, red is the winner here. (We’ll
    discuss why that’s so in the next chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of early 2023, proposals have been made to add element-proximity awareness
    to CSS via *selector scoping*, but the proposals are still being actively revised
    and may not come to fruition.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Children
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, you don’t want to select an arbitrarily descended element. Rather,
    you want to narrow your range to select an element that is specifically a child
    of another element. You might, for example, want to select a `<strong>` element
    only if it is a child (as opposed to any other level of descendant) of an `<h1>`
    element. To do this, you use the *child combinator*, which is the greater-than
    symbol (`>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule will make red the `<strong>` element shown in the first `<h1>`, but
    not the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Read right to left, the selector `h1 > strong` translates as, “Selects any `<strong>`
    element that is a direct child of an `<h1>` element.” The child combinator can
    be optionally surrounded by whitespace. Thus, `h1 > strong`, `h1> strong`, and
    `h1>strong` are all equivalent. You can use or omit whitespace as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: When viewing the document as a tree structure, we can see that a child selector
    restricts its matches to elements that are directly connected in the tree. [Figure 2-18](#a_document_tree_fragment)
    shows part of a document tree.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0218](assets/css5_0218.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-18\. A document tree fragment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this tree fragment, you can pick out parent-child relationships. For example,
    the `<a>` element is a parent to `<strong>` and is also a child of the `<p>` element.
    You could match elements in this fragment with the selectors `p > a` and `a >
    strong`, but not `p > strong`, since `<strong>` is a descendant of `<p>` but not
    its child.
  prefs: []
  type: TYPE_NORMAL
- en: You can also combine descendant and child combinators in the same selector.
    Thus, `table.summary td > p` will select any `<p>` element that is a *child* of
    a `<td>` element that is itself *descended* from a `<table>` element that has
    a `class` attribute containing the word `summary`.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Adjacent-Sibling Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say you want to style the paragraph immediately after a heading, or give
    a special margin to a list that immediately follows a paragraph. To select an
    element that immediately follows another element with the same parent, you use
    the *adjacent-sibling combinator*, represented as a plus symbol (+). As with the
    child combinator, the symbol can be surrounded by whitespace, or not, at your
    discretion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the top margin from a paragraph immediately following an `<h1>` element,
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The selector is read as, “Select any `<p>` element that immediately follows
    an `<h1>` element that *shares a parent* with the `<p>` element.”
  prefs: []
  type: TYPE_NORMAL
- en: To visualize how this selector works, let’s once again consider a fragment of
    a document tree, shown in [Figure 2-19](#another_document_tree_fragment).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0219](assets/css5_0219.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-19\. Another document tree fragment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this fragment, a pair of lists descends from a `<div>` element, one ordered
    and the other not, each containing three list items. Each list is an adjacent
    sibling, and the list items themselves are also adjacent siblings. However, the
    list items from the first list are *not* siblings of the second, as the two sets
    of list items do not share the same parent element. (At best, they’re cousins,
    and CSS has no cousin selector.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that you can select the second of two adjacent siblings only with
    a single combinator. Thus, if you write `li + li {font-weight: bold;}`, only the
    second and third items in each list will be boldfaced. The first list items will
    be unaffected, as illustrated in [Figure 2-20](#selecting_adjacent_siblings).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0220](assets/css5_0220.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-20\. Selecting adjacent siblings
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To work properly, CSS requires that the two elements appear in *source order*.
    In our example, an `<ol>` element is followed by a `<ul>` element. This allows
    us to select the second element with `ol + ul`, but we cannot select the first
    by using the same syntax. For `ul + ol` to match, an ordered list must immediately
    follow an unordered list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that text content between two elements does *not* prevent the
    adjacent-sibling combinator from working. Consider this markup fragment, whose
    tree view would be the same as that shown in [Figure 2-18](#a_document_tree_fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have text between the two lists, we can still match the second
    list with the selector `ol + ul`. That’s because the intervening text is not contained
    within a sibling element, but is instead part of the parent `<div>`. If we wrapped
    that text in a paragraph element, it would then prevent `ol + ul` from matching
    the second list. Instead, we might have to write something like `ol + p + ul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the following example illustrates, the adjacent-sibling combinator can be
    used in conjunction with other combinators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The selector translates as, “Selects any `<ul>` element that immediately follows
    a sibling `<table>` element that is descended from a `<body>` element that is
    itself a child of an `<html>` element.”
  prefs: []
  type: TYPE_NORMAL
- en: As with all combinators, you can place the adjacent-sibling combinator in a
    more complex setting, such as `div#content h1 + div ol`. That selector is read
    as, “Selects any `<ol>` element that is descended from a `<div>` when the `<div>`
    is the adjacent sibling of an `<h1>` that is itself descended from a `<div>` whose
    `id` attribute has a value of `content`.”
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Following Siblings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *general sibling combinator* lets you select any element that follows another
    element when both elements share the same parent, represented using the tilde
    (`~`) combinator.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, to italicize any `<ol>` that follows an `<h2>` and also shares
    a parent with the `<h2>`, you’d write `h2 ~ ol {font-style: italic;}`. The two
    elements do not have to be adjacent siblings, although they can be adjacent and
    still match this rule. The result of applying this rule to the following markup
    is shown in [Figure 2-21](#selecting_following_siblings-id1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both ordered lists are italicized. That’s because both of them
    are `<ol>` elements that follow an `<h2>` with which they share a parent (the
    `<div>`).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0221](assets/css5_0221.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-21\. Selecting following siblings
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using selectors based on the document’s language, you can create CSS rules
    that apply to a large number of similar elements just as easily as you can construct
    rules that apply in very narrow circumstances. The ability to group together both
    selectors and rules keeps stylesheets compact and flexible, which incidentally
    leads to smaller file sizes and faster download times.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors are the one thing that user agents usually must get right, because
    the inability to correctly interpret selectors pretty much prevents a user agent
    from using CSS at all. On the flip side, it’s crucial for authors to correctly
    write selectors because errors can prevent the user agent from applying the styles
    as intended. An integral part of correctly understanding selectors and how they
    can be combined is having a strong grasp of how selectors relate to document structure
    and how mechanisms—such as inheritance and the cascade itself—come into play when
    determining how an element will be styled.
  prefs: []
  type: TYPE_NORMAL
- en: The selectors we covered in this chapter aren’t the end of the story, though.
    They’re not even half the story. In the next chapter, we’ll dive into the powerful
    and ever-expanding world of pseudo-class and pseudo-element selectors.
  prefs: []
  type: TYPE_NORMAL
