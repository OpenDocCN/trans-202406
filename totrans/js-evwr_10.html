<html><head></head><body><section data-pdf-bookmark="Chapter 9. Details" data-type="chapter" epub:type="chapter"><div class="chapter" id="details">&#13;
<h1><span class="label">Chapter 9. </span>Details</h1>&#13;
&#13;
&#13;
<p><a data-primary="details" data-type="indexterm" id="ix_ch09-asciidoc0"/>When the now-near-ubiquitous air freshener Febreze was first released, it was a dud. The original ads showed people using the product to remove specific bad smells, such as cigarette smoke, resulting in poor sales. Faced with this disappointing outcome, the marketing team shifted focus to using Febreze as a finishing detail. Now, the ads depicted someone cleaning a room, fluffing the pillows, and completing the tasks of refreshing a room with a spritz of Febreze. This reframing of the product caused sales to skyrocket.</p>&#13;
&#13;
<p>This is a great example of the fact that <em>details matter</em>. Right now we have a working API, but it’s lacking the finishing touches that will allow us to put it into production. In this chapter we’ll implement some web and GraphQL application security and user experience best practices. These details, far exceeding a spritz of air freshener, will be critical to the safety, security, and usability of our application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Web Application and Express.js Best Practices" data-type="sect1"><div class="sect1" id="idm45339502661560">&#13;
<h1>Web Application and Express.js Best Practices</h1>&#13;
&#13;
<p><a data-primary="details" data-secondary="web application and express.js best practices" data-type="indexterm" id="idm45339502660392"/><a data-primary="Express.js" data-type="indexterm" id="idm45339502659384"/><a data-primary="web application" data-secondary="best practices" data-type="indexterm" id="idm45339502658712"/>Express.js is the underlying web application framework that powers our API. We can make a few small tweaks to our Express.js code to provide a solid basis for our <span class="keep-together">application.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Express Helmet" data-type="sect2"><div class="sect2" id="idm45339502656808">&#13;
<h2>Express Helmet</h2>&#13;
&#13;
<p><a data-primary="details" data-secondary="Express Helmet" data-type="indexterm" id="idm45339502655368"/><a data-primary="Express Helmet" data-type="indexterm" id="idm45339502654392"/>The Express <a href="https://oreil.ly/NGae1">Helmet middleware</a> is a collection of small security-minded middleware functions. These will adjust our application’s HTTP headers to be more secure. While many of these are specific to browser-based applications, enabling Helmet is a simple step to protect our application from common web vulnerabilities.</p>&#13;
&#13;
<p>To enable Helmet, we’ll require the middleware in our application and instruct Express to use it early in our middleware stack. In the <em>./src/index.js</em> file, add the <span class="keep-together">following:</span></p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// first require the package at the top of the file</code>&#13;
<code class="kr">const</code> <code class="nx">helmet</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'helmet'</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// add the middleware at the top of the stack, after const app = express()</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">helmet</code><code class="p">());</code></pre>&#13;
&#13;
<p>By adding the Helmet middleware, we’re quickly enabling common web security best practices for our application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cross-Origin Resource Sharing" data-type="sect2"><div class="sect2" id="idm45339502614824">&#13;
<h2>Cross-Origin Resource Sharing</h2>&#13;
&#13;
<p><a data-primary="CORS (cross-origin resource sharing)" data-type="indexterm" id="idm45339502613704"/><a data-primary="cross-origin resource sharing (CORS)" data-type="indexterm" id="idm45339502613064"/><a data-primary="details" data-secondary="cross-origin resource sharing" data-type="indexterm" id="idm45339502612424"/>Cross-Origin Resource Sharing (CORS) is the means by which we allow resources to be requested from another domain. Because our API and UI code will live separately, we’ll want to enable credentials from other origins. If you’re interested in learning the ins and outs of CORS, I highly recommend the <a href="https://oreil.ly/E1lXZ">Mozilla CORS Guide</a>.</p>&#13;
&#13;
<p>To enable CORS, we’ll use the Express.js <a href="https://oreil.ly/lYr7g">CORS middleware</a> package in our <em>.src/index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// first require the package at the top of the file</code>&#13;
<code class="kr">const</code> <code class="nx">cors</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'cors'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// add the middleware after app.use(helmet());</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">cors</code><code class="p">());</code></pre>&#13;
&#13;
<p>By adding the middleware in this way, we are enabling cross-origin requests from <em>all</em> domains. This works well for us for now, as we’re in development mode and will likely be using domains generated by our hosting providers, but by using the middleware, we could also limit the requests to those of specific origins.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pagination" data-type="sect1"><div class="sect1" id="idm45339502596968">&#13;
<h1>Pagination</h1>&#13;
&#13;
<p><a data-primary="details" data-secondary="pagination" data-type="indexterm" id="ix_ch09-asciidoc1"/><a data-primary="pagination" data-type="indexterm" id="ix_ch09-asciidoc2"/>Currently our <code>notes</code> and <code>users</code> queries return the full list of notes and users in the database. This works fine for local development, but as our application grows it will become unsustainable, as a query that returns potentially hundreds (or thousands) of notes is expensive and will slow down our database, server, and network. Instead, we can paginate those queries, returning only a set number of results.</p>&#13;
&#13;
<p>There are two common types of pagination that we could implement. The first type, <a data-primary="offset pagination" data-type="indexterm" id="idm45339502563976"/><em>offset pagination</em>, works by the client passing an offset number and returning a limited amount of data. For example, if each page of data were limited to 10 records, and we wanted to request the third page of data, we could pass an offset of 20. While this is the most straightforward approach conceptually, it can run into scaling and performance issues.</p>&#13;
&#13;
<p>The second type of pagination is <a data-primary="cursor-based pagination" data-type="indexterm" id="idm45339502562120"/><em>cursor-based pagination</em>, in which a time-based cursor or unique identifier is passed as a starting point. We then request a specific amount of data that follows this record. This approach gives us the greatest control over our pagination. Additionally, because Mongo’s object IDs are ordered (they begin with a 4-byte time value), we can easily utilize them as our cursor. To learn more about Mongo’s object ID, I recommend reading <a href="https://oreil.ly/GPE1c">the corresponding MongoDB documentation</a>.</p>&#13;
&#13;
<p>If this sounds overly conceptual to you, that’s OK. Let’s walk through implementing a paginated feed of notes as a GraphQL query. First, let’s define what we’ll be creating, followed by our schema updates, and lastly our resolver code. For our feed we’ll want to query our API while optionally passing a cursor as a parameter. The API should then return a limited amount of data, a cursor point representing the last item in the data set, and a Boolean value if there is an additional page of data to query.</p>&#13;
&#13;
<p>With this description, we can update our <em>src/schema.js</em> file to define this new query. First, we’ll need to add a <code>NoteFeed</code> type to our file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">NoteFeed</code> <code class="p">{</code>&#13;
  <code class="nx">notes</code><code class="o">:</code> <code class="p">[</code><code class="nx">Note</code><code class="p">]</code><code class="o">!</code>&#13;
  <code class="nx">cursor</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
  <code class="nx">hasNextPage</code><code class="o">:</code> <code class="nb">Boolean</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Next, we’ll add our <code>noteFeed</code> query:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Query</code> <code class="p">{</code>&#13;
  <code class="err">#</code> <code class="nx">add</code> <code class="nx">noteFeed</code> <code class="nx">to</code> <code class="nx">our</code> <code class="nx">existing</code> <code class="nx">queries</code>&#13;
  <code class="nx">noteFeed</code><code class="p">(</code><code class="nx">cursor</code><code class="o">:</code> <code class="nb">String</code><code class="p">)</code><code class="o">:</code> <code class="nx">NoteFeed</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With our schema updated, we can write the <a data-primary="resolvers" data-secondary="pagination and" data-type="indexterm" id="idm45339502507304"/>resolver code for our query. In <em>./src/resolvers/query.js</em>, add the following to the exported object:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">noteFeed</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">cursor</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// hardcode the limit to 10 items</code>&#13;
  <code class="kr">const</code> <code class="nx">limit</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>&#13;
  <code class="c1">// set the default hasNextPage value to false</code>&#13;
  <code class="kd">let</code> <code class="nx">hasNextPage</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>&#13;
  <code class="c1">// if no cursor is passed the default query will be empty</code>&#13;
  <code class="c1">// this will pull the newest notes from the db</code>&#13;
  <code class="kd">let</code> <code class="nx">cursorQuery</code> <code class="o">=</code> <code class="p">{};</code>&#13;
&#13;
  <code class="c1">// if there is a cursor</code>&#13;
  <code class="c1">// our query will look for notes with an ObjectId less than that of the cursor</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">cursor</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">cursorQuery</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">_id</code><code class="o">:</code> <code class="p">{</code> <code class="nx">$lt</code><code class="o">:</code> <code class="nx">cursor</code> <code class="p">}</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// find the limit + 1 of notes in our db, sorted newest to oldest</code>&#13;
  <code class="kd">let</code> <code class="nx">notes</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">cursorQuery</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">sort</code><code class="p">({</code> <code class="nx">_id</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code> <code class="p">})</code>&#13;
    <code class="p">.</code><code class="nx">limit</code><code class="p">(</code><code class="nx">limit</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// if the number of notes we find exceeds our limit</code>&#13;
  <code class="c1">// set hasNextPage to true and trim the notes to the limit</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">notes</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="nx">limit</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">hasNextPage</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
    <code class="nx">notes</code> <code class="o">=</code> <code class="nx">notes</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// the new cursor will be the Mongo object ID of the last item in the feed array</code>&#13;
  <code class="kr">const</code> <code class="nx">newCursor</code> <code class="o">=</code> <code class="nx">notes</code><code class="p">[</code><code class="nx">notes</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">].</code><code class="nx">_id</code><code class="p">;</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">notes</code><code class="p">,</code>&#13;
    <code class="nx">cursor</code><code class="o">:</code> <code class="nx">newCursor</code><code class="p">,</code>&#13;
    <code class="nx">hasNextPage</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this resolver in place, we can query our <code>noteFeed</code>, which will return a maximum of 10 results. In the GraphQL Playground, we can write a query as follows to receive a list of notes, their object IDs, their “created at” timestamp, the cursor, and the next page boolean:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">noteFeed</code> <code class="p">{</code>&#13;
    <code class="nx">notes</code> <code class="p">{</code>&#13;
      <code class="nx">id</code>&#13;
      <code class="nx">createdAt</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">cursor</code>&#13;
    <code class="nx">hasNextPage</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Since we have more than 10 notes in our database, this returns a cursor as well as a <code>hasNextPage</code> value of <code>true</code>. With that cursor, we can query the second page of the feed:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">noteFeed</code><code class="p">(</code><code class="nx">cursor</code><code class="o">:</code> <code class="s2">"&lt;YOUR OBJECT ID&gt;"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">notes</code> <code class="p">{</code>&#13;
      <code class="nx">id</code>&#13;
      <code class="nx">createdAt</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">cursor</code>&#13;
    <code class="nx">hasNextPage</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can continue to do this for each cursor where the <code>hasNextPage</code> value is <code>true</code>. With this implementation in place, we’ve created a paginated feed of notes. This will both allow our UI to request a specific feed of data as well as reduce the burden on our server and database.<a data-startref="ix_ch09-asciidoc2" data-type="indexterm" id="idm45339502248184"/><a data-startref="ix_ch09-asciidoc1" data-type="indexterm" id="idm45339502247656"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Limitations" data-type="sect1"><div class="sect1" id="idm45339502568632">&#13;
<h1>Data Limitations</h1>&#13;
&#13;
<p><a data-primary="data limitations" data-type="indexterm" id="idm45339502245576"/><a data-primary="details" data-secondary="data limitations" data-type="indexterm" id="idm45339502244872"/>In addition to establishing pagination, we’ll want to limit the amount of data that can be requested through our API. This prevent queries that could overload our server or database.</p>&#13;
&#13;
<p>A simple first step in this process is to limit the amount of data that a query can return. Two of our queries, <code>users</code> and <code>notes</code>, return all of the matching data from the database. We could address this by setting a <a data-primary="limit()" data-type="indexterm" id="idm45339502218216"/><code>limit()</code> method on our database queries. For example, in our <em>.src/resolvers/query.js</em> file, we can update our <code>notes</code> query as <span class="keep-together">follows:</span></p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">notes</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">limit</code><code class="p">(</code><code class="mi">100</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>While limiting data is a solid start, currently our queries can be written with an unlimited depth. This means that a single query could be written to retrieve a list of notes, the author information for each of those notes, the list of favorites of each author, the author information for each of those favorites, and so on. That’s a lot of data in one query, and we could keep going! To prevent these types of overnested queries, we can <em>limit the depth</em> of queries against our API.</p>&#13;
&#13;
<p>Additionally, we might have complex queries that are not overly nested, but still require heavy computation to return the data. We can protect against these types of requests by <em>limiting query complexity</em>.</p>&#13;
&#13;
<p>We can implement these limits by using the <code>graphql-depth-limit</code> and <code>graphql-validation-complexity</code> packages in our <em>./src/index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// import the modules at the top of the file</code>&#13;
<code class="kr">const</code> <code class="nx">depthLimit</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'graphql-depth-limit'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">createComplexityLimitRule</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'graphql-validation-complexity'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// update our ApolloServer code to include validationRules</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code>&#13;
  <code class="nx">typeDefs</code><code class="p">,</code>&#13;
  <code class="nx">resolvers</code><code class="p">,</code>&#13;
  <code class="nx">validationRules</code><code class="o">:</code> <code class="p">[</code><code class="nx">depthLimit</code><code class="p">(</code><code class="mi">5</code><code class="p">),</code> <code class="nx">createComplexityLimitRule</code><code class="p">(</code><code class="mi">1000</code><code class="p">)],</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">async</code> <code class="p">({</code> <code class="nx">req</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// get the user token from the headers</code>&#13;
    <code class="kr">const</code> <code class="nx">token</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">headers</code><code class="p">.</code><code class="nx">authorization</code><code class="p">;</code>&#13;
    <code class="c1">// try to retrieve a user with the token</code>&#13;
    <code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getUser</code><code class="p">(</code><code class="nx">token</code><code class="p">);</code>&#13;
    <code class="c1">// add the db models and the user to the context</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">models</code><code class="p">,</code> <code class="nx">user</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>With these package additions, we’ve added extra query protection to our API. For more information on securing a GraphQL API from malicious queries, check out the <a href="https://oreil.ly/_r5tl">fantastic article</a> from Max Stoiber, CTO of Spectrum.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Considerations" data-type="sect1"><div class="sect1" id="idm45339502246680">&#13;
<h1>Other Considerations</h1>&#13;
&#13;
<p>After building our API, you should have a solid understanding of the fundamentals of GraphQL development. If you’re eager to dig in more on the topics, some excellent places to go next would be testing, GraphQL subscriptions, and Apollo Engine.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing" data-type="sect2"><div class="sect2" id="idm45339502003176">&#13;
<h2>Testing</h2>&#13;
&#13;
<p><a data-primary="details" data-secondary="testing" data-type="indexterm" id="idm45339502001976"/><a data-primary="testing" data-type="indexterm" id="idm45339502001000"/><a data-primary="testing" data-secondary="about" data-type="indexterm" id="idm45339502000328"/>OK, I’ll admit it: I feel guilty for not writing about tests in this book. Testing our code is important because it allows us to comfortably make changes and improves our collaboration with other developers. One of the great things about our GraphQL setup is that resolvers are simply functions, taking some parameters and returning data. This makes our GraphQL logic straightforward to test.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subscriptions" data-type="sect2"><div class="sect2" id="idm45339501998584">&#13;
<h2>Subscriptions</h2>&#13;
&#13;
<p><a data-primary="details" data-secondary="subscriptions" data-type="indexterm" id="idm45339501997416"/><a data-primary="subscriptions" data-type="indexterm" id="idm45339501996440"/>Subscriptions are an incredibly powerful feature of GraphQL, which offers a straightforward way to integrate the publish-subscribe pattern in our application. This means that a UI can subscribe to be notified or updated when data is published on the server. This makes GraphQL servers an ideal solution for applications that work with real-time data. For more information about GraphQL subscriptions, take a look at the <a href="https://oreil.ly/YwI5_">Apollo Server documentation</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Apollo GraphQL Platform" data-type="sect2"><div class="sect2" id="idm45339501994296">&#13;
<h2>Apollo GraphQL Platform</h2>&#13;
&#13;
<p><a data-primary="Apollo GraphQL platform" data-type="indexterm" id="idm45339501993096"/><a data-primary="details" data-secondary="Apollo GraphQL platform" data-type="indexterm" id="idm45339501992392"/>Throughout the development of our API, we’ve been using the Apollo GraphQL library. In future chapters we’ll also be using the Apollo client libraries to interface with our API. I’ve chosen these libraries because they are industry standards and offer a great developer experience for working with GraphQL. If you take your application to production, Apollo, the company who maintains these libraries, also offers a platform that provides monitoring and tooling for GraphQL APIs. You can learn more at <a href="https://www.apollographql.com">Apollo’s website</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339501989912">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter we added some finishing touches to our application. Though there are many other options we could implement, at this point we have developed a solid MVP (minimum viable product). In this state, we are ready to launch our API! In the next chapter, we’ll deploy our API to a public web server.<a data-startref="ix_ch09-asciidoc0" data-type="indexterm" id="idm45339501988232"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>