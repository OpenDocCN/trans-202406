<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 23. Network Policies" class="praise"><div class="dedication" id="network_policies">
<h1 class="calibre14"><span class="keep-together">Chapter 23. </span>Network Policies</h1>


<p class="author1">The uniqueness of the IP address assigned to a Pod is maintained across all nodes and namespaces. This is accomplished by allocating a dedicated subnet to each registered node during its creation. The Container Network Interface (CNI) plugin handles the leasing of IP addresses from the assigned subnet when a new Pod is created on a node. Consequently, Pods on a node can seamlessly communicate with all other Pods running on any node within the cluster.</p>

<p class="author1">Network policies in Kubernetes function similarly to firewall rules, specifically designed for governing Pod-to-Pod communication. These policies include rules specifying the direction of network traffic (ingress and/or egress) for one or multiple Pods within a namespace or across different namespaces. Additionally, these rules define the targeted ports for communication. This fine-grained control enhances security and governs the flow of traffic within the Kubernetes cluster.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id492">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Demonstrate basic understanding of Network Policies</p>
</li>
</ul>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with Network Policies" class="praise"><div class="dedication" id="id434">
<h1 class="calibre17">Working with Network Policies</h1>

<p class="author1">Within a Kubernetes cluster, any Pod can talk to any other Pod without restrictions using its <a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pods" class="calibre10">IP address or DNS name</a>, even across namespaces. Not only does unrestricted inter-Pod communication pose a potential security risk, it also makes it harder to understand the mental communication model of your architecture. A network policy defines the rules that control traffic from and to a Pod, as illustrated in <a data-type="xref" href="#network_policies_from_to_pods" class="calibre10">Figure 23-1</a>.</p>

<figure class="calibre35"><div id="network_policies_from_to_pods" class="figure">
<img src="Images/ckd2_2301.png" alt="ckd2 2301" class="calibre113"/>
<h6 class="calibre32"><span class="keep-together">Figure 23-1. </span>Network policies define traffic from and to a Pod</h6>
</div></figure>

<p class="author1">For example, there’s no good reason to allow a backend application running in a Pod to talk directly to the frontend application running in another Pod. The communication should be directed from the frontend Pod to the backend Pod.</p>








<section data-type="sect2" data-pdf-bookmark="Installing an Network Policy Controller" class="praise"><div class="dedication" id="id435">
<h2 class="calibre33">Installing an Network Policy Controller</h2>

<p class="author1">A network policy cannot work without a network policy controller. The network policy controller evaluates the collection of rules defined by a network policy. You can find instructions for a wide range of network policy controllers in the <a href="https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/" class="calibre10">Kubernetes documentation</a>.</p>

<p class="author1"><a href="https://cilium.io/" class="calibre10">Cilium</a> is a CNI that implements a network policy controller. You can install Cilium on cloud provider and on-prem Kubernetes clusters. Refer to the <a href="https://docs.cilium.io/en/stable/gettingstarted/k8s-install-default/" class="calibre10">installation instructions</a> for detailed information. Once it is installed, you should find at least two Pods running Cilium and the Cilium Operator in the <code class="calibre15">kube-system</code> namespace:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pods -n kube-system</strong>
NAME                               READY   STATUS    RESTARTS       AGE
cilium-k5td6                       1/1     Running   0              110s
cilium-operator-f5dcdcc8d-njfbk    1/1     Running   0              110s
</pre>

<p class="author1">You can now assume that the rules defined by network policy objects will be evaluated. Additionally, you can use the Cilium command line tool to validate the proper installation.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating a Network Policy" class="praise"><div class="dedication" id="id436">
<h2 class="calibre33">Creating a Network Policy</h2>

<p class="author1">Label selection plays a crucial role in defining which Pods a network policy applies to. We already saw the concept in action in other contexts (e.g., the <a href="ch10.xhtml#deployments" class="calibre10">Deployment</a> and the <a href="ch21.xhtml#services" class="calibre10">Service</a>). Furthermore, a network policy defines the direction of the traffic, to allow or disallow. In the context of a network policy, incoming traffic is called <em class="calibre3">ingress</em>, and outgoing traffic is called <em class="calibre3">egress</em>. For ingress and egress, you can whitelist the sources of traffic like Pods, IP addresses, or ports.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Network policies do not apply to Services</h1>
<p class="author1">In most cases, you’d set up Service objects to funnel network traffic to Pods based on label and port selection. Network policies do not involve Services at all. All rules are namespace- and Pod-specific.</p>
</div>

<p class="author1">The creation of network policies is best explained by example. Let’s say you’re dealing with the following scenario: you’re running a Pod that exposes an API to other consumers. For example, a Pod that processes payments for other applications. The company you’re working for is migrating applications from a legacy payment processor to a new one. Therefore, you’ll want to allow access only from the applications that are capable of properly communicating with it. Right now, you have two consumers—a grocery store and a coffee shop—each running their application in a separate Pod. The coffee shop is ready to consume the API of the payment processor, but the grocery store isn’t. <a data-type="xref" href="#network_policy_api_allow" class="calibre10">Figure 23-2</a> shows the Pods and their assigned labels.</p>

<figure class="calibre35"><div id="network_policy_api_allow" class="figure">
<img src="Images/ckd2_2302.png" alt="ckd2 2302" class="calibre114"/>
<h6 class="calibre32"><span class="keep-together">Figure 23-2. </span>Limiting traffic to and from a Pod</h6>
</div></figure>

<p class="author1">Before creating a network policy, we’ll stand up the Pods to represent the scenario:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run grocery-store --image=nginx:1.25.3-alpine \
  -l app=grocery-store,role=backend --port 80</strong>
pod/grocery-store created
<strong class="calibre38">$ kubectl run payment-processor --image=nginx:1.25.3-alpine \
  -l app=payment-processor,role=api --port 80</strong>
pod/payment-processor created
<strong class="calibre38">$ kubectl run coffee-shop --image=nginx:1.25.3-alpine \
  -l app=coffee-shop,role=backend --port 80</strong>
</pre>

<p class="author1">Given Kubernetes’ default behavior of allowing unrestricted Pod-to-Pod communication, the three Pods will be able to talk to one another. The following commands verify the behavior. The grocery store and coffee shop Pods perform a <code class="calibre15">wget</code> call to the payment processor Pod’s IP address:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pod payment-processor --template '{{.status.podIP}}'</strong>
10.244.0.136
<strong class="calibre38">$ kubectl exec grocery-store -it -- wget --spider --timeout=1 10.244.0.136</strong>
Connecting to 10.244.0.136 (10.244.0.136:80)
remote file exists
<strong class="calibre38">$ kubectl exec coffee-shop -it -- wget --spider --timeout=1 10.244.0.136</strong>
Connecting to 10.244.0.136 (10.244.0.136:80)
remote file exists
</pre>

<p class="author1">You cannot create a new network policy with the imperative <code class="calibre15">create</code> command. Instead, you will have to use the declarative approach. The YAML manifest in <a data-type="xref" href="#network_policy" class="calibre10">Example 23-1</a>, stored in the file <em class="calibre3">networkpolicy-api-allow.yaml</em>, shows a network policy for the scenario described previously.</p>
<div id="network_policy" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 23-1. </span>Declaring a NetworkPolicy with YAML</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">networking.k8s.io/v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">NetworkPolicy</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">api-allow</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">                     </code><a class="calibre10" id="co_network_policies_CO1-1" href="#callout_network_policies_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">payment-processor</code><code class="w">
</code><code class="w">      </code><code class="nt">role</code><code class="p">:</code><code class="w"> </code><code class="calibre15">api</code><code class="w">
</code><code class="w">  </code><code class="nt">ingress</code><code class="p">:</code><code class="w">                         </code><a class="calibre10" id="co_network_policies_CO1-2" href="#callout_network_policies_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">from</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">
</code><code class="w">        </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">
</code><code class="w">          </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">coffee-shop</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_network_policies_CO1-1" href="#co_network_policies_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Selects the Pod the policy should apply to by label selection.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_network_policies_CO1-2" href="#co_network_policies_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Allows incoming traffic from the Pod with matching labels within the same namespace.</p></dd>
</dl>

<p class="author1">A network policy defines a couple of important attributes, which together form its set of rules. <a data-type="xref" href="#network_policy_spec_attributes" class="calibre10">Table 23-1</a> shows the attributes on the <code class="calibre15">spec</code> level.</p>
<table id="network_policy_spec_attributes" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 23-1. </span>Spec attributes of a network policy</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Attribute</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">podSelector</code></p></td>
<td class="calibre65"><p class="author1">Selects the Pods in the namespace to apply the network policy to.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">policyTypes</code></p></td>
<td class="calibre65"><p class="author1">Defines the type of traffic (i.e., ingress and/or egress) the network policy applies to.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">ingress</code></p></td>
<td class="calibre65"><p class="author1">Lists the rules for incoming traffic. Each rule can define <code class="calibre60">from</code> and <code class="calibre60">ports</code> sections.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">egress</code></p></td>
<td class="calibre65"><p class="author1">Lists the rules for outgoing traffic. Each rule can define <code class="calibre60">to</code> and <code class="calibre60">ports</code> sections.</p></td>
</tr>
</tbody>
</table>

<p class="author1">You can specify ingress and egress rules independently using <code class="calibre15">spec.ingress.from[]</code> and <code class="calibre15">spec.egress.to[]</code>. Each rule consists of a Pod selector, an optional namespace selector, or a combination of both. <a data-type="xref" href="#network_policy_to_from_selectors" class="calibre10">Table 23-2</a> lists the relevant attributes for the <code class="calibre15">to</code> and <code class="calibre15">from</code> selectors.</p>
<table id="network_policy_to_from_selectors" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 23-2. </span>Attributes of a network policy <code class="calibre60">to</code> and <code class="calibre60">from</code> selectors</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Attribute</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">podSelector</code></p></td>
<td class="calibre65"><p class="author1">Selects Pods by label(s) in the same namespace as the network policy that should be allowed as ingress sources or egress destinations.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">namespaceSelector</code></p></td>
<td class="calibre65"><p class="author1">Selects namespaces by label(s) for which all Pods should be allowed as ingress sources or egress destinations.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">namespaceSelector</code> and <code class="calibre60">podSelector</code></p></td>
<td class="calibre65"><p class="author1">Selects Pods by label(s) within namespaces by label(s).</p></td>
</tr>
</tbody>
</table>

<p class="author1">Let’s see the effect of the network policy in action. Create the network policy object from the manifest:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f networkpolicy-api-allow.yaml</strong>
networkpolicy.networking.k8s.io/api-allow created
</pre>

<p class="author1">The network policy prevents calling the payment processor from the grocery store Pod. Accessing the payment processor from the coffee shop Pod works perfectly, as the network policy’s Pod selector matches the Pod’s assigned label <code class="calibre15">app=coffee-shop</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">kubectl exec grocery-store -it -- wget --spider --timeout=1 10.244.0.136</strong>
Connecting to 10.244.0.136 (10.244.0.136:80)
wget: download timed out
command terminated with exit code 1
<strong class="calibre38">$ kubectl exec coffee-shop -it -- wget --spider --timeout=1 10.244.0.136</strong>
Connecting to 10.244.0.136 (10.244.0.136:80)
remote file exists
</pre>

<p class="author1">As a developer, you may be dealing with network policies that have been set up for you by other team members or administrators. You need to know about the <code class="calibre15">kubectl</code> commands for listing and inspecting network policy objects to understand their effects on the directional network traffic between microservices.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Listing Network Policies" class="praise"><div class="dedication" id="id437">
<h2 class="calibre33">Listing Network Policies</h2>

<p class="author1">Listing network policies works the same as any other Kubernetes primitive. Use the <code class="calibre15">get</code> command in combination with the resource type <code class="calibre15">networkpolicy</code>, or its short-form, <code class="calibre15">netpol</code>. For the previous network policy, you see a table that renders the name and Pod selector:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get networkpolicy api-allow</strong>
NAME         POD-SELECTOR                     AGE
api-allow    app=payment-processor,role=api   83m
</pre>

<p class="author1">It’s unfortunate that the output of the command doesn’t give a lot of information about the ingress and egress rules. To retrieve more information, you have to dig into the details.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Rendering Network Policy Details" class="praise"><div class="dedication" id="id438">
<h2 class="calibre33">Rendering Network Policy Details</h2>

<p class="author1">You can inspect the details of a network policy using the <code class="calibre15">describe</code> command. The output renders all the important information: Pod selector, and ingress and egress rules:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl describe networkpolicy api-allow</strong>
Name:         api-allow
Namespace:    default
Created on:   2024-01-10 09:06:59 -0700 MST
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Spec:
  PodSelector:     app=payment-processor,role=api
  Allowing ingress traffic:
    To Port: &lt;any&gt; (traffic allowed to all ports)
    From:
      PodSelector: app=coffee-shop
  Not affecting egress traffic
  Policy Types: Ingress
</pre>

<p class="author1">The network policy details don’t draw a clear picture of the Pods that have been selected based on its rules. You can create Pods that match the rules and do not match the rules to verify the network policy’s desired behavior.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Visualizing network policies</h1>
<p class="author1">Defining the rules of network policies correctly can be challenging. The page <a href="https://networkpolicy.io" class="calibre10">networkpolicy.io</a> provides a visual editor for network policies that renders a graphical representation in the browser.</p>
</div>

<p class="author1">As explained earlier, every Pod can talk to other Pods running on any node of the cluster, which exposes a potential security risk. An attacker able to gain access to a Pod theoretically can try to compromise another Pod by communicating with it by its virtual IP address.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Applying Default Network Policies" class="praise"><div class="dedication" id="id439">
<h2 class="calibre33">Applying Default Network Policies</h2>

<p class="author1">The principle of least privilege is a fundamental security concept, and it’s highly recommended when it comes to restricting Pod-to-Pod network traffic in Kubernetes. The idea is to initially disallow all traffic and then selectively open up only the necessary connections based on the application’s architecture and communication 
<span class="keep-together">requirements.</span></p>

<p class="author1">You can lock down Pod-to-Pod communication with the help of a <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-policies" class="calibre10">default network policy</a>. Default network policies are custom policies set up by administrators to enforce restrictive communication patterns by default.</p>

<p class="author1">To demonstrate the functionality of such a default network policy, we’ll set up two Pods in the namespace <code class="calibre15">internal-tools</code>. Within the namespace, all Pods will be able to communicate with each other:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create namespace internal-tools</strong>
namespace/internal-tools created
<strong class="calibre38">$ kubectl run metrics-api --image=nginx:1.25.3-alpine --port=80 \
  -l app=api -n internal-tools</strong>
pod/metrics-api created
<strong class="calibre38">$ kubectl run metrics-consumer --image=nginx:1.25.3-alpine --port=80 \
  -l app=consumer -n internal-tools</strong>
pod/metrics-consumer created
</pre>

<p class="author1">Let’s create a default network policy that denies all ingress and egress network traffic in the namespace. We’ll store the network policy in the file <em class="calibre3">networkpolicy-deny-all.yaml</em>.</p>
<div id="network_policy_default_deny_all" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 23-2. </span>Disallowing all traffic with the default policy</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">networking.k8s.io/v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">NetworkPolicy</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">default-deny-all</code><code class="w">
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre15">internal-tools</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"> </code><code class="calibre15">{</code><code class="calibre15">}</code><code class="w">                  </code><a class="calibre10" id="co_network_policies_CO2-1" href="#callout_network_policies_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">policyTypes</code><code class="p">:</code><code class="w">                     </code><a class="calibre10" id="co_network_policies_CO2-2" href="#callout_network_policies_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">Ingress</code><code class="w">                        </code><a class="calibre10" id="co_network_policies_CO2-3" href="#callout_network_policies_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">Egress</code><code class="w">                         </code><a class="calibre10" id="co_network_policies_CO2-4" href="#callout_network_policies_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_network_policies_CO2-1" href="#co_network_policies_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The curly braces for <code class="calibre15">spec.podSelector</code> mean “apply to all Pods in the 
<span class="keep-together">namespace.”</span></p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_network_policies_CO2-2" href="#co_network_policies_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Defines the types of traffic the rule should apply to, in this case ingress and egress traffic.</p></dd>
</dl>

<p class="author1">Create the network policy from the manifest:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f networkpolicy-deny-all.yaml</strong>
networkpolicy.networking.k8s.io/default-deny-all created
</pre>

<p class="author1">The network policy prevents any network communication between the Pods in the <code class="calibre15">internal-tools</code> namespace will, as shown here:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pod metrics-api --template '{{.status.podIP}}' -n internal-tools</strong>
10.244.0.182
<strong class="calibre38">$ kubectl exec metrics-consumer -it -n internal-tools \
  -- wget --spider --timeout=1 10.244.0.182</strong>
Connecting to 10.244.0.182 (10.244.0.182:80)
wget: download timed out
command terminated with exit code 1
<strong class="calibre38">$ kubectl get pod metrics-consumer --template '{{.status.podIP}}' \
  -n internal-tools</strong>
10.244.0.70
<strong class="calibre38">$ kubectl exec metrics-api -it -n internal-tools \
  -- wget --spider --timeout=1 10.244.0.70</strong>
Connecting to 10.244.0.70 (10.244.0.70:80)
wget: download timed out
command terminated with exit code 1
</pre>

<p class="author1">With those default deny constraints in place, you can define more detailed rules and loosen restrictions gradually. Network policies are additive. It’s common practice to now set up additional network policies that will open up directional traffic, but only the ones that are really required.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Restricting Access to Specific Ports" class="praise"><div class="dedication" id="id440">
<h2 class="calibre33">Restricting Access to Specific Ports</h2>

<p class="author1">Controlling access at the port level is a critical aspect of network security in Kubernetes. If not explicitly defined by a network policy, all ports are accessible, which can pose security risks. For instance, if you have an application running in a Pod that exposes port 80 to the outside world, leaving all other ports open widens the attack vector unnecessarily. Port rules can be specified for ingress and egress as part of a 
<span class="keep-together">network</span> policy. The definition of a network policy in <a data-type="xref" href="#network_policy_ports" class="calibre10">Example 23-3</a> allows access on port 80.</p>
<div id="network_policy_ports" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 23-3. </span>Definition of a network policy allowing ingress access on port 8080</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">networking.k8s.io/v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">NetworkPolicy</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">port-allow</code><code class="w">
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre15">internal-tools</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">api</code><code class="w">
</code><code class="w">  </code><code class="nt">ingress</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">from</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">
</code><code class="w">        </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">
</code><code class="w">          </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">consumer</code><code class="w">
</code><code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w">                         </code><a class="calibre10" id="co_network_policies_CO3-1" href="#callout_network_policies_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="calibre15">TCP</code><code class="w">                </code><a class="calibre10" id="co_network_policies_CO3-2" href="#callout_network_policies_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre15">80</code><code class="w">                     </code><a class="calibre10" id="co_network_policies_CO3-3" href="#callout_network_policies_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_network_policies_CO3-1" href="#co_network_policies_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Only allows incoming traffic on port 80.</p></dd>
</dl>

<p class="author1">When defining network policies, only allow those ports that are required for implementing your architectural needs. All other ports should be locked down.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id441">
<h1 class="calibre17">Summary</h1>

<p class="author1">Intra-Pod communication or communication between two containers of the same Pod is completely unrestricted in Kubernetes. Network policies instate rules to control the network traffic either from or to a Pod. You can think of network policies as firewall rules for Pods. It’s best practice to start with a “deny all traffic” rule to minimize the attack vector.</p>

<p class="author1">From there, you can open access as needed. Learning about the intricacies of network policies requires a bit of hands-on practice, as it is not directly apparent if the rules work as expected.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id442">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Understand the purpose and effects of network policies</dt>
<dd class="calibre20">
<p class="calibre21">By default, Pod-to-Pod communication is unrestricted. Instantiate a default deny rule to restrict Pod-to-Pod network traffic with the principle of least privilege. The attribute <code class="calibre15">spec.podSelector</code> of a network policy selects the target Pod the rules apply to based on label selection. The ingress and egress rules define Pods, namespaces, IP addresses, and ports for allowing incoming and outgoing traffic.</p>
</dd>
<dt class="calibre19">Know how to implement the principle of least privilege</dt>
<dd class="calibre20">
<p class="calibre21">Network policies can be aggregated. A default deny rule can disallow ingress and/or egress traffic. An additional network policy can open up those rules with a more fine-grained definition.</p>
</dd>
<dt class="calibre19">Explore common network policy scenarios</dt>
<dd class="calibre20">
<p class="calibre21">To explore common scenarios, look at the GitHub repository named <a href="https://github.com/ahmetb/kubernetes-network-policy-recipes" class="calibre10">“Kubernetes Network Policy Recipes”</a>. The repository comes with a visual representation for each scenario and walks you through the steps to set up the network policy and the involved Pods. This is a great practice resource.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id443">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_019.xhtml#appendix_a_network_policies" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">You have been tasked with setting up a network policy for an existing application stack that consists of a <code class="calibre15">frontend</code> Pod in the namespace <code class="calibre15">end-user</code> and a <code class="calibre15">backend</code> Pod in the namespace <code class="calibre15">internal</code>.</p>

<p class="author1">Navigate to the directory <em class="calibre3">app-a/ch23/app-stack</em> of the checked-out GitHub repository <a href="https://github.com/bmuschko/ckad-study-guide" class="calibre10"><em class="calibre3">bmuschko/ckad-study-guide</em></a>. Create the objects from the YAML manifest <em class="calibre3">setup.yaml</em>. Inspect the objects in both namespaces.</p>

<p class="author1">Create a network policy named <code class="calibre15">app-stack</code> in the <code class="calibre15">end-user</code> namespace. Allow egress traffic only from the <code class="calibre15">frontend</code> Pod to the <code class="calibre15">backend</code> Pod. The <code class="calibre15">backend</code> Pod should be reachable only on port 80.</p>
</li>
<li class="calibre56">
<p class="author1">Navigate to the directory <em class="calibre3">app-a/ch23/troubleshooting</em> of the checked-out GitHub repository <a href="https://github.com/bmuschko/ckad-study-guide" class="calibre10"><em class="calibre3">bmuschko/ckad-study-guide</em></a>. Create the objects from the YAML manifest <em class="calibre3">setup.yaml</em>. Inspect the objects in the namespace <code class="calibre15">k1</code> and <code class="calibre15">k2</code>.</p>

<p class="author1">Determine the virtual IP address of Pod <code class="calibre15">nginx</code> in namespace <code class="calibre15">k2.</code> Try to make a wget call on port 80 from the Pod <code class="calibre15">busybox</code> in namespace <code class="calibre15">k1</code> to the Pod <code class="calibre15">nginx</code> in namespace <code class="calibre15">k2</code>. The call will fail with the current setup.</p>

<p class="author1">Create a network policy that allows performing ingress calls for all Pods in namespace <code class="calibre15">k1</code> to the Pod <code class="calibre15">nginx</code> in namespace <code class="calibre15">k2</code>. Pods in all other namespaces should be denied to make ingress calls to Pods in namespace <code class="calibre15">k2</code>.</p>

<p class="author1">Verify that a network connection can be established.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>