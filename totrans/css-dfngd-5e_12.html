<html><head></head><body><section data-pdf-bookmark="Chapter 12. Grid Layout" data-type="chapter" epub:type="chapter"><div class="chapter" id="grid-layout">&#13;
<h1><span class="label">Chapter 12. </span>Grid Layout</h1>&#13;
&#13;
&#13;
<p>At its <a data-primary="grid layout" data-type="indexterm" id="grid_layout_ch12"/>inception, CSS had a layout-shaped hole at its center. Designers bent other&#13;
features to the purposes of layout, most notably <code>float</code> and <code>clear</code>,&#13;
and generally hacked their way around that hole. Flexbox layout helped to&#13;
fill it, but flexbox is really meant for specific use cases, like&#13;
navigation bars (navbars), as shown in <a data-type="xref" href="ch11.html#flexbox">Chapter 11</a>.</p>&#13;
&#13;
<p>Grid layout, by contrast, is a <em>generalized</em> layout system. With its&#13;
emphasis on rows and columns, it might at first feel like a return to table&#13;
layout—and in certain ways that’s not too far off—but there is far,&#13;
far more to grid layout than table layout. <a data-primary="table layout" data-secondary="versus grid layout" data-secondary-sortas="grid layout" data-type="indexterm" id="idm45176074690864"/><a data-primary="grid layout" data-secondary="versus table layout" data-secondary-sortas="table layout" data-type="indexterm" id="idm45176074689616"/>Grid allows pieces of the&#13;
design to be laid out independently of their document source order, and&#13;
even overlap pieces of the layout, if that’s your wish. CSS provides&#13;
powerfully flexible methods for defining repeating patterns of grid&#13;
lines, attaching elements to those grid lines, and more. You can nest&#13;
grids inside grids, or for that matter, attach tables or flexbox&#13;
containers to a grid. And much, much more.</p>&#13;
&#13;
<p>In short, grid layout was the layout system we long waited for, and in 2017, it landed in all the major browser engines.  It takes many, many layouts that were difficult, or even impossible, and invariably fragile, and allows you to create them simply, flexibly, and robustly.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a Grid Container" data-type="sect1"><div class="sect1" id="creating-a-grid-container">&#13;
<h1>Creating a Grid Container</h1>&#13;
&#13;
<p>The <a data-primary="grid layout" data-secondary="grid container" data-type="indexterm" id="ix_grid_container"/><a data-primary="container box" data-secondary="grid layout" data-type="indexterm" id="ix_cont_box_grid"/>first step to creating a grid is defining a <em>grid container</em>. This&#13;
is much like a containing block in positioning, or a flex container in&#13;
flexible-box layout: a <a data-primary="grid layout" data-secondary="grid-formatting context" data-type="indexterm" id="idm45176074682768"/>grid container is an element that defines a <em>grid&#13;
formatting context</em> for its contents.</p>&#13;
&#13;
<p>At <a data-primary="grid layout" data-secondary="grid items" data-type="indexterm" id="idm45176074680608"/>this basic level, grid layout is quite reminiscent of&#13;
flexbox. For example, the <a data-primary="grid items" data-type="indexterm" id="idm45176074679504"/>child elements of a grid container become&#13;
<em>grid items</em>, just as the child elements of a flex container become flex&#13;
items. <a data-primary="nesting grids" data-type="indexterm" id="idm45176074678288"/><a data-primary="grid layout" data-secondary="nesting grids" data-type="indexterm" id="idm45176074677584"/>The children of those grid items do <em>not</em> become grid&#13;
elements—although any grid item can itself be made a grid container, and&#13;
thus have its child elements become grid items to the nested grid. It’s possible to nest grids inside grids, until it’s grids all the way down.</p>&#13;
&#13;
<p>CSS has two <a data-primary="inline grids" data-type="indexterm" id="idm45176074675648"/><a data-primary="display property" data-secondary="grid layout" data-type="indexterm" id="idm45176074674912"/><a data-primary="grid layout" data-secondary="inline grids" data-type="indexterm" id="idm45176074673968"/>kinds of grids: <em>regular</em> grids and <em>inline</em> grids. These are&#13;
created with special values for the <code>display</code> property: <code>grid</code> and&#13;
<code>inline-grid</code>. The first generates a block-level box, and the second an&#13;
inline-level box. <a data-type="xref" href="#grids_and_inline_grids">Figure 12-1</a> illustrates the difference.</p>&#13;
&#13;
<figure><div class="figure" id="grids_and_inline_grids">&#13;
<img alt="image" src="assets/css5_1201.png"/>&#13;
<h6><span class="label">Figure 12-1. </span>Grids and inline grids</h6>&#13;
</div></figure>&#13;
&#13;
<p>These are very similar to the <code>block</code> and <code>inline-block</code> values for&#13;
<code>display</code>. Most grids you create are likely to be block-level, though&#13;
the ability to create inline grids is always there should you need it.</p>&#13;
&#13;
<p>Although <code>display: grid</code> creates a block-level grid, the specification&#13;
is careful to explicitly state that “grid containers are not block&#13;
containers.” Although the grid box participates&#13;
in layout much as a block container does, there are differences between them.</p>&#13;
&#13;
<p>First off, <a data-primary="floating" data-secondary="grid layouts and" data-type="indexterm" id="idm45176074665072"/><a data-primary="grid layout" data-secondary="floated elements and" data-type="indexterm" id="idm45176074664064"/>floated elements do not intrude into the grid container. What&#13;
this means in practice is that a grid will not slide under a floated&#13;
element, as a block container will. See <a data-type="xref" href="#floats_interact_differently">Figure 12-2</a> for a demonstration&#13;
of the difference.</p>&#13;
&#13;
<figure><div class="figure" id="floats_interact_differently">&#13;
<img alt="image" src="assets/css5_1202.png"/>&#13;
<h6><span class="label">Figure 12-2. </span>Floats interact differently with blocks and grids</h6>&#13;
</div></figure>&#13;
&#13;
<p>Furthermore, the <a data-primary="margins" data-secondary="grid layout" data-type="indexterm" id="idm45176074659680"/><a data-primary="vertical formatting" data-secondary="collapsing margins" data-type="indexterm" id="idm45176074658704"/><a data-primary="grid layout" data-secondary="margins and grid" data-type="indexterm" id="idm45176074657728"/><a data-primary="collapsing margins" data-type="indexterm" id="idm45176074656784"/><a data-primary="margins" data-secondary="collapsing" data-type="indexterm" id="idm45176074656112"/>margins of a grid container do not collapse with the&#13;
margins of its descendants. Again, this is distinct from block boxes,&#13;
whose margins do (by default) collapse with descendants. For example,&#13;
the first list item in an ordered list may have a top margin, but this&#13;
margin will collapse with the list element’s top margin. The top margin&#13;
of a grid item will <em>never</em> collapse with the top margin of its grid&#13;
container. <a data-type="xref" href="#margin_collapsing">Figure 12-3</a> &#13;
<span class="keep-together">illustrates</span> the difference.</p>&#13;
&#13;
<figure><div class="figure" id="margin_collapsing">&#13;
<img alt="image" src="assets/css5_1203.png"/>&#13;
<h6><span class="label">Figure 12-3. </span>Margin collapsing and the lack thereof</h6>&#13;
</div></figure>&#13;
&#13;
<p>A few CSS <a data-primary="grid layout" data-secondary="properties not applicable to" data-type="indexterm" id="idm45176074650848"/>properties and features do not apply to grid&#13;
containers and grid items:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>All <code>column</code> properties<a data-primary="column property" data-type="indexterm" id="idm45176074648048"/> (e.g., <code>column-count</code>, <code>columns</code>, etc.) are&#13;
ignored when applied to a grid container. (You can learn more about multicolumn properties at <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns">CSS Multi-Column Layout</a>.)</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>::first-line</code> and <code>::first-letter</code> pseudo-elements<a data-primary="::first-letter pseudo-element" data-primary-sortas="first-letter pseudo-element" data-type="indexterm" id="idm45176074643904"/><a data-primary="::first-line pseudo-element" data-primary-sortas="first-line pseudo-element" data-type="indexterm" id="idm45176074642960"/> do not apply&#13;
to grid containers and are ignored.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>float</code> and <code>clear</code> are<a data-primary="float property" data-type="indexterm" id="idm45176074640016"/><a data-primary="clear property" data-type="indexterm" id="idm45176074639280"/> effectively ignored for grid items (though not&#13;
grid containers). Despite this, the <code>float</code> property still helps&#13;
determine the computed value of the &#13;
<span class="keep-together"><code>display</code></span> property for children of a&#13;
grid container, because the <code class="keep-together">display</code> value of the grid items is&#13;
resolved <em>before</em> they’re made into grid items.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>vertical-align</code> property<a data-primary="vertical-align property" data-secondary="grid items and" data-type="indexterm" id="idm45176074634992"/><a data-primary="vertical formatting" data-secondary="alignment setting" data-type="indexterm" id="idm45176074634048"/><a data-primary="alignment" data-secondary="vertical" data-type="indexterm" id="idm45176074633104"/> has no effect on the placement of grid items, though it&#13;
may affect the content inside the grid item. (Don’t worry: we’ll talk later about other, more powerful ways to align grid items.)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Lastly, if a <a data-primary="inline grids" data-type="indexterm" id="idm45176074631168"/><a data-primary="grid layout" data-secondary="inline grids" data-type="indexterm" id="idm45176074630464"/>grid container’s declared <code>display</code> value is <code>inline-grid</code>&#13;
<em>and</em> the element is either floated or absolutely positioned, the&#13;
computed value of <code>display</code> becomes <code>grid</code> (thus dropping&#13;
<code>inline-grid</code>).</p>&#13;
&#13;
<p>Once you’ve defined a grid container, the next step is to set up the&#13;
grid within. Before we explore how that works, though, it’s necessary to&#13;
cover some terminology.<a data-primary="" data-startref="ix_cont_box_grid" data-type="indexterm" id="idm45176074626480"/><a data-primary="" data-startref="ix_grid_container" data-type="indexterm" id="idm45176074625504"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Basic Grid Terminology" data-type="sect1"><div class="sect1" id="basic-grid-terminology">&#13;
<h1>Understanding Basic Grid Terminology</h1>&#13;
&#13;
<p>We’ve <a data-primary="grid layout" data-secondary="terminology" data-type="indexterm" id="ix_grid_term"/>already talked about grid containers and grid items, but let’s&#13;
define them in a bit more detail. <a data-primary="grid layout" data-secondary="grid-formatting context" data-type="indexterm" id="idm45176074621008"/>As we said before, a <em>grid container</em>&#13;
is a box that establishes a <em>grid-formatting context</em>—that is, an area&#13;
in which a grid is created and elements are laid out according to the rules of grid layout instead of block layout. You can think of it like the way an element set to <code>display: table</code> creates a table-formatting context within it. Given the grid-like nature of tables, this comparison is fairly apt, though be sure not to make the assumption that grids are&#13;
just tables in another form. Grids are far more powerful than tables &#13;
<span class="keep-together">ever were.</span></p>&#13;
&#13;
<p>A <em>grid item</em> is a <a data-primary="grid layout" data-secondary="grid items" data-type="indexterm" id="idm45176074617360"/><a data-primary="grid items" data-type="indexterm" id="idm45176074616352"/><a data-primary="anonymous items" data-secondary="grid items" data-type="indexterm" id="idm45176074615680"/>thing that participates in grid layout within a grid-formatting context.&#13;
This is usually a child element of a grid&#13;
container, but it can also be the anonymous (that is, not contained&#13;
within an element) bits of text that are part of an element’s content.&#13;
Consider the following, which has the result shown in <a data-type="xref" href="#grid_items">Figure 12-4</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#warning</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="m">#FCC</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">7</code><code class="o">,</code> <code class="m">1</code><code class="n">fr</code><code class="p">);}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">p</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"warning"</code><code class="o">&gt;&lt;</code><code class="nt">img</code> <code class="nt">src</code><code class="o">=</code><code class="s2">"warning.svg"</code><code class="o">&gt;&lt;</code><code class="nt">strong</code><code class="o">&gt;</code><code class="nt">Note</code><code class="o">:&lt;/</code><code class="nt">strong</code><code class="o">&gt;</code> <code class="nt">This</code> <code class="nt">element</code> <code class="nt">is</code> <code class="nt">a</code>&#13;
   <code class="o">&lt;</code><code class="nt">em</code><code class="o">&gt;</code><code class="nt">grid</code> <code class="nt">container</code><code class="o">&lt;/</code><code class="nt">em</code><code class="o">&gt;</code> <code class="nt">with</code> <code class="nt">several</code> <code class="o">&lt;</code><code class="nt">em</code><code class="o">&gt;</code><code class="nt">grid</code> <code class="nt">items</code><code class="o">&lt;/</code><code class="nt">em</code><code class="o">&gt;</code> <code class="nt">inside</code> <code class="nt">it</code><code class="o">.&lt;/</code><code class="nt">p</code><code class="o">&gt;</code></pre>&#13;
&#13;
<figure><div class="figure" id="grid_items">&#13;
<img alt="image" src="assets/css5_1204.png"/>&#13;
<h6><span class="label">Figure 12-4. </span>Grid items</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice how each element, <em>and</em> each bit of text between the elements, has become a&#13;
grid item. The image is a grid item, just as much as the elements and&#13;
text runs—seven grid items in all. Each will participate in the&#13;
grid layout, although the anonymous text runs will be much more&#13;
difficult (or impossible) to affect with the various grid properties&#13;
we’ll discuss.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’re wondering about <code>grid-template-rows</code> and&#13;
<code>grid-template-columns</code>, we’ll tackle them in the next section.</p>&#13;
</div>&#13;
&#13;
<p>In the course of using those properties, you’ll create or reference&#13;
several core components of grid layout. These are summarized in <a data-type="xref" href="#grid_components">Figure 12-5</a>.</p>&#13;
&#13;
<p>The <a data-primary="grid layout" data-secondary="grid lines" data-type="indexterm" id="ix_grid_layout_lines"/>most fundamental unit is the <em>grid line</em>. By defining the placement&#13;
of one or more grid lines, you implicitly create the rest of the grid’s&#13;
components:</p>&#13;
<dl>&#13;
<dt>Grid track</dt>&#13;
<dd>&#13;
<p>A <a data-primary="grid layout" data-secondary="grid tracks" data-type="indexterm" id="idm45176074487808"/>continuous run between two adjacent grid&#13;
lines—in other words, a <em>grid column</em> or a <em>grid row</em>. It goes from one&#13;
edge of the grid container to the other. The size of a grid track is&#13;
dependent on the placement of the grid lines that define it. These are&#13;
analogous to table columns and rows. More generically, these can be&#13;
referred to as <em>block-axis</em> and <em>inline-axis</em> tracks, where (in Western&#13;
languages) column tracks are on the block axis and row tracks are on the&#13;
inline axis.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grid_components">&#13;
<img alt="image" src="assets/css5_1205.png"/>&#13;
<h6><span class="label">Figure 12-5. </span>Grid components</h6>&#13;
</div></figure>&#13;
<dl>&#13;
<dt>Grid cell</dt>&#13;
<dd>&#13;
<p>Any <a data-primary="grid layout" data-secondary="grid cells" data-type="indexterm" id="idm45176074481200"/><a data-primary="grid cells" data-type="indexterm" id="idm45176074480192"/>space bounded by four grid lines, with no grid&#13;
lines running through it, analogous to a table cell. This is the&#13;
smallest unit of area in grid layout. Grid cells cannot be directly&#13;
addressed with CSS grid properties; that is, no property allows you to&#13;
say a grid item should be associated with a given cell. (But see the next&#13;
point for more details.)</p>&#13;
</dd>&#13;
<dt>Grid area</dt>&#13;
<dd>&#13;
<p>Any <a data-primary="grid layout" data-secondary="grid areas" data-type="indexterm" id="idm45176074478112"/>rectangular area bounded by four grid lines and&#13;
made up of one or more grid cells. An area can be as small as a single&#13;
cell or as large as all the cells in the grid. Grid areas <em>are</em> directly&#13;
addressable by CSS grid properties, which allow you to define the areas&#13;
and then associate grid items with them.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>An important point to note is that these grid tracks, cells, and areas&#13;
are entirely constructed of grid lines—and, more importantly, do not have&#13;
to correspond to grid items. There is no requirement that all grid areas&#13;
be filled with an item; it is perfectly possible to have some or even&#13;
most of a grid’s cells be empty of any content. You can also have grid items overlap each other, either by defining overlapping grid&#13;
areas or by using grid-line references that create overlapping&#13;
situations.</p>&#13;
&#13;
<p>Another fact to keep in mind is that you can define as many or as few&#13;
grid lines as you wish. You could literally define just a set of&#13;
vertical grid lines, thus creating a bunch of columns and only one row.&#13;
Or you could go the other way, creating a bunch of row tracks and no&#13;
column tracks (though there would be one, stretching from one side of&#13;
the grid container to the other).</p>&#13;
&#13;
<p>The flip side is that if you create a condition preventing a grid item&#13;
from being placed within the column and row tracks you define, or if you&#13;
explicitly place a grid item outside those tracks, new grid lines and&#13;
tracks will be automatically added to the grid to accommodate, creating&#13;
implicit grid tracks (a subject we’ll return to later in the chapter).<a data-primary="" data-startref="ix_grid_term" data-type="indexterm" id="idm45176074475088"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Grid Lines" data-type="sect1"><div class="sect1" id="creating-grid-lines">&#13;
<h1>Creating Grid Lines</h1>&#13;
&#13;
<p>It turns out that creating grid lines can get fairly complex. That’s not so much because the concept is difficult. CSS just provides many ways to get it done, and each uses its own subtly different syntax.</p>&#13;
&#13;
<p>We’ll <a data-primary="grid-template-columns property" data-type="indexterm" id="ix_grid_temp_col_prop"/><a data-primary="grid-template-rows property" data-type="indexterm" id="ix_grid_temp_row_prop"/>start by looking at two closely related properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176074469360">&#13;
<h1>grid-template-rows, grid-template-columns</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | &lt;<em><code>track-list</code></em>&gt; | &lt;<code><em>auto-track-list</em></code>&gt;_  | [ <code>subgrid</code> &lt;<code><em>line-name-list</em></code>&gt; ]?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the inline size (usually width) of the grid&#13;
container for <code>grid-template-columns</code>, and to the block size (usually&#13;
height) of the grid container for <code>grid-template-rows</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared, with lengths made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>With <a data-primary="explicit grid" data-type="indexterm" id="idm45176074451808"/>these properties, you can define the grid tracks of your overall&#13;
<em>grid template</em>, or what the CSS specification calls the <em>explicit&#13;
grid</em>. Everything depends on these grid tracks; fail to place them&#13;
properly, and the whole layout can easily fall apart.</p>&#13;
&#13;
<p>Once you define a grid track, grid lines are created.  If you create just one track for the whole grid, two lines are created: one at the start of the track and one at the end.  Two tracks means three lines: one at the start of the first track, one between the two, and one at the end of the second track.  And so on.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>When you’re starting out with CSS grid layout, it’s probably a good idea to sketch out where the grid tracks need to be on paper&#13;
first, or in some close digital analogue. Having a visual reference for&#13;
where the lines will land, and how the tracks should behave, can make writing&#13;
your grid CSS a lot easier.</p>&#13;
</div>&#13;
&#13;
<p>The exact syntax patterns for &lt;<em><code>track-list</code></em>&gt; and &lt;<em><code>auto-track-list</code></em>&gt; are complex and nest a few layers deep, and unpacking them would take a lot of time and space that’s better devoted to just exploring how things work. There are a lot of ways to make all this happen, so before&#13;
we start discussing those patterns, we have some basic things&#13;
to establish.</p>&#13;
&#13;
<p>First, <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="naming" data-type="indexterm" id="idm45176074445920"/>grid lines can always be referred to by number, but can also be&#13;
explicitly named by the author. Take the grid shown in <a data-type="xref" href="#grid_line_numbers_and_names">Figure 12-6</a>, for example. From your CSS, you can use any of the numbers to refer to a grid line, or you&#13;
can use the defined names, or you can mix them together. Thus, you could&#13;
say that a grid item stretches from column line <code>3</code> to line <code>steve</code>, and&#13;
from row line <code>skylight</code> to line <code>2</code>.</p>&#13;
&#13;
<p>Note that a grid line can have more than one name. You can use any of&#13;
them to refer to a given grid line, though you can’t combine them the&#13;
way you can multiple class names. You might think that means it’s a good idea&#13;
to avoid repeating grid-line names, but that’s not always the case, as&#13;
you’ll soon see.</p>&#13;
&#13;
<figure><div class="figure" id="grid_line_numbers_and_names">&#13;
<img alt="image" src="assets/css5_1206.png"/>&#13;
<h6><span class="label">Figure 12-6. </span>Grid-line numbers and names</h6>&#13;
</div></figure>&#13;
&#13;
<p>We used intentionally silly grid-line names in <a data-type="xref" href="#grid_line_numbers_and_names">Figure 12-6</a> to illustrate&#13;
that you can pick any name you like, as well as to avoid the implication&#13;
that there are “default” names. If you’d seen <code>start</code> for the first&#13;
line, you might have assumed that the first line is always called that.&#13;
Nope. If you want to stretch an element from <code>start</code> to <code>end</code>, you’ll&#13;
need to define those names yourself. Fortunately, that’s simple to do.</p>&#13;
&#13;
<p>As we’ve said, many value patterns can be&#13;
used to define the grid template. We’ll start with the simpler ones and work our way&#13;
toward the more complex.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We’ll discuss the <code>subgrid</code> value in <a data-type="xref" href="#subgrid">“Using Subgrids”</a>, after establishing how grid tracks and grid areas are defined, named, sized, combined, and so on.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Fixed-Width Grid Tracks" data-type="sect2"><div class="sect2" id="fixed-width-grid-tracks">&#13;
<h2>Using Fixed-Width Grid Tracks</h2>&#13;
&#13;
<p>As our initial step, let’s create a <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="fixed-width tracks" data-type="indexterm" id="ix_grid_line_fixw_track"/><a data-primary="grid layout" data-secondary="grid tracks" data-startref="ix_grid_track_fixw" data-tertiary="fixed-width" data-type="indexterm" id="idm45176074430080"/><a data-primary="fixed-width grid tracks" data-type="indexterm" id="ix_fix_width_grid_track"/>grid whose grid tracks are a fixed width.&#13;
We don’t necessarily mean a fixed length like&#13;
pixels or ems; percentages also count as fixed width here. In this&#13;
context, <em>fixed width</em> means the grid lines are placed such that the&#13;
distance between them does not change because of content changes within the grid tracks.</p>&#13;
&#13;
<p>So, as an example, this counts as a definition of three fixed-width grid&#13;
columns:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">200px</code> <code class="m">50%</code> <code class="m">100px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That will place a line 200 pixels from the start of the grid container&#13;
(by default, the left side); a second grid line half the width of the&#13;
grid container away from the first; and a third line 100 pixels away&#13;
from the second. This is illustrated in <a data-type="xref" href="#grid_line_placement">Figure 12-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="grid_line_placement">&#13;
<img alt="image" src="assets/css5_1207.png"/>&#13;
<h6><span class="label">Figure 12-7. </span>Grid-line placement</h6>&#13;
</div></figure>&#13;
&#13;
<p>While it’s true that the second column can change in size if the grid&#13;
container’s size changes, it will <em>not</em> change based on the content of&#13;
the grid items. However wide or narrow the content placed in that second&#13;
column, the column’s width will always be half the width of the grid&#13;
container.</p>&#13;
&#13;
<p>It’s also true that the last grid line doesn’t reach the right edge of&#13;
the grid container. That’s fine; it doesn’t have to. If you want it to—and you probably will—you’ll see various ways to deal with that in just&#13;
a bit.</p>&#13;
&#13;
<p>This is all lovely, but what if you want to <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="naming" data-type="indexterm" id="ix_grid_line_name"/>name your grid&#13;
lines? Just place any grid-line name you want, and as many as you want,&#13;
in the appropriate place in the value, surrounded by square brackets. That’s all! Let’s add some names to our previous&#13;
example, with the result shown in <a data-type="xref" href="#grid_name_placement">Figure 12-8</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">col</code><code class="o">-</code><code class="n">a</code><code class="p">]</code> <code class="m">200px</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">b</code><code class="p">]</code> <code class="m">50%</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">c</code><code class="p">]</code> <code class="m">100px</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code> <code class="n">last</code><code class="p">];</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="grid_name_placement">&#13;
<img alt="image" src="assets/css5_1208.png"/>&#13;
<h6><span class="label">Figure 12-8. </span>Grid-line naming</h6>&#13;
</div></figure>&#13;
&#13;
<p>What’s nice is that adding the names makes clear that each value is&#13;
actually specifying a grid track’s width, which means there is always a&#13;
grid line to either side of a width value. Thus, for the three widths we&#13;
have, four grid lines are actually created.</p>&#13;
&#13;
<p>Row grid lines are placed in exactly the same way as columns, as <a data-type="xref" href="#creating_a_grid">Figure 12-9</a> shows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">col</code><code class="o">-</code><code class="n">a</code><code class="p">]</code> <code class="m">200px</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">b</code><code class="p">]</code> <code class="m">50%</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">c</code><code class="p">]</code> <code class="m">100px</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code> <code class="n">last</code><code class="p">];</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">masthead</code><code class="p">]</code> <code class="m">3em</code> <code class="p">[</code><code class="n">content</code><code class="p">]</code> <code class="m">80%</code> <code class="p">[</code><code class="n">footer</code><code class="p">]</code> <code class="m">2em</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code><code class="p">];</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="creating_a_grid">&#13;
<img alt="image" src="assets/css5_1209.png"/>&#13;
<h6><span class="label">Figure 12-9. </span>Creating a grid</h6>&#13;
</div></figure>&#13;
&#13;
<p>We have a couple of things to point out here. First, both column and row lines have the names <code>start</code> and <code>end</code>. This is&#13;
perfectly OK. Rows and columns don’t share the same namespace, so you&#13;
can reuse names like these in the two contexts.<a data-primary="" data-startref="ix_grid_line_name" data-type="indexterm" id="idm45176074223376"/></p>&#13;
&#13;
<p>Second is the percentage value for the <code>content</code> row track. This is&#13;
calculated with respect to the height of the grid container; thus, a&#13;
container 500 pixels tall would yield a <code>content</code> row that’s 400 pixels&#13;
tall (because the percentage value of this row is <code>80%</code>). Doing this generally requires that you know ahead of time how tall the&#13;
grid container will be, which won’t always be the case.</p>&#13;
&#13;
<p>You might think we could just say <code>100%</code> and have it fill out the space,&#13;
but that doesn’t work, as <a data-type="xref" href="#exceeding_the_grid_container">Figure 12-10</a> illustrates: the <code>content</code> row track&#13;
will be as tall as the grid container itself, thus pushing the <code>footer</code>&#13;
row track out of the container altogether:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">col</code><code class="o">-</code><code class="n">a</code><code class="p">]</code> <code class="m">200px</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">b</code><code class="p">]</code> <code class="m">50%</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">c</code><code class="p">]</code> <code class="m">100px</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code> <code class="n">last</code><code class="p">];</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">masthead</code><code class="p">]</code> <code class="m">3em</code> <code class="p">[</code><code class="n">content</code><code class="p">]</code> <code class="m">100%</code> <code class="p">[</code><code class="n">footer</code><code class="p">]</code> <code class="m">2em</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code><code class="p">];</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="exceeding_the_grid_container">&#13;
<img alt="image" src="assets/css5_1210.png"/>&#13;
<h6><span class="label">Figure 12-10. </span>Exceeding the grid container</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">One <a data-primary="minmax() function" data-type="indexterm" id="idm45176074128656"/>way (not necessarily the best way) to handle this scenario is to&#13;
<em>minmax</em> the row’s value, telling the browser that you want the row no&#13;
shorter than one amount and no taller than another, leaving the browser to fill&#13;
in the exact value. This is done with the <code>minmax(a,b)</code> pattern, where&#13;
<code>a</code> is the minimum size and <code>b</code> is the maximum size:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">col</code><code class="o">-</code><code class="n">a</code><code class="p">]</code> <code class="m">200px</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">b</code><code class="p">]</code> <code class="m">50%</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">c</code><code class="p">]</code> <code class="m">100px</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code> <code class="n">last</code><code class="p">];</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">masthead</code><code class="p">]</code> <code class="m">3em</code> <code class="p">[</code><code class="n">content</code><code class="p">]</code> <code class="n">minmax</code><code class="p">(</code><code class="m">3em</code><code class="o">,</code><code class="m">100%</code><code class="p">)</code> <code class="p">[</code><code class="n">footer</code><code class="p">]</code> <code class="m">2em</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code><code class="p">];</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<p>This code indicates that the <code>content</code> row should never be shorter than&#13;
3 ems tall, and never taller than the grid container itself. This allows&#13;
the browser to bring up the size until it’s tall enough to fit the space&#13;
left over from the <code>masthead</code> and <code>footer</code> tracks, and no more.&#13;
It also allows the browser to make it shorter than that, as long as it’s&#13;
not shorter than <code>3em</code>, so this is not a guaranteed result. <a data-type="xref" href="#adapting_to_the_grid_container">Figure 12-11</a> shows one possible outcome of this approach.</p>&#13;
&#13;
<figure><div class="figure" id="adapting_to_the_grid_container">&#13;
<img alt="image" src="assets/css5_1211.png"/>&#13;
<h6><span class="label">Figure 12-11. </span>Adapting to the grid container</h6>&#13;
</div></figure>&#13;
&#13;
<p>In like fashion, with the same caveats, <code>minmax()</code> could have been&#13;
used to help the <code>col-b</code> column fill out the space across the grid&#13;
container. The thing to remember with <code>minmax()</code> is that if the <em>max</em> is&#13;
smaller than the <em>min</em>, the <em>max</em> value is thrown out and the <em>min</em>&#13;
value is used as a fixed-width track length. Thus, <code>minmax(100px, 2em)</code>&#13;
would resolve to <code>100px</code> for any font-size value smaller than <code>50px</code>.</p>&#13;
&#13;
<p>If the <a data-primary="calc() function" data-type="indexterm" id="idm45176074021664"/>vagueness of <code>minmax()</code>’s behavior unsettles you, CSS offers&#13;
alternatives to this scenario. We could also have used the <code>calc()</code>&#13;
value pattern to come up with a track’s height (or width). For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting">    <code class="k">grid-template-rows</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">start</code> <code class="n">masthead</code><code class="p">]</code> <code class="m">3em</code> <code class="p">[</code><code class="n">content</code><code class="p">]</code> <code class="n">calc</code><code class="p">(</code><code class="m">100%-5em</code><code class="p">)</code> <code class="p">[</code><code class="n">footer</code><code class="p">]</code> <code class="m">2em</code> <code class="p">[</code><code class="n">stop</code> <code class="n">end</code><code class="p">];</code></pre>&#13;
&#13;
<p>That would yield a <code>content</code> row exactly as tall as the grid container&#13;
minus the sum of the <code>masthead</code> and <code>footer</code> heights, as we saw in the&#13;
previous figure.</p>&#13;
&#13;
<p>That works as far as it goes, but is a somewhat fragile solution, since&#13;
any changes to the <code>masthead</code> or <code>footer</code> heights will also require an&#13;
adjustment of the calculation. It also becomes a lot more difficult (or&#13;
impossible) if you want more than one grid track to flex in this fashion. As&#13;
it happens, CSS has much more robust ways to deal with this sort of&#13;
situation, as you’ll see next.<a data-primary="" data-startref="ix_fix_width_grid_track" data-type="indexterm" id="idm45176073989584"/><a data-primary="" data-startref="ix_grid_line_fixw_track" data-type="indexterm" id="idm45176073988608"/><a data-primary="" data-startref="ix_grid_track_fixw" data-type="indexterm" id="idm45176073987664"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Flexible Grid Tracks" data-type="sect2"><div class="sect2" id="flexible-grid-tracks">&#13;
<h2>Using Flexible Grid Tracks</h2>&#13;
&#13;
<p>Thus far, <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="flexible tracks" data-type="indexterm" id="ix_grid_line_flex_track"/><a data-primary="grid layout" data-secondary="grid tracks" data-tertiary="flexible" data-type="indexterm" id="ix_grid_track_flex"/><a data-primary="flexible grid tracks" data-type="indexterm" id="ix_flex_grid_track"/>all our grid tracks have been <em>inflexible</em>—their size determined&#13;
by a length measure or the grid container’s dimensions, but unaffected&#13;
by any other considerations. <em>Flexible</em> grid tracks, by contrast, can be&#13;
based on the amount of space in the grid container not consumed by&#13;
inflexible tracks; or, alternatively, can be based on the actual content&#13;
of the entire grid track.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fractional units" data-type="sect3"><div class="sect3" id="fractional-units">&#13;
<h3>Fractional units</h3>&#13;
&#13;
<p>If you <a data-primary="units of measure" data-secondary="fractional" data-type="indexterm" id="ix_unit_fraction"/><a data-primary="fr (fractional) unit" data-type="indexterm" id="ix_fraction_unit"/>want to divide up whatever space is available by a certain fraction&#13;
and distribute the fractions to various columns, the <code>fr</code> unit is here&#13;
for you.  An <code>fr</code> is a flexible amount of space, representing a fraction of the <em>leftover</em> space in a grid.</p>&#13;
&#13;
<p>In the simplest case, you can divide up the whole container by equal&#13;
fractions. For example, if you want four columns, you could write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this very specific and limited case, that’s equivalent to saying the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">25%</code> <code class="m">25%</code> <code class="m">25%</code> <code class="m">25%</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#dividing_the_container">Figure 12-12</a> shows the result of either.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="dividing_the_container">&#13;
<img alt="image" src="assets/css5_1212.png"/>&#13;
<h6><span class="label">Figure 12-12. </span>Dividing the container into four columns</h6>&#13;
</div></figure>&#13;
&#13;
<p>This works because all of the grid container was “leftover space,” so all of it is available to be divided up by the <code>fr</code> lengths.  We’ll get into how that plays out with nonflexible grid tracks in just a bit.</p>&#13;
&#13;
<p>Going back to the previous example, suppose we want to add a fifth column and redistribute the column&#13;
sizes so they’re all still equal. If we used percentage values, we’d have to rewrite&#13;
the entire value to be five instances of <code>20%</code>. With <code>fr</code>, though, we&#13;
can just add another <code>1fr</code> to the value and have everything done for us&#13;
automatically:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code></pre>&#13;
&#13;
<p>The way <code>fr</code> units work is that all of the <code>fr</code> values are added&#13;
together, and all the leftover space in the grid is divided by that total. Then each&#13;
track gets the number of those fractions indicated by its <code>fr</code> value.</p>&#13;
&#13;
<p>In our first example, we had four <code>1fr</code> values, so their <code>1</code>’s were added together to get a&#13;
total of 4. The available space was then divided by 4, and each&#13;
column got one of those fourths. When we added a fifth <code>1fr</code>, the space&#13;
was divided by 5, and each column got one of those fifths.</p>&#13;
&#13;
<p>You are not required to always use <code>1</code> with your <code>fr</code> units! Suppose you&#13;
want to divide up a space into three columns, with the&#13;
middle column twice as wide as the other two. The code would look like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="m">2</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code></pre>&#13;
&#13;
<p>Again, these values are added up to get 4, and then we divide that 4 by 1 (representing the whole), so the base <code>fr</code> in this case&#13;
is <code>0.25</code>. The first and third tracks are thus 25% the width of the&#13;
container, whereas the middle column is half the container’s width,&#13;
because it’s <code>2fr</code>, which is twice <code>0.25</code>, or <code>0.5</code>, or 50%.</p>&#13;
&#13;
<p>You aren’t limited to integers, either. A recipe card for apple pie&#13;
could be laid out using these columns:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="m">3</code><code class="o">.</code><code class="m">14159</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code></pre>&#13;
&#13;
<p>We’ll leave the math on that one as an exercise for you. (Lucky&#13;
you! Just remember to start with <code>1 + 3.14159 + 1</code>, and you’ll have a&#13;
good head start.)</p>&#13;
&#13;
<p>This is a convenient way to slice up a container, but there’s&#13;
more here than just replacing percentages with something more intuitive.&#13;
Fractional units really come into their own when we have some fixed tracks and some flexible space. Consider, for&#13;
example, the following, which is illustrated in <a data-type="xref" href="#giving_the_center_column">Figure 12-13</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">15em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">10%</code><code class="p">;</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="giving_the_center_column">&#13;
<img alt="image" src="assets/css5_1213.png"/>&#13;
<h6><span class="label">Figure 12-13. </span>Giving the center column whatever’s available</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here, the browser assigns the first and third&#13;
tracks to their inflexible widths, and then gives whatever is left in&#13;
the grid container to the center track. For a 1,000-pixel-wide grid container whose <code>font-size</code>&#13;
is the usual browser default of <code>16px</code>, the first column will be 240&#13;
pixels wide and the third will be 100 pixels wide. That totals 340&#13;
pixels, leaving 660 pixels that aren’t assigned to the fixed tracks. The&#13;
fractional units total 1, so 660 is divided by 1, yielding 660&#13;
pixels, all of which are given to the single <code>1fr</code> track. If the grid&#13;
container’s width is increased to 1,400 pixels, the third column will be&#13;
140 pixels wide and the center column 1,020 pixels wide.</p>&#13;
&#13;
<p>Just like that, we have a mixture of fixed and flexible columns. We can&#13;
keep this going, splitting up any flexible space into as many&#13;
fractions as we like. Consider this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">width</code><code class="o">:</code> <code class="m">100em</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">15em</code> <code class="m">4</code><code class="o">.</code><code class="m">5</code><code class="n">fr</code> <code class="m">3</code><code class="n">fr</code> <code class="m">10%</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this case, the columns will be sized as shown in <a data-type="xref" href="#flexible_column_sizing">Figure 12-14</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="flexible_column_sizing">&#13;
<img alt="image" src="assets/css5_1214.png"/>&#13;
<h6><span class="label">Figure 12-14. </span>Flexible column sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>The widths of the columns will be, from left to right: 15, 45, 30, and 10 ems.  The first column gets its fixed width of <code>15em</code>.  The last column is <code>10%</code> of 100 em, which is 10 em.  That leaves 75 ems to distribute among the flexible columns.  The two added together total 7.5 fr.  For the wider column, 4.5 ÷ 7.5 equals 0.6, and that times 75 ems equals 45 ems.  Similarly, 3 ÷ 7.5 = 0.4, and that times 75 ems equals 30 ems.</p>&#13;
&#13;
<p>Yes, admittedly, we put a thumb on the scales for that example: the <code>fr</code>&#13;
total and <code>width</code> value were engineered to yield nice, round numbers for&#13;
the various columns. This was done purely to aid understanding. If&#13;
you want to work through the process with <span class="keep-together">less tidy</span> numbers, consider&#13;
using <code>92.5em</code> or <code>1234px</code> for the <code>width</code> value in the previous&#13;
example.</p>&#13;
&#13;
<p>If you want to define a<a data-primary="minmax() function" data-type="indexterm" id="ix_minmax_function"/> minimum or maximum size for a given&#13;
track, <code>minmax()</code> can be quite useful. To extend the&#13;
previous example, suppose the third column should never be less than 5 ems&#13;
wide, no matter what. The CSS would then be as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">15em</code> <code class="m">4</code><code class="o">.</code><code class="m">5</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">5em</code><code class="o">,</code><code class="m">3</code><code class="n">fr</code><code class="p">)</code> <code class="m">10%</code><code class="p">;</code></pre>&#13;
&#13;
<p>Now the layout will have two flexible columns at its middle, down to the&#13;
point that the third column reaches <code>5em</code> wide. Below that point, the&#13;
layout will have three inflexible columns (<code>15em</code>, <code>5em</code>, and <code>10%</code> wide,&#13;
respectively) and a single flexible column that will get all the&#13;
leftover space, if there is any. Once you run the math, it turns out&#13;
that up to <code>30.5556em</code> wide, the grid will have one flexible column. Above&#13;
that width, there will be two flexible columns.</p>&#13;
&#13;
<p>You might think this works the other way—for example, if you wanted&#13;
to make a column track flexible up to a certain point, and then become&#13;
fixed after, you would declare a minimum <code>fr</code> value.&#13;
This won’t work, sadly, because <code>fr</code> units are not allowed in&#13;
the <em>min</em> position of a <code>minmax()</code> expression. So any <code>fr</code> value  provided&#13;
as a minimum will invalidate the entire declaration.</p>&#13;
&#13;
<p>Speaking of setting to 0, let’s look at a&#13;
minimum value explicitly set to <code>0</code>, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">15em</code> <code class="m">1</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">500px</code><code class="p">)</code> <code class="m">10%</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#minmaxed_column_sizing">Figure 12-15</a> illustrates the narrowest grid width at which the third column&#13;
can remain 500 pixels wide. Any narrower, and the <code>minmax</code>-ed column will&#13;
be narrower than 500 pixels. Any wider, and the second column, the <code>fr</code> column,&#13;
will grow beyond zero width while the third column stays at 500 pixels wide.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="minmaxed_column_sizing">&#13;
<img alt="image" src="assets/css5_1215.png"/>&#13;
<h6><span class="label">Figure 12-15. </span>Minmaxed column sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">If you look closely, you’ll see the <code>1fr</code> label next to the boundary&#13;
between the <code>15em</code> and <code>minmax(0,500px)</code> columns. That’s there because the <code>1fr</code>&#13;
is placed with its left edge on the second-column grid line, and has no width,&#13;
because there is no space left to flex. Similarly, the <code>minmax</code> is placed&#13;
on the third-column grid line. It’s just that, in this specific situation, the&#13;
second- and third-column grid lines are in the same place (which is why the&#13;
<code>1fr</code> column has zero width).</p>&#13;
&#13;
<p>If you ever run into a case where the minimum value is greater than the&#13;
maximum value, the whole thing is replaced with the minimum value.&#13;
Thus, <code class="keep-together">minmax(</code><code>500px,200px)</code> would be treated as a simple <code>500px</code>. You&#13;
probably wouldn’t do this so obviously, but this feature is useful when&#13;
mixing things like percentages and fractions. Thus, you could have a&#13;
column that’s <code>minmax(10%,1fr)</code> that would be flexible down to the point&#13;
where the flexible column was less than 10% of the grid container’s size,&#13;
at which point it would stick at <code>10%</code>.</p>&#13;
&#13;
<p>Fractional units and minmaxes are usable on rows just as easily as&#13;
columns; it’s just that rows are rarely sized in this way. You could&#13;
easily imagine setting up a layout in which the masthead and footer are&#13;
fixed tracks, while the content is flexible down to a certain point.&#13;
That might look something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">3em</code> <code class="n">minmax</code><code class="p">(</code><code class="m">5em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;</code></pre>&#13;
&#13;
<p>That works OK, but it’s a lot more likely that you’ll want to size&#13;
that row by the height of its content, not some fraction of the grid&#13;
container’s height. The next section shows exactly how to make that&#13;
happen.<a data-primary="" data-startref="ix_fraction_unit" data-type="indexterm" id="idm45176073599472"/><a data-primary="" data-startref="ix_unit_fraction" data-type="indexterm" id="idm45176073598624"/><a data-primary="" data-startref="ix_minmax_func" data-type="indexterm" id="idm45176073597712"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Content-aware tracks" data-type="sect3"><div class="sect3" id="content-aware-tracks">&#13;
<h3>Content-aware tracks</h3>&#13;
&#13;
<p>It’s one thing to set up <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="content-aware" data-type="indexterm" id="ix_grid_line_cont_aware"/><a data-primary="content-aware grid tracks" data-type="indexterm" id="ix_cont_aware_track"/>grid tracks that take up fractions of the space&#13;
available to them, or that occupy fixed amounts of space. But what if&#13;
you want to line up a bunch of pieces of a page and can’t guarantee&#13;
how wide or tall they might get? This is where <code>min-content</code> and&#13;
<code>max-content</code> come in.  (See <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a> for a detailed explanation of these keywords.)</p>&#13;
&#13;
<p>What’s so powerful about using these sizing keywords in CSS Grid is that they apply to the&#13;
entire grid track they define. For example, if you size a column to be&#13;
<code>max-content</code>, the entire column track will be as wide as the&#13;
widest content within it. This is easiest to illustrate with a grid of&#13;
images (12, in this case) with the grid declared as follows and&#13;
shown in <a data-type="xref" href="#sizing_grid_tracks_by_content">Figure 12-16</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sizing_grid_tracks_by_content">&#13;
<img alt="css5 1216" src="assets/css5_1216.png"/>&#13;
<h6><span class="label">Figure 12-16. </span>Sizing grid tracks by content</h6>&#13;
</div></figure>&#13;
&#13;
<p>Looking at the columns, we can see that each column track is as wide as&#13;
the widest image within that track. Where a bunch of portrait images&#13;
happen to line up, the column is more narrow; where a landscape image&#13;
shows up, the column is made wide enough to fit it. The same thing&#13;
happens with the rows. Each row is as tall as the tallest image within&#13;
it, so if a row happens to have all short images, the row is also&#13;
short.</p>&#13;
&#13;
<p>The advantage here is that this works for any sort of content, no matter&#13;
what’s in there. Say we add captions to the photos. All of the&#13;
columns and rows will resize themselves as needed to handle both text&#13;
and images, as shown in <a data-type="xref" href="#sizing_grid_tracks_around_mixed_content">Figure 12-17</a>.</p>&#13;
&#13;
<p>This isn’t a <a data-primary="max-content keyword" data-type="indexterm" id="idm45176073521760"/>full-fledged design—the images are out of place,&#13;
and there’s no attempt to constrain the caption widths. In fact, that’s&#13;
exactly what we should expect from <code>max-content</code> values for the column&#13;
widths. Since it means “make this column wide enough to hold all its&#13;
content,” that’s what we get.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sizing_grid_tracks_around_mixed_content">&#13;
<img alt="image" src="assets/css5_1217.png"/>&#13;
<h6><span class="label">Figure 12-17. </span>Sizing grid tracks around mixed content</h6>&#13;
</div></figure>&#13;
&#13;
<p>What’s <a data-primary="minmax() function" data-type="indexterm" id="idm45176073490656"/>important to realize is that this will hold even if the grid&#13;
tracks have to spill out of the grid container. Even if&#13;
we’d assigned something like <code>width: 250px</code> to the grid container, the&#13;
images and captions would be laid out just the same. That’s why things&#13;
like <code>max-content</code> tend to appear in <code>minmax()</code> statements. Consider the&#13;
following, where grids with and without <code>minmax()</code> appear side by side.&#13;
In both cases, the grid container is represented by a shaded&#13;
background (see <a data-type="xref" href="#sizing_grid_tracks_minmax">Figure 12-18</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#g1</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="nf">#g2</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">minmax</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">)</code> <code class="n">minmax</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">)</code>&#13;
          <code class="n">minmax</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">)</code> <code class="n">minmax</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">);</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sizing_grid_tracks_minmax">&#13;
<img alt="image" src="assets/css5_1218.png"/>&#13;
<h6><span class="label">Figure 12-18. </span>Sizing grid tracks with and without <code>minmax()</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first instance, the grid items completely contain their contents,&#13;
but they spill out of the grid container. In the second, <code>minmax()</code>&#13;
directs the browser to keep <span class="keep-together">the columns</span> within the range of <code>0</code> and&#13;
<code>max-content</code>, so they’ll all be fitted into the grid container if&#13;
possible. A variant would be to declare&#13;
<code>minmax(min-content, max-content)</code>, which can lead to a slightly different&#13;
result than the <code>0, max-content</code> approach.</p>&#13;
&#13;
<p>The reason that some images are overflowing their cells in the second example is that the tracks have been fitted into the grid container according to <code>minmax(0,max-content)</code>.  They can’t reach <code>max-content</code> in every track, but they can get as close as possible while all still fitting into the grid container.  Where the contents are wider than the track, they just stick out of it, overlapping other tracks.  This is standard grid behavior.</p>&#13;
&#13;
<p>If you’re <a data-primary="min-content keyword" data-type="indexterm" id="idm45176073381616"/>wondering what happens if you <code>min-content</code> both the columns&#13;
and the rows, it’s pretty much the same as applying <code>min-content</code> to the&#13;
columns and leaving the rows alone. This happens because the grid&#13;
specification directs browsers to resolve column sizing first, and row&#13;
sizing after that.</p>&#13;
&#13;
<p>One more keyword you can use with grid track sizing is&#13;
<code>auto</code>, which also happens to be the default value for any grid track’s width.&#13;
As a minimum, it’s treated as the minimum size for the grid&#13;
item, as defined by <code>min-width</code> or <code>min-height</code>. As a maximum, it’s&#13;
treated the same as <code>max-content</code>. You might think this means it can&#13;
be used only in <code>minmax()</code> statements, but this is not the case. You can&#13;
use it anywhere, and it will take on either a minimum or maximum role.&#13;
Which one it takes on depends on the other track values around it, in&#13;
ways that are frankly too complicated to get into here. As with so many&#13;
other aspects of CSS, using <code>auto</code> is essentially letting the browser do&#13;
what it wants. Sometimes that’s fine, but in general you’ll probably&#13;
want to avoid it.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There is a caveat to that last statement: <code>auto</code> values allow&#13;
grid items to be resized by the <code>align-content</code> and <code>justify-content</code>&#13;
properties, a topic we’ll discuss in <a data-type="xref" href="#aligning-and-grids">“Setting Alignment in Grids”</a>. Since <code>auto</code>&#13;
values are the only track-sizing values that permit this, there may be&#13;
very good reasons to use <code>auto</code> after all.<a data-primary="" data-startref="ix_flex_grid_track" data-type="indexterm" id="idm45176073371808"/><a data-primary="" data-startref="ix_grid_line_flex_track" data-type="indexterm" id="idm45176073370800"/><a data-primary="" data-startref="ix_grid_track_flex" data-type="indexterm" id="idm45176073369856"/><a data-primary="" data-startref="ix_cont_aware_track" data-type="indexterm" id="idm45176073368912"/><a data-primary="" data-startref="ix_grid_line_cont_aware" data-type="indexterm" id="idm45176073367968"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fitting Track Contents" data-type="sect2"><div class="sect2" id="idm45176073978192">&#13;
<h2>Fitting Track Contents</h2>&#13;
&#13;
<p>In <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="fitting content to" data-type="indexterm" id="ix_grid_line_fit_cont"/><a data-primary="fit-content() function" data-type="indexterm" id="ix_fit_content"/>addition to the <code>min-content</code> and <code>max-content</code> keywords, a <code>fit-content()</code> function allows you to more compactly express certain types of sizing patterns.  It’s a bit complicated to decipher, but the effort is worth it:</p>&#13;
&#13;
<p>The <code>fit-content()</code> function accepts a &lt;<em><code>length</code></em>&gt; or a &lt;<em><code>percentage</code></em>&gt; as its argument, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code>  <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="n">fit</code><code class="o">-</code><code class="n">content</code><code class="p">(</code><code class="m">150px</code><code class="p">)</code> <code class="m">2</code><code class="n">fr</code><code class="p">;}</code>&#13;
<code class="nf">#grid2</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">2</code><code class="n">fr</code> <code class="n">fit</code><code class="o">-</code><code class="n">content</code><code class="p">(</code><code class="m">50%</code><code class="p">)</code> <code class="m">1</code><code class="n">fr</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Before we explore what that means, let’s ponder the pseudo-formula given by the &#13;
<span class="keep-together">specification:</span></p>&#13;
<ul class="simplelist">&#13;
<li>fit-content(<em>argument</em>) =&gt; min(max-content, max(min-content, <em>argument</em>))</li>&#13;
</ul>&#13;
&#13;
<p>This means, <a data-primary="minmax() function" data-type="indexterm" id="ix_minmax_func2"/>essentially, “figure out which is greater, the <code>min-content</code> sizing or the supplied argument, and then take that result and choose whichever is smaller, that result or the <code>max-content</code> size.”  Which is probably confusing!.</p>&#13;
&#13;
<p>We feel that a better way of phrasing it is “<code>fit-content(<em>argument</em>)</code> is equivalent to <code>minmax(min-content,max-content)</code>, except that the value given as an argument sets an upper limit, similar to <code>max-width</code> or <code>max-height</code>.”  Let’s consider this example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">fit</code><code class="o">-</code><code class="n">content</code><code class="p">(</code><code class="m">50ch</code><code class="p">);}</code></pre>&#13;
&#13;
<p>The argument here is <code>50ch</code>, or the same width as 50 zero (<code>0</code>) characters side by side.  So we’re setting up a single column that’s having its content fit to that measure.</p>&#13;
&#13;
<p>For the initial case, assume the content is only 29 characters long, measuring 29 ch (because it’s in a monospace font).  That means the value of <code>max-content</code> is <code>29ch</code>, and the column will be only that wide, because it minimizes to that measure—<code>29ch</code> is smaller than whatever the maximum of <code>50ch</code> and <code>min-content</code> turns out to be.</p>&#13;
&#13;
<p>Now, let’s assume a bunch of text content is added so that there are 256 characters, thus measuring <code>256ch</code> in width (without any line wrapping).  That means <code>max-content</code> evaluates to <code>256ch</code>.  This is well beyond the <code>50ch</code> argument, so the column is constrained to be the larger of <code>min-content</code> and <code>50ch</code>, which is <code>50ch</code>.</p>&#13;
&#13;
<p>As further illustration, consider the results of the following, as shown in <a data-type="xref" href="#sizing_grid_tracks_fit_content">Figure 12-19</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#thefollowing</code>  <code class="p">{</code>&#13;
    <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
        <code class="n">fit</code><code class="o">-</code><code class="n">content</code><code class="p">(</code><code class="m">50ch</code><code class="p">)</code> <code class="n">fit</code><code class="o">-</code><code class="n">content</code><code class="p">(</code><code class="m">50ch</code><code class="p">)</code> <code class="n">fit</code><code class="o">-</code><code class="n">content</code><code class="p">(</code><code class="m">50ch</code><code class="p">);</code>&#13;
    <code class="k">font-family</code><code class="o">:</code> <code class="nb">monospace</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sizing_grid_tracks_fit_content">&#13;
<img alt="image" src="assets/css5_1219.png"/>&#13;
<h6><span class="label">Figure 12-19. </span>Sizing grid tracks with <code>fit-content()</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice the first column is narrower than the other two.  Its <code>29ch</code> content minimizes to that size.  The other two columns have more content than will fit into <code>50ch</code>, so they line-wrap, because their width has been limited to <code>50ch</code>.</p>&#13;
&#13;
<p>Now let’s consider what happens if an image is added to the second column.  We’ll make it <code>500px</code> wide, which happens to be wider than <code>50ch</code> in this instance.  For that column, the maximum of <code>min-content</code> and <code>50ch</code> is determined.  As we said, the larger value there is <code>min-content</code>, which is to say <code>500px</code> (the width of the image).  Then the <em>minimum</em> of <code>500px</code> and <code>max-content</code> is determined.  The text, rendered as a single line, would go on past <code>500px</code>, so the minimum is <code>500px</code>.  Thus, the second column is now 500 pixels wide.  This is depicted in <a data-type="xref" href="#sizing_grid_tracks_fit_content_wide">Figure 12-20</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sizing_grid_tracks_fit_content_wide">&#13;
<img alt="image" src="assets/css5_1220.png"/>&#13;
<h6><span class="label">Figure 12-20. </span>Fitting to wide content</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you compare Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#sizing_grid_tracks_fit_content">12-19</a> to <a data-type="xref" data-xrefstyle="select:labelnumber" href="#sizing_grid_tracks_fit_content_wide">12-20</a>, you’ll see that the text in the second column wraps at a different point, due to the change in column width.  But also compare the text in the third column.  It, too, has different line wraps.</p>&#13;
&#13;
<p>That happens because after the first and second columns are sized, the third column has a bit less than <code>50ch</code> of space in which to be sized. The <code>fit-content(50ch)</code> function still does its thing, but here, it does so within the space available to it.  Remember, the <code>50ch</code> argument is an upper bound, not a fixed size.</p>&#13;
&#13;
<p>This is one of the great advantages of <code>fit-content()</code> over the less flexible <code>minmax()</code>.  It allows you to shrink tracks to their minimum <code>content-size</code> when there isn’t much content, while still setting an upper bound on the track size when there’s a lot of content.<a data-primary="" data-startref="ix_fit_content" data-type="indexterm" id="idm45176073160160"/><a data-primary="" data-startref="ix_minmax_func2" data-type="indexterm" id="idm45176073159184"/><a data-primary="" data-startref="ix_grid_line_fit_cont" data-type="indexterm" id="idm45176073158240"/></p>&#13;
&#13;
<p>You may have been wondering about the&#13;
repetitive grid template values in previous examples, and what happens if you need more than&#13;
three or four grid tracks. Will you have to write out every single track&#13;
width individually? Indeed not, as you’ll see in the &#13;
<span class="keep-together">next section.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Repeating Grid Tracks" data-type="sect2"><div class="sect2" id="repeating-grid-tracks">&#13;
<h2>Repeating Grid Tracks</h2>&#13;
&#13;
<p>If you <a data-primary="repeating elements" data-secondary="grid tracks" data-type="indexterm" id="ix_repeat_elem_track"/><a data-primary="repeat() function" data-type="indexterm" id="ix_repeat_func"/><a data-primary="grid layout" data-secondary="grid lines" data-tertiary="repeating" data-type="indexterm" id="ix_grid_line_repeat"/>want to set up a bunch of grid tracks of the same size,&#13;
you probably don’t want to have to type out every single one of them.&#13;
Fortunately, <code>repeat()</code> is here to make sure you don’t have to.</p>&#13;
&#13;
<p>Let’s say we want to set up a column grid line every 5 ems and have&#13;
10 column tracks. Here’s how to do that:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">10</code><code class="o">,</code> <code class="m">5em</code><code class="p">);}</code></pre>&#13;
&#13;
<p>That’s it. Done. Ten column tracks, each one <code>5em</code> wide, for a total of&#13;
50 ems of column tracks. It sure beats typing <code>5em</code> 10 times!</p>&#13;
&#13;
<p>Any track-sizing value can be used in a repeat, from <code>min-content</code> and&#13;
<code>max-content</code> to <code>fr</code> values to <code>auto</code>, and so on, and you can put&#13;
together more than one sizing value. Suppose we want to define a column&#13;
structure such that there’s a <code>2em</code> track, then a <code>1fr</code> track, and then&#13;
another <code>1fr</code> track—and, furthermore, we want to repeat that pattern&#13;
three times. Here’s how to do that, with the result shown in <a data-type="xref" href="#repeating_a_track_pattern">Figure 12-21</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="m">2em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">);}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="repeating_a_track_pattern">&#13;
<img alt="image" src="assets/css5_1221.png"/>&#13;
<h6><span class="label">Figure 12-21. </span>Repeating a track pattern</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that the last-column track is a <code>1fr</code> track, whereas the first-column track is <code>2em</code> wide. This is an effect of the way the <code>repeat()</code>&#13;
was written. It’s easy to add another <code>2em</code> track at the end, in order&#13;
to balance things out, by adding a <code>2em</code> after the <code>repeat()</code> &#13;
<span class="keep-together">expression:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="m">2em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This highlights the fact that&#13;
<code>repeat</code> can be combined with any other track-sizing values—even other&#13;
repeats—in the construction of a grid. The one thing you <em>can’t</em> do is&#13;
nest a repeat inside another repeat.</p>&#13;
&#13;
<p>Other than that, just about anything goes within a <code>repeat()</code> value.&#13;
Here’s an example taken straight from the grid specification:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code>&#13;
    <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">4</code><code class="o">,</code> <code class="m">10px</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">250px</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">end</code><code class="p">])</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In this case, there are four repetitions of a 10-pixel track, a named&#13;
grid line, a 250-pixel track, and then another named grid line. Then,&#13;
after the four repetitions, a final 10-pixel column track. Yes, that&#13;
means there will be four column grid lines named <code>col-start</code>, and&#13;
another four named <code>col-end</code>, as shown in <a data-type="xref" href="#repeated_columns_w_named_grid_lines">Figure 12-22</a>. This is acceptable; grid-line names are not required to be unique.</p>&#13;
&#13;
<figure><div class="figure" id="repeated_columns_w_named_grid_lines">&#13;
<img alt="image" src="assets/css5_1222.png"/>&#13;
<h6><span class="label">Figure 12-22. </span>Repeated columns with named grid lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>One thing to remember, if you’re going to repeat named lines, is that if&#13;
you place two named lines next to each other, they’ll be merged into a&#13;
single, double-named grid line. In other words, the following two&#13;
declarations are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="p">[</code><code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code><code class="p">]);</code>&#13;
<code class="k">grid-template-rows</code><code class="o">:</code> <code class="p">[</code><code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code> <code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="nb">top</code> <code class="n">bottom</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code><code class="p">];</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’re <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="naming" data-type="indexterm" id="idm45176072922160"/>concerned about having the same name applied to&#13;
multiple grid lines, don’t be: there’s nothing preventing it, and it can&#13;
even be helpful in some cases. We’ll explore ways to handle such&#13;
situations in <a data-type="xref" href="#using-column-and-row-lines">“Using Column and Row Lines”</a>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Autofilling tracks" data-type="sect3"><div class="sect3" id="auto-filling-tracks">&#13;
<h3>Autofilling tracks</h3>&#13;
&#13;
<p>CSS <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="autofilling tracks" data-type="indexterm" id="ix_grid_line_autofill_track"/><a data-primary="grid layout" data-secondary="grid tracks" data-tertiary="autofilling" data-type="indexterm" id="ix_grid_track_autofill"/><a data-primary="autofilling grid tracks" data-type="indexterm" id="ix_autofill_track"/>provides a way to set up a simple pattern and repeat it until the&#13;
grid container is filled. This doesn’t have quite the same complexity as&#13;
regular <code>repeat()</code>—at least not yet—but it can still be pretty handy.</p>&#13;
&#13;
<p>For example, suppose we want to have the previous row pattern repeat&#13;
as many times as the grid container will comfortably accept:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="nb">auto</code><code class="o">-</code><code class="n">fill</code><code class="o">,</code> <code class="p">[</code><code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code><code class="p">]);</code></pre>&#13;
&#13;
<p>That will define a row line every 5 ems until there’s no more room. Thus,&#13;
for a grid &#13;
<span class="keep-together">container</span> that’s 11 ems tall, the following is equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-rows</code><code class="o">:</code> <code class="p">[</code><code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code> <code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code><code class="p">];</code></pre>&#13;
&#13;
<p>If the grid container’s height is increased past 15 ems, but is less than&#13;
20 ems, then this is an equivalent declaration:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-rows</code><code class="o">:</code> <code class="p">[</code><code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code> <code class="nb">top</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="nb">top</code> <code class="n">bottom</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">bottom</code><code class="p">];</code></pre>&#13;
&#13;
<p>See <a data-type="xref" href="#auto-fill-rows-three-heights">Figure 12-23</a> for examples of the autofilled rows at three grid container heights.</p>&#13;
&#13;
<figure><div class="figure" id="auto-fill-rows-three-heights">&#13;
<img alt="image" src="assets/css5_1223.png"/>&#13;
<h6><span class="label">Figure 12-23. </span>Autofilling rows at three heights</h6>&#13;
</div></figure>&#13;
&#13;
<p>One limitation with auto-repeating is that it can take only an optional&#13;
grid-line name, a fixed track size, and another optional grid-line name.&#13;
So <code>[top] 5em [bottom]</code> represents about the maximum value pattern. You&#13;
can drop the named lines and just repeat <code>5em</code>, or just drop one of the&#13;
names.</p>&#13;
&#13;
<p>It’s not possible to auto-repeat multiple fixed track sizes, nor can&#13;
you auto-repeat flexible track sizes.&#13;
Similarly, you can’t use intrinsic track sizes with auto-repeated&#13;
tracks, so values such as <code>min-content</code> and <code>max-content</code> can’t be&#13;
put into an auto-repeated pattern.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You <a data-primary="column-gap property" data-type="indexterm" id="idm45176072777024"/><a data-primary="gap property" data-type="indexterm" id="idm45176072776288"/><a data-primary="row-gap property" data-type="indexterm" id="idm45176072775616"/><a data-primary="gutter space" data-secondary="between grid columns" data-type="indexterm" id="idm45176072774944"/>might wish you could auto-repeat multiple track sizes in&#13;
order to define gutters around your content columns. This is&#13;
usually unnecessary because of the properties <code>row-gap</code> and <code>column-gap</code>&#13;
and their shorthand <code>gap</code>,&#13;
which are covered in <a data-type="xref" href="ch11.html#flexbox">Chapter 11</a> but also apply in CSS Grid.</p>&#13;
</div>&#13;
&#13;
<p>Furthermore, you can have only one auto-repeat in a given track&#13;
template. Thus, the following would <em>not</em> be permissible:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="nb">auto</code><code class="o">-</code><code class="n">fill</code><code class="o">,</code> <code class="m">4em</code><code class="p">)</code> <code class="nb">repeat</code><code class="p">(</code><code class="nb">auto</code><code class="o">-</code><code class="n">fill</code><code class="o">,</code> <code class="m">100px</code><code class="p">);</code></pre>&#13;
&#13;
<p>However, you <em>can</em> combine fixed-repeat tracks with autofill tracks.&#13;
For example, you could start with three wide columns, and then fill the&#13;
rest of the grid container with narrow tracks (assuming there’s space&#13;
for them). That would look something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="m">20em</code><code class="p">)</code> <code class="nb">repeat</code><code class="p">(</code><code class="nb">auto</code><code class="o">-</code><code class="n">fill</code><code class="o">,</code> <code class="m">2em</code><code class="p">);</code></pre>&#13;
&#13;
<p>You can flip that around too:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="nb">auto</code><code class="o">-</code><code class="n">fill</code><code class="o">,</code> <code class="m">2em</code><code class="p">)</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="m">20em</code><code class="p">);</code></pre>&#13;
&#13;
<p>That works because the grid layout algorithm assigns space to the fixed&#13;
tracks first, and then fills up whatever space is left with&#13;
auto-repeated tracks. The end result is to have one or&#13;
more autofilled 2-em tracks, and then three 20-em tracks.  <a data-type="xref" href="#auto-fill-columns-with-fixed">Figure 12-24</a> shows two examples.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="auto-fill-columns-with-fixed">&#13;
<img alt="image" src="assets/css5_1224.png"/>&#13;
<h6><span class="label">Figure 12-24. </span>Autofilling columns next to fixed columns</h6>&#13;
</div></figure>&#13;
&#13;
<p>With <code>auto-fill</code>, you will always get at least one repetition of the track template, even if it&#13;
won’t fit into the grid container for some reason. You’ll also get as&#13;
many tracks as will fit, even if some of the tracks don’t have content. As an example, suppose you set up an autofill that places five&#13;
columns, but only the first three actually end up with grid items&#13;
in them. The other two would remain in place, holding open layout space.</p>&#13;
&#13;
<p>If you use <code>auto-fit</code>, on the other hand, tracks that don’t&#13;
contain any grid items will be compressed to a width of zero,&#13;
though they (and their associated grid lines) remain part of the grid.&#13;
Otherwise, <code>auto-fit</code> acts the same as <code>auto-fill</code>. Suppose the <span class="keep-together">following:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="nb">auto-fit</code><code class="o">,</code> <code class="m">20em</code><code class="p">);</code></pre>&#13;
&#13;
<p>If the grid container has room for five column tracks (i.e., it’s&#13;
more than 100 ems wide), but two tracks don’t have any grid items to go&#13;
into them, those empty grid tracks will be dropped, leaving the three&#13;
column tracks that <em>do</em> contain grid items. The leftover space is handled&#13;
in accordance with the values of <code>align-content</code> and <code>justify-content</code>&#13;
(discussed in <a data-type="xref" href="#aligning-and-grids">“Setting Alignment in Grids”</a>).  A simple comparison of <code>auto-fill</code> and <code>auto-fit</code> is shown in <a data-type="xref" href="#auto-fill-and-auto-fit">Figure 12-25</a>, where the numbers in the colored boxes indicate the grid-column number to which they’ve been attached.<a data-primary="" data-startref="ix_grid_temp_col_prop" data-type="indexterm" id="idm45176072608368"/><a data-primary="" data-startref="ix_grid_temp_row_prop" data-type="indexterm" id="idm45176072607424"/><a data-primary="" data-startref="ix_grid_line_repeat" data-type="indexterm" id="idm45176072606480"/><a data-primary="" data-startref="ix_repeat_func" data-type="indexterm" id="idm45176072605536"/><a data-primary="" data-startref="ix_repeat_elem_track" data-type="indexterm" id="idm45176072604592"/><a data-primary="" data-startref="ix_autofill_track" data-type="indexterm" id="idm45176072603648"/><a data-primary="" data-startref="ix_grid_line_autofill_track" data-type="indexterm" id="idm45176072602704"/><a data-primary="" data-startref="ix_grid_track_autofill" data-type="indexterm" id="idm45176072584400"/></p>&#13;
&#13;
<figure><div class="figure" id="auto-fill-and-auto-fit">&#13;
<img alt="image" src="assets/css5_1225.png"/>&#13;
<h6><span class="label">Figure 12-25. </span>Using <code>auto-fill</code> versus <code>auto-fit</code></h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Grid Areas" data-type="sect2"><div class="sect2" id="grid-areas">&#13;
<h2>Defining Grid Areas</h2>&#13;
&#13;
<p>Maybe you’d <a data-primary="grid-template-areas property" data-type="indexterm" id="ix_grid_temp_area_prop"/><a data-primary="grid layout" data-secondary="grid areas" data-type="indexterm" id="ix_grid_area_ch12"/>rather just “draw a picture” of your grid—both because it’s fun to do and because the picture can serve as self-documenting code.  It turns out you can more or less do exactly that with the <code>grid-template-areas</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176072576848">&#13;
<h1>grid-template-areas</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | &lt;<em><code>string</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>We could go through a wordy description of how this works, but it’s a&#13;
lot more fun to just show it. The following rule has the result shown in&#13;
<a data-type="xref" href="#simple_set_of_grid_areas">Figure 12-26</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"h h h h"</code>&#13;
        <code class="s2">"l c c r"</code>&#13;
        <code class="s2">"l f f f"</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="simple_set_of_grid_areas">&#13;
<img alt="image" src="assets/css5_1226.png"/>&#13;
<h6><span class="label">Figure 12-26. </span>A simple set of grid areas</h6>&#13;
</div></figure>&#13;
&#13;
<p>That’s right: the letters in the string values are used to define how&#13;
areas of the grid are shaped. Really! And you aren’t even restricted to&#13;
single letters! For example, we could expand the previous example&#13;
like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header     header    header    header"</code>&#13;
        <code class="s2">"leftside   content   content   rightside"</code>&#13;
        <code class="s2">"leftside   footer    footer    footer"</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The grid layout is the same as that shown in <a data-type="xref" href="#simple_set_of_grid_areas">Figure 12-26</a>, though the&#13;
name of each area would be different (e.g., <code>footer</code> instead of <code>f</code>).</p>&#13;
&#13;
<p>In defining template areas, the whitespace is collapsed, so you can use&#13;
it (as was done in the previous example) to visually line up columns of&#13;
names in the value of <code>grid-template-areas</code>. You can line up the names with&#13;
spaces or tabs, whichever will annoy your coworkers the most. Or you&#13;
can just use a single space to separate each identifier, and not worry&#13;
about the names lining up with one another. You don’t even have to&#13;
line-break between strings; the following works just as well as a&#13;
pretty-printed version:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-areas</code><code class="o">:</code> <code class="s2">"h h h h"</code> <code class="s2">"l c c r"</code> <code class="s2">"l f f f"</code><code class="p">;</code></pre>&#13;
&#13;
<p>What you can’t do is merge those separate strings into a single string&#13;
and have it mean the same thing. Every new string (as delimited by the quote marks) defines a new row in the grid. Thus the previous&#13;
example, like the examples before it, defines three rows. Say we merge&#13;
them all into a single string, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-areas</code><code class="o">:</code>&#13;
    <code class="s2">"h h h h</code>&#13;
<code class="s2">     l c c r</code>&#13;
<code class="s2">     l f f f"</code><code class="p">;</code></pre>&#13;
&#13;
<p>Then we’d have a single row of 12 columns, starting with the&#13;
four-column area <code>h</code> and ending with the three-column area <code>f</code>. The&#13;
line breaks aren’t significant in any way, except as whitespace that&#13;
separates one identifier from another.</p>&#13;
&#13;
<p>If you look at these values closely, you may come to realize that each&#13;
individual identifier represents a grid cell. Let’s bring back our first example&#13;
from this section, and consider the result shown in <a data-type="xref" href="#grid_cells_with_ids">Figure 12-27</a>, which uses Firefox’s Grid Inspector to label each cell:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"h h h h"</code>&#13;
        <code class="s2">"l c c r"</code>&#13;
        <code class="s2">"l f f f"</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grid_cells_with_ids">&#13;
<img alt="image" src="assets/css5_1227.png"/>&#13;
<h6><span class="label">Figure 12-27. </span>Grid cells with their grid area identifiers</h6>&#13;
</div></figure>&#13;
&#13;
<p>This <a data-primary="grid cells" data-type="indexterm" id="idm45176072416720"/>is exactly the same layout result as in <a data-type="xref" href="#simple_set_of_grid_areas">Figure 12-26</a>, but here, we’ve shown how each&#13;
grid identifier in the <code>grid-template-areas</code> value corresponds to a grid&#13;
cell. Once all the cells are identified, the browser merges any adjacent&#13;
cells with the same name into a single area that encloses all of&#13;
them—as long as they describe a rectangular shape! If you try to set up&#13;
more complicated areas, the entire template is invalid. Thus, the&#13;
following would result in no grid areas being defined:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"h h h h"</code>&#13;
        <code class="s2">"l c c r"</code>&#13;
        <code class="s2">"l l f f"</code><code class="p">;}</code></pre>&#13;
&#13;
<p>See how <code>l</code> outlines an <em>L</em> shape? That humble change causes the entire&#13;
<code>grid-template-areas</code> value to be dropped as invalid. A future version&#13;
of grid layout may allow for nonrectangular shapes, but for now, this&#13;
limitation exists.</p>&#13;
&#13;
<p>If you want to define only some grid cells to&#13;
be part of grid areas but leave others unlabeled, you can use one or&#13;
more <code>.</code> characters to fill in for those unnamed cells. Let’s say you&#13;
just want to define some header, footer, and sidebar areas, and leave&#13;
the rest unnamed. That would look something like this, with the result&#13;
shown in <a data-type="xref" href="#grid_with_unnamed_cells">Figure 12-28</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header  header  header  header"</code>&#13;
        <code class="s2">"left    ...     ...     right"</code>&#13;
        <code class="s2">"footer  footer  footer  footer"</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grid_with_unnamed_cells">&#13;
<img alt="image" src="assets/css5_1228.png"/>&#13;
<h6><span class="label">Figure 12-28. </span>A grid with some unnamed grid cells</h6>&#13;
</div></figure>&#13;
&#13;
<p>The two <a data-primary="null cell tokens, grid layout" data-type="indexterm" id="idm45176072336800"/>cells in the center of the grid are not part of a named&#13;
area, having been represented in the template by <em>null cell tokens</em> (the&#13;
<code>.</code> identifiers). Where each of those <code>...</code> sequences appears, we&#13;
could have used one or more null tokens—so <code>left . . right</code> or&#13;
<code>left</code> <code>...</code> <code>...</code> <code>right</code> would work just as well.</p>&#13;
&#13;
<p>You can be as simple or creative with your cell names as you like. If&#13;
you want to call your header <code>ronaldo</code> and your footer <code>podiatrist</code>, go&#13;
for it. You can even use any Unicode character above codepoint U+0080,&#13;
so <code>ConHugeCo©®™</code> and <code>åwësømë</code> are completely valid area identifiers…as are emoji! <img src="assets/joy_1f602.png"/> Now, to size the grid tracks created by these areas, we bring in our old&#13;
friends <code>grid-template-columns</code> and <code>grid-template-rows</code>. Let’s add both&#13;
to the previous example, with the result shown in <a data-type="xref" href="#named_areas_and_sized_tracks">Figure 12-29</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header  header  header  header"</code>&#13;
        <code class="s2">"left    ...     ...     right"</code>&#13;
        <code class="s2">"footer  footer  footer  footer"</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="m">20em</code> <code class="m">20em</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">40px</code> <code class="m">10em</code> <code class="m">3em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="named_areas_and_sized_tracks">&#13;
<img alt="image" src="assets/css5_1229.png"/>&#13;
<h6><span class="label">Figure 12-29. </span>Named areas and sized tracks</h6>&#13;
</div></figure>&#13;
&#13;
<p>Thus, the columns and rows created by naming the grid areas are given&#13;
track sizes. If we give more track sizes than there are area tracks,&#13;
that will add more tracks past the named areas. Therefore, the&#13;
following CSS will lead to the result shown in <a data-type="xref" href="#adding_more_tracks">Figure 12-30</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header  header  header  header"</code>&#13;
        <code class="s2">"left    ...     ...     right"</code>&#13;
        <code class="s2">"footer  footer  footer  footer"</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="m">20em</code> <code class="m">20em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">40px</code> <code class="m">10em</code> <code class="m">3em</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="adding_more_tracks">&#13;
<img alt="image" src="assets/css5_1230.png"/>&#13;
<h6><span class="label">Figure 12-30. </span>Adding more tracks beyond the named areas</h6>&#13;
</div></figure>&#13;
&#13;
<p>So, given that we’re naming areas, how about mixing in some named grid&#13;
lines? As it happens, we already have: naming a grid area automatically&#13;
adds names to the grid lines at its start and end. For the <code>header</code>&#13;
area, there’s an implicit <code>header-start</code> name on its first-column grid&#13;
line <em>and</em> its first-row grid line, and <code>header-end</code> for its second-column and -row grid lines. For the <code>footer</code> area, the <code>footer-start</code> and&#13;
<code>footer-end</code> names were automatically assigned to its grid lines.</p>&#13;
&#13;
<p>Grid lines extend throughout the whole grid area, so a lot of&#13;
these names are coincident. <a data-type="xref" href="#implicit_grid_line_names_explicit">Figure 12-31</a> shows the naming of the lines&#13;
created by the following template:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting">    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header    header    header    header"</code>&#13;
        <code class="s2">"left      ...       ...       right"</code>&#13;
        <code class="s2">"footer    footer    footer    footer"</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="implicit_grid_line_names_explicit">&#13;
<img alt="image" src="assets/css5_1231.png"/>&#13;
<h6><span class="label">Figure 12-31. </span>Implicit grid-line names made explicit</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s mix it up even more by adding a couple of explicit grid-line&#13;
names to our CSS. Given the following rules, the first-column grid line&#13;
in the grid would add the name <code>begin</code>, and the second-row grid line in&#13;
the grid would add the name <code>content</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header  header  header  header"</code>&#13;
        <code class="s2">"left    ...     ...     right"</code>&#13;
        <code class="s2">"footer  footer  footer  footer"</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="p">[</code><code class="n">begin</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code> <code class="m">20em</code> <code class="m">20em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">40px</code> <code class="p">[</code><code class="n">content</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code> <code class="m">3em</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Again: those grid-line names are <em>added</em> to the implicit grid-line names&#13;
created by the named areas. Grid-line names never&#13;
replace other grid-line names. Instead, they just keep piling up.</p>&#13;
&#13;
<p>Even more interesting, this implicit-name mechanism runs in reverse.&#13;
Suppose you don’t use <code>grid-template-areas</code> at all, but instead set up&#13;
some named grid lines like so, as illustrated in <a data-type="xref" href="#implicit_grid_area_names_explicit">Figure 12-32</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting">    <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
         <code class="p">[</code><code class="n">header</code><code class="o">-</code><code class="n">start</code> <code class="n">footer</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code>&#13;
         <code class="p">[</code><code class="n">content</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">content</code><code class="o">-</code><code class="n">end</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code>&#13;
         <code class="p">[</code><code class="n">header</code><code class="o">-</code><code class="n">end</code> <code class="n">footer</code><code class="o">-</code><code class="n">end</code><code class="p">];</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">header</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">3em</code>&#13;
        <code class="p">[</code><code class="n">header</code><code class="o">-</code><code class="n">end</code> <code class="n">content</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code>&#13;
        <code class="p">[</code><code class="n">content</code><code class="o">-</code><code class="n">end</code> <code class="n">footer</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">3em</code>&#13;
        <code class="p">[</code><code class="n">footer</code><code class="o">-</code><code class="n">end</code><code class="p">];</code></pre>&#13;
&#13;
<figure><div class="figure" id="implicit_grid_area_names_explicit">&#13;
<img alt="image" src="assets/css5_1232.png"/>&#13;
<h6><span class="label">Figure 12-32. </span>Implicit grid-area names made explicit</h6>&#13;
</div></figure>&#13;
&#13;
<p>Because the grid lines use the form of <code>name-start</code>/<code>name-end</code>, the grid&#13;
areas they define are implicitly named. To be frank, it’s clumsier than&#13;
doing it the other way, but the capability is there in case you ever&#13;
want it.</p>&#13;
&#13;
<p>Bear in mind that you don’t need all four grid lines to be named in&#13;
order to create a named grid area, though you probably do need them all&#13;
to create a named grid area where you want it to be. Consider the&#13;
following example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting">    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">content</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">content</code><code class="o">-</code><code class="n">end</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">3em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">3em</code><code class="p">;</code></pre>&#13;
&#13;
<p>This will still create a grid area named <code>content</code>. It’s just that the&#13;
named area will be placed into a new row after all the defined rows.&#13;
What’s odd is that an extra, empty row will appear after the defined&#13;
rows but before the row containing <code>content</code>. This has been confirmed to&#13;
be the intended behavior. Thus, if you try to create a named area by&#13;
naming the grid lines and miss one or more of them, your named&#13;
area will effectively hang off to one side of the grid instead of being a&#13;
part of the overall grid structure.</p>&#13;
&#13;
<p>So, again, if you want to create named grid areas, you should probably stick to explicitly naming grid areas and&#13;
let the <code>start-</code> and <code>end-</code> grid-line names be created implicitly, as opposed to the other&#13;
way around.<a data-primary="" data-startref="ix_grid_layout_lines" data-type="indexterm" id="idm45176071950960"/><a data-primary="" data-startref="ix_grid_area_ch12" data-type="indexterm" id="idm45176071948320"/><a data-primary="" data-startref="ix_grid_temp_area_prop" data-type="indexterm" id="idm45176071947376"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Placing Elements in the Grid" data-type="sect1"><div class="sect1" id="placing-elements-in-the-grid">&#13;
<h1>Placing Elements in the Grid</h1>&#13;
&#13;
<p>Believe it or not, we’ve <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="placing elements" data-type="indexterm" id="ix_grid_line_place_elem"/>gotten this far without talking about how grid&#13;
items are actually placed in a grid, once they’ve been defined.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Column and Row Lines" data-type="sect2"><div class="sect2" id="using-column-and-row-lines">&#13;
<h2>Using Column and Row Lines</h2>&#13;
&#13;
<p>There are a <a data-primary="column and row grid lines" data-type="indexterm" id="ix_col_row_grid_line"/><a data-primary="grid-row-start property" data-type="indexterm" id="ix_grid_row_strt_prop"/><a data-primary="grid-column-start property" data-type="indexterm" id="ix_grid_col_strt_prop"/><a data-primary="grid-row-end property" data-type="indexterm" id="ix_grid_row_end_prop"/><a data-primary="grid-column-end property" data-type="indexterm" id="ix_grid_col_end_prop"/>couple of ways to go about placing grid items, depending on whether you&#13;
want to refer to grid lines or grid areas. We’ll start with four simple&#13;
properties that attach an element to grid lines.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176071937120">&#13;
<h1>grid-row-start, grid-row-end, grid-column-start, grid-column-end</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p>&lt;<code><em>grid-line</em></code>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid items and absolutely positioned elements, if their&#13;
containing block is a grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<dl>&#13;
<dt>&lt;<code><em>grid-line</em></code>&gt;</dt>&#13;
<dd>&#13;
<p><code>auto</code> | &lt;<code><em>custom-ident</em></code>&gt; | [ &lt;<code><em>integer</em></code>&gt; &amp;&amp; &lt;<code><em>custom-ident</em></code>&gt;? ] | [ <code>span</code> &amp;&amp; [ &lt;<code><em>integer</em></code>&gt; ‖ &lt;<code><em>custom-ident</em></code>&gt; ]]</p>&#13;
</dd>&#13;
</dl>&#13;
</div></aside>&#13;
&#13;
<p>These properties let you say, “I want the edge of the element&#13;
to be attached to grid line such-and-so.” As with so much of CSS Grid,&#13;
it’s a lot easier to show than to describe, so ponder the&#13;
following styles and their result (see <a data-type="xref" href="#attaching_elements_to_grid_lines">Figure 12-33</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">50em</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="m">5em</code><code class="p">);</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">10</code><code class="o">,</code> <code class="m">5em</code><code class="p">);}</code>&#13;
<code class="nc">.one</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="m">4</code><code class="p">;}</code>&#13;
<code class="nc">.two</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="m">10</code><code class="p">;}</code>&#13;
<code class="nc">.three</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">6</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="attaching_elements_to_grid_lines">&#13;
<img alt="image" src="assets/css5_1233.png"/>&#13;
<h6><span class="label">Figure 12-33. </span>Attaching elements to grid lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here, we’re using grid-line numbers to say where and how the elements&#13;
should be placed within the grid. Column numbers count from left to&#13;
right, and row numbers from top to bottom. If you omit ending&#13;
grid lines, as was the case for <code>.three</code>, then the next grid lines in&#13;
sequence are used for the end lines.</p>&#13;
&#13;
<p>Thus, the rule for <code>.three</code> in the&#13;
previous example is exactly equivalent to this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.three</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">6</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="m">7</code><code class="p">;}</code></pre>&#13;
&#13;
<p>There’s <a data-primary="spanning grid lines" data-type="indexterm" id="ix_span_grid_line"/>another way to say that same thing, as it happens: you could&#13;
replace the ending values with <code>span 1</code>, or even just plain <code>span</code>, like&#13;
this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.three</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">6</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If you supply <code>span</code> with a number, you’re saying, “Span across this&#13;
many grid tracks.” So we can rewrite our earlier example like this and&#13;
get exactly the same result:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="m">5em</code><code class="p">);</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">10</code><code class="o">,</code> <code class="m">5em</code><code class="p">);}</code>&#13;
<code class="nc">.one</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nc">.two</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">5</code><code class="p">;}</code>&#13;
<code class="nc">.three</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">6</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If you leave out a number for <code>span</code>, it’s set to be <code>1</code>. You can’t use&#13;
0 or negative numbers for <code>span</code>; only positive integers.</p>&#13;
&#13;
<p>An interesting feature of <code>span</code> is that you can use it for both ending&#13;
<em>and</em> starting grid lines. The precise behavior of <code>span</code> is that it&#13;
counts grid lines in the direction “away” from the grid line where it&#13;
starts. In other words, if you define a start grid line and set the&#13;
ending grid line to be a <code>span</code> value, it will search toward the end of&#13;
the grid. <span class="keep-together">Conversely,</span> if you define an ending grid line and make the&#13;
start line a <code>span</code> value, it will search toward the start of the&#13;
grid.</p>&#13;
&#13;
<p>That means the following rules will have the result shown in <a data-type="xref" href="#spanning_grid_lines">Figure 12-34</a> (the column and row numbers were added for clarity):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">4</code><code class="o">,</code> <code class="m">2em</code><code class="p">);</code> <code class="nb">grid</code><code class="o">-</code><code class="k">columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="m">5em</code><code class="p">);}</code>&#13;
<code class="nc">.box1</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code> <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code>      <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nc">.box2</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-column-start</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="m">3</code><code class="p">;}</code>&#13;
<code class="nc">.box3</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code> <code class="k">grid-column-start</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>      <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">5</code><code class="p">;}</code>&#13;
<code class="nc">.box4</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-column-start</code><code class="o">:</code> <code class="n">span</code> <code class="m">1</code><code class="p">;</code> <code class="k">grid-column-end</code><code class="o">:</code> <code class="m">5</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="spanning_grid_lines">&#13;
<img alt="image" src="assets/css5_1234.png"/>&#13;
<h6><span class="label">Figure 12-34. </span>Spanning grid lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>In contrast to <code>span</code> numbering, you aren’t restricted to positive&#13;
integers for your actual grid-line values. Negative numbers will&#13;
count backward from the end of explicitly defined grid lines. Thus, to&#13;
place an element into the bottom-right grid cell of a defined grid,&#13;
regardless of how many columns or rows it might have, you can just say this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-column-start</code><code class="o">:</code> <code class="m">-1</code><code class="p">;</code>&#13;
<code class="k">grid-row-start</code><code class="o">:</code> <code class="m">-1</code><code class="p">;</code></pre>&#13;
&#13;
<p>Note that this doesn’t apply to any implicit grid tracks, a concept&#13;
we’ll get to in a bit, but only to the grid lines you explicitly define&#13;
via one of the <code>grid-template-*</code> properties (e.g., <code>grid-template-rows</code>).</p>&#13;
&#13;
<p>We aren’t restricted to grid-line numbers, as it happens. If there are&#13;
named grid lines, we can refer to those instead of (or in conjunction&#13;
with) numbers. If you have multiple instances of a grid-line name,&#13;
you can use numbers to identify which instance of the &#13;
<span class="keep-together">grid-line</span> name&#13;
you’re talking about. Thus, to start from the fourth instance of a row&#13;
grid named <code>mast-slice</code>, you can say <code>mast-slice 4</code>. Take a look at the&#13;
following, illustrated in <a data-type="xref" href="#attaching_elements_to_named_grid_lines">Figure 12-35</a>, for an idea of how this works:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="p">[</code><code class="n">R</code><code class="p">]</code> <code class="m">4em</code><code class="p">);</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">2em</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">A</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">B</code><code class="p">]</code> <code class="m">5em</code><code class="p">)</code> <code class="m">2em</code><code class="p">;}</code>&#13;
<code class="nc">.one</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="n">R</code> <code class="m">2</code><code class="p">;</code>       <code class="k">grid-row-end</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="n">col</code><code class="o">-</code><code class="n">B</code><code class="p">;</code>  <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nc">.two</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="n">R</code><code class="p">;</code>           <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="n">R</code> <code class="m">2</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="n">col</code><code class="o">-</code><code class="n">A</code> <code class="m">3</code><code class="p">;</code>  <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code> <code class="n">col</code><code class="o">-</code><code class="n">A</code><code class="p">;}</code>&#13;
<code class="nc">.three</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">9</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="n">col</code><code class="o">-</code><code class="n">A</code> <code class="m">-2</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="attaching_elements_to_named_grid_lines">&#13;
<img alt="image" src="assets/css5_1235.png"/>&#13;
<h6><span class="label">Figure 12-35. </span>Attaching elements to named grid lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice how <code>span</code> changes when we add a name: specifying&#13;
<code>span 2 col-A</code> causes the grid item to span from its starting&#13;
point (the third <code>col-A</code>) across another <code>col-A</code> and end at the <code>col-A</code>&#13;
after that. This means the grid item actually spans four column tracks,&#13;
since <code>col-A</code> appears on every other column grid line.<a data-primary="" data-startref="ix_span_grid_line" data-type="indexterm" id="idm45176071228912"/></p>&#13;
&#13;
<p>Again, negative numbers count backward from the end of a sequence, so&#13;
<code>col-A -2</code> gets us the second-to-last instance of a grid line named&#13;
<code>col-A</code>. Because no end-line values are declared for <code>.three</code>,&#13;
they’re both set to <code>span 1</code>. That means the following is exactly&#13;
equivalent to the <code>.three</code> in the previous example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.three</code> <code class="p">{</code>&#13;
    <code class="k">grid-row-start</code><code class="o">:</code> <code class="m">9</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">grid-column-start</code><code class="o">:</code> <code class="n">col</code><code class="o">-</code><code class="n">A</code> <code class="m">-2</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">1</code><code class="p">;}</code></pre>&#13;
&#13;
<p>There’s an alternative way to use names with named grid&#13;
lines—specifically, the named grid lines that are implicitly created by&#13;
grid areas. For example, consider the following styles, illustrated in&#13;
<a data-type="xref" href="#another_way_of_attaching">Figure 12-36</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">grid-template-areas</code><code class="o">:</code>&#13;
    <code class="s2">"header     header    header    header"</code>&#13;
    <code class="s2">"leftside   content   content   rightside"</code>&#13;
    <code class="s2">"leftside   footer    footer    footer"</code><code class="o">;</code>&#13;
<code class="nf">#masthead</code> <code class="p">{</code><code class="k">grid-row-start</code><code class="o">:</code> <code class="n">header</code><code class="p">;</code>&#13;
	<code class="k">grid-column-start</code><code class="o">:</code> <code class="n">header</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">header</code><code class="p">;}</code>&#13;
<code class="nf">#sidebar</code> <code class="p">{</code><code class="k">grid-row-start</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code>&#13;
	<code class="k">grid-column-start</code><code class="o">:</code> <code class="n">leftside</code> <code class="o">/</code> <code class="n">span</code> <code class="m">1</code><code class="p">;}</code>&#13;
<code class="nf">#main</code> <code class="p">{</code><code class="k">grid-row-start</code><code class="o">:</code> <code class="n">content</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">content</code><code class="p">;</code>&#13;
	<code class="k">grid-column-start</code><code class="o">:</code> <code class="n">content</code><code class="p">;}</code>&#13;
<code class="nf">#navbar</code> <code class="p">{</code><code class="k">grid-row-start</code><code class="o">:</code> <code class="n">rightside</code><code class="p">;</code> <code class="n">grd</code><code class="o">-</code><code class="n">row</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code>&#13;
	<code class="k">grid-column-start</code><code class="o">:</code> <code class="n">rightside</code><code class="p">;}</code>&#13;
<code class="nf">#footer</code> <code class="p">{</code><code class="k">grid-row-start</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">1</code><code class="p">;</code>&#13;
	<code class="k">grid-column-start</code><code class="o">:</code> <code class="n">footer</code><code class="p">;</code> <code class="k">grid-row-end</code><code class="o">:</code> <code class="n">footer</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="another_way_of_attaching">&#13;
<img alt="image" src="assets/css5_1236.png"/>&#13;
<h6><span class="label">Figure 12-36. </span>Another way of attaching elements to named grid lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you supply a custom identifier (i.e., a name you&#13;
defined), the browser looks for a grid line with that name <em>plus</em>&#13;
either <code>-start</code> or <code>-end</code> added on, depending on whether you’re&#13;
assigning a start line or an end line. Thus, the following are&#13;
equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-column-start</code><code class="o">:</code> <code class="n">header</code><code class="p">;</code>        <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">header</code><code class="p">;</code>&#13;
<code class="k">grid-column-start</code><code class="o">:</code> <code class="n">header</code><code class="o">-</code><code class="n">start</code><code class="p">;</code>  <code class="k">grid-column-end</code><code class="o">:</code> <code class="n">header</code><code class="o">-</code><code class="n">end</code><code class="p">;</code></pre>&#13;
&#13;
<p>This works because, as we mentioned with <code>grid-template-areas</code>,&#13;
explicitly creating a grid area implicitly creates the named <code>-start</code> and&#13;
<code>-end</code> grid lines that surround it.</p>&#13;
&#13;
<p>The final <a data-primary="grid layout" data-secondary="grid flow, specifying" data-type="indexterm" id="idm45176070991760"/>value possibility, <code>auto</code>, is kind of interesting. According&#13;
to the Grid Layout specification, if one of the grid-line start/end&#13;
properties is set to <code>auto</code>, that indicates “auto-placement, an&#13;
automatic span, or a default span of one.” In practice, this tends&#13;
to mean that the grid line that gets picked is governed by the <em>grid&#13;
flow</em>, a concept we have yet to cover (but will soon!). For a start line,&#13;
<code>auto</code> usually means that the next available column or row line will be&#13;
used. For an end line, <code>auto</code> usually means a one-cell span. In both&#13;
cases, the word <em>usually</em> is used intentionally: as with any automatic&#13;
mechanism, there are no absolutes.<a data-primary="" data-startref="ix_grid_col_end_prop" data-type="indexterm" id="idm45176070988016"/><a data-primary="" data-startref="ix_grid_col_strt_prop" data-type="indexterm" id="idm45176070987040"/><a data-primary="" data-startref="ix_grid_row_end_prop" data-type="indexterm" id="idm45176070986096"/><a data-primary="" data-startref="ix_grid_row_strt_prop" data-type="indexterm" id="idm45176070985152"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Using Row and Column Shorthands" data-type="sect2"><div class="sect2" id="row-and-column-shorthands">&#13;
<h2>Using Row and Column Shorthands</h2>&#13;
&#13;
<p>Two <a data-primary="grid-row property" data-type="indexterm" id="ix_grid_row_prop"/><a data-primary="grid-column property" data-type="indexterm" id="ix_grid_col_prop"/>shorthand properties allow you to more compactly&#13;
attach an element to grid lines.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176070978848">&#13;
<h1>grid-row, grid-column</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>grid-line</code></em>&gt; [ / &lt;<em><code>grid-line</code></em>&gt; ]?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid items and absolutely positioned elements, if their&#13;
containing block is a grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The primary benefit of these properties is that they make it a lot&#13;
simpler to declare the start and end grid lines to be used for laying&#13;
out a grid item. For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">10</code><code class="o">,</code> <code class="p">[</code><code class="n">R</code><code class="p">]</code> <code class="m">1.5em</code><code class="p">);</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">2em</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">A</code><code class="p">]</code> <code class="m">5em</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">B</code><code class="p">]</code> <code class="m">5em</code><code class="p">)</code> <code class="m">2em</code><code class="p">;}</code>&#13;
<code class="nc">.one</code> <code class="p">{</code>&#13;
    <code class="k">grid-row</code><code class="o">:</code> <code class="n">R</code> <code class="m">3</code> <code class="o">/</code> <code class="m">7</code><code class="p">;</code>&#13;
    <code class="k">grid-column</code><code class="o">:</code> <code class="n">col</code><code class="o">-</code><code class="n">B</code> <code class="o">/</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nc">.two</code> <code class="p">{</code>&#13;
    <code class="k">grid-row</code><code class="o">:</code> <code class="n">R</code> <code class="o">/</code> <code class="n">span</code> <code class="n">R</code> <code class="m">2</code><code class="p">;</code>&#13;
    <code class="k">grid-column</code><code class="o">:</code> <code class="n">col</code><code class="o">-</code><code class="n">A</code> <code class="m">3</code> <code class="o">/</code> <code class="n">span</code> <code class="m">2</code> <code class="n">col</code><code class="o">-</code><code class="n">A</code><code class="p">;}</code>&#13;
<code class="nc">.three</code> <code class="p">{</code>&#13;
    <code class="k">grid-row</code><code class="o">:</code> <code class="m">9</code><code class="p">;</code>&#13;
    <code class="k">grid-column</code><code class="o">:</code> <code class="n">col</code><code class="o">-</code><code class="n">A</code> <code class="m">-2</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That’s a whole lot easier to read than having each start and end value&#13;
in its own property, honestly. Other than being more compact, the&#13;
behavior of these properties is more or less what you’d expect. If you&#13;
have two bits separated by a forward slash (<code>/</code>), the first part defines the&#13;
starting grid line, and the second part defines the ending grid line.</p>&#13;
&#13;
<p>If you have only one value with no forward slash, it defines the starting grid&#13;
line. The ending grid line depends on what you said for the starting&#13;
line. If you supply a name for the starting grid line, the ending&#13;
grid line is given that same name. If a single number is given, the second number (the end line) is set to <code>auto</code>. That&#13;
means the following pairs &#13;
<span class="keep-together">are equivalent:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code>&#13;
<code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="nb">auto</code><code class="p">;</code>&#13;
&#13;
<code class="k">grid-column</code><code class="o">:</code> <code class="n">header</code><code class="p">;</code>&#13;
<code class="k">grid-column</code><code class="o">:</code> <code class="n">header</code> <code class="o">/</code> <code class="n">header</code><code class="p">;</code></pre>&#13;
&#13;
<p>A subtle behavior built into the handling of grid-line names in&#13;
<code>grid-row</code> and <code>grid-column</code> pertains to implicitly named grid&#13;
lines. As you may recall, defining a named grid area creates <code>-start</code> and <code>-end</code>&#13;
grid lines. That is, given a grid area with a name of <code>footer</code>, there&#13;
are implicitly created <code>footer-start</code> grid lines to its top and left,&#13;
and <code>footer-end</code> grid lines to its bottom and right.</p>&#13;
&#13;
<p>In that case, if you refer to those grid lines by the area’s name, the&#13;
element will still be placed properly. Thus, the following styles have&#13;
the result shown in <a data-type="xref" href="#attaching_to_implicit_grid_lines">Figure 12-37</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header header"</code>&#13;
        <code class="s2">"sidebar content"</code>&#13;
        <code class="s2">"footer footer"</code><code class="p">;</code>&#13;
     <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">auto</code> <code class="m">1</code><code class="n">fr</code> <code class="nb">auto</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">25%</code> <code class="m">75%</code><code class="p">;}</code>&#13;
<code class="nf">#header</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">header</code> <code class="o">/</code> <code class="n">header</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="n">header</code><code class="p">;}</code>&#13;
<code class="nf">#footer</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">footer</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="n">footer</code><code class="o">-</code><code class="n">start</code> <code class="o">/</code> <code class="n">footer</code><code class="o">-</code><code class="n">end</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="attaching_to_implicit_grid_lines">&#13;
<img alt="image" src="assets/css5_1237.png"/>&#13;
<h6><span class="label">Figure 12-37. </span>Attaching to implicit grid lines via grid-area names</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can always explicitly refer to the implicitly named grid lines, but&#13;
if you just refer to the grid area’s name, things still work out. If you refer&#13;
to a grid-line name that doesn’t correspond to a grid area, it&#13;
falls back to the behavior discussed previously. In detail, it’s the&#13;
same as saying <code>line-name 1</code>, so the following two are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-column</code><code class="o">:</code> <code class="n">jane</code> <code class="o">/</code> <code class="n">doe</code><code class="p">;</code>&#13;
<code class="k">grid-column</code><code class="o">:</code> <code class="n">jane</code> <code class="m">1</code> <code class="o">/</code> <code class="n">doe</code> <code class="m">1</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is why it’s risky to name grid lines the same as grid areas.&#13;
Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting">    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header header"</code>&#13;
        <code class="s2">"sidebar content"</code>&#13;
        <code class="s2">"footer footer"</code>&#13;
        <code class="s2">"legal legal"</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">auto</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">footer</code><code class="p">]</code> <code class="nb">auto</code> <code class="p">[</code><code class="n">footer</code><code class="p">];</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">25%</code> <code class="m">75%</code><code class="p">;</code></pre>&#13;
&#13;
<p>This explicitly sets grid lines named <code>footer</code> above the “footer” row&#13;
and below the “legal” row…and now there’s trouble ahead. Suppose we add&#13;
this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#footer</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">footer</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="n">footer</code><code class="p">;}</code></pre>&#13;
&#13;
<p>For the column lines, there’s no problem. The name <code>footer</code> gets expanded to&#13;
<code>footer / footer</code>. The browser looks for a grid area with that name and&#13;
finds it, so it translates <code>footer / footer</code> to&#13;
<code>footer-start / footer-end</code>. The <code>#footer</code> element is attached to those&#13;
implicit grid lines.</p>&#13;
&#13;
<p>For <code>grid-row</code>, everything starts out the same. The <code>footer</code> name becomes&#13;
<code>footer / footer</code>, which is translated to <code>footer-start / footer-end</code>.&#13;
But that means the <code>#footer</code> will only be as tall as the “footer” row.&#13;
It will <em>not</em> stretch to the second explicitly named <code>footer</code> grid line&#13;
below the “legal” row, because the translation of <code>footer</code> to&#13;
<code>footer-end</code> (due to the match between the grid-line name and the grid-area name) takes precedence.</p>&#13;
&#13;
<p>The upshot of all this: it’s generally a bad idea to use the same name&#13;
for grid areas and grid lines. You might be able to get away with it in&#13;
some scenarios, but you’re almost always better off keeping your line&#13;
and area names distinct, so as to avoid tripping over name-resolution&#13;
conflicts.<a data-primary="" data-startref="ix_col_row_grid_line" data-type="indexterm" id="idm45176070571872"/><a data-primary="" data-startref="ix_grid_line_place_elem" data-type="indexterm" id="idm45176070570896"/><a data-primary="" data-startref="ix_grid_col_prop" data-type="indexterm" id="idm45176070569952"/><a data-primary="" data-startref="ix_grid_row_prop" data-type="indexterm" id="idm45176070569008"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Working with Implicit Grid" data-type="sect2"><div class="sect2" id="the-implicit-grid">&#13;
<h2>Working with Implicit Grid</h2>&#13;
&#13;
<p>Up to this <a data-primary="implicit grid" data-type="indexterm" id="ix_implicit_grid"/><a data-primary="grid layout" data-secondary="implicit grid" data-type="indexterm" id="ix_grid_implicit"/>point, we’ve concerned ourselves solely with&#13;
explicitly defined grids: we’ve talked about the row and column tracks&#13;
we define via properties like <code>grid-template-columns</code>, and how to attach grid&#13;
items to the cells in those tracks.</p>&#13;
&#13;
<p>But what happens if we try to place a grid item, or even just part of a&#13;
grid item, beyond that explicitly created grid? For example, consider&#13;
the following grid:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">2em</code> <code class="m">2em</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">6</code><code class="o">,</code> <code class="m">4em</code><code class="p">);}</code></pre>&#13;
&#13;
<p>Two rows, six columns. Simple enough. But suppose we define a grid item&#13;
to sit in the first column and go from the first-row grid line to the&#13;
fourth:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.box1</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">4</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now what? We have only two rows bounded by three grid lines, and we’ve&#13;
told the browser to go beyond that, from row line 1 to row line 4.</p>&#13;
&#13;
<p>What happens is that another row line is created to handle the&#13;
situation. This grid line, and the new row track it creates, are both&#13;
part of the <em>implicit grid</em>. Here are a few examples of grid items that&#13;
create implicit grid lines (and tracks) and how they’re laid out (see&#13;
<a data-type="xref" href="#creating_implicit_grid_lines_and_tracks">Figure 12-38</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.box1</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">4</code><code class="p">;}</code>&#13;
<code class="nc">.box2</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">3</code> <code class="o">/</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nc">.box3</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code> <code class="o">/</code> <code class="m">3</code><code class="p">;}</code>&#13;
<code class="nc">.box4</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code> <code class="o">/</code> <code class="m">5</code><code class="p">;}</code>&#13;
<code class="nc">.box5</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="n">span</code> <code class="m">4</code> <code class="o">/</code> <code class="m">5</code><code class="p">;}</code>&#13;
<code class="nc">.box6</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">6</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">-1</code> <code class="o">/</code> <code class="n">span</code> <code class="m">3</code><code class="p">;}</code>&#13;
<code class="nc">.box7</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">7</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="n">span</code> <code class="m">3</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="creating_implicit_grid_lines_and_tracks">&#13;
<img alt="image" src="assets/css5_1238.png"/>&#13;
<h6><span class="label">Figure 12-38. </span>Creating implicit grid lines and tracks</h6>&#13;
</div></figure>&#13;
&#13;
<p>A lot is going on there, so let’s break it down. First off, the&#13;
explicit grid is represented by the filled-in box behind the various&#13;
numbered boxes; all the dashed lines represent the implicit grid.</p>&#13;
&#13;
<p>What about those numbered boxes? The first, <code>box1</code>, adds an extra grid row line&#13;
after the end of the explicit grid. The second, <code>box2</code>,&#13;
starts on the last row-line of the explicit grid, and spans forward two&#13;
row-lines, so it adds yet another implicit row-line. The third, <code>box3</code>, ends on the&#13;
last explicit row-line (line 3) and spans <em>back</em> two lines, thus starting&#13;
on the first explicit row-line.</p>&#13;
&#13;
<p>Things really get interesting with <code>box4</code>. It ends on the fifth row-line, which is to say the second implicit row-line. It spans back three&#13;
row-lines—and yet, it still starts on the same row-line as <code>box3</code>. This&#13;
happens because grid track spans have to start counting <em>within</em> the explicit grid.&#13;
Once they start, they can continue into the implicit grid (as&#13;
happened with <code>box2</code>), but they <em>cannot</em> start counting within the&#13;
implicit grid.</p>&#13;
&#13;
<p>Thus, <code>box4</code> ends on row-line 5, but its span starts with row-line 3&#13;
and counts back two lines (<code>span 2</code>) to arrive at row-line 1. Similarly,&#13;
<code>box5</code> ends on row-line 5 and spans back four lines, which means it starts on&#13;
row-line –2. Remember: span counting must <em>start</em> in the explicit grid. It&#13;
doesn’t have to end there.</p>&#13;
&#13;
<p>After those, <code>box6</code> starts on the last&#13;
explicit row-line (line 3), and spans out to the sixth row-line—adding&#13;
yet another implicit row-line. The point of having it here is to show&#13;
that negative grid-line references are with respect to the explicit&#13;
grid, and count back from its end. They do <em>not</em> refer to&#13;
negatively indexed implicit lines that are placed before the start of&#13;
the explicit grid.</p>&#13;
&#13;
<p>If you want to start an element on an implicit grid line before the&#13;
explicit grid’s start, the way to do that is shown by <code>box7</code>: put&#13;
its end line somewhere in the explicit grid, and span back past the&#13;
beginning of the explicit grid. And you may have noticed: <code>box7</code>&#13;
occupies an implicit column track. The original grid was set up to&#13;
<span class="keep-together">create</span> six columns, which means seven column-lines, the seventh being&#13;
the end of the explicit grid. When <code>box7</code> was given <code>grid-column: 7</code>,&#13;
that was equivalent to <code>grid-column: 7 / span 1</code> (since a missing end&#13;
line is always assumed to be <code>span 1</code>). That necessitated the creation&#13;
of an implicit column-line in order to hold the grid item in the&#13;
implicit seventh column.</p>&#13;
&#13;
<p>Now let’s take those principles and add named grid lines to the mix.&#13;
Consider the following, illustrated in <a data-type="xref" href="#named_implicit_grid_lines_and_tracks">Figure 12-39</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="p">[</code><code class="n">begin</code><code class="p">]</code> <code class="m">2em</code> <code class="p">[</code><code class="nb">middle</code><code class="p">]</code> <code class="m">2em</code> <code class="p">[</code><code class="n">end</code><code class="p">];</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="m">5em</code><code class="p">);}</code>&#13;
<code class="nc">.box1</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="n">span</code> <code class="n">end</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nc">.box2</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="n">span</code> <code class="n">final</code><code class="p">;}</code>&#13;
<code class="nc">.box3</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="n">span</code> <code class="m">3</code> <code class="nb">middle</code><code class="p">;}</code>&#13;
<code class="nc">.box4</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="n">span</code> <code class="n">begin</code> <code class="m">2</code> <code class="o">/</code> <code class="n">end</code><code class="p">;}</code>&#13;
<code class="nc">.box5</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code> <code class="nb">middle</code> <code class="o">/</code> <code class="n">begin</code><code class="p">;}</code></pre>&#13;
&#13;
<p>What you can see at work in several of these examples is what&#13;
happens with grid-line names in the implicit grid: every&#13;
implicitly created line has the name that’s being hunted. Take <code>box2</code>,&#13;
for example. It’s given an end line of <code>final</code>, but there is no line&#13;
with that name. Thus the span-search goes to the end of the explicit&#13;
grid and, having not found the name it’s looking for, creates a new grid&#13;
line, to which it attaches the name <code>final</code>.  (In <a data-type="xref" href="#named_implicit_grid_lines_and_tracks">Figure 12-39</a>, the implicitly created line names are italicized and faded out a bit.)</p>&#13;
&#13;
<figure><div class="figure" id="named_implicit_grid_lines_and_tracks">&#13;
<img alt="image" src="assets/css5_1239.png"/>&#13;
<h6><span class="label">Figure 12-39. </span>Named implicit grid lines and tracks</h6>&#13;
</div></figure>&#13;
&#13;
<p>Similarly, <code>box3</code> starts on the first explicit row-line, and then needs&#13;
to span three <code class="keep-together">middle</code> named lines. It searches forward and finds one,&#13;
then goes looking for the other two. Not finding any, it attaches the&#13;
name <code>middle</code> to the first implicit row-line, and then does the same&#13;
for the second implicit row-line. Thus, it ends two implicit row-lines&#13;
past the end of the explicit grid.</p>&#13;
&#13;
<p class="pagebreak-before">The same sort of thing happens with <code>box4</code> and <code>box5</code>, except working backward from endpoints.  You can see that <code>box4</code> ends with the <code>end</code> row-line (line 3), then spans back to the second <code>begin</code> row-line it can find.  This causes an implicit row-line to be created before the first row-line, named <code>begin</code>. Finally, <code>box5</code> spans back from <code>begin</code> (the explicitly labeled <code>begin</code>) to the second <code>middle</code> it can find.  Since it can’t find any, it labels two implicit row-line <code>middle</code> and ends at the one farthest from where it started looking.<a data-primary="" data-startref="ix_grid_implicit" data-type="indexterm" id="idm45176070144560"/><a data-primary="" data-startref="ix_implicit_grid" data-type="indexterm" id="idm45176070143584"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handling Errors" data-type="sect2"><div class="sect2" id="error-handling">&#13;
<h2>Handling Errors</h2>&#13;
&#13;
<p>We <a data-primary="grid layout" data-secondary="error handling when placing" data-type="indexterm" id="idm45176070141264"/>need to cover a few cases, as they fall under the&#13;
general umbrella of “what grids do when things go pear-shaped.” First, what if you accidentally put the start line after the end line? Say, something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-row-start</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code>&#13;
<code class="k">grid-row-end</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code></pre>&#13;
&#13;
<p>All that happens is probably what was meant in the first place: the&#13;
values are <span class="keep-together">swapped</span>. Thus, you end up with the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-row-start</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code>&#13;
<code class="k">grid-row-end</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code></pre>&#13;
&#13;
<p>Second, what if both the start and the end lines are declared to be&#13;
spans of some variety? For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-column-start</code><code class="o">:</code> <code class="n">span</code><code class="p">;</code>&#13;
<code class="k">grid-column-end</code><code class="o">:</code> <code class="n">span</code> <code class="m">3</code><code class="p">;</code></pre>&#13;
&#13;
<p>If this happens, the end value is dropped and replaced with <code>auto</code>. That&#13;
means you’d end up with this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-column-start</code><code class="o">:</code> <code class="n">span</code><code class="p">;</code>  <code class="c">/* 'span' is equal to 'span 1' */</code>&#13;
<code class="k">grid-column-end</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code></pre>&#13;
&#13;
<p>That would cause the grid item to have its ending edge placed&#13;
automatically, according to the current grid flow (a subject we’ll soon&#13;
explore), and the starting edge to be placed one grid line earlier.</p>&#13;
&#13;
<p>Third, what if the only thing directing placement of the grid item is a&#13;
named span? In other words, you’d have this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-row-start</code><code class="o">:</code> <code class="n">span</code> <code class="n">footer</code><code class="p">;</code>&#13;
<code class="k">grid-row-end</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is not permitted, so the <code>span footer</code> in this case is replaced&#13;
with <code>span 1</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Using Areas" data-type="sect2"><div class="sect2" id="using-areas">&#13;
<h2>Using Areas</h2>&#13;
&#13;
<p>Attaching by <a data-primary="grid layout" data-secondary="grid areas" data-type="indexterm" id="ix_grid_layout_areas"/><a data-primary="grid-area property" data-type="indexterm" id="ix_grid_area_prop"/>row lines and column lines is great, but what if you could&#13;
refer to a grid area with a single property? Behold: <code>grid-area</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176069998720">&#13;
<h1>grid-area</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>grid-line</code></em>&gt; [ / &lt;<em><code>grid-line</code></em>&gt; ]{0,3}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid items and absolutely positioned elements, if their&#13;
containing block is a grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Let’s start with a simple use of <code>grid-area</code>: assigning an element to&#13;
a previously defined grid area. For this, we’ll bring back our&#13;
old friend <code>grid-template-areas</code>, put it together with <code>grid-area</code> and&#13;
some markup, and see what magic results (as shown in <a data-type="xref" href="#assigning_elements_to_grid_areas">Figure 12-40</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">200px</code> <code class="m">1</code><code class="n">fr</code> <code class="m">3em</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">20em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">1</code><code class="n">fr</code> <code class="m">10em</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header     header    header    header"</code>&#13;
        <code class="s2">"leftside   content   content   rightside"</code>&#13;
        <code class="s2">"leftside   footer    footer    footer"</code><code class="p">;}</code>&#13;
<code class="nf">#masthead</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">header</code><code class="p">;}</code>&#13;
<code class="nf">#sidebar</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">leftside</code><code class="p">;}</code>&#13;
<code class="nf">#main</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">content</code><code class="p">;}</code>&#13;
<code class="nf">#navbar</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">rightside</code><code class="p">;}</code>&#13;
<code class="nf">#footer</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">footer</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"grid"</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"masthead"</code><code class="o">&gt;</code><code class="err">…</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"main"</code><code class="o">&gt;</code><code class="err">…</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"navbar"</code><code class="o">&gt;</code><code class="err">…</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"sidebar"</code><code class="o">&gt;</code><code class="err">…</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"footer"</code><code class="o">&gt;</code><code class="err">…</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="assigning_elements_to_grid_areas">&#13;
<img alt="image" src="assets/css5_1240.png"/>&#13;
<h6><span class="label">Figure 12-40. </span>Assigning elements to grid areas</h6>&#13;
</div></figure>&#13;
&#13;
<p>That’s all it takes: set up some named grid areas to define your layout,&#13;
and then drop grid items into them with <code>grid-area</code>. So simple and yet&#13;
so powerful.</p>&#13;
&#13;
<p>Another way to use <code>grid-area</code> refers to grid lines&#13;
instead of grid areas. Fair warning: it’s likely to be confusing at&#13;
first.</p>&#13;
&#13;
<p>Here’s an example of a grid template that defines some grid lines, and&#13;
some <code>grid-area</code> rules that reference the lines, as illustrated in&#13;
<a data-type="xref" href="#assigning_elements_to_grid_lines">Figure 12-41</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">r1</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">r1</code><code class="o">-</code><code class="n">end</code> <code class="n">r2</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">2</code><code class="n">fr</code> <code class="p">[</code><code class="n">r2</code><code class="o">-</code><code class="n">end</code><code class="p">];</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
        <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">col</code><code class="o">-</code><code class="n">end</code> <code class="n">main</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">main</code><code class="o">-</code><code class="n">end</code><code class="p">];}</code>&#13;
<code class="nc">.box01</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">r1</code> <code class="o">/</code> <code class="n">main</code> <code class="o">/</code> <code class="n">r1</code> <code class="o">/</code> <code class="n">main</code><code class="p">;}</code>&#13;
<code class="nc">.box02</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">r2</code><code class="o">-</code><code class="n">start</code> <code class="o">/</code> <code class="n">col</code><code class="o">-</code><code class="n">start</code> <code class="o">/</code> <code class="n">r2</code><code class="o">-</code><code class="n">end</code> <code class="o">/</code> <code class="n">main</code><code class="o">-</code><code class="n">end</code><code class="p">;}</code>&#13;
<code class="nc">.box03</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">1</code> <code class="o">/</code> <code class="m">2</code> <code class="o">/</code> <code class="m">2</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="assigning_elements_to_grid_lines">&#13;
<img alt="image" src="assets/css5_1241.png"/>&#13;
<h6><span class="label">Figure 12-41. </span>Assigning elements to grid lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>These elements were placed as directed. Note the ordering&#13;
of the grid-line values, however. They’re listed in the order&#13;
<code>row-start</code>, <code>column-start</code>, <code>row-end</code>, <code>column-end</code>. If you diagram&#13;
that in your head, you’ll quickly realize that the values go&#13;
counterclockwise (also called anticlockwise) around the grid item—the exact opposite of the TRBL pattern we’re used to from margins, padding, borders, and so on.&#13;
Furthermore, this means the column and row references are not grouped&#13;
together but are instead split up.</p>&#13;
&#13;
<p>If you supply fewer than four values, then the missing values are taken from&#13;
those you do supply. If you use only three values, then the missing&#13;
<code>grid-column-end</code> is the same as <code>grid-column-start</code> if it’s a name; if&#13;
the start line is a number, the end line is set to <code>auto</code>. The same&#13;
holds true if you give only two values, except that the now-missing&#13;
<code>grid-row-end</code> is copied from <code>grid-row-start</code> if it’s a name;&#13;
otherwise, it’s set <span class="keep-together">to <code>auto</code>.</span></p>&#13;
&#13;
<p>From that, you can probably guess what happens if only one value is&#13;
supplied: if it’s a name, use it for all four values; if it’s a number,&#13;
the rest are set to <code>auto</code>.</p>&#13;
&#13;
<p>This one-to-four replication pattern is actually how giving a single&#13;
grid-area name translates into having the grid item fill that area. The&#13;
following are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-area</code><code class="o">:</code> <code class="n">footer</code><code class="p">;</code>&#13;
<code class="k">grid-area</code><code class="o">:</code> <code class="n">footer</code> <code class="o">/</code> <code class="n">footer</code> <code class="o">/</code> <code class="n">footer</code> <code class="o">/</code> <code class="n">footer</code><code class="p">;</code></pre>&#13;
&#13;
<p>Now recall the behavior discussed in the previous section about&#13;
<code>grid-column</code> and <code>grid-row</code>: if a grid line’s name matches the name of&#13;
a grid area, it’s translated into a <code>-start</code> or <code>-end</code> variant, as&#13;
appropriate. That means the previous example is translated to the&#13;
following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-area</code><code class="o">:</code> <code class="n">footer</code><code class="o">-</code><code class="n">start</code> <code class="o">/</code> <code class="n">footer</code><code class="o">-</code><code class="n">start</code> <code class="o">/</code> <code class="n">footer</code><code class="o">-</code><code class="n">end</code> <code class="o">/</code> <code class="n">footer</code><code class="o">-</code><code class="n">end</code><code class="p">;</code></pre>&#13;
&#13;
<p>And that’s how a single grid-area name causes an element to be placed&#13;
into the corresponding grid area.<a data-primary="" data-startref="ix_grid_area_prop" data-type="indexterm" id="idm45176069576688"/><a data-primary="" data-startref="ix_grid_layout_areas" data-type="indexterm" id="idm45176069575840"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Grid-Item Overlap" data-type="sect2"><div class="sect2" id="grid-item-overlap">&#13;
<h2>Understanding Grid-Item Overlap</h2>&#13;
&#13;
<p>One <a data-primary="grid layout" data-secondary="overlapping elements" data-type="indexterm" id="idm45176069573360"/><a data-primary="overlapping elements" data-secondary="grid items" data-type="indexterm" id="idm45176069572352"/>thing we’ve been very careful to do in our grid layouts thus far is&#13;
to avoid overlap. Rather like positioning, it’s absolutely (get it?)&#13;
possible to make grid items overlap each other. Let’s take a simple&#13;
case, illustrated in <a data-type="xref" href="#overlapping_grid_items">Figure 12-42</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">50%</code> <code class="m">50%</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">50%</code> <code class="m">50%</code><code class="p">;}</code>&#13;
<code class="nc">.box01</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">1</code> <code class="o">/</code> <code class="m">2</code> <code class="o">/</code> <code class="m">3</code><code class="p">;}</code>&#13;
<code class="nc">.box02</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">2</code> <code class="o">/</code> <code class="m">3</code> <code class="o">/</code> <code class="m">2</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="overlapping_grid_items">&#13;
<img alt="image" src="assets/css5_1242.png"/>&#13;
<h6><span class="label">Figure 12-42. </span>Overlapping grid items</h6>&#13;
</div></figure>&#13;
&#13;
<p>Thanks to the grid numbers that were supplied in the last two lines of the CSS, the two grid items&#13;
overlap in the upper-right grid cell. Which is on top of the other&#13;
depends on the layering behavior we’ll discuss later, but for&#13;
now, just take it as a given that they do layer when overlapping.</p>&#13;
&#13;
<p>There may well be times when you want grid items to overlap.  A photo’s caption might partially overlap the photo, for example.  Or you might want to assign a few items to the same grid area so they combine, or set them to be shown one at a time by script or user interaction.</p>&#13;
&#13;
<p>Overlap isn’t restricted to situations involving raw grid numbers. In the following case, the sidebar and the footer will overlap,&#13;
as shown in <a data-type="xref" href="#overlapping_sidebar_and_footer">Figure 12-43</a>. (Assuming the footer comes later than the sidebar&#13;
in the markup, then in the absence of other styles, the footer will be&#13;
on top of the sidebar.)</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-areas</code><code class="o">:</code>&#13;
        <code class="s2">"header header"</code>&#13;
        <code class="s2">"sidebar content"</code>&#13;
        <code class="s2">"footer footer"</code><code class="p">;}</code>&#13;
<code class="nf">#header</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">header</code><code class="p">;}</code>&#13;
<code class="nf">#sidebar</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">sidebar</code> <code class="o">/</code> <code class="n">sidebar</code> <code class="o">/</code> <code class="n">footer</code><code class="o">-</code><code class="n">end</code> <code class="o">/</code> <code class="n">sidebar</code><code class="p">;}</code>&#13;
<code class="nf">#footer</code> <code class="p">{</code><code class="k">grid-area</code><code class="o">:</code> <code class="n">footer</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="overlapping_sidebar_and_footer">&#13;
<img alt="image" src="assets/css5_1243.png"/>&#13;
<h6><span class="label">Figure 12-43. </span>Overlapping sidebar and footer</h6>&#13;
</div></figure>&#13;
&#13;
<p>We bring this up in part to warn you about the possibility of overlap,&#13;
and also to serve as a transition to the next topic. It’s a feature that&#13;
sets grid layout apart from positioning, in that it can sometimes help&#13;
avoid overlap: the concept of <em>grid flow</em>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Specifying Grid Flow" data-type="sect1"><div class="sect1" id="grid-flow">&#13;
<h1>Specifying Grid Flow</h1>&#13;
&#13;
<p>For the most part, we’ve been explicitly placing grid items on the grid.&#13;
If items aren’t <a data-primary="grid layout" data-secondary="grid flow, specifying" data-type="indexterm" id="ix_grid_flow"/><a data-primary="grid-auto-flow property" data-type="indexterm" id="ix_grid_auto_flow_prop"/>explicitly placed, they’re automatically placed&#13;
into the grid. Following the grid-flow direction that’s in effect, an item is placed in&#13;
the first area that will fit it. The simplest case is just filling a&#13;
grid track in sequence, one grid item after another, but things can get&#13;
a lot more complex than that, especially if there is a mixture of&#13;
explicitly and automatically placed grid items. The latter must work&#13;
around the former.</p>&#13;
&#13;
<p>CSS has primarily two grid-flow models, <em>row-first</em> and <em>column-first</em>, though you can enhance either by specifying a <em>dense</em> flow. All this is done with the property called &#13;
<span class="keep-together"><code>grid-auto-flow</code>.</span></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176069391136">&#13;
<h1>grid-auto-flow</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>row</code> | <code>column</code> ] ‖ <code>dense</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>row</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>To see how these values work, consider the following markup:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ol</code><code class="w"> </code><code class="na">id=</code><code class="s">"grid"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>1<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>2<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>3<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>4<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>5<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ol&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>To that markup, let’s apply the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">45em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">8em</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-flow</code><code class="o">:</code> <code class="n">row</code><code class="p">;}</code>&#13;
<code class="nf">#grid</code> <code class="nt">li</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Assuming a grid with a column line every 15 ems and a row line every 4 ems,&#13;
we get the result shown in <a data-type="xref" href="#row-oriented_grid_flow">Figure 12-44</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="row-oriented_grid_flow">&#13;
<img alt="image" src="assets/css5_1244.png"/>&#13;
<h6><span class="label">Figure 12-44. </span>Row-oriented grid flow</h6>&#13;
</div></figure>&#13;
&#13;
<p>This probably seems pretty normal, the same sort of thing you’d get if&#13;
you floated all the boxes, or if all of them were inline blocks. That familiarity is&#13;
why <code>row</code> is the default value. Now, let’s try switching the&#13;
<code>grid-auto-flow</code> value to <code>column</code>, as shown in <a data-type="xref" href="#column-oriented_grid_flow">Figure 12-45</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">45em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">8em</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-flow</code><code class="o">:</code> <code class="n">column</code><code class="p">;}</code>&#13;
<code class="nf">#grid</code> <code class="nt">li</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>So with <code>grid-auto-flow: row</code>, each row is filled in before starting on&#13;
the next row. With <code>grid-auto-flow: column</code>, each column is filled&#13;
first.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="column-oriented_grid_flow">&#13;
<img alt="image" src="assets/css5_1245.png"/>&#13;
<h6><span class="label">Figure 12-45. </span>Column-oriented grid flow</h6>&#13;
</div></figure>&#13;
&#13;
<p>What needs to be stressed here is that the list items weren’t explicitly&#13;
sized. By default, they were resized to attach to the defined grid&#13;
lines. This can be overridden by assigning explicit sizing to the&#13;
elements. For example, if we make the list items 7 ems wide and 1.5 ems&#13;
tall, we’ll get the result shown in <a data-type="xref" href="#explicitly_sized_grid_items">Figure 12-46</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">45em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">8em</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-flow</code><code class="o">:</code> <code class="n">column</code><code class="p">;}</code>&#13;
<code class="nf">#grid</code> <code class="nt">li</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">7em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">1.5em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="explicitly_sized_grid_items">&#13;
<img alt="image" src="assets/css5_1246.png"/>&#13;
<h6><span class="label">Figure 12-46. </span>Explicitly sized grid items</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you compare that to the previous figure, you’ll see that the&#13;
corresponding grid items start in the same place; they&#13;
just don’t end in the same places. This illustrates that what’s really&#13;
placed in grid flow is grid areas, to which the grid items are then&#13;
attached.</p>&#13;
&#13;
<p>This is important to keep in mind if you auto-flow elements that are&#13;
wider than their assigned column or taller than their assigned row, as&#13;
can very easily happen when turning images or other intrinsically sized&#13;
elements into grid items. Let’s say we want to put a bunch of images,&#13;
each a different size, into a grid that’s set up to have a column line&#13;
every 50 horizontal pixels, and a row line every 50 vertical pixels.&#13;
This grid is illustrated in <a data-type="xref" href="#flowing_images_in_grids">Figure 12-47</a>, along with the results of flowing&#13;
a series of images into that grid by either row or column:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="m">50px</code><code class="p">);</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">4</code><code class="o">,</code> <code class="m">50px</code><code class="p">);</code>&#13;
    <code class="k">grid-auto-rows</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-columns</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">img</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone width-50"><div class="figure" id="flowing_images_in_grids">&#13;
<img alt="image" src="assets/css5_1247.png"/>&#13;
<h6><span class="label">Figure 12-47. </span>Flowing images in grids</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that some of the images <a data-primary="grid layout" data-secondary="overlapping elements" data-type="indexterm" id="idm45176069095488"/><a data-primary="overlapping elements" data-secondary="grid items" data-type="indexterm" id="idm45176069094512"/>overlap others? That’s because each image&#13;
is attached to the next grid line in the flow, without taking into&#13;
account the presence of other grid items. We didn’t set up images to&#13;
span more than one grid track when they needed it, so overlap occurred.</p>&#13;
&#13;
<p>This can be managed with class names or other identifiers. We could&#13;
class images as <code>tall</code> or <code>wide</code> (or both) and specify that they get&#13;
more grid tracks. Here’s some CSS to add to the previous example, with&#13;
the result shown in <a data-type="xref" href="#giving_images_more_track_space">Figure 12-48</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.wide</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="nb">auto</code> <code class="o">/</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.tall</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="nb">auto</code> <code class="o">/</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="giving_images_more_track_space">&#13;
<img alt="css5 1248" src="assets/css5_1248.png"/>&#13;
<h6><span class="label">Figure 12-48. </span>Giving images more track space</h6>&#13;
</div></figure>&#13;
&#13;
<p>This does cause the images to keep spilling down the page, but no overlapping occurs.</p>&#13;
&#13;
<p>However, notice the gaps in this grid? That happens&#13;
because the placement of some grid items across grid lines doesn’t leave&#13;
enough room for other items in the flow. To illustrate this,&#13;
and the two flow patterns, more clearly, let’s try an example with&#13;
numbered boxes (<a data-type="xref" href="#illustrating_flow_patterns">Figure 12-49</a>).</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="illustrating_flow_patterns">&#13;
<img alt="image" src="assets/css5_1249.png"/>&#13;
<h6><span class="label">Figure 12-49. </span>Illustrating flow patterns</h6>&#13;
</div></figure>&#13;
&#13;
<p>Follow across the rows of the first grid, counting along with the&#13;
numbers. In this particular flow, the grid items are laid out almost as&#13;
if they were leftward floats. Almost, but not quite: notice that grid&#13;
item 13 is actually to the left of grid item 11. That would never happen&#13;
with floats, but it can with grid flow. The way row flow (if we may call&#13;
it that) works is that you go across each row from left to right, and if&#13;
there’s room for a grid item, you put it there. If a grid cell has been&#13;
occupied by another grid item, you skip over it. So the cell next to&#13;
item 10 didn’t get filled, because there wasn’t room for item 11. Item&#13;
13 went to the left of item 11 because there was room for it there when&#13;
the row was reached.</p>&#13;
&#13;
<p>As shown by the second example in <a data-type="xref" href="#illustrating_flow_patterns">Figure 12-49</a>,&#13;
the same basic mechanisms hold true for column flow, except in this case&#13;
you work from top to bottom. Thus, the cell below item 9 is empty&#13;
because item 10 wouldn’t fit there. Instead, item 10 went into the next column and&#13;
covered four grid cells (two in each direction). The items after it, since they were just one&#13;
grid cell in size, filled in the cells after it in column order.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Grid flow <a data-primary="writing modes (flow direction)" data-secondary="grid flow and" data-type="indexterm" id="idm45176068999312"/>works left to right, top to bottom in languages that&#13;
have that writing pattern. In RTL languages, such as Arabic&#13;
and Hebrew, the row-oriented flow would be right to left, not&#13;
left to right.</p>&#13;
</div>&#13;
&#13;
<p>If you were just now wishing for a way to pack grid items as densely as&#13;
possible, regardless of how that affected the ordering, good news: you&#13;
can! Just add the keyword <code>dense</code> to your <code>grid-auto-flow</code> value, and&#13;
that’s exactly what will happen. We can see the result in <a data-type="xref" href="#illustrating_dense_flow_patterns">Figure 12-50</a>,&#13;
which shows the results of <code>grid-auto-flow: row dense</code> and&#13;
<code>grid-auto-flow: dense column</code> side by side.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="illustrating_dense_flow_patterns">&#13;
<img alt="image" src="assets/css5_1250.png"/>&#13;
<h6><span class="label">Figure 12-50. </span>Illustrating dense flow patterns</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first grid, item 12 appears in the row above item 11 because&#13;
there was a <span class="keep-together">cell that</span> fit it. For the same reason, item 11 appears to&#13;
the left of item 10 in the second grid.</p>&#13;
&#13;
<p>In effect, what happens with <code>dense</code> grid flow is that for each grid&#13;
item, the browser scans through the <em>entire</em> grid in the given flow&#13;
direction (<code>row</code> or <code>column</code>), starting from the flow’s starting point&#13;
(the top-left corner in LTR languages), until it finds a place where&#13;
that grid item will fit. This can make things like photo galleries more&#13;
compact, and works great as long as you don’t have a specific order in&#13;
which the grid items need to appear.</p>&#13;
&#13;
<p>Now that we’ve explored grid flow, we have a confession to make: to make the last couple of grid items look right, we included some CSS&#13;
that we didn’t show you. Without it, the items hanging off the edge of&#13;
the grid would have looked quite a bit different from the other&#13;
items—much shorter in row-oriented flow, and much narrower in&#13;
column-oriented flow. You’ll see why, and the CSS we used, in the next&#13;
section.<a data-primary="" data-startref="ix_grid_auto_flow_prop" data-type="indexterm" id="idm45176068989216"/><a data-primary="" data-startref="ix_grid_flow" data-type="indexterm" id="idm45176068988240"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Defining Automatic Grid Tracks" data-type="sect1"><div class="sect1" id="automatic-grid-tracks">&#13;
<h1>Defining Automatic Grid Tracks</h1>&#13;
&#13;
<p>So far, we’ve <a data-primary="grid layout" data-secondary="grid tracks" data-tertiary="automatic" data-type="indexterm" id="ix_grid_track_auto"/>almost entirely seen grid items placed into a grid that&#13;
was explicitly defined. <a data-primary="implicit grid" data-type="indexterm" id="ix_implicit_grid2"/><a data-primary="grid layout" data-secondary="implicit grid" data-type="indexterm" id="ix_grid_implicit2"/>But in the preceding section we had grid items running off the edge of the explicitly defined grid. What&#13;
happens when a grid item goes off the edge? Rows or columns are added as&#13;
needed to satisfy the layout directives of the items in question (see <a data-type="xref" href="#the-implicit-grid">“Working with Implicit Grid”</a>). So, if an item with a row span of&#13;
<code>3</code> is added after the end of a row-oriented grid, three new rows are&#13;
added after the explicit grid.</p>&#13;
&#13;
<p>By <a data-primary="grid-auto-rows property" data-type="indexterm" id="ix_grid_auto_row_prop"/><a data-primary="grid-auto-columns property" data-type="indexterm" id="ix_grid_auto_col_prop"/>default, these automatically added grid tracks are the absolute minimum size&#13;
needed. If you want to exert a little more control over their sizing, <code>grid-auto-rows</code> and <code>grid-auto-columns</code> are for you.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176068976432">&#13;
<h1>grid-auto-rows, grid-auto-columns</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>track-breadth</code></em>&gt;+ | <code>minmax(</code> &lt;<em><code>track-breadth</code></em>&gt; <code>,</code> &lt;<em><code>track-breadth</code></em>&gt; <code>)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Depends on the specific track sizing</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>&lt;<em><code>track-breadth</code></em>&gt; is a stand-in for &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | &lt;<code><em>flex</em></code>&gt; | <br/><code>min-content</code> | <code>max-content</code> | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>For any automatically created row or column tracks, you can provide a&#13;
single track size or a minmaxed pair of track sizes. Let’s take a look&#13;
at a reduced version of the grid-flow example from the previous section:&#13;
we’ll set up a 2 × 2 grid and try to put five items into it. In fact,&#13;
let’s do it twice: once with <code>grid-auto-rows</code> and once without, as&#13;
illustrated in <a data-type="xref" href="#grids_auto-row_sizing">Figure 12-51</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">80px</code> <code class="m">80px</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">80px</code> <code class="m">80px</code><code class="p">;}</code>&#13;
<code class="nf">#g1</code> <code class="p">{</code><code class="k">grid-auto-rows</code><code class="o">:</code> <code class="m">80px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As the second grid shows, without assigning a size to the automatically created row, the overflowing grid&#13;
items are placed in a row that’s exactly as tall as the grid items’&#13;
content, and not a pixel more. Each is still just as wide as the column&#13;
into which it’s placed, because the columns have a size (<code>80px</code>). The row,&#13;
lacking an explicit height, defaults to <code>auto</code>, with the result shown.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grids_auto-row_sizing">&#13;
<img alt="css5 1251" src="assets/css5_1251.png"/>&#13;
<h6><span class="label">Figure 12-51. </span>Grids with and without auto-row sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>If we flip things to a column-oriented flow, the same basic principles apply (see <a data-type="xref" href="#grids_auto-column_sizing">Figure 12-52</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-auto-flow</code><code class="o">:</code> <code class="n">column</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">80px</code> <code class="m">80px</code><code class="p">;</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">80px</code> <code class="m">80px</code><code class="p">;}</code>&#13;
<code class="nf">#g1</code> <code class="p">{</code><code class="k">grid-auto-columns</code><code class="o">:</code> <code class="m">80px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grids_auto-column_sizing">&#13;
<img alt="image" src="assets/css5_1252.png"/>&#13;
<h6><span class="label">Figure 12-52. </span>Grids with and without auto-column sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this case, because the flow is column oriented, the last grid items are&#13;
placed into a new column past the end of the explicit grid. In the&#13;
second grid, where there’s no <code>grid-auto-columns</code>, those fifth and sixth items are each as&#13;
tall as their rows (<code>80px</code>), but have an <code>auto</code> width, so they’re just as wide&#13;
as they need to be, and no wider.</p>&#13;
&#13;
<p>Now you know what we used in the <code>grid-auto-flow</code> figures in the&#13;
previous section: we silently made the auto-rows and auto-columns the same&#13;
size as the explicitly sized columns, in order to not have the last&#13;
few grid items look weird. Let’s bring back one of those figures, only&#13;
this time the <code>grid-auto-rows</code> and <code>grid-auto-columns</code> styles will be&#13;
removed. As shown in <a data-type="xref" href="#auto-track_sizing_removed">Figure 12-53</a>, the last few items in each grid are&#13;
shorter or narrower than the rest, because of the lack of auto-track sizing.<a data-primary="" data-startref="ix_grid_auto_col_prop" data-type="indexterm" id="idm45176068864320"/><a data-primary="" data-startref="ix_grid_auto_row_prop" data-type="indexterm" id="idm45176068863376"/><a data-primary="" data-startref="ix_grid_implicit2" data-type="indexterm" id="idm45176068862432"/><a data-primary="" data-startref="ix_implicit_grid2" data-type="indexterm" id="idm45176068861488"/></p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="auto-track_sizing_removed">&#13;
<img alt="image" src="assets/css5_1253.png"/>&#13;
<h6><span class="label">Figure 12-53. </span>A previous figure with auto-track sizing removed</h6>&#13;
</div></figure>&#13;
&#13;
<p>And now you know…the rest of the story.<a data-primary="" data-startref="ix_grid_track_auto" data-type="indexterm" id="idm45176068858080"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the grid Shorthand" data-type="sect1"><div class="sect1" id="the-grid-shorthand">&#13;
<h1>Using the grid Shorthand</h1>&#13;
&#13;
<p>At long last, we’ve come to the <a data-primary="grid property" data-type="indexterm" id="ix_grid_prop"/><a data-primary="grid layout" data-secondary="shorthand property" data-type="indexterm" id="ix_grid_shorthand"/>shorthand property <code>grid</code>. It might just&#13;
surprise you, though, because it’s not like other shorthand properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176068851936">&#13;
<h1>grid</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | [ &lt;<code><em>grid-template-rows</em></code>&gt; / &lt;<code><em>grid-template-columns</em></code>&gt; ] | [ &lt;<code><em>line-names</em></code>&gt;? &lt;<code><em>string</em></code>&gt; &lt;<code><em>track-size</em></code>&gt;? &lt;<code><em>line-names</em></code>&gt;? ]+ [ / &lt;<em><code>track-list</code></em>&gt; ]? | [ &lt;<em><code>grid-auto-flow</code></em>&gt; [ &lt;<code><em>grid-auto-rows</em></code>&gt; [ / &lt;<em><code>grid-auto-columns</code></em>&gt; ]? ]? ]  ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Grid containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The syntax is a little bit migraine-inducing, yes, but we’ll step&#13;
through it a piece at a time.</p>&#13;
&#13;
<p>Let’s get to the elephant in the room right away: <code>grid</code> allows you to either&#13;
define a grid template <em>or</em> to set the grid’s flow and auto-track&#13;
sizing in a compact syntax. You can’t do both at the same time.</p>&#13;
&#13;
<p>Furthermore, whichever you don’t define is reset to its defaults,&#13;
as is normal for a shorthand property. So if you define the grid template,&#13;
the flow and auto tracks will be returned to their default values.</p>&#13;
&#13;
<p>Now let’s talk about creating a grid template by using <code>grid</code>. The values can&#13;
get fiendishly complex and take on some fascinating patterns, but can be&#13;
very handy in some situations. As an example, the following rule is equivalent to the set of&#13;
rules that follows it:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid</code><code class="o">:</code>&#13;
    <code class="s2">"header header header header"</code> <code class="m">3em</code>&#13;
    <code class="s2">". content sidebar ."</code> <code class="m">1</code><code class="n">fr</code>&#13;
    <code class="s2">"footer footer footer footer"</code> <code class="m">5em</code> <code class="o">/</code>&#13;
    <code class="m">2em</code> <code class="m">3</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">10em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;</code>&#13;
&#13;
<code class="c">/* the following together say the same thing as above */</code>&#13;
<code class="k">grid-template-areas</code><code class="o">:</code>&#13;
    <code class="s2">"header header header header"</code>&#13;
    <code class="s2">". content sidebar ."</code>&#13;
    <code class="s2">"footer footer footer footer"</code><code class="p">;</code>&#13;
<code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">3em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">5em</code><code class="p">;</code>&#13;
<code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">2em</code> <code class="m">3</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">10em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;</code></pre>&#13;
&#13;
<p>Notice how the value of <code>grid-template-rows</code> is broken up and scattered&#13;
around the strings of <code>grid-template-areas</code>. That’s how row sizing is&#13;
handled in <code>grid</code> when you have grid-area strings present. Take&#13;
those strings out, and you end up with the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid</code><code class="o">:</code>&#13;
     <code class="m">3em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">5em</code> <code class="o">/</code> <code class="m">2em</code> <code class="m">3</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">10em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;</code></pre>&#13;
&#13;
<p>In other words, the row tracks are separated by a forward slash (<code>/</code>) from the&#13;
column tracks.</p>&#13;
&#13;
<p>Remember that with <code>grid</code>, undeclared shorthands are reset to their defaults.&#13;
That means the following two rules are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#layout</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid</code><code class="o">:</code> <code class="m">3em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">5em</code> <code class="o">/</code> <code class="m">2em</code> <code class="m">3</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">10em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;}</code>&#13;
&#13;
<code class="nf">#layout</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid</code><code class="o">:</code> <code class="m">3em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">5em</code> <code class="o">/</code> <code class="m">2em</code> <code class="m">3</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">10em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-rows</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-columns</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-flow</code><code class="o">:</code> <code class="n">row</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Therefore, make sure your <code>grid</code> declaration comes before anything else&#13;
related to defining the grid.  If we want a dense column&#13;
flow, we’d write something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#layout</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid</code><code class="o">:</code> <code class="m">3em</code> <code class="m">1</code><code class="n">fr</code> <code class="m">5em</code> <code class="o">/</code> <code class="m">2em</code> <code class="m">3</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">10em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-flow</code><code class="o">:</code> <code class="n">dense</code> <code class="n">column</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now, let’s bring the named grid areas back, <em>and</em> add some&#13;
extra row grid-line names to the mix. A named grid line that goes <em>above</em>&#13;
a row track is written <em>before</em> the string, and a grid line that goes&#13;
<em>below</em> the row track comes <em>after</em> the string and any track sizing. So&#13;
let’s say we want to add <code>main-start</code> and <code>main-stop</code> above and below&#13;
the middle row, and <code>page-end</code> at the very bottom:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid</code><code class="o">:</code>&#13;
    <code class="s2">"header header header header"</code> <code class="m">3em</code>&#13;
    <code class="p">[</code><code class="n">main</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="s2">". content sidebar ."</code> <code class="m">1</code><code class="n">fr</code> <code class="p">[</code><code class="n">main</code><code class="o">-</code><code class="n">stop</code><code class="p">]</code>&#13;
    <code class="s2">"footer footer footer footer"</code> <code class="m">5em</code> <code class="p">[</code><code class="k">page</code><code class="o">-</code><code class="n">end</code><code class="p">]</code> <code class="o">/</code>&#13;
    <code class="m">2em</code> <code class="m">3</code><code class="n">fr</code> <code class="n">minmax</code><code class="p">(</code><code class="m">10em</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">)</code> <code class="m">2em</code><code class="p">;</code></pre>&#13;
&#13;
<p>That creates the grid shown in <a data-type="xref" href="#creating_grid_w_grid">Figure 12-54</a>, with the implicitly created&#13;
named grid lines (e.g., <code>footer-start</code>), along with the explicitly named&#13;
grid lines we wrote into the CSS.</p>&#13;
&#13;
<figure><div class="figure" id="creating_grid_w_grid">&#13;
<img alt="image" src="assets/css5_1254.png"/>&#13;
<h6><span class="label">Figure 12-54. </span>Creating a grid with the <code>grid</code> shorthand</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can see how <code>grid</code> values can get very complicated very quickly.&#13;
It’s a powerful syntax, and it’s surprisingly easy to get used to&#13;
once you’ve had just a bit of practice. On the other hand, it’s also&#13;
incredibly easy to get things wrong and have the entire value be invalid, thus&#13;
preventing the appearance of any grid at all.</p>&#13;
&#13;
<p>For the other use of <code>grid</code>, it’s a merging of <code>grid-auto-flow</code>,&#13;
<code>grid-auto-rows</code>, and <code>grid-auto-columns</code>. The following rules are&#13;
equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#layout</code> <code class="p">{</code><code class="k">grid-auto-flow</code><code class="o">:</code> <code class="n">dense</code> <code class="n">rows</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-rows</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code>&#13;
    <code class="k">grid-auto-columns</code><code class="o">:</code> <code class="n">minmax</code><code class="p">(</code><code class="m">1em</code><code class="o">,</code><code class="m">3em</code><code class="p">);}</code>&#13;
&#13;
<code class="nf">#layout</code> <code class="p">{</code><code class="k">grid</code><code class="o">:</code> <code class="n">dense</code> <code class="n">rows</code> <code class="m">2em</code> <code class="o">/</code> <code class="n">minmax</code><code class="p">(</code><code class="m">1em</code><code class="o">,</code><code class="m">3em</code><code class="p">);}</code></pre>&#13;
&#13;
<p>That’s certainly a lot less typing for the same result!  But once again,&#13;
we have to remind you: if you write this,  all the column and row track&#13;
properties will be set to their defaults.  Thus, the following rules are&#13;
equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#layout</code> <code class="p">{</code><code class="k">grid</code><code class="o">:</code> <code class="n">dense</code> <code class="n">rows</code> <code class="m">2em</code> <code class="o">/</code> <code class="n">minmax</code><code class="p">(</code><code class="m">1em</code><code class="o">,</code><code class="m">3em</code><code class="p">);}</code>&#13;
&#13;
<code class="nf">#layout</code> <code class="p">{</code><code class="k">grid</code><code class="o">:</code> <code class="n">dense</code> <code class="n">rows</code> <code class="m">2em</code> <code class="o">/</code> <code class="n">minmax</code><code class="p">(</code><code class="m">1em</code><code class="o">,</code><code class="m">3em</code><code class="p">);</code>&#13;
	<code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
	<code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>So once again, it’s important to make sure your shorthand comes before&#13;
any properties it might otherwise override.<a data-primary="" data-startref="ix_grid_shorthand" data-type="indexterm" id="idm45176068370336"/><a data-primary="" data-startref="ix_grid_prop" data-type="indexterm" id="idm45176068314720"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Subgrids" data-type="sect1"><div class="sect1" id="subgrid">&#13;
<h1>Using Subgrids</h1>&#13;
&#13;
<p>We promised many, many pages ago to talk <a data-primary="grid layout" data-secondary="subgrids" data-type="indexterm" id="ix_grid_subgrid"/>about <code>subgrid</code>, and at last the time has come.  The basic summary is that <em>subgrids</em> are grids that use the grid tracks of an ancestor grid to align their grid items, instead of a pattern unique to themselves.  A crude example is setting a number of columns on the <code>&lt;body&gt;</code> element, and then having all of the layout components use that grid, no matter how far down they are in the markup.</p>&#13;
&#13;
<p>Let’s see how that works.  We’ll start with a simple markup structure like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;body&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;header</code><code class="w"> </code><code class="na">class=</code><code class="s">"site"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;h1&gt;</code>ConHugeCo<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;nav&gt;</code>…<code class="nt">&lt;/nav&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/header&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;main&gt;</code><code class="w"/>&#13;
<code class="w">     </code>…<code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/main&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;footer</code><code class="w"> </code><code class="na">class=</code><code class="s">"site"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"…"</code><code class="w"> </code><code class="na">class=</code><code class="s">"logo"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;nav&gt;</code>…<code class="nt">&lt;/nav&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;div&gt;</code>…<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/footer&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/body&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>A real home page would have a lot more elements, but we’re keeping this brief for clarity’s sake.</p>&#13;
&#13;
<p>First, we add the following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">15</code><code class="o">,</code><code class="m">1</code><code class="n">fr</code><code class="p">);}</code></pre>&#13;
&#13;
<p>At this point, the body has 15 columns, each equally sized thanks to the <code>1fr</code> value.  Those columns are separated by 14 gutters, each 1% the width of the viewport.  (These are almost certainly desktop styles and not intended for mobile devices.)</p>&#13;
&#13;
<p>At the moment, the three children of the <code>&lt;body&gt;</code> element are trying to jam themselves into the first 3 of those 15 columns.  We don’t want that: we want them to span the width of the layout.  Well, we want the header and footer to do that.  The <code>&lt;main&gt;</code> element should actually stand away from the edges of the viewport by, say, one column on each side.</p>&#13;
&#13;
<p>So we add the following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:is</code><code class="o">(</code><code class="nt">header</code><code class="o">,</code> <code class="nt">footer</code><code class="o">)</code><code class="nc">.site</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;}</code>&#13;
<code class="nt">main</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;}</code></pre>&#13;
&#13;
<p>What we have so far is illustrated in <a data-type="xref" href="#subgrid_simple_setup">Figure 12-55</a>, with dashed lines added to represent the grid-column tracks set for the <code>&lt;body&gt;</code> element, and some extra content that wasn’t present in the initial markup code.  (You’ll see it in more detail soon.)</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_simple_setup">&#13;
<img alt="css5 1255" src="assets/css5_1255.png"/>&#13;
<h6><span class="label">Figure 12-55. </span>The initial setup of a page layout</h6>&#13;
</div></figure>&#13;
&#13;
<p>This might look like an entirely pointless exercise in defining and then ignoring a bunch of grid columns, but just wait.  It’s about to get good.</p>&#13;
&#13;
<p>Let’s take a closer look at the site header.  Here’s its full markup structure, minus the link URLs:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;header</code><code class="w"> </code><code class="na">class=</code><code class="s">"site"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;h1&gt;</code>ConHugeCo<code class="w"> </code>Industries<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;nav&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Home<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Mission<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Products<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Services<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Support<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Contact<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/nav&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/header&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Again, a real site would probably have a bit more to it, but this is enough to get the point across.  What we’re going to do now is turn the <code>&lt;header&gt;</code> element into a grid container that uses the <code>&lt;body&gt;</code> element’s grid tracks for itself:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nc">.site</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;}</code>&#13;
<code class="nt">header</code><code class="nc">.site</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="n">span</code> <code class="m">5</code><code class="p">;}</code>&#13;
<code class="nt">header</code><code class="nc">.site</code> <code class="nt">nav</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">7</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;</code>&#13;
     <code class="k">align-self</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code> <code class="k">text-align</code><code class="o">:</code> <code class="n">end</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In the first rule, we make the element into a grid container with <code>display: grid</code> and then says its column template is a <code>subgrid</code>.  At this point, the browser looks up through the markup tree to the closest grid container and uses the <code>grid-template-columns</code> of that ancestor (in this case, the <code>&lt;body&gt;</code>).  But this isn’t just a copy of the value.  The <code>&lt;header&gt;</code> element is literally using the body’s grid tracks for its column-oriented layout.</p>&#13;
&#13;
<p>Thus, when the second rule says the <code>&lt;h1&gt;</code> should start on column line 2 and span five column tracks, it starts on the body’s second column line and spans five of the body’s column lines.  Similarly, the <code>&lt;nav&gt;</code> element is set to span seven tracks back from the second-to-last column line of the  <code>&lt;body&gt;</code>.  <a data-type="xref" href="#subgrid_header">Figure 12-56</a> shows the results, along with the self-alignment and text alignment of the <code>&lt;nav&gt;</code> element and some shaded backgrounds to clearly indicate where the header’s pieces are being gridded.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_header">&#13;
<img alt="css5 1256" src="assets/css5_1256.png"/>&#13;
<h6><span class="label">Figure 12-56. </span>Placing the <code>header</code>’s pieces on the <code>body</code>’s columns</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that the pieces inside the header line up perfectly with the edges of the <code>&lt;main&gt;</code> element.  That’s because they’re all being placed on the exact same grid lines.  Not separate grid lines that just happen to coincide, but the actual grid lines.  This means that if, for example, the <code>&lt;body&gt;</code> element’s column template is changed to add a couple more columns, or to resize some of the columns to be wider or narrower, we just edit the <code>grid-template-columns</code> value for the <code>&lt;body&gt;</code>, and everything using those column lines will move along with the lines.</p>&#13;
&#13;
<p>We can do similar things with the footer.  Take this CSS, for example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">footer</code><code class="nc">.site</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;}</code>&#13;
<code class="nt">footer</code><code class="nc">.site</code> <code class="nt">img</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">5</code><code class="p">;}</code>&#13;
<code class="nt">footer</code><code class="nc">.site</code> <code class="nt">nav</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">9</code> <code class="o">/</code> <code class="m">-4</code><code class="p">;</code> <code class="p">}</code>&#13;
<code class="nt">footer</code><code class="nc">.site</code> <code class="nt">div</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now the logo in the footer is placed right alongside the fifth column line, the <code>&lt;nav&gt;</code> starts from the column line at the center of the layout and spans over a few tracks, and the <code>&lt;div&gt;</code> containing the legal bits ends at the very last column line and spans back two tracks.  <a data-type="xref" href="#subgrid_footer">Figure 12-57</a> shows the result.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_footer">&#13;
<img alt="css5 1257" src="assets/css5_1257.png"/>&#13;
<h6><span class="label">Figure 12-57. </span>Placing the <code>&lt;footer&gt;</code>’s pieces on the <code>&lt;body&gt;</code>’s columns</h6>&#13;
</div></figure>&#13;
&#13;
<p>Looking at it, maybe we’d prefer the legal stuff to be underneath the navlinks.  The usual solution in cases like this is to wrap the navlinks and legalese into a container such as a <code>&lt;div&gt;</code>, and then place that container on the grid columns.  But thanks to how <code>subgrid</code> works, this isn’t at all necessary!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Explicit Tracks" data-type="sect2"><div class="sect2" id="Subgrids_and_Explicit_Tracks">&#13;
<h2>Defining Explicit Tracks</h2>&#13;
&#13;
<p>A more <a data-primary="explicit grid" data-type="indexterm" id="idm45176067856240"/><a data-primary="subgrids" data-secondary="explicit tracks" data-type="indexterm" id="idm45176067855504"/>grid-like solution to the problem of placing footer pieces below others is to put them on their own rows.  So let’s do that:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">footer</code><code class="nc">.site</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">2</code><code class="o">,</code><code class="nb">auto</code><code class="p">);}</code>&#13;
<code class="nt">footer</code><code class="nc">.site</code> <code class="nt">img</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">5</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;}</code>&#13;
<code class="nt">footer</code><code class="nc">.site</code> <code class="nt">nav</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">9</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;</code> <code class="p">}</code>&#13;
<code class="nt">footer</code><code class="nc">.site</code> <code class="nt">div</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">7</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;</code> <code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This code has only three new things as compared to the last time we looked at it.  First, the <code>&lt;footer&gt;</code> itself is given a <code>grid-template-rows</code> value.  Second, the logo image is set to span the two rows defined in the first rule.  Third, the <code>grid-column</code> value of the <code>&lt;div&gt;</code> is changed so it spans the same column tracks the <code>&lt;nav&gt;</code> does.  It’s just expressed differently.  The <code>&lt;div&gt;</code> is also set to an explicit grid row.</p>&#13;
&#13;
<p>So while the <code>&lt;footer&gt;</code> continues to subgrid the column template of the <code>body</code> element, it also defines its own private row template.  Just two rows, in this case, but that’s all we need.  <a data-type="xref" href="#subgrid_footer_own_rows">Figure 12-58</a> shows the result, with a dashed line added to show the boundary between the <code>&lt;footer&gt;</code>’s two rows.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_footer_own_rows">&#13;
<img alt="css5 1258" src="assets/css5_1258.png"/>&#13;
<h6><span class="label">Figure 12-58. </span>Placing the <code>&lt;footer&gt;</code>’s pieces on the <code>&lt;body&gt;</code>’s columns</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dealing with Offsets" data-type="sect2"><div class="sect2" id="deadling_with_offsets">&#13;
<h2>Dealing with Offsets</h2>&#13;
&#13;
<p>Let’s turn <a data-primary="subgrids" data-secondary="offsets" data-type="indexterm" id="ix_subgrid_offset"/><a data-primary="offsets" data-secondary="subgrids" data-type="indexterm" id="ix_offset_subgrid"/>to the <code>&lt;main&gt;</code> element in this document, which contains this basic markup:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;main&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"gallery"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">               </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"…"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">               </code><code class="nt">&lt;h2&gt;</code>Title<code class="nt">&lt;/h2&gt;</code><code class="w"/>&#13;
<code class="w">               </code><code class="nt">&lt;p&gt;</code>Some<code class="w"> </code>descriptive<code class="w"> </code>text<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/main&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>As you saw previously, the <code>&lt;main&gt;</code> element is placed on the <code>&lt;body&gt;</code>’s grid as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This causes it to stretch from the <code>&lt;body&gt;</code>’s second grid column line to the second-to-last grid column line.  This pushes its sides inward by one column on either side.</p>&#13;
&#13;
<p>The contents within the <code>&lt;main&gt;</code> element are not participating in the <code>&lt;body&gt;</code> grid, because <code>&lt;main&gt;</code> isn’t a subgrid.  Well, not yet.  Let’s fix that by changing the rule to the following, with the result shown in <a data-type="xref" href="#subgrid_main_placement">Figure 12-59</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_main_placement">&#13;
<img alt="css5 1259" src="assets/css5_1259.png"/>&#13;
<h6><span class="label">Figure 12-59. </span>Placing the <code>&lt;main&gt;</code> element’s children on the <code>&lt;body&gt;</code>’s grid</h6>&#13;
</div></figure>&#13;
&#13;
<p>Again, this element is a subgrid of the body’s subgrid, but this time it isn’t stretched from one edge of the grid to the other.  The gallery <code>&lt;div&gt;</code> is taking up only one column, because it’s a grid item that hasn’t been assigned any grid column values.</p>&#13;
&#13;
<p>So here’s the question: what if we want move it one column track away from the edge of the <code>&lt;main&gt;</code> element?  That’s the third column line of the <code>&lt;body&gt;</code>, but the second inside the <code>&lt;main&gt;</code> element’s container.  Should it be <code>grid-column: 3</code> or <code>grid-column: 2</code>?</p>&#13;
&#13;
<p>The answer is <code>2</code>.  When counting grid lines within a subgrid, you account for only those grid lines inside it.  Thus, the following would have the result shown in <a data-type="xref" href="#subgrid_main_column_count">Figure 12-60</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now the gallery fills all but the start and end columns within the <code>&lt;main&gt;</code>’s container, by starting at the second grid line within the <code>&lt;main&gt;</code> and ending at the second-to-last grid line.  If we were to change the value to <code>3 / -3</code>, the gallery would stretch from the third column line with the <code>&lt;main&gt;</code> to the third-last, thus leaving two empty columns to either side.  But let’s not do that.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_main_column_count">&#13;
<img alt="css5 1260" src="assets/css5_1260.png"/>&#13;
<h6><span class="label">Figure 12-60. </span>Placing the gallery inward by a column on each side, and spanning &#13;
<span class="keep-together">several columns</span></h6>&#13;
</div></figure>&#13;
&#13;
<p>Instead, let’s now suppose we add five more cards to the gallery, for a total of six, and we’ll add some filler text rather than have each one just titled “Title” and so on.  If we do that and don’t change any of the CSS, we’ll just have six <code>&lt;div&gt;</code>s stacked on top of each other, because while the gallery is stretched across the <code>&lt;main&gt;</code>’s subgrid, it isn’t a subgrid (or even a not-subgrid), so its interior is a normal-flow environment.</p>&#13;
&#13;
<p>We can fix that with—yes—more subgridding!</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;</code> <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now the gallery is a subgrid of its nearest ancestor element that defines a not-subgridded column template, which is the <code>&lt;body&gt;</code> element, and thus the cards within the gallery will use the column template of the <code>&lt;body&gt;</code>.  We want them to fill out the gallery, which has 12 tracks within it, so we’ll have them each span 2 tracks, with the results shown in <a data-type="xref" href="#subgrid_gallery_cards">Figure 12-61</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
     <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#FFF8</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_gallery_cards">&#13;
<img alt="css5 1261" src="assets/css5_1261.png"/>&#13;
<h6><span class="label">Figure 12-61. </span>Adding multiple cards to the subgridded gallery</h6>&#13;
</div></figure>&#13;
&#13;
<p>Not bad, but it could be better.  That last card has a longer title, and it’s wrapped to two lines.  That means all the descriptive text paragraphs don’t line up with one another.  How do we fix that?  The same way we did for the footer: by defining a row template for the gallery, and making the cards subgrid to that row template!</p>&#13;
&#13;
<p>We start by defining the row template with some named lines and track sizes:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;</code>&#13;
	<code class="k">grid-template-rows</code><code class="o">:</code> <code class="p">[</code><code class="n">pic</code><code class="p">]</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="p">[</code><code class="n">title</code><code class="p">]</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="p">[</code><code class="n">desc</code><code class="p">]</code> <code class="nb">auto</code><code class="p">;</code>&#13;
     <code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now, each card needs to span the row template so that the row lines will be available to it:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code>&#13;
     <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now that the cards span from the gallery’s first row line to its last, we’re ready to have the cards become grid containers with a single column and a subgrid of the gallery’s row &#13;
<span class="keep-together">template:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code>&#13;
     <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;</code>&#13;
     <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-rows</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code><code class="p">;}</code></pre>&#13;
&#13;
<p>We didn’t really need to add the <code>grid-template-columns</code> declaration, because it would default to a single column, but sometimes it’s nice to explicitly say what it is you want to happen, so anyone responsible for the CSS after you write it (including you in six months) doesn’t have to guess at what you meant to do.</p>&#13;
&#13;
<p>At the moment, the elements inside each card will automatically fall into the row tracks: the images into the <code>pic</code> track, the titles into the <code>title</code> track, and the paragraphs into the <code>desc</code> track.  But since we’re trying to be self-documenting, let’s explicitly assign each element to its named track, and while we’re at it, vertically align the titles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="nt">img</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">pic</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="nt">h2</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">title</code><code class="p">;</code> <code class="k">align-self</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="nt">p</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">desc</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#subgrid_gallery_card_rows">Figure 12-62</a> shows the final result, with the titles vertically centered with respect to one another, the descriptive paragraphs all lined up along their top edges, and all the cards sharing the same height.</p>&#13;
&#13;
<p>A big advantage here is that with the pieces of the cards explicitly assigned to the named grid row lines, rearranging the cards is now merely a question of editing the <code>grid-row-template</code> value set on the gallery.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_gallery_card_rows">&#13;
<img alt="css5 1262" src="assets/css5_1262.png"/>&#13;
<h6><span class="label">Figure 12-62. </span>Placing card items on subgridded rows</h6>&#13;
</div></figure>&#13;
&#13;
<p>We could also have made the cards’ column template a subgrid, which would have meant they’d use the <code>&lt;body&gt;</code> element’s column template, because the body is the nearest ancestor element with a column template that isn’t a subgrid.  In that case, the cards would use the gallery’s row template and the body’s column template.  And they’d all influence the sizing of those ancestors’ grid tracks, and thus influence the layout of everything else that uses those same templates.</p>&#13;
&#13;
<p>If you have more cards than will fit into a single row, you’ll run into a problem: subgrids do <em>not</em> create implicit grid tracks.  Instead, you need to use the auto-track properties like <code>grid-auto-rows</code>, which will add as many rows as needed.</p>&#13;
&#13;
<p>Thus, we’ll need to remove the line names and rework the CSS we’ve built to read as &#13;
<span class="keep-together">follows:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;</code>&#13;
	<code class="k">grid-auto-rows</code><code class="o">:</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="nb">auto</code><code class="p">;</code>&#13;
	<code class="c">/* was: [pic] max-content [title] max-content [desc] auto */</code>&#13;
     <code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code>&#13;
     <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;</code>&#13;
     <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-rows</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The problem now is that we have the picture, title, and description text each assigned to a named grid line, but <code>grid-auto-rows</code> doesn’t allow line names.  It might look like we have to change the grid row assignments, but that’s not the case, as you’re about to see.<a data-primary="" data-startref="ix_offset_subgrid" data-type="indexterm" id="idm45176067263952"/><a data-primary="" data-startref="ix_subgrid_offset" data-type="indexterm" id="idm45176067178768"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Naming Subgridded Lines" data-type="sect2"><div class="sect2" id="naming_subgridded_lines">&#13;
<h2>Naming Subgridded Lines</h2>&#13;
&#13;
<p>In addition to using the <a data-primary="subgrids" data-secondary="naming lines" data-type="indexterm" id="ix_subgrid_name_line"/>names of any grid lines in the ancestor template, you can assign names to the subgrid, which is a real help if you’re using auto-tracks like those created in the previous section.</p>&#13;
&#13;
<p>In this case, since we used to have row lines named <code>pic</code>, <code>title</code>, and <code>desc</code> in the parent grid but had to remove them in order to set up auto-rows, we take those same labels and put them after the <code>subgrid</code> keyword for <code>grid-template-rows</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">grid-template-rows</code><code class="o">:</code> <code class="n">subgrid</code> <code class="p">[</code><code class="n">pic</code><code class="p">]</code> <code class="p">[</code><code class="n">title</code><code class="p">]</code> <code class="p">[</code><code class="n">desc</code><code class="p">];</code></pre>&#13;
&#13;
<p>Here’s what that looks like in context with the rest of the CSS for these cards, which are laid out as shown in <a data-type="xref" href="#gallery-cards-rows-repeat">Figure 12-63</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code> <code class="n">subgrid</code><code class="p">;</code>&#13;
	<code class="k">grid-auto-rows</code><code class="o">:</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code> <code class="nb">auto</code><code class="p">;</code>&#13;
     <code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">span</code> <code class="m">2</code><code class="p">;</code>&#13;
     <code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="m">-1</code><code class="p">;</code>&#13;
     <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-rows</code><code class="o">:</code> <code class="n">subgrid</code> <code class="p">[</code><code class="n">pic</code><code class="p">]</code> <code class="p">[</code><code class="n">title</code><code class="p">]</code> <code class="p">[</code><code class="n">desc</code><code class="p">];</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">1</code><code class="n">fr</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="nt">img</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">pic</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="nt">h2</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">title</code><code class="p">;</code> <code class="k">align-self</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nt">div</code> <code class="nt">p</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="n">desc</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="gallery-cards-rows-repeat">&#13;
<img alt="css5 1263" src="assets/css5_1263.png"/>&#13;
<h6><span class="label">Figure 12-63. </span>Placing cards onto auto-rows with named lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s also possible to assign names to just a few lines while not naming the rest.  To see this in action, let’s add a couple of paragraphs of text below the gallery, something like this (with ellipsis-enclosed text in place of the actual content):</p>&#13;
<pre data-code-language="html" data-type="programlisting">&#13;
<code class="p">&lt;</code><code class="nt">main</code><code class="p">&gt;</code><code>&#13;
	</code><code class="p">&lt;</code><code class="nt">div</code><code> </code><code class="na">class</code><code class="o">=</code><code class="s">"gallery"</code><code class="p">&gt;</code><code>&#13;
		</code><em><code>…cards here…</code></em><code>&#13;
	</code><code class="p">&lt;</code><code class="p">/</code><code class="nt">div</code><code class="p">&gt;</code><code>&#13;
	</code><code class="p">&lt;</code><code class="nt">p</code><code> </code><code class="na">class</code><code class="o">=</code><code class="s">"leadin"</code><code class="p">&gt;</code><code>…text…</code><code class="p">&lt;</code><code class="p">/</code><code class="nt">p</code><code class="p">&gt;</code><code>&#13;
	</code><code class="p">&lt;</code><code class="nt">p</code><code> </code><code class="na">class</code><code class="o">=</code><code class="s">"explore"</code><code class="p">&gt;</code><code>…text…</code><code class="p">&lt;</code><code class="p">/</code><code class="nt">p</code><code class="p">&gt;</code><code>&#13;
</code><code class="p">&lt;</code><code class="p">/</code><code class="nt">main</code><code class="p">&gt;</code><code>&#13;
</code></pre>&#13;
&#13;
<p>To span the paragraphs across various column tracks, we could count and use numbers, but let’s name some lines and use those instead.  In this case, since these paragraphs are children of the <code>&lt;main&gt;</code> element, we’ll need to modify its subgridded column template.  Here’s how we’ll do it:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;</code>&#13;
     <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
          <code class="n">subgrid</code> <code class="p">[]</code> <code class="p">[</code><code class="n">leadin</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="p">[])</code>&#13;
          <code class="p">[</code><code class="n">leadin</code><code class="o">-</code><code class="n">end</code> <code class="n">explore</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="p">[])</code>&#13;
          <code class="p">[</code><code class="n">explore</code><code class="o">-</code><code class="n">end</code><code class="p">];</code>&#13;
     <code class="p">}</code></pre>&#13;
&#13;
<p>OK, whoa.  What just happened?</p>&#13;
&#13;
<p>Here’s how it breaks down: after the <code>subgrid</code> keyword, we have a bunch of name assignments.  The first is just <code>[]</code>, which means “don’t add a name to this grid line.”  Then we have <code>[leadin-start]</code>, which assigns the name <code>leadin-start</code> to the second grid column line in the subgrid.  After that is a repetition that means the next five grid column lines get no subgrid name assigned.</p>&#13;
&#13;
<p>Next up is what happens to be the line running down the middle of the grid, which is given both the name <code>leadin-end</code> and <code>explore-start</code>.  This means the lead-in paragraph should stop spanning at this line, and the explore paragraph should start spanning at the same line.  After another five no-name-assigned lines, we assign <code>explore-end</code> to a line, and that’s it.  Any lines that weren’t addressed will be left alone.</p>&#13;
&#13;
<p>Now all we have to do is set the paragraphs’ start and end column lines like so, and get the result shown in <a data-type="xref" href="#subgrid_main_named_lines">Figure 12-64</a>, where the two cards on the second line of cards have been removed for clarity:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.leadin</code>  <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">leadin</code><code class="o">-</code><code class="n">start</code> <code class="o">/</code>  <code class="n">leadin</code><code class="o">-</code><code class="n">end</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.explore</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="n">explore</code><code class="o">-</code><code class="n">start</code> <code class="o">/</code> <code class="n">explore</code><code class="o">-</code><code class="n">end</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_main_named_lines">&#13;
<img alt="css5 1264" src="assets/css5_1264.png"/>&#13;
<h6><span class="label">Figure 12-64. </span>Placing elements using subgrid-named grid lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>And there they are, using their custom-named start and end grid lines to span across many grid tracks.  As promised, the first ends where the second starts, right on that grid line that happens to be in the middle of the layout.</p>&#13;
&#13;
<p>Having the cards jam right up next to each other doesn’t look great, though.  We could push the actual text apart by using padding on the paragraphs, but some gaps would be nice, wouldn’t they?<a data-primary="" data-startref="ix_subgrid_name_line" data-type="indexterm" id="idm45176066815280"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Giving Subgrids Their Own Gaps" data-type="sect2"><div class="sect2" id="subgrids_and_gaps">&#13;
<h2>Giving Subgrids Their Own Gaps</h2>&#13;
&#13;
<p>It’s possible to set <a data-primary="subgrids" data-secondary="gaps for" data-type="indexterm" id="ix_subgrid_gaps"/><a data-primary="gaps" data-secondary="subgrids" data-type="indexterm" id="ix_gaps_subgrid"/>gaps on subgrids that are separate from any gaps on their ancestor grids.  Thus, for example, we could extend our previous example like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="p">{</code><code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">-2</code><code class="p">;</code>&#13;
     <code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
     <code class="k">grid-template-columns</code><code class="o">:</code>&#13;
          <code class="n">subgrid</code> <code class="p">[]</code> <code class="p">[</code><code class="n">leadin</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="p">[])</code>&#13;
          <code class="p">[</code><code class="n">leadin</code><code class="o">-</code><code class="n">end</code> <code class="n">explore</code><code class="o">-</code><code class="n">start</code><code class="p">]</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="p">[])</code>&#13;
          <code class="p">[</code><code class="n">explore</code><code class="o">-</code><code class="n">end</code><code class="p">];</code>&#13;
     <code class="n">gap</code><code class="o">:</code> <code class="m">0</code> <code class="m">2em</code><code class="p">;</code>&#13;
     <code class="p">}</code></pre>&#13;
&#13;
<p>With this change, the <code>&lt;main&gt;</code> element is setting no row gaps but 2-em column gaps.  This has the result shown in <a data-type="xref" href="#subgrid_grid_gaps">Figure 12-65</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="subgrid_grid_gaps">&#13;
<img alt="css5 1265" src="assets/css5_1265.png"/>&#13;
<h6><span class="label">Figure 12-65. </span>The effect of adding gaps to a subgrid</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that not only are the two paragraphs pushed apart, but so are the cards in the gallery.  That’s because they’re all participating in the same subgrid, and that subgrid just had some gaps added to it.  This means the sides of the cards and the side of the paragraphs are still lined up precisely with each other, which is pretty nice.</p>&#13;
&#13;
<p>Note also that these gaps don’t apply to the content in ancestor grids: the boxes in the header and footer still come right up to the center column line.  It’s only the elements in the <code>&lt;main&gt;</code> element’s subgrid, and any subgrids of that subgrid, that will know about and make use of these gaps.<a data-primary="" data-startref="ix_grid_subgrid" data-type="indexterm" id="idm45176066693856"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If gaps aren’t familiar to you, the properties <code>row-gap</code>, <code>column-gap</code>, and <code>gap</code> are covered in <a data-type="xref" href="ch11.html#flexbox">Chapter 11</a>.<a data-primary="" data-startref="ix_gaps_subgrid" data-type="indexterm" id="idm45176066689504"/><a data-primary="" data-startref="ix_subgrid_gaps" data-type="indexterm" id="idm45176066688528"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grid Items and the Box Model" data-type="sect1"><div class="sect1" id="grid-items-and-the-box-model">&#13;
<h1>Grid Items and the Box Model</h1>&#13;
&#13;
<p>Now we can create a <a data-primary="box model" data-type="indexterm" id="ix_box_model"/><a data-primary="grid layout" data-secondary="box model and" data-type="indexterm" id="ix_grid_box_model"/><a data-primary="boxes" data-secondary="grid layout and box model" data-type="indexterm" id="ix_box_grid_layout"/>grid, attach items to the grid, create&#13;
gutters between the grid tracks, and even use the track templates of ancestor elements.&#13;
But what happens if we style a grid item with, say, margins? Or if it’s&#13;
absolutely positioned? How do these things interact with the grid lines?</p>&#13;
&#13;
<p class="pagebreak-before">Let’s take <a data-primary="margins" data-secondary="grid layout" data-type="indexterm" id="ix_margins_grid"/><a data-primary="grid layout" data-secondary="margins and grid" data-type="indexterm" id="ix_grid_margins"/>margins first. The basic principle at work is that an element&#13;
is attached to the grid by its margin edges. That means you can push the&#13;
visible parts of the element inward from the grid area it occupies by&#13;
setting positive margins—and pull it outward with negative margins. For&#13;
example, these styles will have the result shown in <a data-type="xref" href="#grid_items_with_margins">Figure 12-66</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">2</code><code class="o">,</code> <code class="m">100px</code><code class="p">);</code>&#13;
    <code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">2</code><code class="o">,</code> <code class="m">200px</code><code class="p">);}</code>&#13;
<code class="nc">.box02</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">25px</code><code class="p">;}</code>&#13;
<code class="nc">.box03</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">-25px</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grid_items_with_margins">&#13;
<img alt="css5 1266" src="assets/css5_1266.png"/>&#13;
<h6><span class="label">Figure 12-66. </span>Grid items with margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>This works as it does because the items have both their <code>width</code> and&#13;
<code>height</code> set to <code>auto</code>, so they can be stretched as needed to make&#13;
everything work out. If <code>width</code> and/or <code>height</code> have non-<code>auto</code> values, they’ll end up overriding margins to make all the math work out.&#13;
This is much like what happens with inline margins when element&#13;
sizing is overconstrained: eventually, one of the margins gets overridden.</p>&#13;
&#13;
<p>Consider an element with the following styles placed into a 200-pixel-wide by 100-pixel-tall grid area:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.exel</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">150px</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Going across the element first, it has 10 pixels of margin to either&#13;
side, and its <code>width</code> is <code>150px</code>, giving a total of 170 pixels.&#13;
Something’s gotta give, and in this case it’s the right margin (in&#13;
LTR languages), which is changed to <code>40px</code> to make everything&#13;
work—10 pixels on the left margin, 150 pixels on the content box, and 40&#13;
pixels on the right margin equals the 200 pixels of the grid area’s&#13;
width.</p>&#13;
&#13;
<p>On the vertical axis, the bottom margin is reset to <code>-10px</code>. This&#13;
compensates for the top margin and content height totaling 110 pixels,&#13;
when the grid area is only 100 pixels tall.</p>&#13;
<div class="less_space pagebreak-before" data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Margins on grid items are ignored when calculating grid-track&#13;
sizes. Therefore, no matter how big or small you make a grid item’s&#13;
margins, it won’t change the sizing of a <code>min-content</code> column, for&#13;
example, nor will increasing the margins on a grid item cause <code>fr</code>-sized&#13;
grid tracks to change size.</p>&#13;
</div>&#13;
&#13;
<p>As with block layout, you can selectively use <code>auto</code> margins to decide&#13;
which margin will have its value changed to fit. Suppose we wanted the&#13;
grid item to align to the right of its grid area. By setting the item’s&#13;
left margin to <code>auto</code>, that would happen:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.exel</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">150px</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">margin-left</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now the element will add up 160 pixels for the right margin and content&#13;
box, and then give the difference between that and the grid area’s width&#13;
to the left margin, since it’s been explicitly set to <code>auto</code>. This results in <a data-type="xref" href="#using_auto_margins_to_align_items">Figure 12-67</a>, with 10 pixels of margin on&#13;
each side of the <code>exel</code> item, except the left margin, which is (as we&#13;
just calculated) 40 pixels.</p>&#13;
&#13;
<figure><div class="figure" id="using_auto_margins_to_align_items">&#13;
<img alt="image" src="assets/css5_1267.png"/>&#13;
<h6><span class="label">Figure 12-67. </span>Using auto margins to align items</h6>&#13;
</div></figure>&#13;
&#13;
<p>That alignment process might seem familiar from block-level layout, where you can use&#13;
<code>auto</code> inline margins to center an element in its containing&#13;
block, as long as you’ve given it an explicit <code>width</code>. Grid layout&#13;
differs in that you can do the same thing on the vertical axis; that is,&#13;
given an element with an absolute height, you can vertically center it&#13;
by setting the top and bottom margins to <code>auto</code>. <a data-type="xref" href="#various_auto-margin_alignments">Figure 12-68</a> shows a&#13;
variety of <code>auto</code> margin effects on images, which inherently have&#13;
explicit heights and widths:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.i01</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code>&#13;
<code class="nc">.i02</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">margin-left</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nc">.i03</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="nb">auto</code> <code class="m">10px</code> <code class="nb">auto</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nc">.i04</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nc">.i05</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="nb">auto</code> <code class="nb">auto</code> <code class="m">0</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nc">.i06</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="various_auto-margin_alignments">&#13;
<img alt="image" src="assets/css5_1268.png"/>&#13;
<h6><span class="label">Figure 12-68. </span>Various auto-margin alignments</h6>&#13;
</div></figure>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>CSS has other ways to align grid items, notably with properties&#13;
like <code>justify-self</code>, which don’t depend on having explicit element sizes or auto margins. These are covered in the next section.</p>&#13;
</div>&#13;
&#13;
<p>This auto-margin behavior is a lot like the way margins and element sizes operate when elements&#13;
are absolutely positioned—which leads us to the next question: what if&#13;
a grid item is <em>also</em> absolutely positioned? For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.exel</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="m">5</code><code class="p">;</code>&#13;
    <code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code>&#13;
    <code class="k">top</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">15%</code><code class="p">;</code>&#13;
    <code class="k">left</code><code class="o">:</code> <code class="m">35px</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">1rem</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The answer is actually pretty elegant: if you’ve defined grid-line&#13;
starts and ends <em>and</em> the grid container establishes a positioning content (e.g., using <code>position: relative</code>),&#13;
that grid area is used as the containing block and&#13;
positioning context for the grid, and so the grid item is positioned <em>within</em> that&#13;
context. That means the offset properties (<code>top</code> et al.) are calculated&#13;
in relation to the declared grid area. Thus, the previous CSS would have&#13;
the result shown in <a data-type="xref" href="#absolutely_positioning_a_grid_item">Figure 12-69</a>, with the lightly shaded area denoting grid area used as the positioning context, and the thick-bordered box denoting the absolutely positioned &#13;
<span class="keep-together">grid item.</span></p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="absolutely_positioning_a_grid_item">&#13;
<img alt="css5 1269" src="assets/css5_1269.png"/>&#13;
<h6><span class="label">Figure 12-69. </span>Absolutely positioning a grid item</h6>&#13;
</div></figure>&#13;
&#13;
<p>Everything you know about absolutely positioned elements regarding&#13;
offsets, margins, element sizing, and so on applies within this&#13;
formatting context. It’s just that in this case, the formatting context&#13;
is defined by a grid area.<a data-primary="" data-startref="ix_grid_margins" data-type="indexterm" id="idm45176066346928"/><a data-primary="" data-startref="ix_margins_grid" data-type="indexterm" id="idm45176066345952"/> Absolute <a data-primary="grid layout" data-secondary="absolute positioning" data-type="indexterm" id="idm45176066344880"/><a data-primary="absolute positioning" data-secondary="grid items" data-type="indexterm" id="idm45176066343904"/>positioning introduces a wrinkle: it changes the behavior of the <code>auto</code> value for grid-line properties. If,&#13;
for example, you set <code>grid-column-end: auto</code> for an&#13;
absolutely positioned grid item, the ending grid line will actually&#13;
create a new and special grid line that corresponds to the padding edge&#13;
of the grid container itself. This is true even if the explicit grid is&#13;
smaller than the grid container, as can happen. To see this in action, we’ll modify the previous example as follows,&#13;
with the result shown in <a data-type="xref" href="#auto_values_and_absolute_positioning">Figure 12-70</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.exel</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code>&#13;
    <code class="k">top</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">15%</code><code class="p">;</code>&#13;
    <code class="k">left</code><code class="o">:</code> <code class="m">35px</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">1rem</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="auto_values_and_absolute_positioning">&#13;
<img alt="css5 1270" src="assets/css5_1270.png"/>&#13;
<h6><span class="label">Figure 12-70. </span>Auto values and absolute positioning</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice how the positioning context now starts at the top of the grid&#13;
container (the thin black line around the outside of the figure), and stretches all the way to the right edge of the grid&#13;
container, even though the grid itself ends short of that edge.</p>&#13;
&#13;
<p>One implication of this behavior is that if you absolutely position an element that’s a grid item, but you don’t give it any grid-line start or end values, then it will use the inner padding edge of the grid container as its positioning context. It does this without having to set the grid container to <code>position: relative</code>, or any of the other usual&#13;
tricks to establish a positioning context.</p>&#13;
&#13;
<p>Also note that absolutely positioned grid items do <em>not</em> participate in figuring&#13;
out grid cell and track sizing. As far as the grid layout is concerned,&#13;
the positioned grid item doesn’t exist. Once the grid is set up, the grid item is positioned with respect to the grid lines that define&#13;
its positioning context.<a data-primary="" data-startref="ix_box_grid_layout" data-type="indexterm" id="idm45176066273184"/><a data-primary="" data-startref="ix_box_model" data-type="indexterm" id="idm45176066272208"/><a data-primary="" data-startref="ix_grid_box_model" data-type="indexterm" id="idm45176066271264"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Alignment in Grids" data-type="sect1"><div class="sect1" id="aligning-and-grids">&#13;
<h1>Setting Alignment in Grids</h1>&#13;
&#13;
<p>If you have any <a data-primary="grid layout" data-secondary="alignment" data-type="indexterm" id="ix_grid_align"/><a data-primary="alignment" data-secondary="grid items" data-type="indexterm" id="ix_align_grid"/>familiarity with flexbox (see <a data-type="xref" href="ch11.html#flexbox">Chapter 11</a>), you’re probably aware of the&#13;
various alignment properties and their values. Those same properties are&#13;
also available in grid layout and have very similar effects.</p>&#13;
&#13;
<p>First, a quick <a data-primary="inline formatting" data-secondary="box model and" data-type="indexterm" id="ix_inline_format_box_mod"/>refresher. <a data-type="xref" href="#grid_layout_properties">Table 12-1</a> summarizes the alignment properties that are available and what&#13;
they affect.  Note there are a few more than you might have expected from &#13;
<span class="keep-together">flexbox.</span></p>&#13;
<table id="grid_layout_properties">&#13;
<caption><span class="label">Table 12-1. </span>Justify and align values</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Property</th>&#13;
<th>Aligns</th>&#13;
<th>Applies to</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>align-content</code></p></td>&#13;
<td><p>The entire grid in the block direction</p></td>&#13;
<td><p>Grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>align-items</code></p></td>&#13;
<td><p>All grid items in the block direction</p></td>&#13;
<td><p>Grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>align-self</code></p></td>&#13;
<td><p>A grid item in the block direction</p></td>&#13;
<td><p>Grid items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>justify-content</code></p></td>&#13;
<td><p>The entire grid in the inline direction</p></td>&#13;
<td><p>Grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>justify-items</code></p></td>&#13;
<td><p>All grid items in the inline direction</p></td>&#13;
<td><p>Grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>justify-self</code></p></td>&#13;
<td><p>A grid item in the inline direction</p></td>&#13;
<td><p>Grid items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>place-content</code></p></td>&#13;
<td><p>The entire grid in both the block and inline directions</p></td>&#13;
<td><p>Grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>place-items</code></p></td>&#13;
<td><p>All grid items in both the block and inline directions</p></td>&#13;
<td><p>Grid container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>place-self</code></p></td>&#13;
<td><p>A grid item in both the block and inline directions</p></td>&#13;
<td><p>Grid items</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>As <a data-type="xref" href="#grid_layout_properties">Table 12-1</a> shows, the various <code>justify-*</code> properties change alignment&#13;
along the inline axis—in English, this will be the horizontal direction.&#13;
The difference is whether a property applies to a single grid item, all&#13;
the grid items in a grid, or the entire grid. Similarly, the&#13;
<code>align-*</code> properties affect alignment along the block axis; in English,&#13;
this is the vertical direction.  The <code>place-*</code> properties, on the other hand,&#13;
are shorthands that apply in both the block and inline directions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Aligning and Justifying Individual Items" data-type="sect2"><div class="sect2" id="aligning-and-justifying-individual-items">&#13;
<h2>Aligning and Justifying Individual Items</h2>&#13;
&#13;
<p>It’s easiest to <a data-primary="justified items, grid layout" data-type="indexterm" id="ix_justified_grid_items"/>start with the <code>*-self</code> properties, because we can have&#13;
one grid show various <code>justify-self</code> property values, <a data-primary="justify-self property" data-type="indexterm" id="idm45176066228336"/><a data-primary="align-self property" data-type="indexterm" id="idm45176066227600"/>while a second&#13;
grid shows the effects of those same values when used by <code>align-self</code>.&#13;
(See <a data-type="xref" href="#self_alignment_in_the_inline_and_block_directions">Figure 12-71</a>.)</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="self_alignment_in_the_inline_and_block_directions">&#13;
<img alt="image" src="assets/css5_1271.png"/>&#13;
<h6><span class="label">Figure 12-71. </span>Self-alignment in the inline and block directions</h6>&#13;
</div></figure>&#13;
&#13;
<p>Each grid item in <a data-type="xref" href="#self_alignment_in_the_inline_and_block_directions">Figure 12-71</a> is shown with its grid area (the dashed line) and a label identifying the property value that’s applied to it.&#13;
Each deserves a bit of <span class="keep-together">commentary.</span></p>&#13;
&#13;
<p>First, though, realize that for all of these values, any element that&#13;
doesn’t have an explicit <code>width</code> or <code>height</code> will “shrink-wrap” its&#13;
content, instead of using the default grid-item behavior of filling out the&#13;
entire grid area.</p>&#13;
&#13;
<p>The <code>start</code> and <code>end</code> values cause the grid item to be aligned to the start or end&#13;
edge of its grid area, which makes sense. Similarly, <code>center</code> centers&#13;
the grid item within its area along the alignment axis, <em>without</em> the&#13;
need to declare margins or any other properties, including <code>height</code>&#13;
and <code>width</code>.</p>&#13;
&#13;
<p>The <code>left</code> and <code>right</code> values cause the item to be aligned to the left or right edge of the grid area when the inline axis is horizontal, as shown in <a data-type="xref" href="#self_alignment_in_the_inline_and_block_directions">Figure 12-71</a>.  If the inline axis is vertical, as in <code>writing-mode: vertical-rl</code>, items are aligned along the inline axis as if the inline axis were still horizontal; thus, in a top-to-bottom inline axis, <code>left</code> will align to the top of the grid area <a data-primary="direction property" data-type="indexterm" id="idm45176066213392"/>when <code>direction</code> is <code>ltr</code>, and to its bottom when <code>direction</code> is <code>rtl</code>.  When applied to <code>align-self</code>, <code>left</code> and <code>right</code> are treated as if they were <code>stretch</code>.</p>&#13;
&#13;
<p>The <code>self-start</code> and <code>self-end</code> values are more interesting. The <code>self-start</code> option aligns a&#13;
grid item with the grid-area edge that corresponds to the grid <em>item’s</em>&#13;
start edge. So in <a data-type="xref" href="#self_alignment_in_the_inline_and_block_directions">Figure 12-71</a>, the <code>self-start</code> and <code>self-end</code> boxes are&#13;
set to <code>direction: rtl</code>. That sets them to use RTL language&#13;
direction, meaning their start edges are their right edges, and their&#13;
end edges their left. You can see in the first grid this&#13;
right-aligned <code>self-start</code> and left-aligned <code>self-end</code>. In the second&#13;
grid, however, the RTL direction is irrelevant to block-axis alignment.&#13;
Thus, <code>self-start</code> is treated as <code>start</code>, and <code>self-end</code> is treated &#13;
<span class="keep-together">as <code>end</code>.</span></p>&#13;
&#13;
<p class="pagebreak-before">The last value, <code>stretch</code>, is also interesting. To understand it, notice how&#13;
the other boxes in each grid “shrink-wrap” themselves to their content, as if set to <code>max-content</code>.&#13;
The <code>stretch</code> value, by contrast, directs the element to stretch from edge&#13;
to edge in the given direction—<code>align-self: stretch</code> causes the grid&#13;
item to stretch along the block axis, and <code>justify-self: stretch</code> causes&#13;
inline-axis stretching. This is as you might expect, but bear in mind&#13;
that it works only if the element’s size properties are set to <code>auto</code>.&#13;
Thus, given the following styles, the first example will stretch&#13;
vertically, but the second will not:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.exel01</code> <code class="p">{</code><code class="k">align-self</code><code class="o">:</code> <code class="n">stretch</code><code class="p">;</code> <code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nc">.exel02</code> <code class="p">{</code><code class="k">align-self</code><code class="o">:</code> <code class="n">stretch</code><code class="p">;</code> <code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">50%</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Because the second example sets a <code>block-size</code> value that isn’t <code>auto</code> (which&#13;
is the default value), that grid item cannot be resized by <code>stretch</code>. The same holds true for <code>justify-self</code> and <code>inline-size</code>.</p>&#13;
&#13;
<p>Two more values that can be used to align grid items are sufficiently interesting to merit their own explanation. These&#13;
permit the alignment of a grid item’s first or last baseline with the&#13;
highest or lowest baseline in the grid track. For example, suppose you&#13;
want a grid item to be aligned so the baseline of its last line is&#13;
aligned with the last baseline in the tallest grid item sharing its row&#13;
track. That would look like the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.exel</code> <code class="p">{</code><code class="k">align-self</code><code class="o">:</code> <code class="n">last</code><code class="o">-</code><code class="nb">baseline</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Conversely, to align its first baseline with the lowest first baseline&#13;
in the same row track, you’d say this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.exel</code> <code class="p">{</code><code class="k">align-self</code><code class="o">:</code> <code class="nb">baseline</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If a grid element doesn’t have a baseline, or it’s&#13;
asked to baseline-align itself in a direction where baselines can’t be&#13;
compared, <code>baseline</code> is treated as <code>start</code>, and <code>last-baseline</code> is&#13;
treated as <code>end</code>.<a data-primary="" data-startref="ix_inline_format_box_mod" data-type="indexterm" id="idm45176066122544"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This section intentionally skips two values: <code>flex-start</code> and <code>flex-end</code>. These values are supposed to&#13;
be used only in flexbox layout, and are defined to be equivalent to <code>start</code> and <code>end</code> in any other layout context, including grid layout.</p>&#13;
&#13;
<p>For a more detailed explanation of the values just discussed and how they cause items to interact, see <a data-type="xref" href="ch11.html#flexbox">Chapter 11</a>.</p>&#13;
</div>&#13;
&#13;
<p>The <a data-primary="place-self property" data-type="indexterm" id="idm45176066096672"/>shorthand property <code>place-self</code> combines the two self-placement properties &#13;
<span class="keep-together">just discussed.</span></p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176066094704">&#13;
<h1>place-self</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<code><em>align-self</em></code>&gt;  &lt;<code><em>justify-self</em></code>&gt;?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Block-level and absolutely positioned elements, and grid items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Supplying one value for <code>place-self</code> means it’s copied to the second value as well.  Thus, in each of the following pairs of declarations, the first declaration is equivalent to the &#13;
<span class="keep-together">second:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">place</code><code class="o">-</code><code class="n">self</code><code class="o">:</code> <code class="n">end</code><code class="p">;</code>&#13;
<code class="n">place</code><code class="o">-</code><code class="n">self</code><code class="o">:</code> <code class="n">end</code> <code class="n">end</code><code class="p">;</code></pre>&#13;
&#13;
<p>Because both of the individual properties <code>place-self</code> shorthands can accept baseline alignment values, supplying only one value causes both individual properties to be set to the same value.  In other words, the following are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">place</code><code class="o">-</code><code class="n">self</code><code class="o">:</code> <code class="n">last</code> <code class="nb">baseline</code><code class="p">;</code>&#13;
<code class="n">place</code><code class="o">-</code><code class="n">self</code><code class="o">:</code> <code class="n">last</code> <code class="nb">baseline</code> <code class="n">last</code> <code class="nb">baseline</code><code class="p">;</code></pre>&#13;
&#13;
<p>You can also supply two values, one for each of the individual properties the shorthand represents.  So the following CSS shows rules that are equivalent to each other:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nc">.highlight</code> <code class="p">{</code><code class="n">place</code><code class="o">-</code><code class="n">self</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="o">&gt;</code> <code class="nc">.highlight</code> <code class="p">{</code><code class="k">align-self</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code> <code class="nb">justify</code><code class="o">-</code><code class="n">self</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Aligning and Justifying All Items" data-type="sect2"><div class="sect2" id="aligning-and-justifying-all-items">&#13;
<h2>Aligning and Justifying All Items</h2>&#13;
&#13;
<p>Now let’s <a data-primary="justify-items property" data-type="indexterm" id="idm45176065933920"/><a data-primary="align-items property" data-type="indexterm" id="idm45176065959168"/>consider <code>align-items</code> and <code>justify-items</code>. These properties&#13;
accept all the same values you saw in the previous section plus a few more, and have the same effect, except they apply to all grid items in a given grid&#13;
container, and must be applied to the grid container instead of to&#13;
individual grid items.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176065957376">&#13;
<h1>align-items</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>normal</code> | <code>stretch</code>  | [ [ <code>first</code> | <code>last</code> ]? &amp;&amp; <code>baseline</code> ] | [ [ <code>unsafe</code> | <code>safe</code> ]? <code>center</code> | <code>start</code> | <code>end</code> | <code>left</code> | <code>right</code> ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176065915904">&#13;
<h1>justify-items</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>normal</code> | <code>stretch</code>  | [ [ <code>first</code> | <code>last</code> ]? &amp;&amp; <code>baseline</code> ] | [ [ <code>unsafe</code> | <code>safe</code> ]? <code>center</code> | <code>start</code> | <code>end</code> | <code>left</code> | <code>right</code> ] | [ <code>legacy</code> &amp;&amp; [ <code>left</code> | <code>right</code> | <code>center</code> ]? ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>legacy</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared (except for <code>legacy</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>As an example, you could set all of the grid items in a grid to be center-aligned&#13;
within their grid areas as follows, with a result like that depicted in&#13;
<a data-type="xref" href="#centering_all_the_grid_items">Figure 12-72</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
    <code class="k">align-items</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code> <code class="nb">justify</code><code class="o">-</code><code class="n">items</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="centering_all_the_grid_items">&#13;
<img alt="image" src="assets/css5_1272.png"/>&#13;
<h6><span class="label">Figure 12-72. </span>Centering all the grid items</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see, that rule horizontally <em>and</em> vertically centers every grid&#13;
item within its given grid area. Furthermore, it causes any grid item&#13;
without an explicit width and height to “shrink-wrap” its content&#13;
rather than stretch out to fill its grid area, because of the way <code>center</code> is handled. If a grid item has an&#13;
explicit inline or block size, those are honored instead of “shrink-wrapping” the content, and the item is still centered within its grid area.</p>&#13;
&#13;
<p>For an overview of the effects of the various keyword values in the context of both <code>justify-items</code> and <code>align-items</code>, see <a data-type="xref" href="#grid-alignment-justify-items-both">Figure 12-73</a>; the grid areas are represented with dashed lines, and the grid items are placed according to their alignment values.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grid-alignment-justify-items-both">&#13;
<img alt="image" src="assets/css5_1273.png"/>&#13;
<h6><span class="label">Figure 12-73. </span>The alignment of grid items within their grid cells</h6>&#13;
</div></figure>&#13;
&#13;
<p>Not illustrated in <a data-type="xref" href="#grid-alignment-justify-items-both">Figure 12-73</a>, the <code>legacy</code> value is a new addition to grid alignment, and is essentially treated as <code>start</code>.  (It exists to re-create the behaviors of HTML’s ancient &#13;
<span class="keep-together"><code>&lt;CENTER&gt;</code></span> element and <code>align</code> attribute, neither of which is relevant in a grid context.)</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For an exploration of what <code>safe</code> and <code>unsafe</code> mean in terms of items overflowing their container, see <a data-type="xref" href="ch11.html#flexbox">Chapter 11</a>.</p>&#13;
</div>&#13;
&#13;
<p>The <a data-primary="place-items property" data-type="indexterm" id="idm45176065859728"/>shorthand property <code>place-items</code> combines the two item-placement properties just discussed.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176065858320">&#13;
<h1>place-items</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<code><em>align-items</em></code>&gt;  &lt;<code><em>justify-items</em></code>&gt;?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The way <code>place-items</code> works is very similar to the <code>place-self</code> property discussed previously in the chapter.  If one value is given, it’s applied to both <code>align-items</code> and <code>justify-items</code>.  If two values are given, the first is applied to <code>align-items</code> and the second to <code>justify-items</code>.  Thus, the following rules are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="n">place</code><code class="o">-</code><code class="n">items</code><code class="o">:</code> <code class="n">first</code> <code class="nb">baseline</code> <code class="n">start</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="p">{</code><code class="k">align-items</code><code class="o">:</code> <code class="n">first</code> <code class="nb">baseline</code><code class="p">;</code> <code class="nb">justify</code><code class="o">-</code><code class="n">items</code><code class="o">:</code> <code class="n">start</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Distributing Grid Items and Tracks" data-type="sect2"><div class="sect2" id="distributing-grid-items-and-tracks">&#13;
<h2>Distributing Grid Items and Tracks</h2>&#13;
&#13;
<p>Beyond <a data-primary="grid layout" data-secondary="distributing grid items and tracks" data-type="indexterm" id="ix_grid_distr_items"/><a data-primary="justify-content property" data-type="indexterm" id="idm45176065800112"/>aligning and justifying every grid item, it’s possible to&#13;
distribute the grid items, or even to justify or align the entire grid,&#13;
using <code>align-content</code> and <code>justify-content</code>. A small set of&#13;
distributive values is used for these properties. <a data-type="xref" href="#distributing_grid_items_horizontally">Figure 12-74</a> illustrates the&#13;
effects of each value as applied to <code>justify-content</code>, with each grid&#13;
sharing the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0.5em</code> <code class="m">1em</code><code class="p">;</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
	<code class="k">grid-gap</code><code class="o">:</code> <code class="m">0.75em</code> <code class="m">0.5em</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
	<code class="k">grid-template-rows</code><code class="o">:</code> <code class="m">4em</code><code class="p">;</code>&#13;
	<code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="m">6em</code><code class="p">);}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="distributing_grid_items_horizontally">&#13;
<img alt="image" src="assets/css5_1274.png"/>&#13;
<h6><span class="label">Figure 12-74. </span>Distributing grid items along the inline axis</h6>&#13;
</div></figure>&#13;
&#13;
<p>In these cases, the set of <a data-primary="grid layout" data-secondary="grid lines" data-tertiary="distributing tracks" data-type="indexterm" id="idm45176065700240"/><a data-primary="grid layout" data-secondary="grid tracks" data-tertiary="distributing" data-type="indexterm" id="idm45176065698992"/>grid tracks is taken as a single unit, and&#13;
the items are then justified by the value of <code>justify-content</code>.&#13;
That alignment does not&#13;
affect the alignment of individual grid items; thus, you could&#13;
end-justify the whole grid with <code>justify-content: end</code> while having&#13;
individual grid items be left-, center-, or start-justified (among other&#13;
options) within their grid areas.</p>&#13;
&#13;
<p>This <a data-primary="align-content property" data-type="indexterm" id="idm45176065685696"/>works just as well in column tracks as it does in row tracks, as&#13;
<a data-type="xref" href="#distributing_grid_items_vertically">Figure 12-75</a> illustrates, as long as you switch to <code>align-content</code>. This time, the grids all share these styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
	<code class="k">grid-gap</code><code class="o">:</code> <code class="m">0.75em</code> <code class="m">0.5em</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
	<code class="k">grid-template-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">4</code><code class="o">,</code> <code class="m">3em</code><code class="p">);</code>&#13;
	<code class="k">grid-template-columns</code><code class="o">:</code> <code class="m">5em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="distributing_grid_items_vertically">&#13;
<img alt="image" src="assets/css5_1275.png"/>&#13;
<h6><span class="label">Figure 12-75. </span>Distributing grid items along the block axis</h6>&#13;
</div></figure>&#13;
&#13;
<p>The way these distributions work is that the <a data-primary="gutter space" data-secondary="grid track sizing" data-type="indexterm" id="idm45176065649008"/>grid tracks, including any&#13;
gutters, are all sized as usual. Then, if any space is left over&#13;
beyond the grid tracks and gutters—that is, if the grid tracks don’t reach all&#13;
the way from one edge of the grid container to the other—then the&#13;
remaining space is distributed according to the value of&#13;
<code>justify-content</code> (in the inline axis) or <code>align-content</code> (in the&#13;
block axis).</p>&#13;
&#13;
<p>This space distribution is carried out by resizing the grid gutters. If&#13;
no gutters are declared, they will be created. If gutters already exist, their sizes are altered as required to distribute the&#13;
grid tracks as specified.</p>&#13;
&#13;
<p>Note that because space is distributed only when the tracks don’t fill&#13;
out the grid container, the gutters can only increase in size. If the&#13;
tracks are larger than the container, which can easily happen, there is&#13;
no leftover space to distribute (negative space turns out to be&#13;
indivisible).</p>&#13;
&#13;
<p>One more distribution value&#13;
wasn’t shown in the previous figures: <code>stretch</code>. This value takes any leftover space&#13;
and applies it equally to the grid tracks, not the gutters. So if&#13;
we have 400 pixels of leftover space and 8 grid tracks, each grid&#13;
track is increased by 50 pixels. The grid tracks are <em>not</em> increased&#13;
proportionally, but equally.  As of late 2022, there is no browser&#13;
support for this value in terms of grid distribution.<a data-primary="" data-startref="ix_align_grid" data-type="indexterm" id="idm45176065644992"/><a data-primary="" data-startref="ix_grid_align" data-type="indexterm" id="idm45176065644016"/><a data-primary="" data-startref="ix_justified_grid_items" data-type="indexterm" id="idm45176065643072"/><a data-primary="" data-startref="ix_grid_distr_items" data-type="indexterm" id="idm45176065642128"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Layering and Ordering" data-type="sect1"><div class="sect1" id="layering-and-ordering">&#13;
<h1>Layering and Ordering</h1>&#13;
&#13;
<p>As we <a data-primary="grid layout" data-secondary="ordering layers" data-type="indexterm" id="ix_grid_order_layer"/><a data-primary="grid layout" data-secondary="overlapping elements" data-type="indexterm" id="ix_grid_overlap_elem"/><a data-primary="grid layout" data-secondary="layering and ordering elements" data-type="indexterm" id="ix_grid_layer_order"/><a data-primary="overlapping elements" data-secondary="grid items" data-type="indexterm" id="ix_overlap_grid_items"/>discussed in a previous section, it’s entirely possible to have grid&#13;
items overlap each other, whether because negative margins are used to&#13;
pull a grid item beyond the edges of its grid area, or because&#13;
the grid areas of two different grid items share grid cells. By default,&#13;
the grid items will visually overlap in document source order: grid&#13;
items later in the document source will appear above (or “in front of”) grid items&#13;
earlier in the &#13;
<span class="keep-together">document</span> source. Thus the following results in <a data-type="xref" href="#grid_items_overlapping">Figure 12-76</a> (assume the number in each class name represents the grid item’s source order):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#grid</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">80%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">20em</code><code class="p">;</code>&#13;
    <code class="k">grid-rows</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">10</code><code class="o">,</code> <code class="m">1</code><code class="n">fr</code><code class="p">);</code> <code class="nb">grid</code><code class="o">-</code><code class="k">columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">10</code><code class="o">,</code> <code class="m">1</code><code class="n">fr</code><code class="p">);}</code>&#13;
<code class="nc">.box01</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="n">span</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="m">1</code> <code class="o">/</code> <code class="n">span</code> <code class="m">4</code><code class="p">;}</code>&#13;
<code class="nc">.box02</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">4</code> <code class="o">/</code> <code class="n">span</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="m">4</code> <code class="o">/</code> <code class="n">span</code> <code class="m">4</code><code class="p">;}</code>&#13;
<code class="nc">.box03</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">7</code> <code class="o">/</code> <code class="n">span</code> <code class="m">4</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="m">7</code> <code class="o">/</code> <code class="n">span</code> <code class="m">4</code><code class="p">;}</code>&#13;
<code class="nc">.box04</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">4</code> <code class="o">/</code> <code class="n">span</code> <code class="m">7</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="m">3</code> <code class="o">/</code> <code class="n">span</code> <code class="m">2</code><code class="p">;}</code>&#13;
<code class="nc">.box05</code> <code class="p">{</code><code class="k">grid-row</code><code class="o">:</code> <code class="m">2</code> <code class="o">/</code> <code class="n">span</code> <code class="m">3</code><code class="p">;</code> <code class="k">grid-column</code><code class="o">:</code> <code class="m">4</code> <code class="o">/</code> <code class="n">span</code> <code class="m">5</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="grid_items_overlapping">&#13;
<img alt="image" src="assets/css5_1276.png"/>&#13;
<h6><span class="label">Figure 12-76. </span>Grid items overlapping in source order</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you want to assert your own stacking order, <code>z-index</code> is here to&#13;
help. Just as in positioning, <code>z-index</code> places elements relative to&#13;
one another on the z-axis, which is perpendicular to the display surface.&#13;
Positive values are closer to you, and negative values further away. So&#13;
to bring the second box to the “top,” as it were, all you need is to&#13;
give it a <code>z-index</code> value higher than any other (with the result shown&#13;
in <a data-type="xref" href="#elevating_a_grid_item">Figure 12-77</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.box02</code> <code class="p">{</code><code class="k">z-index</code><code class="o">:</code> <code class="m">10</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="elevating_a_grid_item">&#13;
<img alt="image" src="assets/css5_1277.png"/>&#13;
<h6><span class="label">Figure 12-77. </span>Elevating a grid item</h6>&#13;
</div></figure>&#13;
&#13;
<p>Another way you can <a data-primary="order property" data-type="indexterm" id="ix_order_prop2"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="ordering grid items" data-type="indexterm" id="idm45176065414304"/>affect the ordering of grid items is by using the&#13;
<code>order</code> property. Its effect is essentially the same as it is in&#13;
flexbox—you can change the order of grid items within a grid track by&#13;
giving them <code>order</code> values. This affects not only placement within the&#13;
track, but also <em>paint order</em> if they should overlap. For example, we&#13;
could change the previous example from <code>z-index</code> to <code>order</code>, as shown&#13;
here, and get the same result shown in <a data-type="xref" href="#elevating_a_grid_item">Figure 12-77</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.box02</code> <code class="p">{</code><code class="k">order</code><code class="o">:</code> <code class="m">10</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In this case, <code>box02</code> appears “on top of” the other grid items because&#13;
its order places it after the rest of them. Thus, it’s drawn last.&#13;
Similarly, if those grid items were all placed in sequence in a grid&#13;
track, the <code>order</code> value for <code>box02</code> would put it at the end of the&#13;
sequence. This is depicted in <a data-type="xref" href="#changing_grid_item_order">Figure 12-78</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="changing_grid_item_order">&#13;
<img alt="image" src="assets/css5_1278.png"/>&#13;
<h6><span class="label">Figure 12-78. </span>Changing grid-item order</h6>&#13;
</div></figure>&#13;
&#13;
<p>Remember that just because you <em>can</em> rearrange the order of grid items&#13;
this way doesn’t necessarily mean you <em>should</em>. As the <a href="https://www.w3.org/TR/css-grid-1/#order-property">Grid Layout&#13;
specification</a> says:</p>&#13;
<blockquote>&#13;
<p>As with reordering flex items, the <code>order</code> property must only be used when&#13;
the visual order needs to be <em>out-of-sync</em> with the speech and navigation&#13;
order; otherwise the underlying document source should be reordered&#13;
instead.</p></blockquote>&#13;
&#13;
<p>So the only reason to use <code>order</code> to rearrange grid-item layout is if&#13;
you need to have the document source in one order and layout in the&#13;
other. This is already easily possible by assigning grid items to areas&#13;
that don’t match source order.</p>&#13;
&#13;
<p>This is not to say that <code>order</code> is useless and should always be shunned;&#13;
there may well be times it makes sense. But unless you find yourself&#13;
nearly forced into using it by specific circumstances, think very hard&#13;
about whether it’s the best solution.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For a formal definition of the <code>order</code> property, see <a data-type="xref" href="ch11.html#flexbox">Chapter 11</a>.<a data-primary="" data-startref="ix_grid_layer_order" data-type="indexterm" id="idm45176065352896"/><a data-primary="" data-startref="ix_grid_order_layer" data-type="indexterm" id="idm45176065352048"/><a data-primary="" data-startref="ix_grid_overlap_elem" data-type="indexterm" id="idm45176065351200"/><a data-primary="" data-startref="ix_order_prop2" data-type="indexterm" id="idm45176065350352"/><a data-primary="" data-startref="ix_overlap_grid_items" data-type="indexterm" id="idm45176065349504"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="gl_summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Grid layout is complex and powerful, so don’t be discouraged if you feel&#13;
overwhelmed at first. It takes some time to get used to the way grid operates,&#13;
especially because so many of its features are nothing like what we’ve&#13;
dealt with before. Much of those features’ power comes directly from&#13;
their novelty—but like any powerful tool, grid layout can be difficult and frustrating to learn to use.<a data-primary="" data-startref="grid_layout_ch12" data-type="indexterm" id="idm45176065346992"/></p>&#13;
&#13;
<p>We hope we were able to steer you past some of those pitfalls, but still,&#13;
remember the <span class="keep-together">wisdom</span> of Master Yoda: “You must unlearn what you have learned.” When coming to grid layout, there has never been greater need to put aside what you think you <span class="keep-together">know about</span> layout and learn anew. Over time, your patience and persistence will be rewarded.</p>&#13;
</div></section>&#13;
</div></section></body></html>