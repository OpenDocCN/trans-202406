<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Building Offline Apps with Amplify DataStore"><div class="chapter" id="ch9">
<h1><span class="label">Chapter 9. </span>Building Offline Apps with <span class="keep-together">Amplify DataStore</span></h1>


<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="about" id="idm45364346659432"/>So far in this book, we’ve worked with REST APIs and GraphQL APIs. When working with the GraphQL APIs, we used the API class to directly call mutations and queries against the API.</p>

<p>Amplify also supports another type of API for interacting with AppSync: Amplify DataStore. DataStore has a different approach than a traditional GraphQL API.</p>

<p><a data-type="indexterm" data-primary="IndexDB for web" id="idm45364346657288"/>Instead of interacting with the GraphQL API itself, using queries and mutations, DataStore introduces a client-side SDK that allows you to write to and read from a local store and persists this data locally using the local storage engine of the platform you are working with (i.e., IndexDB for web and SQLite for native iOS and Android). DataStore then automatically syncs the local data to the GraphQL backend for you as updates are made both locally and remotely.</p>

<p>Using the DataStore SDK, you then only have to perform the operations like save, update, and delete, writing directly to DataStore itself. DataStore handles everything else for you: it syncs your data to the cloud when you have an internet connection, and if you’re not online, will queue it for the next time you’re connected.</p>

<p>DataStore also handles conflict detection and resolution for you with one of three built-in conflict-resolution strategies:</p>
<dl class="less_space pagebreak-before">
<dt>AutoMerge</dt>
<dd>
<p><a data-type="indexterm" data-primary="AutoMerge conflict-resolution strategy" id="idm45364346652888"/>GraphQL type information on an object is inspected at runtime to perform merge operations (suggested option).</p>
</dd>
<dt>Optimistic concurrency</dt>
<dd>
<p><a data-type="indexterm" data-primary="optimistic concurrency conflict-resolution strategy" id="idm45364346650808"/>The latest written item to your database will be used with a version check against the incoming record.</p>
</dd>
<dt>Custom</dt>
<dd>
<p><a data-type="indexterm" data-primary="custom conflict-resolution strategy" id="idm45364346648616"/>Use a Lambda function and write any custom business logic you wish to the process when merging or rejecting updates.</p>
</dd>
</dl>






<section data-type="sect1" data-pdf-bookmark="About Amplify DataStore"><div class="sect1" id="idm45364346647384">
<h1>About Amplify DataStore</h1>

<p><a href="https://oreil.ly/Wv_TT">Amplify DataStore</a> is<a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="website" id="idm45364346645384"/> a combination of the following things:</p>

<ul>
<li>
<p>AppSync GraphQL API</p>
</li>
<li>
<p>Local storage repository and syncing engine that also persists data offline</p>
</li>
<li>
<p>Client-side SDK for interacting with the local storage repository</p>
</li>
<li>
<p>Special sync-enabled GraphQL resolvers (generated by the Amplify CLI) that enable sophisticated conflict detection and conflict resolution on the server</p>
</li>
</ul>








<section data-type="sect2" data-pdf-bookmark="Amplify DataStore Overview"><div class="sect2" id="idm45364346639960">
<h2>Amplify DataStore Overview</h2>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="overview of" id="idm45364346638744"/><a data-type="indexterm" data-primary="conflict detection" id="idm45364346637768"/>When getting started with DataStore, you still create the API as we have done in past chapters. The main difference is, when creating the API, you will enable <em>conflict detection</em> in the advanced settings of the CLI flow.</p>

<p>From there, to enable DataStore on the client, we need to create models for DataStore to use to interact with the storage repository. This can easily be done by just using the GraphQL schema you already have and running a build command—<code>amplify codegen models</code>—from the CLI.</p>

<p>Now, you are all set up and can begin interacting with DataStore.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Amplify DataStore Operations"><div class="sect2" id="idm45364346634616">
<h2>Amplify DataStore Operations</h2>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="operations" id="idm45364346633320"/><a data-type="indexterm" data-primary="operations" data-secondary="Amplify DataStore" id="idm45364346632344"/>To interact with the Store, first import the <code>DataStore</code> API from Amplify and the Model you’d like to use. From there, you can perform actions against the store.</p>

<p><a data-type="indexterm" data-primary="reading data" id="idm45364346630408"/><a data-type="indexterm" data-primary="data" data-secondary="reading" id="idm45364346629480"/><a data-type="indexterm" data-primary="deleting" data-secondary="data" id="idm45364346628536"/><a data-type="indexterm" data-primary="data" data-secondary="deleting" id="idm45364346627592"/><a data-type="indexterm" data-primary="data" data-secondary="updating" id="idm45364346626648"/><a data-type="indexterm" data-primary="updating" data-secondary="data" id="idm45364346625704"/><a data-type="indexterm" data-primary="data" data-secondary="saving" id="idm45364346624760"/><a data-type="indexterm" data-primary="saving data" id="idm45364346623816"/><a data-type="indexterm" data-primary="importing models" id="idm45364346623144"/><a data-type="indexterm" data-primary="models, importing" id="idm45364346622472"/>See <a data-type="xref" href="#table-DataStore">Table 9-1</a> for some available operations.</p>
<table id="table-DataStore">
<caption><span class="label">Table 9-1. </span>Amplify DataStore Operations</caption>
<thead>
<tr>
<th>Operation</th>
<th>Commands</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Import the model and DataStore API</p></td>
<td><p><code>import { DataStore } from '@aws-amplify/datastore'
import { Message} from './models'</code></p></td>
</tr>
<tr>
<td><p>Saving data</p></td>
<td><p><code>await DataStore.save(
  new Message({
    title: 'Hello World',
    sender: 'Chris'
  })
))</code></p></td>
</tr>
<tr>
<td><p>Reading data</p></td>
<td><p><code>const posts = await DataStore.query(Post)</code></p></td>
</tr>
<tr>
<td><p>Deleting data</p></td>
<td><p><code>const message = await DataStore.query(Message, '123')
DataStore.delete(message)</code></p></td>
</tr>
<tr>
<td><p>Updating data</p></td>
<td><p><code>const message = await DataStore.query(Message, '123')
await DataStore.save(
	Post.copyOf(message, updated =&gt; {
		updated.title = 'My new title'
	})
)</code></p></td>
</tr>
<tr>
<td><p>Observing/subscribing to changes in data for real-time functionality</p></td>
<td><p><code>const subscription = DataStore.observe(Message).subscribe(msg =&gt; {
  console.log(message.model, message.opType, message.element)
});</code></p></td>
</tr>
</tbody>
</table>
</div></section>













<section data-type="sect2" data-pdf-bookmark="DataStore Predicates"><div class="sect2" id="idm45364346605992">
<h2>DataStore Predicates</h2>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="predicates" id="idm45364346604680"/><a data-type="indexterm" data-primary="predicates, Amplify DataStore" id="idm45364346603704"/>You can apply predicate filters against the DataStore using the fields defined on your GraphQL type along with the following conditions supported by DynamoDB:</p>

<pre data-type="programlisting">Strings: eq | ne | le | lt | ge | gt | contains | notContains | beginsWith
            | between
Numbers: eq | ne | le | lt | ge | gt | between
Lists: contains | notContains</pre>

<p>For example, if you wanted a list of all messages that have a <code>title</code> that includes “Hello”:</p>

<pre data-type="programlisting">const messages = await DataStore
  .query(Message, m =&gt;
m.title('contains', 'Hello'))</pre>

<p>You can also chain multiple predicates into a single operation:</p>

<pre data-type="programlisting">const message = await DataStore
  .query(Message, m =&gt; m.title('contains', 'Hello').sender('eq', 'Chris'))</pre>

<p>These predicates enable you to have many ways to retrieve different selection sets from your local data. Instead of retrieving the entire collection and filtering on the client, you are able to query from the store exactly the data that you need.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Building an Offline and Real-Time App with Amplify DataStore"><div class="sect1" id="idm45364346598200">
<h1>Building an Offline and Real-Time App with <span class="keep-together">Amplify DataStore</span></h1>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="building offline/real-time apps with" id="ads_off"/><a data-type="indexterm" data-primary="creating" data-secondary="offline apps with Amplify DataStore" id="cre_ads"/><a data-type="indexterm" data-primary="creating" data-secondary="real-time apps with Amplify DataStore" id="cre_rta"/>The app that we will build is a real-time and offline-first message board, as shown in <a data-type="xref" href="#fig9a">Figure 9-1</a>.</p>

<figure><div id="fig9a" class="figure">
<img src="Images/fssl_0901.png" alt="Real Time Message Board" width="1397" height="939"/>
<h6><span class="label">Figure 9-1. </span>Real-time message board</h6>
</div></figure>

<p>Users of the app can create a new message and all other users will receive the message in real time. If a user goes offline, they will continue to be able to create messages. Once they are online, the messages will be synced with the backend, and all other messages created by other users will also be fetched and synced locally.</p>

<p>Our app will perform three types of operations against the DataStore API:</p>
<dl>
<dt><code>save</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="save operation" id="idm45364346586552"/>Creating a new item in the DataStore; saves the item locally and performs a GraphQL mutation behind the scenes.</p>
</dd>
<dt><code>query</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="query operation" id="idm45364346584312"/>Reading from the DataStore; returns a single item or list (array) and performs a GraphQL query behind the scenes.</p>
</dd>
<dt><code>observe</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="observe operation" id="idm45364346582072"/>Listening for changes (create, update, delete) in data and performs a GraphQL subscription behind the scenes.</p>
</dd>
</dl>

<p>Let’s get started.</p>








<section data-type="sect2" data-pdf-bookmark="Creating the Base Project"><div class="sect2" id="idm45364346580472">
<h2>Creating the Base Project</h2>

<p><a data-type="indexterm" data-primary="creating" data-secondary="base projects" id="idm45364346579000"/><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="creating base projects" id="idm45364346578152"/><a data-type="indexterm" data-primary="projects" data-secondary="creating base" id="idm45364346577240"/>To get started, we will create a new React project, initialize an Amplify app, and install the dependencies.</p>

<p>The first thing we will do is create the React project:</p>

<pre data-type="programlisting">~ npx create-react-app rtmessageboard
~ cd rtmessageboard</pre>

<p>Next, we will install the local dependencies.</p>

<p>Amplify supports a full installation of Amplify, and <em>scoped</em> (modular) installations for specific APIs. Scoped packages reduce the bundle size, since we’re installing only the code that we are using. Since we are only using the DataStore API, we can install the scoped DataStore package.</p>

<p><a data-type="indexterm" data-primary="React Color" id="idm45364346572824"/><a data-type="indexterm" data-primary="Amplify Core" id="idm45364346572120"/>We will also install Ant Design (<code>antd</code>) for styling, React Color (<code>react-color</code>) for an easy-to-use color picker, and the scoped dependency for Amplify Core in order to still configure the Amplify app with <em>aws-exports.js</em>:</p>

<pre data-type="programlisting">~ npm install @aws-amplify/core @aws-amplify/datastore antd react-color</pre>

<p>Next, initialize a new Amplify project:</p>

<pre data-type="programlisting">~ amplify init

# Follow the steps to give the project a name, environment name, and set the
  default text editor.
# Accept defaults for everything else and choose your AWS Profile.</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating the API"><div class="sect2" id="idm45364346579848">
<h2>Creating the API</h2>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="creating AppSync GraphQL API" id="idm45364346566232"/><a data-type="indexterm" data-primary="creating" data-secondary="AppSync GraphQL API" id="idm45364346565288"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="creating" id="idm45364346564344"/>Now we will create the AppSync GraphQL API:</p>

<pre data-type="programlisting">~ amplify add api

? Please select from one of the below mentioned services: GraphQL
? Provide API name: rtmessageboard
? Choose the default authorization type for the API: API key
? Enter a description for the API key: public
? After how many days from now the API key should expire (1-365): 365 (or your
  preferred expiration)
? Do you want to configure advanced settings for the GraphQL API: Yes
? Configure additional auth types: N
? Configure conflict detection: Y
? Select the default resolution strategy: Auto Merge
? Do you have an annotated GraphQL schema: N
? Do you want a guided schema creation: Y
? What best describes your project: Single object with fields
? Do you want to edit the schema now: Y</pre>

<p>Update the schema with the following type:</p>

<pre data-type="programlisting">type Message @model {
  id: ID!
  title: String!
  color: String
  image: String
  createdAt: String
}</pre>

<p>Now that we have created the GraphQL API, and we have a GraphQL schema to work with, we can create the models we’ll need for working the local DataStore API (based on the GraphQL schema):</p>

<pre data-type="programlisting">~ amplify codegen models</pre>

<p>This will create a new folder in our project called <em>models</em>. Using the models in this folder, we can start interacting with the DataStore API. Deploy the API:</p>

<pre data-type="programlisting">~ amplify push --y</pre>

<p>With the backend deployed, we can start writing the client-side code.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Writing the Client-Side Code"><div class="sect2" id="idm45364346567176">
<h2>Writing the Client-Side Code</h2>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="writing client-side code" id="idm45364346555480"/><a data-type="indexterm" data-primary="client-side code, writing" id="idm45364346554488"/><a data-type="indexterm" data-primary="code" data-secondary="client-side" id="idm45364346553800"/><a data-type="indexterm" data-primary="writing client-side code" id="idm45364346552856"/>First, open <em>src/index.js</em> and configure the Amplify app by adding the following code below the last import:</p>

<pre data-type="programlisting">import 'antd/dist/antd.css'
import Amplify from '@aws-amplify/core'
import config from './aws-exports'
Amplify.configure(config)</pre>

<p>Notice that we are importing from <code>@aws-amplify/core</code> instead of <code>aws-amplify</code>.</p>

<p>Next, open <em>App.js</em> and update it with the following code:</p>

<pre data-type="programlisting">/* src/App.js */
import React, { useState, useEffect } from 'react'
import { SketchPicker } from 'react-color'
import { Input, Button } from 'antd'
import { DataStore } from '@aws-amplify/datastore'
import { Message} from './models'

const initialState = { color: '#000000', title: '' }
function App() {
  const [formState, updateFormState] = useState(initialState)
  const [messages, updateMessages] = useState([])
  const [showPicker, updateShowPicker] = useState(false)
  useEffect(() =&gt; {
    fetchMessages()
    const subscription = DataStore
      .observe(Message)
      .subscribe(() =&gt; fetchMessages())
    return () =&gt; subscription.unsubscribe()
  }, [])
  async function fetchMessages() {
    const messages = await DataStore.query(Message)
    updateMessages(messages)
  }
  function onChange(e) {
    if (e.hex) {
      updateFormState({ ...formState, color: e.hex})
    } else { updateFormState({ ...formState, [e.target.name]: e.target.value}) }
  }
  async function createMessage() {
    if (!formState.title) return
    await DataStore.save(new Message({ ...formState }))
    updateFormState(initialState)
  }
  return (
    &lt;div style={container}&gt;
      &lt;h1 style={heading}&gt;Real Time Message Board&lt;/h1&gt;
      &lt;Input
        onChange={onChange}
        name="title"
        placeholder="Message title"
        value={formState.title}
        style={input}
      /&gt;
      &lt;div&gt;
        &lt;Button
        onClick={() =&gt; updateShowPicker(!showPicker)}
        style={button}
        &gt;Toggle Color Picker&lt;/Button&gt;
        &lt;p&gt;Color:
          &lt;span
           style={{fontWeight: 'bold', color: formState.color}}&gt;{formState.color}
          &lt;/span&gt;
        &lt;/p&gt;
      &lt;/div&gt;
      {
        showPicker &amp;&amp; (
          &lt;SketchPicker
           color={formState.color}
           onChange={onChange} /
          &gt;
        )
      }
      &lt;Button type="primary" onClick={createMessage}&gt;Create Message&lt;/Button&gt;
      {
        messages.map(message =&gt; (
          &lt;div
            key={message.id}
            style={{...messageStyle, backgroundColor: message.color}}
          &gt;
            &lt;div style={messageBg}&gt;
              &lt;p style={messageTitle}&gt;{message.title}&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        ))
      }
    &lt;/div&gt;
  );
}

const container = { width: '100%', padding: 40, maxWidth: 900 }
const input = { marginBottom: 10 }
const button = { marginBottom: 10 }
const heading = { fontWeight: 'normal', fontSize: 40 }
const messageBg = { backgroundColor: 'white' }
const messageStyle = { padding: '20px', marginTop: 7, borderRadius: 4 }
const messageTitle = { margin: 0, padding: 9, fontSize: 20  }

export default App</pre>

<p>Let’s walk through the most important parts of what’s going on in this component:</p>
<ol>
<li>
<p>We import the <code>DataStore</code> API from Amplify as well as the <code>Message</code> model.</p>
</li>
<li>
<p>We create three pieces of component state using the <code>useState</code> hook:</p>
<dl>
<dt><code>formState</code></dt>
<dd>
<p>This object manages the state for the form, including the <code>title</code> and <code>color</code> that will be used to display the background color of the message.</p>
</dd>
<dt><code>messages</code></dt>
<dd>
<p>This will manage the array of messages once they are fetched from <span class="keep-together">DataStore.</span></p>
</dd>
<dt><code>showPicker</code></dt>
<dd>
<p>This will manage a Boolean value that will be toggled to show and hide a color picker to fill the <code>color</code> value for the message (by default, the color is set to black and held in the <code>formState</code>).</p>
</dd>
</dl>
</li>
<li>
<p>When the component loads (in <code>useEffect</code>), we fetch all messages by invoking the <code>fetchMessages</code> function and create a subscription (<code>DataStore.observe</code>) to listen to message updates. When a subscription is fired, we again invoke the <code>fetchMessages</code> function because we know there has been an update and we would like to update the app with the most recent data coming back from the API.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="fetchMessages function" id="idm45364346529720"/>The <code>fetchMessages</code> function calls <code>DataStore.query</code> and then updates the component state with the returned array of messages.</p>
</li>
<li>
<p>The <code>onChange</code> handler handles the updates to the form input as well as the color picker being changed.</p>
</li>
<li>
<p>In <code>createMessage</code>, we first check to make sure the title field is populated. If it is, we save the message using <code>DataStore.save</code> and then reset the form state.</p>
</li>

</ol>

<p>Let’s test it out<a data-type="indexterm" data-primary="" data-startref="ads_off" id="idm45364346524120"/><a data-type="indexterm" data-primary="" data-startref="cre_ads" id="idm45364346523112"/><a data-type="indexterm" data-primary="" data-startref="cre_rta" id="idm45364346522168"/>:</p>

<pre data-type="programlisting">~ npm start</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Testing the Offline Functionality"><div class="sect2" id="idm45364346556408">
<h2>Testing the Offline Functionality</h2>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="testing offline functionality" id="idm45364346519064"/><a data-type="indexterm" data-primary="offline functionality, testing" id="idm45364346518072"/><a data-type="indexterm" data-primary="testing" data-secondary="offline functionality" id="idm45364346517384"/>Try going offline, creating a new mutation, and then coming back online. You should notice that, when back online, the app takes all of the messages created when you were offline and creates them in the database.</p>

<p>To verify this, open the AppSync API in the AWS Console:</p>

<pre data-type="programlisting">~ amplify console api

? Please select from one of the below mentioned services: GraphQL</pre>

<p>Next, click Data Sources and then open the Message Table resource. You should now see the items in the Message Table.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Testing the Real-Time Functionality"><div class="sect2" id="idm45364346514152">
<h2>Testing the Real-Time Functionality</h2>

<p><a data-type="indexterm" data-primary="Amplify DataStore" data-secondary="testing real-time functionality" id="idm45364346512984"/><a data-type="indexterm" data-primary="real-time functionality, testing" id="idm45364346511992"/><a data-type="indexterm" data-primary="testing" data-secondary="real-time functionality" id="idm45364346511304"/>To test out the real-time functionality, open another browser window so that you have two windows running the same app. Then create a new item in one window and see the update come through automatically in the other window.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45364346597608">
<h1>Summary</h1>

<p>Here are a few things to keep in mind from this chapter:</p>

<ul>
<li>
<p>Amplify enables two different APIs to interact with AppSync: the <code>API</code> category as well as DataStore.</p>
</li>
<li>
<p>When using DataStore, you are no longer sending HTTP requests directly to the API. Instead, you are writing to the local storage engine, and DataStore then takes care of syncing to and from the cloud.</p>
</li>
<li>
<p>Amplify DataStore works offline by default.</p>
</li>
</ul>
</div></section>







</div></section></div>



  </body></html>