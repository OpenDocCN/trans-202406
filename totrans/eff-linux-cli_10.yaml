- en: Chapter 8\. Building a Brash One-Liner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember this long, intricate command from the preface?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Such magical incantations are called *brash one-liners*.^([1](ch08.xhtml#idm46586639000896))
    Let’s take this one apart to understand what it does and how it works. The innermost
    `echo` commands use brace expansion to generate lists of JPEG filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Piping the filenames to `sed` replaces space characters with newlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paste` command prints the two lists side by side. Process substitution
    allows `paste` to read the two lists as if they were files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepending `mv` to each line prints a sequence of strings that are `mv` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of the command is now revealed: it generates 10 commands to rename
    the image files *1.jpg* through *10.jpg*. The new names are *0.jpg* through *9.jpg*,
    respectively. Piping the output to `bash` executes the `mv` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Brash one-liners are like puzzles. You’re faced with a business problem, such
    as renaming a set of files, and you apply your toolbox to construct a Linux command
    to solve it. Brash one-liners challenge your creativity and build your skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll create brash one-liners like the preceding one, step-by-step,
    using the following magical formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Invent a command that solves a piece of the puzzle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command and check the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recall the command from history and tweak it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 and 3 until the command produces the desired result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter will give your brain a workout. Expect to feel puzzled at times
    by the examples. Just take things one step at a time, and run the commands on
    a computer as you read them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some brash one-liners in this chapter are too wide for a single line, so I’ve
    split them onto multiple lines using backslashes. We do not, however, call them
    brash two-liners (or brash seven-liners).
  prefs: []
  type: TYPE_NORMAL
- en: Get Ready to Be Brash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you launch into creating brash one-liners, take a moment to get into
    the right mindset:'
  prefs: []
  type: TYPE_NORMAL
- en: Be flexible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about where to start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know your testing tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll discuss each of these ideas in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Be Flexible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key to writing brash one-liners is *flexibility*. You’ve learned some awesome
    tools by this point—a core set of Linux programs (and umpteen ways to run them)
    along with command history, command-line editing, and more. You can combine these
    tools in many ways, and a given problem usually has multiple solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the simplest Linux tasks can be accomplished in many ways. Consider how
    you might list *.jpg* files in your current directory. I’ll bet 99.9% of Linux
    users would run a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is just one solution of many. For example, you could list *all* the
    files in the directory and then use `grep` to match only the names ending in *.jpg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Why would you choose this solution? Well, you saw an example in [“Long Argument
    Lists”](ch07.xhtml#tip_xargs), when a directory contained so many files that they
    couldn’t be listed by pattern matching. The technique of *grepping for a filename
    extension* is a robust, general approach for solving all sorts of problems. What’s
    important here is to be flexible and understand your tools so you can apply the
    best one in your time of need. That is a wizard’s skill when creating brash one-liners.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following commands list *.jpg* files in the current directory. Try
    to figure out how each command works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Are the results identical or do some commands behave a bit differently? Can
    you come up with any other suitable commands?
  prefs: []
  type: TYPE_NORMAL
- en: Think About Where to Start
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every brash one-liner begins with the output of a simple command. That output
    might be the contents of a file, part of a file, a directory listing, a sequence
    of numbers or letters, a list of users, a date and time, or other data. Your first
    challenge, therefore, is to produce the initial data for your command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to know the 17th letter of the English alphabet, then
    your initial data could be 26 letters produced by brace expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once you can produce this output, the next step is deciding how to massage it
    to fit your goal. Do you need to slice the output by rows or columns? Join the
    output with other information? Transform the output in a more complicated way?
    Look to the programs in Chapters [1](ch01.xhtml#ch_combining_commands) and [5](ch05.xhtml#ch_toolbox)
    to do that work, like `grep` and `sed` and `cut`, and apply them using the techniques
    of [Chapter 7](ch07.xhtml#ch_running_commands).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, you could print the 17th field with `awk`, or remove spaces
    with `sed` and locate the 17th character with `cut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As another example, if you want to print the months of the year, your initial
    data could be the numbers 1 through 12, again produced by brace expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, augment the brace expansion so it forms dates for the first day
    of each month (from `2021-01-01` through `2021-12-01`); then run `date -d` on
    each line to produce month names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, suppose you want to know the length of the longest filename in the current
    directory. Your initial data could be a directory listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, use `awk` to generate commands to count characters in each filename
    with `wc -c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '(The `-n` option prevents `echo` from printing newline characters, which would
    throw off each count by one.) Finally, pipe the commands to `bash` to run them,
    sort the numeric results from high to low, and grab the maximum value (the first
    line) with `head -n1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This last example was tricky, generating pipelines as strings and passing them
    to a further pipeline. Nevertheless, the general principle is the same: figure
    out your starting data and manipulate it to fit your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Know Your Testing Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building a brash one-liner may require trial and error. The following tools
    and techniques will help you try different solutions quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: Use command history and command-line editing.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t retype commands while you experiment. Use techniques from [Chapter 3](ch03.xhtml#ch_history)
    to recall previous commands, tweak them, and run them.
  prefs: []
  type: TYPE_NORMAL
- en: Add `echo` to test your expressions.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t sure how an expression will evaluate, print it with `echo` beforehand
    to see the evaluated results on stdout.
  prefs: []
  type: TYPE_NORMAL
- en: Use `ls` or add `echo` to test destructive commands.
  prefs: []
  type: TYPE_NORMAL
- en: If your command invokes `rm`, `mv`, `cp`, or other commands that might overwrite
    or remove files, place `echo` in front of them to confirm which files will be
    affected. (So, instead of executing `rm`, execute `echo rm`.) Another safety tactic
    is to replace `rm` with `ls` to list files that would be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Insert a `tee` to view intermediate results.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to view the output (stdout) in the middle of a long pipeline, insert
    the `tee` command to save output to a file for examination. The following command
    saves the output from `command3` in the file *outfile*, while piping that same
    output to `command4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: OK, let’s build some brash one-liners!
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a Filename into a Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This brash one-liner is similar to the one that opened the chapter (renaming
    *.jpg* files), but more detailed. It’s also a real situation I faced while writing
    this book. Like the previous one-liner, it combines two techniques from [Chapter 7](ch07.xhtml#ch_running_commands):
    process substitution and piping to `bash`. The result is a repeatable pattern
    for solving similar problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I wrote this book on a Linux computer using a typesetting language called [AsciiDoc](https://asciidoc.org).
    The language details aren’t important here; what matters is each chapter was a
    separate file, and originally there were 10 of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At some point, I decided to insert an 11th chapter between Chapters 2 and 3\.
    That meant renaming some files. Chapters 3–10 had to become 4–11, leaving a gap
    so I could make a new Chapter 3 (*ch03.asciidoc*). I could have renamed the files
    manually, starting with *ch11.asciidoc* and working backward:^([2](ch08.xhtml#idm46586638858416))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But this method is tedious (imagine if there were 1,000 files instead of 11!),
    so instead, I generated the necessary `mv` commands and piped them to `bash`.
    Take a good look at the preceding `mv` commands and think for a moment how you
    might create them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Focus first on the original filenames *ch03.asciidoc* through *ch10.asciidoc*.
    You could print them using brace expansion such as `ch{10..03}.asciidoc`, like
    the first example in this chapter, but to practice a little flexibility, use the
    `seq -w` command to print the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then turn this numeric sequence into filenames by piping it to `sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You now have a list of the original filenames. Do likewise for Chapters 4–11
    to create the destination filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To form the `mv` commands, you need to print the original and new filenames
    side by side. The first example in this chapter solved the “side by side” problem
    with `paste`, and it used process substitution to treat the two printed lists
    as files. Do the same here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The preceding command might look like a lot of typing, but with command history
    and Emacs-style command-line editing, it’s really not. To go from the single “`seq`
    and `sed`” line to the `paste` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Recall the previous command from history with the up arrow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Ctrl-A and then Ctrl-K to cut the whole line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the word `paste` followed by a space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Ctrl-Y twice to create two copies of the `seq` and `sed` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use movement and editing keystrokes to modify the second copy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prepend `mv` to each line by piping the output to `sed`, printing exactly the
    `mv` commands you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final step, pipe the commands to `bash` for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'I used exactly this solution for my book. After the `mv` commands ran, the
    resulting files were Chapters 1, 2, and 4–11, leaving a gap for a new Chapter
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern I just presented is reusable in all kinds of situations to run
    a sequence of related commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate the command arguments as lists on stdout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the lists side by side with `paste` and process substitution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepend a command name with `sed` by replacing the beginning-of-line character
    (`^`) with a program name and a space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pipe the results to `bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking Matched Pairs of Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This brash-one liner is inspired by a real use of Mediawiki, the software that
    powers Wikipedia and thousands of other wikis. Mediawiki allows users to upload
    images for display. Most users follow a manual process via web forms: click Choose
    File to bring up a file dialog, navigate to an image file and select it, add a
    descriptive comment in the form, and click Upload. Wiki administrators use a more
    automated method: a script that reads a whole directory and uploads its images.
    Each image file (say, *bald_eagle.jpg*) is paired with a text file (*bald_eagle.txt*)
    containing a descriptive comment about the image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you’re faced with a directory filled with hundreds of image files
    and text files. You want to confirm that every image file has a matching text
    file and vice versa. Here’s a smaller version of that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s develop two different solutions to identify any unmatched files. For
    the first solution, create two lists, one for the JPEG files and one for the text
    files, and use `cut` to strip off their file extensions *.txt* and *.jpg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then compare the lists with `diff` using process substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You could stop here, because the output indicates that the first list has an
    extra *blue_jay* (implying *blue_jay.jpg*) and the second list has an extra *oriole*
    (implying *oriole.txt*). Nevertheless, let’s make the results more precise. Eliminate
    unwanted lines by grepping for the characters `<` and `>` at the beginning of
    each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use `awk` to append the correct file extension to each filename (`$2`),
    based on whether the filename is preceded by a leading `<` or `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You now have your list of unmatched files. However, this solution has a subtle
    bug. Suppose the current directory contained the filename *yellow.canary.jpg*,
    which has two dots. The preceding command would produce incorrect output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This problem occurs because the two `cut` commands remove characters from the
    first dot onward, instead of the last dot onward, so *yellow.canary.jpg* is truncated
    to *yellow* rather than *yellow.canary*. To fix this issue, replace `cut` with
    `sed` to remove characters from the last dot to the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first solution is now complete. The second solution takes a different approach.
    Instead of applying `diff` to two lists, generate a single list and weed out matched
    pairs of filenames. Begin by removing the file extensions with `sed` (using the
    same sed script as before) and count the occurrences of each string with `uniq
    -c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line of output contains either the number `2`, representing a matched
    pair of filenames, or `1`, representing an unmatched filename. Use `awk` to isolate
    lines that begin with whitespace and a `1`, and print only the second field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For the final step, how can you add the missing file extensions? Don’t bother
    with any complicated string manipulations. Just use `ls` to list the actual files
    in the current directory. Stick an asterisk (a wildcard) onto the end of each
    line of output with `awk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: and feed the lines to `ls` via command substitution. The shell performs pattern
    matching, and `ls` lists the unmatched filenames. Done!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generating a CDPATH from Your Home Directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the section [“Organize Your Home Directory for Fast Navigation”](ch04.xhtml#cs_homedir),
    you wrote a complicated `CDPATH` line by hand. It began with `$HOME`, followed
    by all subdi­r⁠ectories of `$HOME`, and ended with the relative path `..` (parent
    directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a brash one-liner to generate that `CDPATH` line automatically,
    suitable for insertion into a `bash` configuration file. Begin with the list of
    subdirectories in `$HOME`, using a subshell to prevent the `cd` command from changing
    your shell’s current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `$HOME/` in front of each directory with `sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding sed script is slightly complicated because the replacement string,
    `$HOME/`, contains a forward slash, and `sed` substitutions also use the forward
    slash as a separator. That’s why my slash is escaped: `$HOME\/`. To simplify things,
    recall from [“Substitution and Slashes”](ch05.xhtml#tip_sed_slash) that `sed`
    accepts any convenient character as a separator. Let’s use at signs (`@`) instead
    of forward slashes so no escaping is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, lop off the final forward slash with another `sed` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the output on a single line using `echo` and command substitution. Notice
    that you no longer need plain parentheses around `cd` and `ls` to create a subshell
    explicitly, because command substitution creates a subshell of its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the first directory `$HOME` and the final relative directory `..`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Change spaces to colons by piping all the output so far to `tr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `CDPATH` environment variable, and you have generated a variable
    definition to paste into a `bash` configuration file. Store this command in a
    script to generate the line anytime, like when you add a new subdirectory to `$HOME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Generating Test Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common task in the software industry is testing—feeding a wide variety of
    data to a program to validate that the program behaves as intended. The next brash
    one-liner generates one thousand files containing random text that could be used
    in software testing. The number one thousand is arbitrary; you can generate as
    many files as you want.
  prefs: []
  type: TYPE_NORMAL
- en: The solution will select words randomly from a large text file and create one
    thousand smaller files with random contents and lengths. A perfect source file
    is the system dictionary */usr/share/dict/words*, which contains 102,305 words,
    each on its own line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce this brash one-liner, you’ll need to solve four puzzles:'
  prefs: []
  type: TYPE_NORMAL
- en: Randomly shuffling the dictionary file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting a random number of lines from the dictionary file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an output file to hold the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running your solution one thousand times
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To shuffle the dictionary into random order, use the aptly named command `shuf`.
    Each run of the command `shuf /usr/share/dict/words` produces more than a hundred
    thousand lines of output, so peek at the first few random lines using `head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Your first puzzle is solved. Next, how can you select a random quantity of
    lines from the shuffled dictionary? `shuf` has an option, `-n`, to print a given
    number of lines, but you want the value to change for each output file you create.
    Fortunately, `bash` has a variable, `RANDOM`, that holds a random positive integer
    between 0 and 32,767\. Its value changes every time you access the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, run `shuf` with the option `-n $RANDOM` to print a random number
    of random lines. Again, the full output could be very long, so pipe the results
    to `wc -l` to confirm that the number of lines changes with each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve solved the second puzzle. Next, you need one thousand output files,
    or more specifically, one thousand different filenames. To generate filenames,
    run the program `pwgen`, which generates random strings of letters and digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the option `-N1` to generate just a single string, and specify the string
    length (10) as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, make the string look more like the name of a text file, using command
    substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Third puzzle complete! You now have all the tools to generate a single random
    text file. Use the `-o` option of `shuf` to save its output in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'and check the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks good! The final puzzle is how to run the preceding `shuf` command one
    thousand times. You could certainly use a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'but that’s not as fun as creating a brash one-liner. Instead, let’s pregenerate
    the commands, as strings, and pipe them to `bash`. As a test, print your desired
    command once using `echo`. Add single quotes to ensure that `$RANDOM` doesn’t
    evaluate and `pwgen` doesn’t run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This command can easily be piped to `bash` for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, print the command one thousand times using the `yes` command piped to
    `head`, then pipe the results to `bash`, and you’ve solved the fourth puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’d prefer one thousand random image files instead of text files, use
    the same technique (`yes`, `head`, and `bash`) and replace `shuf` with a command
    that generates a random image. Here’s a brash one-liner that I adapted from a
    [solution by Mark Setchell on Stack Overflow](https://oreil.ly/ruDwG). It runs
    the command `convert`, from the graphics package ImageMagick, to produce random
    images of size 100 x 100 pixels consisting of multicolored squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Generating Empty Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes all you need for testing is lots of files with different names, even
    if they’re empty. Generating a thousand empty files named *file0001.txt* through
    *file1000.txt* is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer more interesting filenames, grab them randomly from the system
    dictionary. Use `grep` to limit the names to lowercase letters for simplicity
    (avoiding spaces, apostrophes, and other characters that would be special to the
    shell):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Shuffle the names with `shuf` and print the first thousand with `head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, pipe the results to `xargs` to create the files with `touch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope the examples in this chapter helped to build your skills in writing brash
    one-liners. Several of them provided reusable patterns that you may find useful
    in other situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat: brash one-liners are not the only solution in town. They’re just
    one approach to working efficiently at the command line. Sometimes you’ll get
    more bang for the buck by writing a shell script. Other times you’ll find better
    solutions with a programming language such as Perl or Python. Nevertheless, brash
    one-liner-writing is a vital skill for performing critical tasks with speed and
    style.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.xhtml#idm46586639000896-marker)) The earliest use of this term (that
    I know of) is the [manpage for lorder(1)](https://oreil.ly/ro621) in BSD Unix
    4.x. Thanks to Bob Byrnes for finding it.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.xhtml#idm46586638858416-marker)) Starting with *ch03.asciidoc* and
    working forward would be dangerous—can you see why? If not, create these files
    with the command `touch ch{01..10}.asciidoc` and try it yourself.
  prefs: []
  type: TYPE_NORMAL
