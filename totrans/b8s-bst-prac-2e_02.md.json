["```\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/asn1\"\n\t\"encoding/pem\"\n\t\"os\"\n)\n\nfunc main() {\n\tname := os.Args[1]\n\tuser := os.Args[2]\n\n\tkey, err := rsa.GenerateKey(rand.Reader, 1024)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tkeyDer := x509.MarshalPKCS1PrivateKey(key)\n\tkeyBlock := pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: keyDer,\n\t}\n\tkeyFile, err := os.Create(name + \"-key.pem\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tpem.Encode(keyFile, &keyBlock)\n\tkeyFile.Close()\n\n\tcommonName := user\n\t// You may want to update these too\n\temailAddress := \"someone@myco.com\"\n\n\torg := \"My Co, Inc.\"\n\torgUnit := \"Widget Farmers\"\n\tcity := \"Seattle\"\n\tstate := \"WA\"\n\tcountry := \"US\"\n\n\tsubject := pkix.Name{\n\t\tCommonName:         commonName,\n\t\tCountry:            []string{country},\n\t\tLocality:           []string{city},\n\t\tOrganization:       []string{org},\n\t\tOrganizationalUnit: []string{orgUnit},\n\t\tProvince:           []string{state},\n\t}\n\n\tasn1, err := asn1.Marshal(subject.ToRDNSequence())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcsr := x509.CertificateRequest{\n\t\tRawSubject:         asn1,\n\t\tEmailAddresses:     []string{emailAddress},\n\t\tSignatureAlgorithm: x509.SHA256WithRSA,\n\t}\n\n\tbytes, err := x509.CreateCertificateRequest(rand.Reader, &csr, key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcsrFile, err := os.Create(name + \".csr\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpem.Encode(csrFile, &pem.Block{Type: \"CERTIFICATE REQUEST\", Bytes:\n      bytes})\n\tcsrFile.Close()\n}\n```", "```\ngo run csr-gen.go client <user-name>;\n```", "```\n#!/bin/bash\n\ncsr_name=\"my-client-csr\"\nname=\"${1:-my-user}\"\n\ncsr=\"${2}\"\n\ncat <<EOF | kubectl create -f -\napiVersion: certificates.k8s.io/v1\nkind: CertificateSigningRequest\nmetadata:\n name: ${csr_name}\nspec:\n groups:\n - system:authenticated\n request: $(cat ${csr} | base64 | tr -d '\\n')\n usages:\n - key encipherment\n - client auth\nEOF\n\necho\necho \"Approving signing request.\"\nkubectl certificate approve ${csr_name}\n\necho\necho \"Downloading certificate.\"\nkubectl get csr ${csr_name} -o jsonpath='{.status.certificate}' \\\n\t| base64 --decode > $(basename ${csr} .csr).crt\n\necho\necho \"Cleaning up\"\nkubectl delete csr ${csr_name}\n\necho\necho \"Add the following to the 'users' list in your kubeconfig file:\"\necho \"- name: ${name}\"\necho \"  user:\"\necho \"    client-certificate: ${PWD}/$(basename ${csr} .csr).crt\"\necho \"    client-key: ${PWD}/$(basename ${csr} .csr)-key.pem\"\necho\necho \"Next you may want to add a role-binding for this user.\"\n```", "```\nns='my-namespace'\nteam='some team'\nkubectl create namespace ${ns}\nkubectl annotate namespace ${ns} team=${team}\n```", "```\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: example\n  namespace: my-namespace\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: edit\nsubjects:\n- apiGroup: rbac.authorization.k8s.io\n  kind: User\n  name: myuser\n```", "```\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: limit-compute\n  namespace: my-namespace\nspec:\n  hard:\n    # These look a little odd because they're not nested\n\t# but they refer to the requests and limit fields in\n\t# a Pod\n    requests.cpu: \"10\"\n    requests.memory: 100Gi\n    limits.cpu: 10\n    limits.memory: 100Gi\n```", "```\nkubectl create my-service/database-stateful-set-yaml\nkubectl create my-service/middle-tier.yaml\nkubectl create my-service/configs.yaml\n```", "```\n{\n    ...\n    \"scripts\": {\n        \"setup\": \"./setup.sh\",\n        ...\n    }\n}\n```", "```\nkubectl delete -f ./my-service/deployment.yaml\nperl -pi -e 's/${old_version}/${new_version}/' ./my-service/deployment.yaml\nkubectl create -f ./my-service/deployment.yaml\n```"]