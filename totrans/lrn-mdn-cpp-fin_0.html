<html><head></head><body><div id="sbo-rt-content"><section class="pagenumrestart" data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 1. An Overview of C++"><div class="chapter" id="an_overview_of_c">
<h1><span class="label">Chapter 1. </span>An Overview of C++</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45807810298800">
<h5>A Note for Early Release Readers</h5>

<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 1st chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <em>learnmodcppfinance@gmail.com</em>.</p>
</div></aside>

<p>Before launching into programming in C++, it will be useful to present a brief overview of the language the C++ Standard Library, and the ways in which C++ continues to have a major presence in quantitative finance.</p>

<p>You may have already felt intimidated by opinions and rumors claiming that C++ is extraordinarily difficult to learn and fraught with minefields. So, in this chapter, we will try to allay these fears by first debunking some of the common myths about C++, and then presenting straightforward examples to help you get up and running.</p>

<p>Most of the content here is likely familiar for most readers, but the discussion here attempts to extend some of the basics with points about quantitative programming and best practices that often are not included in introductory books. We will also have our first look at C++20, namely mathematical constants that have been added to the C++ Standard Library.</p>

<p>By the end of the chapter, you should be able to write, compile, and run simple C++ programs, understand basic numerical types, and employ mathematical functions in the Standard Library that are fundamental in just about any quantitative discipline, including finance.</p>

<section data-type="sect1" data-pdf-bookmark="C++ and Quantitative Finance"><div class="sect1" id="c_and_quantitative_finance">
<h1><span>C++ and Quantitative Finance</span></h1>

<p>C++ started its rapid growth in the financial sector around the mid-1990’s. Many of us who were in the industry around this time had been raised on FORTRAN, particularly for writing numerical routines and scientific applications. While FORTRAN and its supporting libraries were very well-developed in terms of mathematical and linear algebra support, it lacked support for object-oriented programming.</p>

<p>Financial modeling in the abstract is naturally comprised of different components that interact with each other. For example, to price even a simple derivative contract based on foreign exchange and interest rates, one would typically require the following:</p>

<ul>
	<li>
	<p>The term structure of interest rates for each currency</p>
	</li>
	<li>
	<p>A market rate feed of live foreign exchange rate quotes</p>
	</li>
	<li>
	<p>Volatility curves or surfaces for movements in FX rates and interest rates</p>
	</li>
	<li>
	<p>A set of pricing methods, eg closed form, simulation, or other numerical approximations</p>
	</li>
</ul>

<p>Each of these components can be represented by an <em>object</em>, and C++ provided the means for creating these objects and managing their relationships to each other.</p>

<p>Banks and other financial institutions also needed a way to calculate risk measures at both a regional and global scale. This was a particular challenge for companies with trading operations spread across the major financial centers of New York, London, and Tokyo, as well as other capital markets. At the start of each trading day, risk reporting was required for a firm’s headquarters in, say, New York that took into account the portfolios maintained both locally and around the world. This could be a computationally intensive task, but the performance of C++ made it possible and was yet another significant factor in its early adoption in the financial industry.</p>

<p>Around the turn of the century, newer object-oriented languages, such as Java and C#, made software development a relatively simpler and faster process, while more efficient processors became less expensive. However, the same features in these languages that enabled quicker deployment, such as built-in managed memory and intermediate compilation, could also introduce overhead in terms of run-time performance. Management decisions on which language to adopt often came down to a trade-off between more rapid development and run-time efficiency. Even if one of these language alternatives was employed, computationally intensive pricing models and risk calculations were -- and still are -- often delegated to existing C++ libraries and called via an interface. It should also be noted that C++ also offers certain compile-time optimizations that are not available in these other programming languages.</p>

<section data-type="sect2" data-pdf-bookmark="C++ 11: The Modern Era is Born"><div class="sect2" id="c_11_the_modern_era_is_born">
<h2><span>C++</span> <span>11: The Modern Era is Born</span></h2>

<p>In 2011, the <a href="https://isocpp.org"><span>Standard C++ Foundation</span></a> released a substantial revision that addressed long-needed modernization and in particular provided some very welcome abstractions that are immediately useful to quantitative developers. These include:</p>

<ul>
	<li>
	<p>Random number generation from a variety of probability distributions</p>
	</li>
	<li>
	<p>Lambda expressions that encapsulate mathematical functions that can also be passed as arguments</p>
	</li>
	<li>
	<p>Task-based concurrency that can parallelize computations without the need for manual thread management</p>
	</li>
	<li>
	<p>Smart pointers that prevent memory-related program crashes, without affecting performance</p>
	</li>
</ul>

<p>These topics and more will be discussed in the chapters ahead. An excellent reference that covers the history and evolution of C++ into the modern era is also available from O’Reilly: <em>C++</em><em> Today: The Beast is Back</em>, by Jon Kalb and Gasper Azman [1]. It should also be noted that with more attention to, and promotion of <a href="https://isocpp.org/wiki/faq/coding-standards"><span>best practices</span></a>[1] and <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"><span>guidelines</span></a>[2] by the ISO C++ committee, cross-platform development is now a much easier task than in years past.</p>

<p>And following C++11, new releases with more and more modern features addressing the demands of financial and data science industries are being rolled out on a threeyear cadence, with the most recent release being C++20. This book will primarily cover developments through C++20, particularly those that should be of interest to financial quant developers. Proposals currently in the works for future standards are also mentioned where relevant.</p>

<p>Proprietary and high-frequency trading firms have been at the forefront of adopting the C++11 Standard and later, where the speed of acting on market and trading book signals in statistical strategies can mean a profound difference in profit and loss. Modern C++ is also in keen demand for derivatives pricing models utilized by traders and risk managers at investment banks and hedge funds. The recent random number generation and concurrency features in the Standard Library, for example, provide built-in support for efficient Monte Carlo simulation that is a key component in both evaluating trading strategies and pricing complex exotic options. These tasks used to require many more hours of distributional random number generation code development and time-consuming integration of platform-dependent threading libraries.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Open Source Mathematical Libraries"><div class="sect2" id="open_source_mathematical_libraries">
<h2><span>Open Source Mathematical Libraries</span></h2>

<p>Another very welcome development over the past decade has been the proliferation of robust open-source mathematical libraries written in standard C++ that therefore do not require the time-consuming C-language interface gymnastics of the past. Primary among these are the Boost libraries, the Eigen and Armadillo matrix algebra libraries, and machine learning libraries such as TensorFlow and PyTorch. We will cover Boost and Eigen in more detail later in the book.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Debunking Myths About C++"><div class="sect1" id="debunking_myths_about_c">
<h1><span>Debunking Myths About C++</span></h1>

<p>There are a multitude of myths about C++. Here are several of the more infamous beliefs, and explanations which debunk them.</p>

<ul>
	<li>
	<p><em>Knowledge of C is necessary for learning C++</em>: While the C++ Standard retains most of the C language, it is entirely possible to learn C++ without knowledge of C, as we shall see. Clinging to C style can in fact hinder learning the powerful abstractions and potential benefits of C++.</p>
	</li>
	<li>
	<p><em>C++ is too difficult</em>: There is no doubt that C++ is a rich language that provides plenty of the proverbial rope with which one can hang oneself, but by leveraging _modern_ features of the language while holding legacy issues in abeyance at the outset, it is entirely possible to become very productive as a quantitative developer in C++ very quickly.</p>
	</li>
	<li>
	<p><em>Memory leaks are always a problem in </em><em>C++</em>: With smart pointers available since C++11, this no longer needs to be an issue in most financial model implementations, as we shall see.</p>
	</li>
</ul>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Compiled vs Interpreted Code"><div class="sect1" id="compiled_vs_interpreted_code">
<h1><span>Compiled vs Interpreted Code</span></h1>

<p>As alluded to above, C++ is a compiled language, where commands typed into a file by us mere mortals are translated into binary instructions, or <em>machine code</em>, that a computer processor will understand. This is in contrast to non-typed and interpreted quantitative languages such as Python, R, and Matlab, where each line of code must be individually translated to machine code at run-time, thus slowing down execution time for larger applications.</p>

<p>This is by no means a knock on these languages, as their power is evident in their popularity for rapid implementations of models arising in quantitative fields such as finance, data science, and biosciences, with their built-in mathematical and statistical functions are often compiled in C, C++, or FORTRAN. However, the financial world at least is replete with stories where a model would require days to run in an interpreted language, where run times could be reduced to a matter of minutes when reimplemented in C++.</p>

<p>An effective approach is to use interpreted mathematical languages with C++ in a complementary fashion. For example, when computationally intensive models code is written in a C++ library, and then called either interactively or from an application in R, for example, C++ efficiently takes care of the number crunching. The results can then be used inside powerful plotting and other visualization tools in R that are not available in C++.</p>

<p>Another advantage is that the models code is written once and maintained in a C++ library that can be deployed across many different departments, divisions, and even international boundaries, and called via interfaces from applications in written in different front-end languages, while ensuring consistent numerical results throughout the organization. This can be particularly advantageous for regulatory compliance purposes.</p>

<p>Popular open-source C++ packages are available for both R and Python, namely <a href="http://www.rcpp.org/"><span>Rcpp</span></a> and <a href="https://github.com/pybind/pybind11"><span>pybind11</span></a>, respectively. Matlab also provides options for C++ interfaces.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="The Components of  C++"><div class="sect1" id="the_components_of_c">
<h1><span>The Components of </span> <span>C++</span></h1>

<p>Standard C++ releases, at a high level, consist of two components: language features, and the C++ Standard Library. A software library is essentially a set of functions and classes that are not executable on their own but that are called by an application or system. Library development -- both open source and commercial -- now dominates modern C++ development compared to standalone applications that were popular in previous decades, and we will discuss some of those later that are useful for computational work. The most important C++ library is the Standard Library that is shipped with modern compilers.</p>

<section data-type="sect2" data-pdf-bookmark="C++  Language Features"><div class="sect2" id="c_language_features">
<h2><span>C++</span> <span> Language Features</span></h2>

<p>C++ language features mostly overlap with the essential operators and constructs one would find in other programming languages, such as:</p>

<ul>
	<li>
	<p>Fundamental integer and floating-point numerical types</p>
	</li>
	<li>
	<p>Conditional branching: <code>if/else if/else</code> statements and switch/case statements</p>
	</li>
	<li>
	<p>Iterative constructs: for loops and <code>while</code> loops</p>
	</li>
	<li>
	<p>Standard mathematical variable types: integer, double precision floating point, etc</p>
	</li>
	<li>
	<p>Standard mathematical and logical operators for numerical types: addition, subtraction, multiplication, division, modulus, and inequalities</p>
	</li>
</ul>

<p>In addition, C++ is not limited to object-oriented programming; rather, the language also supports the other three major programming paradigms, namely procedural programming, generic programming, and functional programming. Each of these will be discussed in subsequent chapters.</p>

<p>C++ is a strongly-typed language, meaning that before we use a variable, we must declare it by its type. The language provides a variety of numerical types; however, those that we will primarily use are as follows:</p>

<table id="Table1.1">
	<thead>
		<tr>
			<th>Type</th>
			<th>Description</th>
			<th>Minimum Value</th>
			<th>Maximum Value</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>double</td>
			<td>Double Precision</td>
			<td>+/- 2.2e-308</td>
			<td>+/- 1.8e308</td>
		</tr>
		<tr>
			<td>int</td>
			<td>Integer</td>
			<td>-2,147,483,648</td>
			<td>2,147,483,647</td>
		</tr>
	</tbody>
</table>

<p>Others, such as unsigned and extended integer types, will be introduced later when we need them.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="The C++ Standard Library"><div class="sect2" id="the_c_standard_library">
<h2><span>The C++ Standard Library</span></h2>

<p>As Nicolai Josuttis describes it in his indispensable text, <em>The C++ Standard Library - A Tutorial and Reference, 2nd Edition</em>[3], the C++ Standard Library “enable(s) programmers to use general components and a higher level of abstraction without losing portability rather than having to develop all code from scratch.” Up through the latest C++20 release, highly useful library features for quantitative model implementations include:</p>

<ul>
	<li>
	<p>Array-style containers, particularly the venerable `vector` class</p>
	</li>
	<li>
	<p>A wide set of standard algorithms that operate on these array containers, such as sorting, searching, and efficiently applying functions to a range of elements in a container</p>
	</li>
	<li>
	<p>Standard real-valued mathematical functions such as square root, exponential, and trigonometric functions</p>
	</li>
	<li>
	<p>Complex numbers and arithmetic</p>
	</li>
	<li>
	<p>Random number generation from a set of standard probability distributions</p>
	</li>
	<li>
	<p>Task-based concurrency that manages threads internally and safely</p>
	</li>
	<li>
	<p>Smart pointers that abstract away the dangers associated with memory management</p>
	</li>
	<li>
	<p>A class to store and manage character data</p>
	</li>
	<li>
	<p>Streaming functions to take input from and display results to the console</p>
	</li>
</ul>

<p>Use of Standard Library components, however, requires the programmer to explicitly import them into the code, as they reside in a separate library rather than within the core language. The idea is similar to importing a NumPy array into a Python program or loading an external package of functions into an R script. In C++, this is a two-step process, starting with loading the file containing the Standard Library declarations of functions and classes we wish to use, and then scoping these functions with the Standard Library namespace name, `std` (often pronounced as “stood” by C++ developers).</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Compilers and IDE’s  "><div class="sect1" id="compilers_and_ide_s">
<h1><span>Compilers and IDE’s</span> <span> </span></h1>

<p>In order to get started with learning C++, you will need to obtain a compiler and a development environment. The three major modern and freely available compilers, which ship with their implementations of the C++ Standard Library, are:</p>

<ul>
	<li>
	<p><span><a href="https://visualstudio.microsoft.com/vs/features/cplusplus/">The Microsoft Visual Studio 2019 compiler</a> </span></p>
	</li>
	<li>
	<p><a href="https://clang.llvm.org/"><span>Clang (LLVM Project)</span> </a></p>
	</li>
	<li>
	<p><a href="https://gcc.gnu.org/"><span>GNU gcc compiler</span></a></p>
	</li>
</ul>

<p>There are also several integrated development environments (IDE’s) available, namely Visual Studio, Apple’s Xcode (which ships with the Clang compiler), and CLion, a product that typically requires purchase from JetBrains. For this book, Microsoft’s Visual Studio compiler and IDE are highly recommended. They are user-friendly options to get up and running quickly on C++, with very powerful debugging tools.</p>

<p>Furthermore, the Visual Studio option also includes a Clang option that allows a programmer to switch between it and the Microsoft compiler, helping to ensure cross-platform compatibility.</p>

<p>Unfortunately, the Visual Studio option for C++ only exists for Windows, as the Mac version does not ship with a C++ option. In this case, one might opt for downloading Apple’s Xcode, which ships with the Clang compiler. Linux users will typically want to opt for the gcc or Clang compiler.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Basic Review of C++"><div class="sect1" id="basic_review_of_c">
<h1><span>Basic Review of C++</span></h1>

<p>The following will be a quick review of C++ using some simple code examples. We will also have our first look at a new feature in C++20, namely mathematical constants.</p>

<section data-type="sect2" data-pdf-bookmark="Good Old “Hello World!”"><div class="sect2" id="good_old_hello_world">
<h2><span>Good Old “Hello World!”</span></h2>

<p>First, here is a “Hello World!” example to get started. The following code will return the message to the screen, and then allow the user to input the name of someone to whom to say hello:</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
#include &lt;iostream&gt;
#include &lt;string&gt;
int main()
{
	std::cout &lt;&lt; "Hello World!" &lt;&lt; '\n';
	std::string person;
	std::cout &lt;&lt; "To whom do you wish to say hello? ";
	std::cin &gt;&gt; person;
	std::cout &lt;&lt; "Hello "&lt;&lt; person &lt;&lt; "!" &lt;&lt; '\n';
	return 0;
}</strong></pre>
</div>

<p>If you want to say hello to your mother, then after compiling and running the code, the screen would resemble the following:</p>

<div data-type="example">
<pre data-type="programlisting">
Hello World!
To whom do you wish to say hello? Mom
Hello Mom!</pre>
</div>

<p>The main review points here are</p>

<ul>
	<li>
	<p><code>cout</code> and <code>cin</code>, along with the string class, depend upon including the C++ Standard Library declaration files iostream and string.</p>

	<p>Members of the Standard Library need to be scoped by their namespace <code>std</code>. An alternative is to put <code>using</code> statements with the namespace scopes at the top of the file, indicating that anytime these elements appear in the code, they are understood to be coming from the std namespace. Also, you may find it easier to type <code>endl</code> (end of line) rather than '\n’:</p>

	<pre data-type="programlisting">
<strong>
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
#include &lt;string&gt;
using std::string;
int main()
{
	cout &lt;&lt; "Hello World!" &lt;&lt; endl;
	string person;
	cout &lt;&lt; "To whom do you wish to say hello? ";
	cin &gt;&gt; person;
	cout &lt;&lt; "Hello " &lt;&lt; person &lt;&lt; "!" &lt;&lt; endl;
	return 0;
}</strong></pre>
	</li>
	<li>
	<p>Importing the std namespace into the global namespace with</p>

	<pre data-type="programlisting">
using namespace std;</pre>

	<p>is sometimes used to replace the individual using statements; however, this is not considered good practice, as it can result in naming clashes at compile time. The motivation behind namespaces will be presented in Chapter 3.</p>
	</li>
	<li>
	<p>Output to and input from the console is almost never used in production-level financial programming. User input data will typically come from graphical user interfaces (GUIs) or web applications, while market data usually comes from live feeds. Results are typically displayed in the user interface and then stored in a database, such as when a trade in executed.</p>
	</li>
	<li>
	<p>We will use <code>cout</code> and <code>cin</code> to sometimes mimic these inputs, but they should be avoided in production code.</p>
	</li>
</ul>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Simple Procedural Programming in C++"><div class="sect2" id="simple_procedural_programming_in_c">
<h2><span>Simple Procedural Programming in C++</span></h2>

<p>The structure of a procedural program should be familiar, namely:</p>

<ul>
	<li>
	<p>A `main()` function, which is called first in execution of a program, and</p>
	</li>
	<li>
	<p>A set of user-defined functions that contain individual tasks that comprise the program.</p>
	</li>
</ul>

<p>In the simplest case, these can all be written in a single executable file containing `main()`.</p>

<p>We first <em>declare</em> each user-defined function in a function <em>declaration</em> statement, prior to the start of program execution in the `main()` function. A function declaration states its name, return type, and input argument types, followed by a semicolon.</p>

<p>The function <em>implementations</em> are written beneath `main()`, each containing a series of commands within open and closed braces. User-defined function calls can then be made within the `main` function, or from other user-defined functions.</p>

<p>Single line comments are indicated by two consecutive forward slashes. The high-level format is shown here:</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
// Function declarations ("//" indicates a comment line)
return_type function_01(input arguments);
return_type function_02(input arguments);
return_type function_03(input arguments);
.
.
.
int main()
{
  // Call each function 
  function_01(input arguments);
  function_02(input arguments);
  function_03(input arguments);
.
.
.
}
return_type function_01(input arguments)
{
  // Do stuff
  // Return something (or void return)
}
return_type function_02(input arguments)
{
  // Do stuff
  // Return something (or void return)
}
return_type function_03(input arguments)
{
  // Do stuff
  // Return something (or void return)
}</strong>
.
.
.</pre>
</div>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>For larger and more robust production applications, we will soon look at writing functions in separate <em>modules</em>, using a new feature in C++20, in which the same method of declaring and implementing functions will carry over.</p>
</div>

<p>Further details on functions follow in the next two subsections.</p>

<section data-type="sect3" data-pdf-bookmark="Function declarations"><div class="sect3" id="function_declarations">
<h3><span>Function declarations</span></h3>

<p>C++ functions may or may not return a value; furthermore, they may or may not take input arguments. A function that has no return value is indicated by a `void` return type. For example, if we move our “Hello World” example into a separate function, it would simply output a message to the screen without returning a value when called from the `main` function, so it would be declared as a `void` function. In addition, it does not require any input parameters, so its declaration would take on the form</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
void hello_world();    </strong></pre>
</div>

<p>Next, suppose we want to write a real-valued function that takes in a single variable and returns twice its value. In this case, our declaration will have a double precision floating type return, indicated by `double`, and an input of the same type. If we name this function `twice_a_real`, and the input variable `x`, our declaration would be written as</p>

<div data-type="example">
<pre data-type="programlisting">
double twice_a_real(double x);    </pre>
</div>

<p>As a final example, as in other programming languages, a function can take in more than one variable. Suppose we wish to add three integers in a function called `add_three_ints` and return the sum of variables `i`, `j`, and `k`. Integer types are indicated by `int`, so our function declaration would be</p>

<div data-type="example">
<pre data-type="programlisting">
int add_three_ints(int i, int j, int k);    </pre>
</div>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Function implementations"><div class="sect3" id="function_implementations">
<h3><span>Function implementations</span></h3>

<p>Function implementations, also called function <em>definitions</em>, are where we implement the actual commands to display a message to the screen, calculate a mathematical result, or to perform other tasks. The <em>body</em> of the function is placed inside braces, as shown here for the `hello_world` function. We again need to indicate the `void` return type.</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
void hello_world()
{
  std::cout &lt;&lt; "Hello World!\n";
}</strong></pre>
</div>

<p>Next, we can write the implementations of our two simple mathematical functions. As in their declarations, the `double` and `int` return types, respectively, as well as the types of their input variables, must be included:</p>

<div data-type="example">
<pre data-type="programlisting">
double twice_a_real(double x)
{
	double y = 2.0 * x;
	return y;
}
int add_three_ints(int i, int j, int k)
{
	return i + j + k;
}</pre>
</div>

<p>In the first case, we initialize a new `double` variable `y` and with the result of the calculation. Because C++ is a strongly typed language, we need to indicate the type of a variable when it is initialized. This variable is then returned to the `main` function with the result. In the second function, we just put the sum operations in the return statement itself; this is also perfectly legal.</p>

<p>Finally, we put this all together with a `main` function that is called when the program starts and makes calls to our user-defined functions. It goes in between the user-defined function declarations and their implementations below, as shown here:</p>

<div data-type="example">
<pre data-type="programlisting">
#include &lt;iostream&gt;
// Maybe put in using statements here(?)
void hello_world();
double twice_a_real(double x);
int add_three_ints(int i, int j, int k);
int main()
{
	hello_world();
	double prod = twice_a_real(2.5);
	std::cout &lt;&lt; "2 x 2.5 = " &lt;&lt; prod &lt;&lt; std::endl;
	std::cout &lt;&lt; "1 + 2 + 3 = " &lt;&lt; add_three_ints(1, 2, 3) &lt;&lt; std::endl;
	double r;
	std::cout &lt;&lt; "Enter a real number: ";
	std::cin &gt;&gt; r;
	std::cout &lt;&lt; "2 x " &lt;&lt; r &lt;&lt; " = " &lt;&lt; twice_a_real(r) &lt;&lt; std::endl;
	return 0;
}
void hello_world()
{
	std::cout &lt;&lt; "Hello World!\n";
}
double twice_a_real(double x)
{
	double y = 2.0 * x;
	return y;
}
int add_three_ints(int i, int j, int k)
{
	return i + j + k;
}</pre>
</div>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="C++ Syntax and Style Guidelines"><div class="sect2" id="c_syntax_and_style_guidelines">
<h2><span>C++ Syntax and Style Guidelines</span></h2>

<p>In this section a review of essential C++ syntax is provided, along with guidelines on code formatting and variable naming. The guidelines discussion might not be high on many people’s priority list, but this topic is in fact quite important when writing critical production code in financial systems, in a feature-rich language such as C++. Bugs, runtime errors, and program crashes are much more easily avoided or addressed if the source code is written in a clean and maintainable state.</p>

<section data-type="sect3"><div class="sect3" id="_idURnzdr">
<p>We will review essential rules about C++ syntax. Even if you are familiar with some of it already, a summary will be presented in one place that you may find useful.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Code Blocks in Braces"><div class="sect3" id="code_blocks_in_braces">
<h3><span>Code Blocks in Braces</span></h3>

<p>Function implementations, also called <em>function definitions</em>, are placed inside braces, as shown in each of the function implementations in 6.2.2 above. When control reaches the closing brace, the function terminates. This is also true for other code blocks such as in conditional statements, loops, user-defined functions, and user-defined classes. When the closing brace is encountered, non-static local variables and objects defined within the block are said to _go out of scope_. That is, they are wiped from memory and no longer accessible. Pointers can be an exception to this rule, but we will discuss this in more detail in Chapter XX.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Syntax Review"><div class="sect3" id="syntax_review">
<h3><span>Syntax Review</span></h3>

<p>Commands and declarations in C++ terminate with a semicolon:</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
double y = 2.0 * x;</strong></pre>
</div>

<p>Again, as C++ is a strongly-typed language, numerical variable types should be indicated before initialization.</p>

<div data-type="example">
<pre data-type="programlisting">
double x1 = 10.6;
int k;	// Defaults to zero
double y1 = twice_a_real(x1);</pre>
</div>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C++11 introduced the `auto` keyword that can automatically deduce a variable or object type, as well as uniform initialization (with braces). Varied opinions on their use exist, but many programmers still prefer to explicitly state plain old data (POD) types such as `int` and `double` to avoid ambiguity. This will be the style followed in this book. `auto` and uniform initialization will be discussed later within contexts where they tend to be more useful.</p>
</div>

<p>One-line comments are indicated with two forward slashes, eg,</p>

<div data-type="example">
<pre data-type="programlisting">
// This is a comment</pre>
</div>

<p>Multiple lines of comments in a block can also be commented out, as follows:</p>

<div data-type="example">
<pre data-type="programlisting">
/*
    Owl loved to rest quietly whilst no one was talking
    Sitting on a fence one day, he was surprised when
    suddenly a kangaroo ran close by.
*/</pre>
</div>

<p>There is no difference to the compiler between a single space or multiple spaces; for example, despite the variations in whitespace, the following code is legal:</p>

<div data-type="example">
<pre data-type="programlisting">
  int j = 1101;
  int k=   603;
  int sum = j +    k;
  std::cout &lt;&lt;    "j + k = " &lt;&lt;   sum &lt;&lt; "\n";</pre>
</div>

<p>A well-known mantra in programming, however, and particularly relevant to C++, is <em>just because you can do something, doesn’t mean you should</em>. The above code will be more readable and maintainable if written with clear and consistent spacing:</p>

<div data-type="example">
<pre data-type="programlisting">
  int j = 1101;
  int k = 603;
  int sum = j + k;
  std::cout &lt;&lt; "j + k = " &lt;&lt; sum &lt;&lt; "\n";</pre>
</div>

<p>Again, for more realistic and complex code, this mantra should be kept in mind. It will be a recurring theme throughout this book.</p>

<p>Code may also be continued onto multiple lines without the use of a continuation character, and vertical spaces are ignored. Returning to our previous example, writing</p>

<div data-type="example">
<pre data-type="programlisting">
  int j = 1101;
  int k = 
          603;
  
  int sum = j + k;
  std::cout &lt;&lt; "j + k = " 
            &lt;&lt; sum 
            &lt;&lt; "\n";</pre>
</div>

<p>would yield the same result. As before, the preceding example, with uniform spacing and each command placed in a single line, would be preferable. However, it should be noted that, in quantitative programming where complex and nested calculations are involved, it often becomes highly advisable to split up formulae and algorithms on multiple lines for clarity and code maintainability. We will see examples of this in subsequent chapters.</p>

<p>Finally, C++ syntax is <em>case sensitive</em>. For example, two `double` variables `x` and `X` would be as different as two other variables `kirk` and `spock`. The same applies to function names. In examples above, we used the Standard Library function `std::cout`. Attempting to write `std::Cout` instead would trigger a compiler error.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Naming Conventions "><div class="sect3" id="naming_conventions">
<h3><span>Naming Conventions </span></h3>

<p>Variable, function, and class names can be any contiguous combination of letters and numbers, subject to the following conditions:</p>

<ul>
	<li>
	<p>Names must begin with a letter or an underscore; leading numerals are not allowed.</p>
	</li>
	<li>
	<p>Other than the underscore character, special characters, such as `@`, `=`, `$` etc are not allowed.</p>
	</li>
	<li>
	<p>Spaces are not allowed. Names must be contiguous.</p>
	</li>
	<li>
	<p>Language keywords are not allowed in naming, such as `double`, `if`, `while`, etc. A complete listing can be found on https://en.cppreference.com/w/cpp/keyword.</p>
	</li>
</ul>

<p>The maximum name length is compiler-dependent, and in at least one case – the GNU gcc compiler – imposes no limitation; however, see the <em>mantra</em> discussed above.</p>

<p>Single letter variable and function names are fine for simple examples and plain mathematical functions. However, for quantitative models, it will usually be better to pass function arguments with more descriptive names. Function and class names as well should also provide some indication of what they do.</p>

<p>Several naming styles have been common over the years, namely</p>

<ul>
	<li>
	<p>Lower Camel case; eg, `optionDelta`, `riskFreeRate`, `efficientFrontier`: Letter of first word in lower case, and following words capitalized</p>
	</li>
	<li>
	<p>Upper Camel, aka Pascal case; eg, `OptionDelta`, `RiskFreeRate`, `EfficientFrontier`: Letter of each word is in upper case</p>
	</li>
	<li>
	<p>Snake case; eg, `option_delta`, `risk_free_rate`, `efficient_frontier`: Each word begins with lower case, separated by an underscore character</p>
	</li>
</ul>

<p>Lower Camel and Snake cases are the most typical of what is found in C++ function and variable names, and class names are usually in Upper Camel form. In recent years – likely propelled by <a href="https://google.github.io/styleguide/cppguide.html=General_Naming_Rules"><span>Google’s C++ Style Guide</span></a> [5] – variable and function names have gravitated more toward the snake case. As such, we will adopt this convention in this book, and use Upper Camel for class names.</p>

<p>In cases where single characters are used for integral counting variables, it is still common to use the FORTRAN convention of letters `i` through `n`, although this is not required. We will also adopt this practice.</p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Mathematical Operators, Functions, and Constants in C++"><div class="sect1" id="mathematical_operators_functions_and_constants_i">
<h1><span>Mathematical Operators, Functions, and Constants in C++</span></h1>

<p>While the previous discussion was loads of fun, our focus in this book is on math and finance. We have already used the mathematical operators for addition and multiplication of built-in C++ numerical types above. These are language features in C++, and a comprehensive discussion of these standard operators follows. Common mathematical functions, however -- such as cosine, exponential, etc -- are provided in the C++ Standard Library rather than in the core language.</p>

<section data-type="sect2" data-pdf-bookmark="Standard Arithmetic Operators"><div class="sect2" id="standard_arithmetic_operators">
<h2><span>Standard Arithmetic Operators</span></h2>

<p>As suggested in the examples above, addition, subtraction, multiplication, and division of numerical types are provided in C++ with the operators `+`, `-`, `*`, and `/`, respectively, as usually found in other programming languages. In addition, the modulus operator, `%`, is also included. Examples are as follows:</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
// integers:		
int i = 8;		    
int j = 5;		    
int k = i + 7;		
int v = j - 3;		
int u = i % j;		
  // double precision:
double x1 = 30.6;
double x2 = 8.74;
double y = x1 + x2;
double z = x1 - x2;
double twice_x2 = 2.0 * x2;</strong></pre>
</div>

<p>The order and precedence of arithmetic operators are the same as found in most other programming languages, namely:</p>

<ul>
	<li>
	<p>Order runs from left to right:</p>
	</li>
</ul>

<pre data-type="programlisting">
i + j - v</pre>

<p>Using the above integer values would result in 8 + 5 - 2 = 11</p>

<ul>
	<li>
	<p>Multiplication, division, and modulus take precedence over addition and subtraction:</p>
	</li>
</ul>

<pre data-type="programlisting">
x1 + twice_x2/x2</pre>

<p>Using the above double precision values would result in 30.6 + 2.0 = 32.6</p>

<ul>
	<li>
	<p>Use round brackets to change the precedence:</p>
	</li>
</ul>

<pre data-type="programlisting">
(x1 + twice_x2)/x2</pre>

<p>This would yield <img alt="" src="Images/1.1.png" width="149" height="53"/></p>

<p>with the same double precision values.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Mathematical Functions in the Standard Library"><div class="sect2" id="mathematical_functions_in_the_standard_library">
<h2><span>Mathematical Functions in the Standard Library</span></h2>

<p>Many of the usual mathematical functions one finds in other languages have the same or similar syntax in C++. Functions commonly used in computational finance include the following, where `x` and `y` are assumed to be double precision variables:</p>

<pre data-type="programlisting">
 </pre>

<table id="Table1.2">
	<tbody>
		<tr>
			<td>`cos(x)`</td>
			<td>cosine of <em>x</em></td>
		</tr>
		<tr>
			<td>`sin(x)`</td>
			<td>sine of <em>x</em></td>
		</tr>
		<tr>
			<td>`tan`</td>
			<td>tangent of <em>x</em></td>
		</tr>
		<tr>
			<td>`exp`</td>
			<td>exponential function <em>e<sup>x</sup></em></td>
		</tr>
		<tr>
			<td>`log`</td>
			<td>natural logarithm <em>ln(x)</em></td>
		</tr>
		<tr>
			<td>`sqrt`</td>
			<td>square root of <em>x</em></td>
		</tr>
		<tr>
			<td>`cbrt`</td>
			<td>cube root of <em>x</em></td>
		</tr>
		<tr>
			<td>`pow`</td>
			<td><em>x</em> raised to the power of <em>y</em></td>
		</tr>
		<tr>
			<td>`hypot`</td>
			<td>computes <img alt="" src="Images/1.2.png" width="156" height="68"/> for two numerical values x and y</td>
		</tr>
	</tbody>
</table>

<p>As these are contained in the Standard Library rather than as language features. The `cmath` header file should always be included, with the functions scoped by the `std::` prefix:</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
#include &lt;cmath&gt;      // Put this at top of the file.
double trig_fcn(double theta, double phi)
{  
  return = std::sin(theta) + std::cos(phi);
}	</strong></pre>
</div>

<p>Again, if you don’t feel like typing out `std::` all the time, putting `using` statements after the `include` statement are also fine:</p>

<div data-type="example">
<pre data-type="programlisting">
#include &lt;cmath&gt;      // Put this at top of the file.
using std::sin;
using std::cos;
double trig_fcn(double theta, double phi)
{  
  return = sin(theta) + cos(phi);
}</pre>
</div>

<p>We can also now write our first finance example. We want to price a zero coupon bond</p>

<p>Ae<sup>-rt</sup></p>

<p>where</p>

<p>A = the face value of the bond,</p>

<p>r is the interest rate, and</p>

<p>t is the time to maturity as a year fraction.</p>

<p>In C++, we could then write</p>

<div data-type="example">
<pre data-type="programlisting">
double zero_coupon_bond(double face_value, double int_rate, double year_fraction)
{  
    return face_value * std::exp(-int_rate * year_fraction);
}</pre>
</div>

<p>For a more comprehensive list of Standard Library math functions, again see Josuttis, <em>The C++ Standard Library (2E)</em><em> </em>[4], Section 17.3, or the listing available on <a href="https://en.cppreference.com/w/cpp/numeric/math"><span>the CppReference website</span></a> [6]. Both are indispensable references for any modern C++ developer and are highly recommended advanced complementary resources for this book. Some additional guidance on the use of Standard Library math functions follows in the next two sections.</p>

<section data-type="sect3" data-pdf-bookmark="There is No Power Operator in C++"><div class="sect3" id="there_is_no_power_operator_in_c">
<h3><span>There is No Power Operator in C++</span></h3>

<p>Unlike other languages, where an exponent is typically indicated by a `^` or a `**` operator, this does not exist as a C++ language feature. Instead, one needs to call the Standard Library `std::pow` function in `cmath`. When computing polynomials, however, it is more efficient to apply factoring per Horner’s Method and reduce the number of multiplicative operations[6]. For example, if we wish to implement a function</p>

<p>it would be preferable to write it in C++ as</p>

<p><em>f(x)</em> = 8<em>x</em><sup>4</sup> + 7<em>x</em><sup>3</sup> + 4<em>x</em><sup>2</sup>- 10<sup>x</sup> - 6</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
double f(double x)
{  
  return x * (x * (x * (8.0 * x + 7.0) + 4.0 * x) - 10.0) - 6.0;
}</strong></pre>
</div>

<p>rather than</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
double f(double x)
{  
  return 8.0 * std::pow(x, 4) + 7.0 * std::pow(x, 3) + 
    4.0 * std::pow(x, 2) + 10.0 * x - 6.0;
}</strong></pre>
</div>

<p>For the case of a non-integer exponent, say</p>

<p><em>g(x,y)</em> = <em>x</em><sup>-1.368<em>x</em></sup> + 4.19<em>y</em></p>

<p>then there is no alternative but to use `std::pow`:</p>

<div data-type="example">
<pre data-type="programlisting">
double g(double x, double y)
{  
  return std::pow(x, -1.368 * x) + 4.19 * y; 
}</pre>
</div>

<section data-type="sect4" data-pdf-bookmark="` &lt; cmath &gt;`  Ensures Consistency Across Compilers"><div class="sect4" id="_cmath_ensures_consistency_across_compilers">
<h4><span>`</span> <span>&lt;</span> <span>cmath</span> <span>&gt;`</span> <span> Ensures Consistency Across Compilers</span></h4>

<p>It may be the case that you can use these math functions without `#include &lt;cmath&gt;`, but one should adhere to including `cmath` and scoping the functions with `std::`. First, because C++ is built upon C, some compilers retain the old math functions from C in what is called the <em>global namespace</em>. Other compilers, however, might put `cmath` into the global namespace. As a result, one might actually be calling old C functions rather than the ISO C++ Standard versions, and this could cause unexpected or inconsistent behavior among different compilers.</p>

<p>Another example of inconsistencies that can arise is with the absolute value function. In C, and on older C++ compilers, the `abs` function was only implemented for integer types. In order to calculate the absolute value of a floating point number, one would need to use the `fabs` function. However, `std::abs` is overloaded for both integer and floating point (eg `double`) arguments and should be preferred.</p>

<p>This is unfortunately one of the quirks in C++ due to its long association with C; however, the moral of the story is quite simple: to keep C++ code ISO-compliant, we should always put `#include &lt;cmath&gt;`, and scope the math functions with `std::`. This will help ensure cross-compatibility on different compilers and operating system platforms.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Note: Regarding C headers and namespace std, this is clarified, for example, in the specifications for the gcc compiler:</p>

<p><em>The standard specifies that if one includes the C-style header (&lt;</em><em>math.h</em><em>&gt; in this case), the symbols will be available in the global namespace and perhaps in namespace </em><em>std::</em><em> (but this is no longer a firm requirement.) On the other hand, including the C++-style header (&lt;</em><em>cmath</em><em>&gt;) guarantees that the entities will be found in namespace std and perhaps in the global namespace</em>.[8]</p>
</div>
</div></section>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Constants"><div class="sect2" id="constants_idOEFnSR">
<h2><span>Constants</span></h2>

<p>In any type of quantitative programming, there is often a need to use constant values in calculations. In C++, one can define a constant by simply appending the keyword `const` when a value is assigned. Furthermore, beginning with C++20, a set of commonly used mathematical constants is now available.</p>

<section data-type="sect3" data-pdf-bookmark="The `const` Keyword"><div class="sect3" id="the_const_keyword">
<h3><span>The `const` Keyword</span></h3>

<p>If a variable doesn’t change value, it is safer to declare it as a constant type, by using the `const` keyword. For example, we could use it to store an approximation of earth’s gravitational acceleration constant:</p>

<div data-type="example">
<pre data-type="programlisting">
const double grav_accel = 9.80665;</pre>
</div>

<p>Then, if later within the same scope someone attempted to reassign it to a different value:</p>

<div data-type="example">
<pre data-type="programlisting">
grav_accel = 1.625;	// Gravitational constant for the moon</pre>
</div>

<p>a compiler error would result, with a message indicating an attempt was made to modify the value of a constant. Catching errors at compile time is better than chasing them at runtime and tracking down the cause, especially in a live production environment.</p>

<p>`const` also has other important uses and interesting properties that we will cover later, particularly in an object-oriented programming context.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Standard Library Mathematical Constants"><div class="sect3" id="standard_library_mathematical_constants">
<h3><span>Standard Library Mathematical Constants</span></h3>

<p>A handy addition to the C++ 20 Standard Library is a set of commonly used mathematical constants, such as the values of <img alt="" src="Images/1.3.png" width="28" height="23"/>, <em>e</em>, <img alt="" src="Images/1.4.png" width="35" height="32"/>, etc. Some of those that are convenient for quantitative finance are shown in the following table.</p>

<p> </p>

<table id="Table1.3">
	<thead>
		<tr>
			<td>C++ constant</td>
			<td>`e`</td>
			<td>`pi`</td>
			<td>`inv_pi`</td>
			<td>`inv_sqrt_pi`</td>
			<td>`sqrt2`</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Definition</td>
			<td><em>e</em></td>
			<td><img alt="" src="Images/1.3.png" width="28" height="23"/></td>
			<td><img alt="" src="Images/1.5.png" width="34" height="55"/></td>
			<td><img alt="" src="Images/1.6.png" width="39" height="51"/></td>
			<td><img alt="" src="Images/1.4.png" width="35" height="32"/></td>
		</tr>
	</tbody>
</table>

<p>To use these constants, one must first include the `numbers` header in the Standard Library. At the time of this writing, each must be scoped with the `std::numbers` namespace. For example, to implement the function</p>
<img alt="" src="Images/1.7.png" width="329" height="65"/>
<p>we could write</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
#include &lt;cmath&gt;
#include &lt;numbers&gt;
. . . 
double some_fcn(double x, double y)
{
	double math_inv_sqrt_two_pi = 
		std::numbers::inv_sqrtpi / std::numbers::sqrt2;
	return math_inv_sqrt_two_pi*(std::sin(std::numbers::pi * x) + 
		std::cos(std::numbers::inv_pi*y));
}</strong></pre>
</div>

<p>This way, whenever <img alt="" src="Images/1.3.png" width="28" height="23"/>is used in calculations for example, its value will be consistent throughout the program, rather than leaving it up to different programmers on a project who might use approximations out to varying precisions, resulting in possible consistencies in numerical results.</p>

<p>In addition, the value of <img alt="" src="Images/1.4.png" width="35" height="32"/>, which can crop up somewhat frequently in mathematical calculations, does not have to be computed with</p>

<div data-type="example">
<pre data-type="programlisting">
std::sqrt(2.0)</pre>
</div>

<p>each time it is needed. The constant</p>

<div data-type="example">
<pre data-type="programlisting">
std::numbers::sqrt2</pre>
</div>

<p>holds the double precision approximation itself. While perhaps of trivial consequence in terms of one-off performance, repeated calls to the `std::sqrt` function millions of times in computationally intensive code could potentially have some effect.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While not essential to know at this point, it is worth at least mentioning that these constants are set at <em>compile time</em> rather than runtime, using a C++11 designation called `constexpr`. This ties in with the much broader and more advanced subject of <em>template metaprogramming</em>, in which calculations of constant values to be used at runtime are performed at compile time. [[Might return to this topic later, although it is of limited used in financial modeling where the computations depend on data only available at runtime]].</p>
</div>

<p>As a closing note, it is somewhat curious that the set of mathematical constants provided in C++20 include the value <img alt="" src="Images/1.8.png" width="35" height="46"/>, but not <img alt="" src="Images/1.9.png" width="35" height="47"/>or <img alt="" src="Images/1.10.png" width="45" height="47"/>, despite the latter two being more commonly present in statistical calculations. [[See later chapter on the Boost libraries – they are included there]].</p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Conclusion "><div class="sect1" id="conclusion">
<h1><span>Conclusion </span></h1>

<p>This concludes our whirlwind overview of C++. We emphasized quantitative programming, along with the mathematical constants now included in C++20.</p>

<p>Our coverage of best practices with respect to coding style will be a consistent theme throughout the book, as C++ is an extremely feature-rich language with plenty of the proverbial rope with which to hang oneself. Adhering to best practices and consistent coding style is vital to ensure code maintainability and reliability.</p>

<p>One other point to remember is that while we use a lot of screen output and input, this is not how C++ is typically used in quantitative development. `std::cout`, and `std::cin` should be thought as placeholders for real-world interfaces. We will continue to use them as devices to check our results, but they will mostly be relegated to use within the test functions that are called from `main()`, rather than within mathematical and models code itself where they should be avoided in practice anyway.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="References"><div class="sect1" id="references">
<h1><span>References</span></h1>

<p>[1] Kalb and Azman, <em>C++</em><em> Today: The Beast is Back</em>, available on <a href="https://resources.jetbrains.com/storage/products/cpp/books/Cplusplus_Today.pdf"><span>https://resources.jetbrains.com/storage/products/cpp/books/Cplusplus_Today.pdf</span></a> (link)</p>

<p>[2] <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"><span>Guideline Support Library (ISO) </span></a>(link)</p>

<p>[3] <a href="https://isocpp.org/wiki/faq/coding-standards"><span>ISO C++ Coding Standards</span></a> (link)</p>

<p>[4] Nicolai Josuttis, <a href="http://www.cppstdlib.com"><em>The C++ Standard Library (2E)</em></a> (link)</p>

<p>[5] Google C++ Style Guide (https://google.github.io/styleguide/cppguide.html)</p>

<p>[6] cppreference.com</p>

<p>[7] Stepanov, Mathematics of Generic Programming (Horner’s Method)</p>

<p>[8] GNU gcc Compiler Documentation</p>

<p>(https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_headers.html</p>
</div></section>
</div></section></div></body></html>