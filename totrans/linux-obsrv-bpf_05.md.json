["```\nfrom bcc import BPF\n\nbpf_source = \"\"\"\nint do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) { ![1](assets/1.png)\n char comm[16];\n bpf_get_current_comm(&comm, sizeof(comm));\n bpf_trace_printk(\"executing program: %s\", comm);\n return 0;\n}\n\"\"\"\n\nbpf = BPF(text = bpf_source)\t![2](assets/2.png)\nexecve_function = bpf.get_syscall_fnname(\"execve\")\t\t![3](assets/3.png)\nbpf.attach_kprobe(event = execve_function, fn_name = \"do_sys_execve\")\t![4](assets/4.png)\nbpf.trace_print()\n```", "```\nfrom bcc import BPF\n\nbpf_source = \"\"\"\nint ret_sys_execve(struct pt_regs *ctx) { ![1](assets/1.png)\n int return_value;\n char comm[16];\n bpf_get_current_comm(&comm, sizeof(comm));\n return_value = PT_REGS_RC(ctx);\n\n bpf_trace_printk(\"program: %s, return: %d\", comm, return_value);\n return 0;\n}\n\"\"\"\n\nbpf = BPF(text = bpf_source)\t   ![2](assets/2.png)\nexecve_function = bpf.get_syscall_fnname(\"execve\")\nbpf.attach_kretprobe(event = execve_function, fn_name = \"ret_sys_execve\")  ![3](assets/3.png)\nbpf.trace_print()\n```", "```\nsudo ls -la /sys/kernel/debug/tracing/events/bpf\ntotal 0\ndrwxr-xr-x  14 root root 0 Feb  4 16:13 .\ndrwxr-xr-x 106 root root 0 Feb  4 16:14 ..\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_create\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_delete_elem\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_lookup_elem\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_next_key\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_update_elem\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_get_map\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_get_prog\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_pin_map\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_pin_prog\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_prog_get_type\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_prog_load\ndrwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_prog_put_rcu\n-rw-r--r--   1 root root 0 Feb  4 16:13 enable\n-rw-r--r--   1 root root 0 Feb  4 16:13 filter\n```", "```\nfrom bcc import BPF\n\nbpf_source = \"\"\"\nint trace_bpf_prog_load(void ctx) { ![1](assets/1.png)\n char comm[16];\n bpf_get_current_comm(&comm, sizeof(comm));\n\n bpf_trace_printk(\"%s is loading a BPF program\", comm);\n return 0;\n}\n\"\"\"\n\nbpf = BPF(text = bpf_source)\nbpf.attach_tracepoint(tp = \"bpf:bpf_prog_load\",\n                      fn_name = \"trace_bpf_prog_load\") ![2](assets/2.png)\nbpf.trace_print()\n```", "```\npackage main\nimport \"fmt\"\n\nfunc main() {\n        fmt.Println(\"Hello, BPF\")\n}\n```", "```\nnm hello-bpf | grep main\n0000000004850b0 T main.init\n00000000567f06 B main.initdone.\n00000000485040 T main.main\n000000004c84a0 R main.statictmp_0\n00000000428660 T runtime.main\n0000000044da30 T runtime.main.func1\n00000000044da80 T runtime.main.func2\n000000000054b928 B runtime.main_init_done\n00000000004c8180 R runtime.mainPC\n0000000000567f1a B runtime.mainStarted\n```", "```\nfrom bcc import BPF\n\nbpf_source = \"\"\"\nint trace_go_main(struct pt_regs *ctx) {\n u64 pid = bpf_get_current_pid_tgid(); ![1](assets/1.png)\n bpf_trace_printk(\"New hello-bpf process running with PID: %d\", pid);\n}\n\"\"\"\n\nbpf = BPF(text = bpf_source)\nbpf.attach_uprobe(name = \"hello-bpf\",\n    sym = \"main.main\", fn_name = \"trace_go_main\")\t![2](assets/2.png)\nbpf.trace_print()\n```", "```\nbpf_source = \"\"\"\nint trace_go_main(struct pt_regs *ctx) {\n u64 pid = bpf_get_current_pid_tgid();\n bpf_trace_printk(\"New hello-bpf process running with PID: %d\", pid); ![1](assets/1.png)\n}\n\"\"\"\n\nbpf = BPF(text = bpf_source)\nbpf.attach_uprobe(name = \"hello-bpf\", \t![2](assets/2.png)\n    sym = \"main.main\", fn_name = \"trace_go_main\")\t![3](assets/3.png)\nbpf.trace_print()\n```", "```\nbpf_source += \"\"\"\nstatic int print_duration(struct pt_regs *ctx) {\n u64 pid = bpf_get_current_pid_tgid(); ![1](assets/1.png)\n u64 start_time_ns = cache.lookup(&pid);\n if (start_time_ns == 0) {\n return 0;\n }\n u64 duration_ns = bpf_ktime_get_ns() - start_time_ns;\n bpf_trace_printk(\"Function call duration: %d\", duration_ns); ![2](assets/2.png)\n return 0; ![3](assets/3.png)\n}\n\"\"\"\n```", "```\nbpf = BPF(text = bpf_source)\nbpf.attach_uprobe(name = \"hello-bpf\", sym = \"main.main\",\n           fn_name = \"trace_start_time\")\nbpf.attach_uretprobe(name = \"hello-bpf\", sym = \"main.main\",\n           fn_name = \"print_duration\")\nbpf.trace_print()\n```", "```\n #include <sys/sdt.h>\n int main() {\n   DTRACE_PROBE(\"hello-usdt\", \"probe-main\");\n }\n```", "```\ngcc -o hello_usdt hello_usdt.c\n```", "```\nreadelf -n ./hello_usdt\n```", "```\nDisplaying notes found in: .note.stapsdt\n  Owner                 Data size        Description\n  stapsdt              0x00000033        NT_STAPSDT (SystemTap probe descriptors)\n    Provider: \"hello-usdt\"\n    Name: \"probe-main\"\n```", "```\n tplist -l ./hello_usdt\n```", "```\n ./hello_usdt \"hello-usdt\":\"probe-main\"\n```", "```\nfrom bcc import BPF, USDT\n\nbpf_source = \"\"\"\n#include <uapi/linux/ptrace.h>\nint trace_binary_exec(struct pt_regs *ctx) {\n u64 pid = bpf_get_current_pid_tgid();\n bpf_trace_printk(\"New hello_usdt process running with PID: %d\", pid);\n}\n\"\"\"\n\nusdt = USDT(path = \"./hello_usdt\")\t![1](assets/1.png)\nusdt.enable_probe(probe = \"probe-main\", fn_name = \"trace_binary_exec\")     ![2](assets/2.png)\nbpf = BPF(text = bpf_source, usdt = usdt)\t![3](assets/3.png)\nbpf.trace_print()\n```", "```\nrequire 'ruby-static-tracing'\n\nStaticTracing.configure do |config|\n  config.mode = StaticTracing::Configuration::Modes::SIGNAL\n  config.signal = StaticTracing::Configuration::Modes::SIGNALS::SIGPROF\nend\n```", "```\nkill -SIGPROF `pgrep -nx ruby`\n```", "```\nrequire 'ruby-static-tracing'\nrequire 'ruby-static-tracing/tracer/concerns/latency_tracer'\n\nStaticTracing.configure do |config|\n  config.add_tracer(StaticTracing::Tracer::Latency)\nend\n```", "```\nclass UserModel\n  def find(id)\n  end\n\n  include StaticTracing::Tracer::Concerns::Latency\nend\n```", "```\nbpf_source = \"\"\"\n#include <uapi/linux/ptrace.h>\nint trace_latency(struct pt_regs *ctx) {\n char method[64];\n u64 latency;\n\n bpf_usdt_readarg_p(1, ctx, &method, sizeof(method));\n bpf_usdt_readarg(2, ctx, &latency);\n\n bpf_trace_printk(\"method %s took %d ms\", method, latency);\n}\n\"\"\"\n```", "```\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-p\", \"--pid\", type = int, help = \"Process ID\")\t![1](assets/1.png)\nargs = parser.parse_args()\n\nusdt = USDT(pid = int(args.pid))\nusdt.enable_probe(probe = \"latency\", fn_name = \"trace_latency\")\t\t![2](assets/2.png)\nbpf = BPF(text = bpf_source, usdt = usdt)\nbpf.trace_print()\n```", "```\npackage main\n\nimport \"time\"\n\nfunc main() {\n\tj := 3\n\tfor time.Since(time.Now()) < time.Second {\n\t\tfor i := 1; i < 1000000; i++ {\n\t\t\tj *= i\n\t\t}\n\t}\n}\n```", "```\nbpf_source = \"\"\"\n#include <uapi/linux/ptrace.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <linux/sched.h>\n\nstruct trace_t { ![1](assets/1.png)\n int stack_id;\n}\n\nBPF_HASH(cache, struct trace_t); ![2](assets/2.png)\nBPF_STACK_TRACE(traces, 10000); ![3](assets/3.png)\n\"\"\"\n```", "```\nbpf_source += \"\"\"\nint collect_stack_traces(struct bpf_perf_event_data *ctx) {\n u32 pid = bpf_get_current_pid_tgid() >> 32; ![1](assets/1.png)\n if (pid != PROGRAM_PID)\n return 0;\n\n struct trace_t trace = { ![2](assets/2.png)\n .stack_id = traces.get_stackid(&ctx->regs, BPF_F_USER_STACK)\n };\n\n cache.increment(trace); ![3](assets/3.png)\n return 0;\n}\n\"\"\"\n```", "```\nprogram_pid = int(sys.argv[0])\t\t![1](assets/1.png)\nbpf_source = bpf_source.replace('PROGRAM_PID', program_pid) ![2](assets/2.png)\n\nbpf = BPF(text = bpf_source)\nbpf.attach_perf_event(ev_type = PerfType.SOFTWARE,          ![3](assets/3.png)\n                      ev_config = PerfSWConfig.CPU_CLOCK,\n                      fn_name = 'collect_stack_traces')\n```", "```\ntry:\n  sleep(99999999)\nexcept KeyboardInterrupt:\n  signal.signal(signal.SIGINT, signal_ignore)\n\nfor trace, acc in sorted(cache.items(), key=lambda cache: cache[1].value):   ![1](assets/1.png)\n  line = []\n  if trace.stack_id < 0 and trace.stack_id == -errno.EFAULT\t\t     ![2](assets/2.png)\n    line = ['Unknown stack']\n  else\n    stack_trace = list(traces.walk(trace.stack_id))\n    for stack_address in reversed(stack_trace)\t\t\t             ![3](assets/3.png)\n      line.extend(bpf.sym(stack_address, program_pid))\t\t     \t![4](assets/4.png)\n\n  frame = b\";\".join(line).decode('utf-8', 'replace')\t\t     \t![5](assets/5.png)\n  print(\"%s %d\" % (frame, acc.value))\n```", "```\n./profiler.py `pgrep -nx go` > /tmp/profile.out\n```", "```\n./flamegraph.pl /tmp/profile.out > /tmp/flamegraph.svg && \\\n  firefox /tmp/flamefraph.svg\n```", "```\nbpf_source = \"\"\"\n#include <uapi/linux/ptrace.h>\n\nBPF_HASH(cache, u64, u64);\nBPF_HISTOGRAM(histogram);\n\nint trace_bpf_prog_load_start(void ctx) { ![1](assets/1.png)\n u64 pid = bpf_get_current_pid_tgid(); ![2](assets/2.png)\n u64 start_time_ns = bpf_ktime_get_ns();\n cache.update(&pid, &start_time_ns); ![3](assets/3.png)\n return 0;\n}\n\"\"\"\n```", "```\nbpf_source += \"\"\"\nint trace_bpf_prog_load_return(void ctx) {\n u64 *start_time_ns, delta;\n u64 pid = bpf_get_current_pid_tgid();\n start_time_ns = cache.lookup(&pid);\n if (start_time_ns == 0)\n return 0;\n\n delta = bpf_ktime_get_ns() - *start_time_ns; ![1](assets/1.png)\n histogram.increment(bpf_log2l(delta)); ![2](assets/2.png)\n return 0;\n}\n\"\"\"\n```", "```\nbpf = BPF(text = bpf_source)\t\t\t![1](assets/1.png)\nbpf.attach_kprobe(event = \"bpf_prog_load\",\n    fn_name = \"trace_bpf_prog_load_start\")\nbpf.attach_kretprobe(event = \"bpf_prog_load\",\n    fn_name = \"trace_bpf_prog_load_return\")\n\ntry:\t\t\t\t\t\t![2](assets/2.png)\n  sleep(99999999)\nexcept KeyboardInterrupt:\n  print()\n\nbpf[\"histogram\"].print_log2_hist(\"msecs\")\t![3](assets/3.png)\n```", "```\nbpf_source = \"\"\"\n#include <uapi/linux/ptrace.h>\n\nBPF_PERF_OUTPUT(events); ![1](assets/1.png)\n\nint do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) {\n char comm[16];\n bpf_get_current_comm(&comm, sizeof(comm));\n\n events.perf_submit(ctx, &comm, sizeof(comm)); ![2](assets/2.png)\n return 0;\n}\n\"\"\"\n\nbpf = BPF(text = bpf_source)\t\t\t\t\t\t![3](assets/3.png)\nexecve_function = bpf.get_syscall_fnname(\"execve\")\nbpf.attach_kprobe(event = execve_function, fn_name = \"do_sys_execve\")\n```", "```\nfrom collections import Counter\naggregates = Counter()\t\t\t![1](assets/1.png)\n\ndef aggregate_programs(cpu, data, size):\t![2](assets/2.png)\n  comm = bpf[\"events\"].event(data)\t\t ![3](assets/3.png)\n  aggregates[comm] += 1\n\nbpf[\"events\"].open_perf_buffer(aggregate_programs)\t![4](assets/4.png)\nwhile True:\n    try:\n      bpf.perf_buffer_poll()\n    except KeyboardInterrupt:\t\t\t\t![5](assets/5.png)\n      break\n\nfor (comm, times) in aggregates.most_common():\n  print(\"Program {} executed {} times\".format(comm, times))\n```"]