- en: Chapter 3\. Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are a popular and standard format for packaging applications. The
    format is an open standard promoted by the [Open Container Initiative (OCI)](https://opencontainers.org),
    an open governance structure for the express purpose of creating open industry
    standards around container formats and runtimes. The openness of this format ensures
    portability and interoperability across different operating systems, vendors,
    platforms, or clouds. Kubernetes runs containerized apps, so before going into
    the GitOps approach to managing apps on Kubernetes, we provide a list of recipes
    useful for understanding how to package your application as a container image.
  prefs: []
  type: TYPE_NORMAL
- en: The first step for creating images is to use a container engine for packaging
    your application by building a layered structure containing a base OS and additional
    layers on top such as runtimes, libraries, and applications. Docker is a widespread
    open source implementation of a container engine and runtime, and it can generate
    a container image by specifying a manifest called a Dockerfile (see [Recipe 3.1](#recipe_3_1)).
  prefs: []
  type: TYPE_NORMAL
- en: Since the format is open, it’s possible to create container images with other
    tools. [Docker](https://www.docker.com), a popular container engine, requires
    the installation and the execution of a *daemon* that can handle all the operations
    with the container engine. Developers can use a software development kit (SDK)
    to interact with the Docker daemon or use *dockerless* solutions such as JiB to
    create container images (see [Recipe 3.2](#recipe_3_2)).
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to rely on a specific programming language or SDK to build
    container images, you can use another *daemonless* solution like Buildah (see
    [Recipe 3.3](#recipe_3_3)) or Buildpacks (see [Recipe 3.4](#recipe_3_4)). Those
    are other popular open source tools for building OCI container images. By avoiding
    dependencies from the OS, such tools make automation more manageable and portable
    (see [Chapter 6](ch06.xhtml#ch_Cloud_Native_CICD)).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes doesn’t provide a native mechanism for building container images.
    However, its highly extensible architecture allows interoperability with external
    tools and the platform’s extensibility to create container images. Shipwright
    is an open source framework for building container images on Kubernetes, providing
    an abstraction that can use tools such as kaniko, Buildpacks, or Buildah (see
    [Recipe 3.5](#recipe_3_5)) to create container images.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll learn how to create OCI-compliant container
    images from a Dockerfile, either from a host with Docker installed, or using tools
    such as Buildah and Buildpacks.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Building a Container Using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a container image for your application with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you need to do is install [Docker](https://oreil.ly/jd0kH).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Docker is available for Mac, Windows, and Linux. Download the installer for
    your operating system and refer to the [documentation](https://oreil.ly/7vGmZ)
    to start the Docker service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can create a container image by defining a *Dockerfile*. The best
    definition for a Dockerfile comes from the [Docker documentation](https://oreil.ly/RMm2y)
    itself: “A Dockerfile is a text document that contains all the commands a user
    could call on the command line to assemble an image.”'
  prefs: []
  type: TYPE_NORMAL
- en: Container images present a layered structure, as you can see in [Figure 3-1](#fig3-1).
    Each container image provides the foundation layer for a container, and any update
    is just an additional layer that can be committed on the foundation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Container image layers](assets/gocb_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Container image layers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can create a Dockerfile like the one shown here, which will generate a container
    image for Python apps. You can also find this example in [this book’s repository](https://oreil.ly/J7cXP).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_containers_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`: always start from a base image as a foundational layer. In this case
    we start from a Universal Base Image (UBI), publicly available based on RHEL 8
    with Python 3.9 runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_containers_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV`: set an environment variable for the app.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_containers_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPOSE`: expose a port to the container network, in this case port TCP 8080.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_containers_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR`: set a directory inside the container to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_containers_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: '`COPY`: copy the assets from the source code files on your workstation to the
    container image layer, in this case, to the `WORKDIR`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_containers_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN`: run a command inside the container, using the tools already available
    within the base image. In this case, it runs the `pip` tool to install dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_containers_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`: define the entry point for your app inside the container. It
    can be a binary or a script. In this case, it runs the Python interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_containers_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMD`: the command that is used when starting a container. In this case it
    uses the name of the Python app `app.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now create your container image with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Change the container image name with the your registry, user, and repo. Example:
    `quay.io/youruser/yourrepo:latest`. See [Chapter 2](ch02.xhtml#ch_Requirements)
    for how to create a new account on registries such as Quay.io.'
  prefs: []
  type: TYPE_NORMAL
- en: Your container image is building now. Docker will fetch existing layers from
    a public container registry (DockerHub, Quay, Red Hat Registry, etc.) and add
    a new layer with the content specified in the Dockerfile. Such layers could also
    be available locally, if already downloaded, in special storage called a *container
    cache* or *Docker cache*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Your container image is now available in your Docker cache and ready to be
    used. You can verify its presence with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the list of available container images from the cache in output.
    Those could be images you have built or downloaded with the `docker pull` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once your image is created, you can consume it locally or push it to a public
    container registry to be consumed elsewhere, like from a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to first log in to your public registry. In this example, we are using
    Quay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can push your container image to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As confirmed, you should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create container images in this way with Docker from your workstation
    or any host where the Docker service/daemon is running.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Additionally, you can use functionalities offered by a public registry such
    as [Quay.io](https://quay.io) that can directly create the container image from
    a Dockerfile and store it to the registry.
  prefs: []
  type: TYPE_NORMAL
- en: The build requires access to all layers, thus an internet connection to the
    registries storing base layers is needed, or at least having them in the container
    cache. Docker has a layered structure where any change to your app is committed
    on top of the existing layers, so there’s no need to download all the layers each
    time since it will add only deltas for each new change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Container images typically start from a base OS layer such as Fedora, CentOS,
    Ubuntu, Alpine, etc. However, they can also start from `scratch`, an empty layer
    for super-minimal images containing only the app’s binary. See the [`scratch`
    documentation](https://oreil.ly/vj0gs) for more info.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run your previously created container image, you can do so with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`docker run` has many options to start your container. The most common are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`'
  prefs: []
  type: TYPE_NORMAL
- en: Binds the port of the container with the port of the host running such container.
  prefs: []
  type: TYPE_NORMAL
- en: '`-t`'
  prefs: []
  type: TYPE_NORMAL
- en: Attaches a TTY to the container.
  prefs: []
  type: TYPE_NORMAL
- en: '`-i`'
  prefs: []
  type: TYPE_NORMAL
- en: Goes into an interactive mode.
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`'
  prefs: []
  type: TYPE_NORMAL
- en: Goes in the background, printing a hash that you can use to interact asynchronously
    with the running container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will start your app in the Docker network and bind it
    to port 8080 of your workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From a new terminal, try accessing your running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Best practices for writing Dockerfiles](https://oreil.ly/2hMQD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Manage Docker images](https://oreil.ly/hUByf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.2 Building a Container Using Dockerless Jib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are a software developer, and you want to create a container image without
    installing Docker or any additional software on your workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Recipe 3.1](#recipe_3_1), you need to install the Docker engine
    to create container images. Docker requires permissions to install a service running
    as a daemon, thus a privileged process in your operating system. Today, *dockerless*
    solutions are also available for developers; a popular one is Jib.
  prefs: []
  type: TYPE_NORMAL
- en: '[Jib](https://oreil.ly/NYCtv) is an open source framework for Java made by
    Google to build OCI-compliant container images, without the need for Docker or
    any container runtime. Jib comes as a library that Java developers can import
    in their Maven or Gradle projects. This means you can create a container image
    for your app without writing or maintaining any Dockerfiles, delegating this complexity
    to Jib.'
  prefs: []
  type: TYPE_NORMAL
- en: We see the benefits from this approach as the following:^([1](ch03.xhtml#idm45120847711664))
  prefs: []
  type: TYPE_NORMAL
- en: Pure Java
  prefs: []
  type: TYPE_NORMAL
- en: No Docker or Dockerfile knowledge is required. Simply add Jib as a plug-in,
    and it will generate the container image for you.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs: []
  type: TYPE_NORMAL
- en: The application is divided into multiple layers, splitting dependencies from
    classes. There’s no need to rebuild the container image like for Dockerfiles;
    Jib takes care of modifying the layers that changed.
  prefs: []
  type: TYPE_NORMAL
- en: Reproducibility
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary updates are not triggered because the same contents generate the
    same image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to kickstart a container image build with Jib on existing Maven
    is by adding the plug-in via the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can do so by adding Jib as a plug-in into your *pom.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can also manage other settings such as authentication or parameters
    for the build.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now add Jib to an existing Java application, a Hello World application
    in Spring Boot that you can find in the [book’s repository](https://oreil.ly/dn1LF).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a container image without using Docker,
    and push it directly to a container registry. In this example, we use Quay.io,
    and we will store the container image at *quay.io/gitops-cookbook/jib-example:latest*,
    so you will need to provide your credentials for the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The authentication here is handled with command-line options, but Jib can manage
    existing authentication with Docker CLI or read credentials from your *settings.xml*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build takes a few moments, and the result is a Java-specific container
    image, based on the *adoptOpenJDK* base image, built locally and pushed directly
    to a registry. In this case, to Quay.io:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have Docker and run the command `docker images`, you won’t see this image
    in your local cache!
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your container image is not present in your local cache, as you don’t need any
    container runtime to build images with Jib. You won’t see it with the `docker
    images` command, but you can pull it from the public container registry afterward,
    and it will store it in your cache.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is suitable for development velocity and automation, where the
    CI system doesn’t need to have Docker installed on the nodes where it runs. Jib
    can create the container image without any Dockerfiles. Additionally, it can push
    the image to a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: If you also want to store it locally from the beginning, Jib can connect to
    Docker hosts and do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pull your container image from the registry to try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the `hello` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Using Jib with Quarkus projects](https://oreil.ly/sTcpJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.3 Building a Container Using Buildah
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes installing or managing Docker is not possible. Dockerless solutions
    for creating container images are useful in use cases such as local development
    or CI/CD systems.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OCI specification is an open standard, and this favors multiple open source
    implementations for the container engine and the container image building mechanism.
    Two growing popular examples today are [Podman](https://podman.io) and [Buildah](https://buildah.io).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While Docker uses a single monolithic application for creating, running, and
    shipping container images, the codebase for container management functionalities
    here has been split between different projects like Podman, Buildah, and Skopeo.
    Podman support is already available on Mac and Windows, however Buildah is currently
    only available on Linux or Linux subsystems such as WSL2 for Windows. See the
    [documentation](https://oreil.ly/W9l1a) to install it on your workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Those are two complementary open source projects and command-line tools that
    work on OCI containers and images; however, they differ in their specialization.
    While Podman specializes in commands and functions that help you to maintain and
    modify container images, such as pulling, tagging, and pushing, Buildah specializes
    in building container images. Decoupling functions in different processes is done
    by design, as the authors wanted to move from the single privileged process Docker
    model to a lightweight, rootless, daemonless, and decoupled set of tools to improve
    agility and security.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Following the same approach, you find [Skopeo](https://oreil.ly/oJnAK), a tool
    used to move container images; and [CRI-O](https://cri-o.io), a container engine
    complaint with the Kubernetes container runtime interface for running applications.
  prefs: []
  type: TYPE_NORMAL
- en: Buildah supports the Dockerfile format, but its goal is to provide a lower-level
    interface to build container images without requiring a Dockerfile. Buildah is
    a daemonless solution that can create images inside a container without mounting
    the Docker socket. This functionality improves security and portability since
    it’s easy to add Buildah builds on the fly to a CI/CD pipeline where the Linux
    or Kubernetes nodes do not require a Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed, you can create a container image with or without a Dockerfile.
    Let’s now create a simple HTTPD container image without a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start from any base image such as CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similarly to Docker and `docker images`, you can run the command `buildah containers`
    to get the list of available images from the container cache. If you also have
    installed Podman, this is similar to `podman images`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the container image ID is `centos-working-container`, and you
    can refer to it for creating the other layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s install the `httpd` package inside a new layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s copy a welcome HTML page inside the container running HTTPD. You
    can find the source code in [this book’s repo](https://oreil.ly/azx91):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For each new layer added, you should get output with the new container image
    hash, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Your container image is now in the container cache, ready to run or push to
    another registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, Buildah can also create container images from a Dockerfile.
    Let’s make the same container image from the Dockerfile listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have also installed Podman, you can run it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then you can test it by opening the browser on [*http://localhost:8080*](http://localhost:8080).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Buildah, you have the opportunity to create container images from scratch
    or starting from a Dockerfile. You don’t need to install Docker, and everything
    is designed around security: rootless mechanism, daemonless utilities, and more
    refined control of creating image layers.'
  prefs: []
  type: TYPE_NORMAL
- en: Buildah can also build images from scratch, thus it creates an empty layer similar
    to the `FROM scratch` Dockerfile statement. This aspect is useful for creating
    very lightweight images containing only the packages needed to run your application,
    as you can see in [Figure 3-2](#fig3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Buildah image shrink](assets/gocb_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Buildah image shrink
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A good example use case for a scratch build is considering the development images
    versus staging or production images. During development, container images may
    require a compiler and other tools. However, in production, you may only need
    the runtime or your packages.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Running Buildah inside a container](https://oreil.ly/GUfss)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.4 Building a Container with Buildpacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating container image by using Dockerfiles can be challenging at scale. You
    want a tool complementing Docker that can inspect your application source code
    to create container images without writing a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Cloud Native Buildpacks](https://oreil.ly/psc6h) is an open source project
    that provides a set of executables to inspect your app source code and to create
    a plan to build and run your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Buildpacks can create OCI-compliant container images without a Dockerfile, starting
    from the app source code, as you can see in [Figure 3-3](#fig3-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Buildpacks builds](assets/gocb_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Buildpacks builds
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This mechanism consists of two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Detection
  prefs: []
  type: TYPE_NORMAL
- en: Buildpacks tooling will navigate your source code to discover which programming
    language or framework is used (e.g., POM, NPM files, Python requirements, etc.)
    and assign a suitable buildpack for the build.
  prefs: []
  type: TYPE_NORMAL
- en: Building
  prefs: []
  type: TYPE_NORMAL
- en: Once a buildpack is found, the source is compiled and Buildpacks creates a container
    image with the appropriate entry point and startup scripts.
  prefs: []
  type: TYPE_NORMAL
- en: To use Buildpacks, you have to download the [pack](https://oreil.ly/K0gGM) CLI
    for your operating system (Mac, Windows, Linux), and also have Docker installed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'On macOS, `pack` is available through [Homebrew](https://brew.sh) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s start creating our container image with Buildpacks from a sample
    Node.js app. You can find the app source code in this [book’s repository](https://oreil.ly/eViRN):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The app directory structure contains a *package.json* file, a manifest listing
    Node.js packages required for this build, which helps Buildpacks understand which
    buildpack to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify it with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can decide to pick one of the suggested buildpacks. Let’s try the `paketobuildpacks/builder:base`,
    which also contains the Node.js runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Run `pack builder inspect paketobuildpacks/builder:base` to know the exact content
    of libraries and frameworks available in this buildpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The building process should start accordingly, and after a while, it should
    finish, and you should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s run it with Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'View the running application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud Native Buildpacks is an incubating project in the Cloud Native Computing
    Foundation (CNCF), and it supports both Docker and Kubernetes. On Kubernetes,
    it can be used with [Tekton](https://tekton.dev), a Kubernetes-native CI/CD system
    that can run Buildpacks as a Tekton `Task` to create container images. It recently
    adopted the [Boson Project](https://oreil.ly/F0OTs) to provide a functions-as-a-service
    (FaaS) experience on Kubernetes with Knative, by enabling the build of functions
    via buildpacks.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Using Buildpacks with Tekton Pipelines](https://oreil.ly/wFIHd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FaaS Knative Boson project’s buildpacks](https://oreil.ly/p1U6n)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.5 Building a Container Using Shipwright and kaniko in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create a container image, and you want to do it with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes is well known as a container orchestration platform to deploy and
    manage apps. However, it doesn’t include support for building container images
    out-of-the-box. Indeed, according to [Kubernetes documentation](https://oreil.ly/qgpKi):
    “(Kubernetes) Does not deploy source code and does not build your application.
    Continuous Integration, Delivery, and Deployment (CI/CD) workflows are determined
    by organization cultures and preferences as well as technical requirements.”'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, one standard option is to rely on CI/CD systems for this purpose,
    like Tekton (see [Chapter 6](ch06.xhtml#ch_Cloud_Native_CICD)). Another option
    is to use a framework to manage builds with many underlying tools, such as the
    one we discussed in the previous recipes. One example is Shipwright.
  prefs: []
  type: TYPE_NORMAL
- en: '[Shipwright](https://shipwright.io) is an extensible framework for building
    container images on Kubernetes. It supports popular tools such as Buildah, Cloud
    Native Buildpacks, and kaniko. It uses Kubernetes-style APIs, and it runs workloads
    using Tekton.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefit for developers is a simplified approach for building container images,
    by defining a minimal YAML file that does not require any previous knowledge of
    containers or container engines. This approach makes this solution agnostic and
    highly integrated with the Kubernetes API ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to install Shipwright to your Kubernetes cluster, say
    kind or Minikube (see [Chapter 2](ch02.xhtml#ch_Requirements)), following the
    [documentation](https://oreil.ly/FWvXv) or from [OperatorHub.io](https://oreil.ly/6Ds5R).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using Operators and Operator Lifecycle Manager (OLM) gives consistency for installing/uninstalling
    software on Kubernetes, along with dependency management and lifecycle control.
    For instance, the Tekton Operator dependency is automatically resolved and installed
    if you install Shipwright via the Operator. Check the OLM [documentation](https://oreil.ly/V3k2p)
    for details with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow the standard procedure from the documentation. First you need
    to install the Tekton dependency. At the time of writing this book, it is version
    `0.30.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you install Shipwright. At the time of writing this book, it is version
    `0.7.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you install Shipwright build strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have installed Shipwright, you can start creating your container image
    build using one of these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: kaniko
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Native Buildpacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BuildKit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buildah
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore kaniko.
  prefs: []
  type: TYPE_NORMAL
- en: '[kaniko](https://oreil.ly/ncdWg) is another dockerless solution to build container
    images from a Dockerfile inside a container or Kubernetes cluster. Shipwright
    brings additional APIs to Kubernetes to use tools such as kaniko to create container
    images, acting as an abstract layer that can be considered an extensible building
    system for Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the APIs that are defined from Cluster Resource Definitions (CRDs):'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClusterBuildStrategy`'
  prefs: []
  type: TYPE_NORMAL
- en: Represents the type of build to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '`Build`'
  prefs: []
  type: TYPE_NORMAL
- en: Represents the build. It includes the specification of one `ClusterBuildStrategy`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '`BuildRun`'
  prefs: []
  type: TYPE_NORMAL
- en: Represents a running build. The build starts when this object is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check all available `ClusterBuildStrategy` (CBS)
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a list of available CBSs to consume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This CRD is cluster-wide, available for all namespaces. If you don’t see any
    items, please install the Shipwright build strategies as discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Shipwright will generate a container image on the Kubernetes nodes container
    cache, and then it can push it to a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to provide the credentials to push the image to the registry in the
    form of a Kubernetes Secret. For example, if you use Quay you can create one like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With Quay, you can use an encrypted password instead of using your account password.
    See the documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create a *build-kaniko.yaml* file containing the `Build` object that
    will use kaniko to containerize a Node.js sample app. You can find the source
    code in this [book’s repository](https://oreil.ly/S84zu):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_containers_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Repository to grab the source code from.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_containers_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The directory where the source code is present.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_containers_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ClusterBuildStrategy` to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_containers_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The destination of the resulting container image. Change this with your container
    registry repo.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_containers_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The secret to use to authenticate to the container registry and push the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the `Build` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s list the available builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your `Build` is `REGISTERED`, but it’s not started yet. Let’s
    create the following object in order to start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the list of running pods, you should see one being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `STATUS` changes, the build will start, and you can track the progress
    by checking the logs from the containers used by this pod to run the build in
    multiple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: step-source-default
  prefs: []
  type: TYPE_NORMAL
- en: The first step, used to get the source code
  prefs: []
  type: TYPE_NORMAL
- en: step-build-and-push
  prefs: []
  type: TYPE_NORMAL
- en: The step to run the build, either from source code or from a Dockerfile like
    in this case with kaniko
  prefs: []
  type: TYPE_NORMAL
- en: step-results
  prefs: []
  type: TYPE_NORMAL
- en: The result of the build
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the logs of the building phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The image is built and pushed to the registry, and you can check the result
    from this command as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: And on your registry, as shown in [Figure 3-4](#fig3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image pushed to Quay.io](assets/gocb_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Image pushed to Quay
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shipwright provides a convenient way to create container images on Kubernetes,
    and its agnostic approach makes it robust and interoperable. The project aims
    at being the Build API for Kubernetes, providing an easier path for developers
    to automate on Kubernetes. As Tekton runs under the hood creating builds, Shipwright
    also makes transitioning from micropipeline to extended pipeline workflows on
    Kubernetes easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reference, if you would like to create a build with Buildah instead of
    kaniko, it’s just a `ClusterBuildStrategy` change in your `Build` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_containers_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed previously in [Recipe 3.3](#recipe_3_3), Buildah can create
    the container image from the source code. It doesn’t need a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_containers_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Buildah as the `ClusterBuildStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Final Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The container format is the de facto standard for packaging applications, and
    today many tools help create container images. Developers can create images with
    Docker or with other tools and frameworks and then use the same with any CI/CD
    system to deploy their apps to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: While Kubernetes per se doesn’t build container images, some tools interact
    with the Kubernetes API ecosystem to add this functionality. This aspect improves
    development velocity and consistency across environments, delegating this complexity
    to the platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, you will see how to control the deployment of your
    containers running on Kubernetes with tools such as Kustomize or Helm, and then
    how to add automation to support highly scalable workloads with CI/CD and GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45120847711664-marker)) For a presentation about Jib, see
    Appu Goundan and Qingyang Chen’s [presentation from Velocity San Jose 2018](https://oreil.ly/W4j49).
  prefs: []
  type: TYPE_NORMAL
