- en: Chapter 3\. Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are a popular and standard format for packaging applications. The
    format is an open standard promoted by the [Open Container Initiative (OCI)](https://opencontainers.org),
    an open governance structure for the express purpose of creating open industry
    standards around container formats and runtimes. The openness of this format ensures
    portability and interoperability across different operating systems, vendors,
    platforms, or clouds. Kubernetes runs containerized apps, so before going into
    the GitOps approach to managing apps on Kubernetes, we provide a list of recipes
    useful for understanding how to package your application as a container image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The first step for creating images is to use a container engine for packaging
    your application by building a layered structure containing a base OS and additional
    layers on top such as runtimes, libraries, and applications. Docker is a widespread
    open source implementation of a container engine and runtime, and it can generate
    a container image by specifying a manifest called a Dockerfile (see [Recipe 3.1](#recipe_3_1)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Since the format is open, it’s possible to create container images with other
    tools. [Docker](https://www.docker.com), a popular container engine, requires
    the installation and the execution of a *daemon* that can handle all the operations
    with the container engine. Developers can use a software development kit (SDK)
    to interact with the Docker daemon or use *dockerless* solutions such as JiB to
    create container images (see [Recipe 3.2](#recipe_3_2)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to rely on a specific programming language or SDK to build
    container images, you can use another *daemonless* solution like Buildah (see
    [Recipe 3.3](#recipe_3_3)) or Buildpacks (see [Recipe 3.4](#recipe_3_4)). Those
    are other popular open source tools for building OCI container images. By avoiding
    dependencies from the OS, such tools make automation more manageable and portable
    (see [Chapter 6](ch06.xhtml#ch_Cloud_Native_CICD)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes doesn’t provide a native mechanism for building container images.
    However, its highly extensible architecture allows interoperability with external
    tools and the platform’s extensibility to create container images. Shipwright
    is an open source framework for building container images on Kubernetes, providing
    an abstraction that can use tools such as kaniko, Buildpacks, or Buildah (see
    [Recipe 3.5](#recipe_3_5)) to create container images.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll learn how to create OCI-compliant container
    images from a Dockerfile, either from a host with Docker installed, or using tools
    such as Buildah and Buildpacks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Building a Container Using Docker
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a container image for your application with Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you need to do is install [Docker](https://oreil.ly/jd0kH).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Docker is available for Mac, Windows, and Linux. Download the installer for
    your operating system and refer to the [documentation](https://oreil.ly/7vGmZ)
    to start the Docker service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can create a container image by defining a *Dockerfile*. The best
    definition for a Dockerfile comes from the [Docker documentation](https://oreil.ly/RMm2y)
    itself: “A Dockerfile is a text document that contains all the commands a user
    could call on the command line to assemble an image.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Container images present a layered structure, as you can see in [Figure 3-1](#fig3-1).
    Each container image provides the foundation layer for a container, and any update
    is just an additional layer that can be committed on the foundation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Container image layers](assets/gocb_0301.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Container image layers
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can create a Dockerfile like the one shown here, which will generate a container
    image for Python apps. You can also find this example in [this book’s repository](https://oreil.ly/J7cXP).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_containers_CO1-1)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`: always start from a base image as a foundational layer. In this case
    we start from a Universal Base Image (UBI), publicly available based on RHEL 8
    with Python 3.9 runtime.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_containers_CO1-2)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV`: set an environment variable for the app.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_containers_CO1-3)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPOSE`: expose a port to the container network, in this case port TCP 8080.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_containers_CO1-4)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR`: set a directory inside the container to work with.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_containers_CO1-5)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`COPY`: copy the assets from the source code files on your workstation to the
    container image layer, in this case, to the `WORKDIR`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_containers_CO1-6)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN`: run a command inside the container, using the tools already available
    within the base image. In this case, it runs the `pip` tool to install dependencies.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_containers_CO1-7)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`: define the entry point for your app inside the container. It
    can be a binary or a script. In this case, it runs the Python interpreter.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_containers_CO1-8)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`CMD`: the command that is used when starting a container. In this case it
    uses the name of the Python app `app.py`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now create your container image with the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Change the container image name with the your registry, user, and repo. Example:
    `quay.io/youruser/yourrepo:latest`. See [Chapter 2](ch02.xhtml#ch_Requirements)
    for how to create a new account on registries such as Quay.io.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Your container image is building now. Docker will fetch existing layers from
    a public container registry (DockerHub, Quay, Red Hat Registry, etc.) and add
    a new layer with the content specified in the Dockerfile. Such layers could also
    be available locally, if already downloaded, in special storage called a *container
    cache* or *Docker cache*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your container image is now available in your Docker cache and ready to be
    used. You can verify its presence with this command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the list of available container images from the cache in output.
    Those could be images you have built or downloaded with the `docker pull` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once your image is created, you can consume it locally or push it to a public
    container registry to be consumed elsewhere, like from a CI/CD pipeline.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to first log in to your public registry. In this example, we are using
    Quay:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get output similar to this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then you can push your container image to the registry:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As confirmed, you should get output similar to this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create container images in this way with Docker from your workstation
    or any host where the Docker service/daemon is running.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Additionally, you can use functionalities offered by a public registry such
    as [Quay.io](https://quay.io) that can directly create the container image from
    a Dockerfile and store it to the registry.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The build requires access to all layers, thus an internet connection to the
    registries storing base layers is needed, or at least having them in the container
    cache. Docker has a layered structure where any change to your app is committed
    on top of the existing layers, so there’s no need to download all the layers each
    time since it will add only deltas for each new change.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Container images typically start from a base OS layer such as Fedora, CentOS,
    Ubuntu, Alpine, etc. However, they can also start from `scratch`, an empty layer
    for super-minimal images containing only the app’s binary. See the [`scratch`
    documentation](https://oreil.ly/vj0gs) for more info.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run your previously created container image, you can do so with
    this command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`docker run` has many options to start your container. The most common are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`-p`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Binds the port of the container with the port of the host running such container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`-t`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Attaches a TTY to the container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`-i`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Goes into an interactive mode.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Goes in the background, printing a hash that you can use to interact asynchronously
    with the running container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will start your app in the Docker network and bind it
    to port 8080 of your workstation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From a new terminal, try accessing your running container:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should get output like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See Also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Best practices for writing Dockerfiles](https://oreil.ly/2hMQD)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Manage Docker images](https://oreil.ly/hUByf)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.2 Building a Container Using Dockerless Jib
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are a software developer, and you want to create a container image without
    installing Docker or any additional software on your workstation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Recipe 3.1](#recipe_3_1), you need to install the Docker engine
    to create container images. Docker requires permissions to install a service running
    as a daemon, thus a privileged process in your operating system. Today, *dockerless*
    solutions are also available for developers; a popular one is Jib.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[Jib](https://oreil.ly/NYCtv) is an open source framework for Java made by
    Google to build OCI-compliant container images, without the need for Docker or
    any container runtime. Jib comes as a library that Java developers can import
    in their Maven or Gradle projects. This means you can create a container image
    for your app without writing or maintaining any Dockerfiles, delegating this complexity
    to Jib.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: We see the benefits from this approach as the following:^([1](ch03.xhtml#idm45120847711664))
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Pure Java
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: No Docker or Dockerfile knowledge is required. Simply add Jib as a plug-in,
    and it will generate the container image for you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The application is divided into multiple layers, splitting dependencies from
    classes. There’s no need to rebuild the container image like for Dockerfiles;
    Jib takes care of modifying the layers that changed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Reproducibility
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary updates are not triggered because the same contents generate the
    same image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to kickstart a container image build with Jib on existing Maven
    is by adding the plug-in via the command line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can do so by adding Jib as a plug-in into your *pom.xml*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this way, you can also manage other settings such as authentication or parameters
    for the build.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now add Jib to an existing Java application, a Hello World application
    in Spring Boot that you can find in the [book’s repository](https://oreil.ly/dn1LF).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a container image without using Docker,
    and push it directly to a container registry. In this example, we use Quay.io,
    and we will store the container image at *quay.io/gitops-cookbook/jib-example:latest*,
    so you will need to provide your credentials for the registry:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The authentication here is handled with command-line options, but Jib can manage
    existing authentication with Docker CLI or read credentials from your *settings.xml*
    file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The build takes a few moments, and the result is a Java-specific container
    image, based on the *adoptOpenJDK* base image, built locally and pushed directly
    to a registry. In this case, to Quay.io:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have Docker and run the command `docker images`, you won’t see this image
    in your local cache!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your container image is not present in your local cache, as you don’t need any
    container runtime to build images with Jib. You won’t see it with the `docker
    images` command, but you can pull it from the public container registry afterward,
    and it will store it in your cache.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: This approach is suitable for development velocity and automation, where the
    CI system doesn’t need to have Docker installed on the nodes where it runs. Jib
    can create the container image without any Dockerfiles. Additionally, it can push
    the image to a container registry.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: If you also want to store it locally from the beginning, Jib can connect to
    Docker hosts and do it for you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pull your container image from the registry to try it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Get the `hello` endpoint:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See Also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Using Jib with Quarkus projects](https://oreil.ly/sTcpJ)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.3 Building a Container Using Buildah
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes installing or managing Docker is not possible. Dockerless solutions
    for creating container images are useful in use cases such as local development
    or CI/CD systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OCI specification is an open standard, and this favors multiple open source
    implementations for the container engine and the container image building mechanism.
    Two growing popular examples today are [Podman](https://podman.io) and [Buildah](https://buildah.io).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While Docker uses a single monolithic application for creating, running, and
    shipping container images, the codebase for container management functionalities
    here has been split between different projects like Podman, Buildah, and Skopeo.
    Podman support is already available on Mac and Windows, however Buildah is currently
    only available on Linux or Linux subsystems such as WSL2 for Windows. See the
    [documentation](https://oreil.ly/W9l1a) to install it on your workstation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Those are two complementary open source projects and command-line tools that
    work on OCI containers and images; however, they differ in their specialization.
    While Podman specializes in commands and functions that help you to maintain and
    modify container images, such as pulling, tagging, and pushing, Buildah specializes
    in building container images. Decoupling functions in different processes is done
    by design, as the authors wanted to move from the single privileged process Docker
    model to a lightweight, rootless, daemonless, and decoupled set of tools to improve
    agility and security.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Following the same approach, you find [Skopeo](https://oreil.ly/oJnAK), a tool
    used to move container images; and [CRI-O](https://cri-o.io), a container engine
    complaint with the Kubernetes container runtime interface for running applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Buildah supports the Dockerfile format, but its goal is to provide a lower-level
    interface to build container images without requiring a Dockerfile. Buildah is
    a daemonless solution that can create images inside a container without mounting
    the Docker socket. This functionality improves security and portability since
    it’s easy to add Buildah builds on the fly to a CI/CD pipeline where the Linux
    or Kubernetes nodes do not require a Docker installation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed, you can create a container image with or without a Dockerfile.
    Let’s now create a simple HTTPD container image without a Dockerfile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start from any base image such as CentOS:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get output similar to this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similarly to Docker and `docker images`, you can run the command `buildah containers`
    to get the list of available images from the container cache. If you also have
    installed Podman, this is similar to `podman images`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the container image ID is `centos-working-container`, and you
    can refer to it for creating the other layers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s install the `httpd` package inside a new layer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should get output similar to this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let’s copy a welcome HTML page inside the container running HTTPD. You
    can find the source code in [this book’s repo](https://oreil.ly/azx91):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For each new layer added, you should get output with the new container image
    hash, similar to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get output similar to this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Your container image is now in the container cache, ready to run or push to
    another registry.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, Buildah can also create container images from a Dockerfile.
    Let’s make the same container image from the Dockerfile listed here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you have also installed Podman, you can run it this way:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then you can test it by opening the browser on [*http://localhost:8080*](http://localhost:8080).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Buildah, you have the opportunity to create container images from scratch
    or starting from a Dockerfile. You don’t need to install Docker, and everything
    is designed around security: rootless mechanism, daemonless utilities, and more
    refined control of creating image layers.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Buildah can also build images from scratch, thus it creates an empty layer similar
    to the `FROM scratch` Dockerfile statement. This aspect is useful for creating
    very lightweight images containing only the packages needed to run your application,
    as you can see in [Figure 3-2](#fig3-2).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Buildah image shrink](assets/gocb_0302.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Buildah image shrink
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A good example use case for a scratch build is considering the development images
    versus staging or production images. During development, container images may
    require a compiler and other tools. However, in production, you may only need
    the runtime or your packages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Running Buildah inside a container](https://oreil.ly/GUfss)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.4 Building a Container with Buildpacks
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating container image by using Dockerfiles can be challenging at scale. You
    want a tool complementing Docker that can inspect your application source code
    to create container images without writing a Dockerfile.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Cloud Native Buildpacks](https://oreil.ly/psc6h) is an open source project
    that provides a set of executables to inspect your app source code and to create
    a plan to build and run your application.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Buildpacks can create OCI-compliant container images without a Dockerfile, starting
    from the app source code, as you can see in [Figure 3-3](#fig3-3).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Buildpacks builds](assets/gocb_0303.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Buildpacks builds
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This mechanism consists of two phases:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Detection
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Buildpacks tooling will navigate your source code to discover which programming
    language or framework is used (e.g., POM, NPM files, Python requirements, etc.)
    and assign a suitable buildpack for the build.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Building
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Once a buildpack is found, the source is compiled and Buildpacks creates a container
    image with the appropriate entry point and startup scripts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To use Buildpacks, you have to download the [pack](https://oreil.ly/K0gGM) CLI
    for your operating system (Mac, Windows, Linux), and also have Docker installed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'On macOS, `pack` is available through [Homebrew](https://brew.sh) as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let’s start creating our container image with Buildpacks from a sample
    Node.js app. You can find the app source code in this [book’s repository](https://oreil.ly/eViRN):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The app directory structure contains a *package.json* file, a manifest listing
    Node.js packages required for this build, which helps Buildpacks understand which
    buildpack to use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify it with this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should get output similar to this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now you can decide to pick one of the suggested buildpacks. Let’s try the `paketobuildpacks/builder:base`,
    which also contains the Node.js runtime:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Run `pack builder inspect paketobuildpacks/builder:base` to know the exact content
    of libraries and frameworks available in this buildpack.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The building process should start accordingly, and after a while, it should
    finish, and you should get output similar to this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let’s run it with Docker:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get output similar to this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'View the running application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should get output similar to this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discussion
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud Native Buildpacks is an incubating project in the Cloud Native Computing
    Foundation (CNCF), and it supports both Docker and Kubernetes. On Kubernetes,
    it can be used with [Tekton](https://tekton.dev), a Kubernetes-native CI/CD system
    that can run Buildpacks as a Tekton `Task` to create container images. It recently
    adopted the [Boson Project](https://oreil.ly/F0OTs) to provide a functions-as-a-service
    (FaaS) experience on Kubernetes with Knative, by enabling the build of functions
    via buildpacks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Using Buildpacks with Tekton Pipelines](https://oreil.ly/wFIHd)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FaaS Knative Boson project’s buildpacks](https://oreil.ly/p1U6n)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.5 Building a Container Using Shipwright and kaniko in Kubernetes
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create a container image, and you want to do it with Kubernetes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes is well known as a container orchestration platform to deploy and
    manage apps. However, it doesn’t include support for building container images
    out-of-the-box. Indeed, according to [Kubernetes documentation](https://oreil.ly/qgpKi):
    “(Kubernetes) Does not deploy source code and does not build your application.
    Continuous Integration, Delivery, and Deployment (CI/CD) workflows are determined
    by organization cultures and preferences as well as technical requirements.”'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, one standard option is to rely on CI/CD systems for this purpose,
    like Tekton (see [Chapter 6](ch06.xhtml#ch_Cloud_Native_CICD)). Another option
    is to use a framework to manage builds with many underlying tools, such as the
    one we discussed in the previous recipes. One example is Shipwright.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[Shipwright](https://shipwright.io) is an extensible framework for building
    container images on Kubernetes. It supports popular tools such as Buildah, Cloud
    Native Buildpacks, and kaniko. It uses Kubernetes-style APIs, and it runs workloads
    using Tekton.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The benefit for developers is a simplified approach for building container images,
    by defining a minimal YAML file that does not require any previous knowledge of
    containers or container engines. This approach makes this solution agnostic and
    highly integrated with the Kubernetes API ecosystem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to install Shipwright to your Kubernetes cluster, say
    kind or Minikube (see [Chapter 2](ch02.xhtml#ch_Requirements)), following the
    [documentation](https://oreil.ly/FWvXv) or from [OperatorHub.io](https://oreil.ly/6Ds5R).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using Operators and Operator Lifecycle Manager (OLM) gives consistency for installing/uninstalling
    software on Kubernetes, along with dependency management and lifecycle control.
    For instance, the Tekton Operator dependency is automatically resolved and installed
    if you install Shipwright via the Operator. Check the OLM [documentation](https://oreil.ly/V3k2p)
    for details with this approach.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow the standard procedure from the documentation. First you need
    to install the Tekton dependency. At the time of writing this book, it is version
    `0.30.0`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then you install Shipwright. At the time of writing this book, it is version
    `0.7.0`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, you install Shipwright build strategies:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once you have installed Shipwright, you can start creating your container image
    build using one of these tools:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: kaniko
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Native Buildpacks
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BuildKit
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buildah
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore kaniko.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[kaniko](https://oreil.ly/ncdWg) is another dockerless solution to build container
    images from a Dockerfile inside a container or Kubernetes cluster. Shipwright
    brings additional APIs to Kubernetes to use tools such as kaniko to create container
    images, acting as an abstract layer that can be considered an extensible building
    system for Kubernetes.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the APIs that are defined from Cluster Resource Definitions (CRDs):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`ClusterBuildStrategy`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Represents the type of build to execute.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`Build`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Represents the build. It includes the specification of one `ClusterBuildStrategy`
    object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`BuildRun`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Represents a running build. The build starts when this object is created.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check all available `ClusterBuildStrategy` (CBS)
    objects:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should get a list of available CBSs to consume:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This CRD is cluster-wide, available for all namespaces. If you don’t see any
    items, please install the Shipwright build strategies as discussed previously.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Shipwright will generate a container image on the Kubernetes nodes container
    cache, and then it can push it to a container registry.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to provide the credentials to push the image to the registry in the
    form of a Kubernetes Secret. For example, if you use Quay you can create one like
    the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With Quay, you can use an encrypted password instead of using your account password.
    See the documentation for more details.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create a *build-kaniko.yaml* file containing the `Build` object that
    will use kaniko to containerize a Node.js sample app. You can find the source
    code in this [book’s repository](https://oreil.ly/S84zu):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[![1](assets/1.png)](#co_containers_CO2-1)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Repository to grab the source code from.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_containers_CO2-2)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The directory where the source code is present.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_containers_CO2-3)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The `ClusterBuildStrategy` to use.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_containers_CO2-4)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The destination of the resulting container image. Change this with your container
    registry repo.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_containers_CO2-5)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The secret to use to authenticate to the container registry and push the image.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the `Build` object:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should get output similar to this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s list the available builds:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should get output similar to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At this point, your `Build` is `REGISTERED`, but it’s not started yet. Let’s
    create the following object in order to start it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you check the list of running pods, you should see one being created:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When the `STATUS` changes, the build will start, and you can track the progress
    by checking the logs from the containers used by this pod to run the build in
    multiple steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: step-source-default
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The first step, used to get the source code
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: step-build-and-push
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The step to run the build, either from source code or from a Dockerfile like
    in this case with kaniko
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: step-results
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The result of the build
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the logs of the building phase:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The image is built and pushed to the registry, and you can check the result
    from this command as well:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: And on your registry, as shown in [Figure 3-4](#fig3-4).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Image pushed to Quay.io](assets/gocb_0304.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Image pushed to Quay
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shipwright provides a convenient way to create container images on Kubernetes,
    and its agnostic approach makes it robust and interoperable. The project aims
    at being the Build API for Kubernetes, providing an easier path for developers
    to automate on Kubernetes. As Tekton runs under the hood creating builds, Shipwright
    also makes transitioning from micropipeline to extended pipeline workflows on
    Kubernetes easier.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reference, if you would like to create a build with Buildah instead of
    kaniko, it’s just a `ClusterBuildStrategy` change in your `Build` object:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[![1](assets/1.png)](#co_containers_CO3-1)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed previously in [Recipe 3.3](#recipe_3_3), Buildah can create
    the container image from the source code. It doesn’t need a Dockerfile.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_containers_CO3-2)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Buildah as the `ClusterBuildStrategy`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Final Thoughts
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The container format is the de facto standard for packaging applications, and
    today many tools help create container images. Developers can create images with
    Docker or with other tools and frameworks and then use the same with any CI/CD
    system to deploy their apps to Kubernetes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: While Kubernetes per se doesn’t build container images, some tools interact
    with the Kubernetes API ecosystem to add this functionality. This aspect improves
    development velocity and consistency across environments, delegating this complexity
    to the platform.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 本身不构建容器映像，但一些工具与 Kubernetes API 生态系统交互以添加此功能。这一方面提高了开发速度和环境一致性，将这种复杂性委托给平台。
- en: In the following chapters, you will see how to control the deployment of your
    containers running on Kubernetes with tools such as Kustomize or Helm, and then
    how to add automation to support highly scalable workloads with CI/CD and GitOps.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将看到如何使用 Kustomize 或 Helm 等工具控制在 Kubernetes 上运行的容器的部署，然后如何添加自动化支持高度可扩展的工作负载与
    CI/CD 和 GitOps。
- en: ^([1](ch03.xhtml#idm45120847711664-marker)) For a presentation about Jib, see
    Appu Goundan and Qingyang Chen’s [presentation from Velocity San Jose 2018](https://oreil.ly/W4j49).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45120847711664-marker)) 欲了解有关 Jib 的演示，请参阅 Appu Goundan 和
    Qingyang Chen 在 Velocity San Jose 2018 的[演示](https://oreil.ly/W4j49)。
