<html><head></head><body><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Express Data Path"><div class="chapter" id="express_data_path_XDP">
<h1><span class="label">Chapter 7. </span>Express Data Path</h1>


<p>Express Data Path (XDP) is a safe, programmable, high-performance, kernel-integrated packet processor in the Linux network data path that executes BPF programs when the NIC driver receives a packet.<a data-type="indexterm" data-primary="XDP (Express Data Path)" id="ix_XDP"/> This allows XDP programs to make decisions regarding the received packet (drop, modify, or just allow it) at the earliest possible point in time.<a data-type="indexterm" data-primary="Express Data Path" data-see="XDP" id="idm46623551655480"/><a data-type="indexterm" data-primary="packet processing with XDP" data-seealso="XDP" id="idm46623551654536"/></p>

<p>The execution point<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="fast XDP programs, reasons for" id="idm46623551653160"/> is not the only aspect that makes XDP programs fast; other design decisions play a role in that:</p>

<ul>
<li>
<p>There are no memory allocations while doing packet processing with XDP.</p>
</li>
<li>
<p>XDP programs work only with linear, unfragmented packets and have the start and end pointers of the packet.</p>
</li>
<li>
<p>There’s no access to full packet metadata, which is why the input context this kind of program<a data-type="indexterm" data-primary="xdp_buff struct" id="idm46623551648952"/> receives will be of type <code>xdp_buff</code> instead of the <code>sk_buff</code> struct you encountered in <a data-type="xref" href="ch06.html#linux_networking">Chapter 6</a>.</p>
</li>
<li>
<p>Because they are eBPF programs, XDP programs have a bounded execution time, and the consequence of this is that their usage has a fixed cost in the networking pipeline.<a data-type="indexterm" data-primary="eBPF" data-secondary="XDP programs" id="idm46623551645352"/></p>
</li>
</ul>

<p>When talking about XDP, it is important to remember that it is not a kernel bypass mechanism; it is designed to be integrated with other kernel components and the internal Linux security model.<a data-type="indexterm" data-primary="kernel" data-secondary="XDP and" id="idm46623551643528"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>xdp_buff</code> struct is used to present a packet context to a BPF program that uses the direct packet access mechanism provided by the XDP framework. Think of it as a “lightweight” version of the <code>sk_buff</code>.</p>

<p>The difference between the two is that <code>sk_buff</code> also holds and allows you to mingle with the packets’ metadata (proto, mark, type), which is only available at a higher level in the networking pipeline. The fact that <code>xdp_buff</code> is created early and doesn’t depend on other kernel layers is one reason it’s faster to obtain and process packets using XDP. The other reason is that <code>xdp_buff</code> doesn’t hold references to routes, Traffic Control hooks, or other kind of packet metadata like it would with program types that use an <code>sk_buff</code>.</p>
</div>

<p>In this chapter we explore the characteristics of XDP programs, the different kinds of XDP programs out there, and how they can be compiled and loaded. After that, to give more context, we discuss real-world use cases for it.</p>






<section data-type="sect1" data-pdf-bookmark="XDP Programs Overview"><div class="sect1" id="idm46623551636872">
<h1>XDP Programs Overview</h1>

<p>Essentially, what XDP programs do is that they make determinations about the received packet, and then they can edit the received packet’s content or just return a result code.<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="overview of XDP programs" id="ix_XDPovr"/> The result code is used to determine what happens to the packet in the form of an action. You can drop the packet, you can transmit it out the same interface, or you can
pass it up to the rest of the networking stack. Additionally, to cooperate with the network stack, XDP programs can push and pull a packet’s headers; for example, if the current kernel does not support an encapsulation format or a protocol, an XDP program can de-encapsulate it or translate the protocol and send the result to the kernel for processing.</p>

<p>But wait, what’s the correlation between XDP and eBPF?</p>

<p>It turns out that XDP programs are controlled through the <code>bpf</code> syscall and loaded using the program type <code>BPF_PROG_TYPE_XDP</code>. Also, the execution driver hook executes BPF bytecode.</p>

<p>An important concept to understand when writing XDP programs is that the contexts where they will run are also called <em>operation modes</em>.</p>








<section data-type="sect2" data-pdf-bookmark="Operation Modes"><div class="sect2" id="idm46623551630392">
<h2>Operation Modes</h2>

<p>XDP has three operation modes to accommodate easily testing functions, custom hardware from vendors, and commonly built kernels without custom hardware. Let’s go over each of them.<a data-type="indexterm" data-primary="operation modes (XDP)" id="ix_opsmd"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="overview of XDP programs" data-tertiary="operation modes" id="ix_XDPovrops"/></p>










<section data-type="sect3" data-pdf-bookmark="Native XDP"><div class="sect3" id="idm46623551626056">
<h3>Native XDP</h3>

<p>This is the default mode. In this mode, the XDP BPF program is run directly out of the networking driver’s early receive path.<a data-type="indexterm" data-primary="native XDP" id="idm46623551624440"/><a data-type="indexterm" data-primary="operation modes (XDP)" data-secondary="native XDP" id="idm46623551623736"/> When using this mode, it’s important to check whether the driver supports it. You can check that by executing the following command against the source tree of a given kernel version:</p>
<pre># Clone the linux-stable repository
git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\
linux-stable

# Checkout the tag for your current kernel version
cd linux-stable
git checkout tags/v4.18

# Check the available drivers
git grep -l XDP_SETUP_PROG drivers/</pre>

<p>That produces output like this:</p>
<pre>drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c
drivers/net/ethernet/cavium/thunder/nicvf_main.c
drivers/net/ethernet/intel/i40e/i40e_main.c
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
drivers/net/ethernet/mellanox/mlx4/en_netdev.c
drivers/net/ethernet/mellanox/mlx5/core/en_main.c
drivers/net/ethernet/netronome/nfp/nfp_net_common.c
drivers/net/ethernet/qlogic/qede/qede_filter.c
drivers/net/netdevsim/bpf.c
drivers/net/tun.c
drivers/net/virtio_net.c</pre>

<p>From what we can see, kernel 4.18 supports the following:</p>

<ul>
<li>
<p>Broadcom NetXtreme-C/E network driver <code>bnxt</code></p>
</li>
<li>
<p>Cavium <code>thunderx</code> driver</p>
</li>
<li>
<p>Intel <code>i40</code> driver</p>
</li>
<li>
<p>Intel <code>ixgbe</code> and <code>ixgvevf</code> drivers</p>
</li>
<li>
<p>Mellanox <code>mlx4</code> and <code>mlx5</code> drivers</p>
</li>
<li>
<p>Netronome Network Flow Processor</p>
</li>
<li>
<p>QLogic <code>qede</code> NIC Driver</p>
</li>
<li>
<p>TUN/TAP</p>
</li>
<li>
<p>Virtio</p>
</li>
</ul>

<p>With a clear idea of the native operation mode, we can proceed to see how XDP program duties can be directly handled by network cards by using offloaded XDP.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Offloaded XDP"><div class="sect3" id="idm46623551607224">
<h3>Offloaded XDP</h3>

<p>In this mode the XDP BPF program is directly offloaded into the NIC instead of being executed on the host CPU.<a data-type="indexterm" data-primary="offloaded XDP" id="idm46623551605592"/><a data-type="indexterm" data-primary="operation modes (XDP)" data-secondary="offloaded XDP" id="idm46623551604888"/><a data-type="indexterm" data-primary="hardware offload" id="idm46623551603944"/> By pushing execution off of the CPU, this mode has high-performance gains over native XDP.</p>

<p>We can reuse the kernel source tree we just cloned to check what NIC drivers in 4.18 support hardware <a data-type="indexterm" data-primary="XDP_SETUP_PROG_HW" id="idm46623551602536"/>offload by looking for <code>XDP_SETUP_PROG_HW</code>:</p>

<pre data-type="programlisting" data-code-language="bash">git grep -l XDP_SETUP_PROG_HW drivers/</pre>

<p>That should output something like this:</p>
<pre>include/linux/netdevice.h
866:    XDP_SETUP_PROG_HW,

net/core/dev.c
8001:           xdp.command = XDP_SETUP_PROG_HW;

drivers/net/netdevsim/bpf.c
200:    if (bpf-&gt;command == XDP_SETUP_PROG_HW &amp;&amp; !ns-&gt;bpf_xdpoffload_accept) {
205:    if (bpf-&gt;command == XDP_SETUP_PROG_HW) {
560:    case XDP_SETUP_PROG_HW:

drivers/net/ethernet/netronome/nfp/nfp_net_common.c
3476:   case XDP_SETUP_PROG_HW:</pre>

<p>That shows only the Netronome Network Flow Processor (<code>nfp</code>) meaning that it can operate in both modes by also supporting hardware offload along with native XDP.</p>

<p>Now a good question for yourself might be, what do I do when I don’t have network cards and drivers to try my XDP programs? The answer is easy, generic XDP!</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Generic XDP"><div class="sect3" id="idm46623551596328">
<h3>Generic XDP</h3>

<p>This is provided as a test-mode for developers who want to write and run XDP programs without having the capabilities of native or offloaded XDP.<a data-type="indexterm" data-primary="operation modes (XDP)" data-secondary="generic XDP" id="idm46623551593784"/><a data-type="indexterm" data-primary="generic XDP" id="idm46623551592808"/> Generic XDP has been supported since kernel version 4.12. You can use this mode, for example, on <code>veth</code> devices—we use this mode in the subsequent examples to show the capabilities of XDP without requiring you to buy specific hardware to follow along.</p>

<p>But who is the actor responsible for the coordination between all of the components and the operation modes?<a data-type="indexterm" data-primary="operation modes (XDP)" data-startref="ix_opsmd" id="idm46623551590808"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="overview of XDP programs" data-tertiary="operation modes" data-startref="ix_XDPovrops" id="idm46623551589832"/> Continue to the next section to learn about the packet <span class="keep-together">processor</span>.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="The Packet Processor"><div class="sect2" id="idm46623551587336">
<h2>The Packet Processor</h2>

<p>The actor that makes it possible to execute BPF programs on XDP packets and that coordinates the interaction between them and the network stack is the XDP packet processor.<a data-type="indexterm" data-primary="packet processor (XDP)" id="ix_pktpr"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="overview of XDP programs" data-tertiary="packet processor" id="ix_XDPovrpktpr"/> The packet processor is the in-kernel component for XDP programs that processes packets on the receive (RX) queue directly as they are presented by the NIC.<a data-type="indexterm" data-primary="receive (RX) queues" id="idm46623551582808"/> It ensures that packets are readable and writable and allows you to attach post-processing verdicts in the form of packet processor actions. Atomic program updates and new program loads to the packet processor can be done at runtime without any service interruption in terms of networking and associated traffic.<a data-type="indexterm" data-primary="busy polling mode (XDP)" id="idm46623551581672"/> While operating, XDP can be used in “busy polling” mode, allowing you to reserve the CPUs that will have to deal with each RX queue; this avoids context switches and allows immediate packet reactivity upon arrival regardless of IRQ affinities. <a data-type="indexterm" data-primary="interrupt driven mode (XDP)" id="idm46623551580600"/>The other mode XDP can be used in is the “interrupt driven” mode that, on the other hand, does not reserve the CPU but instructs an interrupt acting as an event medium to inform the CPU that it has to deal with a new event while still doing normal processing.</p>

<p>In <a data-type="xref" href="#xdp-interaction">Figure 7-1</a> you can see in the interaction points between RX/TX, applications, the packet processor, and the BPF programs applied to its packets.</p>

<p>Notice that there are a few squares with a string prepended by <code>XDP_</code> in <a data-type="xref" href="#xdp-interaction">Figure 7-1</a>. Those are the XDP result codes,<a data-type="indexterm" data-primary="packet processor (XDP)" data-secondary="result codes or packet processor actions" id="idm46623551576504"/> which we cover next.</p>

<figure><div id="xdp-interaction" class="figure">
<img src="assets/lbpf_0701.png" alt="Interaction between the XDP packet processor and the network stack, dashed lines represent the packets flow, the bold full line represent the loading of the BPF program in the XDP packet processor."/>
<h6><span class="label">Figure 7-1. </span>The packet processor</h6>
</div></figure>










<section data-type="sect3" data-pdf-bookmark="XDP result codes (packet processor actions)"><div class="sect3" id="idm46623551556712">
<h3>XDP result codes (packet processor actions)</h3>

<p>After a decision is made about the packet in the packet processor, it can be expressed using one of the five return codes that then can instruct the network driver on how to process the packet. Let’s dive into the actions that the packet processor performs:</p>
<dl>
<dt>Drop (<code>XDP_DROP</code>)</dt>
<dd>
<p>Drops the packet. This happens at the earliest RX stage in the driver; dropping a packet simply implies<a data-type="indexterm" data-primary="dropping packets (XDP_DROP)" id="idm46623551552520"/> recycling it back into the RX ring queue it just “arrived” on. Dropping the packet as early as possible is key for the denial-of-service (DoS) mitigation use cases. This way, dropped packets use as little CPU processing time and power as possible.</p>
</dd>
<dt>Forward (<code>XDP_TX</code>)</dt>
<dd>
<p>Forwards the packet. <a data-type="indexterm" data-primary="forwarding packets (XDP_TX)" id="idm46623551549672"/>This can happen before or after the packet has been modified. Forwarding a packet implies bouncing the received packet page back out the same NIC it arrived on.</p>
</dd>
<dt>Redirect (<code>XDP_REDIRECT</code>)</dt>
<dd>
<p>Similar to <code>XDP_TX</code> in that it is able to transmit the XDP packet, but it does so through another NIC or into a BPF <code>cpumap</code>.<a data-type="indexterm" data-primary="redirecting packets (XDP_REDIRECT)" id="idm46623551545688"/> In the case of a BPF <code>cpumap</code>, the CPUs serving XDP on the NIC’s receive queues can continue to do so and push the packet for processing the upper kernel stack to a remote CPU. This is similar to <code>XDP_PASS</code>, but with the ability that the XDP BPF program can keep serving the incoming high load as opposed to temporarily spending work on the current packet for pushing into the upper layers.</p>
</dd>
<dt>Pass (<code>XDP_PASS</code>)</dt>
<dd>
<p>Passes the packet to the normal network stack for processing.<a data-type="indexterm" data-primary="passing packets (XDP_PASS)" id="idm46623551541992"/> This is equivalent to the default packet handling behavior without XDP. This can be done in one of two ways:</p>

<ul>
<li>
<p><em>Normal receive</em> allocates metadata (<code>sk_buff</code>), receives the packet onto
the stack, and steers the packet to another CPU for processing.<a data-type="indexterm" data-primary="normal receive" id="idm46623551539192"/> It allows for
raw interfaces to user-space. This can happen before or after the packet has
been modified.</p>
</li>
<li>
<p><em>Generic receive offload</em> (GRO) can perform a receive of large packets and
combines packets of the same connection.<a data-type="indexterm" data-primary="generic receive offload (GRO)" id="idm46623551537000"/> GRO eventually passes the packet
through the “normal receive” flow after processing.</p>
</li>
</ul>
</dd>
<dt>Code error (<code>XDP_ABORTED</code>)</dt>
<dd>
<p>Denotes an eBPF program error and results in the packet being dropped.<a data-type="indexterm" data-primary="code error (XDP_ABORTED)" id="idm46623551534056"/> It is not something a functional program should ever use as a return code. For example, <code>XDP_ABORTED</code> would be returned if the program divided by zero. <code>XDP_ABORTED</code>’s value will always be zero. It passes the <code>trace_xdp_exception</code> tracepoint, which can be additionally monitored to detect misbehavior.<a data-type="indexterm" data-primary="trace_xdp_exception tracepoint" id="idm46623551531752"/></p>
</dd>
</dl>

<p>These action codes<a data-type="indexterm" data-primary="linux/bpf.h file, XDP packet processor action codes" id="idm46623551530648"/> are expressed in the <code>linux/bpf.h</code> header file as follows:</p>

<pre data-type="programlisting">enum xdp_action {
    XDP_ABORTED = 0,
    XDP_DROP,
    XDP_PASS,
    XDP_TX,
    XDP_REDIRECT,
};</pre>

<p>Because XDP actions determine different behaviors and are an internal mechanism of the packet processor, you can look at a simplified version of <a data-type="xref" href="#xdp-interaction">Figure 7-1</a> focused on only the return actions (see <a data-type="xref" href="#xdp-result">Figure 7-2</a>).</p>

<figure><div id="xdp-result" class="figure">
<img src="assets/lbpf_0702.png" alt="Interaction between XDP actions triggered by a BPF program and the network stack"/>
<h6><span class="label">Figure 7-2. </span>XDP action codes</h6>
</div></figure>

<p>An interesting thing about XDP programs is that you don’t usually need to write a loader to load them. There is a good loader in most Linux machines implemented by the <code>ip</code> command. The next section describes how to use it.<a data-type="indexterm" data-primary="packet processor (XDP)" data-startref="ix_pktpr" id="idm46623551523240"/><a data-type="indexterm" data-primary="XDP" data-secondary="overview of XDP programs" data-tertiary="packet processor" data-startref="ix_XDPovrpktpr" id="idm46623551522264"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="XDP and iproute2 as a Loader"><div class="sect2" id="idm46623551520632">
<h2>XDP and iproute2 as a Loader</h2>

<p>The <code>ip</code> command, available in <a href="https://oreil.ly/65zuT">iproute2</a>, has the ability to act as a frontend to load XDP programs compiled into an ELF file and has full support <a data-type="indexterm" data-primary="loader programs" data-secondary="XDP and iproute2 as loader" id="ix_loadXDP"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="overview of XDP programs" data-tertiary="XDP and iproute2 as a loader" id="ix_XDPovrload"/><a data-type="indexterm" data-primary="iproute2 toolkit" data-secondary="ip command as loader for XDP programs" id="ix_iprt"/>for maps, map relocation, tail call and object pinning.</p>

<p>Because loading an XDP program can be expressed as a configuration of an existing network interface, the loader is implemented as part of the <code>ip link</code> command, which is the one that does network device configuration.</p>

<p>The syntax to load the XDP program is simple:</p>

<pre data-type="programlisting"># ip link set dev eth0 xdp obj program.o sec mysection</pre>

<p>Let’s analyze this command parameter by parameter:</p>
<dl>
<dt><code>ip</code></dt>
<dd>
<p>This invokes the <code>ip</code> command.</p>
</dd>
<dt><code>link</code></dt>
<dd>
<p>Configures network interfaces.</p>
</dd>
<dt><code>set</code></dt>
<dd>
<p>Changes device attributes.</p>
</dd>
<dt><code>dev eth0</code></dt>
<dd>
<p>Specifies the network device on which we want to operate and load the XDP <span class="keep-together">program</span>.</p>
</dd>
<dt><code>xdp obj program.o</code></dt>
<dd>
<p>Loads an XDP program from the ELF file (object) named <code>program.o</code>. The <code>xdp</code> part of this command tells the system to use the native driver when it is available and fallback to generic otherwise. You can force using a mode or another by using a more specific selector:</p>

<ul>
<li>
<p><code>xdpgeneric</code> to use generic XDP</p>
</li>
<li>
<p><code>xdpdrv</code> to use native XDP</p>
</li>
<li>
<p><code>xdpoffload</code> to use offloaded XDP</p>
</li>
</ul>
</dd>
<dt><code>sec mysection</code></dt>
<dd>
<p>Specifies the section name <code>mysection</code> containing the BPF program to use from the ELF file; if this is not specified, the section named <code>prog</code> will be used. If no section is specified in the program, you have to specify <code>sec .text</code> in the <code>ip</code> <span class="keep-together">invocation</span>.</p>
</dd>
</dl>

<p>Let’s see a practical example.</p>

<p>The scenario is that we have a system with a web server on port 8000 for which we want to block any access to its pages on the public-facing NIC of the server by disallowing all the TCP connections to it.</p>

<p>The first thing that we will need is the web server in question; if you don’t already have one, you can start one with <code>python3</code>.</p>

<pre data-type="programlisting">$ python3 -m http.server</pre>

<p>After your webserver is started, its open port will be shown in the open sockets using <code>ss</code>. As you can see the webserver is bound to any interface, <code>*:8000</code>, so as of now, any external caller with access to our public interfaces will be able to see its content!</p>

<pre data-type="programlisting">$  ss -tulpn
Netid  State      Recv-Q Send-Q Local Address:Port   Peer Address:Port
tcp    LISTEN     0      5      *:8000                *:*</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Socket statistics, <code>ss</code> in the terminal, is a command-line utility used to investigate network sockets in Linux.<a data-type="indexterm" data-primary="socket statistics (ss command-line utility)" id="idm46623551485160"/><a data-type="indexterm" data-primary="ss (socket statistics) command-line utility" id="idm46623551484360"/> It is effectively a modern version of <code>netstat</code>, and its user experience is similar to Netstat, meaning that you can pass the same arguments and get comparable results.<a data-type="indexterm" data-primary="netstat utility" id="idm46623551482952"/></p>
</div>

<p>At this point, we can inspect the network interfaces on the machine that’s running our <a data-type="indexterm" data-primary="network interfaces" data-secondary="on machine where HTTP server is started" id="idm46623551481624"/>HTTP server:</p>

<pre data-type="programlisting">$ ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group defau
lt qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP g
roup default qlen 1000
    link/ether 02:1e:30:9c:a3:c0 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3
       valid_lft 84964sec preferred_lft 84964sec
    inet6 fe80::1e:30ff:fe9c:a3c0/64 scope link
       valid_lft forever preferred_lft forever
3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP g
roup default qlen 1000
    link/ether 08:00:27:0d:15:7d brd ff:ff:ff:ff:ff:ff
    inet 192.168.33.11/24 brd 192.168.33.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe0d:157d/64 scope link
       valid_lft forever preferred_lft forever</pre>

<p>Notice that this machine has three interfaces, and the network topology is simple:</p>
<dl>
<dt><code>lo</code></dt>
<dd>
<p>This is just the loopback interface for internal communication.</p>
</dd>
<dt><code>enp0s3</code></dt>
<dd>
<p>This is the management network tier; administrators will use this interface to connect to the web server to do their operations.</p>
</dd>
<dt><code>enp0s8</code></dt>
<dd>
<p>This is the interface open to the public, our web server will need to be hidden from this interface.</p>
</dd>
</dl>

<p>Now, before loading any XDP program, we can check open ports on the server from another server that can access its network interface, in our case, with IPv4 <code>192.168.33.11</code>.</p>

<p>You can check open ports on a remote host by using <a data-type="indexterm" data-primary="nmap utility" data-secondary="checking open ports on remote host" id="idm46623551471624"/> <code>nmap</code> as follows:</p>

<pre data-type="programlisting"># nmap -sS 192.168.33.11
Starting Nmap 7.70 ( https://nmap.org ) at 2019-04-06 23:57 CEST
Nmap scan report for 192.168.33.11
Host is up (0.0034s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
8000/tcp open  http-alt</pre>

<p>Good! Port 8000 is right there, at this point we need to block it!</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Network Mapper (<code>nmap</code>) is a network scanner that can do host, service, network, and port discovery along with operating system detection.<a data-type="indexterm" data-primary="nmap utility" data-secondary="use cases" id="idm46623551466968"/> Its main use cases are security auditing and network scanning. When scanning a host for open ports, <code>nmap</code> will try every port in the specified (or full) range.</p>
</div>

<p>Our program will consist of a single source file named <em>program.c</em>, so let’s see what we need to write.</p>

<p>It needs to use the IPv4 <code>iphdr</code> and Ethernet Frame <code>ethhdr</code> header structs and also protocol constants and other structs. Let’s include the needed headers, as shown here:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;linux/bpf.h&gt;</code>
<code class="cp">#include &lt;linux/if_ether.h&gt;</code>
<code class="cp">#include &lt;linux/in.h&gt;</code>
<code class="cp">#include &lt;linux/ip.h&gt;</code></pre>

<p>After the headers are included, we can declare the <code>SEC</code> macro we already met in the previous chapters, used to declare ELF attributes.</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#define SEC(NAME) __attribute__((section(NAME), used))</code></pre>

<p>Now we can declare the main entry point for our program, <code>myprogram</code>, and its ELF section name, <code>mysection</code>. Our program takes as input context an <code>xdp_md</code> struct pointer, the BPF equivalent of the in-driver <code>xdp_buff</code>. By using that as the context, we then define the variables we will use next such as the data pointers, the Ethernet, and IP layer structs:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">SEC</code><code class="p">(</code><code class="s">"mysection"</code><code class="p">)</code>
<code class="kt">int</code> <code class="n">myprogram</code><code class="p">(</code><code class="k">struct</code> <code class="n">xdp_md</code> <code class="o">*</code><code class="n">ctx</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">ipsize</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kt">void</code> <code class="o">*</code><code class="n">data</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code>
  <code class="kt">void</code> <code class="o">*</code><code class="n">data_end</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">ethhdr</code> <code class="o">*</code><code class="n">eth</code> <code class="o">=</code> <code class="n">data</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">iphdr</code> <code class="o">*</code><code class="n">ip</code><code class="p">;</code></pre>

<p>Because <code>data</code> contains the Ethernet frame, we can now extract the IPv4 layer from it. We also check that the offset where we look for the IPv4 layer doesn’t exceed the whole pointer space so that the static verifier stays happy. When the address space is exceeded we just drop the packet:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="n">ipsize</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="o">*</code><code class="n">eth</code><code class="p">);</code>
  <code class="n">ip</code> <code class="o">=</code> <code class="n">data</code> <code class="o">+</code> <code class="n">ipsize</code><code class="p">;</code>
  <code class="n">ipsize</code> <code class="o">+=</code> <code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code> <code class="n">iphdr</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">data</code> <code class="o">+</code> <code class="n">ipsize</code> <code class="o">&gt;</code> <code class="n">data_end</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">XDP_DROP</code><code class="p">;</code>
  <code class="p">}</code></pre>

<p>Now, after all the verifications and setup, we can implement the real logic for the program, which basically drops every TCP packet while allowing anything else:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="k">if</code> <code class="p">(</code><code class="n">ip</code><code class="o">-&gt;</code><code class="n">protocol</code> <code class="o">==</code> <code class="n">IPPROTO_TCP</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">XDP_DROP</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">XDP_PASS</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Now that our program is done, we can save it as <em>program.c.</em></p>

<p>The next step is to compile the ELF file <em>program.o</em> out of our program using Clang. We can do this compilation step outside the target machine because BPF ELF binaries are not platform dependent:</p>

<pre data-type="programlisting">$ clang -O2 -target bpf -c program.c -o program.o</pre>

<p>Now back on the machine hosting our web server, we can finally load <code>program.o</code> against the public network interface <code>enp0s8</code> using the <code>ip</code> utility with the <code>set</code> command, as described earlier:</p>

<pre data-type="programlisting"># ip link set dev enp0s8 xdp obj program.o sec mysection</pre>

<p>As you might notice, we select the section <code>mysection</code> as the entry point for the <span class="keep-together">program</span>.</p>

<p>At this stage, if that command returned zero as the exit code with no errors, we can check the network interface to see whether the program had been loaded correctly:</p>

<pre data-type="programlisting"># ip a show enp0s8
3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric/id:32
    qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:0d:15:7d brd ff:ff:ff:ff:ff:ff
    inet 192.168.33.11/24 brd 192.168.33.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe0d:157d/64 scope link
       valid_lft forever preferred_lft forever</pre>

<p>As you can see, our output for <code>ip a</code> now has a new detail; after the MTU, it shows <code>xdpgeneric/id:32</code>, which is showing two interesting bits of information:</p>

<ul>
<li>
<p>The driver that had been used, <code>xdpgeneric</code></p>
</li>
<li>
<p>The ID of the XDP program, <code>32</code></p>
</li>
</ul>

<p>The last step is to verify that the loaded program is in fact doing what it is supposed to do. We can verify that by executing <code>nmap</code> again on an external machine to observe that port 8000 is no longer reachable:</p>

<pre data-type="programlisting"># nmap -sS 192.168.33.11
Starting Nmap 7.70 ( https://nmap.org ) at 2019-04-07 01:07 CEST
Nmap scan report for 192.168.33.11
Host is up (0.00039s latency).
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh</pre>

<p>Another test to verify that it all works can be trying to access the program through a browser or doing any HTTP request. Any kind of test should fail when targeting <code>192.168.33.11</code> as the destination. Good job and congratulations on loading your first XDP program!</p>

<p>If you followed all of those steps on a machine that you need to restore to its original state, you can always detach the program and turn off XDP for the device:</p>

<pre data-type="programlisting"># ip link set dev enp0s8 xdp off</pre>

<p>Interesting! Loading XDP programs seems easy, doesn’t it?</p>

<p>At least when using <code>iproute2</code> as the loader, you can skip the part of having to write a loader yourself. In this example, our focus was on <code>iproute2</code>, which already implements a loader for XDP programs. However, the programs are in fact BPF programs, so even if <code>iproute2</code> can be handy sometimes, you should always remember that you can load your programs using BCC, as shown in the next section, or you can use the <code>bpf</code> syscall directly. Having a custom loader has the advantage of allowing you to manage the lifecycle of the program and its interactions with user-space.<a data-type="indexterm" data-primary="loader programs" data-secondary="XDP and iproute2 as loader" data-startref="ix_loadXDP" id="idm46623551206872"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="overview of XDP programs" data-tertiary="XDP and iproute2 as a loader" data-startref="ix_XDPovrload" id="idm46623551205608"/><a data-type="indexterm" data-primary="iproute2 toolkit" data-secondary="ip command as loader for XDP programs" data-startref="ix_iprt" id="idm46623551204088"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="overview of XDP programs" data-startref="ix_XDPovr" id="idm46623551202856"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="XDP and BCC"><div class="sect1" id="idm46623551201496">
<h1>XDP and BCC</h1>

<p>Like with any other BPF program, XDP programs can be compiled, loaded, and run using BCC.<a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="using with XDP programs" id="ix_BCCXDP"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="and BCC" data-secondary-sortas="BCC" id="ix_XDPBCC"/> The following example shows an XDP program that is similar to the one we used for <code>iproute2</code> but that has a custom user-space loader made with BCC. The loader in this case is needed because we also want to count the number of packets we encounter while dropping TCP packets.</p>

<p>Like before, we create a kernel-space program named <em>program.c</em> first.</p>

<p>In the <code>iproute2</code> example, our program needed to import the required headers for struct and function definitions related to BPF and protocols. Here we do the same, but we also declare a map of type <code>BPF_MAP_TYPE_PERCPU_ARRAY</code> using the <code>BPF_TABLE</code> macro. <a data-type="indexterm" data-primary="CPUs" data-secondary="per-cpu array maps" id="idm46623551181960"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="per-cpu array map" id="idm46623551180952"/><a data-type="indexterm" data-primary="per-cpu array maps" id="idm46623551180008"/><a data-type="indexterm" data-primary="array maps" data-secondary="per-cpu" id="idm46623551179336"/><a data-type="indexterm" data-primary="BPF_TABLE macro" id="idm46623551178392"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_PERCPU_ARRAY type" id="idm46623551177720"/>The map will contain a packet counter for each IP protocol index, which is the reason for the size <code>256</code> (the IP specification contains only 256 values). We want to use a <code>BPF_MAP_TYPE_PERCPU_ARRAY</code> type because that’s the one that guarantees atomicity of the counters at CPU level without locking:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#define KBUILD_MODNAME "program"</code>
<code class="cp">#include &lt;linux/bpf.h&gt;</code>
<code class="cp">#include &lt;linux/in.h&gt;</code>
<code class="cp">#include &lt;linux/ip.h&gt;</code>

<code class="n">BPF_TABLE</code><code class="p">(</code><code class="s">"percpu_array"</code><code class="p">,</code> <code class="kt">uint32_t</code><code class="p">,</code> <code class="kt">long</code><code class="p">,</code> <code class="n">packetcnt</code><code class="p">,</code> <code class="mi">256</code><code class="p">);</code></pre>

<p>After that, we declare our main function, <code>myprogram</code>, which takes as a parameter the <code>xdp_md</code> struct.<a data-type="indexterm" data-primary="xdp_md struct" id="idm46623551163768"/> The first thing this needs to contain is the variable declarations for the Ethernet IPv4 frames:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="nf">myprogram</code><code class="p">(</code><code class="k">struct</code> <code class="n">xdp_md</code> <code class="o">*</code><code class="n">ctx</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">ipsize</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kt">void</code> <code class="o">*</code><code class="n">data</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code>
  <code class="kt">void</code> <code class="o">*</code><code class="n">data_end</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">ethhdr</code> <code class="o">*</code><code class="n">eth</code> <code class="o">=</code> <code class="n">data</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">iphdr</code> <code class="o">*</code><code class="n">ip</code><code class="p">;</code>
  <code class="kt">long</code> <code class="o">*</code><code class="n">cnt</code><code class="p">;</code>
  <code class="n">__u32</code> <code class="n">idx</code><code class="p">;</code>

  <code class="n">ipsize</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="o">*</code><code class="n">eth</code><code class="p">);</code>
  <code class="n">ip</code> <code class="o">=</code> <code class="n">data</code> <code class="o">+</code> <code class="n">ipsize</code><code class="p">;</code>
  <code class="n">ipsize</code> <code class="o">+=</code> <code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code> <code class="n">iphdr</code><code class="p">);</code></pre>

<p>After we have all the variable declarations done and can access the <code>data</code> pointer that now contains the Ethernet frame and the <code>ip</code> pointer with the IPv4 packet, we can check whether the memory space is out of bounds. If it is, we drop the packet. If the memory space is OK, we extract the protocol and lookup the <code>packetcnt</code> array to get the previous value of the packet counter for the current protocol in the variable <code>idx</code>. Then we increment the counter by one. When the increment is handled, we can proceed and check whether the protocol is TCP. If it is, we just drop the packet without questioning; otherwise, we allow it:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="k">if</code> <code class="p">(</code><code class="n">data</code> <code class="o">+</code> <code class="n">ipsize</code> <code class="o">&gt;</code> <code class="n">data_end</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">XDP_DROP</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">idx</code> <code class="o">=</code> <code class="n">ip</code><code class="o">-&gt;</code><code class="n">protocol</code><code class="p">;</code>
  <code class="n">cnt</code> <code class="o">=</code> <code class="n">packetcnt</code><code class="p">.</code><code class="n">lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="n">idx</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">cnt</code><code class="p">)</code> <code class="p">{</code>
    <code class="o">*</code><code class="n">cnt</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">ip</code><code class="o">-&gt;</code><code class="n">protocol</code> <code class="o">==</code> <code class="n">IPPROTO_TCP</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">XDP_DROP</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">XDP_PASS</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Now let’s write the loader:<a data-type="indexterm" data-primary="loader programs" data-secondary="writing loader.py in BCC" id="idm46623551028232"/> <code>loader.py</code>.</p>

<p>It is made of two parts: the actual loading logic and the loop that prints
the packet counts.</p>

<p>For the loading logic, we open our program by reading the file <em>program.c</em>. With <code>load_func</code>, we instruct the <code>bpf</code> syscall to use the <code>myprogram</code> function as “main” using the program type <code>BPF.XDP</code>. That stands for <code>BPF_PROG_TYPE_XDP</code>.<a data-type="indexterm" data-primary="BPF_PROG_TYPE_XDP" id="idm46623550918136"/></p>

<p>After the loading, we gain access to the BPF map named <code>packetcnt</code> using <code>get_table</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Make sure to change the <code>device</code> variable from <code>enp0s8</code> to the interface you want to work on.</p>
</div>

<pre data-type="programlisting" data-code-language="python"><code class="c-Hashbang">#!/usr/bin/python</code>

<code class="kn">from</code> <code class="nn">bcc</code> <code class="kn">import</code> <code class="n">BPF</code>
<code class="kn">import</code> <code class="nn">time</code>
<code class="kn">import</code> <code class="nn">sys</code>

<code class="n">device</code> <code class="o">=</code> <code class="s2">"enp0s8"</code>
<code class="n">b</code> <code class="o">=</code> <code class="n">BPF</code><code class="p">(</code><code class="n">src_file</code><code class="o">=</code><code class="s2">"program.c"</code><code class="p">)</code>
<code class="n">fn</code> <code class="o">=</code> <code class="n">b</code><code class="o">.</code><code class="n">load_func</code><code class="p">(</code><code class="s2">"myprogram"</code><code class="p">,</code> <code class="n">BPF</code><code class="o">.</code><code class="n">XDP</code><code class="p">)</code>
<code class="n">b</code><code class="o">.</code><code class="n">attach_xdp</code><code class="p">(</code><code class="n">device</code><code class="p">,</code> <code class="n">fn</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>
<code class="n">packetcnt</code> <code class="o">=</code> <code class="n">b</code><code class="o">.</code><code class="n">get_table</code><code class="p">(</code><code class="s2">"packetcnt"</code><code class="p">)</code></pre>

<p>The remaining part we need to write is the actual loop to print out the packet counts. Without this, our program will already be able to drop the packets, but we want to see what’s going on there. We have two loops. The outer loop gets keyboard events and terminates when there’s a signal to interrupt the program. When the outer loop breaks, the <code>remove_xdp</code> function is called, and the interface is freed from the XDP program.</p>

<p>Within the outer loop, the inner loop has the duty of getting back the values from the <code>packetcnt</code> map and prints them in the format <code><em>protocol</em>: <em>counter</em> pkt/s</code>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">prev</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">*</code> <code class="mi">256</code>
<code class="k">print</code><code class="p">(</code><code class="s2">"Printing packet counts per IP protocol-number, hit CTRL+C to stop"</code><code class="p">)</code>
<code class="k">while</code> <code class="mi">1</code><code class="p">:</code>
    <code class="k">try</code><code class="p">:</code>
        <code class="k">for</code> <code class="n">k</code> <code class="ow">in</code> <code class="n">packetcnt</code><code class="o">.</code><code class="n">keys</code><code class="p">():</code>
            <code class="n">val</code> <code class="o">=</code> <code class="n">packetcnt</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">k</code><code class="p">)</code><code class="o">.</code><code class="n">value</code>
            <code class="n">i</code> <code class="o">=</code> <code class="n">k</code><code class="o">.</code><code class="n">value</code>
            <code class="k">if</code> <code class="n">val</code><code class="p">:</code>
                <code class="n">delta</code> <code class="o">=</code> <code class="n">val</code> <code class="o">-</code> <code class="n">prev</code><code class="p">[</code><code class="n">i</code><code class="p">]</code>
                <code class="n">prev</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">=</code> <code class="n">val</code>
                <code class="k">print</code><code class="p">(</code><code class="s2">"{}: {} pkt/s"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">i</code><code class="p">,</code> <code class="n">delta</code><code class="p">))</code>
        <code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
    <code class="k">except</code> <code class="ne">KeyboardInterrupt</code><code class="p">:</code>
        <code class="k">print</code><code class="p">(</code><code class="s2">"Removing filter from device"</code><code class="p">)</code>
        <code class="k">break</code>

<code class="n">b</code><code class="o">.</code><code class="n">remove_xdp</code><code class="p">(</code><code class="n">device</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code></pre>

<p>Good! Now we can test that program by simply executing the loader with root <span class="keep-together">privileges</span>:</p>

<pre data-type="programlisting"># python program.py</pre>

<p>That will output a line every second with the packet counters:</p>

<pre data-type="programlisting">Printing packet counts per IP protocol-number, hit CTRL+C to stop
6: 10 pkt/s
17: 3 pkt/s
^CRemoving filter from device</pre>

<p>We encountered only two types of packets: <code>6</code> stands for TCP, and <code>17</code> stands for UDP.</p>

<p>At this point your brain will probably start thinking about ideas and projects for using XDP, and that’s extremely good! But as always, in software engineering if you want to make a good program, it’s important to write tests first—or at least write tests! The next section covers how you can unit-test XDP programs.<a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="using with XDP programs" data-startref="ix_BCCXDP" id="idm46623550722072"/><a data-type="indexterm" data-primary="XDP" data-secondary="and BCC" data-secondary-sortas="BCC" data-startref="ix_XDPBCC" id="idm46623550720856"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Testing XDP Programs"><div class="sect1" id="idm46623551188680">
<h1>Testing XDP Programs</h1>

<p>When working on XDP programs, the most difficult part is that in order to test the actual packet flow, you need to reproduce an environment in which all of the components are aligned to provide the correct packets.<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="testing programs" id="ix_XDPtst"/> Although it’s true that with virtualization technologies nowadays, creating a working environment can be an easy task, it’s also true that a complicated setup can limit the reproducibility and programmability of the test environment. In addition to that, when analyzing the performance aspects of high-frequency XDP programs in a virtualized environment, the cost of virtualization makes the test ineffective because it’s much more substantial than the actual packet processing.</p>

<p>Fortunately, kernel developers have a solution.<a data-type="indexterm" data-primary="BPF_PROG_TEST_RUN command" id="idm46623550715704"/> They have implemented a command that can be used to test XDP programs, called <code>BPF_PROG_TEST_RUN</code>.</p>

<p>Essentially, <code>BPF_PROG_TEST_RUN</code> gets an XDP program to execute, along with an input packet and an output packet. When the program is executed, the output packet variable is populated, and the return XDP code is returned. This means you can use the output packet and return code in your test assertions! This technique can also be used for <code>skb</code> programs.</p>

<p>For the sake of completeness and to make this example simple, we use Python and its unit testing framework.</p>








<section data-type="sect2" data-pdf-bookmark="XDP Testing Using the Python Unit Testing Framework"><div class="sect2" id="idm46623550712184">
<h2>XDP Testing Using the Python Unit Testing Framework</h2>

<p>Writing XDP tests with <code>BPF_PROG_TEST_RUN</code> and integrating them with the Python unit testing framework <code>unittest</code> is a good <a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="testing programs" data-tertiary="using Python unit testing framework" id="ix_XDPtstPyUT"/><a data-type="indexterm" data-primary="Python" data-secondary="unit testing framework, testing XDP programs" id="ix_Pyutst"/>idea for several reasons:</p>

<ul>
<li>
<p>You can load and execute BPF programs using the Python <em>BCC</em> library.</p>
</li>
<li>
<p>Python has one of the best packet crafting and introspection libraries available: <code>scapy</code>.<a data-type="indexterm" data-primary="scapy library (Python)" id="idm46623550702856"/></p>
</li>
<li>
<p>Python integrates with C structs using <code>ctypes</code>.</p>
</li>
</ul>

<p>As said, we need to import all of the needed libraries; that’s the first thing we will do in a file named <em>test_xdp.py</em>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">bcc</code> <code class="kn">import</code> <code class="n">BPF</code><code class="p">,</code> <code class="n">libbcc</code>
<code class="kn">from</code> <code class="nn">scapy.all</code> <code class="kn">import</code> <code class="n">Ether</code><code class="p">,</code> <code class="n">IP</code><code class="p">,</code> <code class="n">raw</code><code class="p">,</code> <code class="n">TCP</code><code class="p">,</code> <code class="n">UDP</code>

<code class="kn">import</code> <code class="nn">ctypes</code>
<code class="kn">import</code> <code class="nn">unittest</code>


<code class="k">class</code> <code class="nc">XDPExampleTestCase</code><code class="p">(</code><code class="n">unittest</code><code class="o">.</code><code class="n">TestCase</code><code class="p">):</code>
    <code class="n">SKB_OUT_SIZE</code> <code class="o">=</code> <code class="mi">1514</code>  <code class="c1"># mtu 1500 + 14 ethernet size</code>
    <code class="n">bpf_function</code> <code class="o">=</code> <code class="bp">None</code></pre>

<p>After all the needed libraries are imported, we can proceed and create a test case class named <code>XDPExampleTestCase</code>. This test class will contain all of our test cases and a member method (<code>_xdp_test_run</code>) that we will use to do assertions and call <code>bpf_prog_test_run</code>.</p>

<p>In the following code you can see what <code>_xdp_test_run</code> looks like:</p>

<pre data-type="programlisting" data-code-language="python">    <code class="k">def</code> <code class="nf">_xdp_test_run</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">given_packet</code><code class="p">,</code> <code class="n">expected_packet</code><code class="p">,</code> <code class="n">expected_return</code><code class="p">):</code>
        <code class="n">size</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">given_packet</code><code class="p">)</code>

        <code class="n">given_packet</code> <code class="o">=</code> <code class="n">ctypes</code><code class="o">.</code><code class="n">create_string_buffer</code><code class="p">(</code><code class="n">raw</code><code class="p">(</code><code class="n">given_packet</code><code class="p">),</code> <code class="n">size</code><code class="p">)</code>
        <code class="n">packet_output</code> <code class="o">=</code> <code class="n">ctypes</code><code class="o">.</code><code class="n">create_string_buffer</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">SKB_OUT_SIZE</code><code class="p">)</code>

        <code class="n">packet_output_size</code> <code class="o">=</code> <code class="n">ctypes</code><code class="o">.</code><code class="n">c_uint32</code><code class="p">()</code>
        <code class="n">test_retval</code> <code class="o">=</code> <code class="n">ctypes</code><code class="o">.</code><code class="n">c_uint32</code><code class="p">()</code>
        <code class="n">duration</code> <code class="o">=</code> <code class="n">ctypes</code><code class="o">.</code><code class="n">c_uint32</code><code class="p">()</code>
        <code class="n">repeat</code> <code class="o">=</code> <code class="mi">1</code>
        <code class="n">ret</code> <code class="o">=</code> <code class="n">libbcc</code><code class="o">.</code><code class="n">lib</code><code class="o">.</code><code class="n">bpf_prog_test_run</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">bpf_function</code><code class="o">.</code><code class="n">fd</code><code class="p">,</code>
                                           <code class="n">repeat</code><code class="p">,</code>
                                           <code class="n">ctypes</code><code class="o">.</code><code class="n">byref</code><code class="p">(</code><code class="n">given_packet</code><code class="p">),</code>
                                           <code class="n">size</code><code class="p">,</code>
                                           <code class="n">ctypes</code><code class="o">.</code><code class="n">byref</code><code class="p">(</code><code class="n">packet_output</code><code class="p">),</code>
                                           <code class="n">ctypes</code><code class="o">.</code><code class="n">byref</code><code class="p">(</code><code class="n">packet_output_size</code><code class="p">),</code>
                                           <code class="n">ctypes</code><code class="o">.</code><code class="n">byref</code><code class="p">(</code><code class="n">test_retval</code><code class="p">),</code>
                                           <code class="n">ctypes</code><code class="o">.</code><code class="n">byref</code><code class="p">(</code><code class="n">duration</code><code class="p">))</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">assertEqual</code><code class="p">(</code><code class="n">ret</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">assertEqual</code><code class="p">(</code><code class="n">test_retval</code><code class="o">.</code><code class="n">value</code><code class="p">,</code> <code class="n">expected_return</code><code class="p">)</code>

        <code class="k">if</code> <code class="n">expected_packet</code><code class="p">:</code>
            <code class="bp">self</code><code class="o">.</code><code class="n">assertEqual</code><code class="p">(</code>
                <code class="n">packet_output</code><code class="p">[:</code><code class="n">packet_output_size</code><code class="o">.</code><code class="n">value</code><code class="p">],</code> <code class="n">raw</code><code class="p">(</code><code class="n">expected_packet</code><code class="p">))</code></pre>

<p>It takes three arguments:</p>
<dl>
<dt><code>given_packet</code></dt>
<dd>
<p>This is the packet we test our XDP program against; it is the raw packet received by the interface.</p>
</dd>
<dt><code>expected_packet</code></dt>
<dd>
<p>This is the packet we expect to receive back after the XDP program processes it; when the XDP program returns an <code>XDP_DROP</code> or <code>XDP_ABORT</code>, we expect this to be <code>None</code>; in all the other cases, the packet remains the same as <code>given_packet</code> or can be modified.</p>
</dd>
<dt><code>expected_return</code></dt>
<dd>
<p>This is the expected return of the XDP program after processing our <code>given_packet</code>.</p>
</dd>
</dl>

<p>Besides the arguments, the body of this method is simple.<a data-type="indexterm" data-primary="C language" data-secondary="Python conversion to C types with ctypes library" id="idm46623550400248"/> It does conversion to C types using the <em>ctypes</em> library, and then it calls the <code>libbcc</code> equivalent of <code>BPF_PROG_TEST_RUN</code>, <code>libbcc.lib.bpf_prog_test_run</code>, using as test arguments our packets and their metadata. Then it does all of the assertions based on the results from the test call along with the given values.</p>

<p>After we have that function we can basically just write test cases by crafting different packets to test how they behave when passing through our XDP program, but before doing that, we need to do a <code>setUp</code> method for our test.</p>

<p>This part is crucial because the setup does the actual load of our BPF program named <code>myprogram</code> by opening and compiling a source file named <em>program.c</em> (that’s the file where our XDP code will be):</p>

<pre data-type="programlisting" data-code-language="python">    <code class="k">def</code> <code class="nf">setUp</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="n">bpf_prog</code> <code class="o">=</code> <code class="n">BPF</code><code class="p">(</code><code class="n">src_file</code><code class="o">=</code><code class="s-Affix">b</code><code class="s2">"program.c"</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">bpf_function</code> <code class="o">=</code> <code class="n">bpf_prog</code><code class="o">.</code><code class="n">load_func</code><code class="p">(</code><code class="s-Affix">b</code><code class="s2">"myprogram"</code><code class="p">,</code> <code class="n">BPF</code><code class="o">.</code><code class="n">XDP</code><code class="p">)</code></pre>

<p>After the setup is done, the next step is to write the first behavior we want to observe. Without being too imaginative, we want to test that we will drop all TCP packets.</p>

<p>So we craft a packet in <code>given_packet</code>, which is just a TCP packet over IPv4. Then, using our assertion method, <code>_xdp_test_run</code>, we just verify that given our packet, we will get back an <code>XDP_DROP</code> with no return packet:</p>

<pre data-type="programlisting" data-code-language="python">    <code class="k">def</code> <code class="nf">test_drop_tcp</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="n">given_packet</code> <code class="o">=</code> <code class="n">Ether</code><code class="p">()</code> <code class="o">/</code> <code class="n">IP</code><code class="p">()</code> <code class="o">/</code> <code class="n">TCP</code><code class="p">()</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_xdp_test_run</code><code class="p">(</code><code class="n">given_packet</code><code class="p">,</code> <code class="bp">None</code><code class="p">,</code> <code class="n">BPF</code><code class="o">.</code><code class="n">XDP_DROP</code><code class="p">)</code></pre>

<p>Because that is not enough, we also want to explicitly test that all UDP packets are allowed. We then craft two UDP packets, one for <code>given_packet</code> and one for <code>expected_packet</code>, that are essentially the same. In that way we are also testing that UDP packets are not modified while being allowed with <code>XDP_PASS</code>:</p>

<pre data-type="programlisting" data-code-language="python">    <code class="k">def</code> <code class="nf">test_pass_udp</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="n">given_packet</code> <code class="o">=</code> <code class="n">Ether</code><code class="p">()</code> <code class="o">/</code> <code class="n">IP</code><code class="p">()</code> <code class="o">/</code> <code class="n">UDP</code><code class="p">()</code>
        <code class="n">expected_packet</code> <code class="o">=</code> <code class="n">Ether</code><code class="p">()</code> <code class="o">/</code> <code class="n">IP</code><code class="p">()</code> <code class="o">/</code> <code class="n">UDP</code><code class="p">()</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_xdp_test_run</code><code class="p">(</code><code class="n">given_packet</code><code class="p">,</code> <code class="n">expected_packet</code><code class="p">,</code> <code class="n">BPF</code><code class="o">.</code><code class="n">XDP_PASS</code><code class="p">)</code></pre>

<p>To make things a bit more complicated, we decided that this system will then allow TCP packets on the condition that they go to port 9090. When they do, they will also be rewritten to change their destination MAC address to redirect to a specific network interface with address <code>08:00:27:dd:38:2a</code>.</p>

<p>Here’s the test case to do that. The <code>given_packet</code> has <code>9090</code> as a destination port, and we require the <code>expected_packet</code> with the new destination and port <code>9090</code> again:</p>

<pre data-type="programlisting" data-code-language="python">    <code class="k">def</code> <code class="nf">test_transform_dst</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="n">given_packet</code> <code class="o">=</code> <code class="n">Ether</code><code class="p">()</code> <code class="o">/</code> <code class="n">IP</code><code class="p">()</code> <code class="o">/</code> <code class="n">TCP</code><code class="p">(</code><code class="n">dport</code><code class="o">=</code><code class="mi">9090</code><code class="p">)</code>
        <code class="n">expected_packet</code> <code class="o">=</code> <code class="n">Ether</code><code class="p">(</code><code class="n">dst</code><code class="o">=</code><code class="s1">'08:00:27:dd:38:2a'</code><code class="p">)</code> <code class="o">/</code> \
            <code class="n">IP</code><code class="p">()</code> <code class="o">/</code> <code class="n">TCP</code><code class="p">(</code><code class="n">dport</code><code class="o">=</code><code class="mi">9090</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_xdp_test_run</code><code class="p">(</code><code class="n">given_packet</code><code class="p">,</code> <code class="n">expected_packet</code><code class="p">,</code> <code class="n">BPF</code><code class="o">.</code><code class="n">XDP_TX</code><code class="p">)</code></pre>

<p>With plenty of test cases, we now write the entry point for our test program, which will just call <code>unittest.main()</code> that then loads and executes our tests:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">if</code> <code class="nv-Magic">__name__</code> <code class="o">==</code> <code class="s1">'__main__'</code><code class="p">:</code>
    <code class="n">unittest</code><code class="o">.</code><code class="n">main</code><code class="p">()</code></pre>

<p>We have now written tests for our XDP program first! Now that we have the test acting as a specific example of what we want to have, we can write the XDP program that implements it by creating a file named <em>program.c</em>.</p>

<p>Our program is simple. It just contains the <code>myprogram</code> XDP function with the logic we just tested. As always, the first thing we need to do is to include the needed headers. Those headers are self-explainatory. We have a BPF program that will process TCP/IP flowing over Ethernet:</p>

<pre data-type="programlisting" data-code-language="python"><code class="c1">#define KBUILD_MODNAME "kmyprogram"</code>

<code class="c1">#include &lt;linux/bpf.h&gt;</code>
<code class="c1">#include &lt;linux/if_ether.h&gt;</code>
<code class="c1">#include &lt;linux/tcp.h&gt;</code>
<code class="c1">#include &lt;linux/in.h&gt;</code>
<code class="c1">#include &lt;linux/ip.h&gt;</code></pre>

<p>Again, as with the other programs in this chapter, we need to check offsets and fill variables for the three layers of our packet: <code>ethhdr</code>, <code>iphdr</code>, and <code>tcphdr</code>, respectively, for Ethernet, IPv4, and TCP:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nb">int</code> <code class="n">myprogram</code><code class="p">(</code><code class="n">struct</code> <code class="n">xdp_md</code> <code class="o">*</code><code class="n">ctx</code><code class="p">)</code> <code class="p">{</code>
  <code class="nb">int</code> <code class="n">ipsize</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="n">void</code> <code class="o">*</code><code class="n">data</code> <code class="o">=</code> <code class="p">(</code><code class="n">void</code> <code class="o">*</code><code class="p">)(</code><code class="nb">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code>
  <code class="n">void</code> <code class="o">*</code><code class="n">data_end</code> <code class="o">=</code> <code class="p">(</code><code class="n">void</code> <code class="o">*</code><code class="p">)(</code><code class="nb">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code>
  <code class="n">struct</code> <code class="n">ethhdr</code> <code class="o">*</code><code class="n">eth</code> <code class="o">=</code> <code class="n">data</code><code class="p">;</code>
  <code class="n">struct</code> <code class="n">iphdr</code> <code class="o">*</code><code class="n">ip</code><code class="p">;</code>
  <code class="n">struct</code> <code class="n">tcphdr</code> <code class="o">*</code><code class="n">th</code><code class="p">;</code>

  <code class="n">ipsize</code> <code class="o">=</code> <code class="n">sizeof</code><code class="p">(</code><code class="o">*</code><code class="n">eth</code><code class="p">);</code>
  <code class="n">ip</code> <code class="o">=</code> <code class="n">data</code> <code class="o">+</code> <code class="n">ipsize</code><code class="p">;</code>
  <code class="n">ipsize</code> <code class="o">+=</code> <code class="n">sizeof</code><code class="p">(</code><code class="n">struct</code> <code class="n">iphdr</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">data</code> <code class="o">+</code> <code class="n">ipsize</code> <code class="o">&gt;</code> <code class="n">data_end</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">XDP_DROP</code><code class="p">;</code>
  <code class="p">}</code></pre>

<p>Once we have the values we can implement our logic.</p>

<p>The first thing we do is to check whether the protocol is TCP <code>ip-&gt;protocol == IPPROTO_TCP</code>. When it is, we always do an <code>XDP_DROP</code>; otherwise, we do an <code>XDP_PASS</code> for everything else.</p>

<p>In the check for the TCP protocol, we do another control to check whether the destination port is <code>9090</code>, <code>th-&gt;dest == htons(9090)</code>; if it is, we change the destination MAC address at the Ethernet layer and return <code>XDP_TX</code> to bounce the packet through the same NIC:</p>

<pre data-type="programlisting" data-code-language="python">  <code class="k">if</code> <code class="p">(</code><code class="n">ip</code><code class="o">-&gt;</code><code class="n">protocol</code> <code class="o">==</code> <code class="n">IPPROTO_TCP</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">th</code> <code class="o">=</code> <code class="p">(</code><code class="n">struct</code> <code class="n">tcphdr</code> <code class="o">*</code><code class="p">)(</code><code class="n">ip</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>
    <code class="k">if</code> <code class="p">((</code><code class="n">void</code> <code class="o">*</code><code class="p">)(</code><code class="n">th</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code> <code class="o">&gt;</code> <code class="n">data_end</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="n">XDP_DROP</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">th</code><code class="o">-&gt;</code><code class="n">dest</code> <code class="o">==</code> <code class="n">htons</code><code class="p">(</code><code class="mi">9090</code><code class="p">))</code> <code class="p">{</code>
      <code class="n">eth</code><code class="o">-&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mh">0x08</code><code class="p">;</code>
      <code class="n">eth</code><code class="o">-&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="mh">0x00</code><code class="p">;</code>
      <code class="n">eth</code><code class="o">-&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="mh">0x27</code><code class="p">;</code>
      <code class="n">eth</code><code class="o">-&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="mh">0xdd</code><code class="p">;</code>
      <code class="n">eth</code><code class="o">-&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code> <code class="o">=</code> <code class="mh">0x38</code><code class="p">;</code>
      <code class="n">eth</code><code class="o">-&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code> <code class="o">=</code> <code class="mh">0x2a</code><code class="p">;</code>
      <code class="k">return</code> <code class="n">XDP_TX</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="n">XDP_DROP</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">XDP_PASS</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Amazing! Now we can just run our tests:</p>

<pre data-type="programlisting">sudo python test_xdp.py</pre>

<p>The output of it will just report that the three tests passed:</p>

<pre data-type="programlisting">...
--------------------------------
Ran 3 tests in 4.676s

OK</pre>

<p>At this point, breaking things is easier! We can just change the last <code>XDP_PASS</code> to <code>XDP_DROP</code> in <em>program.c</em> and observe what happens:</p>

<pre data-type="programlisting">.F.
======================================================================
FAIL: test_pass_udp (__main__.XDPExampleTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_xdp.py", line 48, in test_pass_udp
    self._xdp_test_run(given_packet, expected_packet, BPF.XDP_PASS)
  File "test_xdp.py", line 31, in _xdp_test_run
    self.assertEqual(test_retval.value, expected_return)
AssertionError: 1 != 2

----------------------------------------------------------------------
Ran 3 tests in 4.667s

FAILED (failures=1)</pre>

<p>Our test failed—the status code did not match, and the test framework reported an error. That’s exactly what we wanted! This is an effective testing framework to write XDP programs with confidence. We now have the ability to make assertions on specific steps and change them accordingly to the behavior that we want to obtain. Then we write the matching code to express that behavior in the form of an XDP program.<a data-type="indexterm" data-primary="Python" data-secondary="unit testing framework, testing XDP programs" data-startref="ix_Pyutst" id="idm46623549792984"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="testing programs" data-tertiary="using Python unit testing framework" data-startref="ix_XDPtstPyUT" id="idm46623549791640"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="testing programs" data-startref="ix_XDPtst" id="idm46623549790184"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>MAC address is short for Media Access Controll address. It is a unique identifier made of two groups of hexadecimal digits that every network interface has and is used in the data link layer (layer 2 in the OSI model) to interconnect devices over technologies like Ethernet, Bluetooth, and WiFi.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="XDP Use Cases"><div class="sect1" id="idm46623550710600">
<h1>XDP Use Cases</h1>

<p>While approaching XDP, it is certainly useful to understand the use cases for which it has been employed by various organizations around the globe.<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="use cases" id="ix_XDPuse"/> This can help you to imagine why using XDP is better than other techniques such as socket filtering or Traffic Control in certain cases.</p>

<p>Let’s begin with a common one: monitoring.</p>








<section data-type="sect2" data-pdf-bookmark="Monitoring"><div class="sect2" id="idm46623549784584">
<h2>Monitoring</h2>

<p>Nowadays, most of the network monitoring systems are implemented either by writing kernel modules or by accessing proc files from user-space.<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="use cases" data-tertiary="monitoring" id="idm46623549783096"/><a data-type="indexterm" data-primary="monitoring with XDP" id="idm46623549781848"/> Writing, distributing, and compiling kernel modules is not a task for everyone; it’s a dangerous operation. They are not easy to maintain and debug either. However, the alternative might be even worse. To obtain the same kind of information, such as how many packets a card received in a second, you’d need to open and part a file, in this case <em>/sys/class/net/eth0/statistics/rx_packets</em>. This might seem like a good idea, but it requires a lot of computing just to obtain some simple information, because using the open syscall is not cheap in some cases.</p>

<p>So, we need a solution that allows us to implement features similar to the ones of a kernel module without having to lose on performance. XDP is perfect for that, because we can use an XDP program to send the data we want to extract in a map. Then the map is consumed by a loader that can store the metrics into a storage backend and apply algorithms to it or plot the results in a graph.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="DDoS Mitigation"><div class="sect2" id="idm46623549779064">
<h2>DDoS Mitigation</h2>

<p>Being able to see packets at the NIC level ensures that any possible packet is intercepted at the first stage, when the system didn’t spend enough computing power yet to understand whether the packets will be useful for the system.<a data-type="indexterm" data-primary="DDoS mitigation with XDP" id="idm46623549777480"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="use cases" data-tertiary="DDoS mitigation" id="idm46623549776808"/> In a typical scenario, a <code>bpf</code> map can instruct an XDP program to <code>XDP_DROP</code> packets from a certain source. That packet list can be generated in user-space after analyzing packets received via another map. Once there’s a match between a packet flowing into the XDP program and an element of the list, the mitigation occurs. The packet is dropped, and the kernel didn’t even need to spend a CPU cycle to handle it. That has the result of making the attacker goal difficult to achieve because, in this case, it wasn’t able to waste any expensive computing resources.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Load Balancing"><div class="sect2" id="idm46623549773896">
<h2>Load Balancing</h2>

<p>An interesting use case for XDP programs, is load balancing; however, XDP can retransmit packets only on the same NIC where they arrived.<a data-type="indexterm" data-primary="load balancing with XDP" id="idm46623549772408"/><a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="use cases" data-tertiary="load balancing" id="idm46623549771704"/> This means that XDP is not the best option to implement a classic load balancer that sits in front of all your servers and forwards traffic to them. However, this does not mean that XDP is not good for this use case. If we move load balancing from an external server to the same machines serving the application, you immediately see how their NICs can be used to do the job.</p>

<p>In that way, we can create a distributed load balancer where each machine hosting the application helps spread the traffic to the appropriate servers.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Firewalling"><div class="sect2" id="idm46623549769176">
<h2>Firewalling</h2>

<p>When people think of firewalling on Linux, they typically think of <code>iptables</code> or <code>netfilter</code>.<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="use cases" data-tertiary="firewalling" id="idm46623549766984"/><a data-type="indexterm" data-primary="firewalling with XDP" id="idm46623549765704"/> With XDP, you can get the same functionality in a completely programmable way directly in the NIC or its driver. Usually, firewalls are expensive machines sitting on top of the network stack or between nodes to control what their communication looks like. When using XDP, however, it’s immediately clear that because XDP programs are very cheap and fast, we could implement the firewalling logic directly into a nodes’ NICs instead of having a set of dedicated machines. A common use case is to have an XDP loader that controls a map with a set of rules changed with a remote procedure call API. The set of rules in the map then is dynamically passed to the XDP programs loaded into every specific machine, to control what it can receive, from who, and in which situation.</p>

<p>This alternative doesn’t just make firewalling less expensive; it allows every node to deploy its own level of firewalling without relying on user-space software or the kernel to do that. When this is deployed using offloaded XDP as the operation mode, we obtain the maximum advantage because the processing is not even done by the main node CPU.<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="use cases" data-startref="ix_XDPuse" id="idm46623549763352"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46623549761848">
<h1>Conclusion</h1>

<p>What great skills you have now! I promise that XDP will help you think about network flows in a completely different way from now on. Having to rely on tools like <code>iptables</code> or other user-space tools when dealing with network packets is often frustrating and slow. XDP is interesting because it is faster as a result of its direct packet processing capabilities, and because you can write your own logic to deal with the network packets. Because all of that arbitrary code can work with maps and interact with other BPF programs, you have an entire world of possible use cases to invent and explore for your own architectures!<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-startref="ix_XDP" id="idm46623549759496"/></p>

<p>Even though it is not about networking, the next chapter returns to a lot of the concepts covered here and in <a data-type="xref" href="ch06.html#linux_networking">Chapter 6</a>. Again, BPF is used to filter some conditions based on a given input and to filter what a program can do. Don’t forget that the <em>F</em> in BPF stands for filter!</p>
</div></section>







</div></section></body></html>