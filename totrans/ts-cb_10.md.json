["```\nObject.keys(person).map(k => person[k])\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\nfunction printPerson(p: Person) {\n  Object.keys(p).forEach((k) => {\n    console.log(k, p[k]);\n//                ^\n// Element implicitly has an 'any' type because expression\n// of type 'string' can't be used to index type 'Person'.\n  });\n}\n```", "```\nconst me = {\n  name: \"Stefan\",\n  age: 40,\n  website: \"https://fettblog.eu\",\n};\n\nprintPerson(me); // All good!\n```", "```\nfunction printPerson(p: Person) {\n  const you: Person = {\n    name: \"Reader\",\n    age: NaN,\n  };\n\n  Object.keys(p).forEach((k) => {\n    console.log(k, you[k]);\n  });\n}\n\nconst me = {\n  name: \"Stefan\",\n  age: 40,\n  website: \"https://fettblog.eu\",\n};\n\nprintPerson(me);\n```", "```\nfunction isKey<T>(x: T, k: PropertyKey): k is keyof T {\n  return k in x;\n}\n\nfunction printPerson(p: Person) {\n  Object.keys(p).forEach((k) => {\n    if (isKey(p, k)) console.log(k, p[k]); // All fine!\n  });\n}\n```", "```\nfunction printPerson(p: Person) {\n  for (let k in p) {\n    console.log(k, p[k]);\n//                 ^\n// Element implicitly has an 'any' type because expression\n// of type 'string' can't be used to index type 'Person'.\n  }\n}\n```", "```\nfunction printPerson(p: Person) {\n  const you: Person = {\n    name: \"Reader\",\n    age: NaN,\n  };\n\n  for (let k in p) {\n    console.log(k, you[k]);\n  }\n}\n\nconst me = {\n  name: \"Stefan\",\n  age: 40,\n  website: \"https://fettblog.eu\",\n};\n\nprintPerson(me);\n```", "```\nfunction printPerson<T extends Person>(p: T) {\n  for (let k in p) {\n    console.log(k, p[k]); // This works\n  }\n}\n```", "```\nfunction printPerson<T extends Person>(p: T) {\n  const you: Person = {\n    name: \"Reader\",\n    age: NaN,\n  };\n  for (let k in p) {\n    console.log(k, you[k]);\n//                 ^\n//  Type 'Extract<keyof T, string>' cannot be used to index type 'Person'\n  }\n}\n```", "```\np.age = you.age\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\nconst ppl: Person[] = await fetch(\"/api/people\").then((res) => res.json());\n```", "```\nconst ppl = await fetch(\"/api/people\").then((res) => res.json()) as Person[];\n```", "```\ninterface Body {\n  readonly body: ReadableStream<Uint8Array> | null;\n  readonly bodyUsed: boolean;\n  arrayBuffer(): Promise<ArrayBuffer>;\n  blob(): Promise<Blob>;\n  formData(): Promise<FormData>;\n  json(): Promise<any>;\n  text(): Promise<string>;\n}\n```", "```\ninterface Body {\n  json(): Promise<unknown>;\n}\n```", "```\nconst ppl: Person[] = await fetch(\"/api/people\").then((res) => res.json());\n//    ^\n// Type 'unknown' is not assignable to type 'Person[]'.ts(2322)\n```", "```\nconst ppl = await fetch(\"/api/people\").then((res) => res.json()) as Person[];\n```", "```\nconst storage = {\n  currentValue: 0\n};\n\nObject.defineProperty(storage, 'maxValue', {\n  value: 9001,\n  writable: false\n});\n\nconsole.log(storage.maxValue); // 9001\n\nstorage.maxValue = 2;\n\nconsole.log(storage.maxValue); // still 9001\n```", "```\nconst storage = {\n  currentValue: 0\n};\n\nObject.defineProperty(storage, 'maxValue', {\n  value: 9001,\n  writable: false\n});\n\nconsole.log(storage.maxValue);\n//                  ^\n// Property 'maxValue' does not exist on type '{ currentValue: number; }'.\n```", "```\nfunction assertIsNumber(val: any) {\n  if (typeof val !== \"number\") {\n    throw new AssertionError(\"Not a number!\");\n  }\n}\n\nfunction multiply(x, y) {\n  assertIsNumber(x);\n  assertIsNumber(y);\n  // at this point I'm sure x and y are numbers\n  // if one assert condition is not true, this position\n  // is never reached\n  return x * y;\n}\n```", "```\nfunction assertIsNumber(val: any) : asserts val is number\n  if (typeof val !== \"number\") {\n    throw new AssertionError(\"Not a number!\");\n  }\n}\n```", "```\nfunction multiply(x, y) {\n  assertIsNumber(x);\n  assertIsNumber(y);\n  // Now also TypeScript knows that both x and y are numbers\n  return x * y;\n}\n```", "```\nfunction defineProperty<\n  Obj extends object,\n  Key extends PropertyKey,\n  PDesc extends PropertyDescriptor>\n  (obj: Obj, prop: Key, val: PDesc) {\n  Object.defineProperty(obj, prop, val);\n}\n```", "```\nfunction defineProperty<\n  Obj extends object,\n  Key extends PropertyKey,\n  PDesc extends PropertyDescriptor>\n   (obj: Obj, prop: Key, val: PDesc):\n     asserts obj is Obj & DefineProperty<Key, PDesc> {\n  Object.defineProperty(obj, prop, val);\n}\n```", "```\ntype DefineProperty<\n  Prop extends PropertyKey,\n  Desc extends PropertyDescriptor> =\n    Desc extends { writable: any, set(val: any): any } ? never :\n    Desc extends { writable: any, get(): any } ? never :\n    Desc extends { writable: false } ? Readonly<InferValue<Prop, Desc>> :\n    Desc extends { writable: true } ? InferValue<Prop, Desc> :\n    Readonly<InferValue<Prop, Desc>>;\n```", "```\ntype InferValue<Prop extends PropertyKey, Desc> =\n  Desc extends { get(): any, value: any } ? never :\n  Desc extends { value: infer T } ? Record<Prop, T> :\n  Desc extends { get(): infer T } ? Record<Prop, T> : never;\n```", "```\ntype InferValue<Prop extends PropertyKey, Desc> =\n  Desc extends { get(): any, value: any } ? never :\n  Desc extends { value: infer T } ? Record<Prop, T> :\n  Desc extends { get(): infer T } ? Record<Prop, T> : never;\n\ntype DefineProperty<\n  Prop extends PropertyKey,\n  Desc extends PropertyDescriptor> =\n    Desc extends { writable: any, set(val: any): any } ? never :\n    Desc extends { writable: any, get(): any } ? never :\n    Desc extends { writable: false } ? Readonly<InferValue<Prop, Desc>> :\n    Desc extends { writable: true } ? InferValue<Prop, Desc> :\n    Readonly<InferValue<Prop, Desc>>\n\nfunction defineProperty<\n  Obj extends object,\n  Key extends PropertyKey,\n  PDesc extends PropertyDescriptor>\n  (obj: Obj, prop: Key, val: PDesc):\n    asserts  obj is Obj & DefineProperty<Key, PDesc> {\n  Object.defineProperty(obj, prop, val)\n}\n```", "```\nconst storage = {\n  currentValue: 0\n};\n\ndefineProperty(storage, 'maxValue', {\n  writable: false, value: 9001\n});\n\nstorage.maxValue; // it's a number\nstorage.maxValue = 2; // Error! It's read-only\n\nconst storageName = 'My Storage';\ndefineProperty(storage, 'name', {\n  get() {\n    return storageName\n  }\n});\n\nstorage.name; // it's a string!\n\n// it's not possible to assign a value and a getter\ndefineProperty(storage, 'broken', {\n  get() {\n    return storageName\n  },\n  value: 4000\n});\n\n// storage is never because we have a malicious\n// property descriptor\nstorage;\n```", "```\n// actions: string[]\nconst actions = [\"CREATE\", \"READ\", \"UPDATE\", \"DELETE\"];\n\nfunction execute(action: string) {\n  if (actions.includes(action)) {\n    // do something with action\n  }\n}\n```", "```\n// Adding const context\n// actions: readonly [\"CREATE\", \"READ\", \"UPDATE\", \"DELETE\"]\nconst actions = [\"CREATE\", \"READ\", \"UPDATE\", \"DELETE\"] as const;\n\nfunction execute(action: string) {\n  if (actions.includes(action)) {\n//                     ^\n// Argument of type 'string' is not assignable to parameter of type\n// '\"CREATE\" | \"READ\" | \"UPDATE\" | \"DELETE\"'.(2345)\n  }\n}\n```", "```\ninterface Array<T> {\n  /**\n * Determines whether an array includes a certain element,\n * returning true or false as appropriate.\n * @param searchElement The element to search for.\n * @param fromIndex The position in this array at which\n *   to begin searching for searchElement.\n */\n  includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface ReadonlyArray<T> {\n  /**\n * Determines whether an array includes a certain element,\n * returning true or false as appropriate.\n * @param searchElement The element to search for.\n * @param fromIndex The position in this array at which\n *   to begin searching for searchElement.\n */\n  includes(searchElement: T, fromIndex?: number): boolean;\n}\n```", "```\ninterface ReadonlyArray<T> {\n  includes(searchElement: any, fromIndex?: number): searchElement is T;\n}\n```", "```\nconst actions = [\"CREATE\", \"READ\", \"UPDATE\", \"DELETE\"] as const;\n\nfunction execute(action: string) {\n  if(actions.includes(action)) {\n    // action: \"CREATE\" | \"READ\" | \"UPDATE\" | \"DELETE\"\n  }\n}\n```", "```\n// type number has no relation to actions at all\nfunction execute(action: number) {\n  if(actions.includes(action)) {\n    // do something\n  }\n}\n```", "```\nfunction includes<T extends U, U>(coll: ReadonlyArray<T>, el: U): el is T {\n  return coll.includes(el as T);\n}\n```", "```\nfunction execute(action: number) {\n  if(includes(actions, action)) {\n//            ^\n// Argument of type 'readonly [\"CREATE\", \"READ\", \"UPDATE\", \"DELETE\"]'\n// is not assignable to parameter of type 'readonly number[]'.\n  }\n}\n```", "```\n// const array: (number | null | undefined)[]\nconst array = [1, 2, 3, undefined, 4, null];\n```", "```\nconst filtered = array.filter((val) => !!val);\n```", "```\n// const array: (number | null | undefined)[]\nconst filtered = array.filter(Boolean);\n```", "```\ninterface Array<T> {\n  filter(predicate: BooleanConstructor): NonNullable<T>[]\n}\n\ninterface ReadonlyArray<T> {\n  filter(predicate: BooleanConstructor): NonNullable<T>[]\n}\n```", "```\n// const array: number[]\nconst filtered = array.filter(Boolean);\n```", "```\ntype Truthy<T> = T extends \"\" | false | 0 | 0n ? never : T;\n\ninterface Array<T> {\n  filter(predicate: BooleanConstructor): Truthy<NonNullable<T>>[];\n}\n\ninterface ReadonlyArray<T> {\n  filter(predicate: BooleanConstructor): Truthy<NonNullable<T>>[];\n}\n\n// as const creates a readonly tuple\nconst array = [0, 1, 2, 3, ``, -0, 0n, false, undefined, null] as const;\n\n// const filtered: (1 | 2 | 3)[]\nconst filtered = array.filter(Boolean);\n\nconst nullOrOne: Array<0 | 1> = [0, 1, 0, 1];\n\n// const onlyOnes: 1[]\nconst onlyOnes = nullOrOne.filter(Boolean);\n```", "```\n<button onClick={() => alert('YES')}>Click me</button>\n\n// Transpiles to:\n\nReact.createElement(\"button\", { onClick: () => alert('YES') }, 'Click me');\n```", "```\n<img src=\"/awesome.jpg\" loading=\"lazy\" alt=\"What an awesome image\" />\n```", "```\nfunction Image({ src, alt }) {\n  // Property 'loading' does not exist.\n  return <img src={src} alt={alt} loading=\"lazy\" />;\n}\n```", "```\n{\n  \"compilerOptions\": {\n    ...\n    /* Type declaration files to be included in compilation. */\n    \"types\": [\"@types/**\"],\n  },\n  ...\n}\n```", "```\nimport \"react\";\n\ndeclare module \"react\" {\n  interface ImgHTMLAttributes<T> extends HTMLAttributes<T> {\n    loading?: \"lazy\" | \"eager\" | \"auto\";\n  }\n}\n```", "```\nimport \"react\";\n\ndeclare module \"react\" {\n  interface ImgHTMLAttributes<T> extends HTMLAttributes<T> {\n    loading?: \"lazy\" | \"eager\" | \"auto\";\n    alt: string;\n  }\n}\n```", "```\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    img: HTMLAttributes & {\n      alt: string;\n      src: string;\n      loading?: \"lazy\" | \"eager\" | \"auto\";\n    };\n  }\n}\n```", "```\nenum ResizeObserverBoxOptions {\n  \"border-box\", \"content-box\", \"device-pixel-content-box\"\n};\n\ndictionary ResizeObserverOptions {\n  ResizeObserverBoxOptions box = \"content-box\";\n};\n\n[Exposed=(Window)]\ninterface ResizeObserver {\n  constructor(ResizeObserverCallback callback);\n  void observe(Element target, optional ResizeObserverOptions options);\n  void unobserve(Element target);\n  void disconnect();\n};\n\ncallback ResizeObserverCallback = void (\n  sequence<ResizeObserverEntry> entries,\n  ResizeObserver observer\n);\n\n[Exposed=Window]\ninterface ResizeObserverEntry {\n  readonly attribute Element target;\n  readonly attribute DOMRectReadOnly contentRect;\n  readonly attribute FrozenArray<ResizeObserverSize> borderBoxSize;\n  readonly attribute FrozenArray<ResizeObserverSize> contentBoxSize;\n  readonly attribute FrozenArray<ResizeObserverSize> devicePixelContentBoxSize;\n};\n\ninterface ResizeObserverSize {\n  readonly attribute unrestricted double inlineSize;\n  readonly attribute unrestricted double blockSize;\n};\n\ninterface ResizeObservation {\n  constructor(Element target);\n  readonly attribute Element target;\n  readonly attribute ResizeObserverBoxOptions observedBox;\n  readonly attribute FrozenArray<ResizeObserverSize> lastReportedSizes;\n};\n```", "```\ntype ResizeObserverBoxOptions =\n  \"border-box\" |\n  \"content-box\" |\n  \"device-pixel-content-box\";\n\ninterface ResizeObserverOptions {\n  box?: ResizeObserverBoxOptions;\n}\n\ninterface ResizeObservation {\n  readonly lastReportedSizes: ReadonlyArray<ResizeObserverSize>;\n  readonly observedBox: ResizeObserverBoxOptions;\n  readonly target: Element;\n}\n\ndeclare var ResizeObservation: {\n  prototype: ResizeObservation;\n  new(target: Element): ResizeObservation;\n};\n\ninterface ResizeObserver {\n  disconnect(): void;\n  observe(target: Element, options?: ResizeObserverOptions): void;\n  unobserve(target: Element): void;\n}\n\nexport declare var ResizeObserver: {\n  prototype: ResizeObserver;\n  new(callback: ResizeObserverCallback): ResizeObserver;\n};\n\ninterface ResizeObserverEntry {\n  readonly borderBoxSize: ReadonlyArray<ResizeObserverSize>;\n  readonly contentBoxSize: ReadonlyArray<ResizeObserverSize>;\n  readonly contentRect: DOMRectReadOnly;\n  readonly devicePixelContentBoxSize: ReadonlyArray<ResizeObserverSize>;\n  readonly target: Element;\n}\n\ndeclare var ResizeObserverEntry: {\n  prototype: ResizeObserverEntry;\n  new(): ResizeObserverEntry;\n};\n\ninterface ResizeObserverSize {\n  readonly blockSize: number;\n  readonly inlineSize: number;\n}\n\ndeclare var ResizeObserverSize: {\n  prototype: ResizeObserverSize;\n  new(): ResizeObserverSize;\n};\n\ninterface ResizeObserverCallback {\n  (entries: ResizeObserverEntry[], observer: ResizeObserver): void;\n}\n```", "```\ndeclare var ResizeObserver: {\n  prototype: ResizeObserver;\n  new(callback: ResizeObserverCallback): ResizeObserver;\n};\n```", "```\ndeclare global { // opening up the namespace\n  var ResizeObserver: { // merging ResizeObserver with it\n    prototype: ResizeObserver;\n    new(callback: ResizeObserverCallback): ResizeObserver;\n  }\n}\n```", "```\n{\n  \"compilerOptions\": {\n    //...\n    \"typeRoots\": [\"@types\", \"./node_modules/@types\"],\n    //...\n  },\n  \"include\": [\"src\", \"@types\"]\n}\n```", "```\ndeclare global {\n  var ResizeObserver: {\n    prototype: ResizeObserver;\n    new(callback: ResizeObserverCallback): ResizeObserver;\n  } | undefined\n}\n```", "```\nif (typeof ResizeObserver !== 'undefined') {\n  const x = new ResizeObserver((entries) => {});\n}\n```", "```\n// like this\nimport \"./Button.css\";\n\n// or this\nimport styles from \"./Button.css\";\n```", "```\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export var sep: string;\n}\n```", "```\ndeclare module '*.css' {\n  // to be done.\n}\n```", "```\ndeclare module '*.css' {\n  interface IClassNames {\n    [className: string]: string\n  }\n  const classNames: IClassNames;\n  export default classNames;\n}\n```", "```\ndeclare module '*.mdx' {\n  let MDXComponent: (props) => JSX.Element;\n  export default MDXComponent;\n}\n```", "```\nimport About from '../articles/about.mdx';\n\nfunction App() {\n  return <>\n    <About/>\n  </>\n}\n```", "```\ndeclare module '*.svg';\n```", "```\n{\n  ...\n  \"compilerOptions\": {\n    ...\n    \"typeRoots\": [\n      \"./node_modules/@types\",\n      \"./@types\"\n    ],\n    ...\n  }\n}\n```"]