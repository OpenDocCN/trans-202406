- en: Chapter 5\. Common Questions and Powerful Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’re more aware of what React does and how it works under the hood,
    let’s explore its practical applications a little deeper in how we write React
    applications. In this chapter, we’ll explore the answers to common React questions
    to boost our fluency around memoization, lazy loading, and performance. Let’s
    get started by talking about memoization.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization with React.memo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memoization is a technique used in computer science to optimize the performance
    of functions by caching their previously computed results. In simple terms, memoization
    stores the output of a function based on its inputs so that if the function is
    called again with the same inputs, it returns the cached result rather than recomputing
    the output. This significantly reduces the time and resources needed to execute
    a function, especially for functions that are computationally expensive or called
    frequently. Memoization relies on function purity, which is defined as a function
    predictably returning the same outputs for given inputs. An example of a pure
    function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `add` function always returns `3` when given arguments `1` and `2`, and
    therefore can be memoized safely. If the function relies on some side effect like
    network communication, it wouldn’t be memoizable. Consider, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Given an input `2`, this function will return a different result every day and
    therefore cannot be memoized. A silly example perhaps, but through it we crudely
    understand basic memoization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoization is particularly useful when dealing with expensive calculations
    or when rendering large lists of items. Consider a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Calling `doHardThing` once might take a few minutes to do the hard thing, but
    calling it a second, third, fourth, or *nth* time doesn’t actually do the hard
    thing but instead returns the stored result. This is the gist of memoization.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of React, memoization can be applied to functional components
    using the `React.memo` component. This function returns a new component that only
    rerenders if its props have changed. Based on [Chapter 4](ch04.html#ch04), ideally
    now we know that to “rerender” means to reinvoke the function component. If wrapped
    in `React.memo`, the function is not called again during reconciliation unless
    its props have changed. By memoizing functional components, we can prevent unnecessary
    rerenders, which can improve the overall performance of our React application.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that React components are functions that are invoked for reconciliation,
    as discussed in [Chapter 4](ch04.html#ch04). React calls function components with
    their props recursively to create a vDOM tree that is then used as the basis of
    two Fiber trees that are reconciled. Sometimes, rendering (that is, invoking a
    component function) can take a long time due to intense computations within the
    function component, or intense computations when applying it to the DOM via placement
    or update effects, as covered in [Chapter 4](ch04.html#ch04). This slows down
    our application and presents a laggy user experience. Memoization is a way to
    avoid this by storing the results of expensive computations and returning them
    when the same inputs are passed to the function, or the same props are passed
    to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why `React.memo` is important, let’s consider a common scenario
    where we have a list of items that need to be rendered in a component. For example,
    let’s say we have a to do list that we want to display in a component, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s compose this component into another component that rerenders on
    user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `App` component, on every keystroke in the `input` field, `TodoList`
    will rerender: the `TodoList` function component will be reinvoked with its props
    on every keystroke. This can and probably will present performance problems, but
    is central to how React works: when a state change occurs in a component, every
    function component from that component down the tree is reinvoked during reconciliation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the to do list is large, and the component is rerendered frequently, this
    can cause a performance bottleneck in the application. One way to optimize this
    component is to memoize it using `React.memo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By wrapping the `TodoList` component with `React.memo`, React will only rerender
    the component if its props have changed. Surrounding state changes will not affect
    it. This means that if the to do list remains the same, the component will not
    rerender, and its cached output will be used instead. This can save significant
    resources and time, especially when the component is complex and the to do list
    is large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another example where we have a complex component with multiple
    nested components that are expensive to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `data` prop changes frequently, this component can be expensive to render,
    especially if the nested components are also complex. We can optimize this component
    using `React.memo` to memoize each nested component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By memoizing each nested component, React will only rerender the components
    that have changed, and the cached outputs will be used for the components that
    have not changed. This can significantly improve the performance of the `Dashboard`
    component and reduce unnecessary rerenders. Thus, we can see that `React.memo`
    is an essential tool for optimizing the performance of functional components in
    React. This can be particularly useful for components that are expensive to render
    or have complex logic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Fluent in React.memo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s briefly walk through how `React.memo` works. When an update happens in
    React, your component is compared with the results of the vDOM returned from its
    previous render. If these results are different—i.e., if its props change—the
    reconciler runs an update effect if the element already exists in the host environment
    (usually the browser DOM), or a placement effect if it doesn’t. If its props are
    the same, the component still rerenders and the DOM is still updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what `React.memo` is good for: avoiding unnecessary rerenders when
    a component’s props are identical between renders. Since we can do this in React,
    it begs the question: how much and how often should we memoize stuff? Surely if
    we memoize every component, our application might be faster overall, no?'
  prefs: []
  type: TYPE_NORMAL
- en: Memoized Components That Still Rerender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`React.memo` performs what is called a *shallow* comparison of the props to
    determine whether they’ve changed or not. The problem with this is while scalar
    types can be compared quite accurately in JavaScript, nonscalars cannot. To have
    a high-quality discussion, let’s break down briefly what scalar and nonscalar
    types are, and how they behave in comparison operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Scalars (primitive types)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scalar types, also known as primitive types, are foundational. These types represent
    singular, indivisible values. Unlike more complex data structures like arrays
    and objects, scalars do not possess properties or methods, and they are immutable
    by nature. This means that once a scalar value is set, it cannot be altered without
    creating a completely new value. JavaScript has several scalar types, including
    numbers, strings, booleans, and others like symbols, BigInts, undefined, and null.
    Each of these types serves a unique purpose. For instance, while numbers are self-explanatory,
    symbols provide a way to create unique identifiers, and undefined and null allow
    developers to represent the absence of a value in different contexts. When comparing
    scalar values, we’re often interested in their actual content or value.
  prefs: []
  type: TYPE_NORMAL
- en: Nonscalars (reference types)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving beyond the simplicity of scalars, we encounter nonscalar or reference
    types. These types don’t store data, but rather a reference or a pointer to where
    the data is stored in memory. This distinction is crucial because it impacts how
    these types are compared, manipulated, and interacted with in code. In JavaScript,
    the most common nonscalar types are objects and arrays. Objects allow us to store
    structured data with key-value pairs, while arrays provide ordered collections.
    Functions, too, are considered reference types in JavaScript. A key characteristic
    of nonscalars is that multiple references can point to the same memory location.
    This means that modifying data through one reference can impact other references
    pointing to the same data. When it comes to comparison, nonscalar types are compared
    by their memory reference, not by their content. This can sometimes lead to unexpected
    results for those not familiar with this nuance. For example, two arrays with
    identical content but different memory locations will be considered unequal when
    compared using the strict equality operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this array comparison, the arrays, objects, and other nonscalar types
    are compared *by reference*: as in, does the lefthand-side array’s reference to
    its position in the computer’s memory equal the righthand-side’s memory location.
    This is why the comparison returns `false`. The same is true for objects. What
    we’re doing with the object comparison is creating two different objects in memory
    on the lefthand side and the righthand side—of course they’re not equal, they’re
    two different objects that live in two different places in memory! They just have
    the same content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why `React.memo` can be tricky to use. Consider a functional component
    `List` that takes in an array of items as a prop and renders them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine using this component within a parent component and passing a new
    array instance each time the parent renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Every time the `Increment` button is clicked, the `ParentComponent` rerenders.
    Even though the items passed to `List` haven’t changed in value, a new array instance
    is created, with `['apple', 'banana', 'cherry']` each time. Since `React.memo`
    performs a shallow comparison of props, it will see this new array instance as
    a different prop from the previous render’s array, causing the `List` component
    to rerender unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we could memoize the array using the `useMemo` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, the array is only created once and retains the same reference across rerenders,
    preventing unnecessary rerenders of the `List` component.
  prefs: []
  type: TYPE_NORMAL
- en: This example underscores the importance of understanding reference comparisons
    when working with `React.memo` and nonscalar props. If not used cautiously, we
    could inadvertently introduce performance issues instead of optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.memo` often also gets circumvented quite commonly by another nonscalar
    type: functions. Consider the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While the props don’t appear to change or depend on enclosing state with props
    `name`, `url`, and `onChange` all having constant values, if we compare the props
    we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, this is because we’re comparing functions *by reference*. Remember
    that as long as props differ, our component will not be memoized. We can combat
    this by using the `useCallback` hook inside `MemoizedAvatar`’s parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we can be confident that `onAvatarChange` will never change unless one of
    the things in its dependency array (second argument) changes, like the current
    user ID. With this, our memoization is fully complete and reliable. This is the
    recommended way to memoize components that have functions as props.
  prefs: []
  type: TYPE_NORMAL
- en: Great! This now means that our memoized components will never unnecessarily
    rerender. Right? Wrong! There’s one more thing we need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a Guideline, Not a Rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React uses `React.memo` as a hint to its reconciler that we don’t want our components
    to rerender if their props stay the same. The function just hints to React. Ultimately,
    what React does is up to React. `React.memo` is consistent about avoiding rerenders
    that cascade from the parent, and that’s its one purpose. It’s not a guarantee
    that a component will never rerender. To echo back to the beginning of this book,
    React is intended to be a declarative abstraction of our user interface where
    we describe *what* we want, and React figures out the best way *how* to do it.
    `React.memo` is a part of this.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.memo` does not guarantee consistently avoided rerenders, because React
    may decide to rerender a memoized component for various reasons, such as changes
    to the component tree or changes to the global state of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand this more, let’s take a look at some code snippets from React’s
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the implementation of `React.memo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, `React.memo` returns a new object that represents the
    memoized component. The object has a `$$typeof` property that identifies it as
    a memoized component, a `type` property that references the original component,
    and a `compare` property that specifies the comparison function to use for memoization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at how `React.memo` is used in the reconciler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a breakdown of what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Initial check
  prefs: []
  type: TYPE_NORMAL
- en: The function `updateMemoComponent` takes several parameters, including the current
    and work-in-progress Fibers, the component, new props, and render lanes (which,
    as discussed, indicate priority and timing of updates). The initial check (`if
    (current === null)`) determines if this is the initial render of the component.
    If `current` is `null`, the component is being mounted for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Type and fast path optimization
  prefs: []
  type: TYPE_NORMAL
- en: It then checks if the component is a simple function component and eligible
    for a fast path update by checking `Component.compare` and `Component.defaultProps`.
    If these conditions are met, it sets the work-in-progress Fiber’s tag to `SimpleMemoComponent`,
    indicating a simpler component type that can be updated more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Development mode checks
  prefs: []
  type: TYPE_NORMAL
- en: In development mode (`__DEV__`), the function performs additional checks, like
    validating prop types and warning about deprecated features (like `defaultProps`
    in function components).
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Creating new Fiber
  prefs: []
  type: TYPE_NORMAL
- en: If it’s the initial render, a new Fiber is created with `createFiberFromTypeAndProps`.
    This Fiber represents the unit of work for React’s renderer. It sets up references
    and returns the child (new Fiber).
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Updating existing Fiber
  prefs: []
  type: TYPE_NORMAL
- en: If the component is updating (`current !== null`), it performs similar development
    mode checks. It then checks if the component needs an update by comparing the
    old props with new props using a shallow comparison (`shallowEqual`) or a custom
    comparison function, if provided.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Bailing out of update
  prefs: []
  type: TYPE_NORMAL
- en: If the props are equal and the ref hasn’t changed, it can bail out of the update
    using `bailoutOnAlreadyFinishedWork`, which means no further rendering work is
    needed for this component.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Updating work-in-progress Fiber
  prefs: []
  type: TYPE_NORMAL
- en: If an update is needed, the function flags the work-in-progress Fiber with `PerformedWork`
    and creates a new work-in-progress child Fiber based on the current child, but
    with new props.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, this function is responsible for determining whether a memoized
    component (a component wrapped with `React.memo`) needs to be updated or if it
    can skip updating to optimize performance. It handles both the initial render
    and updates, performing different operations based on whether it’s creating a
    new Fiber or updating an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what parts of this function tell us about the conditions under which
    a `React.memo` component would rerender or not:'
  prefs: []
  type: TYPE_NORMAL
- en: No previous render (initial mount)
  prefs: []
  type: TYPE_NORMAL
- en: If `current === null`, the component is being mounted for the first time and
    thus it cannot skip rendering. A new Fiber is created and returned for the component
    to render.
  prefs: []
  type: TYPE_NORMAL
- en: Simple function component optimization
  prefs: []
  type: TYPE_NORMAL
- en: If the component is a simple function component (without default props and without
    a custom comparison function), React will optimize it to a `SimpleMemoComponent`.
    This allows React to use a fast path for updates because it can assume that the
    component only depends on its props and nothing else, and a shallow comparison
    is sufficient to determine if it should update.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison function
  prefs: []
  type: TYPE_NORMAL
- en: If there is a previous render, the component will only update if the comparison
    function returns `false`. This comparison function can be custom if supplied or
    default to a shallow equality check (`shallowEqual`). If the comparison function
    determines that the new props are equal to the previous props and the `ref` is
    the same, the component will not rerender, and the function will bail out of the
    rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: Default props and prop types in development
  prefs: []
  type: TYPE_NORMAL
- en: In development mode (`__DEV__`), there are checks for `defaultProps` and `propTypes`.
    The use of `defaultProps` will trigger a warning in development mode because future
    versions of React plan to deprecate `defaultProps` on function components. Prop
    types are checked for validation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Bailout conditions
  prefs: []
  type: TYPE_NORMAL
- en: If there are no scheduled updates or context changes (`hasScheduledUpdateOr​Con⁠text`
    is `false`), the comparison function deems the old and new props to be equal,
    and the `ref` hasn’t changed, then the function will return the result of `bailoutOnAlreadyFinishedWork`,
    effectively skipping the rerender.
  prefs: []
  type: TYPE_NORMAL
- en: However, if there are scheduled context updates, the component will rerender—even
    if its props don’t change. This is because context updates are considered to be
    outside the scope of the component’s props. State changes, context changes, and
    scheduled updates can also trigger rerenders.
  prefs: []
  type: TYPE_NORMAL
- en: Performed work flag
  prefs: []
  type: TYPE_NORMAL
- en: If an update is necessary, the `PerformedWork` flag is set on the `workInProgress`
    Fiber, indicating that this Fiber has performed work during the current render.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `React.memo` components will not rerender if the comparison between the
    old and new props (using either the custom provided comparison function or the
    default shallow comparison) determines that the props are equal, and there are
    no updates scheduled due to state or context changes. If the props are determined
    to be different, or if there are state or context changes, the component will
    rerender.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization with useMemo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`React.memo` and the `useMemo` hook are both tools for memoization, but with
    very different purposes. `React.memo` memoizes an entire component to keep it
    from rerendering. `useMemo` memoizes a specific calculation inside a component,
    to avoid expensive recalculations and preserve a consistent reference for the
    result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s briefly delve into `useMemo`. Consider a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This component can potentially slow down our application due to its sorting
    operation. The sorting operation has a time complexity that’s typically O(n log
    n) for average and worst-case scenarios. If our list has, say, one million people,
    it can involve significant computational overhead on each render. In computer
    science terms, the sorting operation’s efficiency is largely determined by the
    number of items, n, hence the O(n log n) time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: To optimize this, we would use the `useMemo` hook to avoid sorting the people
    array on every render, especially when the `unsortedPeople` array hasn’t changed.
  prefs: []
  type: TYPE_NORMAL
- en: The current implementation of the component presents a significant performance
    issue. Every time the state updates, which happens on every keystroke inside the
    input field, the component rerenders. If a name is entered with 5 characters and
    our list contains 1,000,000 people, the component will rerender 5 times. For each
    render, it will sort the list, which involves on the order of 1,000,000 × log(1,000,000)
    operations due to the time complexity of sorting. This amounts to many millions
    of operations just for entering a five-character name! Fortunately, this inefficiency
    can be mitigated using the `useMemo` hook, ensuring that the sorting operation
    is only executed when the `unsortedPeople` array changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite that code snippet a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There! Much better! We wrapped the value of `sortedPeople` in a function that
    was passed to the first argument of `useMemo`. The second argument we pass to
    `useMemo` represents an array of values that, if changed, re-sorts the array.
    Since the array contains only `unsortedPeople`, it will only sort the array once,
    and every time the list of people changes—not whenever someone types in the name
    input field. This is a great example of how to use `useMemo` to avoid unnecessary
    rerenders.
  prefs: []
  type: TYPE_NORMAL
- en: useMemo Considered Harmful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it might be tempting to wrap all variable declarations inside a component
    with `useMemo`, this isn’t always beneficial. `useMemo` is particularly valuable
    for memoizing computationally expensive operations or maintaining stable references
    to objects and arrays. For scalar values, such as strings, numbers, or booleans,
    using `useMemo` is typically unnecessary. This is because these scalar values
    are passed and compared by their actual value in JavaScript, not by reference.
    So every time you set or compare a scalar value, it’s the actual value you’re
    working with, not a reference to a memory location that might change.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, loading and executing the `useMemo` function may be more expensive
    than the actual operation it’s trying to optimize. For instance, consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `doubledCount` variable is memoized using the `useMemo`
    hook. However, since `count` is a scalar value, it’s not necessary to memoize
    it. Instead, we can simply compute the doubled count directly in the JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, `doubledCount` is no longer memoized, but the component still performs
    the same computation with less memory consumption and overhead since we’re not
    importing and invoking `useMemo`. This is a good example of how to avoid using
    `useMemo` when it’s not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What may present an additional performance problem, however, is that we’re re-creating
    the `onClick` handler on the button on every render since it’s passed by memory
    reference. But is this really a problem? Let’s look closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some suggest that we should memoize the `onClick` handler using `useCallback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Should we, though? The answer is no. There is no benefit in having the increment
    function memoized here, since `<button>` is a browser-native element and not a
    React function component that can be called. Also, there are no further components
    below it that React would continue on to render.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in React, built-in or “host” components (like `div`, `button`, `input`,
    etc.) are treated slightly differently from custom components when it comes to
    props, including function props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what happens with function props on built-in components:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct pass-through
  prefs: []
  type: TYPE_NORMAL
- en: When you pass a function prop (such as an `onClick` handler) to a built-in component,
    React passes it through directly to the actual DOM element. It does not create
    any wrappers or perform any additional work on these functions.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of `onClick` and event-based props, React uses event delegation
    for handling events, not direct attachment of event handlers to DOM elements.
    This means that when you provide an `onClick` handler to a built-in React element
    like a `<button>`, React does not attach the `onClick` handler directly to the
    button’s DOM node. Instead, React listens for all events at the top level using
    a single event listener. This is attached to the root of the document (or the
    root of the React application), and it relies on event bubbling to catch events
    that originate from individual elements. This approach is efficient because it
    reduces the memory footprint and the initial setup time for event handlers. Rather
    than having to attach and manage individual handlers for each instance of an event
    on each element, React can handle all events of a particular type (like clicks)
    with a single real event listener. When an event occurs, React maps it to the
    appropriate component and calls the handlers you’ve defined in a way that follows
    the expected propagation path. So even though the events are being caught at the
    top level, they will behave as if they were attached directly to the specific
    elements. This event delegation system is mostly transparent when you’re writing
    a React application; you define `onClick` handlers the same way you would if they
    were being attached directly. Under the hood, however, React is optimizing event
    handling for you.
  prefs: []
  type: TYPE_NORMAL
- en: Rerendering behavior
  prefs: []
  type: TYPE_NORMAL
- en: Built-in components do not rerender due to changes in function props unless
    they are part of a higher component that has rerendered. For example, if a parent
    component rerenders and provides a new function as a prop to a built-in component,
    the built-in component will rerender because its props have changed. However,
    this rerender is typically fast and not something you generally need to optimize
    unless profiling shows it to be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: No virtual DOM comparison for functions
  prefs: []
  type: TYPE_NORMAL
- en: The virtual DOM comparison for built-in components is based on the identity
    of the function props. If you pass an inline function (like `onClick={() => do​Something()}`),
    it will be a new function each time the component renders, but React doesn’t do
    a deep comparison on functions to detect changes. The new function simply replaces
    the old one on the DOM element, and thus we get performance savings with built-in
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Event pooling
  prefs: []
  type: TYPE_NORMAL
- en: React uses event pooling for event handlers to reduce memory overhead. The event
    object that is passed to your event handlers is a synthetic event that is pooled,
    meaning that it is reused for different events to reduce the garbage collection
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: This is a strong contrast to custom components. For custom components, if you
    pass a new function as a prop, the child component may rerender if it’s a pure
    component or if it has memoization applied (such as with `React.memo`), because
    it detects a change in props. But for host components, React doesn’t provide such
    built-in memoization because it would add overhead that isn’t beneficial in most
    cases. The actual DOM elements that React outputs don’t have a memoization concept;
    they simply update with the new function reference when the properties change.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this means that while you should be cautious about passing new
    function instances to custom components that might be expensive to rerender, doing
    so with built-in components is less of a concern. However, it’s always good to
    be mindful of how often you’re creating new functions and passing them around,
    as unnecessary function creation can lead to garbage collection churn, which might
    be a performance issue in very high-frequency update scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, `useCallback` isn’t helping here at all, and is in fact worse than useless:
    not only does it provide no value, it also adds overhead to our application. This
    is because `useCallback` has to be imported, invoked, and passed the dependencies,
    and then it has to compare the dependencies to see if the function should be recomputed.
    All of this has runtime complexity that can hurt our app more than help it.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s a good example for `useCallback` then? `useCallback` is particularly
    useful when you have a component that is likely to rerender often and you pass
    a callback down to a child component, especially if that child component is optimized
    with `React.memo` or `shouldComponentUpdate`. The memoization of the callback
    ensures that the child component does not rerender unnecessarily when the parent
    component renders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example where `useCallback` is beneficial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExpensiveComponent` is a child component that is wrapped in `React.memo`,
    which means it will only rerender if its props change. This is a case where you
    want to avoid passing a new function instance on each render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyComponent` has two pieces of state: `count` and `otherState`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`incrementCount` is a callback that updates `count`. It is memoized with `use​Call⁠back`,
    which means the `ExpensiveComponent` will not rerender when `MyComponent` rerenders
    due to a change in `otherState`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `doSomethingElse` function changes `otherState` but doesn’t need to be memoized
    with `useCallback` because it is not passed down to `Expensive​Compo⁠nent` or
    any other child.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using `useCallback`, we ensure that `ExpensiveComponent` does not rerender
    unnecessarily when `MyComponent` rerenders for reasons unrelated to `count`. This
    is beneficial in cases where the rendering of the child component is a heavy operation
    and you want to optimize performance by reducing the number of renders.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good example of how to use `useCallback` to avoid unnecessary rerenders,
    ensuring that the function that is passed down to an expensive component is only
    created once, and it retains the same reference across rerenders. This prevents
    unnecessary rerenders of the expensive component. `useCallback` is essentially
    `useMemo` for functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re not using `useMemo` here anywhere, mainly because the component is stateless.
    This is good! But what if we have some input that triggers rerenders like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re recomputing `new Date()` on every keystroke. Let’s fix this with
    `useMemo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is good because `today` will be a reference to the same object every time
    the component rerenders with the same props, and we assume the component will
    always rerender in the same day.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s a slight edge case here if the user’s clock lapses at midnight while
    they’re using this component, but this is a rare edge case that we can ignore
    for now. Of course, we do better when there’s real production code involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example facilitates a bigger question: should we wrap `isAdult`’s value
    in `useMemo`? What happens if we do? The answer is that we shouldn’t because `isAdult`
    is a scalar value that requires no computation besides memory allocation. We *do*
    call `.getFullYear` a bunch of times, but we trust the JavaScript engine and the
    React runtime to handle the performance for us. It’s a simple assignment with
    no further computation, like sorting, filter, or mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we should not use `useMemo` because it is more likely to slow
    our app down than speed it up because of the overhead of `useMemo` itself, including
    importing it, calling it, passing in the dependencies, and then comparing the
    dependencies to see if the value should be recomputed. All of this has runtime
    complexity that can hurt our app more than help it. Instead, we assign and trust
    React to intelligently rerender our component when necessary with its own optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Our applications are now enjoying performance benefits of faster rerenders even
    in the face of heavy computations—but can we do more? In the next section, let’s
    take a look at how all of the stuff we’ve covered so far probably will not even
    matter in a few years based on some exciting things the React team is working
    on to automatically consider memoization for us, enabling us to *forget* about
    the details and instead focus on our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Forget About All of This
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Forget is a new toolchain aimed at automating memoization in React applications,
    potentially making hooks like `useMemo` and `useCallback` redundant. By automatically
    handling memoization, React Forget helps optimize component rerendering, improving
    both user experience (UX) and developer experience (DX). This automation shifts
    React’s rerendering behavior from object identity changes to semantic value changes
    without deep comparisons, thereby enhancing performance. Introduced at React Conf
    2021, React Forget is not yet generally available at the time of writing, but
    is in use in production at Meta across Facebook, Instagram, and more, and has
    “exceeded expectations” internally so far.
  prefs: []
  type: TYPE_NORMAL
- en: If there is enough interest, we will cover React Forget in a future edition
    of this book. Please let us know by posting about it on social media (especially
    𝕏, formerly Twitter) and tagging the author, *@tejaskumar_*.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our applications grow, we accumulate a lot of JavaScript. Our users then
    download these massive JavaScript bundles—sometimes going into the double digits
    on megabytes—only to use a small portion of the code. This is a problem because
    it slows down our users’ initial load time, and it also slows down our users’
    subsequent page loads because they have to download the entire bundle again, especially
    when we don’t have access to the servers that serve these bundles and cannot add
    the requisite headers for caching and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main problems with shipping too much JavaScript is that it can slow
    down page load times. JavaScript files are typically larger than other types of
    web assets, such as HTML and CSS, and require more processing time to execute.
    This can lead to longer page load times, especially on slower internet connections
    or older devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code snippet that loads a large JavaScript
    file on page load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the *large.js* file is loaded in the `<head>` of the page,
    which means that it will be executed before any other content on the page. This
    can lead to slower page load times, especially on slower internet connections
    or older devices. A common solution to this problem is to load JavaScript files
    asynchronously using the `async` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the *large.js* file is loaded asynchronously using the `async`
    attribute. This means that it will be downloaded in parallel with other resources
    on the page, which can help improve page load times.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with shipping too much JavaScript is that it can increase data
    usage. JavaScript bundles are typically larger than other types of web assets,
    which means that they require more data to be transferred over the network. This
    can be a problem for users with limited data plans or slow internet connections,
    as it can lead to increased costs and slower page load times.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate these issues, we can take several steps to reduce the amount of
    JavaScript that is shipped to users. One approach is to use code splitting to
    load only the JavaScript that is needed for a particular page or feature. This
    can help reduce page load times and data usage by only loading the necessary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code snippet that uses code splitting to
    load only the JavaScript that is needed for a particular page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `import` function is used to asynchronously load the *large.js*
    file only when it is needed. This can help reduce page load times and data usage
    by only loading the necessary code.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to use lazy loading to defer the loading of noncritical
    JavaScript until after the page has loaded. This can help reduce page load times
    and data usage by loading noncritical code only when it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code snippet that uses lazy loading to
    defer the loading of noncritical JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `import` function is used to asynchronously load the *non-critical.js*
    file only when the “Load more content” button is clicked. This can help reduce
    page load times and data usage by loading noncritical code only when it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, React has a solution that makes this even more straightforward:
    lazy loading using `React.lazy` and `Suspense`. Let’s take a look at how we can
    use these to improve our application’s performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading is a technique that allows us to load a component only when it’s
    needed, like with the dynamic import in the preceding example. This is useful
    for large applications that have many components that are not needed on the initial
    render. For example, if we have a large application with a collapsible sidebar
    that has a list of links to other pages, we might not want to load the full sidebar
    if it’s collapsed on first load. Instead, we can load it only when the user toggles
    the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `<Sidebar />` is 22 MB of JavaScript. This is a lot of JavaScript
    to download, parse, and execute, and it’s not necessary on the initial render
    if the sidebar is collapsed. Instead, we can use `React.lazy` to lazy load the
    component only if `showSidebar` is true. As in, only if we need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Instead of *statically importing* `./Sidebar`, we *dynamically* import it—that
    is, we pass a function to `lazy` that returns a promise that resolves to the imported
    module. A dynamic import returns a promise because the module may not be available
    immediately. It may need to be downloaded from the server first. React’s `lazy`
    function, which triggers the import, is never called unless the underlying component
    (in this case, `Sidebar`) is to be rendered. This way, we avoid shipping the 22
    MB sidebar until we actually *render* `<Sidebar />`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have also noticed another new import: `Suspense`. We use `Suspense`
    to wrap the component in the tree. `Suspense` is a component that allows us to
    show a fallback component while the promise is resolving (read: as the sidebar
    is downloading). In the snippet, we’re showing a fallback component that is a
    lightweight version of the heavy sidebar while the heavy sidebar is downloading.
    This is a great way to provide immediate feedback to the user while the sidebar
    is loading.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the user clicks the button to toggle the sidebar, they’ll see a “skeleton
    UI” that they can orient themselves around while the sidebar is loaded and rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Greater UI Control with Suspense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Suspense works like a try/catch block. You know how you can `throw` an
    exception from literally anywhere in your code, and then catch it with a `catch`
    block somewhere else—even in a different module? Well, Suspense works in a similar
    (but not exactly the same) way. You can place lazy-loaded and asynchronous primitives
    anywhere in your component tree, and then catch them with a `Suspense` component
    anywhere above it in the tree, even if your Suspense boundary is in a completely
    different file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, we have the power to choose where we want to show the loading
    state for our 22 MB sidebar. For example, we can hide the entire application while
    the sidebar is loading—which is a pretty bad idea because we block our entire
    app’s information from the user just for a sidebar—or we can show a loading state
    for the sidebar only. Let’s take a look at how we can do the former (even though
    we shouldn’t) just to understand `Suspense`’s capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By wrapping the entire component in `Suspense`, we render the `fallback` until
    all asynchronous children (promises) are resolved. This means that the entire
    application is hidden until the sidebar is loaded. This can be useful if we want
    to wait until everything’s ready to reveal the user interface to the user, but
    in this case it might not be the best idea because the user is left wondering
    what’s going on and can’t interact with the application at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why we should only use `Suspense` to wrap the components that need
    to be lazy loaded, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The Suspense boundary is a very powerful primitive that can remedy layout shift
    and make user interfaces more responsive and intuitive. It’s a great tool to have
    in your arsenal. Moreover, if high-quality skeleton UI is used in the `fallback`,
    we can further guide our users to understand what’s going on and what to expect
    while our lazy-loaded components load, thereby orienting them to the interface
    they’re about to interact with before it’s ready. Taking advantage of all of this
    is a great way to improve our applications’ performance and fluently get the most
    out of React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at another interesting question that many React developers
    ask: when should we use `useState` versus `useReducer`?'
  prefs: []
  type: TYPE_NORMAL
- en: useState Versus useReducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React exposes two hooks for managing state: `useState` and `useReducer`. Both
    of these hooks are used to manage state in a component. The difference between
    the two is that `useState` is a hook that is better suited to manage a single
    piece of state, whereas `useReducer` is a hook that manages more complex state.
    Let’s take a look at how we can use `useState` to manage state in a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we’re using `useState` to manage a single piece of state:
    `count`. But what if our state’s a little more complex?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see that our state is a little more complex. We have a `count`, a
    `name`, and an `age`. We can increment the `count` by clicking the button, which
    sets the state to *a new object* that has the same properties as the previous
    state, but with the `count` incremented by `1`. This is a very common pattern
    in React. The problem with it is that it can raise the possibility of bugs. For
    example, if we don’t carefully spread the old state, we might accidentally overwrite
    some of the state’s properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fun fact: `useState` uses `useReducer` internally. You can think of `useState`
    as a higher-level abstraction of `useReducer`. In fact, you can reimplement `useState`
    with `useReducer` if you wish!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Seriously, you’d just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the same example, but implemented with `useReducer` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, some would say this is a tad more verbose than `useState`, and many would
    agree, but this is to be expected whenever anyone goes a level lower in an abstraction
    stack: the lower the abstraction, the more verbose the code. After all, abstractions
    are intended to replace complex logic with syntax sugar in most cases. So since
    we can do the same thing with `useState` as we can with `useReducer`, why don’t
    we just always use `useState` since it’s simpler?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three large benefits to using `useReducer` to answer this question:'
  prefs: []
  type: TYPE_NORMAL
- en: It separates the logic of updating state from the component. Its accompanying
    `reducer` function can be tested in isolation, and it can be reused in other components.
    This is a great way to keep our components clean and simple, and embrace the *single
    responsibility principle*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can test the reducer like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, we’re testing two scenarios: one where the increment action
    is dispatched to the reducer, and one where an unknown action is dispatched.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first test, we’re creating an initial state object with a count value
    of `0`, and an increment action object. We’re then expecting the count value in
    the resulting state object to be incremented to `1`. We use the `toEqual` matcher
    to compare the expected and actual state objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the second test, we’re creating an initial state object with a count value
    of `0`, and an unknown action object. We’re then expecting the resulting state
    object to be the same as the initial state object. We use the `toBe` matcher to
    compare the expected and actual state objects, since we’re testing for reference
    equality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By testing our reducer in this way, we can ensure that it behaves correctly
    and produces the expected output when given different input scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our state and the way it changes is always explicit with `useReducer`, and some
    would argue that `useState` can obfuscate the overall state update flow of a component
    through layers of JSX trees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useReducer` is an *event sourced* model, meaning it can be used to model events
    that happen in our application, which we can then keep track of in some type of
    audit log. This audit log can be used to replay events in our application to reproduce
    bugs or to implement *time-travel debugging*. It also enables some powerful patterns
    like undo/redo, optimistic updates, and analytics tracking of common user actions
    across our interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `useReducer` is a great tool to have in your arsenal, it’s not always
    necessary. In fact, it’s often overkill for most use cases. So when should we
    use `useState` versus `useReducer`? The answer is that it depends on the complexity
    of your state. But hopefully with all of this information, you can make a more
    informed decision about which one to use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Immer and Ergonomics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immer, a popular React library, is particularly useful when dealing with complex
    state management in your applications. When your state shape is nested or complex,
    traditional state updating methods can become verbose and error prone. Immer helps
    to manage such complexities by allowing you to work with a mutable draft state
    while ensuring the produced state is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: In a React application, state management is commonly handled using the `useState`
    or `useReducer` hooks. While `useState` is suitable for simple state, `useReducer`
    is more suited for complex state management, and that’s where Immer shines the
    most.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with `useReducer`, the reducer function you provide is expected
    to be pure and always return a new state object. This can lead to verbose code
    when dealing with nested state objects. However, by integrating Immer with `useReducer`
    through `useImmerReducer` from the use-immer library, you can write reducers that
    appear to mutate the state directly, while actually operating on a draft state
    provided by Immer. This way, you get to write simpler and more intuitive reducer
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `useImmerReducer` simplifies the reducer function significantly,
    allowing direct assignments to update the nested state properties, which would
    have required `spread` or `Object.assign` operations in a traditional reducer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, Immer is not just limited to `useReducer`. You can also use it
    with `useState` whenever you have a complex state object and want to ensure immutability
    when updating the state. Immer provides a `produce` function that you can use
    to create your next state based on the current state and a set of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the `updateName` function, Immer’s `produce` function takes the current `state`
    and a function that receives a `draft` of the state. Inside this function, you
    can work with the draft as if it were mutable, while Immer ensures that the produced
    state is a new immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: Immer’s ability to simplify state updates, especially in complex or nested state
    structures, makes it a great companion to React’s state management hooks, facilitating
    cleaner, more maintainable, and less error-prone code.
  prefs: []
  type: TYPE_NORMAL
- en: Powerful Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software design patterns are commonly used solutions to recurring problems in
    software development. They provide a way to solve problems that have been encountered
    and solved by other developers, saving time and effort in the software development
    process. They are often expressed as templates or guidelines for creating software
    that can be used in different situations. Software design patterns are typically
    described using a common vocabulary and notation, which makes them easier to understand
    and communicate among developers. They can be used to improve the quality, maintainability,
    and efficiency of software systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software design patterns are important for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns provide reusable solutions to common problems, which can save
    time and effort in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Standardization
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns provide a standard way of solving problems, which makes it easier
    for developers to understand and communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns provide a way to structure code that is easy to maintain and
    modify, which can improve the longevity of software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns provide efficient solutions to common problems, which can improve
    the performance of software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, software design patterns naturally arrive over time in response to
    real-world needs. These patterns solve specific problems that engineers experience,
    and find their way into an “engineer’s arsenal” of tools to use in different use
    cases. *One pattern is not inherently worse than the other*; each has its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most patterns help us identify ideal levels of abstraction: how we can write
    code that ages like fine wine instead of accruing extra state and configuration
    to the point where it becomes unreadable and/or unmaintainable. This is why a
    common consideration when picking a design pattern is *control*: how much of it
    we give to users versus how much of it our program handles.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s dive in to some popular React patterns, following a rough chronological
    order of when these patterns emerged.
  prefs: []
  type: TYPE_NORMAL
- en: Presentational/Container Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s common to see a React design pattern that is a combination of two components:
    a *presentational component* and a *container component*. The presentational component
    renders the UI, and the container component handles the state of the UI. Consider
    a counter. This is how a counter would look when implementing this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have two components: `PresentationalCounter` (a presentational
    component) and `ContainerCounter` (a container component). The presentational
    component renders the UI, and the container component handles the state.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is this a thing? This pattern is quite useful because of the principle of
    *single responsibility*, which highly encourages us to separate concerns in our
    applications, enabling them to scale better by being more modular, reusable, and
    even testable. Instead of having a component be responsible for how it should
    look and how it should work, we split these concerns. The result? `PresentationalCounter`
    can be passed between other stateful containers and preserve the look we want,
    while `ContainerCounter` can be replaced with another stateful container and preserve
    the functionality we want.
  prefs: []
  type: TYPE_NORMAL
- en: We can also unit test `ContainerCounter` in isolation, and instead visually
    test (using Storybook or similar) `PresentationalCounter` in isolation. We can
    also assign engineers or engineering teams more comfortable with visual work to
    `PresentationalCounter`, while assigning engineers who prefer data structures
    and algorithms to `ContainerCounter`.
  prefs: []
  type: TYPE_NORMAL
- en: We have so many more options because of this decoupled approach. For these reasons,
    the container/presentational component pattern has gained quite a lot of popularity
    and is still in use today. However, the introduction of hooks allowed for far
    more convenience in adding statefulness to components without needing a container
    component to provide that state.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, in many cases the container/presentational pattern can be replaced
    with hooks. Although we can still leverage this pattern, even with React Hooks,
    it can easily be considered overengineering in smaller applications.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to [Wikipedia’s definition of a higher-order function](https://oreil.ly/Ywx56):'
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics and computer science, a higher-order function (HOF) is a function
    that does at least one of the following: takes one or more functions as arguments
    (i.e., a procedural parameter, which is a parameter of a procedure that is itself
    a procedure), returns a function as its result.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the JSX world, a higher-order component (HOC) is basically this: a component
    that takes another component as an argument and returns a new component that is
    the result of the composition of the two. HOCs are great for *shared behavior
    across components that we’d rather not repeat*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, many web applications need to request data from some data source
    asynchronously. Loading and error states are often inevitable, but we sometimes
    forget to account for them in our software. If we manually add `loading`, `data`,
    and `error` props to our components, the chances that we miss a few get even higher.
    Let’s consider a basic to do list app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This app has a few problems. We don’t account for loading or error states.
    Let’s fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Yikes. This got pretty unruly, pretty fast. Moreover, *this solves the problem
    for just one component*. Do we need to add these pieces of state (i.e., loading,
    data, and error) to each component that interacts with a foreign data source?
    This is a *cross-cutting concern*, and exactly where HOCs shine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of repeating this loading, error, and data pattern for each component
    that talks to a foreign data source asynchronously, we can use an HOC factory
    to deal with these states for us. Let’s consider a `withAsync` HOC factory that
    remedies this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`withAsync` will deal with loading and error states, and render any component
    when data is available. Let’s look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, when any `Component` is passed into `withAsync`, we get a new component
    that renders appropriate pieces of information based on its props. This changes
    our initial component into something more workable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'No more nested ternaries, and the `TodoList` itself can show appropriate information
    depending on whether it’s loading, has an error, or has data. Since the `withAsync`
    HOC factory deals with this cross-cutting concern, we can wrap any component that
    talks to an external data source with it and get back a new component that responds
    to `loading` and `error` props. Consider a blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, both `Post` and `Comments` use the `withAsync` HOC pattern,
    which returns a newer version of `BasicPost` and `BasicComments`, respectively,
    that now responds to `loading` and `error` props. The behavior for this cross-cutting
    concern is centrally managed in `withAsync`’s implementation, so we account for
    loading and error states “for free” just by using the HOC pattern here.
  prefs: []
  type: TYPE_NORMAL
- en: However, similar to presentational and container components, HOCs are often
    also discarded in favor of hooks, since hooks provide similar benefits with added
    convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Composing HOCs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Composing multiple HOCs together is a common pattern in React, which allows
    developers to mix and match functionalities and behaviors across components. Here’s
    an example of how you might compose multiple HOCs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have two HOCs, `withLogging` and `withUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, say you want to compose these two HOCs together. One way to do this is
    to nest them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'However, nested HOC calls can be difficult to read and maintain, especially
    as the number of HOCs increases. Imagine this in your application over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Yuck! A better approach is to create a utility function that composes multiple
    HOCs together into a single HOC. Such a utility function might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this `compose` function, `reduceRight` is used to apply each HOC from right
    to left to the `WrappedComponent`. This way, you can list your HOCs in a flat
    list, which is easier to read and maintain. The `compose` function is a common
    utility in functional programming, and libraries like Redux provide their own
    `compose` utility function for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'To revisit our previous yucky example with our new `compose` utility, it would
    look more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Isn’t that better? Less indentation, more readability, and easier maintenance.
    Each HOC in the chain wraps the component produced by the previous HOC, adding
    its own behavior to the mix. This way, you can build up complex components from
    simpler components and HOCs, each focused on a single concern. This makes your
    code more modular, easier to understand, and easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: HOCs versus hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the introduction of hooks, HOCs have become less popular. Hooks provide
    a more convenient way to add functionality to components, and they also solve
    some of the problems that HOCs have. For example, HOCs can cause issues with ref
    forwarding, and they can also cause unnecessary rerenders when used incorrectly.
    [Table 5-1](#table5-1) shows a little bit of a detailed comparison between the
    two.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Comparison of HOCs versus hooks
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | HOCs | Hooks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Code reuse** | Excellent for sharing logic across multiple components.
    | Ideal for extracting and sharing logic within a component or across similar
    components. |'
  prefs: []
  type: TYPE_TB
- en: '| **Rendering logic** | Can control rendering of wrapped component. | Do not
    affect rendering directly, but can be used within functional components to manage
    side effects related to rendering. |'
  prefs: []
  type: TYPE_TB
- en: '| **Prop manipulation** | Can inject and manipulate props, providing additional
    data or functions. | Cannot inject or manipulate props directly. |'
  prefs: []
  type: TYPE_TB
- en: '| **State management** | Can manage and manipulate state outside of the wrapped
    component. | Designed to manage local state within functional components. |'
  prefs: []
  type: TYPE_TB
- en: '| **Lifecycle methods** | Can encapsulate lifecycle logic related to the wrapped
    component. | `useEffect` and other hooks can handle lifecycle events within functional
    components. |'
  prefs: []
  type: TYPE_TB
- en: '| **Ease of composition** | Can be composed together, but may result in “wrapper
    hell” if not managed well. | Easily composable and can be used alongside other
    hooks without adding layers of components. |'
  prefs: []
  type: TYPE_TB
- en: '| **Ease of testing** | Testing can be more complex due to additional wrapper
    components. | Generally easier to test as they can be isolated easier than HOCs.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Type safety** | With TypeScript, can be tricky to type correctly, especially
    with deeply nested HOCs. | Better type inference and easier to type with TypeScript.
    |'
  prefs: []
  type: TYPE_TB
- en: '[Table 5-1](#table5-1) provides a side-by-side comparison of HOCs and hooks,
    showcasing their respective strengths and use cases. While HOCs are still a useful
    pattern, hooks are generally preferred for most use cases due to their simplicity
    and ease of use.'
  prefs: []
  type: TYPE_NORMAL
- en: From this table, we can observe that HOCs and hooks are pivotal in React for
    sharing logic across components, yet they cater to slightly different use cases.
    HOCs excel in sharing logic across multiple components and are particularly adept
    at controlling the rendering of the wrapped component and manipulating props,
    providing additional data or functions to components. They can manage state outside
    of the wrapped component and encapsulate lifecycle logic related to the wrapped
    component. However, they can lead to a “wrapper hell” if not managed well, especially
    when many HOCs are nested together. This nesting can also make testing more complex,
    and type safety with TypeScript can become tricky, especially with deeply nested
    HOCs.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, hooks are ideal for extracting and sharing logic within a
    component or across similar components without adding extra layers of components,
    thus avoiding the “wrapper hell” scenario. Unlike HOCs, hooks do not affect rendering
    directly and cannot inject or manipulate props directly. They are designed to
    manage local state within functional components and handle lifecycle events using
    the `useEffect` Hook, among others. Hooks promote ease of composition, and are
    generally easier to test as they can be isolated easier than HOCs. Moreover, when
    used with TypeScript, hooks provide better type inference and are easier to type,
    thus potentially reducing bugs related to type errors.
  prefs: []
  type: TYPE_NORMAL
- en: While both HOCs and hooks provide mechanisms to reuse logic, hooks offer a more
    direct and less complicated approach to managing state, lifecycle events, and
    other React features within functional components. On the flip side, HOCs provide
    a more structured way to inject behavior into components, which can be beneficial
    in larger codebases or in codebases that have not yet adopted hooks. Each has
    its own set of advantages, and the choice between using HOCs or hooks would largely
    depend on the specific requirements of your project and the team’s familiarity
    with these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we think of any React HOCs that we use fairly frequently? Yes, we can!
    `React.memo` is one that we just covered in this chapter and is indeed an HOC!
    Let’s look at another one: `React.forwardRef`. This is an HOC that forwards a
    ref to a child component. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re using `React.forwardRef` to forward a ref to the `FancyInput`
    component. This allows us to access the input element’s `focus` method in the
    parent component. This is a common pattern in React, and it’s a great example
    of how HOCs can be used to solve problems that are difficult to solve with regular
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Render Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we’ve already talked about JSX expressions, a common pattern is to have
    props that are functions that receive component-scoped state as arguments to facilitate
    code reuse. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Notice how there’s a prop called `render` that receives a function as a value.
    This prop even outputs some JSX markup that’s actually rendered. But why? Turns
    out `WindowSize` does some magic internally to compute the size of a user’s window,
    and then calls `props.render` to return the structure we declare, making use of
    enclosing state to render the window size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at `WindowSize` to understand this a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'From this example, we can see that `WindowSize` uses an event listener to store
    some stuff in state on every resize, but the component itself is headless: it
    has no opinions about what UI to present. Instead, it yields control to whatever
    parent is rendering it and calls the *render prop* it’s supplied, effectively
    inverting control to its parent for the rendering job.'
  prefs: []
  type: TYPE_NORMAL
- en: This helps a component that depends on the window size for rendering receive
    this information without duplicating the `useEffect` blocks and keeps our code
    a little bit more DRY (Don’t Repeat Yourself). This pattern is no longer as popular
    and has since been effectively replaced with React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Children as a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `children` is a prop, some have preferred to drop the `render` prop name
    altogether and instead just use `children`. This would change the use of `WindowSize`
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Some React authors prefer this because it’s truer to the intent of the code:
    `WindowSize` in this case looks a bit like a React Context, and whatever we display
    tends to feel like children that consume this context. Still, React Hooks eliminate
    the need for this pattern altogether, so maybe proceed with caution.'
  prefs: []
  type: TYPE_NORMAL
- en: Control Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Control Props pattern in React is a strategic approach to state management
    that expands upon the concept of controlled components. It provides a flexible
    mechanism for determining how state is managed within a component. To understand
    this, let’s first understand controlled components.
  prefs: []
  type: TYPE_NORMAL
- en: Controlled components are components that do not maintain their own internal
    state. Instead, they receive their current value as a prop from a parent component,
    which is the single source of truth for their state. When the state should change,
    controlled components notify the parent using callback functions, typically `onChange`.
    The parent is thus responsible for managing the state and updating the value of
    the controlled component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a controlled `<input>` element looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The Control Props pattern takes the principle of controlled components further
    by allowing a component to either be controlled externally by props or manage
    its own state internally, providing optional external control. A component following
    the Control Props pattern accepts both the state value and a function to update
    that state as props. This dual capability enables the parent to exert control
    over the child component’s state if it chooses to do so, but it also allows the
    child component to operate independently if not controlled.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the Control Props pattern is a toggle button that can either
    be controlled by its parent or manage its own state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the `Toggle` component, `isOn` represents the internal state, while `on`
    is the external control prop. The component can operate in a controlled mode if
    the `on` prop is provided by the parent. If not, it falls back to its internal
    state, `isOn`. The `onToggle` prop is a callback that allows the parent component
    to respond to state changes, providing the parent with the opportunity to synchronize
    its own state with the state of the `Toggle`.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern enhances component flexibility, offering both controlled and uncontrolled
    modes of operation. It allows the parent to be in charge when necessary, while
    also letting the component retain autonomy over its own state when not explicitly
    controlled.
  prefs: []
  type: TYPE_NORMAL
- en: Prop Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We often need to bundle a whole bunch of props together. For example, when
    creating drag-and-drop user interfaces, there are quite a few props to manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onDragStart`'
  prefs: []
  type: TYPE_NORMAL
- en: To tell the browser what to do when a user starts dragging an element
  prefs: []
  type: TYPE_NORMAL
- en: '`onDragOver`'
  prefs: []
  type: TYPE_NORMAL
- en: To identify a dropzone
  prefs: []
  type: TYPE_NORMAL
- en: '`onDrop`'
  prefs: []
  type: TYPE_NORMAL
- en: To execute some code when an element is dropped on this element
  prefs: []
  type: TYPE_NORMAL
- en: '`onDragEnd`'
  prefs: []
  type: TYPE_NORMAL
- en: To tell the browser what to do when an element is done being dragged
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, data/elements cannot be dropped in other elements by default. To allow
    an element to be dropped on another, we must prevent the default handling of the
    element. This is done by calling the `event.preventDefault` method for the `onDragOver`
    event for a possible dropzone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these props usually go together, and since `onDragOver` usually defaults
    to `event => { event.preventDefault(); moreStuff(); }`, we can collect these props
    together and reuse them in various components, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we have a React component we expect to behave like a dropzone, we can
    use the prop collection on it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is the prop collection pattern, and it makes a number of props reusable.
    This is often quite widely used in the accessibility space to include a number
    of `aria-*` props on accessible components. One problem that’s still present though
    is that if we write a custom `onDragOver` prop and override the collection, we
    lose the `event.prevent​De⁠fault` call that we get out of the box using the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can cause unexpected behavior, removing the ability to drop a component
    on `Dropzone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, we can fix this using prop getters.
  prefs: []
  type: TYPE_NORMAL
- en: Prop getters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prop getters essentially compose prop collections with custom props and merge
    them. From our example, we’d like to preserve the `event.preventDefault` call
    in the `droppableProps` collection’s `onDragOver` handler, while also adding a
    custom `alert("Dragged!");` call to it. We can do this using prop getters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll change the `droppableProps` collection to a prop getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, nothing has changed besides where we once exported a prop collection,
    we now export a function that returns a prop collection. This is a prop getter.
    Since this is a function, it can receive arguments—like a custom `onDragOver`.
    We can compose this custom `onDragOver` with our default one, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the prop getter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This custom `onDragOver` will compose into our default `onDragOver`, and both
    things will happen: `event.preventDefault()` and `alert("Dragged!")`. This is
    the prop getter pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Compound Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we have accordion components like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This component is intended to render a list similar to this, except *only one
    item* can be open at a given time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`One`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Two`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Three`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The inner workings of this component would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we wanted a custom separator between items `Two` and `Three`? What
    if we wanted the third link to be red or something? We’d probably resort to some
    type of hack like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'But that wouldn’t look the way we want. So we’d probably do more hacks on our
    current hack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is that code we’d be proud of? I’m not sure. This is why we need *compound
    components*: they allow us to have a grouping of interconnected, distinct components
    that share state, but are atomically renderable, giving us more control of the
    element tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This accordion, expressed using the compound components pattern, would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we decide to explore how this pattern can be implemented in React, we might
    consider two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: With `React.cloneElement` on the children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With React Context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.cloneElement` is considered a legacy API, so let’s pursue doing this
    with React Context. First, we’ll start with a context that each part of the accordion
    can read from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our `Accordion` component will just provide context to its children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create discrete `AccordionItem` components that consume and respond
    to this context as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve got multiple parts for our `Accordion` making it a compound
    component, our usage of the `Accordion` goes from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of this is that we have far more control, while each `AccordionItem`
    is aware of the larger state of `Accordion`. So now, if we wanted to include a
    horizontal line between items `Two` and `Three`, we could break out of the `map`
    and go more manual if we wanted to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could do something more hybrid, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the benefit of compound components: they invert control of rendering
    to the parent, while preserving contextual state awareness among children. The
    same approach could be used for a tab UI, where tabs are aware of the current
    tab state while having varying levels of element nesting.'
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit is that this pattern promotes separation of concerns, which
    helps applications scale significantly better over time.
  prefs: []
  type: TYPE_NORMAL
- en: State Reducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The state reducer pattern in React was invented and popularized by Kent C.
    Dodds (*@kentcdodds*), one of the most prominent and proficient engineers and
    educators in the React space, and a true world-renowned expert in the field. This
    pattern offers a powerful way to create flexible and customizable components.
    Let’s illustrate this concept with a real-world example: a toggle button component.
    This example will demonstrate how a basic toggle component can be enhanced to
    allow consumers to customize its state logic, disabling the toggle on certain
    days of the week for some business reason.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start with a basic toggle component using the `useReducer` hook.
    The component maintains its own state, determining whether the toggle is in an
    `On` or `Off` position. The initial state is set to `false`, indicating the `Off`
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the state reducer pattern, the `Toggle` component is modified
    to accept a `stateReducer` prop. This prop allows the component’s internal state
    logic to be customized or extended. The component’s `internalDispatch` function
    combines the internal reducer logic with the external reducer provided by the
    `stateReducer` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'From this code snippet, we can see that the `stateReducer` prop is used to
    customize the component’s internal state logic. The `stateReducer` function is
    called with the current state and the action object; however, we add an extra
    property of metadata to the action: `changes`. This `changes` property contains
    the next state of the component, which is calculated by the internal reducer.
    This allows the external reducer to access the next state of the component and
    make decisions based on that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the `Toggle` component can be utilized with custom behavior based
    on this pattern. In the following example, the `App` component uses the `Toggle`
    but provides a custom `stateReducer`. This reducer contains logic that prevents
    the toggle from being turned off on Wednesdays because Wednesday in this app’s
    location is a universal “no off” day. This illustrates how the state reducer pattern
    allows for flexible modification of component behavior without changing the component
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: With this example, we see the power of the state reducer pattern in creating
    highly flexible and reusable components. By allowing external logic to integrate
    with the internal state management of a component, we can cater to a wide range
    of behaviors and use cases, enhancing both the utility and versatility of the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Whew! What a chapter! Let’s wrap things up and summarize what we learned.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve discussed various aspects of React, including
    memoization, lazy loading, reducers, and state management. We’ve explored the
    advantages and potential drawbacks of different approaches to these topics and
    how they can impact the performance and maintainability of React applications.
  prefs: []
  type: TYPE_NORMAL
- en: We started by discussing memoization in React and its benefits for optimizing
    component rendering. We looked at the `React.memo` function and how it can be
    used to prevent unnecessary rerenders of components. We also examined some potential
    issues with memoization, such as stale state and the need to carefully manage
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we talked about lazy loading in React and how it can be used to defer
    the loading of certain components or resources until they are actually needed.
    We looked at the `React.lazy` and `Suspense` components and how they can be used
    to implement lazy loading in a React application. We also discussed the trade-offs
    of lazy loading, such as increased complexity and potential performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to reducers and how they can be used for state management in
    React. We explored the differences between `useState` and `useReducer`, and discussed
    the advantages of using a centralized reducer function for managing state updates.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout our conversation, we used code examples from our own implementations
    to illustrate the concepts we discussed. We explored how these examples work under
    the hood and how they can impact the performance and maintainability of React
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Through the use of code examples and in-depth explanations, we gained a deeper
    understanding of these topics and how they can be applied in real-world React
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s ask ourselves a few questions to test our understanding of the concepts
    we learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is memoization in React, and how can it be used to optimize component rendering?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using `useReducer` for state management in React,
    and how does it differ from `useState`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can lazy loading be implemented in a React application using the `React.lazy`
    and `Suspense` components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some potential issues that can arise when using memoization in React,
    and how can they be mitigated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the `useCallback` hook be used to memoize functions passed as props
    to components in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at React on the server side—diving into serve-side
    rendering, its benefits and trade-offs, hydration, frameworks, and more. See you
    there!
  prefs: []
  type: TYPE_NORMAL
