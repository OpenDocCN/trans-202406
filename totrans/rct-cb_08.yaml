- en: Chapter 8\. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at various techniques for testing your React applications.
    In general, we’ve found that it is a bad idea to be too prescriptive about the
    precise mix of tests you should have. A good guiding principle is to follow these
    two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Never write code unless you have a failing test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a test passes the first time you run it, delete it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two rules will help you build code that works while avoiding creating
    redundant tests that provide little value.
  prefs: []
  type: TYPE_NORMAL
- en: We have found that early in a project, it is easier to write more browser-based
    tests. These tests tend to be higher-level and help capture the principal business
    requirements for an application. Later, when the application’s architecture starts
    to emerge and stabilize, it becomes easier to write more unit tests of individual
    components. They are faster to write and quicker to run, and once you have a stable
    structure to your code, you will not need to update them continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s worth loosening the definition of what a test *is*. When you
    are working on layout code, whose primary value is visual, you might consider
    a Storybook story to be a “test.” The assertion is done by your eye, looking at
    the component as you create. Of course, this kind of test will not automatically
    pick up regression failures, but we present a technique in a recipe that will
    allow you to turn these visual checks into actual automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: If you write tests *before* you write code, you will find that tests are tools
    for design. They will become executable examples of how you would like your application
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, if you write tests *after* you write the code, they will be simply
    artifacts. Pieces of code that you must slavishly create because they feel like
    the sorts of things a professional developer should write.
  prefs: []
  type: TYPE_NORMAL
- en: 'We focus on four tools in this chapter: the React Testing Library, Storybook,
    the Selenium library, and Cypress.'
  prefs: []
  type: TYPE_NORMAL
- en: The React Testing Library is an excellent way of creating very detailed unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Storybook is a gallery tool that we have looked at previously. We include it
    in this chapter because a gallery is a set of code examples, which is also what
    tests are. You will find ways of using Storybook as part of your testing/development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium is one of the most established libraries for testing your application
    in a real browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, what is quickly becoming our favorite tool for testing: Cypress. Cypress
    is similar to Selenium in that it runs inside a browser. But it includes a whole
    host of additional features, such as test replays, generated videos of test runnings,
    and a significantly simpler programming model. If you use only one tool from this
    chapter, let it be Cypress.'
  prefs: []
  type: TYPE_NORMAL
- en: Use the React Testing Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways that you can test a React application. Early on in a project,
    when you are still defining an application’s essential purpose and function, you
    might choose to create tests in some very high-level form, such as [Cucumber tests](https://cucumber.io).
    If you are looking at some isolated piece of the system (such as creating and
    maintaining a data item), you might want to create functional tests using a tool
    like Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: But if you are deep into the detail of creating a single component, then you
    will probably want to create unit tests. *Unit tests* are so-called because they
    attempt to test a single piece of code as an isolated unit. While it’s debatable
    whether *unit test* is the correct term for testing components (which often contain
    subcomponents and so are not isolated), it’s the name usually applied to tests
    of components that you can test outside of a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do you unit test React components? There have historically been several
    approaches. Early unit tests relied on rendering the component into an HTML string,
    which required minimal testing infrastructure, but there were multiple downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling re-renders when the component state changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making assertions on HTML elements that the test must parse from the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test UI interactions, you need to mock the event model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was not long before developers created libraries to take care of the details
    of each of these problems.
  prefs: []
  type: TYPE_NORMAL
- en: However, tests created in this way lacked the reality of tests created in browsers.
    The subtleties of the interaction between the virtual *Document Object Model*
    (DOM) and the browser DOM were lost. Often subcomponents were not rendered to
    reduce the complexity of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The result was that React applications often had few unit tests. Developers
    would refactor their code to move complex logic into easily testable JavaScript
    functions. Developers would have to test anything more complex with a real browser,
    leading to slower tests. Because they were slow, developers would be discouraged
    from testing too many scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: So how can you unit test React components realistically without the overhead
    of launching the entire app and running the tests in a real browser?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Testing Library by Kent C. Dodds attempts to avoid the issues with previous
    unit testing libraries by providing a standalone implementation of the DOM. As
    a result, tests can render a React component to a virtual DOM, which can then
    be synchronized with the Testing Library’s DOM and create a tree of HTML elements
    that behave like they would in a real browser.
  prefs: []
  type: TYPE_NORMAL
- en: You can inspect the elements in the same way that you would within a browser.
    They have the same attributes and properties. You can even pass keystrokes to
    `input` fields and have them behave the same way as fields in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you created your application with `create-react-app`, you should already
    have the Testing Library installed. If not, you can install it from the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These three libraries will allow us to unit test components.
  prefs: []
  type: TYPE_NORMAL
- en: The Testing Library allows us to render components using the DOM implementation
    in `@testing-library/jest-dom`. The User Event library (`@testing-library/user-event`)
    simplifies interacting with the generated DOM elements. This User Event library
    allows us to click the buttons and type into the fields of our components.
  prefs: []
  type: TYPE_NORMAL
- en: To show how to unit test components, we will need an application to test. We’ll
    be using the same application through much of this chapter. When the application
    opens, it asks the user to perform a simple calculation. The application will
    say if the user’s answer is right or wrong (see [Figure 8-1](ch08_split_000.xhtml#ch08_image_1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. The application under test
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The main component of the application is called `App`. We can create a unit
    test for this component by writing a new file called *App.test.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a Jest test, with a single scenario that tests that the
    `App` component will tell us we’ve won if we enter the correct answer. We’ve put
    placeholder comments for the structure of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by rendering the `App` component. We can do this by importing
    the component and passing it to the Testing Library’s `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we pass actual *JSX* to the `render` function, which means that
    we could, if we wanted, test the component’s behavior when passed different sets
    of properties.
  prefs: []
  type: TYPE_NORMAL
- en: For the next part of the test, we’ll need to enter the correct answer. To do
    that, we must first know what the correct answer is. The puzzle is always a randomly
    generated multiplication, so we can capture the numbers from the page and then
    type the product into the `Guess` field.^([1](ch08_split_001.xhtml#idm46634397841208))
  prefs: []
  type: TYPE_NORMAL
- en: We will need to look at the elements generated by the `App` component. The `render`
    function returns an object that contains the elements and a set of functions for
    filtering them. Instead of using this returned value, we’ll instead use the Testing
    Library’s `screen` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of the `screen` object as the contents of the browser window.
    It allows us to find elements within the page so that we can interact with them.
    For example, if we want to find the input field labeled `Guess`, we can do it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter methods in the `screen` object typically begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getBy...`'
  prefs: []
  type: TYPE_NORMAL
- en: If you know that the DOM contains a single instance of the matching element
  prefs: []
  type: TYPE_NORMAL
- en: '`queryBy...`'
  prefs: []
  type: TYPE_NORMAL
- en: If you know there are zero or one elements that match
  prefs: []
  type: TYPE_NORMAL
- en: '`getAllBy...`'
  prefs: []
  type: TYPE_NORMAL
- en: If you know there are one or more matching elements (returns an array)
  prefs: []
  type: TYPE_NORMAL
- en: '`queryAllBy...`'
  prefs: []
  type: TYPE_NORMAL
- en: To find zero or more elements (returns an array)
  prefs: []
  type: TYPE_NORMAL
- en: These methods will throw an exception if they find more or fewer elements than
    they were expecting. There are also `findBy...` and `findAllBy...` methods that
    are asynchronous versions of `getBy...` and `getAllBy...` that return promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of these filter method types, you can search the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name ends | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByLabelText` | Finds field by label |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByPlaceHolderText` | Finds field with placeholder text |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByText` | With matching text content |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByDisplayValue` | Finds by value |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByAltText` | Matching the alt attribute |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByTitle` | Matching the title attribute |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByRole` | Finds by aria role |'
  prefs: []
  type: TYPE_TB
- en: '| `...ByTestId` | Finds by data-testid attribute |'
  prefs: []
  type: TYPE_TB
- en: There are nearly 50 ways to find elements within the page. However, you might
    have noticed that *none* of them use a CSS selector to track an element down,
    which is deliberate. The Testing Library restricts the number of ways that you
    can find elements within the DOM. It doesn’t allow you to, for example, find elements
    by class name to reduce the fragility of the test. Class names are frequently
    used for cosmetic styling and are subject to frequent change.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is still possible to track down elements with selectors, by using the `container`
    returned by the render method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But this approach is considered poor practice. If you use the Testing Library,
    it’s probably best to follow the standard approach and find elements based upon
    their content or role.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one small concession to this approach made by the filter functions:
    the `...ByTestId` functions. If you have no practical way of finding an element
    by its content, you can always add a `data-testid` attribute to the relevant tag.
    That is useful for the test we are currently writing because we need to find two
    numbers displayed on the page. And these numbers are randomly generated, so we
    don’t know their content ([Figure 8-2](ch08_split_000.xhtml#ch08_image_2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. We cannot find the numbers by content because we won’t know what
    they are
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So, we make a small amendment to the code and add test IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can start to implement the next part of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the text for each of the numbers, and we have the `input` element.
    We now need to type the correct number into the field and then submit the answer.
    We’ll do this with the `@testing-library/user-event` library. The User Event library
    simplifies the process of generating JavaScript events for HTML elements. You
    will often see the User Event library imported with the alias `user`, which is
    because you can think of the calls to the User Event library as the actions a
    user is making:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to assert that we have won. We can write this simply by looking
    for some element containing the word *won*:^([2](ch08_split_001.xhtml#idm46634397514504))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This assertion will work because `getByText` throws an exception if it does
    not find precisely one matching element.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure about the current HTML state at some point in a test, try
    adding `screen.getByTestId('NONEXISTENT')` into the code. The exception that’s
    thrown will show you the current HTML.
  prefs: []
  type: TYPE_NORMAL
- en: However, the test is liable to break if your application is running slowly.
    This is because the `get...` and `query...` functions look at the existing state
    of the DOM. If the result takes a couple of seconds to appear, the assertion will
    fail. For this reason, it’s a good idea to make some assertions asynchronous.
    It makes the code a little more complex, but the test will be more stable when
    running against slow-moving code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find...` methods are asynchronous versions of the `get...` methods, and
    the Testing Library’s `waitFor` will allow you to rerun code for a period of time.
    By combining the two functions, we can create the final part of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unit tests should run quickly, but if for some reason your test takes longer
    than five seconds, you will need to pass a second `timeout` value in milliseconds
    to the `it` function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with different teams, we found that early on in a project, the developers
    would write unit tests for each component. But over time, they would write fewer
    and fewer unit tests. Eventually, they might even delete unit tests if they required
    too much maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: This happens partly because unit tests are more abstract than browser tests.
    They are doing the same kinds of things as browser tests, but they do them invisibly.
    When they are interacting with components, you don’t *see* them.
  prefs: []
  type: TYPE_NORMAL
- en: A second reason is that teams often see tests as deliverable artifacts within
    a project. The team might even have builds that fail if unit tests don’t cover
    a certain percentage of the code.
  prefs: []
  type: TYPE_NORMAL
- en: These issues generally disappear if developers write tests *before* they write
    code. If you write the tests first, a line at a time, you will have a much better
    grasp of the current state of HTML. If you stop seeing tests as development artifacts
    and start to look at them as tools for designing your code, they stop becoming
    a time-consuming burden and become tools that make your work easier.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing when writing code is that you begin with a failing test.
    In the early days of a project, that might be a failing browser test. As the project
    matures and the architecture stabilizes, you should create more and more unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Use Storybook for Render Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tests are simply examples that you can execute. Consequently, tests have a lot
    in common with component gallery systems like Storybook. Both tests and galleries
    are examples of components running in particular circumstances. Whereas a test
    will make assertions with code, a developer will make an *assertion* of a library
    example by looking at it and checking that it appears as expected. In both galleries
    and tests, exceptions will be easily visible.
  prefs: []
  type: TYPE_NORMAL
- en: There are differences. Tests can automatically interact with components; gallery
    components require a person to press buttons and type text. Developers can run
    tests with a single command; galleries have to be manually viewed, one example
    at a time. Gallery components are visual and easy to understand; tests are abstract
    and less fun to create.
  prefs: []
  type: TYPE_NORMAL
- en: Is there some way to combine galleries like Storybook with automated tests to
    get the best of both worlds?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re going to look at how you can reuse your Storybook stories inside tests.
    You can install Storybook into your application with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The example application in this chapter is a simple mathematical game in which
    the user needs to calculate the answer to a multiplication problem (see [Figure 8-3](ch08_split_001.xhtml#ch08_image_3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. The example application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One of the components in the game is called `Question`, and it displays a randomly
    generated multiplication question ([Figure 8-4](ch08_split_001.xhtml#ch08_image_4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. The Question component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s say we don’t worry too much about tests for this component. Let’s just
    build it by creating some Storybook stories. We’ll write a new *Question.stories.js*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we’ll create an initial version of the component that we can look
    at in Storybook and be happy with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This component displays a randomly generated question if the user clicks the
    Refresh button or if a parent component passes in a new `refreshTime` value.
  prefs: []
  type: TYPE_NORMAL
- en: We display the component in Storybook, and it looks like it works fine. We can
    click the Refresh button, and it refreshes. So at that point, we start to use
    the component in the main application. After a while, we add a few extra features,
    but none of them are visual changes, so we don’t look at the Storybook stories
    for it again. After all, it will still look the same. Right?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a modified version of the component, after we’ve wired it into the
    rest of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This version is only *slightly* longer than before. We’ve added an `onAnswer`
    callback function that will return the correct answer to the parent component
    each time the application generates a new question.
  prefs: []
  type: TYPE_NORMAL
- en: The new component appears to work well in the application, but then an odd thing
    occurs. The next time someone looks at Storybook, they notice an error, as shown
    in [Figure 8-5](ch08_split_001.xhtml#ch08_image_5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. An error occurs when we look at the new version of the component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'What happened? We’ve added an implicit assumption into the code that the parent
    component will always pass an `onAnswer` callback into the component. Because
    the Storybook stories rendered `Basic` story without an `onAnswer`, we got the
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Does this matter? Not for a simple component like this. After all, the application
    itself still worked. But failure to cope with missing properties, such as the
    missing callback here or, more frequently, missing data, is one of the most typical
    causes of errors in React.
  prefs: []
  type: TYPE_NORMAL
- en: Applications frequently generate React properties using data from the network,
    and that means the initial properties you pass to components will often be null
    or undefined. It’s generally a good idea to either use a type-safe language, like
    TypeScript, to avoid these issues or write tests that check that your components
    can cope with missing properties.
  prefs: []
  type: TYPE_NORMAL
- en: We created this component without any tests, but we did create it with a Storybook
    story—and that story *did* catch the issue. So is there some way to write a test
    that will automatically check that Storybook can render all the stories?
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to create a test for this component in a file called *Question.test.js*.
  prefs: []
  type: TYPE_NORMAL
- en: Consider creating a folder for each component. Instead of simply having a file
    called *Question.js* in the *src* directory, create a folder called *src/Question*,
    and inside there you can place *Question.js*, *Question.stories.js*, and *Question.test.js*.
    If you then add an *src/Question/index.js* file, which does a default export of
    the `Question` component, the rest of your code will be unaffected, and you will
    reduce the number of files other developers have to deal with.^([3](ch08_split_001.xhtml#idm46634396575256))
  prefs: []
  type: TYPE_NORMAL
- en: In the test file, we can then create a Jest test that loads each of the stories
    and then passes them to the Testing Library’s `render` function:^([4](ch08_split_001.xhtml#idm46634396570056))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If your stories are using *decorators* to provide such things as routers or
    styling, this technique will not pick them up automatically. You should add them
    into the `render` method within the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this test, you will get a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix the error by checking if there is a callback before calling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This technique allows you to create some elementary tests for a component with
    minimal effort. It’s worth creating a story for the component, which includes
    no properties whatsoever. Then, before you add a new property, create a story
    that uses it and think about how you will expect the component to behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the test will perform only a simple render of each story, there
    is no reason why you can’t import a single story and create a test using that
    story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storybook render tests introduce rudimentary unit testing into your application,
    and it can find a surprising number of regression bugs. It also helps you think
    of tests as examples, which are there to help you design your code rather than
    coding artifacts that you must create to keep the team lead happy. Creating render
    tests for stories is also helpful if you have a team that is new to unit testing.
    By creating visual examples, it avoids the problems that can arise from nonvisual
    tests feeling abstract. It can also get developers into the habit of having a
    test file for each component in the system. When you need to make a minor change
    to the component, it will then be much easier to add a small unit test function
    before adding the change.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Test Without a Server Using Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the principal features of high-quality code is the way it responds to
    errors. The first of Peter Deutsch’s [Eight Fallacies of Distributed Computing](https://oreil.ly/eDtKG)
    is: *the network is reliable*. Not only is the network *not* reliable, but neither
    are the servers or databases that connect to it. At some point, your application
    is going to have to deal with some network failure. It might be that the phone
    loses its connection, or the server goes down, or the database crashes, or someone
    else has deleted the data you are trying to update. Whatever the causes, you will
    need to decide what your application will do when terrible things happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Network issues can be challenging to simulate in testing environments. If you
    write code that puts the server into some error state, that is likely to cause
    problems for other tests or users who connect to the server.
  prefs: []
  type: TYPE_NORMAL
- en: How can you create automated tests for network failure cases?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we are going to use Cypress. We mentioned the Cypress testing
    system in [Chapter 1](ch01_split_000.xhtml#chapter01). It’s a genuinely remarkable
    testing system that is rapidly becoming our go-to tool in many development projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Cypress into your project, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Cypress works by automating a web browser. In that sense, it is similar to other
    systems like Selenium. Still, the difference is that Cypress does not require
    you to install a separate driver, and it can both control the browser remotely
    and inject itself into the browser’s JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress can therefore actively replace core parts of the JavaScript infrastructure
    with faked versions that it can control. For example, Cypress can replace the
    JavaScript `fetch` function used to make network calls to the server.^([5](ch08_split_001.xhtml#idm46634396204872))
    Cypress tests can therefore spoof the behavior of a network server and allow a
    client-side developer to artificially craft responses from the server.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the example game application that we use for other recipes in this
    chapter. We will add a network call to store the result each time a user answers
    a question. We can do this without creating the actual server code by faking the
    responses in Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: To show how this works, we will first create a test that simulates the server
    responding correctly. Then we will create a test to simulate a server failure.
  prefs: []
  type: TYPE_NORMAL
- en: Once Cypress is installed, create a file in *cypress/integration/* called *0001-basic-game-functions.js*:^([6](ch08_split_001.xhtml#idm46634396201256))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’ve put placeholder comments for each of the steps we will need to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each command and assertion in Cypress begins with `cy`. If we want to open
    the browser at location *http://localhost:3000*, we can do it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the test, we can type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That command will run all tests without showing the browser.^([7](ch08_split_001.xhtml#idm46634396063368))
    We can also type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command will open the Cypress application window (as you can see in [Figure 8-6](ch08_split_001.xhtml#ch08_image_6)).
    If we double-click the test file, the test will open in a browser (as you can
    see in [Figure 8-7](ch08_split_001.xhtml#ch08_image_7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. The test will appear in the Cypress window when you type `**npx
    cypress open**`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![](Images/recb_0807.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7\. A Cypress test running in a browser
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The example application asks the user to multiply two random numbers (see [Figure 8-8](ch08_split_001.xhtml#ch08_image_8)).
    The numbers will be in the range 1–10, so if we enter the value **`101`**, we
    can be sure that the answer will be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress does not allow you to capture textual content from the screen directly.
    So we cannot simply read the values of the two numbers and store them in variables
    because the commands in Cypress don’t immediately perform the actions in the browser.
    Instead, when you run a command, Cypress adds it to a *chain* of instructions,
    which it performs at the end of the test. This approach might seem a little odd,
    but these *chainable* instructions allow Cypress to cope with most of the problems
    caused by asynchronous interfaces.^([8](ch08_split_001.xhtml#idm46634396079192))
    The downside is that no command can return the page’s contents as the page will
    not exist when the command runs.
  prefs: []
  type: TYPE_NORMAL
- en: We will see elsewhere in this chapter how we can remove randomness in test scenarios
    and make this test deterministic, which will remove the need to capture data from
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8\. The application asks the user to calculate the product of two random
    numbers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can use the `cy.get` command to find the input field by a CSS selector.
    We can also use the `cy.contains` command to find the Submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now we just need to test that the application contacts the server with the result
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `cy.intercept()` command to do this. The `cy.intercept()` command
    will change the behavior of network requests in the application so that we can
    fake responses for a given request. If the result is going to be POSTed to the
    endpoint */api/result*, we generate a faked response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this command takes effect, network requests to */api/result* will receive
    the faked response. That means we need to run the command *before* the network
    request is made. We will do it at the start of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now specified the network response. But how do we assert that the application
    has made the network call, and how do we know that it has sent the correct data
    to the */api/result* endpoint?
  prefs: []
  type: TYPE_NORMAL
- en: We will need to give the network request an *alias*. This will allow us to refer
    to the request later in the test:^([9](ch08_split_001.xhtml#idm46634395808488))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make an assertion at the end of the test, which will wait for the
    network call to be made and will check the contents of the data sent in the request
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This assertion is checking two of the attributes of the request body for the
    expected values.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the test now, it will pass (as you can see in [Figure 8-9](ch08_split_001.xhtml#ch08_image_9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0809.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9\. The completed test passes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now that we’ve created a test for the successful case, we can write a test
    for the failure case. The application should display a message on-screen if the
    network call fails. We don’t actually care what details are sent to the server
    in this test, but we still need to wait for the network request to complete before
    checking for the existence of the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we check for the error message *not* existing before we make the
    network call to ensure that the network call *causes* the error.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to generating stubbed responses and status codes, `cy.intercept`
    can perform other tricks, such as slowing response times, throttling network speed,
    or generating responses from test functions. For further details, see the [`cy.intercept`
    documentation](https://oreil.ly/tcZR8).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress testing can transform how a development team works, specifically in
    its ability to mock network calls. Teams frequently develop APIs at a different
    cadence than frontend code. Also, some teams have developers who specialize in
    frontend or server code. Cypress can help in these situations because it allows
    frontend developers to write code against endpoints that don’t currently exist.
    Cypress can also simulate all of the pathological failure cases.
  prefs: []
  type: TYPE_NORMAL
- en: Network performance can introduce intermittent bugs. Development environments
    use local servers with little or no data, which means that API performance is
    far better at development time than in a production environment. It is straightforward
    to write code that assumes that data is immediately available, but this code will
    break in a production environment where the data may take a second or so to arrive.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is therefore worth having at least one test for each API call where the
    response is slowed by a second or so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Simulating slow network responses will often flush out a whole plethora of asynchronous
    bugs that might otherwise creep into your code.
  prefs: []
  type: TYPE_NORMAL
- en: Almost as importantly, creating artificially slow network responses will give
    you a sense of the overall impact of each API call on performance.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Use Cypress for Offline Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses a custom Cypress command invented by [Etienne Bruines](https://oreil.ly/oOMHP).
  prefs: []
  type: TYPE_NORMAL
- en: Applications need to cope with being disconnected from the network. We’ve seen
    elsewhere how to create a hook to detect if we are currently offline.^([10](ch08_split_001.xhtml#idm46634395450040))
    But how are we test for offline behavior?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can simulate offline working using Cypress. Cypress tests can inject code
    that modifies the internal behavior of the browser under test. We should therefore
    be able to modify the network code to simulate offline conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, you will need to install Cypress in your application. If you
    don’t already have Cypress, you can install it by running this command in your
    application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add a *0002-offline-working.js* file to the *cypress/integration*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We will ignore this test on Firefox. The offline simulation code relies upon
    the Chrome DevTools remote debugging protocol, which is not currently available
    in the Firefox browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have marked out the structure of the test as a series of comments. Cypress
    commands all begin with `cy`, so we can open the application like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The question is, how do we force the browser to simulate offline working?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it because Cypress is designed to be extensible. We can add a custom
    Cypress command that will allow us to go offline and back online:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a custom command, open the *cypress/support/commands.js* file, and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This command uses the remote debugging protocol in DevTools to emulate offline
    network conditions. Once you have saved this file, you can then implement the
    rest of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you run the test now, in Electron, it will pass (see [Figure 8-10](ch08_split_001.xhtml#ch08_image_10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0810.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10\. You can view each stage of the online/offline test by clicking
    on the left panel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be possible to create similar commands that simulate various network
    conditions and speeds.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how the network command works, see [this blog post from
    Cypress.io](https://oreil.ly/PB4zO).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Test in a Browser with Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nothing beats running your code inside a real browser, and the most common way
    of writing automated browser-based tests is by using a *web driver*. You can control
    most browsers by sending a command to a network port. Different browsers have
    different commands, and a web driver is a command-line tool that simplifies controlling
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we write a test for a React application that uses a web driver?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use the Selenium library. Selenium is a framework that provides
    a consistent API for a whole set of different web drivers, which means that you
    can write a test for Firefox and the same code should work in the same way for
    Chrome, Safari, and Edge.^([11](ch08_split_001.xhtml#idm46634394974248))
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same example application that we are using for all recipes in
    this chapter. It’s a game that asks the user for the answer to a simple multiplication
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Selenium library is available for a whole set of different languages, such
    as Python, Java, and C#. We will be using the JavaScript version: Selenium WebDriver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by installing Selenium:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to install at least one web driver. You can install web drivers
    globally, but it is more manageable to install them in your application. We could
    install a driver like `geckodriver` for Firefox, but for now, we will install
    `chromedriver` for Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can now start to create a test. It’s useful to include Selenium tests inside
    the *src* folder of the application, because it will make it easier to use an
    IDE to run the tests manually. So we’ll create a folder called *src/selenium*
    and then add a file inside it called *0001-basic-game-functions.spec.js*:^([12](ch08_split_001.xhtml#idm46634394947128))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We have outlined the test in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s convenient to include Selenium tests in the *src* tree, it can mean
    that a tool like Jest will run it as if it were a unit test, which is a problem
    if you run unit tests continually in the background. For example, if you created
    your application with `create-react-app` and leave an `npm run test` command running,
    you will find that a browser will suddenly appear on your screen each time you
    save the Selenium test. To avoid this, adopt some naming convention to distinguish
    between Selenium and unit tests. If you name all your Selenium tests **.spec.js*,
    you can modify your test script to avoid them by setting it to *react-scripts
    test ‘.*.test.js’*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selenium uses a web driver to automate the web browser. We can create an instance
    of the driver at the start of each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are creating a Chrome driver.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a driver for each test, we will also create a fresh instance of
    the browser for each test, ensuring that no browser state is carried between tests.
    If we carry no state between tests, it will allow us to run the tests in any order.
    We have no such guarantee on shared server state. If your tests are reliant upon,
    for example, database data, you should ensure that each test initializes the server
    correctly when it starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Selenium to create an instance of the driver, we should also explicitly
    *require* the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can now start to fill out the test. The JavaScript version of Selenium is
    highly asynchronous. Virtually all commands return promises, which means that
    it is very efficient, but it is also far too easy to introduce testing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin our test by opening the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `driver.get` command tells the browser to open the given URL. For this to
    work, we’ve also had to make two other changes. First, we’ve had to mark the test
    function with `async`, which will allow us to `await` the promise returned by
    `driver.get`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we’ve added a timeout value of 60,000 milliseconds to the test, overriding
    the implicit five-second limit of Jest tests. If you don’t increase the default
    timeout, you will find your test fails before the browser starts. We’ve set it
    to 60,000 milliseconds here to ensure the test works on any machine. You should
    adjust this value to match your expected hardware.
  prefs: []
  type: TYPE_NORMAL
- en: To enter the correct value into the game, we will need to read the two numbers
    that appear in the question (as shown in [Figure 8-11](ch08_split_001.xhtml#ch08_image_11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11\. The game asks the user to calculate a random product
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can find the two numbers on the page and the `input` and `submit` buttons
    using a command called `findElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are ever reading a set of elements from the page and don’t care about
    resolving them in a strict order, you can use the `Promise.all` function to combine
    them into a single promise that you can then await:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the example application, this optimization will save virtually no time, but
    if you have a page that renders different components in uncertain orders, combining
    the promises can improve test performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can now complete the next part of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are not combining the promises returned by `sendKeys` and `click`
    because we care that the test enters the answer into the input field *before*
    we submit it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want to assert that a *You have won!* message appears on the screen
    (see [Figure 8-12](ch08_split_001.xhtml#ch08_image_12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12\. The app tells the user they got the correct answer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now we could write our assertion like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will almost certainly work because the result is displayed quickly
    after the user submits an answer. React applications will often display dynamic
    results slowly, particularly if they rely upon data from the network. If we modify
    the application code to simulate a two-second delay before the result appears,^([13](ch08_split_001.xhtml#idm46634394193224))
    our test will produce the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can avoid this problem by waiting until the element appears on the screen
    and then waiting until the text matches the expected result. We can do both of
    those things with the `driver.wait` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the final version of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our experience, web driver tests are the most popular form of automated tests
    for web applications—*popular* that is, in the sense of *frequently used*. They
    are inevitably dependent upon matching versions of browsers and web drivers, and
    they do have a reputation for failing intermittently. Timing issues usually cause
    these failures, and those timing issues occur more in Single-Page Applications,
    which can update their contents asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to avoid these problems by carefully adding timing delays
    and retries into the code, this can make your tests sensitive to environmental
    changes, such as running your application on a different testing server. Another
    option, if you experience a lot of intermittent failures, is to move more of your
    tests to a system like Cypress, which is generally more [tolerant](https://oreil.ly/IZJ2T)
    of timing failures.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Test Cross-Browser Visuals with ImageMagick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications can look very different when viewed on different browsers. Applications
    can even look different if viewed on the same browser but on a different operating
    system. One example of this would be Chrome, which tends to hide scrollbars when
    viewed on a Mac but display them on Windows. Thankfully, old browsers like Internet
    Explorer are finally disappearing, but even modern browsers can apply CSS in subtly
    different ways, radically changing the appearance of a page.
  prefs: []
  type: TYPE_NORMAL
- en: It can be time-consuming to constantly check an application manually across
    a range of browsers and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do to automate this compatibility process?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to combine three tools to check for visual consistency
    across different browsers and platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: Storybook
  prefs: []
  type: TYPE_NORMAL
- en: This will give us a basic gallery of all of the components, in all relevant
    configurations, that we need to check.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  prefs: []
  type: TYPE_NORMAL
- en: This will allow us to capture the visual appearance of all of the components
    in Storybook. The Selenium Grid will also allow us to remotely connect to browsers
    on different operating systems to make comparisons between operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: ImageMagick
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we’ll use ImageMagick’s `compare` tool to generate visual differences
    between two screenshots and provide a numerical measure of how far apart the two
    images are.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by installing Storybook. You can do this in your application with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You will then need to create *stories* for each of the components and configurations
    you are interested in tracking. You can find out how to do this from other recipes
    in this book or the [Storybook tutorials](https://oreil.ly/ak7VW).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need Selenium to automate the capture of screenshots. You can
    install Selenium with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to install the relevant web drivers. For example, to automate
    Firefox and Chrome, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you will need to install ImageMagick, a set of command-line image manipulation
    tools. For details on how to install ImageMagick, see the [ImageMagick download
    page](https://oreil.ly/NIQ0A).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the same example game application that we’ve used previously
    in this chapter. You can see the components from the application displayed in
    Storybook in [Figure 8-13](ch08_split_001.xhtml#ch08_image_13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0813.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13\. Components from the application displayed in Storybook
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can run the Storybook server on your application by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create a test that will just be a script for capturing screenshots
    of each of the components inside Storybook. In a folder called *src/selenium*,
    create a script called *shots.spec.js*:^([14](ch08_split_001.xhtml#idm46634393644856))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This script opens a browser to the Storybook server, opens each of the components,
    and takes a screenshot of each story, which it stores in a subdirectory within
    *screenshots*.
  prefs: []
  type: TYPE_NORMAL
- en: We could use a different testing system to take screenshots of each component,
    such as Cypress. The advantage of using Selenium is that we can remotely open
    a browser session on a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the *shots.spec.js* test will take screenshots of Storybook at address
    *http://localhost:6006* using the Chrome browser. Let’s say we are running the
    *shots* test on a Mac. If we have a Windows machine on the same network, we can
    install a Selenium Grid server, which is a [proxy server](https://oreil.ly/gYLds)
    that allows remote machines to start a web driver session.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Windows machine has address `192.168.1.16`, we can set this environment
    variable on the command line before running the *shots.spec.js* test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the Windows machine will be accessing the Storybook server back on
    the Mac, for example, with an IP address of `192.168.1.14`, we will also need
    to set an environment variable for that on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can also choose which browser we want the Windows machine to use:^([15](ch08_split_001.xhtml#idm46634393280696))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create a script to run *shots.spec.js* in *package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'we can run the test and capture the screenshots of each component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The test will use the environment variables we created to contact the Selenium
    Grid server on the remote machine. It will ask Selenium Grid to open a Firefox
    browser to our local Storybook server. It will then send a screenshot of each
    of the components over the network, where the test will store them in a folder
    called *screenshots/firefox*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve run it for Firefox, we can then run it for Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The test will write the Chrome screenshots to *screenshots/chrome*.
  prefs: []
  type: TYPE_NORMAL
- en: A fuller implementation of this technique would also record the operating system
    and type of client (e.g., screen size) used.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to check for visual differences between the screenshots from Chrome
    and the screenshots from Firefox, and this is where ImageMagick is useful. The
    `compare` command in ImageMagick can generate an image that highlights the visual
    differences between two other images. For example, consider the two screenshots
    from Firefox and Chrome in [Figure 8-14](ch08_split_001.xhtml#ch08_image_14).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0814.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-14\. The same component in Chrome and Firefox
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'These two images appear to be identical. If we type in this command from the
    application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: we will generate a new image that shows the differences between the two screenshots,
    which you can see in [Figure 8-15](ch08_split_001.xhtml#ch08_image_15).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0815.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15\. The generated image showing the differences between two screen
    captures
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The generated image shows pixels that are more than 15% visually different between
    the two images. And you can see that the screenshots are virtually identical.
  prefs: []
  type: TYPE_NORMAL
- en: That’s good, but it still requires a human being to look at the images and assess
    whether the differences are significant. What else can we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compare` command also has the ability to display a numerical measure of
    the difference between two images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The value `6774` is a numerical measure (based on the absolute error count,
    or *AE*) of the visual difference between the two images. For another example,
    consider the two screenshots in [Figure 8-16](ch08_split_001.xhtml#ch08_image_16),
    which show the `Answer` component when given a `disabled` property.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0816.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-16\. Disabled form rendered by Chrome and Firefox
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Comparing these two images returns a much larger number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, the generated image (see [Figure 8-17](ch08_split_001.xhtml#ch08_image_17))
    shows precisely where the difference lies: the disabled input field.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0817.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-17\. The visual difference between the Chrome and Firefox forms
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 8-18](ch08_split_001.xhtml#ch08_image_18) shows a similarly significant
    difference (21,131) for a component that displays different font styling between
    the browsers, resulting from some Mozilla-specific CSS attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0818.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-18\. A component with different text styling in Chrome and Firefox
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In fact, it’s possible to write a shell script to run through each of the images
    and generate a small web report showing the visual differences alongside their
    metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This script creates the *screenshots/compare.html* report you can see in [Figure 8-19](ch08_split_001.xhtml#ch08_image_19).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0819.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-19\. An example of the generated comparison report
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To save space, we have shown only a simplistic implementation of this technique.
    It would be possible to create a ranked report that showed visual differences
    from largest to smallest. Such a report would highlight the most significant visual
    differences between platforms.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use automated visual tests to prevent regressions. You need to
    avoid false positives caused by minor variations, such as anti-aliasing. A continuous
    integration job could set some visual threshold between images and fail if any
    components vary by more than that threshold.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Add a Console to Mobile Browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is slightly different from the others in this chapter because instead
    of being about automated testing, it’s about manual testing—specifically manually
    testing code on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: If you are testing an application on a mobile, you might stumble across a bug
    that doesn’t appear in the desktop environment. Generally, if a bug appears, you’re
    able to add debug messages into the JavaScript console. But mobile browsers tend
    not to have a visible JavaScript console. It’s true that if you are using Mobile
    Chrome, you can try debugging it remotely with a desktop version of Chrome. But
    what if you discover the problem in another browser? Or if you simply don’t want
    to go through the work of setting up a remote debug session?
  prefs: []
  type: TYPE_NORMAL
- en: Is there some way to access the JavaScript console, and other development tools,
    from within a mobile browser?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use a piece of software called [Eruda](https://oreil.ly/jCFSn).
  prefs: []
  type: TYPE_NORMAL
- en: Eruda is a lightweight implementation of a development tools panel, which will
    allow you to view the JavaScript console, the structure of the page, and a whole
    heap of other [plugins and extensions](https://oreil.ly/ZUQHw).
  prefs: []
  type: TYPE_NORMAL
- en: To enable Eruda, you will need to install a small amount of reasonably rudimentary
    JavaScript in the `head` section of your application. You can download Eruda from
    a content distribution network. Still, because it can be pretty large, you should
    enable it only if the person using the browser has indicated that they want to
    access it.
  prefs: []
  type: TYPE_NORMAL
- en: One way of doing this is by enabling Eruda only if *eruda=true* appears in the
    URL. Here’s an example script that you can insert into your page container:^([16](ch08_split_001.xhtml#idm46634392955256))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you now open your application as *http://ipaddress/?eruda=true* or *http://ipaddress/#eruda=true*,
    you will notice that an additional button has appeared in the interface, as shown
    in [Figure 8-20](ch08_split_001.xhtml#ch08_image_20).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0820.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-20\. If you add ?eruda=true to the URL, a button will appear on the
    right of the page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are using the example application for this chapter, then try entering
    a few answers into the game.^([17](ch08_split_001.xhtml#idm46634392840120)) Then,
    click the Eruda button. The console will appear as shown in [Figure 8-21](ch08_split_001.xhtml#ch08_image_21).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0821.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-21\. Clicking the button opens the Eruda tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because the endpoint the example application calls is missing, you should find
    some errors and other logs recorded in the console. The console even supports
    the much underused `console.table` function, which is a helpful way of displaying
    an array of objects in tabular format.
  prefs: []
  type: TYPE_NORMAL
- en: The Elements tab provides a fairly rudimentary view of the DOM (see [Figure 8-22](ch08_split_001.xhtml#ch08_image_22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0822.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-22\. The Eruda elements view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Meanwhile, the Settings tab has an extensive set of JavaScript features that
    you can enable and disable while interacting with the web page (see [Figure 8-23](ch08_split_001.xhtml#ch08_image_23)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0823.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-23\. The Eruda settings view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eruda is a delightful tool that delivers a whole bucket of functionality, with
    very little work required by the developer. In addition to the basic features,
    it also has plugins that allow you to track performance, set the screen refresh
    rate, generate fake geolocations, and even write and run JavaScript from inside
    the browser. Once you start to use it, you probably find that it quickly becomes
    a standard part of your manual testing process.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Remove Randomness from Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a perfect world, tests would always have a completely artificial environment.
    Tests are examples of how you would like your application to work under explicitly
    defined conditions. But tests often have to cope with uncertainties. For example,
    they might run at different times of day. The example application that we have
    used throughout this chapter has to deal with *randomness*.
  prefs: []
  type: TYPE_NORMAL
- en: Our example application is a game that presents the user with a randomly generated
    question that they must answer (see [Figure 8-24](ch08_split_001.xhtml#ch08_image_24)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-24\. The game asks the user to calculate a random multiplication problem
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Randomness might also appear in the generation of identifiers within the code
    or random data sets. If you ask for a new username, your application might suggest
    a randomly generated string.
  prefs: []
  type: TYPE_NORMAL
- en: 'But randomness creates a problem for tests. This is an example test that we
    implemented earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'There was actually a good reason why that test looked at the case where the
    user entered an *incorrect* answer. The question asked is always to calculate
    the product of two numbers between 1 and 10\. It’s therefore easy to think of
    an incorrect answer: 101. It will *always* be wrong. But if we want to write a
    test to show what happens when the user enters the *correct* answer, we have a
    problem. The correct answer depends upon data that is randomly generated. We could
    write some code that finds the two numbers that appear on the screen, as in this
    example from the first Selenium recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes this approach is not even possible. For example, Cypress does not
    allow you to capture data from the page. If we wanted to write a Cypress test
    to enter the correct answer to the multiplication problem, we would have great
    difficulty. That’s because Cypress does not allow you to capture values from the
    page and pass them to other steps in the test.
  prefs: []
  type: TYPE_NORMAL
- en: It would be much better if we could turn off the randomness during a test.
  prefs: []
  type: TYPE_NORMAL
- en: But can we?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will look at how we can use the Sinon library to temporarily replace the
    `Math.random` function with a faked one of our own making.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first consider how we can do this inside a unit test. We’ll create a new
    test for the top-level `App` component, which will check that entering the correct
    value results in a message saying that we won.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a function that will fix the return value of `Math.random`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This function works by replacing the `random` method of the `Math` object with
    a stubbed method that always returns the same value. We can now use this in a
    test. The `Question` that appears on the page always generates random numbers
    between 1 and 10, based upon the value of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we fix `Math.random` so that it always produced the value 0.5, then the
    “random” number will always be 6\. That means we can write a unit test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: And this test will always pass because the application will always ask the question,
    “What is 6 × 6?”
  prefs: []
  type: TYPE_NORMAL
- en: The real value of fixing `Math.random` is when we use a testing framework that
    explicitly *prevents* us from capturing a randomly generated value such as Cypress,
    as we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress allows us to add custom commands by adding them to the *cypress/support/commands.js*
    script. If you edit that file and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: you will create a new command called `cy.random`. We can use this command to
    create a test for the *winning* case that we discussed in the introduction:^([18](ch08_split_001.xhtml#idm46634392341560))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After calling the `cy.random` command, we need to click the Refresh button in
    case the application generated the random numbers before the `Math.random` function
    was replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can never remove all randomness from a test. For example, the machine’s
    performance can significantly affect when and how often your components are re-rendered.
    But removing uncertainty as much as we can is generally a good thing in a test.
    The more we can do to remove external dependencies from our tests, the better.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at removing external dependencies in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: Time Travel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time can be the source of a tremendous number of bugs. If time were simply a
    scientific measurement, it would be relatively straightforward. But it isn’t.
    The representation of time is affected by national boundaries and by local laws.
    Some countries have their own time zone. Others have multiple time zones. One
    reassuring factor is that all countries have a time zone offset in whole hours,
    except for places like India, where time is offset by +05:30 from UTC.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why it is helpful to try to fix the time within a test. But how do we
    do that?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will look at how you can fix the time when testing your React application.
    There are some issues that you need to consider when testing time-dependent code.
    First, you should probably avoid changing the time on your server. In most cases,
    it’s best to set your server to UTC and leave it that way.
  prefs: []
  type: TYPE_NORMAL
- en: That does mean that if you want to fake date and time in your browser, you will
    have problems as soon as the browser makes contact with the server. That means
    you will either have to modify the server APIs to accept an *effective date* or
    test time-dependent browser code in isolation from the server.^([19](ch08_split_001.xhtml#idm46634392149944))
  prefs: []
  type: TYPE_NORMAL
- en: 'We will adopt the latter approach for this recipe: using the Cypress testing
    system to fake any connections with the server.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same application we use for other recipes in this chapter. It’s
    a simple game that asks the user to calculate the product of two numbers. We’re
    going to test a feature of the game that gives the user 30 seconds to provide
    an answer. After 30 seconds, they will see a message telling them they’ve run
    out of time (see [Figure 8-25](ch08_split_001.xhtml#ch08_image_25)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0825.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-25\. The player will lose if they don’t answer within 30 seconds
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We could try writing a test that somehow pauses for 30 seconds, but that has
    two problems. First, it will slow your test down. You don’t need many 30-second
    pauses before your tests will become unbearable to run. Second, adding a pause
    is not a very precise way to test a feature. If you try to pause for 30 seconds,
    you might pause for 30.5 seconds before looking for the message.
  prefs: []
  type: TYPE_NORMAL
- en: To get precision, we need to take control of time within the browser. As you
    saw in the previous recipe, Cypress can inject code into the browser, replacing
    critical pieces of code with stubbed functions, which we can control. Cypress
    has a built-in command called `cy.clock`, which allows us to specify the current
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to use `cy.clock` by creating a test for the timeout feature.
    This will be the structure of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start by opening the application and clicking the Refresh button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to simulate 29 seconds of time passing. We can do this with the
    `cy.clock` and `cy.tick` commands. The `cy.clock` command allows you to either
    specify a new date and time; or, if you call `cy.clock` without parameters, it
    will set the time and date back to 1970\. The `cy.tick()` command allows you to
    add a set number of milliseconds to the current date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now complete the other steps in the test. For details on the other Cypress
    commands we’re using, see the [Cypress documentation](https://oreil.ly/vahMA):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If we run the test in Cypress, it passes (as you can see in [Figure 8-26](ch08_split_001.xhtml#ch08_image_26)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0825.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-26\. By controlling time, we can force a timeout in the test
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That’s a relatively simple time-based test. But what if we wanted to test something
    much more complex, like daylight saving time (DST)?
  prefs: []
  type: TYPE_NORMAL
- en: DST bugs are the bane of most development teams. They sit in your codebase silently
    for months and then suddenly appear in the spring and fall, in the early hours
    of the morning.
  prefs: []
  type: TYPE_NORMAL
- en: When DST occurs depends upon your time zone. And that’s a particularly awful
    thing to deal with in client code because JavaScript dates don’t work with time
    zones. They can certainly handle offsets; for example, you can create a `Date`
    object in a browser like Chrome that is set to five hours before Greenwich Mean
    Time:^([20](ch08_split_001.xhtml#idm46634391785704))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: But JavaScript dates are all implicitly in the time zone of the browser. When
    you create a date with a time zone name in it, the JavaScript engine will simply
    shift it into the browser’s time zone.
  prefs: []
  type: TYPE_NORMAL
- en: The browser’s time zone is fixed at the time that the browser opens. There’s
    no way to say *Let’s pretend we’re in New York from now on*.
  prefs: []
  type: TYPE_NORMAL
- en: If developers create tests for DST, the tests might work only in the developer’s
    time zone. The tests might fail if run on an integration server set to UTC.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a way around this problem. On Linux and Mac computers (but
    not Windows), you can specify the time zone when you launch a browser by setting
    an environment variable called `TZ`. If we start the Cypress with the `TZ` variable
    set, any browser that Cypress launches will inherit it, which means that while
    we can’t set the time zone for a single test, we can set it for an entire test
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s launch Cypress with the time zone set to New York:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The example application has a button that allows you to see the current time
    (see [Figure 8-27](ch08_split_001.xhtml#ch08_image_27)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0827.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-27\. The current time is shown on the screen
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can create a test that checks that the time on the page correctly handles
    the change to DST. This is the test we’ll create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we are passing an explicit date to `cy.clock`. We need to convert
    this to milliseconds by calling `getTime` as `cy.clock` accepts only numeric times.
    We then check the initial time, and 30 seconds later, we check the time rolls
    over to 3 a.m., instead of 2 a.m. (as shown in [Figure 8-28](ch08_split_001.xhtml#ch08_image_28)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/recb_0828.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-28\. After 30 seconds, the time correctly changes from 01:59 to 03:00
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to create tests that depend on the current time zone, consider
    placing them into a subfolder so you can run them separately. If you want to format
    dates into various time zones, you can use the `toLocaleString` date method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You can download the source for this recipe from the [GitHub site](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08_split_000.xhtml#idm46634397841208-marker)) You will see in other
    recipes in this chapter that it’s possible to dynamically remove the randomness
    from a test and fix the correct answer without capturing the question from the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08_split_000.xhtml#idm46634397514504-marker)) Notice that many tests
    make text comparisons using regular expressions, which allows, as in this example,
    for case-insensitive matches of substrings. Regular expressions can prevent tests
    from breaking frequently.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08_split_001.xhtml#idm46634396575256-marker)) See the source code in
    the [GitHub repository](https://oreil.ly/P1Tqj) to see how we’ve structured the
    code in the example application.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch08_split_001.xhtml#idm46634396570056-marker)) If you don’t have the
    Testing Library installed, see [“Use the React Testing Library”](ch08_split_000.xhtml#ch08-01).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch08_split_001.xhtml#idm46634396204872-marker)) Either directly or indirectly
    via libraries such as Axios.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch08_split_001.xhtml#idm46634396201256-marker)) It doesn’t matter what
    you call the file, but we follow the convention of prefixing high-level tests
    such as this with story numbers. Doing so reduces the likelihood of test merge
    conflicts and makes it much easier to track the intent of individual changes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch08_split_001.xhtml#idm46634396063368-marker)) This will run the tests
    more quickly and record a video for each one, which is helpful if your tests run
    on an integration server.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch08_split_001.xhtml#idm46634396079192-marker)) Cypress commands are similar
    in many ways to promises, although they are not promises. You can think of each
    one as a “prom-ish.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch08_split_001.xhtml#idm46634395808488-marker)) The `cy.intercept` command
    cannot simply return a reference to the faked network request because of the chainable
    nature of Cypress commands.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch08_split_001.xhtml#idm46634395450040-marker)) See [“Monitor Online
    Status”](ch03.xhtml#ch03-05).
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch08_split_001.xhtml#idm46634394974248-marker)) This doesn’t mean that
    the tests will work against every browser, just that they will all run across
    every browser.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch08_split_001.xhtml#idm46634394947128-marker)) We are following a convention
    where we prefix the test with its associated story number. Selenium does not require
    this.
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch08_split_001.xhtml#idm46634394193224-marker)) You will find the code
    to do this in the downloadable source for this chapter from [GitHub](https://oreil.ly/P1Tqj).
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch08_split_001.xhtml#idm46634393644856-marker)) You could put this script
    anywhere, but this is the location we used in the example code on the GitHub site.
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch08_split_001.xhtml#idm46634393280696-marker)) The remote machine must
    have the appropriate browser and web driver installed for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch08_split_001.xhtml#idm46634392955256-marker)) For `create-react-app`
    applications, this should be added to *public/index.html*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch08_split_001.xhtml#idm46634392840120-marker)) The code is available
    in the [source code repository](https://oreil.ly/P1Tqj) for this book.
  prefs: []
  type: TYPE_NORMAL
- en: ^([18](ch08_split_001.xhtml#idm46634392341560-marker)) You can find out more
    about this test in [“Test Without a Server Using Cypress”](ch08_split_001.xhtml#ch08-03).
  prefs: []
  type: TYPE_NORMAL
- en: ^([19](ch08_split_001.xhtml#idm46634392149944-marker)) That is, allow the browser
    to say to the server *Let’s pretend it’s Thursday, April 14*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([20](ch08_split_001.xhtml#idm46634391785704-marker)) Firefox will not generally
    accept this format.
  prefs: []
  type: TYPE_NORMAL
