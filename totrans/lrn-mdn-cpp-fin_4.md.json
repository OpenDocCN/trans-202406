["```\nimport <valarray>;\n. . .\n\n\tstd::valarray<double> v1{ 1.0, 2.0, 3.0,\n\t\t\t\t  1.5, 2.5 };\n\n\tstd::valarray<double> v2{ 10.0, -20.0, 30.0,\n\t\t\t\t -15.0, 25.0 };\n\n\tdouble vec_sum = 3.0 * v1 + 0.5 * v2;    // vec_sum is also a valarray <double>\n```", "```\n8 -4 24 -3 20\n```", "```\ndouble prod = v1 * v2;\n```", "```\n10 -40 90 -22.5 62.5\n```", "```\ndouble dot_prod = prod.sum();  \t// Result = 100\n```", "```\ndouble v1_max = v1.max();\t// 3.0\ndouble v1_min = v1.min();\t// 1.0\n\n// u and w are valarray<double> types\nauto u = v1.apply([](double x) -> double {return x * x; });\n// Result: 1, 4, 9, 2.25, 6.25\n\nauto w = v1.apply([](double x) -> double {return std::sin(x) + std::cos(x);});\n// Result: 1.38177 0.493151 -0.848872 1.06823 -0.202671\n```", "```\n// The result in each is a valarray<double>\nauto sine_v1 = std::sin(v1);\nauto log_v1 = std::log(v1);\nauto abs_v1 = std::abs(neg_val);\nauto exp_v1 = std::exp(neg_val);\nauto neg_v1 = - v1;\n```", "```\ntemplate<typename T>\nvoid print(T t) { cout << t << \" \"; }\n\nstd::for_each(std::begin(w), std::end(w), print<double>);\n```", "```\nusing mtx_array = std::valarray<double>;\n```", "```\nmtx_array val{ 1.0, 2.0, 3.0,\n\t\t\t   1.5, 2.5, 3.5,\n\t\t\t   7.0, 8.0, 9.0,\n\t\t\t   7.5, 8.5, 9.5};\n```", "```\nauto slice_row01 = val[std::slice(0, 3, 1)];\n```", "```\nauto slice_col02 = val[std::slice(1, 4, 3)];\t\t// The 2nd rowwise element has index 1\n```", "```\nmtx_array va01{ 1.0, 2.0, 3.0,\n \t            1.5, 2.5, 3.5,\n\t\t        4.0, 5.0, 6.0,\n\t\t        4.5, 5.5, 6.5,\n\t\t\t    7.0, 8.0, 9.0 };\n\nunsigned va01_rows{ 5 }, va01_cols{ 3 };\n\nmtx_array va02{ 1.0, 2.0, 3.0, 4.0, 5.0,\n\t\t\t    1.5, 2.5, 3.5, 4.5, 5.5,\n\t\t  \t    5.0, 6.0, 7.0, 8.0, 8.5 };\n\nunsigned va02_rows{ 3 }, va02_cols{ 5 };\n```", "```\nauto slice_01_row_03 = va01[std::slice(9, va01_cols, 1)];\nauto slice_02_col_02 = va02[std::slice(1, va02_rows, 5)];\n```", "```\nmtx_array va01_row03{ slice_01_row_03 };\nmtx_array va02_col02{ slice_02_col_02 };\n```", "```\ndouble dot_prod = (va01_row03 * va02_col02).sum();\n```", "```\nauto slice_01_row_01 = va01[std::slice(0, va01_cols, 1)];\n```", "```\nslice_01_row_01[0] *= 10.0;\nslice_01_row_01[1] += 1.0;\nslice_01_row_01[2] -= 3.0;\n```", "```\n10\t3\t0\n1.5\t2.5\t3.5\n7\t8\t9\n7.5\t8.5\t9.5\n```", "```\ntemplate <typename T>\nstd::vector<T> operator + (const std::vector<T>& a,\n\tconst std::vector<T>& b)\n{\n\tstd::vector<T> res(a.size());\n\tfor (size_t i = 0; i < a.size(); ++i)\n\t\tres[i] = a[i] + b[i];\n\treturn res;\n}\n```", "```\n\tvector<double> v1{ 1.0, 2.0, 3.0 };\n\tvector<double> v2{ 1.5, 2.5, 3.5 };\n\tvector<double> v3{ 4.0, 5.0, 6.0 };\n\tvector<double> v4{ 4.5, 5.5, 6.5 };\n\n\tauto y = v1 + v2 + v3 + v4;\n```", "```\ntemplate <typename T>\nstd::vector<T> sum_four_vectors(const std::vector<T>& a, const std::vector<T>& b,\n\tconst std::vector<T>& c, const std::vector<T>& d)\n{\n\t// Assume a, b, c, and d all contain the same\n\t// number of elements:\n\tstd::vector<T> sum(a.size());\n\n\tfor (size_t i = 0; i < a.size(); ++i)\n\t{\n\t\tsum[i] = a[i] + b[i] + c[i] + d[i];\n\t}\n\n\treturn sum;\n}\n```", "```\n#include <Eigen/Dense>\n. . .\n\nEigen::Matrix3d dbl_mtx\t\t\t// Contains 'double' elements\n{\n\t{10.6, 41.2, 2.16},\n\t{41.9, 5.31, 13.68},\n\t{22.47, 57.43, 8.82}\n};\n\nEigen::Matrix4i int_mtx\t\t\t// Contains 'int' elements\n{\n\t{24, 0, 23, 13},\n\t{8, 75, 0, 98},\n\t{11, 60, 1, 3 },\n\t{422, 55, 11, 55}\n};\n\ncout << dbl_mtx << endl << endl;\ncout << int_mtx << endl << endl;\n```", "```\n 10.6  87.4 58.63\n 41.9  53.1 13.68\n22.47 57.43  88.2\n\n 24   0  23  13\n  8  75   0  98\n 11  60   1   3\n422  55  11  55\n```", "```\ncout << dbl_mtx.col(0) << endl << endl;\ncout << int_mtx.row(2) << endl << endl;\n```", "```\n10.6\n41.9\n22.47\n\n11 60  1  3\n```", "```\nusing Eigen::MatrixXd;\n. . .\n\nMatrixXd mtx0\n{\n\t{1.0, 2.0, 3.0},\n\t{4.0, 5.0, 6.0},\n\t{7.0, 8.0, 9.0},\n\t{10.0, 11.0, 12.0}\n};\n\nMatrixXd mtx1{4, 3};\t\t// 4 rows, 3 columns\nmtx1 << 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0;\n\nMatrixXd mtx3{2, 2};\nmtx3(0, 0) = 3.0;\nmtx3(1, 0) = 2.5;\nmtx3(0, 1) = -1.0;\nmtx3(1, 1) = mtx3(1, 0) + mtx3(0, 1);\n```", "```\nusing Eigen::VectorXd;\nusing Eigen::RowVectorXd;\n. . .\n\nVectorXd a \t{ {1.5, 2.5, 3.5} };             // A column-vector with 3 coefficients\nRowVectorXd b { {1.0, 2.0, 3.0, 4.0} };      // A row-vector with 4 coefficients\n\nEigen::VectorXd v(2);\nv(0) = 4.0;\nv(1) = v(0) - 1.0;\n```", "```\nMatrixXd A\n{\n\t{1.0, 2.0, 3.0},\n\t{1.5, 2.5, 3.5},\n\t{4.0, 5.0, 6.0},\n\t{4.5, 5.5, 6.5},\n\t{7.0, 8.0, 9.0}\n};\n\nMatrixXd B\n{\n\t{1.0, 2.0, 3.0, 4.0, 5.0},\n\t{1.5, 2.5, 3.5, 4.5, 5.5},\n\t{5.0, 6.0, 7.0, 8.0, 8.5}\n};\n\nMatrixXd prod_ab = A * B;\n```", "```\n   19    25    31    37  41.5\n22.75 30.25 37.75 45.25    51\n 41.5  56.5  71.5  86.5  98.5\n45.25 61.75 78.25 94.75   108\n   64    88   112   136 155.5\n```", "```\nMatrixXd corr_mtx\n{\n\t{1.0, 0.5, 0.25},\n\t{0.5, 1.0, -0.7},\n\t{0.25, -0.7, 1.0}\n};\n\nVectorXd vols{ {0.2, 0.1, 0.4 } };\n\nMatrixXd cov_mtx = vols.asDiagonal() * corr_mtx * vols.asDiagonal();\n```", "```\nVectorXd fund_weights{ {0.6, -0.3, 0.7 } };\ndouble port_vol = std::sqrt(fund_weights.transpose() * cov_mtx * fund_weights);\n```", "```\nMatrixXd cwise_prod = A.cwiseProduct(B.transpose());\n```", "```\nVectorXd u{ {1.0, 2.0, 3.0} };\nVectorXd v{ {0.5, -0.5, 1.0} };\n```", "```\ndouble dp = u.transpose() * v;\t\t\t// Returns 'double'\nMatrixXd op = u * v.transpose();\t\t// Returns a Matrix\n```", "```\n  0.5 -0.5   1\n   1   -1    2\n 1.5 -1.5    3\n```", "```\ndp = u.dot(v);\n```", "```\nVectorXd u(12);\t\t\t\t\t\t\t// 12 elements\nstd::mt19937_64 mt(100);\t\t\t\t// Mersenne Twister engine, seed = 100\nstd::student_t_distribution<> tdist(5);\t// 5 degrees of freedom\nstd::generate(u.begin(), u.end(), [&mt, &tdist]() {return tdist(mt); });\n```", "```\nstd::generate(u.data()), u.data() + u.size(),\n[&mt, &tdist]() {return tdist(mt); });\n```", "```\nauto max_u = std::max_element(u.begin(), u.end());\t\t// Returns iterator\n```", "```\ndouble dot_prod = std::inner_product(u.begin(), u.end(), v.begin(), 0.0);\n```", "```\nVectorXd w(v.size());\nstd::ranges::transform(u, v, w.begin(), std::plus{});\n```", "```\nstd::vector<double> v{ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0,\n\t7.0, 8.0, 9.0, 10.0, 11.0, 12.0 };\n\nEigen::Map<MatrixXd> mtx_map(v.data(), 4, 3);\n```", "```\n1  5  9\n2  6  10\n3  7  11\n4  8  12\n```", "```\nMatrixXd mtx_from_std_vector{ mtx_map };\n```", "```\nEigen::Map<Eigen::Matrix<double, 4, 3, Eigen::RowMajor>>\n    mtx_row_major_map{ v.data(), 4, 3 };\n```", "```\n// Square matrix, place in row-major order:\nstd::vector<double> sq_data{ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0,\n\t7.0, 8.0, 9.0 };\n\nEigen::Map<MatrixXd> sq_mtx_map{ sq_data.data(), 3, 3 };\nsq_mtx_map.transposeInPlace();\n```", "```\n1 2 3\n4 5 6\n7 8 9\n```", "```\n\tMatrixXd vals\n\t{\n\t\t{ 9.0, 8.0, 7.0 },\n\t\t{ 3.0, 2.0, 1.0 },\n\t\t{ 9.5, 8.5, 7.5 },\n\t\t{ 3.5, 2.5, 1.5 }\n\t};\n```", "```\nfor (auto row : vals.rowwise())\n{\n\tstd::ranges::transform(row, row.begin(), [](double x) {return x * x; });\n}\n```", "```\nfor (auto col : vals.colwise())\n{\n\tstd::ranges::sort(col);\n}\n```", "```\n    9     4     1\n12.25  6.25  2.25\n   81    64    49\n90.25 72.25 56.25\n```", "```\n25.5  8.0 70.5\n31.0  7.5 71.0\n29.5  8.5 77.5\n33.5  5.5 71.5\n26.5  9.5 72.5\n34.5  8.5 75.5\n28.5  9.0 72.0\n23.5  7.5 73.5\n28.0  8.0 72.5\n31.5  9.0 73.0\n32.5  9.5 74.5\n```", "```\nfor (auto row : prices_to_returns.rowwise())\n{\n\tstd::ranges::transform(row, row.begin(), [](double x) {return std::log(x); });\n}\n```", "```\nfor (auto col : prices_to_returns.colwise())\n{\n\tstd::adjacent_difference(col.begin(), col.end(), col.begin());\n}\n```", "```\n   3.23868    2.07944    4.25561\n  0.195309 -0.0645385 0.00706717\n-0.0495969   0.125163  0.0875981\n  0.127155  -0.435318 -0.0805805\n -0.234401   0.546544  0.0138891\n  0.263815  -0.111226  0.0405461\n -0.191055  0.0571584 -0.0474665\n -0.192904  -0.182322  0.0206193\n  0.175204  0.0645385 -0.0136988\n  0.117783   0.117783 0.00687288\n 0.0312525  0.0540672  0.0203397\n```", "```\nMatrixXd returns_mtx{ prices_to_returns(Eigen::seq(1, Eigen::last),\n\tEigen::seq(0, Eigen::last)) };\n```", "```\n  0.195309 -0.0645385 0.00706717\n-0.0495969   0.125163  0.0875981\n  0.127155  -0.435318 -0.0805805\n -0.234401   0.546544  0.0138891\n  0.263815  -0.111226  0.0405461\n -0.191055  0.0571584 -0.0474665\n -0.192904  -0.182322  0.0206193\n  0.175204  0.0645385 -0.0136988\n  0.117783   0.117783 0.00687288\n 0.0312525  0.0540672  0.0203397\n```", "```\nVectorXd monthly_returns = returns_mtx * allocations;\n```", "```\n 0.0443094\n 0.0546058\n -0.149768\n   0.14005\n 0.0579814\n-0.0558726\n  -0.13529\n 0.0837121\n 0.0900555\n 0.0376502\n```", "```\nMatrixXd A\t\t// Row-major\n{\n\t{3.0, -5.0, 1.0},\n\t{-1.0, -1.0, 1.0},\n\t{2.0, -4.0, 1.0}\n};\n\nVectorXd b\n{\n\t{0.0, -4.0, 1.0}\n};\n```", "```\nEigen::FullPivLU<MatrixXd> lu(A);\nVectorXd x = lu.solve(b);\n```", "```\n2.5\n1.5\n  0\n```", "```\nEigen::JacobiSVD<MatrixXd> svd{ X, Eigen::ComputeThinU | Eigen::ComputeThinV };\nVectorXd beta = svd.solve(Y);\n```", "```\nEigen::JacobiSVD<MatrixXd> svd{ X, Eigen::ComputeFullU | Eigen::ComputeFullV };\n```", "```\nMatrixXd X{ 3, 30 };\t// 3 sector funds, 30 observations (will transpose)\nX\t<<\n\t// Sector fund 1\n\t-0.044700388, -0.007888394, 0.042980064, 0.016416586, -0.01779658, -0.016714149,\n\t0.019472031, 0.029853293, 0.023126097, -0.033879088, -0.00338369, -0.018474493,\n\t-0.012509815, -0.01834808, 0.010626754, 0.036669407, 0.010811115, -0.035571742,\n\t0.027474007, 0.005406069, -0.010159427, -0.006145632, -0.0103273, -0.010435171,\n\t0.011127197, -0.023793709, -0.028009362, 0.00218235, 0.008683152, 0.001440032,\n\n\t// Sector fund 2\n\t-0.019002703, 0.026036835, 0.03782709, 0.010629292, -0.008382267, 0.001121697,\n\t-0.004494407, 0.017304537, -0.006106293, 0.012174645, -0.003305029, 0.027219671,\n\t-0.036089287, -0.00222959, -0.015748493, -0.02061919, -0.011641386, 0.023148757,\n\t-0.002290732, 0.006288094, -0.012038397, -0.029258743, 0.011219297, -0.008846992,\n\t-0.033738048, 0.02061908, -0.012077677, 0.015672887, 0.041012907, 0.052195282,\n\n\t// Sector fund 3\n\t-0.030629136, 0.024918984, -0.001715798, 0.008561614, 0.003406931, -0.010823864,\n\t-0.010361097, -0.009302434, 0.008142014, -0.004064208, 0.000584335, 0.004640294,\n\t0.031893332, -0.013544321, -0.023573641, -0.004665085, -0.006446259, -0.005311412,\n\t0.045096308, -0.007374697, -0.00514201, -0.001715798, -0.005176363, -0.002884991,\n\t0.002309361, -0.014521608, -0.017711709, 0.001192088, -0.00238233, -0.004395918;\n\nX.transposeInPlace();\n```", "```\nVectorXd Y{ 30 };\t// 30 observations of market returns\nY <<\n\t-0.039891316, 0.00178709, -0.0162018, 0.056452057, 0.00342504, -0.012038314,\n\t-0.009997657, 0.013452043, 0.013485674, -0.007898137, 0.008111428, -0.015424523,\n\t-0.002161451, -0.028752191, 0.011292655, -0.007958389, -0.004002386, -0.031690771,\n\t0.026776892, 0.009803957, 0.000886608, 0.01495181, -0.004155781, -0.001535225,\n\t0.013517306, -0.021228542, 0.001988701, -0.02051788, 0.005841347, 0.011248933;\n```", "```\n  0.352339\n-0.0899004\n  0.391252\n```", "```\ncout << svd.matrixU() << endl;\t\t\t// U: n x p = 30 x 3\ncout << svd.matrixV() << endl;\t\t\t// V: p x p = 3 x 3\ncout << svd.singularValues().asDiagonal() << endl;\t\t// Sigma: p x p = 3 x 3\n```", "```\nEigen::BDCSVD<MatrixXd> svd(X, Eigen::ComputeThinU | Eigen::ComputeThinV);\nVectorXd beta = svd.solve(Y);\n```", "```\nMatrixXd cov_basket\n{\n    { 0.01263, 0.00025, -0.00017, 0.00503},\n    { 0.00025, 0.00138,  0.00280, 0.00027},\n    {-0.00017, 0.00280,  0.03775, 0.00480},\n    { 0.00503, 0.00027,  0.00480, 0.02900}\n};\n```", "```\nEigen::LLT<Eigen::MatrixXd> chol{ cov_basket };\nMatrixXd chol_mtx = chol.matrixL();\n```", "```\n    0.1124          0          0          0\n  0.002226  0.0370332          0          0\n-0.0015544  0.0756179   0.178975          0\n 0.0447889 0.00464393  0.0252348   0.162289\n```", "```\nMatrixXd corr_norms{ 4, 6 };\n```", "```\nstd::mt19937_64 mt_norm{ 100 };\t\t// Seed is arbitrary, just set to 100 again\nstd::normal_distribution<> std_nd;\n\nauto std_norm = [&mt_norm, &std_nd](double x)\n{\n    return std_nd(mt_norm);\n};\n```", "```\nfor (auto col : corr_norms.colwise())\n{\n    std::ranges::transform(col,\n        col.begin(), std_norm);\n}\n```", "```\n   0.201395    0.197482     1.22857     1.40751     1.82789   -0.150014\n -0.0769593   0.0830647     1.86252    0.122389   -0.949222    0.667817\n   0.936051     1.16233   -0.642932    0.538005    -1.82688   -0.451039\n-0.00916217    -2.79186   -0.434655  -0.0553752     1.46312    0.345527\n```", "```\nMatrixXd corr_norms = chol_mtx * corr_norms;\n```", "```\n  0.0226368   0.0221969    0.138091    0.158204    0.205455  -0.0168616\n-0.00240174  0.00351574   0.0717097  0.00766557  -0.0310838   0.0243974\n   0.161397    0.214002   0.0238613    0.103356   -0.401585  -0.0299926\n  0.0307971   -0.414526  -0.0230881   0.0681989    0.268808   0.0410757\n```", "```\nVectorXd spots(4);          // Init spot prices from market\nspots << 100.0, 150.0, 25.0, 50.0;\n```", "```\nMatrixXd integ_scens{ corr_norms.rows(), corr_norms.cols() + 1 }\t// 4 x 7 matrix\ninteg_scens.col(0) = spots;\n```", "```\ndouble time_to_maturity = 1.0;\nunsigned num_time_steps = 6;\ndouble dt = time_to_maturity / num_time_steps;\n```", "```\nauto gen_price = [dt, rf_rate](double price, double vol, double corr_norm) -> double\n{\n    double expArg1 = (rf_rate - ((vol * vol) / 2.0)) * dt;\n    double expArg2 = corr_norm * std::sqrt(dt);\n    double next_price = price * std::exp(expArg1 + expArg2);\n    return next_price;\n};\n```", "```\nfor (unsigned j = 1; j < integ_scens.cols(); ++j)\n{\n    for (unsigned i = 0; i < integ_scens.rows(); ++i)\n    {\n        integ_scens(i, j) = gen_price(integ_scens(i, j - 1), vols(i), corr_norms(i, j - 1));\n    }\n}\n```", "```\n100\t\t100.99\t\t101.972\t\t107.952\t\t115.226\t\t125.384\t\t124.6\n150\t\t150.086 \t150.535 \t155.248 \t155.976 \t154.248 \t156.034\n25 \t\t26.6633 \t29.0545 \t29.2955 \t30.5129 \t25.8607 \t25.5082\n50 \t\t50.5946 \t42.6858 \t42.2536  \t43.414 \t\t48.4132 \t49.1949\n```", "```\n\tMatrixXd term_struct_cov_mtx\n\t{\n\t\t// 1 month\n\t\t{ 0.018920,\t0.009889, 0.005820,\t0.005103, 0.003813,\t0.003626,\n\t\t\t0.003136, 0.002646, 0.002015, 0.001438, 0.001303 },\n\n\t\t// 3 months\n\t\t{ 0.0, 0.010107, 0.006123, 0.004796, 0.003532, 0.003414,\n\t\t\t0.002893, 0.002404, 0.001815, 0.001217, 0.001109},\n\n\t\t// 6 months\n\t\t{ 0.0, 0.0, 0.005665, 0.004677, 0.003808, 0.003790,\n\t\t\t0.003255, 0.002771, 0.002179, 0.001567, 0.001400 },\n\n\t\t// 1 year\n\t\t\t{ 0.0, 0.0, 0.0, 0.004830, 0.004695, 0.004672,\n\t\t\t\t0.004126, 0.003606, 0.002952, 0.002238, 0.002007},\n\n\t\t// 2 years\n\t\t{ 0.0, 0.0, 0.0, 0.0, 0.006431, 0.006338,\n\t\t\t0.005789, 0.005162, 0.004337, 0.003343, 0.003004},\n\n\t\t// 3 years\n\t\t{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.006524,\n\t\t\t0.005947, 0.005356, 0.004540, 0.003568, 0.003231 },\n\n\t\t// 5 years\n\t\t{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n\t\t\t0.005800, 0.005291, 0.004552, 0.003669, 0.003352 },\n\n\t\t// 7 years\n\t\t{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.004985, 0.004346, 0.003572, 0.003288 },\n\n\t\t// 10 years\n\t\t{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.003958, 0.003319, 0.003085 },\n\n\t\t// 20 years\n\t\t{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.003062, 0.002858 },\n\n\t\t// 30 years\n\t\t{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0, 0.002814 }\n\t};\n```", "```\nVectorXd eigenvals = term_struct_cov_mtx.selfadjointView<Eigen::Upper>().eigenvalues();\n```", "```\ndouble total_ev = std::accumulate(eigenvals.cbegin(), eigenvals.cend(), 0.0);\nstd::ranges::transform(eigenvals, eigenvals.begin(),\n\t[total_ev](double x) {return x / total_ev; });\n```", "```\nstd::ranges::sort(eigenvals, std::greater{});\n```", "```\n0.67245 0.213209 0.073749\n0.023811 0.00962511 0.00275773\n0.0016744 0.00114298 0.000740139\n0.000528862 0.000311391\n```", "```\nvector<int> v{ 101, 102, 103, 104, 105, 106 };\nauto mds1 = std::mdspan{ v.data(), 3, 2 };\n```", "```\nsize_t n_rows{ mds1.extent(0) };\t\t// 3\nsize_t n_cols{ mds1.extent(1) };\t\t// 2\nsize_t n_extents{ mds1.rank() };\t\t// 2\n```", "```\nfor (size_t i = 0; i < mds1.extent(0); ++i)\n{\n\tfor (size_t j = 0; j < mds1.extent(1); ++j)\n\t\tcout << mds1[i, j] << \"\\t\";\n\n\tcout << \"\\n\";\n}\n```", "```\ndouble ** a[3][2];\t\t// Ugh\n\n// Could put a[2, 1] if it were an mdspan instead:\na[2][1] = 5.4;\n\n...\n\ndelete [] a;\n```", "```\n101     102\n103     104\n105     106\n```", "```\nauto mds2 = std::mdspan(v.data(), 2, 3);\t\t// 2 x 3\n```", "```\n101     102     103\n104     105     106\n```", "```\nv[5] = 874;\n```", "```\n101     102\n103     104\n105     874\n```", "```\n101     102     103\n104     105     874\n```", "```\nauto mds2 = std::mdspan(v.data(), 2, 3);\n```", "```\nvoid dynamic_mdspan(size_t m, size_t n, vector<double> vec)\n{\n\n\tstd::mdspan md{ vec.data(), std::extents{m, n} };\n\n\t. . .\n\n}\n```", "```\nvector<double> w{ 10.1, 10.2, 10.3, 10.4, 10.5, 10.6 };\nsize_t m{3};\nsize_t n{2};\n```", "```\n10.1    10.2\n10.3    10.4\n10.5    10.6\n```", "```\ntemplate<typename T, typename S>\nvoid dynamic_mdspan(S m, S n, T vec)\n{\n\tusing ext_t = std::extents<S, std::dynamic_extent, std::dynamic_extent>;\n\tstd::mdspan<T, ext_t> mds_dyn{ vec.data(), m, n };\n\n\t. . .\n\n}\n```", "```\nstd::layout_left::mapping col_major{ std::extents{ m, n } };\n```", "```\nstd::mdspan md{ v.data(), col_major };\n```", "```\n10.1    10.4\n10.2    10.5\n10.3    10.6\n```", "```\nauto row_1 = std::submdspan(mds1, 0, std::full_extent)\n```", "```\nrow_1[0] = 101  row_1[1] = 102\n```", "```\nauto col_last = std::submdspan(mds1, std::full_extent, mds1.extent(1)-1);\n```", "```\ncol_2[0] = 102  col_2[1] = 104  col_2[2] = 106\n```", "```\ncol_2[2] = 3333;\n```", "```\n101     102\n103     104\n105     3333\n```", "```\nnamespace stdex = std::experimental;\nauto mds1 = stdex::mdspan{ v.data(), 3, 2 };\n\n// Replace the square brackets here:\nfor (size_t i = 0; i < n_rows; ++i)\n{\n\tfor (size_t j = 0; j < n_cols; ++j)\n\t\tcout << mds1[i, j]\t\t\t<< \"\\t\";\n}\n\n// with round brackets:\nfor (size_t i = 0; i < n_rows; ++i)\n{\n\tfor (size_t j = 0; j < n_cols; ++j)\n\t\tcout << mds1(i, j) << \"\\t\";\n}\n```", "```\nxGEMV(.)\n```", "```\nstd::vector<double> A_vec(m * n);\nstd::vector<double> x_vec(n);\n\n// A_vec and x_vec are then populated with data...\n\nstd::vector<double> y_vec(n);\t\t// empty vector\n\nstd::mdspan A{ A_vec.data(), std::extents{m, n} };\nstd::mdspan x{ x_vec.data(), std::extents{n} };\nstd::mdspan y{ y_vec.data(), std::extents{m} };\n```", "```\nstd::linalg::matrix_vector_product(A, x, y); \t// y = A * x\n```"]