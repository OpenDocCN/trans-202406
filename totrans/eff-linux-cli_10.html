<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Building a Brash One-Liner"><div class="chapter" id="ch_one_liner">
<h1><span class="label">Chapter 8. </span>Building a Brash One-Liner</h1>


<p><a data-type="indexterm" data-primary="brash one-liner" id="brash"/><a data-type="indexterm" data-primary="one-liner" data-see="brash one-liner" id="idm46586639005696"/>
Remember this long, intricate command from the preface?<a data-type="indexterm" data-primary="paste command" data-secondary="examples" id="idm46586639004624"/></p>
<pre data-type="programlisting">$ <strong>paste &lt;(echo {1..10}.jpg | sed 's/ /\n/g') \
        &lt;(echo {0..9}.jpg | sed 's/ /\n/g') \
  | sed 's/^/mv /' \
  | bash</strong></pre>

<p>Such magical incantations are called <em>brash one-liners</em><a data-type="indexterm" data-primary="brash one-liner" data-secondary="definition" id="idm46586639002000"/>.<sup><a data-type="noteref" id="idm46586639000896-marker" href="ch08.xhtml#idm46586639000896">1</a></sup>
Let’s take this one apart to understand what it does and how it works.
The innermost <code>echo</code> commands use brace expansion to generate lists of
JPEG filenames:</p>

<pre data-type="programlisting">$ <strong>echo {1..10}.jpg</strong>
1.jpg 2.jpg 3.jpg ... 10.jpg
$ <strong>echo {0..9}.jpg</strong>
0.jpg 1.jpg 2.jpg ... 9.jpg</pre>

<p>Piping the filenames to <code>sed</code> replaces space characters with newlines:</p>

<pre data-type="programlisting">$ <strong>echo {1..10}.jpg | sed 's/ /\n/g'</strong>
1.jpg
2.jpg
⋮
10.jpg
$ <strong>echo {0..9}.jpg | sed 's/ /\n/g'</strong>
0.jpg
1.jpg
⋮
9.jpg</pre>

<p>The <code>paste</code> command prints the two lists side by side. Process
substitution allows <code>paste</code> to read the two lists as if they were
files:<a data-type="indexterm" data-primary="brace expansion" data-secondary="examples" id="idm46586638993584"/></p>
<pre data-type="programlisting">$ <strong>paste &lt;(<mark class="box">echo {1..10}.jpg | sed 's/ /\n/g'</mark>) \
        &lt;(<mark class="box">echo {0..9}.jpg | sed 's/ /\n/g'</mark>)</strong>
1.jpg   0.jpg
2.jpg   1.jpg
⋮
10.jpg  9.jpg</pre>

<p>Prepending <code>mv</code> to each line prints a sequence of strings that are
<code>mv</code> commands:<a data-type="indexterm" data-primary="sed command" data-secondary="examples" id="idm46586638988624"/></p>
<pre data-type="programlisting">$ <strong>paste &lt;(echo {1..10}.jpg | sed 's/ /\n/g') \
        &lt;(echo {0..9}.jpg | sed 's/ /\n/g') \
  | sed 's/^/mv /'</strong>
mv 1.jpg   0.jpg
mv 2.jpg   1.jpg
⋮
mv 10.jpg  9.jpg</pre>

<p>The purpose of the command is now revealed: it generates 10 commands
to rename the image files <em>1.jpg</em> through <em>10.jpg</em>. The new names are
<em>0.jpg</em> through <em>9.jpg</em>, respectively. Piping the output to <code>bash</code>
executes the <code>mv</code> commands:<a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" data-tertiary="examples" id="idm46586638982976"/></p>
<pre data-type="programlisting">$ <strong>paste &lt;(echo {1..10}.jpg | sed 's/ /\n/g') \
        &lt;(echo {0..9}.jpg | sed 's/ /\n/g') \
  | sed 's/^/mv /' \
  | bash</strong></pre>

<p>Brash one-liners are like puzzles. You’re faced with a business
problem, such as renaming a set of files, and you apply your toolbox
to construct a Linux command to solve it. Brash one-liners challenge
your creativity and build your skills.</p>

<p>In this chapter, you’ll create brash one-liners like the preceding
one, step-by-step, using the following magical formula:</p>
<ol>
<li>
<p>Invent a command that solves a piece of the puzzle.</p>
</li>
<li>
<p>Run the command and check the output.</p>
</li>
<li>
<p>Recall the command from history and tweak it.</p>
</li>
<li>
<p>Repeat steps 2 and 3 until the command produces the desired result.</p>
</li>

</ol>

<p>This chapter will give your brain a workout. Expect to feel puzzled at
times by the examples. Just take things one step at a time, and run
the commands on a computer as you read them.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some brash one-liners in this chapter are too wide for a single line,
so I’ve split them onto multiple lines using backslashes.  We do not,
however, call them brash two-liners (or brash seven-liners).</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Get Ready to Be Brash"><div class="sect1" id="idm46586638973840">
<h1>Get Ready to Be Brash</h1>

<p>Before you launch into creating brash one-liners, take a moment to get
into the right mindset:</p>

<ul>
<li>
<p>Be flexible.</p>
</li>
<li>
<p>Think about where to start.</p>
</li>
<li>
<p>Know your testing tools.</p>
</li>
</ul>

<p>I’ll discuss each of these ideas in turn.</p>








<section data-type="sect2" data-pdf-bookmark="Be Flexible"><div class="sect2" id="idm46586638968448">
<h2>Be Flexible</h2>

<p><a data-type="indexterm" data-primary="brash one-liner" data-secondary="flexible thinking" id="idm46586638966912"/>
A key to writing brash one-liners is <em>flexibility</em>. You’ve learned
some awesome tools by this point—a core set of Linux programs (and
umpteen ways to run them) along with command history, command-line
editing, and more. You can combine these tools in many ways, and a
given problem usually has multiple solutions.</p>

<p>Even the simplest Linux tasks can be accomplished in many
ways. Consider how you might list<a data-type="indexterm" data-primary="listing files" data-secondary="many commands for" id="idm46586638964848"/>
<em>.jpg</em> files in your current directory. I’ll bet 99.9% of Linux users
would run a command like this:</p>

<pre data-type="programlisting">$ <strong>ls *.jpg</strong></pre>

<p>But this is just one solution of many. For example, you could list <em>all</em>
the files in the directory and then use <code>grep</code> to match only the
names ending in <em>.jpg</em>:<a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638960432"/></p>
<pre data-type="programlisting">$ <strong>ls | grep '\.jpg$'</strong></pre>

<p>Why would you choose this solution? Well, you saw an example in
<a data-type="xref" href="ch07.xhtml#tip_xargs">“Long Argument Lists”</a>, when a directory contained so many files that
they couldn’t be listed by pattern matching.  The technique of
<em>grepping for a filename extension</em><a data-type="indexterm" data-primary="grep command" data-secondary="filename extensions" id="idm46586638956768"/><a data-type="indexterm" data-primary="filenames" data-secondary="grepping extensions" id="idm46586638955824"/> is a robust, general approach for
solving all sorts of problems. What’s important here is to be
flexible and understand your tools so you can apply the best one
in your time of need. That is a wizard’s skill when creating
brash one-liners.</p>

<p class="pagebreak-before">All of the following commands list <em>.jpg</em> files in the current
directory. Try to figure out how each command works:<a data-type="indexterm" data-primary="paste command" data-secondary="examples" id="idm46586638953200"/><a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586638952224"/><a data-type="indexterm" data-primary="process substitution" data-secondary="examples" id="idm46586638951280"/><a data-type="indexterm" data-primary="find command" data-secondary="examples" id="idm46586638950336"/><a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" data-tertiary="examples" id="idm46586638949392"/><a data-type="indexterm" data-primary="Python" id="idm46586638948176"/><a data-type="indexterm" data-primary="sed command" data-secondary="examples" id="idm46586638947504"/><a data-type="indexterm" data-primary="bash" data-secondary="passing a command as an argument (-c option)" id="idm46586638946560"/><a data-type="indexterm" data-primary="exec command" data-secondary="example" id="idm46586638945520"/></p>
<pre data-type="programlisting">$ <strong>echo $(ls *.jpg)</strong>
$ <strong>bash -c 'ls *.jpg'</strong>
$ <strong>cat &lt;(ls *.jpg)</strong>
$ <strong>find . -maxdepth 1 -type f -name \*.jpg -print</strong>
$ <strong>ls &gt; tmp &amp;&amp; grep '\.jpg$' tmp &amp;&amp; rm -f tmp</strong>
$ <strong>paste &lt;(echo ls) &lt;(echo \*.jpg) | bash</strong>
$ <strong>bash -c 'exec $(paste &lt;(echo ls) &lt;(echo \*.jpg))'</strong>
$ <strong>echo 'monkey *.jpg' | sed 's/monkey/ls/' | bash</strong>
$ <strong>python -c 'import os; os.system("ls *.jpg")'</strong></pre>

<p>Are the results identical or do some commands behave a bit
differently? Can you come up with any other suitable commands?</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Think About Where to Start"><div class="sect2" id="idm46586638967824">
<h2>Think About Where to Start</h2>

<p><a data-type="indexterm" data-primary="simple commands" data-secondary="output" id="idm46586638937984"/><a data-type="indexterm" data-primary="command" data-secondary="simple commands" data-tertiary="output" id="idm46586638937008"/>
Every brash one-liner begins with the output of a simple command.
That output might be the contents of a file, part of a file, a
directory listing, a sequence of numbers or letters, a list of users,
a date and time, or other data. Your first challenge, therefore, is to
produce the initial data for your command.</p>

<p>For example, if you want to know the 17th letter of the English
alphabet,<a data-type="indexterm" data-primary="alphabet" data-secondary="nth letter" id="idm46586638935280"/> then your initial data could be 26 letters produced by
brace expansion:<a data-type="indexterm" data-primary="brace expansion" data-secondary="examples" id="idm46586638934176"/></p>

<pre data-type="programlisting">$ <strong>echo {A..Z}</strong>
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</pre>

<p>Once you can produce this output, the next step is deciding how to
massage it to fit your goal. Do you need to slice the output by rows
or columns? Join the output with other information?  Transform the
output in a more complicated way? Look to the programs in
Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch01.xhtml#ch_combining_commands">1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.xhtml#ch_toolbox">5</a> to do that work, like
<code>grep</code> and <code>sed</code> and <code>cut</code>, and apply them using the techniques of
<a data-type="xref" href="ch07.xhtml#ch_running_commands">Chapter 7</a>.</p>

<p>For this example, you could print the 17th field with <code>awk</code>, or remove
spaces with <code>sed</code> and locate the 17th character with <code>cut</code>:</p>

<pre data-type="programlisting">$ <strong>echo {A..Z} | awk '{print $(17)}'</strong>
Q
$ <strong>echo {A..Z} | sed 's/ //g' | cut -c17</strong>
Q</pre>

<p>As another example, if you want to print the months of the year<a data-type="indexterm" data-primary="months of the year" id="idm46586638923040"/>, your
initial data could be the numbers 1 through 12, again produced by
brace expansion:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>echo {1..12}</strong>
1 2 3 4 5 6 7 8 9 10 11 12</pre>

<p>From there, augment the brace expansion so it forms dates for the
first day of each month (from <code>2021-01-01</code> through <code>2021-12-01</code>); then
run <code>date -d</code> on each line to produce month names:</p>

<pre data-type="programlisting">$ <strong>echo 2021-{01..12}-01 | xargs -n1 date +%B -d</strong>
January
February
March
⋮
December</pre>

<p>Or, suppose you want to know the length of the longest filename in the
current directory.<a data-type="indexterm" data-primary="longest filename in a directory" id="idm46586638917040"/><a data-type="indexterm" data-primary="filenames" data-secondary="longest in directory" id="idm46586638916272"/> Your initial data could be a directory listing:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
animals.txt  cartoon-mascots.txt  ...  zebra-stripes.txt</pre>

<p>From there, use <code>awk</code> to generate commands to count characters in each
filename with <code>wc -c</code>:<a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638912752"/><a data-type="indexterm" data-primary="wc command" data-secondary="examples" id="idm46586638911744"/></p>
<pre data-type="programlisting">$ <strong>ls | awk '{print "echo -n", $0, "| wc -c"}'</strong>
echo -n "animals.txt" | wc -c
echo -n "cartoon-mascots.txt | wc -c"
⋮
echo -n "zebra-stripes.txt | wc -c"</pre>

<p>(The <code>-n</code> option prevents <code>echo</code> from printing newline characters,<a data-type="indexterm" data-primary="newline character" data-secondary="suppressing with echo -n" id="idm46586638908000"/><a data-type="indexterm" data-primary="echo command" data-secondary="suppressing newline (-n option)" id="idm46586638907008"/>
which would throw off each count by one.) Finally, pipe the commands
to <code>bash</code> to run them,<a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" data-tertiary="examples" id="idm46586638905536"/> sort the numeric results from high to low, and
grab the maximum value<a data-type="indexterm" data-primary="maximum value in a file" id="idm46586638904128"/><a data-type="indexterm" data-primary="largest value in a file" id="idm46586638903376"/> (the first line) with <code>head -n1</code>:<a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586638902160"/><a data-type="indexterm" data-primary="head command" data-secondary="examples" id="idm46586638901152"/></p>
<pre data-type="programlisting">$ <strong>ls | awk '{print "echo -n", $0, "| wc -c"}' | bash | sort -nr | head -n1</strong>
23</pre>

<p>This last example was tricky, generating pipelines as strings
and passing them to a further pipeline. Nevertheless, the general
principle is the same: figure out your starting data and manipulate
it to fit your needs.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Know Your Testing Tools"><div class="sect2" id="idm46586638898592">
<h2>Know Your Testing Tools</h2>

<p>Building a brash one-liner may require trial and error. The following
tools and techniques will help you try different solutions quickly:</p>
<dl>
<dt>Use command history and command-line editing.</dt>
<dd>
<p>   Don’t retype commands while you experiment.<a data-type="indexterm" data-primary="command history" data-secondary="brash one-liners" id="idm46586638895248"/> Use techniques from
<a data-type="xref" href="ch03.xhtml#ch_history">Chapter 3</a> to recall previous commands, tweak them, and run them.</p>
</dd>
<dt>Add <code>echo</code> to test your expressions.</dt>
<dd>
<p>   If you aren’t sure how an expression<a data-type="indexterm" data-primary="echo command" data-secondary="testing expressions" id="idm46586638891488"/> will evaluate, print it with
<code>echo</code> beforehand to see the evaluated results on stdout.</p>
</dd>
<dt>Use <code>ls</code> or add <code>echo</code> to test destructive commands.</dt>
<dd>
<p>  If your command invokes <code>rm</code>, <code>mv</code>, <code>cp</code>, or other commands that<a data-type="indexterm" data-primary="ls command" data-secondary="testing destructive commands" id="idm46586638886032"/>
might overwrite or remove files, place <code>echo</code> in front of them to
confirm which files will be affected. (So, instead of executing <code>rm</code>,
execute <code>echo rm</code>.) Another safety tactic is to replace <code>rm</code> with <code>ls</code>
to list files that would be removed.</p>
</dd>
<dt>Insert a <code>tee</code> to view intermediate results.</dt>
<dd>
<p>  If you want to view the output (stdout) <a data-type="indexterm" data-primary="tee command" id="idm46586638880752"/><a data-type="indexterm" data-primary="pipes" data-secondary="pipelines" data-tertiary="viewing intermediate results" id="idm46586638880048"/><a data-type="indexterm" data-primary="output redirection" data-secondary="tee command" id="idm46586638878816"/><a data-type="indexterm" data-primary="redirection" data-secondary="tee command" id="idm46586638877872"/>in the middle of a long
pipeline, insert the <code>tee</code> command to save output to a file for
examination. The following command saves the output from <code>command3</code> in
the file <em>outfile</em>, while piping that same output to <code>command4</code>:</p>

<pre data-type="programlisting">$ <em>command1</em> | <em>command2</em> | <em>command3</em> | <strong>tee outfile</strong> | <em>command4</em> | <em>command5</em>
$ <strong>less outfile</strong></pre>
</dd>
</dl>

<p>OK, let’s build some brash one-liners!</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Inserting a Filename into a Sequence"><div class="sect1" id="section_insert_filename_sequence">
<h1>Inserting a Filename into a Sequence</h1>

<p><a data-type="indexterm" data-primary="sequence of" data-secondary="filenames" id="idm46586638868400"/><a data-type="indexterm" data-primary="inserting a filename into a sequence" id="idm46586638867200"/><a data-type="indexterm" data-primary="filenames" data-secondary="inserting into a sequence" id="idm46586638866528"/>
This brash one-liner is similar to the one that opened the chapter
(renaming <em>.jpg</em> files), but more detailed. It’s also a real situation
I faced while writing this book. Like the previous one-liner, it
combines two techniques from <a data-type="xref" href="ch07.xhtml#ch_running_commands">Chapter 7</a>: process
substitution and piping to <code>bash</code>. The result is a repeatable pattern
for solving similar 
<span class="keep-together">problems.</span></p>

<p>I wrote this book on a Linux computer using a typesetting language
called <a href="https://asciidoc.org">AsciiDoc</a>.<a data-type="indexterm" data-primary="AsciiDoc" id="idm46586638862016"/> The language details aren’t
important here; what matters is each chapter was a separate file, and
originally there were 10 of them:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
ch01.asciidoc  ch03.asciidoc  ch05.asciidoc  ch07.asciidoc  ch09.asciidoc
ch02.asciidoc  ch04.asciidoc  ch06.asciidoc  ch08.asciidoc  ch10.asciidoc</pre>

<p>At some point, I decided to insert an 11th chapter between Chapters
2 and 3. That meant renaming some files. Chapters 3–10 had to become
4–11, leaving a gap so I could make a new Chapter 3
(<em>ch03.asciidoc</em>). I could have renamed the files manually, starting
with <em>ch11.asciidoc</em> and working backward:<sup><a data-type="noteref" id="idm46586638858416-marker" href="ch08.xhtml#idm46586638858416">2</a></sup></p>

<pre data-type="programlisting">$ <strong>mv ch10.asciidoc ch11.asciidoc</strong>
$ <strong>mv ch09.asciidoc ch10.asciidoc</strong>
$ <strong>mv ch08.asciidoc ch09.asciidoc</strong>
⋮
$ <strong>mv ch03.asciidoc ch04.asciidoc</strong></pre>

<p>But this method is tedious (imagine if there were 1,000 files instead of
11!), so instead, I generated the necessary <code>mv</code> commands and piped
them to <code>bash</code>. Take a good look at the preceding <code>mv</code> commands and
think for a moment how you might create them.</p>

<p>Focus first on the original filenames <em>ch03.asciidoc</em> through
<em>ch10.asciidoc</em>. You could print them using brace expansion such as
<code>ch{10..03}.asciidoc</code>, like the first example in this chapter, but to
practice a little flexibility, use the <code>seq -w</code> command to print the
numbers:<a data-type="indexterm" data-primary="seq command" data-secondary="examples" id="idm46586638849072"/></p>

<pre data-type="programlisting">$ <strong>seq -w 10 -1 3</strong>
10
09
08
⋮
03</pre>

<p>Then turn this numeric sequence into filenames by piping it to <code>sed</code>:<a data-type="indexterm" data-primary="sed command" data-secondary="examples" id="idm46586638846048"/></p>
<pre data-type="programlisting">$ <strong>seq -w 10 -1 3 | sed 's/\(.*\)/ch\1.asciidoc/'</strong>
ch10.asciidoc
ch09.asciidoc
⋮
ch03.asciidoc</pre>

<p>You now have a list of the original filenames. Do likewise for
Chapters 4–11 to create the destination filenames:</p>
<pre data-type="programlisting">$ <strong>seq -w 11 -1 4 | sed 's/\(.*\)/ch\1.asciidoc/'</strong>
ch11.asciidoc
ch10.asciidoc
⋮
ch04.asciidoc</pre>

<p>To form the <code>mv</code> commands, you need to print the original and new
filenames side by side. The first example in this chapter solved the
“side by side” problem with <code>paste</code>, and it used process substitution
to treat the two printed lists as files. Do the same here:<a data-type="indexterm" data-primary="paste command" data-secondary="examples" id="idm46586638840512"/><a data-type="indexterm" data-primary="process substitution" data-secondary="examples" id="idm46586638839536"/></p>
<pre data-type="programlisting">$ <strong>paste &lt;(seq -w 10 -1 3 | sed 's/\(.*\)/ch\1.asciidoc/') \
        &lt;(seq -w 11 -1 4 | sed 's/\(.*\)/ch\1.asciidoc/')</strong>
ch10.asciidoc   ch11.asciidoc
ch09.asciidoc   ch10.asciidoc
⋮
ch03.asciidoc   ch04.asciidoc</pre>
<div data-type="tip"><h6>Tip</h6>
<p>The preceding command might look like a lot of typing, but with
command history<a data-type="indexterm" data-primary="command history" data-secondary="brash one-liners" id="idm46586638836048"/> and Emacs-style command-line editing,<a data-type="indexterm" data-primary="command-line editing" data-secondary="brash one-liners" id="idm46586638834944"/> it’s
really not. To go from the single “<code>seq</code> and <code>sed</code>” line to the
<code>paste</code> command:</p>
<ol>
<li>
<p>Recall the previous command from history with the up arrow.</p>
</li>
<li>
<p>Press Ctrl-A and then Ctrl-K to cut the whole line.</p>
</li>
<li>
<p>Type the word <code>paste</code> followed by a space.</p>
</li>
<li>
<p>Press Ctrl-Y twice to create two copies of the <code>seq</code> and <code>sed</code> commands.</p>
</li>
<li>
<p>Use movement and editing keystrokes to modify the second copy.</p>
</li>
<li>
<p>And so on.</p>
</li>

</ol>
</div>

<p>Prepend <code>mv</code><a data-type="indexterm" data-primary="prepending to lines of text" id="idm46586638824176"/><a data-type="indexterm" data-primary="text" data-secondary="prepending to" id="idm46586638823504"/> to each line by piping the output to <code>sed</code>, printing
exactly the <code>mv</code> commands you need:<a data-type="indexterm" data-primary="sed command" data-secondary="examples" id="idm46586638821600"/></p>
<pre data-type="programlisting">$ <strong>paste &lt;(seq -w 10 -1 3 | sed 's/\(.*\)/ch\1.asciidoc/') \
        &lt;(seq -w 11 -1 4 | sed 's/\(.*\)/ch\1.asciidoc/') \
  | sed 's/^/mv /'</strong>
mv ch10.asciidoc    ch11.asciidoc
mv ch09.asciidoc    ch10.asciidoc
⋮
mv ch03.asciidoc    ch04.asciidoc</pre>

<p>As the final step, pipe the commands to <code>bash</code> for execution:<a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" data-tertiary="examples" id="idm46586638818336"/></p>
<pre data-type="programlisting">$ <strong>paste &lt;(seq -w 10 -1 3 | sed 's/\(.*\)/ch\1.asciidoc/') \
        &lt;(seq -w 11 -1 4 | sed 's/\(.*\)/ch\1.asciidoc/') \
  | sed 's/^/mv /' \
  | bash</strong></pre>

<p>I used exactly this solution for my book. After the <code>mv</code> commands ran,
the resulting files were Chapters 1, 2, and 4–11, leaving a gap for a
new Chapter 3:</p>
<pre data-type="programlisting">$ <strong>ls ch*.asciidoc</strong>
ch01.asciidoc  <mark class="box">ch04.asciidoc</mark>  ch06.asciidoc  ch08.asciidoc  ch10.asciidoc
<mark class="box">ch02.asciidoc</mark>  ch05.asciidoc  ch07.asciidoc  ch09.asciidoc  ch11.asciidoc</pre>

<p>The pattern I just presented is reusable in all kinds of situations
to run a sequence of related commands:<a data-type="indexterm" data-primary="sequence of" data-secondary="related commands" id="idm46586638811712"/></p>
<ol>
<li>
<p>Generate the command arguments as lists on stdout.</p>
</li>
<li>
<p>Print the lists side by side with <code>paste</code> and process substitution.</p>
</li>
<li class="pagebreak-before">
<p>Prepend a command name with <code>sed</code> by replacing the beginning-of-line
character (<code>^</code>) with a program name and a space.</p>
</li>
<li>
<p>Pipe the results to <code>bash</code>.</p>
</li>
</ol>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Checking Matched Pairs of Files"><div class="sect1" id="section_matched_pairs">
<h1>Checking Matched Pairs of Files</h1>

<p><a data-type="indexterm" data-primary="matched pairs of files" id="idm46586638802752"/><a data-type="indexterm" data-primary="pairs of files, matching" id="idm46586638801888"/><a data-type="indexterm" data-primary="file" data-secondary="matched pairs of files" id="idm46586638801200"/>
This brash-one liner is inspired by a real use of Mediawiki<a data-type="indexterm" data-primary="Mediawiki" id="idm46586638800128"/>, the
software that powers Wikipedia<a data-type="indexterm" data-primary="Wikipedia software" id="idm46586638799248"/> and thousands of other wikis. Mediawiki
allows users to upload images for display. Most users follow a manual
process via web forms: click Choose File to bring up a file dialog,
navigate to an image file and select it, add a descriptive comment in
the form, and click Upload. Wiki administrators use a more automated
method: a script that reads a whole directory and uploads its
images. Each image file (say, <em>bald_eagle.jpg</em>) is paired with a
text file (<em>bald_eagle.txt</em>) containing a descriptive comment about
the image.</p>

<p>Imagine that you’re faced with a directory filled with hundreds of
image files and text files. You want to confirm that every image file
has a matching text file and vice versa. Here’s a smaller version of
that directory:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
bald_eagle.jpg  blue_jay.jpg  cardinal.txt  robin.jpg  wren.jpg
bald_eagle.txt  cardinal.jpg  oriole.txt    robin.txt  wren.txt</pre>

<p>Let’s develop two different solutions to identify any unmatched
files. For the first solution, create two lists, one for the JPEG
files and one for the text files, and use <code>cut</code> to strip off their
file extensions <em>.txt</em> and <em>.jpg</em>:<a data-type="indexterm" data-primary="cut command" data-secondary="examples" id="idm46586638794080"/></p>
<pre data-type="programlisting">$ <strong>ls *.jpg | cut -d. -f1</strong>
bald_eagle
blue_jay
cardinal
robin
wren
$ <strong>ls *.txt | cut -d. -f1</strong>
bald_eagle
cardinal
oriole
robin
wren</pre>

<p>Then compare the lists with <code>diff</code> using process substitution:<a data-type="indexterm" data-primary="process substitution" data-secondary="examples" id="idm46586638790512"/><a data-type="indexterm" data-primary="diff command" data-secondary="examples" id="idm46586638789536"/></p>
<pre data-type="programlisting">$ <strong>diff &lt;(<mark class="box">ls *.jpg | cut -d. -f1</mark>) &lt;(<mark class="box">ls *.txt | cut -d. -f1</mark>)</strong>
2d1
&lt; blue_jay
3a3
&gt; oriole</pre>

<p>You could stop here, because the output indicates that the first list
has an extra <em>blue_jay</em> (implying <em>blue_jay.jpg</em>) and the second
list has an extra <em>oriole</em> (implying <em>oriole.txt</em>). Nevertheless,
let’s make the results more precise. Eliminate unwanted lines by
grepping for the characters <code>&lt;</code> and <code>&gt;</code> at the beginning of each line:<a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638782592"/></p>
<pre data-type="programlisting">$ <strong>diff &lt;(ls *.jpg | cut -d. -f1) &lt;(ls *.txt | cut -d. -f1) \
  | grep '^[&lt;&gt;]'</strong>
&lt; blue_jay
&gt; oriole</pre>

<p>Then use <code>awk</code> to append the correct file extension to each filename
(<code>$2</code>), based on whether the filename is preceded by a leading <code>&lt;</code> or <code>&gt;</code>:<a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638778368"/></p>
<pre data-type="programlisting">$ <strong>diff &lt;(ls *.jpg | cut -d. -f1) &lt;(ls *.txt | cut -d. -f1) \
  | grep '^[&lt;&gt;]' \
  | awk '/^&lt;/{print $2 ".jpg"} /^&gt;/{print $2 ".txt"}'</strong>
blue_jay.jpg
oriole.txt</pre>

<p>You now have your list of unmatched files. However, this solution has
a subtle bug. Suppose the current directory contained the filename
<em>yellow.canary.jpg</em>, which has two dots. The preceding command would
produce incorrect output:</p>

<pre data-type="programlisting">blue_jay.jpg
oriole.txt
yellow.jpg                       <em>This is wrong</em></pre>

<p>This problem occurs because the two <code>cut</code> commands remove characters
from the first dot onward, instead of the last dot onward, so
<em>yellow.canary.jpg</em> is truncated to <em>yellow</em> rather than
<em>yellow.canary</em>.  To fix this issue, replace <code>cut</code> with <code>sed</code> to
remove characters from the last dot to the end of the string:<a data-type="indexterm" data-primary="sed command" data-secondary="examples" id="idm46586638770560"/></p>
<pre data-type="programlisting">$ <strong>diff &lt;(ls *.jpg | sed 's/\.[^.]*$//') \
       &lt;(ls *.txt | sed 's/\.[^.]*$//') \
  | grep '^[&lt;&gt;]' \
  | awk '/&lt;/{print $2 ".jpg"} /&gt;/{print $2 ".txt"}'</strong>
blue_jay.txt
oriole.jpg
yellow.canary.txt
</pre>

<p>The first solution is now complete. The second solution takes a
different approach. Instead of applying <code>diff</code> to two lists, generate
a single list and weed out matched pairs of filenames. Begin by
removing the file extensions with <code>sed</code> (using the same sed script as
before) and count the occurrences of each string with <code>uniq -c</code>:<a data-type="indexterm" data-primary="uniq command" data-secondary="examples" id="idm46586638766496"/></p>
<pre data-type="programlisting">$ <strong>ls *.{jpg,txt} \
  | sed 's/\.[^.]*$//' \
  | uniq -c</strong>
      2 bald_eagle
      1 blue_jay
      2 cardinal
      1 oriole
      2 robin
      2 wren
      1 yellow.canary</pre>

<p>Each line of output contains either the number <code>2</code>, representing a matched
pair of filenames, or <code>1</code>, representing an unmatched filename. Use
<code>awk</code> to isolate lines that begin with whitespace and a <code>1</code>, and print
only the second field:<a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638761840"/></p>
<pre data-type="programlisting">$ <strong>ls *.{jpg,txt} \
  | sed 's/\.[^.]*$//' \
  | uniq -c \
  | awk '/^ *1 /{print $2}'</strong>
blue_jay
oriole
yellow.canary</pre>

<p>For the final step, how can you add the missing file extensions? Don’t
bother with any complicated string manipulations. Just use <code>ls</code> to
list the actual files in the current directory. Stick an asterisk (a
wildcard) onto the end of each line of output with <code>awk</code>:</p>
<pre data-type="programlisting">$ <strong>ls *.{jpg,txt} \
  | sed 's/\.[^.]*$//' \
  | uniq -c \
  | awk '/^ *1 /{print $2 <mark class="box">"*"</mark>}'</strong>
blue_jay*
oriole*
yellow.canary*</pre>

<p>and feed the lines to <code>ls</code> via command substitution. The shell
performs pattern matching, and <code>ls</code> lists the unmatched filenames.
Done!<a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586638754608"/></p>
<pre data-type="programlisting">$ <strong>ls -1 <mark class="box">$(</mark>ls *.{jpg,txt} \
  | sed 's/\.[^.]*$//' \
  | uniq -c \
  | awk '/^ *1 /{print $2 "*"}'<mark class="box">)</mark></strong>
blue_jay.jpg
oriole.txt
yellow.canary.jpg</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Generating a CDPATH from Your Home Directory"><div class="sect1" id="idm46586638803664">
<h1>Generating a CDPATH from Your Home Directory</h1>

<p><a data-type="indexterm" data-primary="cd command" data-secondary="CDPATH variable" data-tertiary="generating a value" id="idm46586638749600"/><a data-type="indexterm" data-primary="CDPATH variable" data-secondary="generating a value" id="idm46586638748352"/>
In the section <a data-type="xref" href="ch04.xhtml#cs_homedir">“Organize Your Home Directory for Fast Navigation”</a>, you wrote a complicated <code>CDPATH</code> line
by hand. It began with <code>$HOME</code>, followed by all subdi­r⁠ectories of
<code>$HOME</code>, and ended with the relative path <code>..</code> (parent directory):</p>

<pre data-type="programlisting">CDPATH=$HOME:$HOME/Work:$HOME/Family:$HOME/Finances:$HOME/Linux:$HOME/Music:..</pre>

<p class="pagebreak-before">Let’s create a brash one-liner to generate that <code>CDPATH</code> line
automatically, suitable for insertion into a <code>bash</code> configuration
file. Begin with the list of subdirectories in <code>$HOME</code>, using a
subshell to prevent the <code>cd</code> command from changing your shell’s
current 
<span class="keep-together">directory:</span><a data-type="indexterm" data-primary="subshell" data-secondary="examples" id="idm46586638740656"/></p>
<pre data-type="programlisting">$ <strong>(cd &amp;&amp; ls -d */)</strong>
Family/  Finances/  Linux/  Music/  Work/</pre>

<p>Add <code>$HOME/</code> in front of each directory with <code>sed</code>:<a data-type="indexterm" data-primary="sed command" data-secondary="examples" id="idm46586638737344"/></p>
<pre data-type="programlisting">$ <strong>(cd &amp;&amp; ls -d */) | sed 's/^/$HOME\//g'</strong>
$HOME/Family/
$HOME/Finances/
$HOME/Linux/
$HOME/Music/
$HOME/Work/</pre>

<p>The preceding sed script is slightly complicated because the
replacement string, <code>$HOME/</code>, contains a forward slash, and <code>sed</code>
substitutions also use the forward slash as a separator. That’s why
my slash is escaped: <code>$HOME\/</code>. To simplify
things, recall from <a data-type="xref" href="ch05.xhtml#tip_sed_slash">“Substitution and Slashes”</a> that <code>sed</code> accepts any
convenient character as a separator. Let’s use at signs (<code>@</code>)
instead of forward slashes so no escaping is needed:</p>
<pre data-type="programlisting">$ <strong>(cd &amp;&amp; ls -d */) | sed 's@^@$HOME/@g'</strong>
$HOME/Family/
$HOME/Finances/
$HOME/Linux/
$HOME/Music/
$HOME/Work/</pre>

<p>Next, lop off the final forward slash with another <code>sed</code> expression:</p>
<pre data-type="programlisting">$ <strong>(cd &amp;&amp; ls -d */) | sed -e 's@^@$HOME/@' -e 's@/$@@'</strong>
$HOME/Family
$HOME/Finances
$HOME/Linux
$HOME/Music
$HOME/Work</pre>

<p>Print the output on a single line using <code>echo</code> and command
substitution. Notice that you no longer need plain parentheses around
<code>cd</code> and <code>ls</code> to create a subshell explicitly, because command
substitution creates a subshell of its own:<a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586638725968"/></p>
<pre data-type="programlisting">$ <strong>echo $(cd &amp;&amp; ls -d */ | sed -e 's@^@$HOME/@' -e 's@/$@@')</strong>
$HOME/Family $HOME/Finances $HOME/Linux $HOME/Music $HOME/Work</pre>

<p>Add the first directory <code>$HOME</code> and the final relative directory <code>..</code>:</p>
<pre data-type="programlisting" class="pagebreak-after">$ <strong>echo '$HOME' \
       $(cd &amp;&amp; ls -d */ | sed -e 's@^@$HOME/@' -e 's@/$@@') \
       ..</strong>
$HOME $HOME/Family $HOME/Finances $HOME/Linux $HOME/Music $HOME/Work ..</pre>

<p>Change spaces to colons by piping all the output so far to <code>tr</code>:<a data-type="indexterm" data-primary="tr command" data-secondary="examples" id="idm46586638719904"/></p>
<pre data-type="programlisting">$ <strong>echo '$HOME' \
       $(cd &amp;&amp; ls -d */ | sed -e 's@^@$HOME/@' -e 's@/$@@') \
       .. \
  | tr ' ' ':'</strong>
$HOME:$HOME/Family:$HOME/Finances:$HOME/Linux:$HOME/Music:$HOME/Work:..</pre>

<p>Finally, add the <code>CDPATH</code> environment variable, and you have generated
a variable definition to paste into a <code>bash</code> configuration file. Store this
command in a script to generate the line anytime, like when you add a
new subdirectory to <code>$HOME</code>:</p>
<pre data-type="programlisting">$ <strong>echo 'CDPATH=$HOME' \
       $(cd &amp;&amp; ls -d */ | sed -e 's@^@$HOME/@' -e 's@/$@@') \
       .. \
  | tr ' ' ':'</strong>
CDPATH=$HOME:$HOME/Family:$HOME/Finances:$HOME/Linux:$HOME/Music:$HOME/Work:..</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Generating Test Files"><div class="sect1" id="section_generate_test">
<h1>Generating Test Files</h1>

<p><a data-type="indexterm" data-primary="test files, generating" id="gentestfiles"/><a data-type="indexterm" data-primary="creating files" data-secondary="test files" id="gentestfiles2"/><a data-type="indexterm" data-primary="file" data-secondary="test files" id="gentestfiles3"/>
A common task in the software industry is testing—feeding a wide
variety of data to a program to validate that the program behaves as
intended. The next brash one-liner generates one thousand files containing
random text that could be used in software testing. The number one thousand
is arbitrary; you can generate as many files as you want.</p>

<p>The solution will select words randomly from a large text file and
create one thousand smaller files with random contents and lengths. A perfect
source file is the system dictionary <em>/usr/share/dict/words</em>,<a data-type="indexterm" data-primary="/usr/share/dict/words file" data-see="dictionary file" id="idm46586638707648"/><a data-type="indexterm" data-primary="/usr/share/dict/words file" data-see="dictionary file" data-primary-sortas="usr share dict words file" id="idm46586638706672"/><a data-type="indexterm" data-primary="dictionary file" id="idm46586638705424"/><a data-type="indexterm" data-primary="system dictionary" data-see="dictionary file" id="idm46586638704752"/><a data-type="indexterm" data-primary="words file" data-see="dictionary file" id="idm46586638703808"/> which
contains 102,305 words, each on its own line.<a data-type="indexterm" data-primary="wc command" data-secondary="examples" id="idm46586638702672"/></p>

<pre data-type="programlisting">$ <strong>wc -l /usr/share/dict/words</strong>
102305 /usr/share/dict/words</pre>

<p>To produce this brash one-liner, you’ll need to solve four puzzles:</p>
<ol>
<li>
<p>Randomly shuffling the dictionary file</p>
</li>
<li>
<p>Selecting a random number of lines from the dictionary file</p>
</li>
<li>
<p>Creating an output file to hold the results</p>
</li>
<li>
<p>Running your solution one thousand times</p>
</li>

</ol>

<p>To shuffle the dictionary into random order, use the aptly named
command <code>shuf</code>.<a data-type="indexterm" data-primary="shuf command" id="idm46586638694800"/><a data-type="indexterm" data-primary="random" data-secondary="shuffle" id="idm46586638694064"/> Each run of the command <code>shuf /usr/share/dict/words</code>
produces more than a hundred thousand lines of output, so peek at the first few
random lines using <code>head</code>:<a data-type="indexterm" data-primary="head command" data-secondary="examples" id="idm46586638692064"/></p>

<pre data-type="programlisting" class="pagebreak-before">$ <strong>shuf /usr/share/dict/words | head -n3</strong>
evermore
shirttail
tertiary
$ <strong>shuf /usr/share/dict/words | head -n3</strong>
interactively
opt
perjurer</pre>

<p>Your first puzzle is solved. Next, how can you select a random
quantity of lines from the shuffled dictionary? <code>shuf</code> has an option,
<code>-n</code>,<a data-type="indexterm" data-primary="shuf command" data-secondary="number of lines (-n option)" id="idm46586638687664"/> to print a given number of lines, but you want the value to
change for each output file you create. Fortunately, <code>bash</code> has a
variable, <code>RANDOM</code>,<a data-type="indexterm" data-primary="RANDOM variable" id="idm46586638685552"/><a data-type="indexterm" data-primary="variables" data-secondary="RANDOM" id="idm46586638684816"/><a data-type="indexterm" data-primary="random" data-secondary="number generator" id="idm46586638683872"/> that holds a random positive integer between 0 and
32,767. Its value changes every time you access the variable:</p>

<pre data-type="programlisting">$ <strong>echo $RANDOM $RANDOM $RANDOM</strong>
7855 11134 262</pre>

<p>Therefore, run <code>shuf</code> with the option <code>-n $RANDOM</code> to print a random
number of random lines. Again, the full output could be very long, so
pipe the results to <code>wc -l</code> to confirm that the number of lines
changes with each execution:<a data-type="indexterm" data-primary="wc command" data-secondary="examples" id="idm46586638679872"/></p>

<pre data-type="programlisting">$ <strong>shuf -n $RANDOM /usr/share/dict/words | wc -l</strong>
9922
$ <strong>shuf -n $RANDOM /usr/share/dict/words | wc -l</strong>
32465</pre>

<p>You’ve solved the second puzzle. Next, you need one thousand output files, or
more specifically, one thousand different filenames. To generate filenames,
run the program <code>pwgen</code>,<a data-type="indexterm" data-primary="pwgen command" id="idm46586638676144"/><a data-type="indexterm" data-primary="password generator" id="idm46586638675408"/>
which generates random strings<a data-type="indexterm" data-primary="random" data-secondary="strings" id="idm46586638674560"/> of letters and digits:</p>

<pre data-type="programlisting">$ <strong>pwgen</strong>
eng9nooG ier6YeVu AhZ7naeG Ap3quail poo2Ooj9 OYiuri9m iQuash0E voo3Eph1
IeQu7mi6 eipaC2ti exah8iNg oeGhahm8 airooJ8N eiZ7neez Dah8Vooj dixiV1fu
Xiejoti6 ieshei2K iX4isohk Ohm5gaol Ri9ah4eX Aiv1ahg3 Shaew3ko zohB4geu
⋮</pre>

<p>Add the option <code>-N1</code><a data-type="indexterm" data-primary="pwgen command" data-secondary="number of strings (-N option)" id="idm46586638671616"/> to generate
just a single string, and specify the string length (10) as an argument:</p>

<pre data-type="programlisting">$ <strong>pwgen -N1 10</strong>
ieb2ESheiw</pre>

<p>Optionally, make the string look more like the name of a text file, using
command substitution:<a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586638668688"/></p>

<pre data-type="programlisting">$ <strong>echo $(pwgen -N1 10).txt</strong>
ohTie8aifo.txt</pre>

<p>Third puzzle complete! You now have all the tools to generate a single
random text file. Use the <code>-o</code> option of <code>shuf</code><a data-type="indexterm" data-primary="shuf command" data-secondary="output file (-o option)" id="idm46586638665344"/> to save its output in
a file:</p>

<pre data-type="programlisting">$ <strong>mkdir -p /tmp/randomfiles &amp;&amp; cd /tmp/randomfiles</strong>
$ <strong>shuf -n $RANDOM -o $(pwgen -N1 10).txt /usr/share/dict/words</strong></pre>

<p>and check the results:<a data-type="indexterm" data-primary="head command" data-secondary="examples" id="idm46586638662272"/></p>

<pre data-type="programlisting">$ <strong>ls</strong>                           <em>List the new file</em>
Ahxiedie2f.txt
$ <strong>wc -l Ahxiedie2f.txt</strong>         <em>How many lines does it contain?</em>
13544 Ahxiedie2f.txt
$ <strong>head -n3 Ahxiedie2f.txt</strong>      <em>Peek at the first few lines</em>
saviors
guerillas
forecaster</pre>

<p>Looks good! The final puzzle is how to run the preceding <code>shuf</code>
command one thousand times. You could certainly use a loop:<a data-type="indexterm" data-primary="for loop" data-secondary="bash" id="idm46586638656848"/></p>

<pre data-type="programlisting" data-code-language="bash"><code class="k">for</code> i <code class="k">in</code> <code class="o">{</code><code class="m">1</code>..1000<code class="o">}</code><code class="p">;</code> <code class="k">do</code>
  shuf -n <code class="nv">$RANDOM</code> -o <code class="k">$(</code>pwgen -N1 <code class="m">10</code><code class="k">)</code>.txt /usr/share/dict/words
<code class="k">done</code></pre>

<p>but that’s not as fun as creating a brash one-liner.
Instead, let’s pregenerate the commands, as strings,
and pipe them to <code>bash</code>. As a test, print your desired command once
using <code>echo</code>.  Add single quotes to ensure that <code>$RANDOM</code>
doesn’t evaluate and <code>pwgen</code> doesn’t run:</p>

<pre data-type="programlisting">$ <strong>echo 'shuf -n $RANDOM -o $(pwgen -N1 10).txt /usr/share/dict/words'</strong>
shuf -n $RANDOM -o $(pwgen -N1 10).txt /usr/share/dict/words</pre>

<p>This command can easily be piped to <code>bash</code> for execution:<a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" data-tertiary="examples" id="idm46586638633120"/></p>

<pre data-type="programlisting">$ <strong>echo 'shuf -n $RANDOM -o $(pwgen -N1 10).txt /usr/share/dict/words' | bash</strong>
$ <strong>ls</strong>
eiFohpies1.txt</pre>

<p>Now, print the command one thousand times using the <code>yes</code> command piped to <code>head</code>, then
pipe the results to <code>bash</code>, and you’ve solved the fourth puzzle:<a data-type="indexterm" data-primary="yes command" data-secondary="examples" id="idm46586638628592"/></p>

<pre data-type="programlisting">$ <strong>yes 'shuf -n $RANDOM -o $(pwgen -N1 10).txt /usr/share/dict/words' \
  | head -n 1000 \
  | bash</strong>
$ <strong>ls</strong>
Aen1lee0ir.txt  IeKaveixa6.txt  ahDee9lah2.txt paeR1Poh3d.txt
Ahxiedie2f.txt  Kas8ooJahK.txt  aoc0Yoohoh.txt sohl7Nohho.txt
CudieNgee4.txt  Oe5ophae8e.txt  haiV9mahNg.txt uchiek3Eew.txt
⋮</pre>

<p>If you’d prefer one thousand random image files<a data-type="indexterm" data-primary="creating files" data-secondary="image files" id="idm46586638625568"/><a data-type="indexterm" data-primary="image files, generating" id="idm46586638624208"/> instead of text files, use the
same technique (<code>yes</code>, <code>head</code>, and <code>bash</code>) and replace <code>shuf</code> with a command
that generates a random image. Here’s a brash one-liner that I adapted from a
<a href="https://oreil.ly/ruDwG">solution
by Mark Setchell on Stack Overflow</a>. It runs the command <code>convert</code>,<a data-type="indexterm" data-primary="convert command" id="idm46586638620464"/>
from the graphics package ImageMagick<a data-type="indexterm" data-primary="ImageMagick" id="idm46586638619600"/>, to produce random images of
size 100 x 100 pixels consisting of multicolored squares:<a data-type="indexterm" data-startref="gentestfiles" id="idm46586638597872"/><a data-type="indexterm" data-startref="gentestfiles2" id="idm46586638597264"/><a data-type="indexterm" data-startref="gentestfiles3" id="idm46586638596624"/></p>

<pre data-type="programlisting">$ <strong>yes 'convert -size 8x8 xc: +noise Random -scale 100x100 $(pwgen -N1 10).png' \
  | head -n 1000 \
  | bash</strong>
$ <strong>ls</strong>
Bahdo4Yaop.png  Um8ju8gie5.png  aing1QuaiX.png  ohi4ziNuwo.png
Eem5leijae.png  Va7ohchiep.png  eiMoog1kou.png  ohnohwu4Ei.png
Eozaing1ie.png  Zaev4Quien.png  hiecima2Ye.png  quaepaiY9t.png
⋮
$ <strong>display Bahdo4Yaop.png</strong>              <em>View the first image</em></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Generating Empty Files"><div class="sect1" id="idm46586638713472">
<h1>Generating Empty Files</h1>

<p><a data-type="indexterm" data-primary="creating files" data-secondary="empty files" id="idm46586638592864"/><a data-type="indexterm" data-primary="empty file creation" data-secondary="in bulk" id="idm46586638591888"/><a data-type="indexterm" data-primary="file" data-secondary="empty" id="idm46586638590944"/>
Sometimes all you need for testing is lots of files with different
names, even if they’re empty. Generating a thousand empty files named
<em>file0001.txt</em> through <em>file1000.txt</em> is as simple as:<a data-type="indexterm" data-primary="touch command" data-secondary="examples" id="idm46586638588880"/></p>

<pre data-type="programlisting">$ <strong>mkdir /tmp/empties</strong>           <em>Create a directory for the files</em>
$ <strong>cd /tmp/empties</strong>
$ <strong>touch file{01..1000}.txt</strong>     <em>Generate the files</em></pre>

<p>If you prefer more interesting filenames, grab them randomly from the
system dictionary. Use <code>grep</code> to limit the names to lowercase letters
for simplicity (avoiding spaces, apostrophes, and other characters that
would be special to the shell):<a data-type="indexterm" data-primary="dictionary file" id="idm46586638584016"/><a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638583312"/></p>
<pre data-type="programlisting">$ <strong>grep '^[a-z]*$' /usr/share/dict/words</strong>
a
aardvark
aardvarks
⋮</pre>

<p>Shuffle the names with <code>shuf</code> and print the first thousand with <code>head</code>:<a data-type="indexterm" data-primary="shuf command" data-secondary="examples" id="idm46586638579920"/><a data-type="indexterm" data-primary="head command" data-secondary="examples" id="idm46586638578912"/></p>
<pre data-type="programlisting">$ <strong>grep '^[a-z]*$' /usr/share/dict/words | shuf | head -n1000</strong>
triplicating
quadruplicates
podiatrists
⋮</pre>

<p>Finally, pipe the results to <code>xargs</code> to create the files with <code>touch</code>:<a data-type="indexterm" data-primary="xargs command" data-secondary="examples" id="idm46586638575552"/></p>
<pre data-type="programlisting" class="pagebreak-after">$ <strong>grep '^[a-z]*$' /usr/share/dict/words | shuf | head -n1000 | xargs touch</strong>
$ <strong>ls</strong>
abases             distinctly      magnolia         sadden
abets              distrusts       maintaining      sales
aboard             divided         malformation     salmon
⋮</pre>
</div></section>













<section data-type="sect1" class="less_space" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586638572304">
<h1>Summary</h1>

<p>I hope the examples in this chapter helped to build your skills in
writing brash one-liners. Several of them provided reusable patterns
that you may find useful in other situations.</p>

<p>One caveat: brash one-liners are not the only solution in town.
They’re just one approach to working efficiently at the command line.
Sometimes you’ll get more bang for the buck by writing a shell
script. Other times you’ll find better solutions with a programming
language such as Perl or Python. Nevertheless, brash one-liner-writing
is a vital skill for performing critical tasks with speed and style.
<a data-type="indexterm" data-startref="brash" id="idm46586638570288"/></p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586639000896"><sup><a href="ch08.xhtml#idm46586639000896-marker">1</a></sup> The earliest use of this term (that I know of) is the <a href="https://oreil.ly/ro621">manpage for lorder(1)</a> in BSD Unix 4.x. Thanks to Bob Byrnes for finding it.</p><p data-type="footnote" id="idm46586638858416"><sup><a href="ch08.xhtml#idm46586638858416-marker">2</a></sup> Starting with <em>ch03.asciidoc</em> and working forward would be dangerous—can you see why? If not, create these files with the command <code>touch ch{01..10}.asciidoc</code><a data-type="indexterm" data-primary="touch command" data-secondary="examples" id="idm46586638856880"/> and try it yourself.</p></div></div></section></div></body></html>