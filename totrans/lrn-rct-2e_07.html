<html><head></head><body><section data-pdf-bookmark="Chapter 7. Enhancing Components with Hooks" data-type="chapter" epub:type="chapter"><div class="chapter" id="enhancing_components_with_hooks">&#13;
<h1><span class="label">Chapter 7. </span>Enhancing Components with Hooks</h1>&#13;
&#13;
&#13;
<p>Rendering<a data-primary="hooks" data-secondary="enhancing components with" data-type="indexterm" id="idm45901635799544"/><a data-primary="components" data-secondary="enhancing with hooks" data-type="indexterm" id="idm45901635798568"/> is the heartbeat of a React application. When something changes (props, state), the component tree rerenders, reflecting the latest data as a user interface. So far, <code>useState</code> has been our workhorse for describing how our components should be rendering. But we can do more. There are more Hooks that define rules about why and when rendering should happen. There are more Hooks that enhance rendering performance. There are always more Hooks to help us out.</p>&#13;
&#13;
<p>In the last chapter, we introduced <code>useState</code>, <code>useRef</code>, and <code>useContext</code>, and we saw that we could compose these Hooks into our own custom Hooks: <code>useInput</code> and <code>useColors</code>. There’s more where that came from, though. React comes with more Hooks out of the box. In this chapter, we’re going to take a closer look at <code>useEffect</code>, <code>useLayoutEffect</code>, and <code>useReducer</code>. All of these are vital when building applications. We’ll also look at <code>useCallback</code> and <code>useMemo</code>, which can help optimize our components for performance.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introducing useEffect" data-type="sect1"><div class="sect1" id="idm45901635795928">&#13;
<h1>Introducing useEffect</h1>&#13;
&#13;
<p>We<a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="introduction to" data-type="indexterm" id="Heffect07"/><a data-primary="useEffect hook" data-secondary="introduction to" data-type="indexterm" id="UEintro07"/> now have a good sense of what happens when we render a component. A component is simply a function that renders a user interface. Renders occur when the app first loads and when props and state values change. But what happens when we need to do something after a render? Let’s take a closer look.</p>&#13;
&#13;
<p>Consider<a data-primary="checkboxes" data-type="indexterm" id="checkbox07"/> a simple component, the <code>Checkbox</code>. We’re using <code>useState</code> to set a <code>checked</code> value and a function to change the value of <code>checked</code>: <code>setChecked</code>. A user can check and uncheck the box, but how might we alert the user that the box has been checked? Let’s try this with an <code>alert</code>, as it’s a great way to block the thread:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Checkbox</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">setChecked</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">alert</code><code class="p">(</code><code class="sb">`checked: </code><code class="si">${</code><code class="nx">checked</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code>&#13;
        <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code>&#13;
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code>&#13;
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setChecked</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
      <code class="p">{</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"checked"</code> <code class="o">:</code> <code class="s2">"not checked"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>We’ve added the <code>alert</code> before the render to block the render. The component will not render until the user clicks the OK button on the alert box. Because the alert is blocking, we don’t see the next state of the checkbox rendered until clicking OK.</p>&#13;
&#13;
<p>That isn’t the goal, so maybe we should place the alert after the return?</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Checkbox</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">setChecked</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code>&#13;
        <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code>&#13;
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code>&#13;
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setChecked</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
      <code class="p">{</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"checked"</code> <code class="o">:</code> <code class="s2">"not checked"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
&#13;
  <code class="nx">alert</code><code class="p">(</code><code class="sb">`checked: </code><code class="si">${</code><code class="nx">checked</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Scratch that. We can’t call <code>alert</code> after the render because the code will never be reached. To ensure that we see the <code>alert</code> as expected, we can use <code>useEffect</code>. Placing the <code>alert</code> inside of the <code>useEffect</code> function means that the function will be called after the render, as a side effect:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Checkbox</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">setChecked</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">alert</code><code class="p">(</code><code class="sb">`checked: </code><code class="si">${</code><code class="nx">checked</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code>&#13;
        <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code>&#13;
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code>&#13;
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setChecked</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
      <code class="p">{</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"checked"</code> <code class="o">:</code> <code class="s2">"not checked"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>We use <code>useEffect</code> when a render needs to cause side effects. Think of a side effect as something that a function does that isn’t part of the return. The function is the <code>Checkbox</code>. The <code>Checkbox</code> function renders UI. But we might want the component to do more than that. Those things we want the component to do other than return UI are called <em>effects</em>.</p>&#13;
&#13;
<p>An <code>alert</code>, a <code>console.log</code>, or an interaction with a browser or native API is not part of the render. It’s not part of the return. In a React app, though, the render affects the results of one of these events. We can use <code>useEffect</code> to wait for the render, then provide the values to an <code>alert</code> or a <code>console.log</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"Yes, checked"</code> <code class="o">:</code> <code class="s2">"No, not checked"</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Similarly, we could check in with the value of <code>checked</code> on render and then set that to a value in <code>localStorage</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">localStorage</code><code class="p">.</code><code class="nx">setItem</code><code class="p">(</code><code class="s2">"checkbox-value"</code><code class="p">,</code> <code class="nx">checked</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We might also use <code>useEffect</code> to focus on a specific text input that has been added to the DOM. React will render the output, then call <code>useEffect</code> to focus the element:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">txtInputRef</code><code class="p">.</code><code class="nx">current</code><code class="p">.</code><code class="nx">focus</code><code class="p">();</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>On <code>render</code>, the <code>txtInputRef</code> will have a value. We can access that value in the effect to apply the focus. Every time we render, <code>useEffect</code> has access to the latest values from that render: props, state, refs, etc.</p>&#13;
&#13;
<p>Think of <code>useEffect</code> as being a function that happens after a render. When a render fires, we can access the current state values within our component and use them to do something else. Then, once we render again, the whole thing starts over. New values, new renders, new effects.<a data-primary="" data-startref="checkbox07" data-type="indexterm" id="idm45901635338712"/><a data-primary="" data-startref="Heffect07" data-type="indexterm" id="idm45901635337736"/><a data-primary="" data-startref="UEintro07" data-type="indexterm" id="idm45901635336792"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Dependency Array" data-type="sect2"><div class="sect2" id="idm45901635335720">&#13;
<h2>The Dependency Array</h2>&#13;
&#13;
<p><code>useEffect</code> is<a data-primary="useEffect hook" data-secondary="dependency arrays" data-type="indexterm" id="UEHdepend07"/><a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="dependency arrays" data-type="indexterm" id="Husedepen07"/><a data-primary="dependencies" data-secondary="dependency arrays" data-type="indexterm" id="Adepen07"/> designed to work in conjunction with other stateful Hooks like <span class="keep-together"><code>useState</code></span> and the heretofore unmentioned <code>useReducer</code>, which we promise to discuss later in the chapter. React will rerender the component tree when the state changes. As we’ve learned, <code>useEffect</code> will be called after these renders.</p>&#13;
&#13;
<p>Consider the following, where the <code>App</code> component has two separate state values:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code><code class="p">,</code> <code class="nx">useEffect</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="s2">"./App.css"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">val</code><code class="p">,</code> <code class="nx">set</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">phrase</code><code class="p">,</code> <code class="nx">setPhrase</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">"example phrase"</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">createPhrase</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">setPhrase</code><code class="p">(</code><code class="nx">val</code><code class="p">);</code>&#13;
    <code class="nx">set</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`typing "</code><code class="si">${</code><code class="nx">val</code><code class="si">}</code><code class="sb">"`</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`saved phrase: "</code><code class="si">${</code><code class="nx">phrase</code><code class="si">}</code><code class="sb">"`</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">label</code><code class="o">&gt;</code><code class="nx">Favorite</code> <code class="nx">phrase</code><code class="o">:&lt;</code><code class="err">/label&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code>&#13;
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">val</code><code class="p">}</code>&#13;
        <code class="nx">placeholder</code><code class="o">=</code><code class="p">{</code><code class="nx">phrase</code><code class="p">}</code>&#13;
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">set</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">createPhrase</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">send</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>val</code> is a state variable that represents the value of the input field. The <code>val</code> changes every time the value of the input field changes. It causes the component to render every time the user types a new character. When the user clicks the Send button, the <code>val</code> of the text area is saved as the phrase, and the <code>val</code> is reset to <code>""</code>, which empties the text field.</p>&#13;
&#13;
<p>This works as expected, but the <code>useEffect</code> hook is invoked more times than it should be. After every render, both <code>useEffect</code> Hooks are called:</p>&#13;
&#13;
<pre data-type="programlisting">typing ""                             // First Render&#13;
saved phrase: "example phrase"        // First Render&#13;
typing "S"                            // Second Render&#13;
saved phrase: "example phrase"        // Second Render&#13;
typing "Sh"                           // Third Render&#13;
saved phrase: "example phrase"        // Third Render&#13;
typing "Shr"                          // Fourth Render&#13;
saved phrase: "example phrase"        // Fourth Render&#13;
typing "Shre"                         // Fifth Render&#13;
saved phrase: "example phrase"        // Fifth Render&#13;
typing "Shred"                        // Sixth Render&#13;
saved phrase: "example phrase"        // Sixth Render</pre>&#13;
&#13;
<p>We don’t want every effect to be invoked on every render. We need to associate <code>useEffect</code> hooks with specific data changes. To solve this problem, we can incorporate the dependency array. The dependency array can be used to control when an effect is invoked:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`typing "</code><code class="si">${</code><code class="nx">val</code><code class="si">}</code><code class="sb">"`</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">val</code><code class="p">]);</code>&#13;
&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`saved phrase: "</code><code class="si">${</code><code class="nx">phrase</code><code class="si">}</code><code class="sb">"`</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">phrase</code><code class="p">]);</code></pre>&#13;
&#13;
<p>We’ve added the dependency array to both effects to control when they’re invoked. The first effect is only invoked when the <code>val</code> value has changed. The second effect is only invoked when the <code>phrase</code> value has changed. Now, when we run the app and take a look at the console, we’ll see more efficient updates occurring:</p>&#13;
&#13;
<pre data-type="programlisting">typing ""                              // First Render&#13;
saved phrase: "example phrase"         // First Render&#13;
typing "S"                             // Second Render&#13;
typing "Sh"                            // Third Render&#13;
typing "Shr"                           // Fourth Render&#13;
typing "Shre"                          // Fifth Render&#13;
typing "Shred"                         // Sixth Render&#13;
typing ""                              // Seventh Render&#13;
saved phrase: "Shred"                  // Seventh Render</pre>&#13;
&#13;
<p>Changing the <code>val</code> value by typing into the input only causes the first effect to fire. When we click the button, the <code>phrase</code> is saved and the <code>val</code> is reset to <code>""</code>.</p>&#13;
&#13;
<p>It’s an array after all, so it’s possible to check multiple values in the dependency array. Let’s say we wanted to run a specific effect any time either the <code>val</code> or <code>phrase</code> has changed:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"either val or phrase has changed"</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">val</code><code class="p">,</code> <code class="nx">phrase</code><code class="p">]);</code></pre>&#13;
&#13;
<p>If either of those values changes, the effect will be called again. It’s also possible to supply an empty array as the second argument to a <code>useEffect</code> function. An empty dependency array causes the effect to be invoked only once after the initial render:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"only once after initial render"</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[]);</code></pre>&#13;
&#13;
<p>Since there are no dependencies in the array, the effect is invoked for the initial render. No dependencies means no changes, so the effect will never be invoked again. Effects that are only invoked on the first render are extremely useful for initialization:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">welcomeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
<code class="p">},</code> <code class="p">[]);</code></pre>&#13;
&#13;
<p>If you return a function from the effect, the function will be invoked when the component is removed from the tree:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">welcomeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">goodbyeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
<code class="p">},</code> <code class="p">[]);</code></pre>&#13;
&#13;
<p>This means that you can use <code>useEffect</code> for setup and teardown. The empty array means that the welcome chime will play once on first render. Then, we’ll return a function as a cleanup function to play a goodbye chime when the component is removed from the tree.</p>&#13;
&#13;
<p>This pattern is useful in many situations. Perhaps we’ll subscribe to a news feed on first render. Then we’ll unsubscribe from the news feed with the cleanup function. More specifically, we’ll start by creating a state value for <code>posts</code> and a function to change that value, called <code>setPosts</code>. Then we’ll create a function, <code>addPosts</code>, that will take in the newest post and add it to the array. Then we can use <code>useEffect</code> to subscribe to the news feed and play the chime. Plus, we can return the cleanup functions, unsubscribing and playing the goodbye chime:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="p">[</code><code class="nx">posts</code><code class="p">,</code> <code class="nx">setPosts</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">([]);</code>&#13;
<code class="kr">const</code> <code class="nx">addPost</code> <code class="o">=</code> <code class="nx">post</code> <code class="o">=&gt;</code> <code class="nx">setPosts</code><code class="p">(</code><code class="nx">allPosts</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">post</code><code class="p">,</code> <code class="p">...</code><code class="nx">allPosts</code><code class="p">]);</code>&#13;
&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
  <code class="nx">welcomeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">unsubscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
    <code class="nx">goodbyeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">},</code> <code class="p">[]);</code></pre>&#13;
&#13;
<p>This is a lot going on in <code>useEffect</code>, though. We might want to use a separate <code>useEffect</code> for the news feed events and another <code>useEffect</code> for the chime events:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">unsubscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">welcomeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">goodbyeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
<code class="p">},</code> <code class="p">[]);</code></pre>&#13;
&#13;
<p>Splitting functionality into multiple <code>useEffect</code> calls is typically a good idea. But let’s enhance this even further. What we’re trying to create here is functionality for subscribing to a news feed that plays different jazzy sounds for subscribing, unsubscribing, and whenever there’s a new post. Everyone loves lots of loud sounds right? This is a case for a custom hook. Maybe we should call it <code>useJazzyNews</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">useJazzyNews</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">posts</code><code class="p">,</code> <code class="nx">setPosts</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">([]);</code>&#13;
  <code class="kr">const</code> <code class="nx">addPost</code> <code class="o">=</code> <code class="nx">post</code> <code class="o">=&gt;</code> <code class="nx">setPosts</code><code class="p">(</code><code class="nx">allPosts</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">post</code><code class="p">,</code> <code class="p">...</code><code class="nx">allPosts</code><code class="p">]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">unsubscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">welcomeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">goodbyeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">posts</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Our custom hook contains all of the functionality to handle a jazzy news feed, which means that we can easily share this functionality with our components. In a new component called <code>NewsFeed</code>, we’ll use the custom<a data-primary="" data-startref="UEHdepend07" data-type="indexterm" id="idm45901634724200"/><a data-primary="" data-startref="Husedepen07" data-type="indexterm" id="idm45901634622648"/><a data-primary="" data-startref="Adepen07" data-type="indexterm" id="idm45901634621704"/> hook:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">NewsFeed</code><code class="p">({</code> <code class="nx">url</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">posts</code> <code class="o">=</code> <code class="nx">useJazzyNews</code><code class="p">();</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">posts</code><code class="p">.</code><code class="nx">length</code><code class="p">}</code> <code class="nx">articles</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="p">{</code><code class="nx">posts</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">post</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nx">Post</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">post</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code> <code class="p">{...</code><code class="nx">post</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
      <code class="p">))}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deep Checking Dependencies" data-type="sect2"><div class="sect2" id="idm45901634618248">&#13;
<h2>Deep Checking Dependencies</h2>&#13;
&#13;
<p>So<a data-primary="useEffect hook" data-secondary="deep checking dependencies" data-type="indexterm" id="UEHdeep07"/><a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="deep checking dependencies" data-type="indexterm" id="Husedeep07"/><a data-primary="dependencies" data-secondary="deep checking" data-type="indexterm" id="Ddeep07"/> far, the dependencies we’ve added to the array have been strings. JavaScript primitives like strings, booleans, numbers, etc., are comparable. A string would equal a string as expected:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="k">if</code> <code class="p">(</code><code class="s2">"gnar"</code> <code class="o">===</code> <code class="s2">"gnar"</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"gnarly!!"</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>However, when we start to compare objects, arrays, and functions, the comparison is different. For example, if we compared two arrays:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="k">if</code> <code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code> <code class="o">!==</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"but they are the same"</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>These arrays <code>[1,2,3]</code> and <code>[1,2,3]</code> are not equal, even though they look identical in length and in entries. This is because they are two different instances of a similar-looking array. If we create a variable to hold this array value and then compare, we’ll see the expected output:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>&#13;
<code class="k">if</code> <code class="p">(</code><code class="nx">array</code> <code class="o">===</code> <code class="nx">array</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"because it's the exact same instance"</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In JavaScript, arrays, objects, and functions are the same only when they’re the exact same instance. So how does this relate to the <code>useEffect</code> dependency array? To demonstrate this, we’re going to need a component we can force to render as much as we want. Let’s build a hook that causes a component to render whenever a key is pressed:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">useAnyKeyToRender</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[,</code> <code class="nx">forceRender</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">();</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nb">window</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"keydown"</code><code class="p">,</code> <code class="nx">forceRender</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nb">window</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s2">"keydown"</code><code class="p">,</code> <code class="nx">forceRender</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>At minimum, all we need to do to force a render is invoke a state change function. We don’t care about the state value. We only want the state function: <code>forceRender</code>. (That’s why we added the comma using array destructuring. Remember, from <a data-type="xref" href="ch02.html#javascript-for-react">Chapter 2</a>?) When the component first renders, we’ll listen for keydown events. When a key is pressed, we’ll force the component to render by invoking <code>forceRender</code>. As we’ve done before, we’ll return a cleanup function where we stop listening to keydown events. By adding this hook to a component, we can force it to rerender simply by pressing a key.</p>&#13;
&#13;
<p>With the custom hook built, we can use it in the <code>App</code> component (and any other component for that matter! Hooks are cool.):</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">useAnyKeyToRender</code><code class="p">();</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Open</code> <code class="nx">the</code> <code class="nx">console</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Every time we press a key, the <code>App</code> component is rendered. <code>useEffect</code> demonstrates this by logging “fresh render” to the console every time the <code>App</code> is rendered. Let’s adjust <code>useEffect</code> in the <code>App</code> component to reference the <code>word</code> value. If <code>word</code> changes, we’ll rerender:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">word</code> <code class="o">=</code> <code class="s2">"gnar"</code><code class="p">;</code>&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">word</code><code class="p">]);</code></pre>&#13;
&#13;
<p>Instead of calling <code>useEffect</code> on every keydown event, we would only call this after first render and any time the <code>word</code> value changes. It doesn’t change, so subsequent <span class="keep-together">rerenders</span> don’t occur. Adding a primitive or a number to the dependency array works as expected. The effect is invoked once.</p>&#13;
&#13;
<p>What happens if instead of a single word, we use an array of words?</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">words</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"sick"</code><code class="p">,</code> <code class="s2">"powder"</code><code class="p">,</code> <code class="s2">"day"</code><code class="p">];</code>&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">words</code><code class="p">]);</code></pre>&#13;
&#13;
<p>The variable <code>words</code> is an array. Because a new array is declared with each render, JavaScript assumes that <code>words</code> has changed, thus invoking the “fresh render” effect every time. The array is a new instance each time, and this registers as an update that should trigger a rerender.</p>&#13;
&#13;
<p>Declaring <code>words</code> outside of the scope of the <code>App</code> would solve the problem:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">words</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"sick"</code><code class="p">,</code> <code class="s2">"powder"</code><code class="p">,</code> <code class="s2">"day"</code><code class="p">];</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">useAnyKeyToRender</code><code class="p">();</code>&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[</code><code class="nx">words</code><code class="p">]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">component</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The dependency array in this case refers to one instance of <code>words</code> that’s declared outside of the function. The “fresh render” effect does not get called again after the first render because <code>words</code> is the same instance as the last render. This is a good solution for this example, but it’s not always possible (or advisable) to have a variable defined outside of the scope of the function. Sometimes the value passed to the dependency array requires variables in scope. For example, we might need to create the <code>words</code> array from a React property like <code>children</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">WordCount</code><code class="p">({</code> <code class="nx">children</code> <code class="o">=</code> <code class="s2">""</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="nx">useAnyKeyToRender</code><code class="p">();</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">words</code> <code class="o">=</code> <code class="nx">children</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[</code><code class="nx">words</code><code class="p">]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">children</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">strong</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">words</code><code class="p">.</code><code class="nx">length</code><code class="p">}</code> <code class="o">-</code> <code class="nx">words</code><code class="o">&lt;</code><code class="err">/strong&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">WordCount</code><code class="o">&gt;</code><code class="nx">You</code> <code class="nx">are</code> <code class="nx">not</code> <code class="nx">going</code> <code class="nx">to</code> <code class="nx">believe</code> <code class="k">this</code> <code class="nx">but</code><code class="p">...</code><code class="o">&lt;</code><code class="err">/WordCount&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>App</code> component contains some words that are children of the <code>WordCount</code> component. The <code>WordCount</code> component takes in <code>children</code> as a property. Then we set <code>words</code> in the component equal to an array of those words that we’ve called <code>.split</code> on. We would hope that the component will rerender only if <code>words</code> changes, but as soon as we press a key, we see the dreaded “fresh render” words appearing in the console.</p>&#13;
&#13;
<p>Let’s replace that feeling of dread with one of calm, because the React team has provided us a way to avoid these extra renders. They wouldn’t hang us out to dry like that. The<a data-primary="hooks" data-secondary="useMemo hook" data-type="indexterm" id="HuseMemo07"/><a data-primary="useMemo hook" data-type="indexterm" id="usememo07"/> solution to this problem is, as you might expect, another hook: <code>useMemo</code>.</p>&#13;
&#13;
<p><code>useMemo</code> invokes a function to calculate a memoized value. In computer science in general, memoization is a technique that’s used to improve performance. In a memoized function, the result of a function call is saved and cached. Then, when the function is called again with the same inputs, the cached value is returned. In React, <code>useMemo</code> allows us to compare the cached value against itself to see if it has actually changed.</p>&#13;
&#13;
<p>The way <code>useMemo</code> works is that we pass it a function that’s used to calculate and create a memoized value. <code>useMemo</code> will only recalculate that value when one of the dependencies has changed. First, let’s import the <code>useMemo</code> hook:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useEffect</code><code class="p">,</code> <code class="nx">useMemo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code></pre>&#13;
&#13;
<p>Then we’ll use the function to set <code>words</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">words</code> <code class="o">=</code> <code class="nx">useMemo</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">words</code> <code class="o">=</code> <code class="nx">children</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="nx">words</code><code class="p">;</code>&#13;
<code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">words</code><code class="p">]);</code></pre>&#13;
&#13;
<p><code>useMemo</code> invokes the function sent to it and sets <code>words</code> to the return value of that function. Like <code>useEffect</code>, <code>useMemo</code> relies on a dependency array:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">words</code> <code class="o">=</code> <code class="nx">useMemo</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">children</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">));</code></pre>&#13;
&#13;
<p>When we don’t include the dependency array with <code>useMemo</code>, the words are calculated with every render. The dependency array controls when the callback function should be invoked. The second argument sent to the <code>useMemo</code> function is the dependency array and should contain the <code>children</code> value:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">WordCount</code><code class="p">({</code> <code class="nx">children</code> <code class="o">=</code> <code class="s2">""</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="nx">useAnyKeyToRender</code><code class="p">();</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">words</code> <code class="o">=</code> <code class="nx">useMemo</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">children</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">),</code> <code class="p">[</code><code class="nx">children</code><code class="p">]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[</code><code class="nx">words</code><code class="p">]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(...);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>words</code> array depends on the <code>children</code> property. If <code>children</code> changes, we should calculate a new value for <code>words</code> that reflects that change. At that point, <code>useMemo</code> will calculate a new value for <code>words</code> when the component initially renders and if the <code>children</code> property changes.</p>&#13;
&#13;
<p>The <code>useMemo</code> hook is a great function to understand when you’re creating React applications.</p>&#13;
&#13;
<p><a data-primary="hooks" data-secondary="useCallback hook" data-type="indexterm" id="idm45901633717640"/><a data-primary="useCallback hook" data-type="indexterm" id="idm45901633716664"/><code>useCallback</code> can be used like <code>useMemo</code>, but it memoizes functions instead of values. For example:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"hello"</code><code class="p">);</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"world"</code><code class="p">);</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
  <code class="nx">fn</code><code class="p">();</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">fn</code><code class="p">]);</code></pre>&#13;
&#13;
<p><code>fn</code> is a function that logs “Hello” then “World.” It is a dependency of <code>useEffect</code>, but just like <code>words</code>, JavaScript assumes <code>fn</code> is different every render. Therefore, it triggers the effect every render. This yields a “fresh render” for every key press. It’s not ideal.</p>&#13;
&#13;
<p>Start by wrapping the function with <code>useCallback</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="nx">useCallback</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"hello"</code><code class="p">);</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"world"</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
<code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"fresh render"</code><code class="p">);</code>&#13;
  <code class="nx">fn</code><code class="p">();</code>&#13;
<code class="p">},</code> <code class="p">[</code><code class="nx">fn</code><code class="p">]);</code></pre>&#13;
&#13;
<p><code>useCallback</code> memoizes the function value for <code>fn</code>. Just like <code>useMemo</code> and <code>useEffect</code>, it also expects a dependency array as the second argument. In this case, we create the memoized callback once because the dependency array is empty.</p>&#13;
&#13;
<p>Now that we have an understanding of the uses and differences between <code>useMemo</code> and <code>useCallback</code>, let’s improve our <code>useJazzyNews</code> hook. Every time there’s a new post, we’ll call <code>newPostChime.play()</code>. In this hook, <code>posts</code> are an array, so we’ll need to use <code>useMemo</code> to memoize the value:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">useJazzyNews</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">_posts</code><code class="p">,</code> <code class="nx">setPosts</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">([]);</code>&#13;
  <code class="kr">const</code> <code class="nx">addPost</code> <code class="o">=</code> <code class="nx">post</code> <code class="o">=&gt;</code> <code class="nx">setPosts</code><code class="p">(</code><code class="nx">allPosts</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">post</code><code class="p">,</code> <code class="p">...</code><code class="nx">allPosts</code><code class="p">]);</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">posts</code> <code class="o">=</code> <code class="nx">useMemo</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">_posts</code><code class="p">,</code> <code class="p">[</code><code class="nx">_posts</code><code class="p">]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">newPostChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
  <code class="p">},</code> <code class="p">[</code><code class="nx">posts</code><code class="p">]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">newsFeed</code><code class="p">.</code><code class="nx">unsubscribe</code><code class="p">(</code><code class="nx">addPost</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">welcomeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">goodbyeChime</code><code class="p">.</code><code class="nx">play</code><code class="p">();</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">posts</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now, the useJazzyNews hook plays a chime every time there’s a new post. We made this happen with a few changes to the hook. First, <code>const [posts, setPosts]</code> was renamed to <code>const [_posts, setPosts]</code>. We’ll calculate a new value for <code>posts</code> every time <code>_posts</code> change.</p>&#13;
&#13;
<p>Next, we added the effect that plays the chime every time the <code>post</code> array changes. We’re listening to the news feed for new posts. When a new post is added, this hook is reinvoked with <code>_posts</code> reflecting that new post. Then, a new value for <code>post</code> is memoized because <code>_posts</code> have changed. Then the chime plays because this effect is dependent on <code>posts</code>. It only plays when the posts change, and the list of posts only changes when a new one is added.</p>&#13;
&#13;
<p>Later in the chapter, we’ll discuss the React Profiler, a browser extension for testing performance and rendering of React components. There, we’ll dig into more detail about when to use <code>useMemo</code> and <code>useCallback</code>. (Spoiler alert: sparingly!)<a data-primary="" data-startref="Ddeep07" data-type="indexterm" id="idm45901633429512"/><a data-primary="" data-startref="Husedeep07" data-type="indexterm" id="idm45901633428536"/><a data-primary="" data-startref="UEHdeep07" data-type="indexterm" id="idm45901633427592"/><a data-primary="" data-startref="HuseMemo07" data-type="indexterm" id="idm45901633426648"/><a data-primary="" data-startref="usememo07" data-type="indexterm" id="idm45901633425704"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When to useLayoutEffect" data-type="sect2"><div class="sect2" id="idm45901634572200">&#13;
<h2>When to useLayoutEffect</h2>&#13;
&#13;
<p>We<a data-primary="useEffect hook" data-secondary="useLayoutEffect" data-type="indexterm" id="idm45901633424056"/><a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="useLayoutEffect hook" data-type="indexterm" id="idm45901633423048"/><a data-primary="useLayoutEffect hook" data-type="indexterm" id="idm45901633421832"/> understand that the render always comes before <code>useEffect</code>. The render happens first, then all effects run in order with full access to all of the values from the render. A quick look at the React docs will point out that there’s another type of effect hook: <code>useLayoutEffect</code>.</p>&#13;
&#13;
<p>useLayoutEffect is called at a specific moment in the render cycle. The series of events is as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Render</p>&#13;
</li>&#13;
<li>&#13;
<p><code>useLayoutEffect</code> is called</p>&#13;
</li>&#13;
<li>&#13;
<p>Browser paint: the time when the component’s elements are actually added to the DOM</p>&#13;
</li>&#13;
<li>&#13;
<p><code>useEffect</code> is called</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This can be observed by adding some simple console messages:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useEffect</code><code class="p">,</code> <code class="nx">useLayoutEffect</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"useEffect"</code><code class="p">));</code>&#13;
  <code class="nx">useLayoutEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"useLayoutEffect"</code><code class="p">));</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">ready</code><code class="o">&lt;</code><code class="err">/div&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the <code>App</code> component, <code>useEffect</code> is the first hook, followed by <code>useLayoutEffect</code>. We see that <code>useLayoutEffect</code> is invoked before <code>useEffect</code>:</p>&#13;
&#13;
<pre data-type="programlisting">useLayoutEffect&#13;
useEffect</pre>&#13;
&#13;
<p><code>useLayoutEffect</code> is invoked after the render but before the browser paints the change. In most circumstances, <code>useEffect</code> is the right tool for the job, but if your effect is essential to the browser paint (the appearance or placement of the UI elements on the screen), you may want to use <code>useLayoutEffect</code>. For instance, you may want to obtain the width and height of an element when the window is resized:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">useWindowSize</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">width</code><code class="p">,</code> <code class="nx">setWidth</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">height</code><code class="p">,</code> <code class="nx">setHeight</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">resize</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">setWidth</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">innerWidth</code><code class="p">);</code>&#13;
    <code class="nx">setHeight</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">innerHeight</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="nx">useLayoutEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nb">window</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code> <code class="nx">resize</code><code class="p">);</code>&#13;
    <code class="nx">resize</code><code class="p">();</code>&#13;
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nb">window</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code> <code class="nx">resize</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">[</code><code class="nx">width</code><code class="p">,</code> <code class="nx">height</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The <code>width</code> and <code>height</code> of the window is information that your component may need before the browser paints. <code>useLayoutEffect</code> is used to calculate the window’s <code>width</code> and <code>height</code> before the paint. Another example of when to use <code>useLayoutEffect</code> is when tracking the position of the mouse:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">useMousePosition</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">setX</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">y</code><code class="p">,</code> <code class="nx">setY</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">setPosition</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">setX</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>&#13;
    <code class="nx">setY</code><code class="p">(</code><code class="nx">y</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="nx">useLayoutEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nb">window</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"mousemove"</code><code class="p">,</code> <code class="nx">setPosition</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nb">window</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s2">"mousemove"</code><code class="p">,</code> <code class="nx">setPosition</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>It’s highly likely that the <code>x</code> and <code>y</code> position of the mouse will be used when painting the screen. <code>useLayoutEffect</code> is available to help calculate those positions accurately before the paint.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rules to Follow with Hooks" data-type="sect2"><div class="sect2" id="idm45901634571608">&#13;
<h2>Rules to Follow with Hooks</h2>&#13;
&#13;
<p>As<a data-primary="useEffect hook" data-secondary="rules to follow with hooks" data-type="indexterm" id="UEHrules07"/><a data-primary="hooks" data-secondary="rules to follow with hooks" data-type="indexterm" id="Heffectrules07"/> you’re working with Hooks, there are a few guidelines to keep in mind that can help avoid bugs and unusual behavior:</p>&#13;
<dl>&#13;
<dt>Hooks only run in the scope of a component</dt>&#13;
<dd>&#13;
<p>Hooks should only be called from React components. They can also be added to custom Hooks, which are eventually added to components. Hooks are not regular JavaScript—they’re a React pattern, but they’re starting to be modeled and incorporated in other libraries.</p>&#13;
</dd>&#13;
<dt>It’s a good idea to break functionality out into multiple Hooks</dt>&#13;
<dd>&#13;
<p>In our earlier example with the Jazzy News component, we split everything related to subscriptions into one effect and everything related to sound effects into another effect. This immediately made the code easier to read, but there was another benefit to doing this. Since Hooks are invoked in order, it’s a good idea to keep them small. Once invoked, React saves the values of Hooks in an array so the values can be tracked. Consider the following component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Counter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">toggle</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">},</code> <code class="p">[</code><code class="nx">checked</code><code class="p">]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">},</code> <code class="p">[]);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">},</code> <code class="p">[</code><code class="nx">count</code><code class="p">]);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code> <code class="p">...</code> <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The order of Hook calls is the same for each and every render:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">checked</code><code class="p">,</code> <code class="nx">DependencyArray</code><code class="p">,</code> <code class="nx">DependencyArray</code><code class="p">,</code> <code class="nx">DependencyArray</code><code class="p">]</code></pre>&#13;
</dd>&#13;
<dt>Hooks should only be called at the top level</dt>&#13;
<dd>&#13;
<p>Hooks should be used at the top level of a React function. They cannot be placed into conditional statements, loops, or nested functions. Let’s adjust the counter:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Counter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&gt;</code> <code class="mi">5</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">toggle</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&gt;</code> <code class="mi">5</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="p">...</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code> <code class="p">...</code> <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When we use <code>useState</code> within the <code>if</code> statement, we’re saying that the hook should only be called when the <code>count</code> value is greater than 5. That will throw off the array values. Sometimes the array will be: <code>[count, checked, DependencyArray, 0, DependencyArray]</code>. Other times: <code>[count, DependencyArray, 1]</code>. The index of the effect in that array matters to React. It’s how values are saved.</p>&#13;
&#13;
<p>Wait, so are we saying that we can never use conditional logic in React applications anymore? Of course not! We just have to organize these conditionals differently. We can nest <code>if</code> statements, loops, and other conditionals within the hook:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Counter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">toggle</code><code class="p">]</code> <code class="o">=</code>&#13;
  <code class="nx">useState</code><code class="p">(</code>&#13;
  <code class="nx">count</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">)</code>&#13;
  <code class="o">?</code> <code class="kc">undefined</code>&#13;
  <code class="o">:</code> <code class="o">!</code><code class="nx">c</code><code class="p">,</code>&#13;
  <code class="p">(</code><code class="nx">count</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">)</code> <code class="o">?</code> <code class="kc">undefined</code>&#13;
  <code class="p">);</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code> <code class="p">...</code> <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, the value for <code>checked</code> is based on the condition that the <code>count</code> is greater than 5. When <code>count</code> is less than 5, the value for <code>checked</code> is <code>undefined</code>. Nesting this conditional inside the hook means that the hook remains on the top level, but the result is similar. The second effect enforces the same rules. If the <code>count</code> is less than 5, the return statement will prevent the effect from continuing to execute. This keeps the hook values array intact: <code>[countValue, checkedValue, DependencyArray, DependencyArray, DependencyArray]</code>.</p>&#13;
&#13;
<p>Like conditional logic, you need to nest asynchronous behavior inside of a hook. <code>useEffect</code> takes a function as the first argument, not a promise. So you can’t use an async function as the first argument: <code>useEffect(async () =&gt; {})</code>. You can, however, create an async function inside of the nested function like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">await</code> <code class="nx">SomePromise</code><code class="p">();</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">fn</code><code class="p">();</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We created a variable, <code>fn</code>, to handle the async/await, then we called the function as the return. You can give this function a name, or you can use async effects as an anonymous function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">useEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">await</code> <code class="nx">SomePromise</code><code class="p">();</code>&#13;
  <code class="p">})();</code>&#13;
<code class="p">});</code></pre>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>If you follow these rules, you can avoid some common gotchas with React Hooks. If you’re using Create React App, there’s an ESLint plug-in included called <span class="keep-together">eslint-plugin-react-hooks</span> that provides warning hints if you’re in violation of these rules.<a data-primary="" data-startref="UEHrules07" data-type="indexterm" id="idm45901632700328"/><a data-primary="" data-startref="Heffectrules07" data-type="indexterm" id="idm45901632699480"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Improving Code with useReducer" data-type="sect2"><div class="sect2" id="idm45901632698312">&#13;
<h2>Improving Code with useReducer</h2>&#13;
&#13;
<p>Consider<a data-primary="useEffect hook" data-secondary="useReducer hook" data-tertiary="improving code with" data-type="indexterm" id="idm45901632622808"/><a data-primary="useReducer hook" data-secondary="improving code with" data-type="indexterm" id="idm45901632621528"/><a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="useReducer hook" data-type="indexterm" id="Huefreduc07"/><a data-primary="checkboxes" data-type="indexterm" id="idm45901632619096"/> the <code>Checkbox</code> component. This component is a perfect example of a component that holds simple state. The box is either checked or not checked. <code>checked</code> is the state value, and <code>setChecked</code> is a function that will be used to change the state. When the component first renders, the value of <code>checked</code> will be <code>false</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Checkbox</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">setChecked</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code>&#13;
        <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code>&#13;
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code>&#13;
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setChecked</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
      <code class="p">{</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"checked"</code> <code class="o">:</code> <code class="s2">"not checked"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This works well, but one area of this function could be cause for alarm:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">onChange</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setChecked</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">)}</code></pre>&#13;
&#13;
<p>Look at it closely. It feels OK at first glance, but are we stirring up trouble here? We’re sending a function that takes in the current value of <code>checked</code> and returns the opposite, <code>!checked</code>. This is probably more complex than it needs to be. Developers could easily send the wrong information and break the whole thing. Instead of handling it this way, why not provide a function as a toggle?</p>&#13;
&#13;
<p>Let’s add a function called <code>toggle</code> that will do the same thing: call <code>setChecked</code> and return the opposite of the current value of <code>checked</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Checkbox</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">setChecked</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="kd">function</code> <code class="nx">toggle</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">setChecked</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code> <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code> <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">toggle</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
      <code class="p">{</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"checked"</code> <code class="o">:</code> <code class="s2">"not checked"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is better. <code>onChange</code> is set to a predictable value: the <code>toggle</code> function. We know what that function is going to do every time, everywhere it’s used. We can still take this one step farther to yield even more predictable results each time we use the <code>checkbox</code> component. Remember the function we sent to <code>setChecked</code> in the <code>toggle</code> <span class="keep-together">function</span>?</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">setChecked</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">);</code></pre>&#13;
&#13;
<p>We’re going to refer to this function, <code>checked =&gt; !checked</code>, by a different name now: a<a data-primary="reducer functions" data-type="indexterm" id="idm45901632363016"/><a data-primary="functions" data-secondary="reducer functions" data-type="indexterm" id="idm45901632362408"/> <em>reducer</em>. A reducer function’s most simple definition is that it takes in the current state and returns a new state. If <code>checked</code> is <code>false</code>, it should return the opposite, <code>true</code>. Instead of hardcoding this behavior into <code>onChange</code> events, we can abstract the logic into a reducer function that will always produce the same results. Instead of <code>useState</code> in the component, we’ll use <code>useReducer</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Checkbox</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">toggle</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useReducer</code><code class="p">(</code><code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">,</code> <code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code> <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code> <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">toggle</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
      <code class="p">{</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"checked"</code> <code class="o">:</code> <code class="s2">"not checked"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>useReducer</code> takes in the reducer function and the initial state, <code>false</code>. Then, we’ll set the <code>onChange</code> function to <code>setChecked</code>, which will call the reducer function.</p>&#13;
&#13;
<p>Our earlier reducer, <code>checked =&gt; !checked</code>, is a prime example of this. If the same input is provided to a function, the same output should be expected. This concept originates with <code>Array.reduce</code> in JavaScript. <code>reduce</code> fundamentally does the same thing as a reducer: it takes in a function (to reduce all of the values into a single value) and an initial value and returns one value.</p>&#13;
&#13;
<p><code>Array.reduce</code> takes<a data-primary="Array.reduce function" data-type="indexterm" id="idm45901632275384"/> in a reducer function and an initial value. For each value in the <code>numbers</code> array, the reducer is called until one value is returned:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="p">[</code><code class="mi">28</code><code class="p">,</code> <code class="mi">34</code><code class="p">,</code> <code class="mi">67</code><code class="p">,</code> <code class="mi">68</code><code class="p">];</code>&#13;
&#13;
<code class="nx">numbers</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">number</code><code class="p">,</code> <code class="nx">nextNumber</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">nextNumber</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code> <code class="c1">// 197</code></pre>&#13;
&#13;
<p>The reducer sent to <code>Array.reduce</code> takes in two arguments. You can also send multiple arguments to a reducer function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Numbers</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">number</code><code class="p">,</code> <code class="nx">setNumber</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useReducer</code><code class="p">(</code>&#13;
    <code class="p">(</code><code class="nx">number</code><code class="p">,</code> <code class="nx">newNumber</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">newNumber</code><code class="p">,</code>&#13;
    <code class="mi">0</code>&#13;
  <code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setNumber</code><code class="p">(</code><code class="mi">30</code><code class="p">)}</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">number</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Every time we click on the <code>h1</code>, we’ll add 30 to the total.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="useReducer to Handle Complex State" data-type="sect2"><div class="sect2" id="idm45901632623784">&#13;
<h2>useReducer to Handle Complex State</h2>&#13;
&#13;
<p><code>useReducer</code> can<a data-primary="useEffect hook" data-secondary="useReducer hook" data-tertiary="handling complex state with" data-type="indexterm" id="idm45901632149512"/><a data-primary="useReducer hook" data-secondary="handling complex state with" data-type="indexterm" id="idm45901632148264"/><a data-primary="state management" data-secondary="handling complex state" data-type="indexterm" id="idm45901632147304"/> help us handle state updates more predictably as state becomes more complex. Consider an object that contains user data:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">firstUser</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="s2">"0391-3233-3201"</code><code class="p">,</code>&#13;
  <code class="nx">firstName</code><code class="o">:</code> <code class="s2">"Bill"</code><code class="p">,</code>&#13;
  <code class="nx">lastName</code><code class="o">:</code> <code class="s2">"Wilson"</code><code class="p">,</code>&#13;
  <code class="nx">city</code><code class="o">:</code> <code class="s2">"Missoula"</code><code class="p">,</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="s2">"Montana"</code><code class="p">,</code>&#13;
  <code class="nx">email</code><code class="o">:</code> <code class="s2">"bwilson@mtnwilsons.com"</code><code class="p">,</code>&#13;
  <code class="nx">admin</code><code class="o">:</code> <code class="kc">false</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Then we have a component called <code>User</code> that sets the <code>firstUser</code> as the initial state, and the component displays the appropriate data:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">User</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">user</code><code class="p">,</code> <code class="nx">setUser</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">firstUser</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">user</code><code class="p">.</code><code class="nx">firstName</code><code class="p">}</code> <code class="p">{</code><code class="nx">user</code><code class="p">.</code><code class="nx">lastName</code><code class="p">}</code> <code class="o">-</code> <code class="p">{</code><code class="nx">user</code><code class="p">.</code><code class="nx">admin</code> <code class="o">?</code> <code class="s2">"Admin"</code> <code class="o">:</code> <code class="s2">"User"</code><code class="p">}</code>&#13;
      <code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">Email</code><code class="o">:</code> <code class="p">{</code><code class="nx">user</code><code class="p">.</code><code class="nx">email</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
        <code class="nx">Location</code><code class="o">:</code> <code class="p">{</code><code class="nx">user</code><code class="p">.</code><code class="nx">city</code><code class="p">},</code> <code class="p">{</code><code class="nx">user</code><code class="p">.</code><code class="nx">state</code><code class="p">}</code>&#13;
      <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code><code class="o">&gt;</code><code class="nx">Make</code> <code class="nx">Admin</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A common error when managing state is to overwrite the state:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">button</code>&#13;
  <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">setUser</code><code class="p">({</code> <code class="nx">admin</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});</code>&#13;
  <code class="p">}}</code>&#13;
<code class="o">&gt;</code>&#13;
  <code class="nx">Make</code> <code class="nx">Admin</code>&#13;
<code class="o">&lt;</code><code class="err">/button&gt;</code></pre>&#13;
&#13;
<p>Doing this would overwrite state from <code>firstUser</code> and replace it with just what we sent to the <code>setUser</code> function: <code>{admin: true}</code>. This can be fixed by spreading the current values from user, then overwriting the <code>admin</code> value:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">button</code>&#13;
  <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">setUser</code><code class="p">({</code> <code class="p">...</code><code class="nx">user</code><code class="p">,</code> <code class="nx">admin</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});</code>&#13;
  <code class="p">}}</code>&#13;
<code class="o">&gt;</code>&#13;
  <code class="nx">Make</code> <code class="nx">Admin</code>&#13;
<code class="o">&lt;</code><code class="err">/button&gt;</code></pre>&#13;
&#13;
<p>This will take the initial state and push in the new key/values: <code>{admin: true}</code>. We need to rewrite this logic in every <code>onClick</code>, making it prone to error (we might forget to do this when we come back to the app tomorrow):</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">User</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">user</code><code class="p">,</code> <code class="nx">setUser</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useReducer</code><code class="p">(</code>&#13;
    <code class="p">(</code><code class="nx">user</code><code class="p">,</code> <code class="nx">newDetails</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code> <code class="p">...</code><code class="nx">user</code><code class="p">,</code> <code class="p">...</code><code class="nx">newDetails</code> <code class="p">}),</code>&#13;
    <code class="nx">firstUser</code>&#13;
  <code class="p">);</code>&#13;
  <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then we’ll send the new state value, <code>newDetails</code>, to the reducer, and it will be pushed into the object:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">button</code>&#13;
  <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">setUser</code><code class="p">({</code> <code class="nx">admin</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});</code>&#13;
  <code class="p">}}</code>&#13;
<code class="o">&gt;</code>&#13;
  <code class="nx">Make</code> <code class="nx">Admin</code>&#13;
<code class="o">&lt;</code><code class="err">/button&gt;</code></pre>&#13;
&#13;
<p>This pattern is useful when state has multiple subvalues or when the next state depends on a previous state. Teach everyone to spread, they’ll spread for a day. Teach everyone to <code>useReducer</code> and they’ll spread for life.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45901631797144">&#13;
<h5>Legacy setState and useReducer</h5>&#13;
<p>In<a data-primary="useEffect hook" data-secondary="useReducer hook" data-tertiary="legacy setState function and" data-type="indexterm" id="idm45901631795736"/><a data-primary="useReducer hook" data-secondary="legacy setState function and" data-type="indexterm" id="idm45901631794488"/><a data-primary="setState function" data-type="indexterm" id="idm45901631793528"/><a data-primary="state management" data-secondary="legacy setState function" data-type="indexterm" id="idm45901631744728"/> previous versions of React, we used a function called <code>setState</code> to update state. Initial state would be assigned in the constructor as an object:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">class</code> <code class="nx">User</code> <code class="kr">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>&#13;
  <code class="nx">constructor</code><code class="p">(</code><code class="nx">props</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">super</code><code class="p">(</code><code class="nx">props</code><code class="p">);</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">=</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="s2">"0391-3233-3201"</code><code class="p">,</code>&#13;
      <code class="nx">firstName</code><code class="o">:</code> <code class="s2">"Bill"</code><code class="p">,</code>&#13;
      <code class="nx">lastName</code><code class="o">:</code> <code class="s2">"Wilson"</code><code class="p">,</code>&#13;
      <code class="nx">city</code><code class="o">:</code> <code class="s2">"Missoula"</code><code class="p">,</code>&#13;
      <code class="nx">state</code><code class="o">:</code> <code class="s2">"Montana"</code><code class="p">,</code>&#13;
      <code class="nx">email</code><code class="o">:</code> <code class="s2">"bwilson@mtnwilsons.com"</code><code class="p">,</code>&#13;
      <code class="nx">admin</code><code class="o">:</code> <code class="kc">false</code>&#13;
    <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onSubmit</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code>&#13;
	<code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">setState</code><code class="p">({</code><code class="nx">admin</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});}}</code>&#13;
<code class="nx">Make</code> <code class="nx">Admin</code>&#13;
<code class="o">&lt;</code><code class="err">/button&gt;</code></pre>&#13;
&#13;
<p>The older incarnation of <code>setState</code> merged state values. The same is true of <code>useReducer</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="p">[</code><code class="nx">state</code><code class="p">,</code> <code class="nx">setState</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useReducer</code><code class="p">(</code>&#13;
	<code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="nx">newState</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
              <code class="p">({...</code><code class="nx">state</code><code class="p">,</code> <code class="p">...</code><code class="nx">newState</code><code class="p">}),</code>&#13;
        <code class="nx">initialState</code><code class="p">);</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onSubmit</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code>&#13;
	<code class="p">{</code><code class="nx">setState</code><code class="p">({</code><code class="nx">admin</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});}}</code>&#13;
<code class="nx">Make</code> <code class="nx">Admin</code>&#13;
<code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
<code class="o">&lt;</code><code class="err">/div&gt;);</code></pre>&#13;
&#13;
<p>If you like this pattern, you can use <code>legacy-set-state</code> npm or <code>useReducer</code>.</p>&#13;
&#13;
<p>The past few examples are simple applications for a reducer. In the next chapter, we’ll dig deeper into reducer design patterns that can be used to simplify state management in your apps.<a data-primary="" data-startref="Huefreduc07" data-type="indexterm" id="idm45901631552184"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Improving Component Performance" data-type="sect2"><div class="sect2" id="idm45901632150808">&#13;
<h2>Improving Component Performance</h2>&#13;
&#13;
<p>In<a data-primary="components" data-secondary="improving component performance" data-type="indexterm" id="idm45901631549112"/><a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="improving component performance" data-type="indexterm" id="idm45901631548136"/><a data-primary="useEffect hook" data-secondary="improving component performance" data-type="indexterm" id="idm45901631546952"/><a data-primary="hooks" data-secondary="useMemo hook" data-type="indexterm" id="idm45901631546040"/><a data-primary="useMemo hook" data-type="indexterm" id="idm45901631545096"/><a data-primary="hooks" data-secondary="useCallback hook" data-type="indexterm" id="idm45901631544424"/><a data-primary="useCallback hook" data-type="indexterm" id="idm45901631543480"/> a React application, components are rendered…usually a lot. Improving performance includes preventing unnecessary renders and reducing the time a render takes to propagate. React comes with tools to help us prevent unnecessary renders: <code>memo</code>, <code>useMemo</code>, and <code>useCallback</code>. We looked at <code>useMemo</code> and <code>useCallback</code> earlier in the chapter, but in this section, we’ll go into more detail about how to use these Hooks to make your websites perform better.</p>&#13;
&#13;
<p>The <code>memo</code> function is used to create<a data-primary="pure components" data-type="indexterm" id="idm45901631539352"/><a data-primary="components" data-secondary="pure components" data-type="indexterm" id="idm45901631538648"/> pure components. As discussed in <a data-type="xref" href="ch03.html#functional-programming-with-javascript">Chapter 3</a>, we know that, given the same parameters, a pure function will always return the same result. A pure component works the same way. In React, a pure component is a component that always renders the same output, given the same properties.</p>&#13;
&#13;
<p>Let’s create a component called <code>Cat</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Cat</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">name</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`rendering </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p><code>Cat</code> is a pure component. The output is always a paragraph that displays the name property. If the name provided as a property is the same, the output will be the same:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">cats</code><code class="p">,</code> <code class="nx">setCats</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">([</code><code class="s2">"Biscuit"</code><code class="p">,</code> <code class="s2">"Jungle"</code><code class="p">,</code> <code class="s2">"Outlaw"</code><code class="p">]);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="p">{</code><code class="nx">cats</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">name</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nx">Cat</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code> <code class="nx">name</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
      <code class="p">))}</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setCats</code><code class="p">([...</code><code class="nx">cats</code><code class="p">,</code> <code class="nx">prompt</code><code class="p">(</code><code class="s2">"Name a cat"</code><code class="p">)])}</code><code class="o">&gt;</code>&#13;
        <code class="nx">Add</code> <code class="nx">a</code> <code class="nx">Cat</code>&#13;
      <code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This app uses the <code>Cat</code> component. After the initial render, the console reads:</p>&#13;
&#13;
<pre data-type="programlisting">rendering Biscuit&#13;
rendering Jungle&#13;
rendering Outlaw</pre>&#13;
&#13;
<p>When the “Add a Cat” button is clicked, the user is prompted to add a cat.</p>&#13;
&#13;
<p>If we add a cat named “Ripple,” we see that all <code>Cat</code> components are rerendered:</p>&#13;
&#13;
<pre data-type="programlisting">rendering Biscuit&#13;
rendering Jungle&#13;
rendering Outlaw&#13;
rendering Ripple</pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This code works because <code>prompt</code> is blocking. This is just an example. Don’t use <code>prompt</code> in a real app.</p>&#13;
</div>&#13;
&#13;
<p>Every time we add a cat, every <code>Cat</code> component is rendered, but the <code>Cat</code> component is a pure component. Nothing changes about the output given the same prop, so there shouldn’t be a render for each of these. We don’t want to rerender a pure component if the properties haven’t changed. The <code>memo</code> function can be used to create a component that will only render when its properties change. Start by importing it from the React library and use it to wrap the current <code>Cat</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code><code class="p">,</code> <code class="nx">memo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Cat</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">name</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`rendering </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">PureCat</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(</code><code class="nx">Cat</code><code class="p">);</code></pre>&#13;
&#13;
<p>Here, we’ve created a new component called <code>PureCat</code>. <code>PureCat</code> will only cause the <code>Cat</code> to render when the properties change. Then we can replace the <code>Cat</code> component with <code>PureCat</code> in the <code>App</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">cats</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">name</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">&lt;</code><code class="nx">PureCat</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code> <code class="nx">name</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now, every time we add a new cat name, like “Pancake,” we see only one render in the console:</p>&#13;
&#13;
<pre data-type="programlisting">rendering Pancake</pre>&#13;
&#13;
<p>Because the names of the other cats have not changed, we don’t render those <code>Cat</code> components. This is working well for a <code>name</code> property, but what if we introduce a function property to the <code>Cat</code> component?</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Cat</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(({</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">meow</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`rendering </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">p</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">meow</code><code class="p">(</code><code class="nx">name</code><code class="p">)}</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;;</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Every time a cat is clicked on, we can use this property to log a <code>meow</code> to the console:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">PureCat</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code> <code class="nx">name</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="nx">meow</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb"> has meowed`</code><code class="p">)}</code> <code class="o">/&gt;</code></pre>&#13;
&#13;
<p>When we add this change, <code>PureCat</code> no longer works as expected. It’s always rendering every <code>Cat</code> component even though the <code>name</code> property remains the same. This is because of the added <code>meow</code> property. Unfortunately, every time we define the <code>meow</code> property as a function, it’s always new function. To React, the <code>meow</code> property has changed, and the component is rerendered.</p>&#13;
&#13;
<p>The <code>memo</code> function will allow us to define more specific rules around when this component should rerender:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">RenderCatOnce</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(</code><code class="nx">Cat</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">true</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">AlwaysRenderCat</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(</code><code class="nx">Cat</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">false</code><code class="p">);</code></pre>&#13;
&#13;
<p>The second argument sent to the <code>memo</code> function is a <em>predicate</em>. A predicate is a function that only returns <code>true</code> or <code>false</code>. This function decides whether to rerender a cat or not. When it returns <code>false</code>, the <code>Cat</code> is rerendered. When this function returns <code>true</code>, the <code>Cat</code> will not be rerendered. No matter what, the <code>Cat</code> is always rendered at least once. This is why, with <code>RenderCatOnce</code>, it will render once and then never again. Typically, this function is used to check actual values:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">PureCat</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(</code>&#13;
  <code class="nx">Cat</code><code class="p">,</code>&#13;
  <code class="p">(</code><code class="nx">prevProps</code><code class="p">,</code> <code class="nx">nextProps</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">prevProps</code><code class="p">.</code><code class="nx">name</code> <code class="o">===</code> <code class="nx">nextProps</code><code class="p">.</code><code class="nx">name</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>We can use the second argument to compare properties and decide if <code>Cat</code> should be rerendered. The predicate receives the previous properties and the next properties. These objects are used to compare the <code>name</code> property. If the <code>name</code> changes, the component will be re-rendered. If the <code>name</code> is the same, it will be rerendered regardless of what React thinks about the <code>meow</code> property.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="shouldComponentUpdate and PureComponent" data-type="sect2"><div class="sect2" id="idm45901631550408">&#13;
<h2>shouldComponentUpdate and PureComponent</h2>&#13;
&#13;
<p>The<a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="shouldComponentUpdate method" data-type="indexterm" id="idm45901631013208"/><a data-primary="shouldComponentUpdate method" data-type="indexterm" id="idm45901630987272"/><a data-primary="useEffect hook" data-secondary="shouldComponentUpdate method" data-type="indexterm" id="idm45901630986632"/><a data-primary="components" data-secondary="shouldComponentUpdate method" data-type="indexterm" id="idm45901630985720"/> concepts we’re discussing are not new to React. The <code>memo</code> function is a new solution to a common problem. In previous versions of React, there was a method called <code>shouldComponentUpdate</code>. If present in the component, it was used to let React know under which circumstances the component should update. <code>shouldComponentUpdate</code> described which props or state would need to change for the component to rerender. Once <code>shouldComponentUpdate</code> was part of the React library, it was embraced as a useful feature by many. So useful that the React team decided to create an alternate way of creating a component as a class. A class component would look like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Cat</code> <code class="kr">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>&#13;
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">(</code>&#13;
      <code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="nx">is</code> <code class="nx">a</code> <code class="nx">good</code> <code class="nx">cat</code><code class="o">!</code>&#13;
    <code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A<a data-primary="PureComponent" data-type="indexterm" id="idm45901630922952"/> <code>PureComponent</code> would look like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Cat</code> <code class="kr">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">PureComponent</code> <code class="p">{</code>&#13;
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">(</code>&#13;
      <code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="nx">is</code> <code class="nx">a</code> <code class="nx">good</code> <code class="nx">cat</code><code class="o">!</code>&#13;
    <code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>PureComponent</code> is the same as<a data-primary="React.memo" data-type="indexterm" id="idm45901630876584"/> <code>React.memo</code>, but <code>PureComponent</code> is only for class components; <code>React.memo</code> is only for function components.</p>&#13;
&#13;
<p><code>useCallback</code> and <code>useMemo</code> can be used to<a data-primary="memoization" data-type="indexterm" id="idm45901630873416"/> memoize object and function properties. Let’s use <code>useCallback</code> in the <code>Cat</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">PureCat</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(</code><code class="nx">Cat</code><code class="p">);</code>&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">meow</code> <code class="o">=</code> <code class="nx">useCallback</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb"> has meowed`</code><code class="p">,</code> <code class="p">[]);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">PureCat</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"Biscuit"</code> <code class="nx">meow</code><code class="o">=</code><code class="p">{</code><code class="nx">meow</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this case, we did not provide a property-checking predicate to <code>memo(Cat)</code>. Instead, we used <code>useCallback</code> to ensure that the <code>meow</code> function had not changed. Using these functions can be helpful when dealing with too many rerenders in your component tree.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When to Refactor" data-type="sect2"><div class="sect2" id="idm45901630787912">&#13;
<h2>When to Refactor</h2>&#13;
&#13;
<p>The<a data-primary="hooks" data-secondary="useEffect hook" data-tertiary="refactoring" data-type="indexterm" id="idm45901630786120"/><a data-primary="useEffect hook" data-secondary="refactoring" data-type="indexterm" id="idm45901630784840"/><a data-primary="refactoring" data-type="indexterm" id="idm45901630783896"/> last Hooks we discussed, <code>useMemo</code> and <code>useCallback</code>, along with the <code>memo</code> function, are commonly overused. React is designed to be fast. It’s designed to have components render a lot. The process of optimizing for performance began when you decided to use React in the first place. It’s fast. Any further refactoring should be a last step.</p>&#13;
&#13;
<p>There are trade-offs to refactoring. Using <code>useCallback</code> and <code>useMemo</code> everywhere because it seems like a good idea might actually make your app less performant. You’re adding more lines of code and developer hours to your application. When you refactor for performance, it’s important to have a goal. Perhaps you want to stop the screen from freezing or flickering. Maybe you know there are some costly functions that are slowing the speed of your app unreasonably.</p>&#13;
&#13;
<p>The<a data-primary="React Profiler" data-type="indexterm" id="idm45901630779544"/> React Profiler can be used to measure the performance of each of your components. The<a data-primary="React Developer Tools" data-type="indexterm" id="idm45901630778680"/> profiler ships with the React Developer Tools that you’ve likely installed already (available for <a href="https://oreil.ly/1UNct">Chrome</a> and <a href="https://oreil.ly/0NYbR">Firefox</a>).</p>&#13;
&#13;
<p>Always make sure your app works and you’re satisfied with the codebase before refactoring. Over-refactoring, or refactoring before your app works, can introduce weird bugs that are hard to spot, and it might not be worth your time and focus to introduce these optimizations.</p>&#13;
&#13;
<p>In the last two chapters, we’ve introduced many of the Hooks that ship with React. You’ve seen use cases for each hook, and you’ve created your own custom Hooks by composing other Hooks. Next, we’ll build on these foundational skills by incorporating additional libraries and advanced patterns.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>