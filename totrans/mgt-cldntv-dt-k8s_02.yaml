- en: 'Chapter 1\. Introduction to Cloud Native Data Infrastructure: Persistence,
    Streaming, and Batch Analytics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：云原生数据基础设施介绍：持久性、流处理和批处理分析
- en: Do you work at solving data problems and find yourself faced with the need for
    modernization? Is your cloud native application limited to the use of microservices
    and service mesh? If you deploy applications on Kubernetes (sometimes abbreviated
    as “K8s”) without including data, you haven’t fully embraced cloud native. Every
    element of your application should embody the cloud native principles of scale,
    elasticity, self-healing, and observability, including how you handle data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否致力于解决数据问题，并发现自己需要现代化？您的云原生应用程序是否仅限于使用微服务和服务网格？如果您在 Kubernetes 上部署应用程序（有时简称为“K8s”），但没有涉及数据，那么您还没有完全拥抱云原生。您的应用程序的每个元素都应体现云原生的规模、弹性、自愈和可观察性原则，包括您如何处理数据。
- en: 'Engineers who work with data are primarily concerned with stateful services,
    and this will be our focus: increasing your skills to manage data in Kubernetes.
    By reading this book, our goal is to enrich your journey to cloud native data.
    If you are just starting with cloud native applications, there is no better time
    to include every aspect of the stack. This convergence is the future of how we
    will consume cloud resources.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据工程师主要关注的是有状态服务，这也将是我们关注的重点：提升您在 Kubernetes 中管理数据的技能。通过阅读本书，我们的目标是丰富您向云原生数据迁移的旅程。如果您刚开始接触云原生应用程序，现在是将技术栈的每一个方面纳入的最佳时机。这种融合是我们将如何消费云资源的未来。
- en: So, what is this future we are creating together?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们一起创造的这个未来是什么样的呢？
- en: For too long, data has lived outside of Kubernetes, creating a lot of extra
    effort and complexity. We will get into valid reasons for this, but now is the
    time to combine the entire stack to build applications faster, at the needed scale.
    Based on current technology, this is very much possible. We’ve moved away from
    the past of deploying individual servers and toward the future where we will be
    able to deploy entire virtual datacenters. Development cycles that once took months
    and years can now be managed in days and weeks. Open source components can now
    be combined into a single deployment on Kubernetes that is portable from your
    laptop to the largest cloud provider.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 太长时间以来，数据一直存在于 Kubernetes 之外，导致了大量额外的工作和复杂性。我们将详细探讨其中的合理原因，但现在是将整个技术栈结合起来，以更快速、按需规模构建应用程序的时候了。基于当前的技术，这是完全可能的。我们已经远离了部署单独服务器的过去，转向了可以部署整个虚拟数据中心的未来。曾经需要数月甚至数年的开发周期现在可以在几天甚至几周内完成。开源组件现在可以结合到一个
    Kubernetes 上的单一部署中，这种部署从你的笔记本到最大的云服务提供商都可以移植。
- en: The open source contribution isn’t a tiny part of this, either. Kubernetes and
    the projects we discuss in this book are under the Apache License 2.0 unless otherwise
    noted, and for a good reason. If we build infrastructure that can run anywhere,
    we need a license model that gives us the freedom of choice. Open source is both
    free-as-in-beer and free-as-in-freedom, and both count when building cloud native
    applications on Kubernetes. Open source has been the fuel of many revolutions
    in infrastructure, and this is no exception.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开源贡献在其中占据了重要地位。除非另有说明，否则 Kubernetes 和本书讨论的项目均采用 Apache License 2.0，这是有充分理由的。如果我们构建能够在任何地方运行的基础设施，我们需要一个能够给予我们选择自由的许可模型。开源既是免费的（如啤酒那样的自由），也是自由的（如自由那样的自由），在构建基于
    Kubernetes 的云原生应用程序时，这两者都至关重要。开源已经成为基础设施革命的推动力量，而这也不例外。
- en: 'That’s what we are building: the near future reality of fully realized Kubernetes
    applications. The final component is the most important, and that is you. As a
    reader of this book, you are one of the people who will create this future. Creating
    is what we do as engineers. We continuously reinvent the way we deploy complicated
    infrastructure to respond to increased demand. When the first electronic database
    system was put online in 1960 for American Airlines, a small army of engineers
    made sure that it stayed online and worked around the clock. Progress took us
    from mainframes to minicomputers, to microcomputers, and eventually to the fleet
    management we do today. Now, that same progression is continuing into cloud native
    and Kubernetes.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们正在构建的内容：完全实现的 Kubernetes 应用程序的接近未来现实。最后一个组成部分是最重要的，那就是你。作为本书的读者，你们中的一员将成为创造这一未来的人之一。作为工程师，创造是我们的工作。我们不断地重新发明我们部署复杂基础设施的方式，以应对增加的需求。当1960年为美国航空公司上线了第一个电子数据库系统时，一小群工程师确保它在线并全天候运行。进步使我们从大型机到小型计算机，再到微型计算机，最终到我们今天的舰队管理。现在，同样的进步正在继续进入云原生和
    Kubernetes。
- en: This chapter will examine the components of cloud native applications, the challenges
    of running stateful workloads, and the essential areas covered in this book. To
    get started, let’s turn to the building blocks that make up data infrastructure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨云原生应用程序的组成部分，运行有状态工作负载的挑战以及本书涵盖的基本领域。首先，让我们转向构成数据基础设施的构建模块。
- en: Infrastructure Types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施类型
- en: 'In the past 20 years, the approach to infrastructure has slowly forked into
    two areas that reflect how we deploy distributed applications (as shown in [Figure 1-1](#stateless_vsdot_stateful_services)):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的20年里，基础设施的方法慢慢分叉成两个领域，反映了我们如何部署分布式应用程序（如[图 1-1](#stateless_vsdot_stateful_services)所示）。
- en: Stateless services
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态服务
- en: These are services that maintain information only for the immediate lifecycle
    of the active request—for example, a service for sending formatted shopping cart
    information to a mobile client. A typical example is an application server that
    performs the business logic for the shopping cart. However, the information about
    the shopping cart contents resides external to these services. They need to be
    online for only a short duration from request to response. The infrastructure
    used to provide the service can easily grow and shrink with little impact on the
    overall application, scaling compute and network resources on demand when needed.
    Since we are not storing critical data in the individual service, that data can
    be created and destroyed quickly, with little coordination. Stateless services
    are a crucial architecture element in distributed systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务仅在活动请求的即时生命周期中维护信息，例如，向移动客户端发送格式化的购物车信息的服务。一个典型的例子是执行购物车业务逻辑的应用服务器。然而，购物车内容的信息存储在这些服务之外。它们只需要在请求到响应的短时间内在线。用于提供服务的基础设施可以轻松地随需求增减，对整体应用的影响很小，可以在需要时扩展计算和网络资源。由于我们不在个别服务中存储关键数据，因此该数据可以快速创建和销毁，几乎不需要协调。无状态服务是分布式系统中的关键架构元素。
- en: Stateful services
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态服务
- en: These services need to maintain information from one request to the next. Disks
    and memory store data for use across multiple requests. An example is a database
    or filesystem. Scaling stateful services is more complex since the information
    typically requires replication for high availability. This creates the need for
    consistency and mechanisms to keep data in sync between replicas. These services
    usually have different scaling methods, both vertical and horizontal. As a result,
    they require different sets of operational tasks than stateless services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务需要维护从一个请求到下一个请求的信息。磁盘和内存存储数据以供多个请求使用。一个例子是数据库或文件系统。由于通常需要复制以实现高可用性，扩展有状态服务更加复杂。这造成了对一致性和保持数据在副本之间同步的机制的需求。这些服务通常具有不同的扩展方法，包括垂直和水平扩展。因此，它们需要不同的操作任务集合，与无状态服务不同。
- en: '![Stateless vs. stateful services](assets/mcdk_0101.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![无状态 vs. 有状态服务](assets/mcdk_0101.png)'
- en: Figure 1-1\. Stateless versus stateful services
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 无状态与有状态服务
- en: 'In addition to the way information is stored, we’ve also seen a shift toward
    developing systems that embrace automated infrastructure deployment. These recent
    advances include the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了信息存储方式外，我们还看到了向开发采纳自动化基础设施部署的转变。这些最新的进展包括以下内容：
- en: Physical servers have given way to virtual machines (VMs) that are easy to deploy
    and maintain.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMs have been simplified and focused on specific applications to containers.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers have allowed infrastructure engineers to package an application’s
    operating system requirements into a single executable.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use of containers has undoubtedly increased the consistency of deployments,
    which has made it easier to deploy and run infrastructure in bulk. Few systems
    emerged to orchestrate the explosion of containers like Kubernetes, which is evident
    from its incredible growth. This speaks to how well it solves the problem. The
    official [documentation](https://oreil.ly/3WKn4) describes Kubernetes as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is a portable, extensible, open source platform for managing containerized
    workloads and services that facilitates both declarative configuration and automation.
    It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools
    are widely available.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Kubernetes was originally designed for stateless workloads, and that is what
    it has traditionally done best. Kubernetes has developed a reputation as a “platform
    for building platforms” in a cloud native way. However, there’s a reasonable argument
    that a complete cloud native solution has to take data into account. That’s the
    goal of this book: exploring how we make it possible to build cloud native data
    solutions on Kubernetes. But first, let’s unpack what “cloud native” means.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: What Is Cloud Native Data?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin defining the aspects of cloud native data that can help us with
    a final definition. First, let’s start with the definition of cloud native from
    the [Cloud Native Computing Foundation (CNCF)](https://oreil.ly/OTdhS):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Cloud native technologies empower organizations to build and run scalable applications
    in modern, dynamic environments such as public, private, and hybrid clouds. Containers,
    service meshes, microservices, immutable infrastructure, and declarative APIs
    exemplify this approach.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These techniques enable loosely coupled systems that are resilient, manageable,
    and observable. Combined with robust automation, they allow engineers to make
    high-impact changes frequently and predictably with minimal toil.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that this definition describes a goal state, desirable characteristics,
    and examples of technologies that embody both. Based on this formal definition,
    we can synthesize the qualities that differentiate a cloud native application
    from other types of deployments in terms of how it handles data. Let’s take a
    closer look at these qualities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: If a service can produce a unit of work for a unit of resources, adding more
    resources should increase the amount of work a service can perform. *Scalability*
    describes the service’s ability to apply additional resources to produce additional
    work. Ideally, services should scale infinitely given an infinite amount of compute,
    network, and storage resources. For data, this means scale without the need for
    downtime. Legacy systems required a maintenance period while adding new resources,
    during which all services had to be shut down. With the needs of cloud native
    applications, downtime is no longer acceptable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个服务可以用一定的资源产生一单位的工作量，增加更多的资源应该能够增加服务的工作量。*可扩展性*描述了服务利用额外资源产生额外工作的能力。理想情况下，服务应该能够在有无限计算、网络和存储资源的情况下无限扩展。对于数据来说，这意味着在无需停机的情况下进行扩展。传统系统在增加新资源时需要维护期间，期间所有服务必须关闭。随着云原生应用程序的需求增加，停机已经不再可接受。
- en: Elasticity
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性
- en: Whereas *scale* is adding resources to meet demand, elasticity is the ability
    to free those resources when they are no longer needed. The difference between
    scalability and elasticity is highlighted in [Figure 1-2](#comparing_scalability_and_elasticity).
    Elasticity can also be called *on-demand infrastructure*. In a constrained environment
    such as a private datacenter, this is critical for sharing limited resources.
    For cloud infrastructure that charges for every resource used, this is a way to
    prevent paying for running services you don’t need. When it comes to managing
    data, this means that we need capabilities to reclaim storage space and optimize
    our usage—for example, moving older data to less expensive storage tiers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*扩展*是为了满足需求而增加资源，弹性则是在不再需要这些资源时释放它们的能力。可扩展性和弹性的差异在[图1-2](#comparing_scalability_and_elasticity)中得到突显。弹性也可以称为*按需基础设施*。在私有数据中心等受限环境中，这对于共享有限资源至关重要。对于按资源使用付费的云基础设施而言，这是避免支付无需运行的服务费用的一种方法。在管理数据时，这意味着我们需要能力来回收存储空间并优化我们的使用，例如将旧数据移到更便宜的存储层次。
- en: '![Comparing scalability and elasticity](assets/mcdk_0102.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![比较可扩展性和弹性](assets/mcdk_0102.png)'
- en: Figure 1-2\. Comparing scalability and elasticity
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 比较可扩展性和弹性
- en: Self-healing
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自愈
- en: Bad things happen. When they do, how will your infrastructure respond? Self-healing
    infrastructure will reroute traffic, reallocate resources, and maintain service
    levels. With larger and more complex distributed applications being deployed,
    this is an increasingly important attribute of a cloud native application. This
    is what keeps you from getting that 3 A.M. wake-up call. For data, this means
    we need capabilities to detect issues with data such as missing data and data
    quality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 发生不良事件时，你的基础设施将如何响应？自愈基础设施将重新路由流量，重新分配资源，并维持服务水平。随着部署更大更复杂的分布式应用程序，这成为云原生应用程序日益重要的特性。这可以避免你在凌晨三点接到电话的情况。对于数据来说，这意味着我们需要检测数据问题的能力，例如缺失数据和数据质量问题。
- en: Observability
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性
- en: If something fails and you aren’t monitoring it, did it happen? Unfortunately,
    not only is the answer yes, but that can be an even worse scenario. Distributed
    applications are highly dynamic, and visibility into every service is critical
    for maintaining service levels. Interdependencies can create complex failure scenarios,
    which is why observability is a key part of building cloud native applications.
    In data systems, the volumes that are commonplace need efficient ways of monitoring
    the flow and state of infrastructure. In most cases, early warnings for issues
    can help operators avoid costly downtime.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些事物发生了而你没有监控到它，那它是否发生了？不幸的是，答案不仅是肯定的，而且这可能是一个更糟糕的情况。分布式应用程序极具动态性，对每个服务的可见性至关重要，以维持服务水平。相互依赖关系可能导致复杂的故障场景，这就是为什么可观察性是构建云原生应用程序的关键部分。在数据系统中，常见的数据量需要高效的监控基础设施的流动和状态。在大多数情况下，对问题的早期警告可以帮助操作员避免昂贵的停机时间。
- en: 'With all the previous definitions in place, let’s try a definition that expresses
    these properties:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有先前的定义都已就绪的情况下，让我们尝试一个能表达这些属性的定义：
- en: '*Cloud native data* approaches empower organizations that have adopted the
    cloud native application methodology to incorporate data holistically rather than
    employ the legacy of people, process, technology, so that data can scale up and
    down elastically, and promote observability and self-healing. This is exemplified
    by containerized data, declarative data, data APIs, data meshes, and cloud native
    data infrastructure (that is, databases, streaming, and analytics technologies
    that are themselves architected as cloud native applications).'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*云原生数据*方法赋予那些采用云原生应用程序方法的组织综合整合数据的能力，而不是使用传统的人员、流程、技术遗留方式，使数据能够弹性地进行扩展和缩减，并促进可观察性和自愈。这通过容器化数据、声明式数据、数据API、数据网格和云原生数据基础设施（即以云原生应用程序架构的数据库、流处理和分析技术）得以体现。'
- en: For data infrastructure to keep parity with the rest of our application, we
    need to incorporate each piece. This includes automation of scale, elasticity,
    and self-healing. APIs are needed to decouple services and increase developer
    velocity, as well as enable you to observe the entire stack of your application
    to make critical decisions. Taken as a whole, your application and data infrastructure
    should appear as one unit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据基础设施与我们应用程序的其他部分保持一致，我们需要整合每一部分。这包括规模自动化、弹性和自愈。需要API来解耦服务并增加开发速度，还能帮助你观察应用程序整个堆栈以做出关键决策。总体而言，你的应用程序和数据基础设施应该表现为一个整体单元。
- en: More Infrastructure, More Problems
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多基础设施，更多问题
- en: 'Whether your infrastructure is in a cloud, on premises, or both (commonly referred
    to as *hybrid*), you could spend a lot of time doing manual configuration. Typing
    things into an editor and doing incredibly detailed configuration work requires
    deep knowledge of each technology. Over the past 20 years, significant advances
    have occurred in the DevOps community, both to code and the way we deploy our
    infrastructure. This is a critical step in the evolution of modern infrastructure.
    DevOps has kept us ahead of the scale required for applications, but just barely.
    Arguably, the same amount of knowledge is needed to fully script a single database
    server deployment. It’s just that now we can do it a million times over (if needed)
    with templates and scripts. What has been lacking is a connectedness between the
    components and a holistic view of the entire application stack. Let’s tackle this
    problem together. (Foreshadowing: this is a problem that needs to be solved.)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的基础设施是在云端、本地，还是两者兼有（通常称为*混合*），你可能需要大量时间进行手动配置。在编辑器中输入内容和进行详细的配置工作需要对每种技术有深入的了解。在过去的20年里，DevOps社区在代码和部署基础设施的方式上都取得了显著进展。这是现代基础设施演变的关键步骤。DevOps让我们保持在应用程序所需规模的前沿，但勉强而已。可以说，完全编写脚本化一个单一数据库服务器部署需要相同的知识量。只是现在我们可以使用模板和脚本做到一百万次（如果需要的话）。缺失的是组件之间的连接性和整个应用程序堆栈的整体视图。让我们一起解决这个问题。（预示：这是一个需要解决的问题。）
- en: 'As with any good engineering problem, let’s break it into manageable parts.
    The first is resource management. Regardless of the many ways we have developed
    to work at scale, fundamentally, we are trying to manage three things as efficiently
    as possible: compute, network, and storage, as shown in [Figure 1-3](#fundamental_resources_of_cloud_applicat).
    These are the critical resources that every application needs and the fuel that’s
    burned during growth. Not surprisingly, these are also the resources that carry
    the monetary component to a running application. We get rewarded when we use the
    resources wisely and pay a literal high price if we don’t. Anywhere you run your
    application, these are the most primitive units. When on prem, everything is bought
    and owned. When using the cloud, we’re renting.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何良好的工程问题一样，让我们将其分解成可管理的部分。第一个是资源管理。无论我们已经开发了多少种规模工作的方式，基本上，我们都在尽可能高效地管理三样东西：计算、网络和存储，如[图1-3](#fundamental_resources_of_cloud_applicat)所示。这些是每个应用程序所需的关键资源，也是在增长过程中消耗的燃料。毫不奇怪，这些资源也带有运行应用程序的货币成分。当我们明智地使用资源时，我们会得到回报，如果不这样做，我们将付出昂贵的代价。无论你在哪里运行应用程序，这些都是最基本的单元。在本地时，一切都是购买和拥有。在使用云时，我们是租赁的。
- en: '![Fundamental resources of cloud applications: compute, network, and storage](assets/mcdk_0103.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![云应用程序的基本资源：计算、网络和存储](assets/mcdk_0103.png)'
- en: 'Figure 1-3\. Fundamental resources of cloud applications: compute, network,
    and storage'
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 云应用程序的基本资源：计算、网络和存储
- en: The second part of the problem is having an entire stack act as a single entity.
    DevOps has provided many tools to manage individual components, but the connective
    tissue between them provides the potential for incredible efficiency—similarly
    to how applications are packaged for the desktop but working at datacenter scales.
    That potential has launched an entire community around cloud native applications.
    These applications are similar to what we’ve always deployed. The difference is
    that modern cloud applications aren’t a single process with business logic. They
    are a complex coordination of many containerized processes that need to communicate
    securely and reliably. Storage has to match the current needs of the application,
    but remain aware of how it contributes to the stability of the application. When
    we think of deploying stateless applications without data managed in the same
    control plane, it sounds incomplete because it is. Breaking your application components
    into different control planes creates more complexity and thus goes against the
    ideals of cloud native.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Leading the Way
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, DevOps automation has kept us on the leading edge of meeting
    scale needs. Containerization produced a need for much better orchestration, and
    Kubernetes has answered that need. For operators, describing a complete application
    stack in a deployment file makes a reproducible and portable infrastructure. This
    is because Kubernetes has gone far beyond the simple deployment management popular
    in the DevOps tool bag. The Kubernetes control plane applies the deployment requirement
    across the underlying compute, network, and storage to manage the entire application
    infrastructure lifecycle. The desired state of your application is maintained
    even when the underlying hardware changes. Instead of deploying VMs, we’re now
    deploying virtual datacenters as a complete definition, as shown in [Figure 1-4](#moving_from_virtual_servers_to_virtual).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The rise in popularity of Kubernetes has eclipsed all other container orchestration
    tools used in DevOps. It has overtaken every other way we deploy infrastructure
    and shows no signs of slowing down. However, the bulk of early adoption was primarily
    in stateless services.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Managing data infrastructure at a large scale was a problem well before the
    move to containers and Kubernetes. Stateful services like databases took a different
    track parallel to the Kubernetes adoption curve. Many experts advised that Kubernetes
    was the wrong way to run stateful services and that those workloads should remain
    outside of Kubernetes. That approach worked until it didn’t, and many of those
    same experts are now driving the needed changes in Kubernetes to converge the
    entire stack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving from virtual servers to virtual datacenters](assets/mcdk_0104.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. Moving from virtual servers to virtual datacenters
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, what are the challenges of stateful services? Why has it been hard to deploy
    data infrastructure with Kubernetes? Let’s consider each component of our infrastructure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有哪些有状态服务的挑战呢？为什么使用 Kubernetes 部署数据基础设施很困难？让我们逐个考虑基础设施的每个组件。
- en: Managing Compute on Kubernetes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上管理计算
- en: In data infrastructure, counting on Moore’s law has made upgrading a regular
    event. Moore’s law predicted that computing capacity would double every 18 months.
    If your requirements double every 18 months, you can keep up by replacing hardware.
    Eventually, raw compute power started leveling out. Vendors started adding more
    processors and cores to keep up with Moore’s law, leading to single-server resource
    sharing with VMs and containers, and enabling us to tap into the vast pools of
    computing power left stranded in islands of physical servers. Kubernetes expanded
    the scope of compute resource management by considering the total datacenter as
    one large resource pool across multiple physical devices.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据基础设施中，依赖摩尔定律使升级成为了一个常规事件。摩尔定律预测计算能力每18个月翻一番。如果您的需求每18个月翻一番，您可以通过更换硬件来跟上。最终，原始计算能力开始趋于平稳。供应商开始添加更多的处理器和核心，以跟上摩尔定律，导致单服务器资源共享与虚拟机和容器，使我们能够利用留在物理服务器岛屿上的大量计算能力。Kubernetes通过将整个数据中心视为跨多个物理设备的一个大资源池，扩展了计算资源管理的范围。
- en: Sharing compute resources with other services is somewhat taboo in the data
    world. Data workloads are typically resource intensive, and the potential of one
    service impacting another (known as the *noisy neighbor problem*) has led to policies
    of keeping them isolated from other workloads. This one-size-fits-all approach
    eliminates the possibility for more significant benefits. First is the assumption
    that all data service resource requirements are the same. Apache Pulsar brokers
    can have far fewer requirements than an Apache Spark worker, and neither are similar
    to a sizable MySQL instance used for online analytical processing (OLAP) reporting.
    Second, the ability to decouple your underlying hardware from running applications
    gives operators a lot of undervalued flexibility. Cloud native applications that
    need scale, elasticity, and self-healing need what Kubernetes can deliver. Data
    is no exception.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据世界中，与其他服务共享计算资源有些禁忌。数据工作负载通常资源密集，一个服务影响另一个服务的潜力（被称为 *noisy neighbor problem*）导致了保持它们与其他工作负载隔离的政策。这种一刀切的方法排除了更大利益的可能性。首先是假设所有数据服务的资源需求相同。Apache
    Pulsar 的代理比 Apache Spark 的工作节点要少得多，而且二者都不同于用于在线分析处理（OLAP）报告的大型 MySQL 实例。其次，将底层硬件与运行应用程序解耦使操作员拥有很多被低估的灵活性。需要规模化、弹性和自愈的云原生应用程序需要
    Kubernetes 所能提供的。数据也不例外。
- en: Managing Network on Kubernetes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上管理网络
- en: Building a distributed application, by nature, requires a reliable and secure
    network. Cloud native applications increase the complexity of adding and subtracting
    services, making dynamic network configuration a new requirement. Kubernetes manages
    all of this inside your virtual datacenter automatically. When new services come
    online, it’s like a virtual network team springs into action. IP addresses are
    assigned, routes are created, DNS entries are added, the virtual security team
    ensures that firewall rules are in place, and when asked, Transport Layer Securiity
    (TLS) certificates provide end-to-end encryption.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建分布式应用程序本质上需要可靠和安全的网络。云原生应用程序增加了添加和减少服务的复杂性，使动态网络配置成为新的需求。Kubernetes 在您的虚拟数据中心内自动管理所有这些。当新服务上线时，就像一个虚拟网络团队迅速行动起来。分配
    IP 地址，创建路由，添加 DNS 条目，虚拟安全团队确保防火墙规则得到执行，并在需要时提供传输层安全（TLS）证书以进行端到端加密。
- en: Data infrastructure tends to be far less dynamic than something like microservices.
    A fixed IP with a hostname has been the norm for databases. Analytic systems like
    Apache Flink are dynamic in processing but have fixed hardware addressing assignments.
    Quality of service is typically at the top of the requirements list and, as a
    result, the desire for dedicated hardware and dedicated networks has turned administrators
    off of Kubernetes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数据基础设施往往比微服务之类的东西不那么动态。数据库通常采用固定 IP 和主机名。像 Apache Flink 这样的分析系统在处理上是动态的，但硬件地址分配是固定的。服务质量通常位于需求列表的顶部，因此对专用硬件和专用网络的需求使管理员们对
    Kubernetes 失去了兴趣。
- en: The advantage of data infrastructure running in Kubernetes is less about the
    past requirements and more about what’s needed for the future. Scaling resources
    dynamically can create a waterfall of dependencies. Automation is the only way
    to maintain clean and efficient networks, which are the lifeblood of distributed,
    stateless systems. The future of cloud native applications will include more components
    and new challenges, such as where applications will run. We can add regulatory
    compliance and data sovereignty to previous concerns about latency and throughput.
    The declarative nature of Kubernetes networks make it a perfect fit for data infrastructure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据基础设施在 Kubernetes 中运行的优势不再仅限于过去的需求，更多地关注未来的需求。动态扩展资源可能会导致一系列依赖关系的产生。自动化是保持干净高效网络的唯一途径，而这些网络是分布式无状态系统的生命线。云原生应用的未来将包括更多组件和新挑战，例如应用程序将在何处运行。我们可以在之前对延迟和吞吐量的关注之外，增加法规合规性和数据主权问题。Kubernetes
    网络的声明性质使其非常适合用于数据基础设施。
- en: Managing Storage on Kubernetes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上管理存储
- en: Any service that provides persistence or analytics over large volumes of data
    will need the right kind of storage device. Early versions of Kubernetes considered
    storage a basic commodity part of the stack and assumed that most workloads were
    ephemeral. For data, this was a huge mismatch—you can’t let your Postgres datafiles
    get deleted every time a container is moved. Additionally, at the outset, the
    underlying block storage ranged from high-performance NVMe disks to old 5400 RPM
    spinning disks, and you could not always be certain what type of hardware you’d
    get. Thankfully, this has been an essential focus of Kubernetes over the past
    few years and has significantly improved.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何提供大数据量持久性或分析的服务都需要合适类型的存储设备。早期版本的 Kubernetes 认为存储是堆栈的基本商品部分，并假定大多数工作负载是短暂的。对于数据来说，这是一个巨大的不匹配——你不能让你的
    Postgres 数据文件在每次容器移动时被删除。另外，在最初阶段，底层块存储从高性能 NVMe 硬盘到旧的 5400 转每分钟的旋转硬盘不等，你并不总能确定将会得到何种类型的硬件。幸运的是，这些问题在过去几年中已成为
    Kubernetes 的重点关注，得到了显著改进。
- en: With the addition of features like StorageClasses, it is possible to address
    specific requirements for performance, capacity, or both. With automation, we
    can avoid the point when you don’t have enough of either. Avoiding surprises is
    the domain of capacity management—both initializing the needed capacity and growing
    when required. When you run out of capacity in your storage, everything grinds
    to a halt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 借助 StorageClasses 等功能的增加，可以针对性能、容量或两者都有的具体要求进行处理。通过自动化，我们可以避免因性能或容量不足而导致的问题。避免意外是容量管理的领域——无论是初始化所需的容量还是在需要时扩展。当存储容量不足时，所有事情都会陷入停滞。
- en: Coupling the distributed nature of Kubernetes with data storage opens up more
    possibilities for self-healing. Automated backups and snapshots keep you ready
    for potential data loss scenarios. Placing compute and storage together minimizes
    hardware failure risks and allows automatic recovery to the desired state when
    the inevitable failure occurs. All of this makes the data storage aspects of Kubernetes
    much more attractive.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Kubernetes 的分布式特性与数据存储耦合，为自愈开辟了更多可能性。自动化的备份和快照使您可以应对潜在的数据丢失情况。将计算和存储放在一起可以最小化硬件故障风险，并在不可避免的故障发生时自动恢复到期望的状态。所有这些都使得
    Kubernetes 的数据存储方面更加具有吸引力。
- en: Cloud Native Data Components
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生数据组件
- en: 'Now that we have defined the resources consumed in cloud native applications,
    let’s clarify the types of data infrastructure that powers them. Instead of a
    comprehensive list of every possible product, we’ll break them into larger buckets
    with similar characteristics:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了云原生应用程序中消耗的资源，让我们澄清一下支持它们的数据基础设施类型。与其列出每种可能的产品，我们将它们分为具有相似特性的大类：
- en: Persistence
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性
- en: 'This is likely the category you think of first when we talk about data infrastructure.
    These systems store data and provide access by some method of a query: relational
    databases like MySQL and Postgres, and NoSQL systems like Apache Cassandra and
    MongoDB. These have been the last holdouts to migrate to Kubernetes because of
    their strict resource needs and high-availability requirements. Databases are
    usually critical to a running application and central to every other part of the
    system.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论数据基础设施时，这可能是您首先考虑的类别。这些系统存储数据，并通过某种查询方法提供访问：如 MySQL 和 Postgres 等关系型数据库，以及
    Apache Cassandra 和 MongoDB 等 NoSQL 系统。由于其严格的资源需求和高可用性要求，这些系统一直是迁移到 Kubernetes
    的最后抵抗者。数据库通常对运行中的应用程序至关重要，并且是系统的每个其他部分的核心。
- en: Streaming
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流
- en: 'The most basic function of streaming is facilitating the high-speed movement
    of data from one point to another. Streaming systems provide a variety of delivery
    semantics based on a use case. In some cases, data can be delivered to many clients,
    or when strict controls are needed, delivered only once. A further enhancement
    of streaming is the addition of *processing*: altering or enhancing data mid-transport.
    The need for faster insights into data has propelled streaming analytics into
    mission-critical status, catching up with persistence systems in terms of importance.
    Examples of streaming systems that move data are Apache Flink and Apache Kafka,
    whereas processing system examples are Apache Flink and Apache Storm.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的最基本功能是促进数据从一点到另一点的高速移动。流处理系统根据使用案例提供各种交付语义。在某些情况下，数据可以传递给多个客户端，或者在需要严格控制时仅传递一次。流处理的进一步增强是*处理*：在传输过程中修改或增强数据。对数据更快速见解的需求推动了流处理分析成为重要的关键任务，与持久性系统在重要性上趋于接近。移动数据的流系统的示例包括
    Apache Flink 和 Apache Kafka，而处理系统的示例包括 Apache Flink 和 Apache Storm。
- en: Batch analytics
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理分析
- en: One of the first problems in big data is analyzing large sets of data to gain
    insights or repurpose into new data. Apache Hadoop was the first large-scale system
    for batch analytics that set the expectations around using large volumes of compute
    and storage, coordinated in a way to produce the results of complex analytic processes.
    Typically, these are issued as jobs distributed throughout the cluster, as is
    common with Spark. The concern with costs can be much more prevalent in these
    systems because of the sheer volume of resources needed. Orchestration systems
    help mitigate the costs by intelligent allocation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在大数据中，第一个问题之一是分析大量数据集以获取见解或重新利用为新数据。Apache Hadoop 是第一个大规模批处理分析系统，设定了使用大量计算和存储协调生成复杂分析过程结果的期望。通常，这些作业分布在整个集群中，这在
    Spark 中是常见的。这些系统由于所需资源的大量而更容易受到成本的担忧。编排系统通过智能分配帮助缓解成本。
- en: Looking Forward
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望未来
- en: 'There is a compelling future with cloud native data. The path we take between
    what we have available today and what we can have in the future is up to us: the
    community of people responsible for data infrastructure. Just as we have always
    done, we see a new challenge and take it on. There is plenty for everyone to do
    here, but the result could be pretty amazing and raise the bar yet again.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生数据的未来充满吸引力。我们如何利用今天可用的资源以及未来可以拥有的资源取决于我们：负责数据基础设施的社区。正如我们一直所做的，我们面临新的挑战并应对。在这里，每个人都有很多事情要做，但结果可能非常惊人，并再次提升标准。
- en: Rick’s point is specifically about databases, but we can extrapolate his call
    to action for our data infrastructure running on Kubernetes. Unlike deploying
    a data application on physical servers, introducing the Kubernetes control plane
    requires a conversation with the services it runs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Rick 的观点特别是关于数据库的，但我们可以推广他对我们在 Kubernetes 上运行数据基础设施的行动呼吁。与在物理服务器上部署数据应用不同，引入
    Kubernetes 控制平面需要与其运行的服务进行对话。
- en: Getting Ready for the Revolution
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为革命做好准备
- en: As engineers who create and run data infrastructure, we have to be ready for
    coming advancements, both in the way we operate and the mindset we have about
    the role of data infrastructure. The following sections describe what you can
    do to be ready for the future of cloud native data running in Kubernetes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建和运行数据基础设施的工程师，我们必须为即将到来的进步做好准备，无论是在操作方式上还是在我们对数据基础设施角色的思维方式上。接下来的章节描述了您可以为在
    Kubernetes 上运行的云原生数据的未来做好准备的内容。
- en: Adopt an SRE Mindset
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采纳 SRE 思维方式
- en: 'The role of site reliability engineering (SRE) has grown with the adoption
    of cloud native methodologies. If we intend our infrastructure to converge, we
    as data infrastructure engineers must learn new skills and adopt new practices.
    Let’s begin with the [Wikipedia definition of SRE](https://oreil.ly/lq1rc):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云原生方法的采用，站点可靠性工程（SRE）的角色已经增长。如果我们打算让基础设施趋同，作为数据基础设施工程师，我们必须学习新技能并采纳新实践。让我们从[SRE的维基百科定义](https://oreil.ly/lq1rc)开始：
- en: Site reliability engineering is a set of principles and practices that incorporates
    aspects of software engineering and applies them to infrastructure and operations
    problems. The main goals are to create scalable and highly reliable software systems.
    Site reliability engineering is closely related to DevOps, a set of practices
    that combine software development and IT operations, and SRE has also been described
    as a specific implementation of DevOps.
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 站点可靠性工程是一组原则和实践，它将软件工程的各个方面应用于基础设施和运维问题。其主要目标是创建可扩展和高度可靠的软件系统。站点可靠性工程与 DevOps
    密切相关，后者是结合了软件开发和IT运维的一组实践，而SRE也被描述为DevOps的一种具体实现。
- en: Deploying data infrastructure has been primarily concerned with the specific
    components deployed—the “what.” For example, you may find yourself focused on
    deploying MySQL at scale or using Spark to analyze large volumes of data. Adopting
    an SRE mindset means going beyond *what* you are deploying and focusing more on
    the *how*. How will all the pieces work together to meet the application’s goals?
    A holistic deployment view considers the way each piece will interact, the required
    access, including security, and the observability of every aspect to ensure that
    service levels are met.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 部署数据基础设施主要关注特定的部署组件——“是什么”。例如，你可能专注于大规模部署MySQL或使用Spark分析大量数据。采用SRE思维意味着超越你正在部署的“是什么”，更关注“如何”。每个部分如何相互作用、所需访问权限（包括安全性）以及每个方面的可观察性，以确保满足服务水平，这种整体部署视角。
- en: 'If your current primary or secondary role is database administrator (DBA),
    there is no better time to make the transition. The trend on LinkedIn shows a
    [year-over-year decrease in the DBA role](https://oreil.ly/4VFc7) and a massive
    increase for SREs. Engineers who have learned the skills required to run critical
    database infrastructure have an essential baseline that translates into what’s
    needed to manage cloud native data. These needs include the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你目前的主要或次要角色是数据库管理员（DBA），那么现在是进行转型的最佳时机。LinkedIn的趋势显示，数据库管理员角色的年度下降，而SRE角色则大幅增加。掌握运行关键数据库基础设施所需的技能，对于管理云原生数据至关重要。这些需求包括以下内容：
- en: Availability
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Latency
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟
- en: Change management
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更管理
- en: Emergency response
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应急响应
- en: Capacity management
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量管理
- en: 'New skills need to be added to this list to become better adapted to the more
    significant responsibility of the entire application. These are skills you may
    already have, but they include the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地适应整个应用程序更重要的责任，需要将新技能添加到此列表中。这些可能是你已经具备的技能，但它们包括以下内容：
- en: CI/CD pipelines
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 管道
- en: Embrace the big picture of taking code from repository to production. There’s
    nothing that accelerates application development more in an organization. Continuous
    integration (CI) builds new code into the application stack and automates all
    testing to ensure quality. Continuous delivery (CD) takes the fully tested and
    certified builds and automatically deploys them into production. Used in combination
    (pipeline), organizations can drastically increase developer velocity and productivity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接受从代码库到生产的大局观。在组织中，没有什么比加速应用程序开发更快的了。持续集成（CI）将新代码构建到应用程序堆栈中，并自动化所有测试以确保质量。持续交付（CD）获取完全测试和认证的构建，并自动部署到生产环境中。结合使用（管道），组织可以大幅提高开发速度和生产力。
- en: Observability
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性
- en: DevOps practitioners like to make a distinction between the “what” (the actual
    service you’re deploying) and the “how” (the methodology of deploying that service).
    Monitoring is something everyone with experience in infrastructure is familiar
    with. In the “what” part of DevOps, the properties you monitor let you know your
    services are healthy, and give you the information needed to diagnose problems.
    Observability expands monitoring into the “how” of your application by considering
    everything as a whole—for example, tracing the source of latency in a highly distributed
    application by giving insight into every hop that data takes as it traverses your
    system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps从业者喜欢区分“什么”（你实际部署的服务）和“如何”（部署该服务的方法）。每个有基础设施经验的人都熟悉监控。在DevOps的“什么”部分，你监控的属性可以让你知道你的服务是否健康，并提供诊断问题所需的信息。可观察性将监控扩展到应用程序的“如何”，通过考虑整体来考虑一切——例如，跟踪高度分布式应用程序中延迟源头，洞察数据在系统中传输时经过的每个跳跃。
- en: Knowing the code
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉代码
- en: When things go bad in a large, distributed application, the cause is not always
    a process failure. In many cases, the problem could be a bug in the code or a
    subtle implementation detail. Being responsible for the entire health of the application,
    you will need to understand the code that is executing in the provided environment.
    Properly implemented observability will help you find problems, and that includes
    the software instrumentation. SREs and development teams need to have clear and
    regular communication, and code is common ground.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当大型分布式应用程序出现问题时，问题并不总是进程失败。在许多情况下，问题可能是代码中的错误或微妙的实现细节。作为负责整个应用程序健康的人，你需要理解在提供的环境中执行的代码。正确实施的可观察性将帮助你找到问题，其中包括软件的仪器化。SREs和开发团队需要进行清晰且定期的沟通，而代码是共同的基础。
- en: Embrace Distributed Computing
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥抱分布式计算
- en: 'Deploying your applications in Kubernetes means embracing all that distributed
    computing offers. When you are accustomed to single-system thinking, that transition
    can be hard, mainly in the shift in thinking around expectations and understanding
    where problems crop up. For example, with every process contained in a single
    system, latency will be close to zero. It’s not what you have to manage. CPU and
    memory resources are the primary concern there. In the 1990s, Sun Microsystems
    was leading in the growing field of distributed computing and published this list
    of [eight common fallacies of distributed computing](https://oreil.ly/XAR93):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中部署应用程序意味着接受分布式计算所提供的一切。当你习惯于单一系统思维时，这种过渡可能很困难，主要是在期望和理解问题出现位置的思维转变方面。例如，每个进程都包含在单一系统中时，延迟将接近于零。这不是你需要管理的。CPU和内存资源是那里的主要关注点。在1990年代，Sun
    Microsystems在不断增长的分布式计算领域中处于领先地位，并发布了这份关于[分布式计算的八个常见误解](https://oreil.ly/XAR93)清单。
- en: The network is reliable.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是可靠的。
- en: Latency is zero.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟为零。
- en: Bandwidth is infinite.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽是无限的。
- en: The network is secure.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是安全的。
- en: Topology doesn’t change.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑结构不会改变。
- en: There is one administrator.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个管理员。
- en: Transport cost is zero.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运输成本为零。
- en: The network is homogeneous.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是同质的。
- en: Behind each of these fallacies is surely the story of a developer who made a
    bad assumption, got an unexpected result, and lost countless hours trying to solve
    the wrong problem. Embracing distributed methodologies is worth the effort in
    the long run. They allow us to build large-scale applications and will continue
    to do so for a long time. The challenge is worth the reward, and for those of
    us who do this daily, it can be a lot of fun too! Kubernetes applications will
    test each of these fallacies, given its default distributed nature. When you plan
    your deployment, consider things such as the cost of transport from one place
    to another or latency implications. They will save you a lot of wasted time and
    redesign.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个错误观念的背后肯定都有一个开发者的故事，他们做出了错误的假设，得到了意外的结果，并花费了无数小时来解决错误的问题。在长期来看，拥抱分布式方法是值得的。它们使我们能够构建大规模应用程序，并将继续如此很长一段时间。挑战值得回报，对于那些每天都在做这件事的人来说，这也可以很有趣！Kubernetes应用程序将测试这些错误观念的每一个，考虑到其默认的分布式特性。在计划部署时，考虑诸如从一个地方到另一个地方的传输成本或延迟影响是非常重要的。它们将节省大量浪费的时间和重新设计的成本。
- en: Principles of Cloud Native Data Infrastructure
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云原生数据基础设施的原则
- en: As engineering professionals, we seek standards and best practices to build
    upon. To make data the most “cloud native” it can be, we need to embrace everything
    Kubernetes offers. A truly cloud native approach means adopting key elements of
    the Kubernetes design paradigm and building from there. An entire cloud native
    application that includes data must be one that can run effectively on Kubernetes.
    Let’s explore a few Kubernetes design principles that point the way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为工程专业人员，我们寻求标准和最佳实践来构建。为了使数据尽可能“云原生”，我们需要拥抱 Kubernetes 提供的一切。真正的云原生方法意味着采用
    Kubernetes 设计范式的关键元素，并在此基础上构建。一个完全的云原生应用程序包括数据，必须能够在 Kubernetes 上有效运行。让我们探索一些指引方向的
    Kubernetes 设计原则。
- en: 'Principle 1: Leverage compute, network, and storage as commodity APIs'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 1：利用计算、网络和存储作为商品化的 API
- en: 'One of the keys to the success of cloud computing is the commoditization of
    compute, networking, and storage as resources we can provision via simple APIs.
    Consider this sampling of AWS services:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算成功的关键之一在于将计算、网络和存储作为可以通过简单API进行配置的资源进行商品化。考虑以下 AWS 服务示例：
- en: Compute
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 计算
- en: We allocate VMs through Amazon Elastic Compute Cloud (EC2) and Auto Scaling
    groups (ASGs).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 Amazon Elastic Compute Cloud（EC2）和 Auto Scaling groups（ASG）分配虚拟机。
- en: Network
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 网络
- en: We manage traffic using Elastic Load Balancers (ELB), Route 53, and virtual
    private cloud (VPC) peering.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Elastic Load Balancers（ELB）、Route 53 和虚拟私有云（VPC）对流量进行管理。
- en: Storage
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存储
- en: We persist data using options such as the Simple Storage Service (S3) for long-term
    object storage, or Elastic Block Store (EBS) volumes for our compute instances.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用诸如 Simple Storage Service（S3）用于长期对象存储，或 Elastic Block Store（EBS）卷用于计算实例的持久化数据。
- en: 'Kubernetes offers its own APIs to provide similar services for a world of containerized
    applications:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供自己的 API 来为容器化应用程序世界提供类似的服务：
- en: Compute
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 计算
- en: Pods, Deployments, and ReplicaSets manage the scheduling and lifecycle of containers
    on computing hardware.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Pods、Deployments 和 ReplicaSets 管理计算硬件上容器的调度和生命周期。
- en: Network
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 网络
- en: Services and Ingress expose a container’s networked interfaces.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Services 和 Ingress 暴露容器的网络接口。
- en: Storage
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 存储
- en: PersistentVolumes (PVs) and StatefulSets enable flexible association of containers
    to storage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PersistentVolumes（PV）和 StatefulSets 允许将容器灵活关联到存储。
- en: 'Kubernetes resources promote the portability of applications across Kubernetes
    distributions and service providers. What does this mean for databases? They are
    simply applications that leverage compute, networking, and storage resources to
    provide the services of data persistence and retrieval:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 资源促进了应用在 Kubernetes 发行版和服务提供商之间的可移植性。对数据库意味着什么？它们只是利用计算、网络和存储资源来提供数据持久性和检索服务的应用程序：
- en: Compute
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 计算
- en: A database needs sufficient processing power to process incoming data and queries.
    Each database node is deployed as a Pod and grouped into StatefulSets, enabling
    Kubernetes to manage scaling out and scaling in.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库需要足够的处理能力来处理传入的数据和查询。每个数据库节点部署为一个 Pod，并分组到 StatefulSets 中，使 Kubernetes 能够管理扩展和缩减。
- en: Network
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 网络
- en: A database needs to expose interfaces for data and control. We can use Kubernetes
    Services and Ingress controllers to expose these interfaces.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库需要暴露数据和控制的接口。我们可以使用 Kubernetes Services 和 Ingress controllers 来暴露这些接口。
- en: Storage
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 存储
- en: A database uses PersistentVolumes of a specified StorageClass to store and retrieve
    data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库使用指定 StorageClass 的 PersistentVolumes 来存储和检索数据。
- en: Thinking of databases in terms of their compute, network, and storage needs
    removes much of the complexity involved in deployment on Kubernetes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库视为其计算、网络和存储需求，有助于消除在 Kubernetes 上部署时涉及的大部分复杂性。
- en: 'Principle 2: Separate the control and data planes'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 2：分离控制平面和数据平面
- en: Kubernetes promotes the separation of control and data planes. The Kubernetes
    API server is the front door of the control plane, providing the interface used
    by the data plane to request computing resources, while the control plane manages
    the details of mapping those requests onto an underlying infrastructure-as-a-service
    (IaaS) platform.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 推广了控制平面和数据平面的分离。Kubernetes API 服务器是控制平面的前门，提供了数据平面用于请求计算资源的接口，而控制平面管理将这些请求映射到基础设施即服务（IaaS）平台的详细信息。
- en: We can apply this same pattern to databases. For example, a database data plane
    consists of ports exposed for clients, and for distributed databases, ports used
    for communication between database nodes. The control plane includes interfaces
    provided by the database for administration and metrics collection and tooling
    that performs operational maintenance tasks. Much of this capability can and should
    be implemented via the Kubernetes operator pattern. Operators define custom resources
    (CRDs) and provide control loops that observe the state of those resources, taking
    actions to move them toward the desired state, helping extend Kubernetes with
    domain-specific logic.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将同样的模式应用到数据库中。例如，数据库的数据平面包括为客户端暴露的端口，对于分布式数据库，还包括用于数据库节点之间通信的端口。控制平面包括数据库提供的用于管理和度量收集的接口，以及执行操作维护任务的工具。大部分甚至应该通过
    Kubernetes 运营商模式来实现。运营商定义自定义资源（CRD）并提供控制循环来观察这些资源的状态，采取行动使其朝向期望的状态，有助于使用特定于领域的逻辑扩展
    Kubernetes。
- en: 'Principle 3: Make observability easy'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 3：使可观察性变得简单
- en: The three pillars of observable systems are logging, metrics, and tracing. Kubernetes
    provides a great starting point by exposing the logs of each container to third-party
    log aggregation solutions. Multiple solutions are available for metrics, tracing,
    and visualization, and we’ll explore several of them in this book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测系统的三大支柱是日志、度量和追踪。Kubernetes 通过将每个容器的日志暴露给第三方日志聚合解决方案，为我们提供了一个很好的起点。度量、追踪和可视化都有多种解决方案可供选择，在本书中我们将探讨其中几种。
- en: 'Principle 4: Make the default configuration secure'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 4：使默认配置安全
- en: 'Kubernetes networking is secure by default: ports must be explicitly exposed
    in order to be accessed externally to a pod. This sets a valuable precedent for
    database deployment, forcing us to think carefully about how each control plane
    and data plane interface will be exposed and which interfaces should be exposed
    via a Kubernetes Service. Kubernetes also provides facilities for secret management
    that can be used for sharing encryption keys and configuring administrative accounts.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 网络默认安全：必须显式地暴露端口才能从 Pod 外部访问。这为数据库部署设定了有价值的先例，迫使我们仔细考虑每个控制平面和数据平面接口如何被暴露，以及哪些接口应通过
    Kubernetes 服务暴露。Kubernetes 还提供了用于秘密管理的设施，可用于共享加密密钥和配置管理账户。
- en: 'Principle 5: Prefer declarative configuration'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 5：优先选择声明式配置
- en: In the Kubernetes declarative approach, you specify the desired state of resources,
    and controllers manipulate the underlying infrastructure in order to achieve that
    state. Operators for data infrastructure can manage the details of how to scale
    up intelligently—for example, deciding how to reallocate shards or partitions
    when scaling out additional nodes or selecting which nodes to remove to scale
    down elastically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 的声明式方法中，您可以指定资源的期望状态，控制器将操作底层基础设施以实现该状态。数据基础设施的操作员可以智能地管理如何扩展，例如，在扩展额外节点时决定如何重新分配分片或分区，或选择何时移除节点以弹性地缩减规模。
- en: The next generation of operators should enable us to specify rules for stored
    data size, number of transactions per second, or both. Perhaps we’ll be able to
    specify maximum and minimum cluster sizes, and when to move less frequently used
    data to object storage. This will allow for more automation and efficiency in
    our data infrastructure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一代操作员应能够为存储数据大小、每秒事务数或两者都指定规则。也许我们将能够指定最大和最小的集群大小，以及何时将较少使用的数据移动到对象存储。这将有助于提升数据基础设施的自动化和效率。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: At this point, we hope you are ready for the exciting journey in the pages ahead.
    The move to cloud native applications must include data, and to do this, we will
    leverage Kuberentes to include stateless *and* stateful services. This chapter
    covered cloud native data infrastructure that can scale elastically and resist
    any downtime due to system failures, and how to build these systems. We as engineers
    must embrace the principles of cloud native infrastructure and, in some cases,
    learn new skills. Congratulations—you have begun a fantastic journey into the
    future of building cloud native applications. Turn the page, and let’s go!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此刻，我们希望你已经准备好迎接前面页面上的激动人心的旅程。迁移到云原生应用必须包括数据，在这方面，我们将利用Kubernetes来包含无状态*和*有状态服务。本章涵盖了能够弹性扩展并抵御系统故障引起的任何停机的云原生数据基础设施，以及如何构建这些系统。作为工程师，我们必须拥抱云原生基础设施的原则，并在某些情况下学习新技能。恭喜你——你已经开始了构建云原生应用未来的美妙旅程。翻页吧，让我们出发！
