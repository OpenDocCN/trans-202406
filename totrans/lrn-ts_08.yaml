- en: Chapter 6\. Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays and tuples
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One flexible and one fixed
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Choose your adventure
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'JavaScript arrays are wildly flexible and can hold any mixture of values inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, though, individual JavaScript arrays are intended to hold only
    one specific type of value. Adding values of a different type may be confusing
    to readers, or worse, the result of an error that could cause problems in the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript respects the best practice of keeping to one data type per array
    by remembering what type of data is initially inside an array, and only allowing
    the array to operate on that kind of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, TypeScript knows the `warriors` array initially contains `string`
    typed values, so while adding more `string` typed values is allowed, adding any
    other type of data is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can think of TypeScript’s inference of an array’s type from its initial
    members as similar to how it understands variable types from their initial values.
    TypeScript generally tries to understand the intended types of your code from
    how values are assigned, and arrays are no exception.
  prefs: []
  type: TYPE_NORMAL
- en: Array Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other variable declarations, variables meant to store arrays don’t need
    to have an initial value. The variables can start off `undefined` and receive
    an array value later.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript will want you to let it know what types of values are meant to go
    in the array by giving the variable a type annotation. The type annotation for
    an array requires the type of elements in the array followed by a `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Array types can also be written in a syntax like `Array<number>` called *class
    generics*. Most developers prefer the simpler `number[]`. Classes are covered
    in [Chapter 8, “Classes”](ch08.xhtml#classes), and generics are covered in [Chapter 9,
    “Type Modifiers”](ch09.xhtml#type_modifiers_chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Array and Function Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array types are an example of a syntax container where function types may need
    parentheses to distinguish what’s in the function type or not. Parentheses may
    be used to indicate which part of an annotation is the function return or the
    surrounding array type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createStrings` type here, which is a function type, is not the same as
    `stringCreators`, which is an array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Union-Type Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use a union type to indicate that each element of an array can be one
    of multiple select types.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using array types with unions, parentheses may need to be used to indicate
    which part of an annotation is the contents of the array or the surrounding union
    type. Using parentheses in array union types is important—the following two types
    are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript will understand from an array’s declaration that it is a union-type
    array if it contains more than one type of element. In other words, the type of
    an array’s elements is the union of all possible types for elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `namesMaybe` is `(string | undefined)[]` because it has both `string`
    values and an `undefined` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Evolving Any Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t include a type annotation on a variable initially set to an empty
    array, TypeScript will treat the array as evolving `any[]`, meaning it can receive
    any content. As with evolving `any` variables, we don’t like evolving `any[]`
    arrays. They partially negate the benefits of TypeScript’s type checker by allowing
    you to add potentially incorrect values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `values` array starts off containing `any` elements, evolves to contain
    `string` elements, then again evolves to include `number | string` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As with variables, allowing arrays to be evolving `any` typed—and using the
    `any` type in general—partially defeats the purpose of TypeScript’s type checking.
    TypeScript works best when it knows what types your values are meant to be.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A 2D array, or an array of arrays, will have two “[]”s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A 3D array, or an array of arrays of arrays, will have three “[]”s. 4D arrays
    have four “[]”s. 5D arrays have five “[]”s. You can guess where this is going
    for 6D arrays and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: These multidimensional array types don’t introduce any new concepts to array
    types. Think of a 2D array as taking in the original type, which just so happens
    to have `[]` at the end, and adding a `[]` after it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `arrayOfArraysOfNumbers` array is of type `number[][]`, which is also
    representable by `(number[])[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Array Members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript understands typical index-based access for retrieving members of
    an array to give back an element of that array’s type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `defenders` array is of type `string[]`, so `defender` is a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Members of union typed arrays are themselves that same union type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `soldiersOrDates` is of type `(string | Date)[]`, so the `soldierOrDate`
    variable is of type `string | Date`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Caveat: Unsound Members'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TypeScript type system is known to be technically *unsound*: it can get
    types mostly right, but sometimes its understanding about the types of values
    may be incorrect. Arrays in particular are a source of unsoundness in the type
    system. By default, TypeScript assumes all array member accesses return a member
    of that array, even though in JavaScript, accessing an array element with an index
    greater than the array’s length gives `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code gives no complaints with the default TypeScript compiler settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We as readers can deduce that it’ll crash at runtime with “`Cannot read property
    'length' of undefined`”, but TypeScript intentionally does not make sure retrieved
    array members exist. It sees `elements[9001]` in the code snippet as being type
    `string`, not `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TypeScript does have a `--noUncheckedIndexedAccess` flag that makes array lookups
    more restricted and type safe, but it’s quite strict and most projects don’t use
    it. I don’t cover it in this book. [Chapter 12, “Using IDE Features”](ch12.xhtml#using_ide_features)
    links to resources that explain all of TypeScript’s configuration options in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Spreads and Rests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember `...` rest parameters for functions from [Chapter 5, “Functions”](ch05.xhtml#functions)?
    Rest parameters and array spreading, both with the `...` operator, are key ways
    to interact with arrays in JavaScript. TypeScript understands both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Spreads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays can be joined together using the `...` spread operator. TypeScript understands
    the result array will contain values that can be from either of the input arrays.
  prefs: []
  type: TYPE_NORMAL
- en: If the input arrays are the same type, the output array will be that same type.
    If two arrays of different types are spread together to create a new array, the
    new array will be understood to be a union type array of elements that are either
    of the two original types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `conjoined` array is known to contain both values that are type `string`
    and values that are type `number`, so its type is inferred to be `(string | number)[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Spreading Rest Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript recognizes and will perform type checking on the JavaScript practice
    of `...` spreading an array as a rest parameter. Arrays used as arguments for
    rest parameters must have the same array type as the rest parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logWarriors` function below takes in only `string` values for its `...names`
    rest parameter. Spreading an array of type `string[]` is allowed, but a `number[]`
    is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although JavaScript arrays may be any size in theory, it is sometimes useful
    to use an array of a fixed size—also known as a *tuple*. Tuple arrays have a specific
    known type at each index that may be more specific than a union type of all possible
    members of the array. The syntax to declare a tuple type looks like an array literal,
    but with types in place of element values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the array `yearAndWarrior` is declared as being a tuple type with a `number`
    at index 0 and a `string` at index 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tuples are often used in JavaScript alongside array destructuring to be able
    to assign multiple values at once, such as setting two variables to initial values
    based on a single condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, TypeScript recognizes here that `year` is always going to be a
    `number` and `warrior` is always going to be a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tuple Assignability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuple types are treated by TypeScript as more specific than variable length
    array types. That means variable length array types aren’t assignable to tuple
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, although we as humans may see `pairLoose` as having `[boolean, number]`
    inside, TypeScript infers it to be the more general `(boolean | number)[]` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If `pairLoose` had been declared as a `[boolean, number]` itself, the assignment
    of its value to `pairTuple` would have been permitted.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples of different lengths are also not assignable to each other, as TypeScript
    includes knowing how many members are in the tuple in tuple types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `tupleTwoExtra` must have exactly two members, so although `tupleThree`
    starts with the correct members, its third member prevents it from being assignable
    to `tupleTwoExtra`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tuples as rest parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because tuples are seen as arrays with more specific type information on length
    and element types, they can be particularly useful for storing arguments to be
    passed to a function. TypeScript is able to provide accurate type checking for
    tuples passed as `...` rest parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `logPair` function’s parameters are typed `string` and `number`.
    Trying to pass in a value of type `(string | number)[]` as arguments wouldn’t
    be type safe as the contents might not match up: they could both be the same type,
    or one of each type in the wrong order. However, if TypeScript knows the value
    to be a `[string, number]` tuple, it understands the values match up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really want to go wild with your rest parameters tuples, you can mix
    them with arrays to store a list of arguments for multiple function calls. Here,
    `trios` is an array of tuples, where each tuple also has a tuple for its second
    member. `trios.forEach(trio => logTrio(...trio))` is known to be safe because
    each `...trio` happens to match the parameter types of `logTrio`. `trios.forEach(logTrio)`,
    however, is not assignable because that is attempting to pass the entire `[string,
    [number, boolean]` as the first parameter, which is type `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tuple Inferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript generally treats created arrays as variable length arrays, not tuples.
    If it sees an array being used as a variable’s initial value or the returned value
    for a function, then it will assume a flexible size array rather than a fixed
    size tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `firstCharAndSize` function is inferred as returning `(string
    |` `number)[]`, not `[string, number]`, because that’s the type inferred for its
    returned array literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two common ways in TypeScript to indicate that a value should be
    a more specific tuple type instead of a general array type: explicit tuple types
    and `const` assertions.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit tuple types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuple types may be used in type annotations, such as the return type annotation
    for a function. If the function is declared as returning a tuple type and returns
    an array literal, that array literal will be inferred to be a tuple instead of
    a more general variable-length array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `firstCharAndSizeExplicit` function version explicitly states that it
    returns a tuple of a `string` and `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Const asserted tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typing out tuple types in explicit type annotations can be a pain for the same
    reasons as typing out any explicit type annotations. It’s extra syntax for you
    to write and update as code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, TypeScript provides an `as const` operator known as a *const
    assertion* that can be placed after a value. Const assertions tell TypeScript
    to use the most literal, read-only possible form of the value when inferring its
    type. If one is placed after an array literal, it will indicate that the array
    should be treated as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `as const` assertions go beyond switching from flexible sized arrays
    to fixed size tuples: they also indicate to TypeScript that the tuple is read-only
    and cannot be used in a place that expects it should be allowed to modify the
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `pairMutable` is allowed to be modified because it has a traditional
    explicit tuple type. However, the `as const` makes the value not assignable to
    the mutable `pairAlsoMutable`, and members of the constant `pairConst` are not
    allowed to be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In practice, read-only tuples are convenient for function returns. Returned
    values from functions that return a tuple are often destructured immediately anyway,
    so the tuple being read-only does not get in the way of using the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `firstCharAndSizeAsConst` returns a `readonly [string, number]`, but the
    consuming code only cares about retrieving the values from that tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Read-only objects and `as const` assertions are covered more deeply in [Chapter 9,
    “Type Modifiers”](ch09.xhtml#type_modifiers_chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you worked with declaring arrays and retrieving their members:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring array types with `[]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parentheses to declare arrays of functions or union types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How TypeScript understands array elements as the type of the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `...` spreads and rests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring tuple types to represent fixed-size arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using type annotations or `as const` assertions to create tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/arrays*](https://learningtypescript.com/arrays).
  prefs: []
  type: TYPE_NORMAL
- en: What’s a pirate’s favorite data structure?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arrrrr-ays!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
