- en: Chapter 19\. ConfigMaps and Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes dedicates two primitives to defining configuration data: the ConfigMap
    and the Secret. Both primitives are completely decoupled from the life cycle of
    a Pod, which enables you to change their configuration data values without necessarily
    having to redeploy the Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: In essence, ConfigMaps and Secrets store a set of key-value pairs. Those key-value
    pairs can be injected into a container as environment variables, or they can be
    mounted as a Volume. [Figure 19-1](#consuming_configuration_data) illustrates
    the options.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1901](Images/ckd2_1901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-1\. Consuming configuration data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ConfigMap and Secret may look almost identical in purpose and structure
    on the surface; however, there is a slight but significant difference. A ConfigMap
    stores plain-text data, for example connection URLs, runtime flags, or even structured
    data like a JSON or YAML content. Secrets are better suited for representing sensitive
    data like passwords, API keys, or SSL certificates and store the data in base64-encoded
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption of ConfigMap and Secret data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cluster component that stores data of a ConfigMap and Secret object is etcd.
    Etcd manages this data in unencrypted form by default. You can configure encryption
    of data in etcd, as described in the [Kubernetes documentation](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
    Etcd encryption is not within the scope of the exam.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter references the concept of Volumes heavily. Refer to [Chapter 7](ch07.xhtml#volumes)
    to refresh your memory on the mechanics of consuming a Volume in a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications often implement logic that uses configuration data to control runtime
    behavior. Examples for configuration data include a connection URL and network
    communication options (like the number of retries or timeouts) to third-party
    services that differ between target deployment environments.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not unusual that the same configuration data needs to be made available
    to multiple Pods. Instead of copy-pasting the same key-value pairs across multiple
    Pod definitions, you can choose to centralize the information in a ConfigMap object.
    The ConfigMap object holds configuration data and can be consumed by as many Pods
    as you want. Therefore, you will need to modify the data in only one location
    should you need to change it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a ConfigMap by emitting the imperative `create configmap` command.
    This command requires you to provide the source of the data as an option. Kubernetes
    distinguishes the four different options shown in [Table 19-1](#source_options_configmap).
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-1\. Source options for data parsed by a ConfigMap
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-literal` | `--from-literal=locale=en_US` | Literal values, which
    are key-value pairs as plain text |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-env-file` | `--from-env-file=config.env` | A file that contains key-value
    pairs and expects them to be environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=app-config.json` | A file with arbitrary contents
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=config-dir` | A directory with one or many files
    |'
  prefs: []
  type: TYPE_TB
- en: It’s easy to confuse the options `--from-env-file` and `--from-file`. The option
    `--from-env-file` expects a file that contains environment variables in the format
    `KEY=value` separated by a new line. The key-value pairs follow typical naming
    conventions for environment variables (e.g., the key is uppercase, and individual
    words are separated by an underscore character). Historically, this option has
    been used to process [Docker Compose `.env` file](https://docs.docker.com/compose/environment-variables/env-file/),
    though you can use it for any other file containing environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `--from-env-file` option does not enforce or normalize the typical naming
    conventions for environment variables. The option `--from-file` points to a file
    or directory containing *any* arbitrary content. It’s an appropriate option for
    files with structured configuration data to be read by an application (e.g., a
    properties file, a JSON file, or an XML file).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows the creation of a ConfigMap in action. We are simply
    providing the key-value pairs as literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The resulting YAML object looks like the one shown in [Example 19-1](#configmap_yaml_manifest).
    As you can see, the object defines the key-value pairs in a section named `data`.
    A ConfigMap does not have a `spec` section.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-1\. ConfigMap YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the key assigned to the ConfigMap data follows the
    typical naming conventions used by environment variables. The intention is to
    consume them as such in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a ConfigMap as Environment Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the ConfigMap created, you can now inject its key-value pairs as environment
    variables into a container. [Example 19-2](#injecting_configmap_environment_variables)
    shows the use of `spec.containers[].envFrom[].configMapRef` to reference the ConfigMap
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-2\. Injecting ConfigMap key-value pairs into the container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the Pod from the YAML manifest, you can inspect the environment
    variables available in the container by running the `env` Unix command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The injected configuration data will be listed among environment variables available
    to the container.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a ConfigMap as a Volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to configure applications at runtime is by processing a machine-readable
    configuration file. Say we have decided to store the database configuration in
    a JSON file named *db.json* with the structure shown in [Example 19-3](#json_file_database_information).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-3\. A JSON file used for configuring database information
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we are not dealing with literal key-value pairs, we need to provide
    the option `--from-file` when creating the ConfigMap object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 19-4](#configmap_yaml_manifest_structured_data) shows the corresponding
    YAML manifest of the ConfigMap. You can see that the file name becomes the key;
    the contents of the file has used a multiline value.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-4\. ConfigMap YAML manifest defining structured data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The multiline string syntax (`|-`) used in this YAML structure removes the line
    feed and removes the trailing blank lines. For more information, see the [YAML
    syntax for multiline string](https://yaml-multiline.info/).
  prefs: []
  type: TYPE_NORMAL
- en: The Pod mounts the ConfigMap as a volume to a specific path inside of the container
    with read-only permissions. The assumption is that the application will read the
    configuration file when starting up. [Example 19-5](#mounting_configmap_volume)
    demonstrates the YAML definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-5\. Mounting a ConfigMap as a volume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Assign the volume type for referencing a ConfigMap object by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the correct behavior, open an interactive shell to the container.
    As you can see in the following commands, the directory */etc/config* contains
    a file with the key we used in the ConfigMap. The content represents the JSON
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The application code can now read the file from the mount path and configure
    the runtime behavior as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data stored in ConfigMaps represent arbitrary plain-text key-value pairs. In
    comparison to the ConfigMap, the Secret primitive is meant to represent sensitive
    configuration data. A typical example for Secret data is a password or an API
    key for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Values stored in a Secret are only encoded, not encrypted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets expect the value of each entry to be Base64-encoded. Base64 encodes
    only a value, but it doesn’t encrypt it. Therefore, anyone with access to its
    value can decode it without problems. Therefore, storing Secret manifests in the
    source code repository alongside other resource files should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: It’s somewhat unfortunate that the Kubernetes project decided to choose the
    term “Secret” to represent sensitive data. The nomenclature implies that data
    is actually secret and therefore encrypted. You can select from a range of options
    to keep sensitive data secure in real-world projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitnami Sealed Secrets](https://github.com/bitnami-labs/sealed-secrets) is
    an production-ready and proven Kubernetes operator that uses asymmetric crypto
    encryption for data. The manifest representation of the data, the CRD SealedSecret,
    is safe to be stored in a public source code repository. You cannot decrypt this
    data yourself. The controller installed with the operator is the only entity that
    can decrypt the data. Another option is to store sensitive data in external secrets
    managers, e.g., HashiCorp Vault or AWS Secrets Manager, and integrate them with
    Kubernetes. The [External Secrets Operator](https://external-secrets.io/) synchronizes
    secrets from external APIs into Kubernetes. The exam only expects you to understand
    the built-in Secret primitive, covered in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a Secret with the imperative command `create secret`. In addition,
    a mandatory subcommand needs to be provided that determines the type of Secret.
    [Table 19-2](#options_creating_secret) lists the different types. Kubernetes assigns
    the value in the Internal Type column to the `type` attribute in the live object.
    [“Specialized Secret types”](#specialized_secret_types) discusses other Secret
    types and their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-2\. Options for creating a Secret
  prefs: []
  type: TYPE_NORMAL
- en: '| CLI option | Description | Internal Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `generic` | Creates a secret from a file, directory, or literal value | `Opaque`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `docker-registry` | Creates a secret for use with a Docker registry, e.g.,
    to pull images from a private registry when requested by a Pod | `kubernetes.io/dockercfg`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tls` | Creates a TLS secret | `kubernetes.io/tls` |'
  prefs: []
  type: TYPE_TB
- en: The most commonly used Secret type is `generic`. The options for a generic Secret
    are exactly the same as for a ConfigMap, as shown in [Table 19-3](#source_options_data_secret).
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-3\. Source options for data parsed by a Secret
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-literal` | `--from-literal=password=secret` | Literal values, which
    are key-value pairs as plain text |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-env-file` | `--from-env-file=config.env` | A file that contains key-value
    pairs and expects them to be environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=id_rsa=~/.ssh/id_rsa` | A file with arbitrary
    contents |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=config-dir` | A directory with one or many files
    |'
  prefs: []
  type: TYPE_TB
- en: 'To demonstrate the functionality, let’s create a Secret of type `generic`.
    The command sources the key-value pairs from the literals provided as a command-line
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When created using the imperative command, a Secret will automatically Base64-encode
    the provided value. This can be observed by looking at the produced YAML manifest.
    You can see in [Example 19-6](#secret_base64_encoded_values) that the value `s3cre!`
    has been turned into `czNjcmUh`, the Base64-encoded equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-6\. A Secret with Base64-encoded values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The value `Opaque` for the type has been assigned to represent generic sensitive
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The plain-text value has been Base64-encoded automatically if the object has
    been created imperatively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with the YAML manifest to create the Secret object, you will need
    to create the Base64-encoded value if you want to assign it to the `data` attribute.
    A Unix tool that does the job is `base64`. The following command achieves exactly
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, if you have access to a Secret object or its YAML manifest then
    you can decode the Base64-encoded value at any time with the `base64` Unix tool.
    Therefore, you may as well specify the value in plain-text when defining the manifest,
    which we’ll discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Secret data with plain-text values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having to generate and assign Base64-encoded values to Secret manifests can
    become cumbersome. The Secret primitive offers the `stringData` attribute as a
    replacement for the `data` attribute. With `stringData`, you can assign plain-text
    values in the manifest file, as shown in [Example 19-7](#secret_plain_text_values).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-7\. A Secret with plain-text values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `stringData` attribute allows assigning plain-text key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The value referenced by the `pwd` key was provided in plain-text format.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes will automatically Base64-encode the `s3cre!` value upon creation
    of the object from the manifest. The result is the live object representation
    shown in [Example 19-8](#secret_live_object), which you can retrieve with the
    command `kubectl get secret db-creds -o yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-8\. A Secret live object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The live object of a Secret always uses the `data` attribute even though you
    may have used `stringData` in the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The value has been Base64-encoded upon creation.
  prefs: []
  type: TYPE_NORMAL
- en: You can represent arbitrary Secret data using the `Opaque` type. Kubernetes
    offers specialized Secret types you can choose from should the data fit specific
    uses cases. We’ll discuss those specialized Secret types in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Specialized Secret types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using the `Opaque` Secret type, you can also use one of the [specialized
    types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)
    to represent configuration data for particular use cases. The type `kubernetes.io/basic-auth`
    is meant for basic authentication and expects the keys `username` and `password`.
    At the time of writing, Kubernetes does not validate the correctness of the assigned
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: The created object from this definition automatically Base64-encodes the values
    for both keys. [Example 19-9](#secret_type_basic_auth) illustrates a YAML manifest
    for a Secret with type `kubernetes.io/basic-auth`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-9\. Usage of the Secret type kubernetes.io/basic-auth
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the `stringData` attribute to allow for assigning plain-text values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the mandatory keys required by the `kubernetes.io/basic-auth` Secret
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a Secret as Environment Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consuming a Secret as environment variables works similar to the way you’d do
    it for ConfigMaps. Here, you’d use the YAML expression `spec.containers[].env⁠From[].secretRef`
    to reference the name of the Secret. [Example 19-10](#injecting_secret_container)
    injects the Secret named `secret-basic-auth` as environment variables into the
    container named `backend`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-10\. Injecting Secret key-value pairs into the container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the environment variables in the container reveals that the Secret
    values do not have to be decoded. That’s something Kubernetes does automatically.
    Therefore, the running application doesn’t need to implement custom logic to decode
    the value. Note that Kubernetes does not verify or normalize the typical naming
    conventions of environment variables, as you can see in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remapping environment variable keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, key-value pairs stored in a Secret do not conform to typical naming
    conventions for environment variables or can’t be changed without impacting running
    services. You can redefine the keys used to inject an environment variable into
    a Pod with the `spec.containers[].env[].valueFrom` attribute. [Example 19-11](#remapping_environment_variable_keys)
    turns the key `username` into `USER` and the key `password` into `PWD`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-11\. Remapping environment variable keys for Secret entries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting environment variables available to the container now follow the
    typical conventions for environment variables, and we changed how their are consumed
    by the application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The same mechanism of reassigning environment variables works for ConfigMaps.
    You’d use the attribute `spec.containers[].env[].valueFrom.configMapRef` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a Secret as a Volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate mounting a Secret as a volume, we’ll create a new Secret of
    type `kubernetes.io/ssh-auth`. This Secret type captures the value of an SSH private
    key that you can view using the command `cat ~/.ssh/id_rsa`. To process the SSH
    private key file with the `create secret` command, it needs to be available as
    a file with the name `ssh-privatekey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Mounting the Secret as a volume follows the two-step approach: define the volume
    first and then reference it as a mount path for one or many containers. The volume
    type is called `secret` as used in [Example 19-12](#mounting_secret_volume).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-12\. Mounting a Secret as a volume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Files provided by the Secret mounted as volume cannot be modified.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the attribute `secretName` that points to the Secret name is not the
    same as for the ConfigMap (which is `name`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the file named `ssh-privatekey` in the mount path */var/app*.
    To verify, open an interactive shell and render the file contents. The contents
    of the file are not Base64-encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application runtime behavior can be controlled either by injecting configuration
    data as environment variables or by mounting a volume to a path. In Kubernetes,
    this configuration data is represented by the API resources ConfigMap and Secret
    in the form of key-value pairs. A ConfigMap is meant for plain-text data, and
    a Secret encodes the values in Base64 to obfuscate the values. Secrets are a better
    fit for sensitive information like credentials and SSH private keys.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice creating ConfigMap objects with the imperative and declarative approach
  prefs: []
  type: TYPE_NORMAL
- en: The quickest ways to create those objects are the imperative `kubectl create
    configmap` commands. Understand how to provide the data with the help of different
    command line flags. The ConfigMap specifies plain-text key-value pairs in the
    `data` section of YAML manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Practice creating Secret objects with the imperative and declarative approach
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret using the imperative command `kubectl create secret` does
    not require you to Base64-encode the provided values. `kubectl` performs the encoding
    operation automatically. The declarative approach requires the Secret YAML manifest
    to specify a Base64-encoded value with the `data` section. You can use the `stringData`
    convenience attribute in place of the `data` attribute if you prefer providing
    a plain-text value. The live object will use a Base64-encoded value. Functionally,
    there’s no difference at runtime between the use of `data` and `stringData`.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the purpose of specialized Secret types
  prefs: []
  type: TYPE_NORMAL
- en: Secrets offer specialized types, e.g., `kubernetes.io/basic-auth` or `kuber⁠netes.io/service-account-token`,
    to represent data for specific use cases. Read up on the different types in the
    Kubernetes documentation and understand their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to inspect ConfigMap and Secret data
  prefs: []
  type: TYPE_NORMAL
- en: The exam may confront you with existing ConfigMap and Secret objects. You need
    to understand how to use the `kubectl get` or the `kubectl describe` command to
    inspect the data of those objects. The live object of a Secret will always represent
    the value in a Base64-encoded format.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise the consumption of ConfigMaps and Secrets in Pods
  prefs: []
  type: TYPE_NORMAL
- en: The primary use case for ConfigMaps and Secrets is the consumption of the data
    from a Pod. Pods can inject configuration data into a container as environment
    variables or mount the configuration data as Volumes. For the exam, you need to
    be familiar with both consumption methods.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_015.xhtml#appendix_a_configmaps_secrets).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will first create a ConfigMap from a YAML configuration
    file as a source. Later, you’ll create a Pod, consume the ConfigMap as Volume,
    and inspect the key-value pairs as files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch19/configmap* of the checked-out GitHub repository
    [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide). Inspect
    the YAML configuration file named *application.yaml*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new ConfigMap named `app-config` from that file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Pod named `backend` that consumes the ConfigMap as Volume at the mount
    path */etc/config*. The container runs the image `nginx:1.23.4-alpine`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Shell into the Pod and inspect the file at the mounted Volume path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will first create a Secret from literal values in this exercise. Next, you’ll
    create a Pod and consume the Secret as environment variables. Finally, you’ll
    print out its values from within the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Secret named `db-credentials` with the key/value pair `db-password=passwd`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Pod named `backend` that uses the Secret as an environment variable
    named `DB_PASSWORD` and runs the container with the image `nginx:1.23.4-alpine`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Shell into the Pod and print out the created environment variables. You should
    be able to find the `DB_PASSWORD` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
