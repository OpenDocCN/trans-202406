- en: Chapter 19\. ConfigMaps and Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章。配置映射和机密
- en: 'Kubernetes dedicates two primitives to defining configuration data: the ConfigMap
    and the Secret. Both primitives are completely decoupled from the life cycle of
    a Pod, which enables you to change their configuration data values without necessarily
    having to redeploy the Pod.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes专门为定义配置数据而设计了两个基本概念：ConfigMap和Secret。这两个基本概念与Pod的生命周期完全解耦，这使得您可以更改它们的配置数据值，而无需重新部署Pod。
- en: In essence, ConfigMaps and Secrets store a set of key-value pairs. Those key-value
    pairs can be injected into a container as environment variables, or they can be
    mounted as a Volume. [Figure 19-1](#consuming_configuration_data) illustrates
    the options.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，配置映射和机密存储一组键值对。这些键值对可以作为环境变量注入到容器中，也可以作为卷挂载。[图19-1](#consuming_configuration_data)说明了选项。
- en: '![ckd2 1901](Images/ckd2_1901.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 1901](Images/ckd2_1901.png)'
- en: Figure 19-1\. Consuming configuration data
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图19-1。消耗配置数据
- en: The ConfigMap and Secret may look almost identical in purpose and structure
    on the surface; however, there is a slight but significant difference. A ConfigMap
    stores plain-text data, for example connection URLs, runtime flags, or even structured
    data like a JSON or YAML content. Secrets are better suited for representing sensitive
    data like passwords, API keys, or SSL certificates and store the data in base64-encoded
    form.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，配置映射和机密在目的和结构上几乎相同；然而，它们之间存在一个轻微但重要的区别。配置映射存储纯文本数据，例如连接URL、运行时标志，甚至结构化数据，如JSON或YAML内容。机密更适合表示像密码、API密钥或SSL证书等敏感数据，并以base64编码形式存储数据。
- en: Encryption of ConfigMap and Secret data
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置映射和机密数据的加密
- en: The cluster component that stores data of a ConfigMap and Secret object is etcd.
    Etcd manages this data in unencrypted form by default. You can configure encryption
    of data in etcd, as described in the [Kubernetes documentation](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
    Etcd encryption is not within the scope of the exam.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 存储配置映射和机密对象数据的集群组件是etcd。Etcd默认以未加密形式管理此数据。您可以按照[Kubernetes文档](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)中的描述配置etcd中的数据加密。Etcd加密不在考试范围内。
- en: This chapter references the concept of Volumes heavily. Refer to [Chapter 7](ch07.xhtml#volumes)
    to refresh your memory on the mechanics of consuming a Volume in a Pod.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大量涉及卷的概念。请参考[第7章](ch07.xhtml#volumes)，以重新了解在Pod中使用卷的机制。
- en: Working with ConfigMaps
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置映射
- en: Applications often implement logic that uses configuration data to control runtime
    behavior. Examples for configuration data include a connection URL and network
    communication options (like the number of retries or timeouts) to third-party
    services that differ between target deployment environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常实现使用配置数据来控制运行时行为的逻辑。配置数据的示例包括连接URL和网络通信选项（如第三方服务之间的重试次数或超时）在不同目标部署环境中的差异。
- en: It’s not unusual that the same configuration data needs to be made available
    to multiple Pods. Instead of copy-pasting the same key-value pairs across multiple
    Pod definitions, you can choose to centralize the information in a ConfigMap object.
    The ConfigMap object holds configuration data and can be consumed by as many Pods
    as you want. Therefore, you will need to modify the data in only one location
    should you need to change it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同一配置数据需要在多个Pod中提供并不罕见。您可以选择将信息集中在一个配置映射对象中，而不是在多个Pod定义中复制粘贴相同的键值对。配置映射对象保存配置数据，并可以由尽可能多的Pod消耗。因此，如果需要更改数据，则只需在一个位置进行修改即可。
- en: Creating a ConfigMap
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建配置映射
- en: You can create a ConfigMap by emitting the imperative `create configmap` command.
    This command requires you to provide the source of the data as an option. Kubernetes
    distinguishes the four different options shown in [Table 19-1](#source_options_configmap).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用命令行`create configmap`来创建配置映射。此命令要求您以选项的形式提供数据的来源。Kubernetes区分如[表19-1](#source_options_configmap)所示的四种不同选项。
- en: Table 19-1\. Source options for data parsed by a ConfigMap
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表19-1。配置映射解析的数据源选项
- en: '| Option | Example | Description |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `--from-literal` | `--from-literal=locale=en_US` | Literal values, which
    are key-value pairs as plain text |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `--from-literal` | `--from-literal=locale=en_US` | 字面值，即键-值对的纯文本形式 |'
- en: '| `--from-env-file` | `--from-env-file=config.env` | A file that contains key-value
    pairs and expects them to be environment variables |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `--from-env-file` | `--from-env-file=config.env` | 包含键值对并期望它们作为环境变量的文件 |'
- en: '| `--from-file` | `--from-file=app-config.json` | A file with arbitrary contents
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `--from-file` | `--from-file=app-config.json` | 一个包含任意内容的文件 |'
- en: '| `--from-file` | `--from-file=config-dir` | A directory with one or many files
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `--from-file` | `--from-file=config-dir` | 一个包含一个或多个文件的目录 |'
- en: It’s easy to confuse the options `--from-env-file` and `--from-file`. The option
    `--from-env-file` expects a file that contains environment variables in the format
    `KEY=value` separated by a new line. The key-value pairs follow typical naming
    conventions for environment variables (e.g., the key is uppercase, and individual
    words are separated by an underscore character). Historically, this option has
    been used to process [Docker Compose `.env` file](https://docs.docker.com/compose/environment-variables/env-file/),
    though you can use it for any other file containing environment variables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易混淆选项`--from-env-file`和`--from-file`。选项`--from-env-file`期望一个文件，该文件包含以新行分隔的`KEY=value`格式的环境变量。键值对遵循环境变量的典型命名约定（例如，键是大写的，并且单词之间用下划线分隔）。从历史上看，此选项已用于处理[Docker
    Compose `.env`文件](https://docs.docker.com/compose/environment-variables/env-file/)，尽管您可以将其用于包含环境变量的任何其他文件。
- en: The `--from-env-file` option does not enforce or normalize the typical naming
    conventions for environment variables. The option `--from-file` points to a file
    or directory containing *any* arbitrary content. It’s an appropriate option for
    files with structured configuration data to be read by an application (e.g., a
    properties file, a JSON file, or an XML file).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`--from-env-file`选项不强制或规范环境变量的典型命名约定。`--from-file`选项指向一个包含*任何*任意内容的文件或目录。这是用于包含应用程序读取的结构化配置数据文件的合适选项（例如，属性文件、JSON
    文件或 XML 文件）。'
- en: 'The following command shows the creation of a ConfigMap in action. We are simply
    providing the key-value pairs as literals:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了创建 ConfigMap 的过程。我们只需提供键值对作为字面量：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The resulting YAML object looks like the one shown in [Example 19-1](#configmap_yaml_manifest).
    As you can see, the object defines the key-value pairs in a section named `data`.
    A ConfigMap does not have a `spec` section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 YAML 对象看起来像示例 19-1中显示的对象。正如您所见，该对象在名为`data`的部分中定义了键值对。ConfigMap 没有`spec`部分。
- en: Example 19-1\. ConfigMap YAML manifest
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-1。ConfigMap YAML 清单
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may have noticed that the key assigned to the ConfigMap data follows the
    typical naming conventions used by environment variables. The intention is to
    consume them as such in a container.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，分配给 ConfigMap 数据的键遵循环境变量使用的典型命名约定。这样做的目的是在容器中以这种方式使用它们。
- en: Consuming a ConfigMap as Environment Variables
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ConfigMap 作为环境变量消耗
- en: With the ConfigMap created, you can now inject its key-value pairs as environment
    variables into a container. [Example 19-2](#injecting_configmap_environment_variables)
    shows the use of `spec.containers[].envFrom[].configMapRef` to reference the ConfigMap
    by name.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ConfigMap 后，您现在可以将其键值对作为环境变量注入到容器中。[示例 19-2](#injecting_configmap_environment_variables)展示了使用`spec.containers[].envFrom[].configMapRef`来按名称引用
    ConfigMap。
- en: Example 19-2\. Injecting ConfigMap key-value pairs into the container
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-2。将 ConfigMap 键值对注入到容器中
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After creating the Pod from the YAML manifest, you can inspect the environment
    variables available in the container by running the `env` Unix command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从 YAML 清单创建 Pod 后，您可以通过运行`env`Unix命令来检查容器中可用的环境变量。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The injected configuration data will be listed among environment variables available
    to the container.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的配置数据将列在容器可用的环境变量中。
- en: Mounting a ConfigMap as a Volume
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为卷挂载 ConfigMap
- en: Another way to configure applications at runtime is by processing a machine-readable
    configuration file. Say we have decided to store the database configuration in
    a JSON file named *db.json* with the structure shown in [Example 19-3](#json_file_database_information).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在运行时配置应用程序的方法是处理机器可读的配置文件。假设我们决定将数据库配置存储在名为*db.json*的 JSON 文件中，其结构如示例 19-3所示。
- en: Example 19-3\. A JSON file used for configuring database information
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-3。用于配置数据库信息的 JSON 文件
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Given that we are not dealing with literal key-value pairs, we need to provide
    the option `--from-file` when creating the ConfigMap object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们不处理字面上的键值对，创建 ConfigMap 对象时需要提供选项`--from-file`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 19-4](#configmap_yaml_manifest_structured_data) shows the corresponding
    YAML manifest of the ConfigMap. You can see that the file name becomes the key;
    the contents of the file has used a multiline value.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例19-4](#configmap_yaml_manifest_structured_data)显示了ConfigMap的相应YAML清单。可以看到文件名成为键；文件内容使用了多行值。'
- en: Example 19-4\. ConfigMap YAML manifest defining structured data
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例19-4。定义结构化数据的ConfigMap YAML清单
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO1-1)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO1-1)'
- en: The multiline string syntax (`|-`) used in this YAML structure removes the line
    feed and removes the trailing blank lines. For more information, see the [YAML
    syntax for multiline string](https://yaml-multiline.info/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此YAML结构中使用的多行字符串语法(`|-`)删除了换行符并去除了尾随空白行。有关更多信息，请参见[YAML多行字符串的语法](https://yaml-multiline.info/)。
- en: The Pod mounts the ConfigMap as a volume to a specific path inside of the container
    with read-only permissions. The assumption is that the application will read the
    configuration file when starting up. [Example 19-5](#mounting_configmap_volume)
    demonstrates the YAML definition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Pod将ConfigMap作为卷挂载到容器内的特定路径，并具有只读权限。假设应用程序将在启动时读取配置文件。[示例19-5](#mounting_configmap_volume)演示了YAML定义。
- en: Example 19-5\. Mounting a ConfigMap as a volume
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例19-5。将ConfigMap挂载为卷
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO2-1)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO2-1)'
- en: Assign the volume type for referencing a ConfigMap object by name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 分配卷类型以通过名称引用ConfigMap对象。
- en: 'To verify the correct behavior, open an interactive shell to the container.
    As you can see in the following commands, the directory */etc/config* contains
    a file with the key we used in the ConfigMap. The content represents the JSON
    configuration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证正确的行为，请打开一个交互式shell到容器。如下命令所示，目录*/etc/config*包含一个文件，其中包含我们在ConfigMap中使用的键。内容表示JSON配置：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The application code can now read the file from the mount path and configure
    the runtime behavior as needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码现在可以从挂载路径读取文件，并根据需要配置运行时行为。
- en: Working with Secrets
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Secrets
- en: Data stored in ConfigMaps represent arbitrary plain-text key-value pairs. In
    comparison to the ConfigMap, the Secret primitive is meant to represent sensitive
    configuration data. A typical example for Secret data is a password or an API
    key for authentication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在ConfigMaps中的数据表示任意的明文键值对。与ConfigMap相比，Secret原语旨在表示敏感的配置数据。Secret数据的典型示例是用于认证的密码或API密钥。
- en: Values stored in a Secret are only encoded, not encrypted
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储在Secret中的值仅进行编码，而不是加密。
- en: Secrets expect the value of each entry to be Base64-encoded. Base64 encodes
    only a value, but it doesn’t encrypt it. Therefore, anyone with access to its
    value can decode it without problems. Therefore, storing Secret manifests in the
    source code repository alongside other resource files should be avoided.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets期望每个条目的值都是Base64编码的。Base64仅对值进行编码，但不进行加密。因此，任何具有其值访问权限的人都可以毫无问题地解码它。因此，应避免将Secret清单存储在源代码仓库中，与其他资源文件一起。
- en: It’s somewhat unfortunate that the Kubernetes project decided to choose the
    term “Secret” to represent sensitive data. The nomenclature implies that data
    is actually secret and therefore encrypted. You can select from a range of options
    to keep sensitive data secure in real-world projects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes项目决定选择“Secret”这个术语来表示敏感数据，有些令人遗憾。命名暗示数据实际上是秘密的，因此应进行加密。您可以从多种选项中选择，以确保在现实世界的项目中保持敏感数据的安全性。
- en: '[Bitnami Sealed Secrets](https://github.com/bitnami-labs/sealed-secrets) is
    an production-ready and proven Kubernetes operator that uses asymmetric crypto
    encryption for data. The manifest representation of the data, the CRD SealedSecret,
    is safe to be stored in a public source code repository. You cannot decrypt this
    data yourself. The controller installed with the operator is the only entity that
    can decrypt the data. Another option is to store sensitive data in external secrets
    managers, e.g., HashiCorp Vault or AWS Secrets Manager, and integrate them with
    Kubernetes. The [External Secrets Operator](https://external-secrets.io/) synchronizes
    secrets from external APIs into Kubernetes. The exam only expects you to understand
    the built-in Secret primitive, covered in the following sections.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bitnami 密封的 Secrets](https://github.com/bitnami-labs/sealed-secrets) 是一个成熟且经过验证的
    Kubernetes 操作器，使用非对称加密技术进行数据加密。数据的清单表示，即 CRD 密封的 Secret，可以安全地存储在公共源代码库中。您无法自行解密此数据。安装了操作器的控制器是唯一可以解密数据的实体。另一个选项是将敏感数据存储在外部
    Secrets 管理器中，例如 HashiCorp Vault 或 AWS Secrets Manager，并将其与 Kubernetes 集成。[External
    Secrets Operator](https://external-secrets.io/) 将外部 API 中的 Secrets 同步到 Kubernetes
    中。考试只要求您理解内置的 Secret 原语，在下面的章节中进行了详细介绍。'
- en: Creating a Secret
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 Secret
- en: You can create a Secret with the imperative command `create secret`. In addition,
    a mandatory subcommand needs to be provided that determines the type of Secret.
    [Table 19-2](#options_creating_secret) lists the different types. Kubernetes assigns
    the value in the Internal Type column to the `type` attribute in the live object.
    [“Specialized Secret types”](#specialized_secret_types) discusses other Secret
    types and their use cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令`create secret`来创建一个 Secret。此外，需要提供一个必需的子命令，以确定 Secret 的类型。[Table 19-2](#options_creating_secret)
    列出了不同类型。Kubernetes 将 Internal Type 列中的值分配给 live 对象中的 `type` 属性。[“专用 Secret 类型”](#specialized_secret_types)
    讨论了其他 Secret 类型及其用途。
- en: Table 19-2\. Options for creating a Secret
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Table 19-2\. 创建 Secret 的选项
- en: '| CLI option | Description | Internal Type |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| CLI 选项 | 描述 | 内部类型 |'
- en: '| --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `generic` | Creates a secret from a file, directory, or literal value | `Opaque`
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `generic` | 从文件、目录或明文值创建 Secret | `Opaque` |'
- en: '| `docker-registry` | Creates a secret for use with a Docker registry, e.g.,
    to pull images from a private registry when requested by a Pod | `kubernetes.io/dockercfg`
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `docker-registry` | 创建用于 Docker 注册表的 Secret，例如，在 Pod 请求时从私有注册表拉取镜像 | `kubernetes.io/dockercfg`
    |'
- en: '| `tls` | Creates a TLS secret | `kubernetes.io/tls` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `tls` | 创建一个 TLS Secret | `kubernetes.io/tls` |'
- en: The most commonly used Secret type is `generic`. The options for a generic Secret
    are exactly the same as for a ConfigMap, as shown in [Table 19-3](#source_options_data_secret).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的 Secret 类型是 `generic`。泛型 Secret 的选项与 ConfigMap 完全相同，如 [Table 19-3](#source_options_data_secret)
    所示。
- en: Table 19-3\. Source options for data parsed by a Secret
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Table 19-3\. 解析为 Secret 的数据源选项
- en: '| Option | Example | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `--from-literal` | `--from-literal=password=secret` | Literal values, which
    are key-value pairs as plain text |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `--from-literal` | `--from-literal=password=secret` | 明文键值对的文字值 |'
- en: '| `--from-env-file` | `--from-env-file=config.env` | A file that contains key-value
    pairs and expects them to be environment variables |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `--from-env-file` | `--from-env-file=config.env` | 包含键值对并期望它们成为环境变量的文件 |'
- en: '| `--from-file` | `--from-file=id_rsa=~/.ssh/id_rsa` | A file with arbitrary
    contents |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `--from-file` | `--from-file=id_rsa=~/.ssh/id_rsa` | 包含任意内容的文件 |'
- en: '| `--from-file` | `--from-file=config-dir` | A directory with one or many files
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `--from-file` | `--from-file=config-dir` | 包含一个或多个文件的目录 |'
- en: 'To demonstrate the functionality, let’s create a Secret of type `generic`.
    The command sources the key-value pairs from the literals provided as a command-line
    option:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示功能，让我们创建一个类型为`generic`的秘密。该命令从作为命令行选项提供的文字中获取键值对：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When created using the imperative command, a Secret will automatically Base64-encode
    the provided value. This can be observed by looking at the produced YAML manifest.
    You can see in [Example 19-6](#secret_base64_encoded_values) that the value `s3cre!`
    has been turned into `czNjcmUh`, the Base64-encoded equivalent.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令创建时，Secret 将自动对提供的值进行 Base64 编码。这可以通过查看生成的 YAML 清单来观察到。您可以在 [Example 19-6](#secret_base64_encoded_values)
    中看到值 `s3cre!` 已被转换为 `czNjcmUh`，即其 Base64 编码的等效值。
- en: Example 19-6\. A Secret with Base64-encoded values
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-6\. 含有 Base64 编码值的 Secret
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO3-1)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO3-1)'
- en: The value `Opaque` for the type has been assigned to represent generic sensitive
    data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`Opaque`的值被分配用于表示通用敏感数据。
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO3-2)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO3-2)'
- en: The plain-text value has been Base64-encoded automatically if the object has
    been created imperatively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是通过命令式方式创建的，那么纯文本值会自动进行Base64编码。
- en: 'If you start with the YAML manifest to create the Secret object, you will need
    to create the Base64-encoded value if you want to assign it to the `data` attribute.
    A Unix tool that does the job is `base64`. The following command achieves exactly
    that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用YAML清单开始创建秘密对象，则需要创建Base64编码的值以便将其分配给`data`属性。Unix工具`base64`可以完成此工作。以下命令正好实现了这一点：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As a reminder, if you have access to a Secret object or its YAML manifest then
    you can decode the Base64-encoded value at any time with the `base64` Unix tool.
    Therefore, you may as well specify the value in plain-text when defining the manifest,
    which we’ll discuss in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您可以访问秘密对象或其YAML清单，那么您可以随时使用Unix工具`base64`解码Base64编码的值。因此，在定义清单时，您也可以指定纯文本值，我们将在下一节讨论。
- en: Defining Secret data with plain-text values
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用纯文本值定义秘密数据
- en: Having to generate and assign Base64-encoded values to Secret manifests can
    become cumbersome. The Secret primitive offers the `stringData` attribute as a
    replacement for the `data` attribute. With `stringData`, you can assign plain-text
    values in the manifest file, as shown in [Example 19-7](#secret_plain_text_values).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 必须生成并分配Base64编码的值到秘密清单可能变得繁琐。秘密原语提供了`stringData`属性来替代`data`属性。使用`stringData`，您可以在清单文件中分配纯文本值，正如在[示例 19-7](#secret_plain_text_values)中展示的那样。
- en: Example 19-7\. A Secret with plain-text values
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-7\. 一个包含纯文本值的秘密
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO4-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO4-1)'
- en: The `stringData` attribute allows assigning plain-text key-value pairs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringData`属性允许分配纯文本键值对。'
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO4-2)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO4-2)'
- en: The value referenced by the `pwd` key was provided in plain-text format.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd`键引用的值以纯文本格式提供。'
- en: Kubernetes will automatically Base64-encode the `s3cre!` value upon creation
    of the object from the manifest. The result is the live object representation
    shown in [Example 19-8](#secret_live_object), which you can retrieve with the
    command `kubectl get secret db-creds -o yaml`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在从清单创建对象时会自动对`s3cre!`值进行Base64编码。结果是在[示例 19-8](#secret_live_object)中展示的实时对象表示，您可以使用`kubectl
    get secret db-creds -o yaml`命令检索它。
- en: Example 19-8\. A Secret live object
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-8\. 一个实时秘密对象
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO5-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO5-1)'
- en: The live object of a Secret always uses the `data` attribute even though you
    may have used `stringData` in the manifest.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个秘密的实时对象总是使用`data`属性，即使在清单中可能使用了`stringData`。
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO5-2)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO5-2)'
- en: The value has been Base64-encoded upon creation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时值已经被Base64编码。
- en: You can represent arbitrary Secret data using the `Opaque` type. Kubernetes
    offers specialized Secret types you can choose from should the data fit specific
    uses cases. We’ll discuss those specialized Secret types in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Opaque`类型表示任意秘密数据。Kubernetes提供了专门的秘密类型供您选择，以适应特定的用例。我们将在下一节讨论这些专门的秘密类型。
- en: Specialized Secret types
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专门的秘密类型
- en: Instead of using the `Opaque` Secret type, you can also use one of the [specialized
    types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)
    to represent configuration data for particular use cases. The type `kubernetes.io/basic-auth`
    is meant for basic authentication and expects the keys `username` and `password`.
    At the time of writing, Kubernetes does not validate the correctness of the assigned
    keys.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用其中一个[专门类型](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)来表示特定用例的配置数据，而不是使用`Opaque`秘密类型。类型`kubernetes.io/basic-auth`适用于基本认证，并期望键`username`和`password`。在撰写时，Kubernetes不验证分配的键的正确性。
- en: The created object from this definition automatically Base64-encodes the values
    for both keys. [Example 19-9](#secret_type_basic_auth) illustrates a YAML manifest
    for a Secret with type `kubernetes.io/basic-auth`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义创建的对象会自动为两个键的值进行Base64编码。[示例 19-9](#secret_type_basic_auth)展示了一个具有类型`kubernetes.io/basic-auth`的秘密的YAML清单。
- en: Example 19-9\. Usage of the Secret type kubernetes.io/basic-auth
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-9\. 使用kubernetes.io/basic-auth秘密类型
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO6-1)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO6-1)'
- en: Uses the `stringData` attribute to allow for assigning plain-text values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stringData`属性允许分配明文值。
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO6-2)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO6-2)'
- en: Specifies the mandatory keys required by the `kubernetes.io/basic-auth` Secret
    type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了`kubernetes.io/basic-auth`秘密类型所需的强制键。
- en: Consuming a Secret as Environment Variables
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为环境变量消费秘密
- en: Consuming a Secret as environment variables works similar to the way you’d do
    it for ConfigMaps. Here, you’d use the YAML expression `spec.containers[].env⁠From[].secretRef`
    to reference the name of the Secret. [Example 19-10](#injecting_secret_container)
    injects the Secret named `secret-basic-auth` as environment variables into the
    container named `backend`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与ConfigMaps的环境变量类似，将秘密作为环境变量消费的工作方式。在这里，您将使用YAML表达式`spec.containers[].env⁠From[].secretRef`来引用秘密的名称。[示例 19-10](#injecting_secret_container)将名为`secret-basic-auth`的秘密作为环境变量注入到名为`backend`的容器中。
- en: Example 19-10\. Injecting Secret key-value pairs into the container
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-10\. 将秘密键值对注入容器
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inspecting the environment variables in the container reveals that the Secret
    values do not have to be decoded. That’s something Kubernetes does automatically.
    Therefore, the running application doesn’t need to implement custom logic to decode
    the value. Note that Kubernetes does not verify or normalize the typical naming
    conventions of environment variables, as you can see in the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器中的环境变量会显示，秘密值无需解码。这是Kubernetes自动完成的操作。因此，运行的应用程序无需实现自定义逻辑来解码该值。请注意，Kubernetes不验证或规范化环境变量的典型命名约定，正如您在以下输出中看到的：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remapping environment variable keys
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重映射环境变量键
- en: Sometimes, key-value pairs stored in a Secret do not conform to typical naming
    conventions for environment variables or can’t be changed without impacting running
    services. You can redefine the keys used to inject an environment variable into
    a Pod with the `spec.containers[].env[].valueFrom` attribute. [Example 19-11](#remapping_environment_variable_keys)
    turns the key `username` into `USER` and the key `password` into `PWD`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，存储在秘密中的键值对不符合环境变量的典型命名约定，或者在不影响正在运行的服务的情况下无法更改。您可以使用`spec.containers[].env[].valueFrom`属性重新定义用于将环境变量注入Pod中的键。[示例 19-11](#remapping_environment_variable_keys)将键`username`转换为`USER`，将键`password`转换为`PWD`。
- en: Example 19-11\. Remapping environment variable keys for Secret entries
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-11\. 重映射秘密条目的环境变量键
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting environment variables available to the container now follow the
    typical conventions for environment variables, and we changed how their are consumed
    by the application code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，容器可用的环境变量遵循环境变量的典型约定，并且我们改变了它们在应用程序代码中的消费方式：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The same mechanism of reassigning environment variables works for ConfigMaps.
    You’d use the attribute `spec.containers[].env[].valueFrom.configMapRef` instead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重新分配环境变量键的相同机制适用于ConfigMaps。您将使用属性`spec.containers[].env[].valueFrom.configMapRef`。
- en: Mounting a Secret as a Volume
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将秘密作为卷挂载
- en: 'To demonstrate mounting a Secret as a volume, we’ll create a new Secret of
    type `kubernetes.io/ssh-auth`. This Secret type captures the value of an SSH private
    key that you can view using the command `cat ~/.ssh/id_rsa`. To process the SSH
    private key file with the `create secret` command, it needs to be available as
    a file with the name `ssh-privatekey`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示将秘密作为卷挂载，我们将创建一个新的类型为`kubernetes.io/ssh-auth`的秘密。这种秘密类型捕获了SSH私钥的值，您可以使用命令`cat
    ~/.ssh/id_rsa`查看。要使用`create secret`命令处理SSH私钥文件，需要将其作为名为`ssh-privatekey`的文件可用：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Mounting the Secret as a volume follows the two-step approach: define the volume
    first and then reference it as a mount path for one or many containers. The volume
    type is called `secret` as used in [Example 19-12](#mounting_secret_volume).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密作为卷挂载遵循两步骤的方法：首先定义卷，然后将其引用为一个或多个容器的挂载路径。卷类型称为`secret`，如[示例 19-12](#mounting_secret_volume)中使用的那样。
- en: Example 19-12\. Mounting a Secret as a volume
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-12\. 将秘密作为卷挂载
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO7-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_configmaps_and_secrets_CO7-1)'
- en: Files provided by the Secret mounted as volume cannot be modified.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由作为卷挂载的秘密提供的文件无法修改。
- en: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO7-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_configmaps_and_secrets_CO7-2)'
- en: Note that the attribute `secretName` that points to the Secret name is not the
    same as for the ConfigMap (which is `name`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the file named `ssh-privatekey` in the mount path */var/app*.
    To verify, open an interactive shell and render the file contents. The contents
    of the file are not Base64-encoded:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application runtime behavior can be controlled either by injecting configuration
    data as environment variables or by mounting a volume to a path. In Kubernetes,
    this configuration data is represented by the API resources ConfigMap and Secret
    in the form of key-value pairs. A ConfigMap is meant for plain-text data, and
    a Secret encodes the values in Base64 to obfuscate the values. Secrets are a better
    fit for sensitive information like credentials and SSH private keys.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice creating ConfigMap objects with the imperative and declarative approach
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The quickest ways to create those objects are the imperative `kubectl create
    configmap` commands. Understand how to provide the data with the help of different
    command line flags. The ConfigMap specifies plain-text key-value pairs in the
    `data` section of YAML manifest.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Practice creating Secret objects with the imperative and declarative approach
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secret using the imperative command `kubectl create secret` does
    not require you to Base64-encode the provided values. `kubectl` performs the encoding
    operation automatically. The declarative approach requires the Secret YAML manifest
    to specify a Base64-encoded value with the `data` section. You can use the `stringData`
    convenience attribute in place of the `data` attribute if you prefer providing
    a plain-text value. The live object will use a Base64-encoded value. Functionally,
    there’s no difference at runtime between the use of `data` and `stringData`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Understand the purpose of specialized Secret types
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Secrets offer specialized types, e.g., `kubernetes.io/basic-auth` or `kuber⁠netes.io/service-account-token`,
    to represent data for specific use cases. Read up on the different types in the
    Kubernetes documentation and understand their purpose.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Know how to inspect ConfigMap and Secret data
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The exam may confront you with existing ConfigMap and Secret objects. You need
    to understand how to use the `kubectl get` or the `kubectl describe` command to
    inspect the data of those objects. The live object of a Secret will always represent
    the value in a Base64-encoded format.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Exercise the consumption of ConfigMaps and Secrets in Pods
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The primary use case for ConfigMaps and Secrets is the consumption of the data
    from a Pod. Pods can inject configuration data into a container as environment
    variables or mount the configuration data as Volumes. For the exam, you need to
    be familiar with both consumption methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_015.xhtml#appendix_a_configmaps_secrets).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will first create a ConfigMap from a YAML configuration
    file as a source. Later, you’ll create a Pod, consume the ConfigMap as Volume,
    and inspect the key-value pairs as files.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch19/configmap* of the checked-out GitHub repository
    [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide). Inspect
    the YAML configuration file named *application.yaml*.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new ConfigMap named `app-config` from that file.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Pod named `backend` that consumes the ConfigMap as Volume at the mount
    path */etc/config*. The container runs the image `nginx:1.23.4-alpine`.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Shell into the Pod and inspect the file at the mounted Volume path.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will first create a Secret from literal values in this exercise. Next, you’ll
    create a Pod and consume the Secret as environment variables. Finally, you’ll
    print out its values from within the container.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Secret named `db-credentials` with the key/value pair `db-password=passwd`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Pod named `backend` that uses the Secret as an environment variable
    named `DB_PASSWORD` and runs the container with the image `nginx:1.23.4-alpine`.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Shell into the Pod and print out the created environment variables. You should
    be able to find the `DB_PASSWORD` variable.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
