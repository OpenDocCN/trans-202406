["```\nsuspend fun getItems(): List<Item> {\n     val items = mutableListOf<Item>()\n     items.add(makeItem())\n     items.add(makeItem())\n     items.add(makeItem())\n     return items\n}\n\nsuspend fun makeItem(): Item {\n    delay(10) // simulate some asynchronism\n    return Item()\n}\n```", "```\nfun consumeItems(items: List<Item>) {\n     for (item in items) println(\"Do something with $item\")\n}\n```", "```\nfun main() = runBlocking {\n     val items = getItems()\n     consumeItems(items)\n}\n```", "```\nfun main() = runBlocking {\n    val channel = Channel<Item>()\n    launch {                        ![1](assets/1.png)\n        channel.send(Item(1))       ![3](assets/3.png)\n        channel.send(Item(2))       ![4](assets/4.png)\n        println(\"Done sending\")\n    }\n\n    println(channel.receive())      ![2](assets/2.png)\n    println(channel.receive())      ![5](assets/5.png)\n\n    println(\"Done!\")\n}\n\ndata class Item(val number: Int)\n```", "```\nItem(number=1)\nItem(number=2)\nDone!\nDone sending\n```", "```\nfor (x in channel) {\n   // do something with x every time some coroutine sends an element in\n   // the channel\n}\n```", "```\nfun main() = runBlocking {\n    val channel = Channel<Item>()\n    launch {\n        channel.send(Item(1))\n        channel.send(Item(2))\n        println(\"Done sending\")\n        channel.close()\n    }\n\n    for (x in channel) {\n        println(x)\n    }\n    println(\"Done!\")\n}\n```", "```\nItem(number=1)\nItem(number=2)\nDone sending\nDone!\n```", "```\nfun main() = runBlocking {\n    val channel = Channel<Int>()\n    channel.close()\n\n    for (x in channel) {\n        println(x)\n    }\n    println(\"Done!\")\n}\n```", "```\npublic fun <E> Channel(capacity: Int = RENDEZVOUS): Channel<E> =\n    when (capacity) {\n        RENDEZVOUS -> RendezvousChannel()\n        UNLIMITED -> LinkedListChannel()\n        CONFLATED -> ConflatedChannel()\n        BUFFERED -> ArrayChannel(CHANNEL_DEFAULT_CAPACITY)\n        else -> ArrayChannel(capacity)\n    }\n```", "```\nfun main() = runBlocking {\n    val channel = Channel<Int>(UNLIMITED)\n    val childJob = launch(Dispatchers.Default) {\n        println(\"Child executing from ${Thread.currentThread().name}\")\n        var i = 0\n        while (isActive) {\n            channel.send(i++)\n        }\n        println(\"Child is done sending\")\n    }\n\n    println(\"Parent executing from ${Thread.currentThread().name}\")\n    for (x in channel) {\n        println(x)\n\n        if (x == 1000_000) {\n            childJob.cancel()\n            break\n        }\n    }\n\n    println(\"Done!\")\n}\n```", "```\nParent executing from main\nChild executing from DefaultDispatcher-worker-2\n0\n1\n..\n1000000\nDone!\nChild is done sending\n```", "```\nfun main() = runBlocking {\n    val channel = Channel<String>(Channel.CONFLATED)\n\n    val job = launch {\n        channel.send(\"one\")\n        channel.send(\"two\")\n    }\n\n    job.join()\n    val elem = channel.receive()\n    println(\"Last value was: $elem\")\n}\n```", "```\nLast value was: two\n```", "```\nfun main() = runBlocking<Unit> {\n    val channel = Channel<Int>(2)\n\n    launch {\n        for (i in 0..4) {\n            println(\"Send $i\")\n            channel.send(i)\n        }\n    }\n\n    launch {\n        for (i in channel) {\n            println(\"Received $i\")\n        }\n    }\n}\n```", "```\nSend 0\nSend 1\nSend 2\nReceived 0\nReceived 1\nReceived 2\nSend 3\nSend 4\nReceived 3\nReceived 4\n```", "```\nfun CoroutineScope.produceValues(): ReceiveChannel<String> = produce {\n    send(\"one\")\n    send(\"two\")\n}\n```", "```\nfun main() = runBlocking {\n    val receiveChannel = produceValues()\n\n    for (e in receiveChannel) {\n        println(e)\n    }\n}\n```", "```\npublic interface Channel<E> : SendChannel<E>, ReceiveChannel<E> {\n    // code removed for brevity\n}\n```", "```\nfun CoroutineScope.collectImages(imagesOutput: SendChannel<Image>) {\n    launch(Dispatchers.IO) {\n        val image = readImage()\n        imagesOutput.send(image)\n    }\n}\n```", "```\ndata class Shape(val location: Location, val data: ShapeData)\ndata class Location(val x: Int, val y: Int)\nclass ShapeData\n```", "```\n               fetchData\nLocation ---------------------> ShapeData\n```", "```\nclass ShapeCollector {\n    private val locationsBeingProcessed = mutableListOf<Location>()\n\n    fun processLocation(location: Location) {\n        if (locationsBeingProcessed.add(location)) {\n             // fetch data, then send back a Shape instance to\n             // the view-model\n        }\n    }\n}\n```", "```\nlaunch {\n    val locationsBeingProcessed = mutableListOf<Location>()     ![1](assets/1.png)\n\n    for (location in locations) {                               ![2](assets/2.png)\n        // same code from previous figure\n    }\n}\n```", "```\nprivate fun CoroutineScope.collectShapes(\n     locations: ReceiveChannel<Location>\n) = launch {\n     // code removed for brevity\n}\n```", "```\nprivate fun CoroutineScope.collectShapes(\n     locations: ReceiveChannel<Location>\n) = launch {\n     val locationsBeingProcessed = mutableListOf<Location>()\n\n     for (loc in locations) {\n         if (!locationsBeingProcessed.contains(loc) {\n              launch(Dispatchers.IO) {\n                   // fetch the corresponding `ShapeData`\n              }\n         }\n    }\n}\n```", "```\nprivate fun CoroutineScope.collectShapes(\n     locations: ReceiveChannel<Location>,\n     locationsToProcess: SendChannel<Location>,\n) = launch {\n     val locationsBeingProcessed = mutableListOf<Location>()\n\n     for (loc in locations) {\n         if (!locationsBeingProcessed.contains(loc) {\n              launch(Dispatchers.IO) {\n                   locationsToProcess.send(loc)\n              }\n         }\n    }\n}\n```", "```\nprivate fun CoroutineScope.worker(\n        locationsToProcess: ReceiveChannel<Location>,\n) = launch(Dispatchers.IO) {\n        for (loc in locationsToProcess) {\n             // fetch the ShapeData, see later\n        }\n}\n```", "```\nprivate fun CoroutineScope.worker(\n    locationsToProcess: ReceiveChannel<Location>,\n    locationsProcessed: SendChannel<Location>,\n    shapesOutput: SendChannel<Shape>\n) = launch(Dispatchers.IO) {\n    for (loc in locationsToProcess) {\n        try {\n            val data = getShapeData(loc)\n            val shape = Shape(loc, data)\n            shapesOutput.send(shape)\n        } finally {\n            locationsProcessed.send(loc)\n        }\n    }\n}\n```", "```\nprivate suspend fun getShapeData(\n    location: Location\n): ShapeData = withContext(Dispatchers.IO) {\n        /* Simulate some remote API delay */\n        delay(10)\n        ShapeData()\n}\n```", "```\nprivate fun CoroutineScope.collectShapes(\n     locations: ReceiveChannel<Location>,\n     locationsToProcess: SendChannel<Location>,\n     locationsProcessed: ReceiveChannel<Location>\n): Job = launch {\n     ...\n     for (loc in locations) {\n          // same implementation, hidden for brevity\n     }\n     // but.. how do we iterate over locationsProcessed?\n}\n```", "```\nselect<Unit> {\n    locations.onReceive { loc ->\n        // do action 1\n    }\n    locationsProcessed.onReceive { loc ->\n        // do action 2\n    }\n}\n```", "```\nprivate fun CoroutineScope.collectShapes(\n    locations: ReceiveChannel<Location>,\n    locationsToProcess: SendChannel<Location>,\n    locationsProcessed: ReceiveChannel<Location>\n) = launch(Dispatchers.Default) {\n\n    val locationsBeingProcessed = mutableListOf<Location>()\n\n    while (true) {\n        select<Unit> {\n            locationsProcessed.onReceive {                     ![1](assets/1.png)\n                locationsBeingProcessed.remove(it)\n            }\n            locations.onReceive {                              ![2](assets/2.png)\n                if (!locationsBeingProcessed.any { loc ->\n                    loc == it }) {\n                    /* Add it to the list of locations being processed */\n                    locationsBeingProcessed.add(it)\n\n                    /* Now download the shape at location */\n                    locationsToProcess.send(it)\n                }\n            }\n        }\n    }\n}\n```", "```\nclass ShapeCollector(private val workerCount: Int) {\n    fun CoroutineScope.start(\n        locations: ReceiveChannel<Location>,\n        shapesOutput: SendChannel<Shape>\n    ) {\n        val locationsToProcess = Channel<Location>()\n        val locationsProcessed = Channel<Location>(capacity = 1)\n\n        repeat(workerCount) {\n             worker(locationsToProcess, locationsProcessed, shapesOutput)\n        }\n        collectShapes(locations, locationsToProcess, locationsProcessed)\n    }\n\n    private fun CoroutineScope.collectShapes // already implemented\n\n    private fun CoroutineScope.worker        // already implemented\n\n    private suspend fun getShapeData         // already implemented\n}\n```", "```\nfun main() = runBlocking<Unit> {\n    val shapes = Channel<Shape>()                ![1](assets/1.png)\n    val locations = Channel<Location>()\n\n    with(ShapeCollector(4)) {                    ![2](assets/2.png)\n        start(locations, shapes)\n        consumeShapes(shapes)\n    }\n\n    sendLocations(locations)\n}\n\nvar count = 0\n\nfun CoroutineScope.consumeShapes(\n    shapesInput: ReceiveChannel<Shape>\n) = launch {\n    for (shape in shapesInput) {\n        // increment a counter of shapes\n        count++                                  ![3](assets/3.png)\n    }\n}\n\nfun CoroutineScope.sendLocations(\n    locationsOutput: SendChannel<Location>\n) = launch {\n    withTimeoutOrNull(3000) {                    ![4](assets/4.png)\n        while (true) {\n            /* Simulate fetching some shape location */\n            val location = Location(Random.nextInt(), Random.nextInt())\n            locationsOutput.send(location)\n        }\n    }\n    println(\"Received $count shapes\")\n}\n```", "```\nfun CoroutineScope.sendLocations(locationsOutput: SendChannel<Location>) = launch {\n    withTimeoutOrNull(3000) {\n        while (true) {\n            /* Simulate fetching some shape location */\n            val location = Location(Random.nextInt(), Random.nextInt())\n            println(\"Sending a new location\")\n            locationsOutput.send(location)      // suspending call\n        }\n    }\n    println(\"Received $count shapes\")\n}\n```", "```\nReceived 4 shapes\n```", "```\nReceived 4 shapes\n```", "```\nfun CoroutineScope.numbers(): ReceiveChannel<Int> = produce {\n    send(1)\n    send(2)\n    // send other numbers\n}\n```", "```\nfun main() = runBlocking {\n    val channel = numbers()\n    for (x in channel) {\n        println(x)\n    }\n}\n```", "```\nsuspend fun transform(n: Int) = withContext(Dispatchers.Default) {\n    delay(10) // simulate some heavy CPU computations\n    n + 1\n}\n```", "```\nfun CoroutineScope.numbers(): ReceiveChannel<Int> = produce {\n    send(transform(1))\n    send(transform(2))\n}\n```", "```\nfun main() = runBlocking {\n    /* Warning - this doesn't compile */\n    val channel = numbers().map {\n        transform(it)\n    }\n    for (x in channel) {\n        println(x)\n    }\n}\n```", "```\npublic fun <E> CoroutineScope.produce(                           ![1](assets/1.png)\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0,\n    @BuilderInference block: suspend ProducerScope<E>.() -> Unit\n): ReceiveChannel<E> {\n    val channel = Channel<E>(capacity)\n    val newContext = newCoroutineContext(context)\n    val coroutine = ProducerCoroutine(newContext, channel)\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)    ![2](assets/2.png)\n    return coroutine\n}\n```", "```\nfun CoroutineScope.numbers(): ReceiveChannel<Int> = produce {\n    use(openConnectionToDatabase()) {\n        send(1)\n        send(2)\n    }\n}\n```"]