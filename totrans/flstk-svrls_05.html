<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Custom Authentication Strategies"><div class="chapter" id="ch5">
<h1><span class="label">Chapter 5. </span>Custom Authentication Strategies</h1>


<p><a data-type="indexterm" data-primary="custom authentication strategies" id="idm45364347507720"/>In this chapter, we will be building and improving the app we completed in <a data-type="xref" href="ch04.xhtml#ch4">Chapter 4</a>, where you learned how to use the <code>withAuthenticator</code> HOC to create a preconfigured authentication form. You also learned how to use React Router and the <code>Auth</code> class to create public and protected routes based on the user’s signed-in state.</p>

<p>While this lays the foundation for what can be done with Amplify and the basics around authentication and routing, we want to go one step further and build a completely custom authentication flow so we know exactly what is going on under the hood and understand the logic and state needed to manage a <em>custom authentication form</em>. This means that we need to update our app to have custom forms for signing up, signing in, and resetting our password instead of using the <code>withAuthenticator</code> HOC.</p>

<p><a data-type="indexterm" data-primary="protected routes" id="idm45364347503048"/>We will also take the idea of <em>protected routes</em> one step further by creating a hook that we can reuse to wrap any component we are wanting to protect with authentication (instead of rewriting the logic in each component).</p>

<p>The <code>Auth</code> class, with over 30 different methods, is very powerful and allows you to handle all of the authentication logic that most applications demand. By the end of this chapter, you will understand how to use the <code>Auth</code> class and React state to build and manage a custom authentication form.</p>






<section data-type="sect1" data-pdf-bookmark="Creating the protectedRoute Hook"><div class="sect1" id="idm45364347499960">
<h1>Creating the protectedRoute Hook</h1>

<p><a data-type="indexterm" data-primary="creating" data-secondary="protectedRoute hook" id="idm45364347498408"/><a data-type="indexterm" data-primary="protectedRoute hook" id="idm45364347497432"/>The first thing we will do is to create the custom <code>protectedRoute</code> hook that we will be using to protect any routes that require authentication. This hook will check for the signed-in user information, and if the user is not signed in, will redirect them to the sign-in page or another specified route. If the user is signed in, the hook will return and render the component passed in as an argument. By using this hook, we can do away with any duplicate logic around authentication that we may need across multiple components.</p>

<p>In the <em>src</em> directory, create a new file called <em>protectedRoute.js</em> and add the following code:</p>

<pre data-type="programlisting">import React, { useEffect } from 'react'
import { Auth } from 'aws-amplify'

const protectedRoute = (Comp, route = '/profile') =&gt; (props) =&gt; {
  async function checkAuthState() {
    try {
      await Auth.currentAuthenticatedUser()
    } catch (err) {
      props.history.push(route)
    }
  }
  useEffect(() =&gt; {
    checkAuthState()
  }, [])
  return &lt;Comp {...props} /&gt;
}

export default protectedRoute</pre>

<p><a data-type="indexterm" data-primary="useEffect hook" id="idm45364347492936"/>This component uses the <code>useEffect</code> hook when the component loads to check if the user is signed in. If the user is signed in, nothing happens and the component that is passed in as an argument gets rendered. If the user is not signed in, we do a redirect.</p>

<p>The redirect route can either be passed in as the second argument to the hook, or if no redirect route is passed in, we set the default to be <code>/profile</code>. Now, we can use the hook to protect any component like this:</p>

<pre data-type="programlisting">// Default redirect route
export default protectedRoute(App)

// Custom redirect route
export default protectedRoute(App, '/about-us')</pre>

<p>Now that the protected route hook has been created, we can begin the refactor of our app. The next thing we may want to do is update the <code>Protected</code> component in our app to use this new <code>protectedRoute</code> hook. To do so, open <em>Protected.js</em> and update the component with this code:</p>

<pre data-type="programlisting">import React from 'react';
import Container from './Container'
import protectedRoute from './protectedRoute'

function Protected() {
  return (
    &lt;Container&gt;
      &lt;h1&gt;Protected route&lt;/h1&gt;
    &lt;/Container&gt;
  );
}

export default protectedRoute(Protected)</pre>

<p>Now this component is protected and users will continue to be redirected when trying to access it if they are not authenticated.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Creating the Form"><div class="sect1" id="idm45364347499336">
<h1>Creating the Form</h1>

<p><a data-type="indexterm" data-primary="creating" data-secondary="custom authentication forms" id="cre_caf"/><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="creating" id="caf_cre"/><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="about" id="idm45364347481704"/>The next thing we will want to do is create the main <code>Form</code> component. This component will hold all of the logic and UI for the following actions:</p>

<ul>
<li>
<p>Signing up</p>
</li>
<li>
<p>Confirming sign up</p>
</li>
<li>
<p>Signing in</p>
</li>
<li>
<p>Resetting password</p>
</li>
</ul>

<p><a data-type="indexterm" data-primary="abstractions" id="idm45364347475624"/><a data-type="indexterm" data-primary="business logic" id="idm45364347474920"/><a data-type="indexterm" data-primary="withAuthenticator component" id="idm45364347474248"/>In <a data-type="xref" href="ch04.xhtml#ch4">Chapter 4</a>, we used the <code>withAuthenticator</code> component that encapsulated most of this logic for us, but we will now be rewriting our own version of this from scratch. It is important to understand how to create and handle custom forms because you might work with custom designs and business logic that may not be compatible with abstractions like the <code>withAuthenticator</code> component.</p>

<p>The first thing we’ll do is create the new component files that we will need. In the <em>src</em> directory, create the following files:</p>

<pre data-type="programlisting">Button.js
Form.js
SignUp.js
ConfirmSignUp.js
SignIn.js
ForgotPassword.js
ForgotPasswordSubmit.js</pre>

<p>Now that you have created these components, let’s continue by creating a reusable button that will serve the submit button across all of the forms. In <em>Button.js</em>, add the following code:</p>

<pre data-type="programlisting">import React from 'react'

export default function Button({ onClick, title }) {
  return (
    &lt;button style={styles.button} onClick={onClick}&gt;
      {title}
    &lt;/button&gt;
  )
}

const styles = {
  button: {
    backgroundColor: '#006bfc',
    color: 'white',
    width: 316,
    height: 45,
    fontWeight: '600',
    fontSize: 14,
    cursor: 'pointer',
    border:'none',
    outline: 'none',
    borderRadius: 3,
    marginTop: '25px',
    boxShadow: '0px 1px 3px rgba(0, 0, 0, .3)',
  },
}</pre>

<p><a data-type="indexterm" data-primary="Button component" id="idm45364347467288"/>The <code>Button</code> component is a basic component that accepts two props: <code>title</code> and <code>onClick</code>. The <code>onClick</code> handler will call the function associated with the button and the <code>title</code> component will render the text for the button.</p>

<p>Next, open <em>Form.js</em> and add the following code:</p>

<pre data-type="programlisting">/* src/Form.js */
import React, { useState } from 'react'
import { Auth } from 'aws-amplify'
import SignIn from './SignIn'
import SignUp from './SignUp'
import ConfirmSignUp from './ConfirmSignUp'
import ForgotPassword from './ForgotPassword'
import ForgotPasswordSubmit from './ForgotPasswordSubmit'

const initialFormState = {
  username: '', password: '', email: '', confirmationCode: ''
}

function Form(props) {
  const [formType, updateFormType] = useState('signIn')
  const [formState, updateFormState] = useState(initialFormState)
  function renderForm() {}
  return (
    &lt;div&gt;
      {renderForm()}
    &lt;/div&gt;
  )
}</pre>

<p class="less_space pagebreak-before">Here, we’ve<a data-type="indexterm" data-primary="form state" id="idm45364347460904"/> imported the individual form components (that we will be writing shortly) and created some initial <em>form state</em>. The items that we will be keeping up with in the form state are the input fields (<code>username</code>, <code>password</code>, <code>email</code>, and <code>confirmationCode</code>) for the authentication flow.</p>

<p><a data-type="indexterm" data-primary="formType" id="idm45364347457656"/>There’s another piece of component state that keeps up with the type of form to be rendered: <code>formType</code>. Because the form components will be displayed all in one route, we will need to check what the current form state is and then render the Sign Up form, Sign In form, or Reset Password form.</p>

<p><a data-type="indexterm" data-primary="updateFormType function" id="idm45364347455704"/><code>updateFormType</code> will be the function that switches between different form types. Once a user has successfully signed up, for example, we will call <code>updateFormType('signIn')</code> to render the <code>SignIn</code> component so that they can then sign in.</p>

<p>The <code>renderForm</code> function will be updated later with some custom logic, but for now, does not do anything.</p>

<p>Next, add the following styles and default export to <em>Form.js</em>. The styles for some of the elements will be shared among the components, so we will be exporting the component as well as the styling:</p>

<pre data-type="programlisting">const styles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    marginTop: 150,
    justifyContent: 'center',
    alignItems: 'center'
  },
  input: {
    height: 45,
    marginTop: 8,
    width: 300,
    maxWidth: 300,
    padding: '0px 8px',
    fontSize: 16,
    outline: 'none',
    border: 'none',
    borderBottom: '2px solid rgba(0, 0, 0, .3)'
  },
  toggleForm: {
    fontWeight: '600',
    padding: '0px 25px',
    marginTop: '15px',
    marginBottom: 0,
    textAlign: 'center',
    color: 'rgba(0, 0, 0, 0.6)'
  },
  resetPassword: {
    marginTop: '5px',
  },
  anchor: {
    color: '#006bfc',
    cursor: 'pointer'
  }
}

export { styles, Form as default }</pre>

<p>Next, let’s go ahead and create the individual form components.</p>








<section data-type="sect2" data-pdf-bookmark="SignIn Component"><div class="sect2" id="idm45364347449608">
<h2>SignIn Component</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="SignIn component" id="idm45364347448328"/><a data-type="indexterm" data-primary="SignIn component" id="idm45364347447288"/><a data-type="indexterm" data-primary="signIn function" id="idm45364347446616"/>The <code>SignIn</code> component will render the sign-in form. This component will accept two props, one for updating the form state (<code>updateFormState</code>) and one for calling the <code>signIn</code> function:</p>

<pre data-type="programlisting">/* src/SignIn.js */
import React from 'react'
import Button from './Button'
import { styles } from './Form'

function SignIn({ signIn, updateFormState }) {
  return (
    &lt;div style={styles.container}&gt;
      &lt;input
        name='username'
        onChange={e =&gt; {e.persist();updateFormState(e)}}
        style={styles.input}
        placeholder='username'
      /&gt;
      &lt;input
        type='password'
        name='password'
        onChange={e =&gt; {e.persist();updateFormState(e)}}
        style={styles.input}
        placeholder='password'
      /&gt;
      &lt;Button onClick={signIn} title="Sign In" /&gt;
    &lt;/div&gt;
  )
}

export default SignIn</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="SignUp Component"><div class="sect2" id="idm45364347442712">
<h2>SignUp Component</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="SignUp component" id="idm45364347441512"/><a data-type="indexterm" data-primary="SignUp component" id="idm45364347440472"/><a data-type="indexterm" data-primary="signUp function" id="idm45364347439800"/>The <code>SignUp</code> component will render the sign-up form. This component will accept two props, one for updating the form state (<code>updateFormState</code>) and one for calling the <code>signUp</code> function:</p>

<pre data-type="programlisting">/* src/SignUp.js */
import React from 'react'
import Button from './Button'
import { styles } from './Form'

function SignUp({ updateFormState, signUp }) {
  return (
    &lt;div style={styles.container}&gt;
      &lt;input
        name='username'
        onChange={e =&gt; {e.persist();updateFormState(e)}}
        style={styles.input}
        placeholder='username'
      /&gt;
      &lt;input
        type='password'
        name='password'
        onChange={e =&gt; {e.persist();updateFormState(e)}}
        style={styles.input}
        placeholder='password'
      /&gt;
      &lt;input
        name='email'
        onChange={e =&gt; {e.persist();updateFormState(e)}}
        style={styles.input}
        placeholder='email'
      /&gt;
      &lt;Button onClick={signUp} title="Sign Up" /&gt;
    &lt;/div&gt;
  )
}

export default SignUp</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="ConfirmSignUp Component"><div class="sect2" id="idm45364347435832">
<h2>ConfirmSignUp Component</h2>

<p><a data-type="indexterm" data-primary="ConfirmSignUp component" id="idm45364347434456"/><a data-type="indexterm" data-primary="confirmSignUp function" id="idm45364347433752"/><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="ConfirmSignUp component" id="idm45364347433080"/><a data-type="indexterm" data-primary="MFA (multifactor authentication)" id="idm45364347432072"/>Once a user has signed up, they will receive a confirmation code for MFA. The <code>ConfirmSignUp</code> component holds the form that will handle and submit this MFA code.</p>

<p>This component will accept two props (in React, <em>props</em> means “properties,” in regard to passing data among components), one for updating the form state (<code>updateFormState</code>) and one for calling the <code>confirmSignUp</code> function:</p>

<pre data-type="programlisting">/* src/ConfirmSignUp.js */
import React from 'react'
import Button from './Button'
import { styles } from './Form'

function ConfirmSignUp(props) {
  return (
    &lt;div style={styles.container}&gt;
      &lt;input
        name='confirmationCode'
        placeholder='Confirmation Code'
        onChange={e =&gt; {e.persist();props.updateFormState(e)}}
        style={styles.input}
      /&gt;
      &lt;Button onClick={props.confirmSignUp} title="Confirm Sign Up" /&gt;
    &lt;/div&gt;
  )
}

export default ConfirmSignUp</pre>

<p>The next two forms will be for handling the resetting of a forgotten password. The first form (<code>ForgotPassword</code>) will take the user’s username as an input and send them a confirmation code. They can then use that confirmation code along with a new password to reset the password in the second form (<code>ForgotPasswordSubmit</code>).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="ForgotPassword Component"><div class="sect2" id="idm45364347426024">
<h2>ForgotPassword Component</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="ForgotPassword component" id="idm45364347424808"/><a data-type="indexterm" data-primary="ForgotPassword component" id="idm45364347423752"/><a data-type="indexterm" data-primary="forgotPassword function" id="idm45364347423064"/>The <code>ForgotPassword</code> component will accept two props, one for updating the form state (<code>updateFormState</code>) and one for calling the <code>forgotPassword</code> function:</p>

<pre data-type="programlisting">/* src/ForgotPassword.js */
import React from 'react'
import Button from './Button'
import { styles } from './Form'

function ForgotPassword(props) {
  return (
    &lt;div style={styles.container}&gt;
      &lt;input
        name='username'
        placeholder='Username'
        onChange={e =&gt; {e.persist();props.updateFormState(e)}}
        style={styles.input}
      /&gt;
      &lt;Button onClick={props.forgotPassword} title="Reset password" /&gt;
    &lt;/div&gt;
  )
}

export default ForgotPassword</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="ForgotPasswordSubmit Component"><div class="sect2" id="idm45364347419368">
<h2>ForgotPasswordSubmit Component</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="ForgotPasswordSubmit component" id="idm45364347418168"/><a data-type="indexterm" data-primary="ForgotPasswordSubmit component" id="idm45364347417112"/>The <code>ForgotPasswordSubmit</code> component will accept two props, one for updating the form state (<code>updateFormState</code>) and one for calling the <code>forgotPassword</code> function:</p>

<pre data-type="programlisting">/* src/ForgotPasswordSubmit.js */
import React from 'react'
import Button from './Button'
import { styles } from './Form'

function ForgotPasswordSubmit(props) {
  return (
    &lt;div style={styles.container}&gt;
      &lt;input
        name='confirmationCode'
        placeholder='Confirmation code'
        onChange={e =&gt; {e.persist();props.updateFormState(e)}}
        style={styles.input}
      /&gt;
      &lt;input
        name='password'
        placeholder='New password'
        type='password'
        onChange={e =&gt; {e.persist();props.updateFormState(e)}}
        style={styles.input}
      /&gt;
      &lt;Button onClick={props.forgotPasswordSubmit} title="Save new password" /&gt;
    &lt;/div&gt;
  )
}

export default ForgotPasswordSubmit</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Completing Form.js"><div class="sect2" id="idm45364347413256">
<h2>Completing Form.js</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="completing" id="idm45364347411880"/><a data-type="indexterm" data-primary="signIn function" id="idm45364347410840"/><a data-type="indexterm" data-primary="signUp function" id="idm45364347410168"/><a data-type="indexterm" data-primary="confirmSignUp function" id="idm45364347409496"/><a data-type="indexterm" data-primary="forgotPasswordSubmit function" id="idm45364347408824"/>Now that all of the individual form components have been created, we can update <em>Form.js</em> to use these new components.</p>

<p>The next thing we will do is open <em>Form.js</em> and create the functions that will interact with the authentication service. These functions—<code>signIn</code>, <code>signUp</code>, <code>confirmSignUp</code>, <code>forgotPassword</code>, and <code>forgotPasswordSubmit</code>—will be passed as props to the individual form components.</p>

<p>Below the last import, add the following code:</p>

<pre data-type="programlisting">/* src/Form.js */
async function signIn({ username, password }, setUser) {
  try {
    const user = await Auth.signIn(username, password)
    const userInfo = { username: user.username, ...user.attributes }
    setUser(userInfo)
  } catch (err) {
    console.log('error signing up..', err)
  }
}

async function signUp({ username, password, email }, updateFormType) {
  try {
    await Auth.signUp({
      username, password, attributes: { email }
    })
    console.log('sign up success!')
    updateFormType('confirmSignUp')
  } catch (err) {
    console.log('error signing up..', err)
  }
}

async function confirmSignUp({ username, confirmationCode }, updateFormType) {
  try {
    await Auth.confirmSignUp(username, confirmationCode)
    updateFormType('signIn')
  } catch (err) {
    console.log('error signing up..', err)
  }
}

async function forgotPassword({ username }, updateFormType) {
  try {
    await Auth.forgotPassword(username)
    updateFormType('forgotPasswordSubmit')
  } catch (err) {
    console.log('error submitting username to reset password...', err)
  }
}

async function forgotPasswordSubmit(
    { username, confirmationCode, password }, updateFormType
  ) {
  try {
    await Auth.forgotPasswordSubmit(username, confirmationCode, password)
    updateFormType('signIn')
  } catch (err) {
    console.log('error updating password... :', err)
  }
}</pre>

<p>The <code>signUp</code>, <code>confirmSignUp</code>, <code>forgotPassword</code>, and <code>forgotPasswordSubmit</code> functions will all take the same arguments, the form state object, and the <code>updateFormType</code> function to update the type of form that is displayed.</p>

<p><a data-type="indexterm" data-primary="re-render" id="idm45364347398728"/><a data-type="indexterm" data-primary="Profile component" id="idm45364347397800"/><a data-type="indexterm" data-primary="setUser function" id="idm45364347397096"/><a data-type="indexterm" data-primary="Form component" id="idm45364347396424"/>The <code>signIn</code> function is different than the other functions in that it takes in a <code>setUser</code> function. This <code>setUser</code> function will be passed into the <code>Form</code> component as a prop from the <code>Profile</code> component. This <code>setUser</code> function will allow us to re-render the <code>Profile</code> component in order to show or hide the form once the user has successfully signed in.</p>

<p><a data-type="indexterm" data-primary="withAuthenticator component" id="idm45364347392376"/>In <a data-type="xref" href="ch04.xhtml#ch4">Chapter 4</a>, the <em>Profile.js</em> component used the <code>withAuthenticator</code> component to render the form, so we did not need to render the proper UI ourselves. Now that we are handling our own form state, we will need to decide whether to render the <code>Profile</code> component or the <code>Form</code> component based on whether the user is authenticated.</p>

<p>You’ll notice that in these functions we are using different methods on the <code>Auth</code> class from AWS Amplify. These methods correspond with the naming of the functions we’ve created so that we know exactly what each of these functions is doing.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="updateForm Helper Function"><div class="sect2" id="idm45364347387224">
<h2>updateForm Helper Function</h2>

<p><a data-type="indexterm" data-primary="helper function" id="idm45364347385720"/><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="updateForm helper function" id="idm45364347385016"/><a data-type="indexterm" data-primary="updateForm helper function" id="idm45364347384088"/>Next, let’s create a <em>helper function</em> for updating the form state. The initial form state variable that we created in <em>Form.js</em> looks like this:</p>

<pre data-type="programlisting">const initialFormState = {
  username: '', password: '', email: '', confirmationCode: ''
}</pre>

<p>This state is an object with values for each form that we will be using.</p>

<p>We then used this <code>initialFormState</code> variable to create the component state (as well as a function to update the component state) using the <code>useState</code> hook:</p>

<pre data-type="programlisting">const [formState, updateFormState] = useState(initialFormState)</pre>

<p>The problem that we have now is that <code>updateFormState</code> is expecting a new object with all of these fields in order to update the form state, but a form handler only gives us the single form event that is being typed. How can we transform this input event into a new object for the state? We’ll do this by creating a helper function that we will use inside of the <code>Form</code> function.</p>

<p><a data-type="indexterm" data-primary="useState hook" id="idm45364347376904"/>In <em>Form.js</em>, add the following code below the <code>useState</code> hooks and inside the <code>Form</code> function:</p>

<pre data-type="programlisting">function updateForm(event) {
  const newFormState = {
    ...formState, [event.target.name]: event.target.value
  }
  updateFormState(newFormState)
}</pre>

<p>The <code>updateForm</code> function will create a new <code>state</code> object using the existing state as well as the new values coming in from the event and then call <code>updateFormState</code> with this new form object. We can then reuse this function across all of our components.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="renderForm Function"><div class="sect2" id="idm45364347386632">
<h2>renderForm Function</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="renderForm function" id="idm45364347370760"/><a data-type="indexterm" data-primary="renderForm function" id="idm45364347369720"/>Now that we have all of the form components created, the form state setup, and the authentication functions created, let’s update the <code>renderForm</code> function to render the current form. In <em>Form.js</em>, update the <code>renderForm</code> function to use the following code:</p>

<pre data-type="programlisting">function renderForm() {
  switch(formType) {
    case 'signUp':
      return (
        &lt;SignUp
          signUp={() =&gt; signUp(formState, updateFormType)}
          updateFormState={e =&gt; updateForm(e)}
        /&gt;
      )
    case 'confirmSignUp':
      return (
        &lt;ConfirmSignUp
          confirmSignUp={() =&gt; confirmSignUp(formState, updateFormType)}
          updateFormState={e =&gt; updateForm(e)}
        /&gt;
      )
    case 'signIn':
      return (
        &lt;SignIn
          signIn={() =&gt; signIn(formState, props.setUser)}
          updateFormState={e =&gt; updateForm(e)}
        /&gt;
      )
    case 'forgotPassword':
      return (
        &lt;ForgotPassword
        forgotPassword={() =&gt; forgotPassword(formState, updateFormType)}
        updateFormState={e =&gt; updateForm(e)}
        /&gt;
      )
    case 'forgotPasswordSubmit':
      return (
        &lt;ForgotPasswordSubmit
          forgotPasswordSubmit={
            () =&gt; forgotPasswordSubmit(formState, updateFormType)}
          updateFormState={e =&gt; updateForm(e)}
        /&gt;
      )
    default:
      return null
  }
}</pre>

<p>The <code>renderForm</code> function will check the current <code>formType</code> that is set in the state and render the proper form. As the <code>formType</code> changes, <code>renderForm</code> will be called and subsequently re-render the correct form based on the <code>formType</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Form Type Toggles"><div class="sect2" id="idm45364347362520">
<h2>Form Type Toggles</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="form type toggles" id="idm45364347361144"/><a data-type="indexterm" data-primary="form type toggles" id="idm45364347360152"/>The last thing we will need to do in this component is render the buttons that will allow us to manually toggle between different form states. The three main form states that we will want to toggle between are <code>signIn</code>, <code>signUp</code>, and <code>forgotPassword</code>.</p>

<p><a data-type="indexterm" data-primary="Form function" id="idm45364347357528"/>To do this, let’s update the return statement from the <code>Form</code> function to also return some buttons that allow the user to toggle the form type:</p>

<pre data-type="programlisting">return (
  &lt;div&gt;
    {renderForm()}
    {
      formType === 'signUp' &amp;&amp; (
        &lt;p style={styles.toggleForm}&gt;
          Already have an account? &lt;span
            style={styles.anchor}
            onClick={() =&gt; updateFormType('signIn')}
          &gt;Sign In&lt;/span&gt;
        &lt;/p&gt;
      )
    }
    {
      formType === 'signIn' &amp;&amp; (
        &lt;&gt;
          &lt;p style={styles.toggleForm}&gt;
            Need an account? &lt;span
              style={styles.anchor}
              onClick={() =&gt; updateFormType('signUp')}
            &gt;Sign Up&lt;/span&gt;
          &lt;/p&gt;
          &lt;p style={{ ...styles.toggleForm, ...styles.resetPassword}}&gt;
            Forget your password? &lt;span
              style={styles.anchor}
              onClick={() =&gt; updateFormType('forgotPassword')}
            &gt;Reset Password&lt;/span&gt;
          &lt;/p&gt;
        &lt;/&gt;
      )
    }
  &lt;/div&gt;
)</pre>

<p>The <code>Form</code> component will now show different buttons based on the current form type and allow the user to toggle between signing in, signing up, and resetting their <span class="keep-together">password.</span></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Updating the Profile Component"><div class="sect2" id="idm45364347352856">
<h2>Updating the Profile Component</h2>

<p><a data-type="indexterm" data-primary="updating" data-secondary="Profile component" id="idm45364347351512"/><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="updating Profile component" id="idm45364347350536"/><a data-type="indexterm" data-primary="Profile component" id="idm45364347349560"/>We now need to update the <code>Profile</code> component to use the new <code>Form</code> component. The main changes are that we will be rendering either the <code>Form</code> component or the user profile information based on whether there is a currently signed-in user.</p>

<p><a data-type="indexterm" data-primary="local eventing system" id="idm45364347347016"/><a data-type="indexterm" data-primary="Hub eventing system" id="idm45364347346312"/>Amplify has a local eventing system called <code>Hub</code>. Amplify uses <code>Hub</code> for different categories to communicate with one another when specific events occur, such as authentication events like a user sign-in or notification of a file download.</p>

<p><a data-type="indexterm" data-primary="Listener" id="idm45364347344136"/>In this component, we will also be setting a <code>Hub</code> listener to listen for the <code>signOut</code> authentication event so that we can remove the user from the state and re-render the <code>Profile</code> component to show the authentication form.</p>

<p>Update <em>Profile.js</em> with the following code:</p>

<pre data-type="programlisting">import React, { useState, useEffect } from 'react'
import { Button } from 'antd'
import { Auth, Hub } from 'aws-amplify'
import Container from './Container'
import Form from './Form'

function Profile() {
  useEffect(() =&gt; {
    checkUser()
    Hub.listen('auth', (data) =&gt; {
      const { payload } = data
      if (payload.event === 'signOut') {
        setUser(null)
      }
    })
  }, [])
  const [user, setUser] = useState(null)
  async function checkUser() {
    try {
      const data = await Auth.currentUserPoolUser()
      const userInfo = { username: data.username, ...data.attributes, }
      setUser(userInfo)
    } catch (err) { console.log('error: ', err) }
  }
  function signOut() {
    Auth.signOut()
      .catch(err =&gt; console.log('error signing out: ', err))
  }
  if (user) {
    return (
      &lt;Container&gt;
        &lt;h1&gt;Profile&lt;/h1&gt;
        &lt;h2&gt;Username: {user.username}&lt;/h2&gt;
        &lt;h3&gt;Email: {user.email}&lt;/h3&gt;
        &lt;h4&gt;Phone: {user.phone_number}&lt;/h4&gt;
        &lt;Button onClick={signOut}&gt;Sign Out&lt;/Button&gt;
      &lt;/Container&gt;
    );
  }
  return &lt;Form setUser={setUser} /&gt;
}

export default Profile</pre>

<p><a data-type="indexterm" data-primary="pass in" id="idm45364347338824"/><a data-type="indexterm" data-primary="re-render" id="idm45364347337992"/>In this component, we check to see if there is a user, and if so we return the profile information of the user. If there is no user, then we return the authentication form (<code>Form</code>). We pass in <code>setUser</code> as a prop to the <code>Form</code> component so that when a user signs in we can update the form state to re-render the component and show the profile information for that user<a data-type="indexterm" data-primary="" data-startref="cre_caf" id="idm45364347335480"/><a data-type="indexterm" data-primary="" data-startref="caf_cre" id="idm45364347334504"/>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Testing the App"><div class="sect2" id="idm45364347333432">
<h2>Testing the App</h2>

<p><a data-type="indexterm" data-primary="custom authentication forms" data-secondary="testing apps" id="idm45364347332136"/><a data-type="indexterm" data-primary="start command" id="idm45364347331192"/><a data-type="indexterm" data-primary="applications" data-secondary="testing" id="idm45364347330520"/><a data-type="indexterm" data-primary="testing" data-secondary="applications" id="idm45364347329576"/>To test the app, we can now run the <code>start</code> command:</p>

<pre data-type="programlisting">npm start</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45364347485128">
<h1>Summary</h1>

<p>Congratulations, you’ve built out a completely custom authentication flow!</p>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="complexity of" id="idm45364347325896"/><a data-type="indexterm" data-primary="Auth class" id="idm45364347324920"/>Here are a few things to keep in mind from this chapter:</p>

<ul>
<li>
<p>Use the <code>Auth</code> class for handling direct API calls to the Amazon Cognito authentication service.</p>
</li>
<li>
<p>As you can see, handling custom form state can become verbose. Try to understand the trade-offs between rolling your own authentication flow versus using something like the <code>withAuthenticator</code> HOC.</p>
</li>
<li>
<p>Authentication is complex. By using a managed-identity service like Amazon Cognito, we’ve abstracted away all of the backend code and logic. The only thing we have to know or understand is how to interact with the authentication APIs and then manage the local state.</p>
</li>
</ul>
</div></section>







</div></section></div>



  </body></html>