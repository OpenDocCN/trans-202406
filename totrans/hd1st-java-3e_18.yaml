- en: 'Chapter 16\. Saving Objects (and Text): Serialization and File I/O'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0539-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Objects can be flattened and inflated.** Objects have state and behavior.
    *Behavior* lives in the *class*, but *state* lives within each individual *object*.
    So what happens when it’s time to *save* the state of an object? If you’re writing
    a game, you’re gonna need a Save/Restore Game feature. If you’re writing an app
    that creates charts, you’re gonna need a Save/Open File feature. If your program
    needs to save state, *you can do it the hard way*, interrogating each object,
    then painstakingly writing the value of each instance variable to a file, in a
    format you create. Or, **you can do it the easy OO way**—you simply freeze-dry/flatten/persist/dehydrate
    the object itself, and reconstitute/inflate/restore/rehydrate it to get it back.
    But you’ll still have to do it the hard way *sometimes*, especially when the file
    your app saves has to be read by some other non-Java application, so we’ll look
    at both in this chapter. And since all I/O operations are risky, we’ll take a
    look at how to do even better exceptions handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Capture the beat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve *made* the perfect pattern. You want to *save* the pattern. You could
    grab a piece of paper and start scribbling it down, but instead you hit the ***Save***
    button (or choose Save from the File menu). Then you give it a name, pick a directory,
    and exhale knowing that your masterpiece won’t go out the window during a random
    computer crash.
  prefs: []
  type: TYPE_NORMAL
- en: You have lots of options for how to save the state of your Java program, and
    what you choose will probably depend on how you plan to *use* the saved state.
    Here are the options we’ll be looking at in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0540-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**If your data will be used by only the Java program that generated it:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Use serialization**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a file that holds flattened (serialized) objects. Then have your program
    read the serialized objects from the file and inflate them back into living, breathing,
    heap-inhabiting objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**If your data will be used by *other* programs:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **Write a plain-text file**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a file, with delimiters that other programs can parse. For example, a
    tab-delimited file that a spreadsheet or database application can use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These aren’t the only options, but if we had to pick only two approaches to
    doing I/O in Java, we’d probably pick these. Of course, you can save data in any
    format you choose. Instead of writing characters, for example, you can write your
    data as bytes. Or you can write out any kind of Java primitive *as* a Java primitive—there
    are methods to write ints, longs, booleans, etc. But regardless of the method
    you use, the fundamental I/O techniques are pretty much the same: write some data
    to *something*, and usually that something is either a file on disk or a stream
    coming from a network connection. Reading the data is the same process in reverse:
    read some data from either a file on disk or a network connection. Everything
    we talk about in this part is for times when you aren’t using an actual database.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you have a program, say, a fantasy adventure game, that takes more than
    one session to complete. As the game progresses, characters in the game become
    stronger, weaker, smarter, etc., and gather and use (and lose) weapons. You don’t
    want to start from scratch each time you launch the game—it took you forever to
    get your characters in top shape for a spectacular battle. So, you need a way
    to save the state of the characters, and a way to restore the state when you resume
    the game. And since you’re also the game programmer, you want the whole save and
    restore thing to be as easy (and foolproof) as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Imagine you have three game characters to save...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0541-01.png)![image](Images/f0541-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The serialized file is much harder for humans to read, but it’s much easier
    (and safer) for your program to restore the three objects from serialization than
    from reading in the object’s variable values that were saved to a text file. For
    example, imagine all the ways in which you could accidentally read back the values
    in the wrong order! The type might become “dust” instead of “Elf,” while the Elf
    becomes a weapon...
  prefs: []
  type: TYPE_NORMAL
- en: Writing a serialized object to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the steps for serializing (saving) an object. Don’t bother memorizing
    all this; we’ll go into more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0542-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Data moves in streams from one place to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0543-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Connection streams represent a connection to a source or destination (file,
    network socket, etc.), while chain streams can’t connect on their own and must
    be chained to a connection stream.
  prefs: []
  type: TYPE_NORMAL
- en: The Java I/O API has ***connection*** streams, which represent connections to
    destinations and sources such as files or network sockets, and ***chain*** streams
    that work only if chained to other streams.
  prefs: []
  type: TYPE_NORMAL
- en: Often, it takes at least two streams hooked together to do something useful—*one*
    to represent the connection and *another* to call methods on. Why two? Because
    *connection* streams are usually too low-level. FileOutputStream (a connection
    stream), for example, has methods for writing *bytes*. But we don’t want to write
    *bytes*! We want to write *objects*, so we need a higher-level *chain* stream.
  prefs: []
  type: TYPE_NORMAL
- en: OK, then why not have just a single stream that does *exactly* what you want?
    One that lets you write objects but underneath converts them to bytes? Think good
    OO. Each class does *one* thing well. FileOutputStreams write bytes to a file.
    ObjectOutputStreams turn objects into data that can be written to a stream. So
    we make a FileOutputStream (a connection stream) that lets us write to a file,
    and we hook an ObjectOutputStream (a chain stream) on the end of it. When we call
    writeObject() on the ObjectOutputStream, the object gets pumped into the stream
    and then moves to the FileOutputStream where it ultimately gets written as bytes
    to a file.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to mix and match different combinations of connection and chain
    streams gives you tremendous flexibility! If you were forced to use only a *single*
    stream class, you’d be at the mercy of the API designers, hoping they’d thought
    of *everything* you might ever want to do. But with chaining, you can patch together
    your own *custom* chains.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0543-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What really happens to an object when it’s serialized?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](Images/1circle.png) **Object on the heap**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0544-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Objects on the heap have state—the value of the object’s instance variables.
    These values make one instance of a class different from another instance of the
    same class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2circle.png) Object serialized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0544-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Serialized objects **save the values of the instance variables** so that an
    identical instance (object) can be brought back to life on the heap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0544-03.png)'
  prefs: []
  type: TYPE_IMG
- en: But what exactly IS an object’s state? What needs to be saved?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it starts to get interesting. Easy enough to save the *primitive* values
    37 and 70\. But what if an object has an instance variable that’s an object *reference*?
    What about an object that has five instance variables that are object references?
    What if those object instance variables themselves have instance variables?
  prefs: []
  type: TYPE_NORMAL
- en: Think about it. What part of an object is potentially unique? Imagine what needs
    to be restored in order to get an object that’s identical to the one that was
    saved. It will have a different memory location, of course, but we don’t care
    about that. All we care about is that out there on the heap, we’ll get an object
    that has the same state the object had when it was saved.
  prefs: []
  type: TYPE_NORMAL
- en: '**When an object is serialized, all the objects it refers to from instance
    variables are *also* serialized. And all the objects *those* objects refer to
    are serialized. And all the objects those objects refer to are serialized...and
    the best part is, it happens automatically!**'
  prefs: []
  type: TYPE_NORMAL
- en: This Kennel object has a reference to a Dog[] array object. The Dog[] holds
    references to two Dog objects. Each Dog object holds a reference to a String and
    a Collar object. The String objects have a collection of characters, and the Collar
    objects have an int.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0546-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want your class to be serializable, implement Serializable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Serializable interface is known as a *marker* or *tag* interface, because
    the interface doesn’t have any methods to implement. Its sole purpose is to announce
    that the class implementing it is, well, *serializable*. In other words, objects
    of that type are saveable through the serialization mechanism. If any superclass
    of a class is serializable, the subclass is automatically serializable even if
    the subclass doesn’t explicitly declare “implements Serializable.” (This is how
    interfaces always work. If your superclass “IS-A” Serializable, you are too.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0547-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Serialization is all or nothing.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you imagine what would happen if some of the object’s state didn’t save
    correctly?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0548-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Either the entire object graph is serialized correctly or serialization fails.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**You can’t serialize a Pond object if its Duck instance variable refuses to
    be serialized (by not implementing Serializable).**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0548-02.png)![image](Images/f0549-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Mark an instance variable as transient if it can’t (or shouldn’t) be saved.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want an instance variable to be skipped by the serialization process,
    mark the variable with the **`transient`** keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0549-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have an instance variable that can’t be saved because it isn’t serializable,
    you can mark that variable with the transient keyword and the serialization process
    will skip right over it.
  prefs: []
  type: TYPE_NORMAL
- en: So why would a variable not be serializable? It could be that the class designer
    simply *forgot* to make the class implement Serializable. Or it might be because
    the object relies on runtime-specific information that simply can’t be saved.
    Although most things in the Java class libraries are serializable, you can’t save
    things like network connections, threads, or file objects. They’re all dependent
    on (and specific to) a particular runtime “experience.” In other words, they’re
    instantiated in a way that’s unique to a particular run of your program, on a
    particular platform, in a particular JVM. Once the program shuts down, there’s
    no way to bring those things back to life in any meaningful way; they have to
    be created from scratch each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deserialization: restoring an object'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole point of serializing an object is so that you can restore it to its
    original state at some later date, in a different “run” of the JVM (which might
    not even be the same JVM that was running at the time the object was serialized).
    Deserialization is a lot like serialization in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0551-01.png)![image](Images/f0551-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What happens during deserialization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an object is deserialized, the JVM attempts to bring the object back to
    life by making a new object on the heap that has the same state the serialized
    object had at the time it was serialized. Well, except for the transient variables,
    which come back either null (for object references) or as default primitive values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0552-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1circle.png) The object is **read** from the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/2circle.png) The JVM determines (through info stored with
    the serialized object) the object’s **class type.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/3circle.png) The JVM attempts to **find and load** the object’s
    **class**. If the JVM can’t find and/or load the class, the JVM throws an exception
    and the deserialization fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/4circle.png) A new object is given space on the heap, but
    the **serialized object’s constructor** **does NOT run**! Obviously, if the constructor
    ran, it would restore the state of the object to its original “new” state, and
    that’s not what we want. We want the object to be restored to the state it had
    *when it was serialized*, not when it was first created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/5circle.png) If the object has a non-serializable class somewhere
    up its inheritance tree, the **constructor for that non-serializable class will
    run** along with any constructors above that (even if they’re serializable). Once
    the constructor chaining begins, you can’t stop it, which means all superclasses,
    beginning with the first non-serializable one, will reinitialize their state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/6circle.png) The object’s i**nstance variables are given the
    values from the serialized state**. Transient variables are given a value of null
    for object references and defaults (0, false, etc.) for primitives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and restoring the game characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0554-01.png)![image](Images/f0554-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The GameCharacter class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is a basic class just for testing the Serialization code on the last page.
    We don’t have an actual game, but we’ll leave that to you to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Version ID: A big serialization gotcha'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve seen that I/O in Java is actually pretty simple, especially if you
    stick to the most common connection/chain combinations. But there’s one issue
    you might *really* care about.
  prefs: []
  type: TYPE_NORMAL
- en: '**Version Control is crucial!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you serialize an object, you must have the class in order to deserialize
    and use the object. OK, that’s obvious. But it might be less obvious what happens
    if you ***change the class*** in the meantime. Yikes. Imagine trying to bring
    back a Dog object when one of its instance variables (non-transient) has changed
    from a double to a String. That violates Java’s type-safe sensibilities in a Big
    Way. But that’s not the only change that might hurt compatibility. Think about
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changes to a class that can hurt deserialization:**'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an instance variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the declared type of an instance variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a non-transient instance variable to transient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving a class up or down the inheritance hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a class (anywhere in the object graph) from Serializable to not Serializable
    (by removing ‘implements Serializable’ from a class declaration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing an instance variable to static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changes to a class that are usually OK:**'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new instance variables to the class (existing objects will deserialize
    with default values for the instance variables they didn’t have when they were
    serialized)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding classes to the inheritance tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing classes from the inheritance tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the access level (public, private, etc.) of an instance variable has
    no effect on the ability of deserialization to assign a value to the variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing an instance variable from transient to non-transient (previously serialized
    objects will simply have a default value for the previously transient variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0556-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the serialVersionUID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each time an object is serialized, the object (including every object in its
    graph) is “stamped” with a version ID number for the object’s class. The ID is
    called the serialVersionUID, and it’s computed based on information about the
    class structure. As an object is being deserialized, if the class has changed
    since the object was serialized, the class could have a different serialVersionUID,
    and deserialization will fail! But you can control this.
  prefs: []
  type: TYPE_NORMAL
- en: '**If you think there is ANY possibility that your class might *evolve*, put
    a serial version ID in your class.**'
  prefs: []
  type: TYPE_NORMAL
- en: When Java tries to deserialize an object, it compares the serialized object’s
    serialVersionUID with that of the class the JVM is using for deserializing the
    object. For example, if a Dog instance was serialized with an ID of, say 23 (in
    reality a serialVersionUID is much longer), when the JVM deserializes the Dog
    object, it will first compare the Dog object serialVersionUID with the Dog class
    serialVersionUID. If the two numbers don’t match, the JVM assumes the class is
    not compatible with the previously serialized object, and you’ll get an exception
    during deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: So, the solution is to put a serialVersionUID in your class, and then as the
    class evolves, the serialVersionUID will remain the same and the JVM will say,
    “OK, cool, the class is compatible with this serialized object,” even though the
    class has actually changed.
  prefs: []
  type: TYPE_NORMAL
- en: This works *only* if you’re careful with your class changes! In other words,
    *you* are taking responsibility for any issues that come up when an older object
    is brought back to life with a newer class.
  prefs: []
  type: TYPE_NORMAL
- en: To get a serialVersionUID for a class, use the serialver tool that ships with
    your Java development kit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0557-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**When you think your class might evolve after someone has serialized objects
    from it...**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Use the serialver command-line tool to get the version
    ID for your class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0557-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) Paste the output into your class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) Be sure that when you make changes to the class, you
    take responsibility in your code for the consequences of the changes you made
    to the class! For example, be sure that your new Dog class can deal with an old
    Dog being deserialized with default values for instance variables added to the
    class *after* the Dog was serialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a String to a Text File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving objects, through serialization, is the easiest way to save and restore
    data between runnings of a Java program. But sometimes you need to save data to
    a plain old text file. Imagine your Java program has to write data to a simple
    text file that some other (perhaps non-Java) program needs to read. You might,
    for example, have a servlet (Java code running within your web server) that takes
    form data the user typed into a browser and writes it to a text file that somebody
    else loads into a spreadsheet for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Writing text data (a String, actually) is similar to writing an object, except
    you write a String instead of an object, and you use something like a FileWriter
    instead of a FileOutputStream (and you don’t chain it to an ObjectOutputStream).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0559-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**To write a serialized object:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**`objectOutputStream.writeObject(someObject);`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**To write a String:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**`fileWriter.write("My first String to save");`**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0559-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Text file example: e-Flashcards'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0560-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember those flashcards you used in school? Where you had a question on one
    side and the answer on the back? They aren’t much help when you’re trying to understand
    something, but nothing beats ’em for raw drill-and-practice and rote memorization.
    *When you have to burn in a fact.* And they’re also great for trivia games.
  prefs: []
  type: TYPE_NORMAL
- en: '**We’re going to make an electronic version that has three classes:**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. ***QuizCardBuilder***, a simple authoring tool for creating and saving a
    set of e-Flashcards.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. ***QuizCardPlayer***, a playback engine that can load a flashcard set and
    play it for the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0560-02.png)![image](Images/f0560-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**QuizCardBuilder**'
  prefs: []
  type: TYPE_NORMAL
- en: Has a File menu with a “Save” option for saving the current set of cards to
    a text file.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0560-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**QuizCardPlayer**'
  prefs: []
  type: TYPE_NORMAL
- en: Has a File menu with a “Load” option for loading a set of cards from a text
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz Card Builder (code outline)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0561-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Reminder: For the next eight pages or so we’ll be using older-style I/O code!'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0562-01.png)![image](Images/f0563-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The java.io.File class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.io.File` class is another example of an older class in the Java API.
    It’s been “replaced” by two classes in the newer `java.nio.file` package, but
    you’ll undoubtedly encounter code that uses the `File` class. **For new code,
    we recommend using the `java.nio.file` package instead of the `java.io.File` class.**
    In a few pages, we’ll take a look at a few of the most important capabilities
    in the `java.nio.file` package. With that said...
  prefs: []
  type: TYPE_NORMAL
- en: The `java.io.File` class *represents* a file on disk but doesn’t actually represent
    the *contents* of the file. What? Think of a File object as something more like
    a *path name* of a file (or even a *directory*) rather than The Actual File Itself.
    The File class does not, for example, have methods for reading and writing. One
    VERY useful thing about a File object is that it offers a much safer way to represent
    a file than just using a String filename. For example, most classes that take
    a String filename in their constructor (like FileWriter or FileInputStream) can
    take a File object instead. You can construct a File object, verify that you’ve
    got a valid path, etc., and then give that File object to the FileWriter or FileInputStream.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A **File** object represents the name and path of a file or directory on
    disk, for example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/Users/Kathy/Data/Game.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**But it does NOT represent, or give you access to, the data *in* the file!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0564-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Some things you can do with a File object:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Make a File object representing an existing file**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**File f = new File("MyCode.txt");**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **Make a new directory**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) **List the contents of a directory**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/4.png) **Delete a file or directory (returns true if successful)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![image](Images/f0564-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The beauty of buffers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If there were no buffers, it would be like shopping without a cart. You’d
    have to carry each thing out to your car, one soup can or toilet paper roll at
    a time.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0565-01.png)![image](Images/f0565-02.png)![image](Images/f0565-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Using buffers is *much* more efficient than working without them. You can write
    to a file using FileWriter alone, by calling write(someString), but FileWriter
    writes each and every thing you pass to the file each and every time. That’s overhead
    you don’t want or need, since every trip to the disk is a Big Deal compared to
    manipulating data in memory. By chaining a BufferedWriter onto a FileWriter, the
    BufferedWriter will hold all the stuff you write to it until it’s full. *Only
    when the buffer is full will the FileWriter actually be told to write to the file
    on disk.*
  prefs: []
  type: TYPE_NORMAL
- en: If you do want to send data *before* the buffer is full, you do have control.
    ***Just Flush It***. Calls to writer.flush() say, “send whatever’s in the buffer,
    ***now***!”
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading text from a file is simple, but this time we’ll use a File object to
    represent the file, a FileReader to do the actual reading, and a BufferedReader
    to make the reading more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The read happens by reading lines in a *while* loop, ending the loop when the
    result of a readLine() is null. That’s the most common style for reading data
    (pretty much anything that’s not a Serialized object): read stuff in a while loop
    (actually a while loop *test*), terminating when there’s nothing left to read
    (which we know because the result of whatever read method we’re using is null).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0566-01.png)![image](Images/f0566-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Quiz Card Player (code outline)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0568-01.png)![image](Images/f0569-01.png)![image](Images/f0569-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Parsing with String split()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Imagine you have a flashcard like this:**![image](Images/f0570-01.png)
    | **Saved in a question file like this:**![image](Images/f0570-02.png) |'
  prefs: []
  type: TYPE_TB
- en: '**How do you separate the question and answer?**'
  prefs: []
  type: TYPE_NORMAL
- en: When you read the file, the question and answer are smooshed together in one
    line, separated by a forward slash “/” (because that’s how we wrote the file in
    the QuizCardBuilder code).
  prefs: []
  type: TYPE_NORMAL
- en: '**String split() lets you break a String into pieces.**'
  prefs: []
  type: TYPE_NORMAL
- en: The split() method says, “give me a separator, and I’ll break out all the pieces
    of this String for you and put them in a String array.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0570-03.png)![image](Images/f0570-04.png)'
  prefs: []
  type: TYPE_IMG
- en: NIO.2 and the java.nio.file package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java NIO.2 is usually taken to mean two packages added in Java 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `java.nio.file.attribute` package lets you manipulate the *metadata* associated
    with a computer’s files and directories. For example, you would use the classes
    in this package if you wanted to read or change a file’s permissions settings.
    We WON’T be discussing this package further. (phew)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.nio.file` package is all you need to do common text file reading
    and writing, and it also provides you with the ability to manipulate a computer’s
    directories and directory structure. Most of the time you’ll use three types in
    java.nio.file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Path interface: You’ll always need a Path object to locate the directories
    or files you want to work with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Paths class: You’ll use the Paths.get() method to make the Path object
    you’ll need when you use methods in the Files class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Files class: This is the class whose (static) methods do all the work you’ll
    want to do: making new Readers and Writers, and creating, modifying, and searching
    through directories and files on file systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A Path object represents the location (name and path) of a file or directory
    on disk, for example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/Users/Kathy/Data/Game.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**But it does NOT represent, or give you access to, the data *in* the file!**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An advanced but useful capability in the Files class allows you to “walk thru”
    (search) directory trees.
  prefs: []
  type: TYPE_NORMAL
- en: '**A mini-tutorial, creating a BufferedWriter with NIO.2**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0572-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Path, Paths, and Files (messing with directories)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Appendix B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d), we’ll
    be discussing how to split your Java app into packages. This includes creating
    the proper directory structure for all of your app’s files. In most cases you’ll
    make and move directories and files by hand, using the command line or utilities
    like the Finder or Windows Explorer. But you can also do it from within your Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Goofing around with directories in a Java program is a real “can
    of worms” topic. To do it correctly you need to learn about paths, absolute paths,
    relative paths, OS permissions, file attributes, and on and on. Below is a greatly
    simplified example of messing around with directories, just to give you a feel
    for what’s possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you wanted to make an installer program to install your killer app.
    You start with the directory and files on the left, and want to end up with the
    directory structure and files on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0573-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, a closer look at `finally`
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several chapters ago we looked at how try-catch-finally worked. Kind of. All
    we said about finally was that it was a good place to put your “cleanup code.”
    That’s true, but let’s get more specific. Most of the time, when we talk about
    “cleanup code,” we mean closing resources we borrowed from the operating system.
    When we open a file or a socket, the OS is giving us some of its resources. When
    we’re done with them, we need to give them back. Below is a snippet of code from
    the QuizCardBuilder class. We highlighted a call to a constructor and three separate
    method calls...
  prefs: []
  type: TYPE_NORMAL
- en: '**That’s FOUR places an exception can be thrown!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0574-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If the call to make a new FileWriter fails, if ANY of the many write() invocations
    fail, or the close() itself fails, an exception will be thrown, the JVM will jump
    to the catch block, and the writer will never be closed. Yikes!
  prefs: []
  type: TYPE_NORMAL
- en: Remember, `finally` ALWAYS runs!!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we REALLY want to make sure we close the writer file, let’s put the close()
    invocation in a finally block.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a closer look at `finally`, cont.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The amount of code required to put the close() in the finally block might surprise
    you; let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0575-01.png)![image](Images/f0575-02.png)'
  prefs: []
  type: TYPE_IMG
- en: There IS a better way!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the early days of Java, this is how you had to make sure you were really
    closing a file. You are very likely to encounter finally blocks that look like
    this when you’re looking at existing code. But for new code, there is a better
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Try-With-Resources**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: The try-with-resources (TWR), statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re using Java 7 or later (and we sure hope you are!), you can use the
  prefs: []
  type: TYPE_NORMAL
- en: 'try-with-resources version of try statements to make doing I/O easier. Let’s
    compare the try code we’ve been looking at with try-with-resources code that does
    the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Old style, try-catch-finally code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Modern, try-with-resources code
  prefs: []
  type: TYPE_NORMAL
- en: Autocloseable, the very small catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the last page we saw a different kind of try statement, the try-with-resources
    statement (TWR). Let’s take a look at how to write and use TWR statements by first,
    deconstructing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: ONLY classes that implement Autocloseable can be used in TWR statements!
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing a try-with-resources statement**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0577-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Autocloseable, it’s everywhere you do I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Autocloseable is an interface that was added to java.lang in Java 7\. Almost
    all of the I/O you’re ever going to do uses classes that implement Autocloseable.
    You mostly won’t have to think about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more things worth knowing about TWR statements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare and use more than one I/O resource in a single TWR block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0577-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If you declare more than one resource, they will be closed in the order OPPOSITE
    to which they were declared; i.e., first declared is last closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you add catch or finally blocks, the system will handle multiple close()
    invocations gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Kitchen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0578-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Let’s make the BeatBox save and restore our favorite pattern.**'
  prefs: []
  type: TYPE_NORMAL
- en: Saving a BeatBox pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, in the BeatBox, a drum pattern is nothing more than a bunch of checkboxes.
    When it’s time to play the sequence, the code walks through the checkboxes to
    figure out which drums sounds are playing at each of the 16 beats. So to save
    a pattern, all we need to do is save the state of the checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: We can make a simple boolean array, holding the state of each of the 256 checkboxes.
    An array object is serializable as long as the things *in* the array are serializable,
    so we’ll have no trouble saving an array of booleans.
  prefs: []
  type: TYPE_NORMAL
- en: To load a pattern back in, we read the single boolean array object (deserialize
    it) and restore the checkboxes. Most of the code you’ve already seen, in the Code
    Kitchen where we built the BeatBox GUI, so in this chapter, we look at only the
    save and restore code.
  prefs: []
  type: TYPE_NORMAL
- en: This CodeKitchen gets us ready for the next chapter, where instead of writing
    the pattern to a *file*, we send it over the *network* to the server. And instead
    of loading a pattern *in* from a file, we get patterns from the *server*, each
    time a participant sends one to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Serializing a pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0579-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Restoring a BeatBox pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is pretty much the save in reverse...read the boolean array and use it
    to restore the state of the GUI checkboxes. It all happens when the user hits
    the “restore” button.
  prefs: []
  type: TYPE_NORMAL
- en: '**Restoring a pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0580-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) Yours to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/pencil1.png)'
  prefs: []
  type: TYPE_IMG
- en: Can they be saved?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) Yours to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: Which of these do you think are, or should be, serializable? If not, why not?
    Not meaningful? Security risk? Only works for the current execution of the JVM?
    Make your best guess, without looking it up in the API.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object type | Serializable? | If not, why not? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Object | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '| String | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '| File | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '| Date | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '| OutputStream | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '| JFrame | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '| System | Yes / No | ______________________________________ |'
  prefs: []
  type: TYPE_TB
- en: '**What’s Legal?**'
  prefs: []
  type: TYPE_NORMAL
- en: Circle the code fragments that would compile (assuming they’re within a legal
    class).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/keep.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) Yours to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explored the wonderful world of Java I/O. Your job is to decide
    whether each of the following I/O-related statements is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: True or False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/hand.png)![image](Images/hand1.png)'
  prefs: []
  type: TYPE_IMG
- en: Serialization is appropriate when saving data for non-Java programs to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object state can be saved only by using serialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ObjectOutputStream is a class used to save serializable objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chain streams can be used on their own or with connection streams.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single call to writeObject() can cause many objects to be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All classes are serializable by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The java.nio.file.Path class can be used to locate files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a superclass is not serializable, then the subclass can’t be serializable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only classes that implement AutoCloseable can be used in try-with-resources
    statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an object is deserialized, its constructor does not run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both serialization and saving to a text file can throw exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: BufferedWriters can be chained to FileWriters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File objects represent files, but not directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can’t force a buffer to send its data before it’s full.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both file readers and file writers can optionally be buffered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The methods on the Files class let you operate on files and directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try-with-resources statements cannot include explicit finally blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisf-id0001).**'
  prefs: []
  type: TYPE_NORMAL
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0583-01.png)![image](Images/f0583-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This one’s tricky, so we promoted it from an Exercise to full Puzzle status.
    Reconstruct the code snippets to make a working Java program that produces the
    output listed below. (You might not need all of the magnets, and you may reuse
    a magnet more than once.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0583-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisf-id0001)**.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: True or False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“True or False”](#true_or_false-id00001))
  prefs: []
  type: TYPE_NORMAL
- en: '| 1\. Serialization is appropriate when saving data for non-Java programs to
    use. | **False** |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. Object state can be saved only by using serialization. | **False** |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. ObjectOutputStream is a class used to save serializable objects. | **True**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4\. Chain streams can be used on their own or with connection streams. |
    **False** |'
  prefs: []
  type: TYPE_TB
- en: '| 5\. A single call to writeObject() can cause many objects to be saved. |
    **True** |'
  prefs: []
  type: TYPE_TB
- en: '| 6\. All classes are serializable by default. | **False** |'
  prefs: []
  type: TYPE_TB
- en: '| 7\. The java.nio.file.Path class can be used to locate files. | **False**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8\. If a superclass is not serializable, then the subclass can’t be serializable.
    | **False** |'
  prefs: []
  type: TYPE_TB
- en: '| 9\. Only classes that implement AutoCloseable can be used in try-with-resources
    statements. | **True** |'
  prefs: []
  type: TYPE_TB
- en: '| 10\. When an object is deserialized, its constructor does not run. | **True**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 11\. Both serialization and saving to a text file can throw exceptions. |
    **True** |'
  prefs: []
  type: TYPE_TB
- en: '| 12\. BufferedWriters can be chained to FileWriters. | **True** |'
  prefs: []
  type: TYPE_TB
- en: '| 13\. File objects represent files, but not directories. | **False** |'
  prefs: []
  type: TYPE_TB
- en: '| 14\. You can’t force a buffer to send its data before it’s full. | **False**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 15\. Both file readers and file writers can optionally be buffered. | **True**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 16\. The methods on the Files class let you operate on files and directories.
    | **True** |'
  prefs: []
  type: TYPE_TB
- en: '| 17\. Try-with-resources statements cannot include explicit finally blocks.
    | **False** |'
  prefs: []
  type: TYPE_TB
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“True or False”](#true_or_false_left_parenthesisf-id0001))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0585-01.png)![image](Images/f0585-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0585-03.png)'
  prefs: []
  type: TYPE_IMG
