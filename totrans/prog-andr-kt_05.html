<html><head></head><body><section data-pdf-bookmark="Chapter 5. Thread Safety" data-type="chapter" epub:type="chapter"><div class="chapter" id="thread_safety_id">&#13;
<h1><span class="label">Chapter 5. </span>Thread Safety</h1>&#13;
&#13;
&#13;
<p><a data-primary="thread safety" data-type="indexterm" id="ix_ch05-asciidoc0"/>With the introduction of the <em>java.util.concurrent</em> package in Java 5, threads became commonly used to improve the performance of complex applications. In graphical (or <em>headed</em>) applications, they improve responsiveness by reducing the load on the main thread that processes information to render <em>views</em>—programmed components the user can see and&#13;
interact with on-screen. When a thread is created within a program that has a concept of a main or UI thread, it’s referred to as a <em>background thread</em>. These background threads often receive and process user interaction events, like gestures and text input; or other forms of data retrieval, like reading from a server; or local stores, like a database or filesystem. On the server side, backend applications using threads have better throughput by leveraging the multiple cores of modern CPUs.</p>&#13;
&#13;
<p>However, using threads has its own risks, as you will see in this chapter. Thread safety can be seen as a&#13;
set of techniques and good practices to circumvent those risks. Those techniques include <em>synchronization</em>, <em>mutexes</em>, and <em>blocking</em> versus <em>nonblocking</em>. Higher-level concepts like thread confinement are also important.</p>&#13;
&#13;
<p>The goal of this chapter is to introduce you to some important thread-safety concepts that will be used in the following&#13;
chapters. However, we won’t cover thread safety extensively. For example, we won’t explain <em>object publication</em>&#13;
or provide details about the Java memory model. These are advanced topics that we encourage you to learn after&#13;
you understand the concepts explained in this chapter.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Example of a Thread Issue" data-type="sect1"><div class="sect1" id="idm46669753283584">&#13;
<h1>An Example of a Thread Issue</h1>&#13;
&#13;
<p><a data-primary="thread safety" data-secondary="example of thread issue" data-type="indexterm" id="ix_ch05-asciidoc1"/>To understand what thread safety is, we’ll pick a simple example of a thread-safety issue. When a program runs several threads concurrently, each thread has the potential to do things <em>at the same time</em> as other running threads. But it doesn’t necessarily mean this will happen. When it does happen, you need to prevent one thread from accessing an object that is being mutated by another thread, because it could read an inconsistent state of the object. The same goes for simultaneous mutations. Ensuring that only one thread at a time can access a block of code is called&#13;
<em>mutual exclusion</em>. Take the following, for example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">aList</code><code class="p">:</code> <code class="n">MutableList</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">ArrayList</code><code class="p">()</code>&#13;
    <code class="k">private</code> <code class="k">set</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">add</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">last</code> <code class="p">=</code> <code class="n">aList</code><code class="p">.</code><code class="n">last</code><code class="p">()</code>  <code class="c1">// equivalent of aList[aList.size - 1]</code>&#13;
        <code class="n">aList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">last</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">init</code> <code class="p">{</code>&#13;
        <code class="n">aList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>add()</code> method takes the last element of the list, adds 1, and appends the result into the list. What would be the&#13;
expected behavior if two threads attempted to simultaneously execute <code>add()</code>?</p>&#13;
&#13;
<p>When the first thread references the last element, the other thread might have had time to execute the entire&#13;
<code>aList.add(last + 1)</code> line.<sup><a data-type="noteref" href="ch05.html#idm46669753196768" id="idm46669753196768-marker">1</a></sup> In this case, the first thread reads 2 for the last element and will append 3 to the list.&#13;
The resulting list would be <code>[1, 2, 3]</code>. Another scenario is possible. If the second thread didn’t have time to&#13;
append a new value, then the two threads will read the same value for the last element. Assuming that the rest of the&#13;
execution runs without hiccups, we get the result <code>[1, 2, 2]</code>. One more hazard may happen: if the two threads&#13;
try to append the new element to the list at exactly the same time, an &#13;
<span class="keep-together"><code>ArrayIndexOutOfBoundsException</code></span> will be thrown.</p>&#13;
&#13;
<p>Depending on the interleaving of the threads, the result may be different. There’s no guarantee that we’ll get a result&#13;
at all. Those are symptoms of a class or function that’s not thread-safe, which may not behave correctly when accessed from&#13;
multiple threads.</p>&#13;
&#13;
<p class="pagebreak-before">So, what could we do to fix this potential misbehavior? We have three options:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Don’t share state across threads.</p>&#13;
</li>&#13;
<li>&#13;
<p>Share immutable state across threads.</p>&#13;
</li>&#13;
<li>&#13;
<p>Change our implementation so that multiple threads can use our class and get predictable results.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>There are multiple strategies for approaching some kind of thread safety, each with its own strengths and caveats, so&#13;
it is important for a developer to be able to evaluate their options and choose one that best fits the needs of a&#13;
threading issue.</p>&#13;
&#13;
<p>The first option is relatively obvious. When threads can work on completely independent datasets, there’s no risk of accessing&#13;
the same memory addresses.</p>&#13;
&#13;
<p>The second option is making use of immutable objects and collections. Immutability is a very effective way to design robust&#13;
systems. If a thread can’t mutate an object, there’s simply no risk of reading inconsistent state from another thread.&#13;
In our example, we could make the list immutable, but then threads wouldn’t be able to append elements to it.&#13;
This doesn’t mean that this principle can’t be applied here. In fact, it can—but we’ll come back to it later in this chapter.&#13;
We have to mention that there’s a potential downside with using immutability. In essence, it requires more memory&#13;
because of object copying. For example, whenever a thread needs to work with another thread’s state, a copy of&#13;
the state object is performed. When done repeatedly and at a high pace, immutability can increase the memory footprint—which may be an issue (especially on Android).</p>&#13;
&#13;
<p>The third option could be described like so: “Any thread which executes the <code>add</code> method happens before any subsequent <code>add</code>&#13;
accesses from other threads.” In other words, <code>add</code> accesses happen serially, with no interleaving. If your implementation enforces the aforementioned statement, then there won’t be thread-safety issues—the class is said to be thread-safe. In the world of concurrency, the previous statement is called an <em>invariant</em>.<a data-startref="ix_ch05-asciidoc1" data-type="indexterm" id="idm46669753184272"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Invariants" data-type="sect1"><div class="sect1" id="idm46669753282960">&#13;
<h1>Invariants</h1>&#13;
&#13;
<p><a data-primary="invariants" data-type="indexterm" id="ix_ch05-asciidoc2"/><a data-primary="thread safety" data-secondary="invariants" data-type="indexterm" id="ix_ch05-asciidoc3"/>To properly make a class or a group of classes thread-safe, we have to define invariants. An invariant is an assertion&#13;
that should always be true. No matter how threads are scheduled, the invariant shall not be violated. In the case of our example, it could be expressed like this (from the standpoint of a thread):</p>&#13;
<blockquote>&#13;
<p>When I’m executing the <code>add</code> method, I’m taking the last element of the list and when I’m appending it to the list, I’m sure&#13;
that the inserted element is greater than the previous one by a difference of 1.</p></blockquote>&#13;
&#13;
<p class="pagebreak-before">Mathematically, we could write:</p>&#13;
<div data-type="equation">&#13;
<math alttext="l i s t left-bracket n right-bracket equals l i s t left-bracket n minus 1 right-bracket plus 1" display="block">&#13;
  <mrow>&#13;
    <mi>l</mi>&#13;
    <mi>i</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>[</mo>&#13;
    <mi>n</mi>&#13;
    <mo>]</mo>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>i</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>[</mo>&#13;
    <mi>n</mi>&#13;
    <mo>-</mo>&#13;
    <mn>1</mn>&#13;
    <mo>]</mo>&#13;
    <mo>+</mo>&#13;
    <mn>1</mn>&#13;
  </mrow>&#13;
</math>&#13;
</div>&#13;
&#13;
<p>We’ve seen from the beginning that our class wasn’t thread-safe. Now we can say so because when executed in a&#13;
multithreaded environment, the invariant is sometimes violated or our program just crashes.</p>&#13;
&#13;
<p>So, what can we do to enforce our invariants? Actually, this is a complex matter, but we’ll cover some of the most common&#13;
techniques:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Mutexes</p>&#13;
</li>&#13;
<li>&#13;
<p>Thread-safe collections</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mutexes" data-type="sect2"><div class="sect2" id="idm46669753162896">&#13;
<h2>Mutexes</h2>&#13;
&#13;
<p><a data-primary="invariants" data-secondary="mutexes" data-type="indexterm" id="idm46669753161664"/><a data-primary="mutexes" data-type="indexterm" id="idm46669753160464"/><a data-primary="thread safety" data-secondary="mutexes" data-type="indexterm" id="idm46669753159792"/>Mutexes allow you to prevent concurrent access of a state—which can be a block of code or just an object. This mutual&#13;
exclusion is also called<a data-primary="synchronization" data-type="indexterm" id="idm46669753158560"/> <em>synchronization</em>. An <code>Object</code> called a <em>mutex</em> or <em>lock</em> guarantees&#13;
that when taken from a thread, no other thread can enter the section guarded by this lock. When a thread attempts to&#13;
acquire a lock held by another thread, it’s blocked—it cannot proceed with its execution until the lock is released.&#13;
This mechanism is relatively easy to use, which is why it’s often the go-to response of developers when facing this&#13;
situation. Unfortunately, this is also like opening a Pandora’s box to problems like deadlocks, race conditions, etc.&#13;
These problems that can arise from improper synchronization are so numerous that drawing a complete picture is way beyond the scope of this book. However, later in the book we will discuss some of them, like deadlocks in communicating&#13;
sequential &#13;
<span class="keep-together">processes.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Thread-Safe Collections" data-type="sect2"><div class="sect2" id="idm46669753154560">&#13;
<h2>Thread-Safe Collections</h2>&#13;
&#13;
<p><a data-primary="invariants" data-secondary="thread-safe collections" data-type="indexterm" id="ix_ch05-asciidoc4"/><a data-primary="thread safety" data-secondary="thread-safe collections" data-type="indexterm" id="ix_ch05-asciidoc5"/>Thread-safe collections are collections that can be accessed by multiple threads while keeping their state consistent.&#13;
The <code>Collections.synchronizedList</code> is a useful way to make a <code>List</code> thread-safe. It returns a <code>List</code> that wraps access&#13;
to the <code>List</code> passed as a parameter, and regulates concurrent access with an internal lock.</p>&#13;
&#13;
<p>At first sight, it looks interesting. So you could be tempted to use it:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">list</code> <code class="p">=</code>&#13;
        <code class="n">Collections</code><code class="p">.</code><code class="n">synchronizedList</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;(</code><code class="k">object</code> <code class="err">: </code><code class="nc">ArrayList</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">?&gt;()</code> <code class="p">{</code>&#13;
            <code class="n">init</code> <code class="p">{</code>&#13;
                <code class="n">add</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">})</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">add</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">last</code> <code class="p">=</code> <code class="n">list</code><code class="p">.</code><code class="n">last</code><code class="p">()</code>&#13;
        <code class="n">list</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">last</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For the record, here is the equivalent in Java:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">A</code> <code class="o">{</code>&#13;
    <code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">list</code> <code class="o">=</code> <code class="n">Collections</code><code class="o">.</code><code class="na">synchronizedList</code><code class="o">(</code>&#13;
        <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;()</code> <code class="o">{{</code>&#13;
           <code class="n">add</code><code class="o">(</code><code class="mi">1</code><code class="o">);</code>&#13;
        <code class="o">}}</code>&#13;
    <code class="o">);</code>&#13;
&#13;
    <code class="kt">void</code> <code class="nf">add</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="n">Integer</code> <code class="n">last</code> <code class="o">=</code> <code class="n">list</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="n">list</code><code class="o">.</code><code class="na">size</code><code class="o">()</code> <code class="o">-</code> <code class="mi">1</code><code class="o">);</code>&#13;
        <code class="n">list</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">last</code> <code class="o">+</code> <code class="mi">1</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>There’s a problem with both implementations. Can you spot it?</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We could also have declared the list as:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">var</code> <code class="py">list</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">CopyOnWriteArrayList</code><code class="p">(</code><code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">))</code></pre>&#13;
&#13;
<p>which, in Java, is the equivalent of:</p>&#13;
&#13;
<pre class="less_space" data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">list</code> <code class="o">=</code> <code class="k">new</code> <code class="n">CopyOnWriteArrayList</code><code class="o">&lt;&gt;(</code><code class="n">Arrays</code><code class="o">.</code><code class="na">asList</code><code class="o">(</code><code class="mi">1</code><code class="o">));</code></pre>&#13;
&#13;
<p><code>CopyOnWriteArrayList</code> is a thread-safe implementation of <code>ArrayList</code> in which all mutative operations like <code>add</code> and <code>set</code>&#13;
are implemented by making a fresh copy of the underlying array. Thread <em>A</em> can safely iterate through the list. If in&#13;
the meantime, thread <em>B</em> adds an element to the list, a fresh copy will be created and only visible from thread <em>B</em>. This in itself doesn’t make the class thread-safe—it is because <code>add</code> and <code>set</code> are guarded by a lock. This data structure is&#13;
useful when we are iterating over it more often than we are modifying it, as copying the entire underlying array can be&#13;
too costly.  Note that there is also a <code>CopyOnWriteArraySet</code>, which is simply a <code>Set</code> implementation rather than a <code>List</code>&#13;
&#13;
<span class="keep-together">implementation.</span></p>&#13;
</div>&#13;
&#13;
<p>We’ve indeed fixed the concurrent access issue, although our class still doesn’t conform to our invariant. In a test&#13;
environment, we created two threads and started them. Each thread executes the <code>add()</code> method once, on the same instance&#13;
of our class. The first time we ran our test, after the two threads finished their job, the resulting list was&#13;
<code>[1, 2, 3]</code>. Curiously, we ran this same test multiple times, and the result was sometimes <code>[1, 2, 2]</code>. This is due&#13;
to the exact same reason shown earlier: when a thread executes the first line inside <code>add()</code>, the other&#13;
thread can execute the whole <code>add()</code> method before the first thread proceeds with the rest of its execution. See how&#13;
pernicious a synchronization issue can be: it looks good, but our program is broken. And we can easily have it wrong,&#13;
even on a trivial example.</p>&#13;
&#13;
<p>A proper solution is:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">list</code><code class="p">:</code> <code class="n">MutableList</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">mutableListOf</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
&#13;
    <code class="n">@Synchronized</code>&#13;
    <code class="k">fun</code> <code class="nf">add</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">last</code> <code class="p">=</code> <code class="n">list</code><code class="p">.</code><code class="n">last</code><code class="p">()</code>&#13;
        <code class="n">list</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">last</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It ay help to see the Java equivalent:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">A</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">list</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;()</code> <code class="o">{{</code>&#13;
        <code class="n">add</code><code class="o">(</code><code class="mi">1</code><code class="o">);</code>&#13;
    <code class="o">}};</code>&#13;
&#13;
    <code class="kd">synchronized</code> <code class="kt">void</code> <code class="nf">add</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="n">Integer</code> <code class="n">last</code> <code class="o">=</code> <code class="n">list</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="n">list</code><code class="o">.</code><code class="na">size</code><code class="o">()</code> <code class="o">-</code> <code class="mi">1</code><code class="o">);</code>&#13;
        <code class="n">list</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">last</code> <code class="o">+</code> <code class="mi">1</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>As you can see, we actually didn’t need to synchronize the list. Instead, the <code>add()</code> method should have been synchronized.&#13;
Now when the <code>add()</code> method is first executed by a thread, the other one blocks when it tries to execute <code>add()</code>,&#13;
until the first thread leaves the <code>add()</code> method. No two threads execute <code>add()</code> at the same time. The invariant is then&#13;
honored.</p>&#13;
&#13;
<p>This example demonstrates that a class can internally use thread-safe collections while not being thread-safe. A class&#13;
or code is said to be thread-safe when its &#13;
<span class="keep-together">invariants</span> are never violated. Those invariants, and how the class should&#13;
be used according to their creators, define a policy that should be clearly expressed in the javadoc<a data-startref="ix_ch05-asciidoc5" data-type="indexterm" id="idm46669752735248"/><a data-startref="ix_ch05-asciidoc4" data-type="indexterm" id="idm46669752734544"/>.<a data-startref="ix_ch05-asciidoc3" data-type="indexterm" id="idm46669752733744"/><a data-startref="ix_ch05-asciidoc2" data-type="indexterm" id="idm46669752733040"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This is Java’s built-in mechanism to enforce mutual exclusion. A synchronized block is made of a lock and a block of code.&#13;
In Java, every <code>Object</code> can be used as a lock. A synchronized method is a synchronized block whose lock is the instance of&#13;
the class instance. When a thread enters a synchronized block, it acquires the lock. And when a thread leaves the block,&#13;
it releases the lock.</p>&#13;
&#13;
<p>Also note that the <code>add</code> method could have been declared as using a <code>synchronized</code> statement:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">void</code> <code class="n">add</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">synchronized</code><code class="p">(</code><code class="k">this</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">last</code> <code class="p">=</code> <code class="n">list</code><code class="p">.</code><code class="n">last</code><code class="p">()</code>&#13;
        <code class="n">list</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">last</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A thread cannot enter a synchronized block whose lock is already acquired by another thread. As a consequence, when a&#13;
thread enters a synchronized method it prevents other threads from executing any synchronized method or any block of code&#13;
guarded by this (also called <em>intrinsic</em> lock).</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Thread Confinement" data-type="sect1"><div class="sect1" id="idm46669753183072">&#13;
<h1>Thread Confinement</h1>&#13;
&#13;
<p><a data-primary="thread safety" data-secondary="thread confinement" data-type="indexterm" id="idm46669752705408"/>Another way to ensure thread safety is to ensure that only one thread owns the state. If the state isn’t visible to other&#13;
threads, there’s simply no risk of having concurrency issues. For example, a public variable of a class (where usage is intended to be thread-confined to the main thread) is a potential source of bugs since a developer (unaware of this thread policy) could use the variable in another thread.</p>&#13;
&#13;
<p>The immediate benefit of thread confinement is simplicity. For example, if we follow the convention that every class of&#13;
type <code>View</code> should only be used from the main thread, then we can save ourselves from synchronizing our code all over&#13;
the place. But this comes at a price. The correctness of the client code is now on the shoulders of the developer who&#13;
uses our code.&#13;
In Android, as we’ve seen in the previous chapter, manipulating views should only be done from the UI thread. This is a form of thread&#13;
confinement—as long as you don’t break the rules, you shouldn’t have issues involving concurrent access to UI-related&#13;
objects.</p>&#13;
&#13;
<p>Another noteworthy form of thread confinement is<a data-primary="ThreadLocal" data-type="indexterm" id="idm46669752701920"/> <code>ThreadLocal</code>. A <code>ThreadLocal</code> instance can be seen as a provider to some&#13;
object. This provider ensures that the given instance of the object is per-thread unique. In other words, each thread&#13;
owns its own instance of the value. An example of usage is:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">val</code> <code class="py">myConnection</code> <code class="p">=</code>&#13;
        <code class="k">object</code> <code class="err">: </code><code class="nc">ThreadLocal</code><code class="p">&lt;</code><code class="n">Connection</code><code class="p">&gt;()</code> <code class="p">{</code>&#13;
            <code class="k">override</code> <code class="k">fun</code> <code class="nf">initialValue</code><code class="p">():</code> <code class="n">Connection</code><code class="p">?</code> <code class="p">{</code>&#13;
                <code class="k">return</code> <code class="n">DriverManager</code><code class="p">.</code><code class="n">getConnection</code><code class="p">(</code><code class="n">connectionStr</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code></pre>&#13;
&#13;
<p>Often used in conjunction with JDBC connections, which aren’t thread-safe, &#13;
<span class="keep-together"><code>ThreadLocal</code></span> ensures that each thread will use&#13;
its own JDBC connection.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Thread Contention" data-type="sect1"><div class="sect1" id="idm46669752644400">&#13;
<h1>Thread Contention</h1>&#13;
&#13;
<p><a data-primary="thread safety" data-secondary="thread contention" data-type="indexterm" id="idm46669752643088"/>Synchronization between threads is hard because a lot of problems can happen. We just saw potential thread-safety issues.&#13;
There is another hazard that can affect performance: <em>thread contention</em>, which we encourage all programmers to familiarize&#13;
themselves with. Consider this example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">WorkerPool</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">workLock</code> <code class="p">=</code> <code class="n">Any</code><code class="p">()</code> <code class="c1">// In Java, we would have used `new Object()`</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">work</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">synchronized</code><code class="p">(</code><code class="n">workLock</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">try</code> <code class="p">{</code>&#13;
                <code class="n">Thread</code><code class="p">.</code><code class="n">sleep</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code> <code class="c1">// simulate CPU-intensive task</code>&#13;
            <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="n">e</code><code class="p">.</code><code class="n">printStackTrace</code><code class="p">()</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// other methods which may use the intrinsic lock</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So, we have a<a data-primary="WorkerPool" data-type="indexterm" id="idm46669752604592"/> <code>WorkerPool</code>, which controls the work done by worker threads in such a way that only one worker at a time&#13;
can do the real work inside the <code>work</code> method. This is the kind of situation you may encounter when the actual work&#13;
involves the use of non-thread-safe objects and the developer decided to solve this using this locking policy. A dedicated&#13;
lock was created for the <code>work</code> method, instead of synchronizing on <code>this</code>, because other methods can now be called&#13;
by workers without mutual exclusion. This is also the reason why the lock is named after the related method.</p>&#13;
&#13;
<p>If several worker threads are started and call this <code>work</code> method, they will contend for the same lock. Eventually,&#13;
depending on the interleaving of the threads, a worker is blocked because another one acquired the lock. This isn’t a&#13;
problem if the time spent waiting for the lock is significantly less than the rest of the execution time. If this&#13;
isn’t the case, then we have a thread contention. Threads spend most of their time waiting for each other. Then the&#13;
operating system may preemptively stall some threads so that other threads in the wait&#13;
state can resume their execution, which makes the situation even worse because context switches between threads aren’t&#13;
free. It can result in a performance impact when they occur frequently.</p>&#13;
&#13;
<p>As a developer, you should always avoid thread contention as it can rapidly degrade throughput and have consequences&#13;
beyond the affected threads, since the rate of context switches is likely to increase, which in itself impacts performance  overall.</p>&#13;
&#13;
<p>One of the most effective ways to avoid such a situation is to avoid blocking calls, which we explain in the next&#13;
section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Blocking Call Versus Nonblocking Call" data-type="sect1"><div class="sect1" id="idm46669752524256">&#13;
<h1>Blocking Call Versus Nonblocking Call</h1>&#13;
&#13;
<p><a data-primary="blocking call" data-type="indexterm" id="idm46669752522912"/><a data-primary="nonblocking call" data-type="indexterm" id="idm46669752521984"/><a data-primary="thread safety" data-secondary="blocking call versus nonblocking call" data-type="indexterm" id="idm46669752521312"/>So far, we know that a thread can be blocked when attempting to obtain a lock held by another thread. The function that&#13;
led the thread to be blocked is then a <em>blocking call</em>. Even if the lock might be acquired immediately, the fact that&#13;
the call may potentially block makes it a <code>blocking call</code>. But this is just a particular case. There are actually two&#13;
other ways of blocking a thread. The first one is by running CPU-intensive computations—this is also called a <em>CPU-bound</em>&#13;
task. The second one is by waiting for a hardware response. For example, it happens when a network request causes the&#13;
calling thread to wait for the response from a remote server—we then talk about an IO-bound task.<sup><a data-type="noteref" href="ch05.html#idm46669752518320" id="idm46669752518320-marker">2</a></sup></p>&#13;
&#13;
<p>Everything else that makes the call return quickly is considered <em>nonblocking</em>.</p>&#13;
&#13;
<p>When you’re about to make a blocking call, you should avoid doing it from the main thread (also called the UI thread, on&#13;
Android).<sup><a data-type="noteref" href="ch05.html#idm46669752516000" id="idm46669752516000-marker">3</a></sup> This is because this thread&#13;
runs the event loop that processes touch events, and all UI-related tasks like animations. If the main thread gets blocked&#13;
repeatedly and for durations exceeding a few milliseconds, the responsiveness is impacted and this is the cause of&#13;
Android’s <em>application not responding</em> (ANR) errors.</p>&#13;
&#13;
<p>Nonblocking calls is one building block of a responsive app. You need now to recognize patterns which leverage this&#13;
technique. Work queues is one of them, and we’ll encounter various forms of them throughout this book.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Most often, the terms <em>synchronous</em> and <em>asynchronous</em> are respectively used as synonyms for <em>blocking</em> and <em>nonblocking</em>.&#13;
While they are conceptually close concepts, the usage of, for instance, asynchronous instead of nonblocking depends on the context.&#13;
Asynchronous calls usually involve the idea of a callback, while this is not necessarily the case for nonblocking.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Work Queues" data-type="sect1"><div class="sect1" id="wqueue">&#13;
<h1>Work Queues</h1>&#13;
&#13;
<p><a data-primary="thread safety" data-secondary="work queues" data-type="indexterm" id="idm46669752508864"/><a data-primary="work queues" data-type="indexterm" id="idm46669752507888"/>Communication between threads and, in particular, work submission from one thread to another is widely used in Android.&#13;
It’s an implementation of the <em>producer-consumer</em> design pattern. Applied to threads, the producer is in this context a&#13;
thread which generates data that needs to be further processed by a consumer thread. Instead of having the producer&#13;
directly interacting with the consumer through shared mutable state, a queue is used in between to enqueue the work&#13;
generated by the producer. It decouples the producer from the consumer—but this isn’t the only benefit, as we’ll see.&#13;
Often, the <code>Queue</code> works in a FIFO (first in, first out) manner.<sup><a data-type="noteref" href="ch05.html#idm46669752505600" id="idm46669752505600-marker">4</a></sup></p>&#13;
&#13;
<p>Semantically it can help to think of a <code>Queue</code> like a queue of moviegoers. As the first viewer arrives,&#13;
they are put at the front of the queue. Each additional viewer is added behind the last. When the doors open&#13;
and viewers are allowed to enter, the first person in line is let in first, then the next, and so on, until the&#13;
entire <code>Queue</code> is empty.</p>&#13;
&#13;
<p>The producer puts an object at the head of the queue, and the consumer pops an object at the tail of the queue.&#13;
The <code>put</code> method might be a blocking call, but if it can be proven that most of the time it effectively doesn’t block (and when it&#13;
does, it’s for a short time), then we have a very efficient way to offload work from the producer to the consumer in a&#13;
nonblocking way (from the standpoint of the producer), as shown in <a data-type="xref" href="#producer_consumer_fig_id">Figure 5-1</a>.</p>&#13;
&#13;
<p>In practice, enqueued objects are often <code>Runnable</code> instances submitted by a background thread and processed by the main&#13;
thread. Also, this isn’t limited to one producer and one consumer. Multiple producers can submit work to the queue,&#13;
concurrently with multiple consumers taking work out of the queue. This implies that the queue must be thread-safe.<sup><a data-type="noteref" href="ch05.html#idm46669752499840" id="idm46669752499840-marker">5</a></sup></p>&#13;
&#13;
<figure><div class="figure" id="producer_consumer_fig_id">&#13;
<img alt="pawk 0501" src="assets/pawk_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>Producer-consumer.</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Don’t confuse a <code>Queue</code> with a<a data-primary="Stack" data-type="indexterm" id="idm46669752495968"/> <code>Stack</code>, which uses LIFO (last in, first out) instead of FIFO.</p>&#13;
&#13;
<p>Semantically, let’s imagine a <code>Stack</code> as a stack of pancakes.  When the kitchen makes more pancakes, they go on the top of the stack.&#13;
When the diner eats pancakes, they also take them from the top of the stack.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Back Pressure" data-type="sect1"><div class="sect1" id="idm46669752493344">&#13;
<h1>Back Pressure</h1>&#13;
&#13;
<p><a data-primary="back pressure" data-type="indexterm" id="ix_ch05-asciidoc7"/><a data-primary="thread safety" data-secondary="back pressure" data-type="indexterm" id="ix_ch05-asciidoc8"/>Imagine now that our producer is much faster than our consumer. The work objects then accumulate in the queue. If the queue&#13;
happens to be unbounded, we risk exhausting memory resources and potentially an unrecoverable exception: the application&#13;
may crash.  While not only is this experience jarring and unpleasant for the user, but in an unhandled error like this,&#13;
you’re almost assuredly going to lose whatever stateful information was present. Unless you’ve taken great care to be&#13;
aware of—and react to—this circumstance, you may experience a sudden termination without an opportunity to perform&#13;
any cleanup you might do normally.  In Android, when a Bitmap instance is no longer being used,&#13;
the recycle method can be used to mark each underlying memory allocation as unreachable and eligible for garbage&#13;
collection.  In an untidy system exit, you might not have an opportunity to do that and may risk leaking that data.</p>&#13;
&#13;
<p>In this case, a wise choice is to use a bounded queue. But what should happen when the queue is full and a producer&#13;
attempts to <code>put</code> an object?</p>&#13;
&#13;
<p>We’ll circle back to it with coroutines, but since we’re only talking about threads for now, the answer is: it should&#13;
block the producer thread until the consumer takes at least one object out of the queue. Although this blocking should&#13;
be part of the design and anticipate whatever circumstance or logic branch might deliver the user to this point in the&#13;
program. While blocking a thread seems harmful, a blocked producer allows the consumer to catch up and free up enough&#13;
space into the queue so that the producer is released.</p>&#13;
&#13;
<p>This mechanism is known as <em>back pressure</em>—the ability of a data consumer that can’t keep up with incoming data to&#13;
slow down the data producer. It’s a very powerful way to design robust systems. <a data-type="xref" href="#back_pressure_example_id">Example 5-1</a> shows a implementation of back pressure.</p>&#13;
<div data-type="example" id="back_pressure_example_id">&#13;
<h5><span class="label">Example 5-1. </span>Back pressure example</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">workQueue</code> <code class="p">=</code> <code class="n">LinkedBlockingQueue</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;(</code><code class="m">5</code><code class="p">)</code>  <code class="c1">// queue of size 5</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">producer</code> <code class="p">=</code> <code class="n">thread</code> <code class="p">{</code>&#13;
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="cm">/* Inserts one element at the tail of the queue,</code>&#13;
<code class="cm">             * waiting if necessary for space to become available. */</code>&#13;
            <code class="n">workQueue</code><code class="p">.</code><code class="n">put</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Producer added a new element to the queue"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">consumer</code> <code class="p">=</code> <code class="n">thread</code> <code class="p">{</code>&#13;
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="c1">// We have a slow consumer - it sleeps at each iteration</code>&#13;
            <code class="n">Thread</code><code class="p">.</code><code class="n">sleep</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
            <code class="n">workQueue</code><code class="p">.</code><code class="n">take</code><code class="p">()</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Consumer took an element out of the queue"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Since Java 7, a family of queues for this&#13;
purpose is <code>BlockingQueue</code>—it’s an interface, and implementations range from a single-ended queue with&#13;
<code>LinkedBlockingQueue</code> to a double-ended queue with <code>LinkedBlockingDequeue</code> (other implementations exist). The output of <a data-type="xref" href="#back_pressure_example_id">Example 5-1</a> is:</p>&#13;
&#13;
<pre data-type="programlisting">Producer added a new element to the queue&#13;
Producer added a new element to the queue&#13;
Producer added a new element to the queue&#13;
Producer added a new element to the queue&#13;
Producer added a new element to the queue&#13;
Consumer took an element out of the queue&#13;
Producer added a new element to the queue&#13;
Consumer took an element out of the queue&#13;
Producer added a new element to the queue&#13;
...</pre>&#13;
&#13;
<p>You can see that the producer quickly filled the queue with five elements. Then, on the sixth attempt to add a new element,&#13;
it’s blocked because the queue is full. One &#13;
<span class="keep-together">second</span> later, the consumer takes an element out of the queue, releasing the&#13;
producer which can now add a new element. At this point, the queue is full. The producer tries to add new elements but&#13;
is blocked again. Again, one second later, the consumer takes one element—and so on.</p>&#13;
&#13;
<p>It’s important to note that the insertion of an element into a <code>BlockingQueue</code> isn’t necessarily blocking. If you use&#13;
the <code>put</code> method, then it blocks when the queue is full. Since <code>put</code> <em>might</em> block, we say that this is a blocking call.&#13;
However, there’s another method available to add a new element:<a data-primary="offer" data-type="indexterm" id="idm46669752368368"/> <code>offer</code>, which attempts to immediately add the new&#13;
element and returns a Boolean—whether or not the operation succeeded. Since the <code>offer</code> method does not block the underlying&#13;
thread and only returns false when the queue is full, we say that <code>offer</code> is nonblocking.</p>&#13;
&#13;
<p>Had we used <code>offer</code> instead of <code>put</code> in <a data-type="xref" href="#back_pressure_example_id">Example 5-1</a>, the producer would never be blocked, and the output&#13;
would be filled with <code>Producer added a new element to the queue</code>. There would be no back pressure at all—don’t do this!</p>&#13;
&#13;
<p>The <code>offer</code> method can be useful in situations where losing work is affordable, or if blocking the producer thread isn’t&#13;
suitable. The same reasoning applies when taking an object out of the queue, with <code>take</code> and <code>poll</code>, which are respectively&#13;
blocking and nonblocking.</p>&#13;
&#13;
<p>Conversely, if the consumer is faster than the producer, then the queue eventually becomes empty. In the case of a&#13;
<code>BlockingQueue</code>, using the <code>take</code> method on a consumer site will block until the producer adds new elements in the queue.&#13;
So in this case, the consumer is slowed down to match the rate of the producer.<a data-startref="ix_ch05-asciidoc8" data-type="indexterm" id="idm46669752360416"/><a data-startref="ix_ch05-asciidoc7" data-type="indexterm" id="idm46669752359712"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669752492752">&#13;
<h1>Summary</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A class or code is said to be thread-safe when its invariants are never violated. So, thread safety always refers to a&#13;
policy that should be clearly defined in the class javadoc.</p>&#13;
</li>&#13;
<li>&#13;
<p>A class can use internally thread-safe data structures while not being thread-safe.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid or reduce thread contention as much as possible. Thread contention is often the consequence of a poor locking&#13;
strategy. An efficient way to reduce this risk is to do nonblocking calls whenever possible.</p>&#13;
</li>&#13;
<li>&#13;
<p>Work queues is a pattern you will often encounter in Android and other platforms like backend services. It simplifies&#13;
how a producer (like UI thread) offloads tasks to consumers (your background threads). Consumers process the tasks&#13;
whenever they can. When the task completes, a consumer can use another work queue to send back to the original producer&#13;
the result of its work.</p>&#13;
</li>&#13;
<li>&#13;
<p>A bounded <code>BlockingQueue</code> blocks a <code>put</code> operation when it’s full. So a too-fast producer eventually gets blocked,&#13;
which gives consumers the opportunity to catch up. This is an implementation of back pressure, which has one major&#13;
downside: the thread of the producer might get blocked. Is it possible to have back pressure without blocking the <a data-startref="ix_ch05-asciidoc0" data-type="indexterm" id="idm46669752351136"/>producer&#13;
thread? Yes—we’ll see that in &#13;
<span class="keep-together"><a data-type="xref" href="ch09.html#channels_id">Chapter 9</a>.</span></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669753196768"><sup><a href="ch05.html#idm46669753196768-marker">1</a></sup> Actually, interleaving of threads can happen between lines of bytecode, not just between lines of normal Java.</p><p data-type="footnote" id="idm46669752518320"><sup><a href="ch05.html#idm46669752518320-marker">2</a></sup> IO operations aren’t necessarily blocking. Nonblocking IO exists, though it’s much more complicated to reason about. Android Link is helpful enough to warn you when you perform an HTTP request on the main thread, but other IO tasks—like reading a file or querying a database—do not do this. This may even be a deliberate and accepted practice if done under extremely thoughtful and careful supervision; while possible, this should be a rare exception to the standard.</p><p data-type="footnote" id="idm46669752516000"><sup><a href="ch05.html#idm46669752516000-marker">3</a></sup> Even for worker threads, executing a long-running task like working with 8-megapixel images, those blocking calls possibly block task packets the UI is waiting on.</p><p data-type="footnote" id="idm46669752505600"><sup><a href="ch05.html#idm46669752505600-marker">4</a></sup> Although not all work queues use this data structure arrangement. Some of them are more sophisticated, like Android’s <code>MessageQueue</code>.</p><p data-type="footnote" id="idm46669752499840"><sup><a href="ch05.html#idm46669752499840-marker">5</a></sup> Even with one producer and one consumer, the queue must be thread-safe.</p></div></div></section></body></html>