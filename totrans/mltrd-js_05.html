<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Shared Memory" class="calibre4"><div class="preface" id="ch_shared_mem">
<h1 class="calibre12"><span class="keep-together">Chapter 4. </span>Shared Memory</h1>


<p class="author1">So far you’ve been exposed to the web workers API for browsers, covered in <a data-type="xref" href="ch02.xhtml#ch_browser" class="calibre6">Chapter 2</a>, and the worker threads module for Node.js, covered in <a data-type="xref" href="ch03.xhtml#ch_nodejs_sec_workermodule" class="calibre6">“The worker_threads Module”</a>. These are two powerful tools for working with concurrency in JavaScript, allowing developers to run code in parallel in a way that wasn’t previously available to JavaScript.</p>

<p class="author1">However, the interaction you’ve had with them so far has been fairly shallow. While it’s true they allow you to run code in parallel, you’ve only done so using message-passing APIs, ultimately depending on the familiar event loop to handle the receipt of a message. This is a much less performant system than the threading code you worked with in <a data-type="xref" href="ch01.xhtml#ch_intro_sec_happycoin" class="calibre6">“Threads in C: Get Rich with Happycoin”</a> where these disparate threads are able to access the same shared memory.</p>

<p class="author1">This chapter covers two powerful tools available to your JavaScript applications: the <code class="calibre18">Atomics</code> object and the <code class="calibre18">SharedArrayBuffer</code> class. These allow you to share <a data-type="indexterm" data-primary="shared memory" data-secondary="Atomics object" id="idm45995921275848" class="calibre6"/><a data-type="indexterm" data-primary="shared memory" data-secondary="SharedArrayBuffer" id="idm45995921274872" class="calibre6"/><a data-type="indexterm" data-primary="Atomics object" id="idm45995921273928" class="calibre6"/><a data-type="indexterm" data-primary="SharedArrayBuffer" id="idm45995921273256" class="calibre6"/>memory between two threads without depending on message passing. But before diving into a complete technical explanation for these objects, a quick introductory example is in order.</p>

<p class="author1">In the wrong hands, the tools covered here can be dangerous, introducing logic-defying bugs to your application that slither in the shadows during development only to rear their heads in production. But when honed and used properly, these tools allow your application to soar to new heights, squeezing never-before-seen levels of performance from your hardware.</p>






<section data-type="sect1" data-pdf-bookmark="Intro to Shared Memory" class="calibre4"><div class="preface" id="ch_shared_mem_sec_intro">
<h1 class="calibre13">Intro to Shared Memory</h1>

<p class="author1">For this example you will build a very basic application that is able to communicate between two web workers. While this does require an initial bit of boilerplate using <code class="calibre18">postMessage()</code> and <code class="calibre18">onmessage</code>, subsequent updates won’t rely on such functionality.</p>

<p class="author1">This shared memory example will <a data-type="indexterm" data-primary="shared memory" data-secondary="postMessage() and" id="idm45995921268040" class="calibre6"/><a data-type="indexterm" data-primary="shared memory" data-secondary="onmessage and" id="idm45995921267064" class="calibre6"/>work in a browser as well as in Node.js, though the setup work required is a little different for the two of them. For now, you’ll build out an example that works in the browser, and a lot of description is provided. Later, once you’re a little more familiar, you’ll build out an example using Node.js.</p>








<section data-type="sect2" data-pdf-bookmark="Shared Memory in the Browser" class="calibre4"><div class="preface" id="idm45995921265544">
<h2 class="calibre37">Shared Memory in the Browser</h2>

<p class="author1">To get started, create another directory to house <a data-type="indexterm" data-primary="browser" data-secondary="shared memory and" id="brow_sharmem" class="calibre6"/><a data-type="indexterm" data-primary="shared memory" data-secondary="browser and" id="shar_brow" class="calibre6"/><a data-type="indexterm" data-primary="code samples" data-secondary="ch4-web-workers" id="idm45995921260904" class="calibre6"/>this project in named <em class="calibre7">ch4-web-workers/</em>. Then, create an HTML file named <em class="calibre7">index.html</em>, and add the content from <a data-type="xref" href="#ex_sharedmemory_index" class="calibre6">Example 4-1</a> to it.</p>
<div id="ex_sharedmemory_index" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 4-1. </span><em class="calibre7">ch4-web-workers/index.html</em></h5>

<pre data-type="programlisting" data-code-language="html" class="calibre28"><code class="nt">&lt;html&gt;</code>
  <code class="nt">&lt;head&gt;</code>
    <code class="nt">&lt;title&gt;</code>Shared Memory Hello World<code class="nt">&lt;/title&gt;</code>
    <code class="nt">&lt;script </code><code class="na">src=</code><code class="s">"main.js"</code><code class="nt">&gt;&lt;/script&gt;</code>
  <code class="nt">&lt;/head&gt;</code>
<code class="nt">&lt;/html&gt;</code></pre></div>

<p class="author1">Once you’re done with that file you’re ready for the more complicated part of the application. Create a file named <em class="calibre7">main.js</em> containing <a data-type="indexterm" data-primary="main.js file" id="idm45995921239192" class="calibre6"/>the content from <a data-type="xref" href="#ex_sharedmemory_main" class="calibre6">Example 4-2</a>.</p>
<div id="ex_sharedmemory_main" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 4-2. </span><em class="calibre7">ch4-web-workers/main.js</em></h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="o">!</code><code class="nx">crossOriginIsolated</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><a class="calibre6" id="co_shared_memory_CO1-1" href="#callout_shared_memory_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="kr">throw</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nb">Error</code><code class="p">(</code><code class="s">'Cannot use SharedArrayBuffer'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18">

</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">worker</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="s">'worker.js'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">buffer</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="mi">1024</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_shared_memory_CO1-2" href="#callout_shared_memory_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">view</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_shared_memory_CO1-3" href="#callout_shared_memory_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">

</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'now'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

</code><code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="nx">buffer</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

</code><code class="nx">setTimeout</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'later'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'prop'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">buffer</code><code class="p">.</code><code class="nx">foo</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_shared_memory_CO1-4" href="#callout_shared_memory_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a><code class="calibre18">
</code><code class="p">}</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">500</code><code class="p">)</code><code class="p">;</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_shared_memory_CO1-1" href="#co_shared_memory_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">When <code class="calibre18">crossOriginIsolated</code> is true, then <code class="calibre18">SharedArrayBuffer</code> can be used.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_shared_memory_CO1-2" href="#co_shared_memory_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">Instantiates a 1 KB buffer.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_shared_memory_CO1-3" href="#co_shared_memory_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">A view into the buffer is created.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_shared_memory_CO1-4" href="#co_shared_memory_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">A modified property is read.</p></dd>
</dl></div>

<p class="author1">This file is similar to one that you created before. In fact, it’s still making use of a dedicated worker. But a few complexities have been added. The first new thing is the check <a data-type="indexterm" data-primary="crossOriginIsolated" id="idm45995921087768" class="calibre6"/>for the <code class="calibre18">crossOriginIsolated</code> value, which is a global variable available in modern browsers. This value tells you if the JavaScript code currently being run is capable of, among other things, instantiating a <code class="calibre18">SharedArrayBuffer</code> instance.</p>

<p class="author1">For security reasons (related to the Spectre CPU attack), the <code class="calibre18">SharedArrayBuffer</code> object isn’t <a data-type="indexterm" data-primary="SharedArrayBuffer" data-secondary="instantiation" id="idm45995921049464" class="calibre6"/>always available for instantiation. In fact, a few years ago browsers disabled this functionality entirely. Now, both Chrome and Firefox support the object and require additional HTTP headers to be set when the document is served before it will allow a <code class="calibre18">SharedArrayBuffer</code> to be instantiated. Node.js doesn’t have the same restrictions. Here are the required headers:</p>

<pre data-type="programlisting" class="calibre38">Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp</pre>

<p class="author1">The test server that you’ll run automatically sets these headers. Any time you build a production-ready application that uses <code class="calibre18">SharedArrayBuffer</code> instances you’ll need to remember to set these headers.</p>

<p class="author1">After a dedicated worker is instantiated, an instance of a <code class="calibre18">SharedArrayBuffer</code> is also instantiated. The argument that follows, 1,024 in this case, is the number of bytes allocated to the buffer. Unlike other arrays or buffer objects you might be familiar with, these buffers cannot shrink or grow in size after they’ve been created.<sup class="calibre39"><a data-type="noteref" id="idm45995921045144-marker" href="ch04.xhtml#idm45995921045144" class="calibre40">1</a></sup></p>

<p class="author1">A view to work with the <a data-type="indexterm" data-primary="buffers" data-secondary="views" id="idm45995921043640" class="calibre6"/><a data-type="indexterm" data-primary="views" data-secondary="buffers" id="idm45995921042792" class="calibre6"/>buffer named <code class="calibre18">view</code> has also been created. Such views are covered extensively in <a data-type="xref" href="#ch_shared_mem_sec_typedarrays" class="calibre6">“SharedArrayBuffer and TypedArrays”</a>, but for now, think of them as a way to read from and write to a buffer.</p>

<p class="author1">This view into the buffer allows us to read from it using the array index syntax. In this case, we’re able to inspect the 0th byte in the buffer by logging a call to <code class="calibre18">view[0]</code>. After that, the buffer <a data-type="indexterm" data-primary="buffers" data-secondary="passing to worker" id="idm45995921039512" class="calibre6"/><a data-type="indexterm" data-primary="worker threads" data-secondary="buffers, passing" id="idm45995921038664" class="calibre6"/>instance is passed into the worker using the <code class="calibre18">worker.postMessage()</code> method. In this case the buffer is the only thing being passed in. However, a more complex object could have been passed in as well, with the buffer being one of the properties. Whereas the algorithm discussed in the <a data-type="xref" data-xrefstyle="appendix" href="app01.xhtml#app_sca" class="calibre6">Appendix</a> mostly clobbers complex objects, instances of <code class="calibre18">SharedArrayBuffer</code> are an intentional exception.</p>

<p class="author1">Once the script is finished with the setup work, it schedules a function to run in 500 ms. This script prints the 0th byte of the buffer again and also attempts to print a property attached to the buffer named <code class="calibre18">.foo</code>. Note that this file otherwise does not have a <code class="calibre18">worker.onmessage</code> handler defined.</p>

<p class="author1">Now that you’re finished with the main JavaScript file <a data-type="indexterm" data-primary="worker.js file" id="idm45995921033944" class="calibre6"/>you’re ready to create the worker. Make a file named <em class="calibre7">worker.js</em> and add the content from <a data-type="xref" href="#ex_sharedmemory_worker" class="calibre6">Example 4-3</a> to it.</p>
<div id="ex_sharedmemory_worker" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 4-3. </span><em class="calibre7">ch4-web-workers/worker.js</em></h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="nx">self</code><code class="p">.</code><code class="nx">onmessage</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="p">(</code><code class="p">{</code><code class="nx">data</code><code class="o">:</code><code class="calibre18"> </code><code class="nx">buffer</code><code class="p">}</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">buffer</code><code class="p">.</code><code class="nx">foo</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">42</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_shared_memory_CO2-1" href="#callout_shared_memory_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">view</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">2</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_shared_memory_CO2-2" href="#callout_shared_memory_CO2-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'updated in worker'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="p">;</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_shared_memory_CO2-1" href="#co_shared_memory_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">A property on the buffer object is written.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_shared_memory_CO2-2" href="#co_shared_memory_CO2-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The 0th index is set to the number 2.</p></dd>
</dl></div>

<p class="author1">This file attaches a handler for the <code class="calibre18">onmessage</code> event, which <a data-type="indexterm" data-primary="onmessage event" id="idm45995920974936" class="calibre6"/>is run after the <code class="calibre18">.postMessage()</code> method in <em class="calibre7">main.js</em> is fired. Once called, the buffer argument is grabbed. 
<span class="keep-together">The first</span> thing that happens in the handler is that a <code class="calibre18">.foo</code> property is attached to the 
<span class="keep-together"><code class="calibre18">SharedArrayBuffer</code></span> instance. Next, another view is created for the buffer. After that the buffer is updated through the view. Once that’s done, a message is printed so that you can see what has happened.</p>

<p class="author1">Now that your files are complete, you’re ready to run your new application. Open up a terminal window and run the following command. It’s a little different than the <code class="calibre18">serve</code> commands you ran before because it needs to provide the security headers:</p>

<pre data-type="programlisting" data-code-language="shell" class="calibre38"><code class="nv">$ </code>npx MultithreadedJSBook/serve .</pre>

<p class="author1">As before, open the link displayed in your terminal. Next, open the web inspector and visit the Console tab. You might not see any output; if so, refresh the page to execute the code again. You should see logs printed from the application. An example of the output has been reproduced in <a data-type="xref" href="#ex_sharedmemory_output" class="calibre6">Table 4-1</a>.</p>
<table id="ex_sharedmemory_output" class="calibre46">
<caption class="calibre47"><span class="keep-together">Table 4-1. </span>Example console output</caption>
<thead class="calibre48">
<tr class="calibre49">
<th class="calibre50">Log</th>
<th class="calibre50">Location</th>
</tr>
</thead>
<tbody class="calibre51">
<tr class="calibre49">
<td class="calibre52"><p class="author1">now 0</p></td>
<td class="calibre52"><p class="author1">main.js:10:9</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1">updated in worker</p></td>
<td class="calibre52"><p class="author1">worker.js:5:11</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1">later 2</p></td>
<td class="calibre52"><p class="author1">main.js:15:11</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1">prop undefined</p></td>
<td class="calibre52"><p class="author1">main.js:16:11</p></td>
</tr>
</tbody>
</table>

<p class="author1">The first printed line is the initial value of the buffer as seen in <em class="calibre7">main.js</em>. In this case the value is <code class="calibre18">0</code>. Next, the code in <em class="calibre7">worker.js</em> is run, though the timing of this is mostly indeterminate. About half a second later, the value as perceived in <em class="calibre7">main.js</em> is printed again, and the value is now set to <code class="calibre18">2</code>. Again, notice that other than the initial setup work, no message passing happened between the thread running the <em class="calibre7">main.js</em> file and the thread running the <em class="calibre7">worker.js</em> file.</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="author1">This is a very simple example that, while it works, is not how you would normally write multithreaded code. There is no guarantee that the value updated in <em class="calibre7">worker.js</em> would be visible in <em class="calibre7">main.js</em>. For example, a clever JavaScript engine could treat the value as a constant, though you’d be hard-pressed to find a browser where this doesn’t happen.</p>
</div>

<p class="author1">After the buffer <a data-type="indexterm" data-primary="buffers" data-secondary="value, printing" id="idm45995920919080" class="calibre6"/><a data-type="indexterm" data-primary="foo property" id="idm45995920918072" class="calibre6"/>value is printed, the <code class="calibre18">.foo</code> property is also printed and a value of 
<span class="keep-together"><code class="calibre18">undefined</code></span> is displayed. Why might this be? Well, while it’s true that a reference to the memory location that stores the binary data contained in the buffer has been shared between the two JavaScript environments, the actual object itself has not been shared. If it had been, this would violate the constraint of the <a data-type="indexterm" data-primary="browser" data-secondary="shared memory and" data-startref="brow_sharmem" id="idm45995920894408" class="calibre6"/><a data-type="indexterm" data-primary="shared memory" data-secondary="browser and" data-startref="shar_brow" id="idm45995920893432" class="calibre6"/>structured clone algorithm wherein object references cannot be shared between threads.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Shared Memory in Node.js" class="calibre4"><div class="preface" id="idm45995921264632">
<h2 class="calibre37">Shared Memory in Node.js</h2>

<p class="author1">The Node.js equivalent of this <a data-type="indexterm" data-primary="shared memory" data-secondary="Node.js" id="shar_Node" class="calibre6"/><a data-type="indexterm" data-primary="Node.js" data-secondary="shared memory" id="nodeshare" class="calibre6"/>application is mostly similar; however, the <code class="calibre18">Worker</code> global provided by browsers isn’t available, and the worker thread won’t make use of <code class="calibre18">self.onmessage</code>. Instead, the worker threads module must be required to gain access to this functionality. Since Node.js isn’t a browser the <em class="calibre7">index.html</em> file isn’t applicable.</p>

<p class="author1">To create a Node.js equivalent, you’ll only <a data-type="indexterm" data-primary="code samples" data-secondary="ch4-web-workers directory" id="idm45995920887016" class="calibre6"/>need two files, which can be put in the same <em class="calibre7">ch4-web-workers/</em> folder you’ve been using. First, create a <em class="calibre7">main-node.js</em> script, and add the content from <a data-type="xref" href="#ex_sharedmemory_main_node" class="calibre6">Example 4-4</a> to it.</p>
<div id="ex_sharedmemory_main_node" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 4-4. </span><em class="calibre7">ch4-web-workers/main-node.js</em></h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">#!/usr/bin/env node</code>

<code class="kr">const</code> <code class="p">{</code> <code class="nx">Worker</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'worker_threads'</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">worker</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Worker</code><code class="p">(</code><code class="nx">__dirname</code> <code class="o">+</code> <code class="s">'/worker-node.js'</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">buffer</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="mi">1024</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'now'</code><code class="p">,</code> <code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>

<code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>

<code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'later'</code><code class="p">,</code> <code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'prop'</code><code class="p">,</code> <code class="nx">buffer</code><code class="p">.</code><code class="nx">foo</code><code class="p">);</code>
  <code class="nx">worker</code><code class="p">.</code><code class="nx">unref</code><code class="p">();</code>
<code class="p">},</code> <code class="mi">500</code><code class="p">);</code></pre></div>

<p class="author1">The code is a little different, but it should feel mostly familiar. Because the <code class="calibre18">Worker</code> global isn’t available, it is instead accessed by pulling the <code class="calibre18">.Worker</code> property from the required <code class="calibre18">worker_threads</code> module. When instantiating the worker a more explicit path to the worker must be provided than what is accepted by browsers. In this case the path 
<span class="keep-together"><em class="calibre7">./worker-node.js</em></span> was required, even though browsers are fine with just <em class="calibre7">worker.js</em>. Other than that, the main JavaScript file for this Node.js example is mostly unchanged when compared to the browser equivalent. The final <code class="calibre18">worker.unref()</code> call was <a data-type="indexterm" data-primary="worker.unref()" id="idm45995920796808" class="calibre6"/>added to prevent the worker from keeping the process running forever.</p>

<p class="author1">Next, create a file named <em class="calibre7">worker-node.js</em>, which will <a data-type="indexterm" data-primary="worker_node.js file" id="idm45995920795272" class="calibre6"/><a data-type="indexterm" data-primary="Node.js" data-secondary="worker_node.js file" id="idm45995920794536" class="calibre6"/>contain the Node.js equivalent of the browser worker. Add the content from <a data-type="xref" href="#ex_sharedmemory_worker_node" class="calibre6">Example 4-5</a> to this file.</p>
<div id="ex_sharedmemory_worker_node" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 4-5. </span><em class="calibre7">ch4-web-workers/worker-node.js</em></h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code> <code class="p">{</code> <code class="nx">parentPort</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'worker_threads'</code><code class="p">);</code>

<code class="nx">parentPort</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'message'</code><code class="p">,</code> <code class="p">(</code><code class="nx">buffer</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">buffer</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
  <code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>
  <code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'updated in worker'</code><code class="p">);</code>
<code class="p">});</code></pre></div>

<p class="author1">In this case the <code class="calibre18">self.onmessage</code> value isn’t available to the worker. Instead, the <code class="calibre18">worker_threads</code> module is required <a data-type="indexterm" data-primary="worker_threads module" data-secondary="parentPort property" id="idm45995920744120" class="calibre6"/>again, and the <code class="calibre18">.parentPort</code> property from the module is used. This is used to represent a connection to the port from the calling JavaScript environment.</p>

<p class="author1">The <code class="calibre18">.onmessage</code> handler can be <a data-type="indexterm" data-primary="parentPort property, onmessage handler" id="idm45995920741272" class="calibre6"/>assigned to the <code class="calibre18">parentPort</code> object, and the method 
<span class="keep-together"><code class="calibre18">.on('message', cb)</code></span> can be called. If using both, they’ll be called in 
<span class="keep-together">the order</span> that they were used. The callback <a data-type="indexterm" data-primary="message events" data-secondary="callback functions" id="idm45995920738456" class="calibre6"/><a data-type="indexterm" data-primary="callbacks" data-secondary="message events" id="idm45995920676568" class="calibre6"/>function for the <code class="calibre18">message</code> event receives the object being passed in (<code class="calibre18">buffer</code> in this case) directly as an argument, while the 
<span class="keep-together"><code class="calibre18">onmessage</code></span> handler provides a <code class="calibre18">MessageEvent</code> instance with a <code class="calibre18">.data</code> property containing <code class="calibre18">buffer</code>. Which approach you use mostly depends on personal preference.</p>

<p class="author1">Other than that the code is exactly the same between Node.js and the browser, the same applicable globals like <code class="calibre18">SharedArrayBuffer</code> are still available, and they still work the same for the sake of this example.</p>

<p class="author1">Now that these files are complete, you can run them using this command:</p>

<pre data-type="programlisting" class="calibre38">$ node main-node.js</pre>

<p class="author1">The output from this command should be equivalent to the output in <a data-type="xref" href="#ex_sharedmemory_output" class="calibre6">Table 4-1</a> as displayed in the browser. Again, the same structured clone algorithm allows instances of <code class="calibre18">SharedArrayBuffer</code> to be passed along, but only the underlying binary <a data-type="indexterm" data-primary="shared memory" data-secondary="Node.js" data-startref="shar_Node" id="idm45995920668760" class="calibre6"/><a data-type="indexterm" data-primary="Node.js" data-secondary="shared memory" data-startref="nodeshare" id="idm45995920667512" class="calibre6"/>buffer data, not a direct reference to the object itself.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="SharedArrayBuffer and TypedArrays" class="calibre4"><div class="preface" id="ch_shared_mem_sec_typedarrays">
<h1 class="calibre13">SharedArrayBuffer and TypedArrays</h1>

<p class="author1">Traditionally the JavaScript language didn’t really support interaction with binary data. Sure, there were <a data-type="indexterm" data-primary="shared memory" data-secondary="ArrayBuffer object" id="sharArr" class="calibre6"/><a data-type="indexterm" data-primary="shared memory" data-secondary="SharedArrayBuffer" id="sharshararr" class="calibre6"/>strings, but they really abstracted the underlying data storage mechanism. There were also arrays, but those can contain values of any type and aren’t appropriate for representing binary buffers. For many years that was sort of “good enough,” especially before the advent of Node.js and the popularity of running JavaScript outside of a web page context took off.</p>

<p class="author1">The Node.js runtime is, among other things, capable of reading and writing to the filesystem, streaming data to and from the network, and so on. Such interactions are not only limited to ASCII-based text files but can also include piping binary data as well. Since there wasn’t a convenient buffer data structure available, the authors created their <a data-type="indexterm" data-primary="Buffer, Node.js" id="idm45995920660136" class="calibre6"/><a data-type="indexterm" data-primary="Node.js" data-secondary="Buffer" id="idm45995920659432" class="calibre6"/>own. Thus, the Node.js <code class="calibre18">Buffer</code> was born.</p>

<p class="author1">As the boundaries of the JavaScript language itself were pushed, so too grew the APIs and the capabilities of the language to interact with the world outside of the browser window. Eventually the <code class="calibre18">ArrayBuffer</code> object and later the <code class="calibre18">SharedArrayBuffer</code> object were created and are now a core part of the language. Most likely, if Node.js were created today, it would not have created its own <code class="calibre18">Buffer</code> implementation.</p>

<p class="author1">Instances of <code class="calibre18">ArrayBuffer</code> and <code class="calibre18">SharedArrayBuffer</code> represent a buffer of binary data that is of fixed length and cannot be resized. While the two are quite similar, it is the latter that will be the focus of this section because it allows applications to share memory across threads. Binary data, while ubiquitous and a first-class concept in many traditional programming languages like C, can be easy to misunderstand, especially for developers using high-level languages such as JavaScript.</p>

<p class="author1">Just in case you haven’t had <a data-type="indexterm" data-primary="binary" id="idm45995920653400" class="calibre6"/><a data-type="indexterm" data-primary="numbers" data-secondary="binary" id="idm45995920652696" class="calibre6"/>experience with it, <em class="calibre7">binary</em> is a system of counting that is 2 based, which at the lowest level is represented as 1s and 0s. Each of these numbers is referred <a data-type="indexterm" data-primary="bits" id="idm45995920651064" class="calibre6"/><a data-type="indexterm" data-primary="decimal system" id="idm45995920650360" class="calibre6"/><a data-type="indexterm" data-primary="numbers" data-secondary="bits" id="idm45995920649688" class="calibre6"/><a data-type="indexterm" data-primary="numbers" data-secondary="decimal system" id="idm45995920648744" class="calibre6"/>to as a <em class="calibre7">bit</em>. <em class="calibre7">Decimal</em>, the system humans mostly use for counting, is 10 based and is represented with numerals from 0 to 9. A combination of 8 bits is referred <a data-type="indexterm" data-primary="bits" data-secondary="bytes" id="idm45995920646648" class="calibre6"/><a data-type="indexterm" data-primary="bytes" id="idm45995920645672" class="calibre6"/>to as a byte and is often the smallest addressable value in memory since it’s usually easier to deal with than individual bits. Basically, this means CPUs (and programmers) work with bytes instead of individual bits.</p>

<p class="author1">These bytes are often <a data-type="indexterm" data-primary="hexadecimal characters" id="idm45995920644376" class="calibre6"/><a data-type="indexterm" data-primary="bytes" data-secondary="hexadecimal characters" id="idm45995920643640" class="calibre6"/>represented as two <em class="calibre7">hexadecimal</em> characters, which is a 16 based system of counting using the numerals 0–9 and the letters A–F. In fact, when you log an instance of an <code class="calibre18">ArrayBuffer</code> using Node.js, the resulting output displays the value of the buffer using hexadecimal.</p>

<p class="author1">Given an arbitrary set of bytes that is stored on disk, or even in a computer’s memory, it’s a little ambiguous what the data means. For example, what might the hexadecimal value <code class="calibre18">0x54</code> (the <code class="calibre18">0x</code> prefix in JavaScript means the value is in hexadecimal) represent? Well, if it’s part of a string, it might mean the capital letter <em class="calibre7">T</em>. However, if it <a data-type="indexterm" data-primary="numbers" data-seealso="integers" id="idm45995920639208" class="calibre6"/><a data-type="indexterm" data-primary="integers" id="idm45995920620856" class="calibre6"/>represents an integer, it might mean the decimal number 84. It might even refer to a memory location, part of a pixel in a JPEG image, or any other number of things. The context here is very important. That same number, represented in binary, looks like <code class="calibre18">0b01010100</code> (the <code class="calibre18">0b</code> prefix represents binary).</p>

<p class="author1">Keeping this ambiguity in mind, it’s also important to mention that the contents of an <code class="calibre18">ArrayBuffer</code> (and <code class="calibre18">SharedArrayBuffer</code>) can’t be directly modified. Instead, a “view” into the buffer must first be created. Also, unlike other languages which might provide access to abandoned memory, when an <code class="calibre18">ArrayBuffer</code> in JavaScript is instantiated the contents of the buffer are initialized to 0. Considering these buffer objects only store numeric data, they truly are a very elementary tool for data storage, one that more complicated systems are often built upon.</p>

<p class="author1">Both <code class="calibre18">ArrayBuffer</code> and <code class="calibre18">SharedArrayBuffer</code> inherit <a data-type="indexterm" data-primary="ArrayBuffer" data-secondary="Object, inheriting from" id="idm45995920615656" class="calibre6"/><a data-type="indexterm" data-primary="SharedArrayBuffer" data-secondary="Object, inheriting from" id="idm45995920614648" class="calibre6"/><a data-type="indexterm" data-primary="inheritance" data-secondary="SharedArrayBuffer" id="idm45995920613704" class="calibre6"/><a data-type="indexterm" data-primary="inheritance" data-secondary="ArrayBuffer" id="idm45995920612760" class="calibre6"/>from <code class="calibre18">Object</code> and come with those associated methods. Other than that, they come with two properties. The first is the read-only value <code class="calibre18">.byteLength</code>, representing the byte length of the buffer, and the second is the <code class="calibre18">.slice(begin, end)</code> method, which returns a copy of the buffer depending on the range that is provided.</p>

<p class="author1">The <code class="calibre18">begin</code> value of <code class="calibre18">.slice()</code> is inclusive, while the <code class="calibre18">end</code> value is exclusive, and is notably different than, say, <code class="calibre18">String#substr(begin, length)</code>, where the second parameter is a length. If the <code class="calibre18">begin</code> value is omitted, it defaults to the first element, and if the <code class="calibre18">end</code> value is omitted, it defaults to the last element. Negative numbers represent values from the end of the buffer.</p>

<p class="author1">Here’s an example of some basic interaction with an <code class="calibre18">ArrayBuffer</code>:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">ab</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">ArrayBuffer</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">ab</code><code class="p">)</code>
<code class="kr">for</code> <code class="p">(</code><code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">8</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">view</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">i</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">view</code><code class="p">);</code>
<code class="c">// Uint8Array(8) [</code>
<code class="c">//   0, 1, 2, 3,</code>
<code class="c">//   4, 5, 6, 7</code>
<code class="c">// ]</code>
<code class="nx">ab</code><code class="p">.</code><code class="nx">byteLength</code><code class="p">;</code> <code class="c">// 8</code>
<code class="nx">ab</code><code class="p">.</code><code class="nx">slice</code><code class="p">();</code> <code class="c">// 0, 1, 2, 3, 4, 5, 6, 7</code>
<code class="nx">ab</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">);</code> <code class="c">// 4, 5</code>
<code class="nx">ab</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="o">-</code><code class="mi">3</code><code class="p">,</code> <code class="o">-</code><code class="mi">2</code><code class="p">);</code> <code class="c">// 5</code></pre>

<p class="author1">Different JavaScript environments display the <a data-type="indexterm" data-primary="ArrayBuffer" data-secondary="contents display" id="idm45995920603096" class="calibre6"/>contents of an <code class="calibre18">ArrayBuffer</code> instance differently. Node.js displays a list of hexadecimal pairs as if the data were going to be viewed as a <code class="calibre18">Uint8Array</code>. Chrome v88 displays an expandable object with several different views. Firefox, however, won’t display the data, and will need to first be passed through a view.</p>

<p class="author1">The term <em class="calibre7">view</em> has been <a data-type="indexterm" data-primary="views" id="idm45995920521096" class="calibre6"/>mentioned in a few places, and now is a good time to define it. Due to the ambiguity of what binary data can mean, we need to use a view to read and write to the underlying buffer. There are several of these views available in JavaScript. Each of these views extends from a base class <a data-type="indexterm" data-primary="TypedArray class" id="idm45995920519928" class="calibre6"/><a data-type="indexterm" data-primary="classes" data-secondary="TypedArray" id="idm45995920519256" class="calibre6"/>called <code class="calibre18">TypedArray</code>. This class can’t be instantiated directly and isn’t available as a global, but it can be accessed by grabbing the <code class="calibre18">.prototype</code> property from an instantiated child class.</p>

<p class="author1"><a data-type="xref" href="#list_typed_array" class="calibre6">Table 4-2</a> contains a <a data-type="indexterm" data-primary="view classes" id="idm45995920516152" class="calibre6"/><a data-type="indexterm" data-primary="classes" data-secondary="view classes" id="idm45995920515448" class="calibre6"/>list of the view classes that extend from <code class="calibre18">TypedArray</code>.</p>
<table id="list_typed_array" class="calibre46">
<caption class="calibre47"><span class="keep-together">Table 4-2. </span>Classes that extend <code class="calibre58">TypedArray</code></caption>
<thead class="calibre48">
<tr class="calibre49">
<th class="calibre50">Class</th>
<th class="calibre50">Bytes</th>
<th class="calibre50">Minimum Value</th>
<th class="calibre50">Maximum Value</th>
</tr>
</thead>
<tbody class="calibre51">
<tr class="calibre49">
<td class="calibre52"><p class="author1"><code class="calibre59">Int8Array</code></p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">–128</p></td>
<td class="calibre52"><p class="author1">127</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1"><code class="calibre59">Uint8Array</code></p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">255</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1"><code class="calibre59">Uint8ClampedArray</code></p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">255</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1"><code class="calibre59">Int16Array</code></p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">–32,768</p></td>
<td class="calibre52"><p class="author1">32,767</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1"><code class="calibre59">Uint16Array</code></p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">65,535</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1"><code class="calibre59">Int32Array</code></p></td>
<td class="calibre52"><p class="author1">4</p></td>
<td class="calibre52"><p class="author1">–2,147,483,648</p></td>
<td class="calibre52"><p class="author1">2,147,483,647</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1"><code class="calibre59">Uint32Array</code></p></td>
<td class="calibre52"><p class="author1">4</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">4294967295</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1"><code class="calibre59">Float32Array</code></p></td>
<td class="calibre52"><p class="author1">4</p></td>
<td class="calibre52"><p class="author1">1.4012984643e-45</p></td>
<td class="calibre52"><p class="author1">3.4028235e38</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1"><code class="calibre59">Float64Array</code></p></td>
<td class="calibre52"><p class="author1">8</p></td>
<td class="calibre52"><p class="author1">5e–324</p></td>
<td class="calibre52"><p class="author1">1.7976931348623157e308</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1"><code class="calibre59">BigInt64Array</code></p></td>
<td class="calibre52"><p class="author1">8</p></td>
<td class="calibre52"><p class="author1">–9,223,372,036,854,775,808</p></td>
<td class="calibre52"><p class="author1">9,223,372,036,854,775,807</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1"><code class="calibre59">BigUint64Array</code></p></td>
<td class="calibre52"><p class="author1">8</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">18,446,744,073,709,551,615</p></td>
</tr>
</tbody>
</table>

<p class="author1">The Class column is the name of the class that is available for instantiation. These classes are globals and are accessible in any modern JavaScript engine. The Bytes column is the number of bytes that are used to represent each individual element in the view. The Minimum Value and Maximum Value columns display the valid numeric ranges that can be used to represent an element in the buffer.</p>

<p class="author1">When creating one of these views, the <code class="calibre18">ArrayBuffer</code> instance <a data-type="indexterm" data-primary="ArrayBuffer" data-secondary="views and" id="idm45995920475704" class="calibre6"/><a data-type="indexterm" data-primary="views" data-secondary="ArrayBuffer object" id="idm45995920474696" class="calibre6"/>is passed into the 
<span class="keep-together">constructor</span> of the view. The buffer byte length must be a multiple of the element 
<span class="keep-together">byte length</span> used by the particular view that it’s being passed into. For example, if an 
<span class="keep-together"><code class="calibre18">ArrayBuffer</code></span> composed of 6 bytes were created, it is acceptable to pass that into an <code class="calibre18">Int16Array</code> (byte length of 2) because this will represent three <code class="calibre18">Int16</code> elements. However, the same 6-byte buffer cannot be passed into an <code class="calibre18">Int32Array</code> because it would represent one and a half elements, which isn’t valid.</p>

<p class="author1">The names of these views might be familiar if you’ve programmed with lower-level languages such as C or Rust.</p>

<p class="author1">The <code class="calibre18">U</code> prefix to half of these classes refers <a data-type="indexterm" data-primary="classes" data-secondary="U prefix" id="idm45995920468776" class="calibre6"/><a data-type="indexterm" data-primary="U prefix, classes" id="idm45995920467800" class="calibre6"/>to unsigned, which means that only positive numbers may be represented. Classes without the <code class="calibre18">U</code> prefix are signed and so negative and positive numbers may be represented, though with only half the maximum value. This is because a signed number uses the first bit to represent the “sign,” conveying if the number is positive or negative.</p>

<p class="author1">The numeric range limitations come <a data-type="indexterm" data-primary="numbers" data-secondary="range limitations" id="idm45995920465784" class="calibre6"/>from the amount of data that can be stored in a single byte to uniquely identify a number. Much like with decimal, numbers are counted from zero on up to the base, and then roll over to a number on the left. So, for a <code class="calibre18">Uint8</code> number, or an “unsigned integer represented by 8 bits,” the maximum value (<code class="calibre18">0b11111111</code>) is equal to 255.</p>

<p class="author1">JavaScript doesn’t have an <a data-type="indexterm" data-primary="JavaScript" data-secondary="Number type" id="idm45995920462968" class="calibre6"/><a data-type="indexterm" data-primary="Number type" id="idm45995920461992" class="calibre6"/>integer data type, only its <code class="calibre18">Number</code> type, which is an implementation of the <a href="https://oreil.ly/gOSK8" class="calibre6">IEEE 754 floating-point number</a>. It is equivalent to the <code class="calibre18">Float64</code> data type. Otherwise, any time a JavaScript <code class="calibre18">Number</code> is written to one of these views, some sort of conversion process needs to happen.</p>

<p class="author1">When a value is written to <code class="calibre18">Float64Array</code>, it can <a data-type="indexterm" data-primary="Float64Array" id="idm45995920458120" class="calibre6"/><a data-type="indexterm" data-primary="Float32Array" id="idm45995920457384" class="calibre6"/>be left mostly as the same. The minimum allowed value is the same as <code class="calibre18">Number.MIN_VALUE</code>, while the maximum is 
<span class="keep-together"><code class="calibre18">Number.MAX_VALUE</code></span>. When a value is written to a <code class="calibre18">Float32Array</code>, not only are the minimum and maximum value ranges reduced but the decimal precision will be truncated as well.</p>

<p class="author1">As an example of this, consider the following code:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">buffer</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">ArrayBuffer</code><code class="p">(</code><code class="mi">16</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">view64</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Float64Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>
<code class="nx">view64</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1.1234567890123456789</code><code class="p">;</code> <code class="c">// bytes 0 - 7</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">view64</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code> <code class="c">// 1.1234567890123457</code>

<code class="kr">const</code> <code class="nx">view32</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Float32Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>
<code class="nx">view32</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1.1234567890123456789</code><code class="p">;</code> <code class="c">// bytes 8 - 11</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">view32</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code> <code class="c">// 1.1234568357467651</code></pre>

<p class="author1">In this case, the decimal precision for the <code class="calibre18">float64</code> number is accurate to the 15th decimal, while the precision for the <code class="calibre18">float32</code> number is only accurate to the 6th 
<span class="keep-together">decimal</span>.</p>

<p class="author1">This code exemplifies another thing of interest. In this case, there is a single <code class="calibre18">ArrayBuffer</code> instance named <code class="calibre18">buffer</code>, and yet there are two different <code class="calibre18">TypedArray</code> instances that point to this buffer data. Can you think of what’s weird with this? <a data-type="xref" href="#fig_array_buffer" class="calibre6">Figure 4-1</a> might give you a hint.</p>

<figure class="calibre29"><div id="fig_array_buffer" class="figure">
<img src="Images/mtjs_0401.png" alt="Two TypedArray views pointing at a single ArrayBuffer" class="calibre60"/>
<h6 class="calibre30"><span class="keep-together">Figure 4-1. </span>Single <code class="calibre18">ArrayBuffer</code> and multiple <code class="calibre18">TypeArray</code> views</h6>
</div></figure>

<p class="author1">What do you think will be returned if you were to read either <code class="calibre18">view64[1]</code>, <code class="calibre18">view32[0]</code>, or <code class="calibre18">view32[1]</code>? In this case, a truncated version of the memory used to store data of one type will be combined, or split, to represent data of another type. The values returned are interpreted in the wrong way and are nonsensical, though they should be deterministic and consistent.</p>

<p class="author1">When numeric values that are outside of the range of the supported <code class="calibre18">TypedArray</code> for nonfloats are written, they need to go through some sort of conversion process to fit the target data type. First, the number must be converted <a data-type="indexterm" data-primary="numbers" data-secondary="converting to integers" id="idm45995920345960" class="calibre6"/><a data-type="indexterm" data-primary="integers" data-secondary="converting from numbers" id="idm45995920344984" class="calibre6"/>into an integer, as if it <a data-type="indexterm" data-primary="Math.trunc()" id="idm45995920343912" class="calibre6"/>were passed into <code class="calibre18">Math.trunc()</code>. If the value falls outside of the acceptable range, then it wraps around and resets at <code class="calibre18">0</code> as if using the modulus (<code class="calibre18">%</code>) operator. Here are some examples of this <a data-type="indexterm" data-primary="Uint8Array" id="idm45995920341752" class="calibre6"/>happening with a <code class="calibre18">Uint8Array</code> (which is a <code class="calibre18">TypedArray</code> with a max element value of 255):</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">buffer</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">ArrayBuffer</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>
<code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">255</code><code class="p">;</code>    <code class="nx">view</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="mi">256</code><code class="p">;</code>
<code class="nx">view</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="mi">257</code><code class="p">;</code>    <code class="nx">view</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
<code class="nx">view</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1.1</code><code class="p">;</code>    <code class="nx">view</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1.999</code><code class="p">;</code>
<code class="nx">view</code><code class="p">[</code><code class="mi">6</code><code class="p">]</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1.1</code><code class="p">;</code>   <code class="nx">view</code><code class="p">[</code><code class="mi">7</code><code class="p">]</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1.9</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">view</code><code class="p">);</code></pre>

<p class="author1"><a data-type="xref" href="#list_typedarray_conversion" class="calibre6">Table 4-3</a> contains a list of the values output on the second line, with their correlating values on the first line.</p>
<table id="list_typedarray_conversion" class="calibre46">
<caption class="calibre47"><span class="keep-together">Table 4-3. </span><code class="calibre58">TypedArray</code> conversions</caption>
<tbody class="calibre51">
<tr class="calibre49">
<td class="calibre52"><p class="author1">Input</p></td>
<td class="calibre52"><p class="author1">255</p></td>
<td class="calibre52"><p class="author1">256</p></td>
<td class="calibre52"><p class="author1">257</p></td>
<td class="calibre52"><p class="author1">–1</p></td>
<td class="calibre52"><p class="author1">1.1</p></td>
<td class="calibre52"><p class="author1">1.999</p></td>
<td class="calibre52"><p class="author1">–1.1</p></td>
<td class="calibre52"><p class="author1">–1.9</p></td>
</tr>
<tr class="calibre53">
<td class="calibre61"><p class="author1">Output</p></td>
<td class="calibre61"><p class="author1">255</p></td>
<td class="calibre61"><p class="author1">0</p></td>
<td class="calibre61"><p class="author1">1</p></td>
<td class="calibre61"><p class="author1">255</p></td>
<td class="calibre61"><p class="author1">1</p></td>
<td class="calibre61"><p class="author1">1</p></td>
<td class="calibre61"><p class="author1">255</p></td>
<td class="calibre61"><p class="author1">255</p></td>
</tr>
</tbody>
</table>

<p class="author1">This behavior is a <a data-type="indexterm" data-primary="Uint8ClampedArray" id="idm45995920200840" class="calibre6"/>little different for <code class="calibre18">Uint8ClampedArray</code>. When a negative value is written, it is converted into <code class="calibre18">0</code>. When a value greater than 255 is written, it’s converted into 255. When a noninteger value is provided, it’s instead passed to <code class="calibre18">Math.round()</code>. Depending on your use case, it may make more sense to use this view.</p>

<p class="author1">Finally, the <code class="calibre18">BigInt64Array</code> and <code class="calibre18">BigUint64Array</code> entries <a data-type="indexterm" data-primary="BigInt64Array" id="idm45995920196888" class="calibre6"/><a data-type="indexterm" data-primary="BigUint64Array" id="idm45995920196152" class="calibre6"/>also deserve some special attention. Unlike the other <code class="calibre18">TypedArray</code> views, which work with the <code class="calibre18">Number</code> type, these two variants work with <a data-type="indexterm" data-primary="BitInt type" id="idm45995920194488" class="calibre6"/><a data-type="indexterm" data-primary="integers" data-secondary="BigInt type" id="idm45995920193784" class="calibre6"/>the <code class="calibre18">BigInt</code> type (<code class="calibre18">1</code> is a <code class="calibre18">Number</code> while <code class="calibre18">1n</code> is a <code class="calibre18">BigInt</code>). This is because the numeric values that can be represented using 64 bytes fall out of the range of the numbers than can be represented using JavaScript’s <code class="calibre18">Number</code>. For that reason, setting a value with these views must be done with a <code class="calibre18">BigInt</code>, and the values retrieved will also be of type <code class="calibre18">BigInt</code>.</p>

<p class="author1">In general, using multiple <code class="calibre18">TypedArray</code> views, especially those of different sizes, to look into the same buffer instance is a dangerous thing and should be avoided when possible. You might find that you accidentally clobber some data when performing different operations. It is possible to pass more than one <code class="calibre18">SharedArrayBuffer</code> between threads, so if you find yourself needing to mix types, then you might benefit from having more than one buffer.</p>

<p class="author1">Now that you’re familiar with the basics of <code class="calibre18">ArrayBuffer</code> and <code class="calibre18">SharedArrayBuffer</code> you’re ready to <a data-type="indexterm" data-primary="shared memory" data-secondary="ArrayBuffer object" data-startref="sharArr" id="idm45995920186344" class="calibre6"/><a data-type="indexterm" data-primary="shared memory" data-secondary="SharedArrayBuffer" data-startref="sharshararr" id="idm45995920185064" class="calibre6"/>interact with them using a more complex API.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Atomic Methods for Data Manipulation" class="calibre4"><div class="preface" id="ch_shared_mem_sec_atomics">
<h1 class="calibre13">Atomic Methods for Data Manipulation</h1>

<p class="author1"><em class="calibre7">Atomicity</em> is a term that you might <a data-type="indexterm" data-primary="atomicity" id="idm45995920181656" class="calibre6"/>have heard before, particularly when it comes to databases, where it’s the first word in the acronym <a data-type="indexterm" data-primary="ACID (atomicity, consistency, isolation, durability)" id="idm45995920180712" class="calibre6"/>ACID (atomicity, consistency, isolation, durability). Essentially, if an <a data-type="indexterm" data-primary="atomicity" data-secondary="atomic operations" id="idm45995920179944" class="calibre6"/>operation is <em class="calibre7">atomic</em>, it means that while the overall operation may be composed of multiple smaller steps, the overall operation is guaranteed to either entirely succeed or entirely fail. For example, a single query sent to a database is going to be atomic, but three separate queries aren’t atomic.</p>

<p class="author1">Then again, if those three queries are wrapped in a database transaction, then the whole lot becomes atomic; either all three queries run successfully, or none run 
<span class="keep-together">successfully</span>. It’s also important that the operations are executed in a particular order, assuming they manipulate the same state or otherwise have any side effects than can affect each other. The <em class="calibre7">isolation</em> part means that other operations can’t run in the 
<span class="keep-together">middle</span>; for example, a read can’t occur when only some of the operations have been applied.</p>

<p class="author1">Atomic operations are very important in computing, especially when it comes to distributed computing. Databases, which may have many client connections, need to support atomic operations. Distributed systems, where many nodes on a network communicate, also need to support atomic operations. Extrapolating that idea a little, even within a single computer where data access is shared across multiple threads, atomicity is important.</p>

<p class="author1">JavaScript provides a <a data-type="indexterm" data-primary="Atomics object" id="idm45995920174056" class="calibre6"/><a data-type="indexterm" data-primary="objects" data-secondary="Atomics" id="idm45995920173320" class="calibre6"/>global object named <code class="calibre18">Atomics</code> with several static methods available on it. This global follows the same pattern as the familiar <code class="calibre18">Math</code> global. In either case you can’t use the <code class="calibre18">new</code> operator to create a new instance, and the available methods are stateless, not affecting the global itself. Instead, with <code class="calibre18">Atomics</code>, they’re used by passing in a reference to the data that is to be modified.</p>

<p class="author1">The rest of this section lists all but three of the methods that are available on the 
<span class="keep-together"><code class="calibre18">Atomics</code></span> object. The remaining methods are covered in <a data-type="xref" href="ch05.xhtml#ch_adv_shared_mem_sec_atomics" class="calibre6">“Atomic Methods for Coordination”</a>. With the exception of <code class="calibre18">Atomics.isLockFree()</code>, all of these <a data-type="indexterm" data-primary="Atomics object" data-secondary="TypedArray instance" id="idm45995920167640" class="calibre6"/><a data-type="indexterm" data-primary="TypedArray class" data-secondary="Atomics object" id="idm45995920166632" class="calibre6"/>methods accept a <code class="calibre18">TypedArray</code> instance as the first argument and the index to act upon as the second argument.</p>








<section data-type="sect2" data-pdf-bookmark="Atomics.add()" class="calibre4"><div class="preface" id="idm45995920165144">
<h2 class="calibre37">Atomics.add()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">old</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method adds the provided <code class="calibre18">value</code> to the existing value in a <code class="calibre18">typedArray</code> that is located at <code class="calibre18">index</code>. The old value is returned. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">old</code> <code class="o">+</code> <code class="nx">value</code><code class="p">;</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.and()" class="calibre4"><div class="preface" id="idm45995920074600">
<h2 class="calibre37">Atomics.and()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">old</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">and</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method performs a <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.and() method" id="idm45995920022568" class="calibre6"/>bitwise <code class="calibre18">and</code> using <code class="calibre18">value</code> with the existing value in <code class="calibre18">typedArray</code> located at <code class="calibre18">index</code>. The old value is returned. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">old</code> <code class="o">&amp;</code> <code class="nx">value</code><code class="p">;</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" class="calibre4" data-pdf-bookmark="Atomics.compareExchange()"><div class="preface" id="idm45995919969080">
<h2 class="calibre37">Atomics.compareExchange()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">old</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">compareExchange</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">oldExpectedValue</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method checks <code class="calibre18">typedArray</code> to <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.compareExchange() method" id="idm45995919939832" class="calibre6"/>see if the value <code class="calibre18">oldExpectedValue</code> is located at <code class="calibre18">index</code>. If it is, then the value is replaced with <code class="calibre18">value</code>. If not, then nothing happens. The old value is always returned, so you can tell if the exchange succeeded if <code class="calibre18">oldExpectedValue === old</code>. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="kr">if</code> <code class="p">(</code><code class="nx">old</code> <code class="o">===</code> <code class="nx">oldExpectedValue</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.exchange()" class="calibre4"><div class="preface" id="idm45995919976312">
<h2 class="calibre37">Atomics.exchange()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">old</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">exchange</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method sets the <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.exchange() method" id="idm45995919898824" class="calibre6"/>value in <code class="calibre18">typedArray</code> located at <code class="calibre18">index</code> to <code class="calibre18">value</code>. The old value is returned. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.isLockFree()" class="calibre4"><div class="preface" id="idm45995919881944">
<h2 class="calibre37">Atomics.isLockFree()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">free</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">isLockFree</code><code class="p">(</code><code class="nx">size</code><code class="p">)</code></pre>

<p class="author1">This method returns a <code class="calibre18">true</code> if <code class="calibre18">size</code> is a <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.isLockFree() method" id="idm45995919810376" class="calibre6"/>value that appears as the <code class="calibre18">BYTES_PER_ELEMENT</code> for any of the <code class="calibre18">TypedArray</code> subclasses (usually 1, 2, 4, 8), and a <code class="calibre18">false</code> if otherwise.<sup class="calibre39"><a data-type="noteref" id="idm45995919889496-marker" href="ch04.xhtml#idm45995919889496" class="calibre40">2</a></sup> If <code class="calibre18">true</code>, then using the <code class="calibre18">Atomics</code> methods will be quite fast using the current system’s hardware. If <code class="calibre18">false</code>, then the application might want to use a manual locking mechanism, like what is covered in <a data-type="xref" href="ch06.xhtml#ch_patterns_sec_basiclock" class="calibre6">“Mutex: A Basic Lock”</a>, especially if performance is the main concern.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.load()" class="calibre4"><div class="preface" id="idm45995919811176">
<h2 class="calibre37">Atomics.load()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">value</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">load</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">)</code></pre>

<p class="author1">This method returns <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.load() method" id="idm45995919772600" class="calibre6"/>the value in <code class="calibre18">typedArray</code> located at <code class="calibre18">index</code>. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.or()" class="calibre4"><div class="preface" id="idm45995919725336">
<h2 class="calibre37">Atomics.or()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">old</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">or</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method performs a <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.or() method" id="idm45995919707816" class="calibre6"/>bitwise <code class="calibre18">or</code> using <code class="calibre18">value</code> with the existing value in <code class="calibre18">typedArray</code> located at <code class="calibre18">index</code>. The old value is returned. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">old</code> <code class="o">|</code> <code class="nx">value</code><code class="p">;</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.store()" class="calibre4"><div class="preface" id="idm45995919638040">
<h2 class="calibre37">Atomics.store()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">value</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">store</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method stores the <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.store() method" id="idm45995919626680" class="calibre6"/>provided <code class="calibre18">value</code> in <code class="calibre18">typedArray</code> located at <code class="calibre18">index</code>. The <code class="calibre18">value</code> that was passed in is then returned. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
<code class="kr">return</code> <code class="nx">value</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.sub()" class="calibre4"><div class="preface" id="idm45995919587000">
<h2 class="calibre37">Atomics.sub()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">old</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">sub</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method subtracts the <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.sub() method" id="idm45995919513576" class="calibre6"/>provided <code class="calibre18">value</code> from the existing value in <code class="calibre18">typedArray</code> that is located at <code class="calibre18">index</code>. The old value is returned. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">old</code> <code class="o">-</code> <code class="nx">value</code><code class="p">;</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Atomics.xor()" class="calibre4"><div class="preface" id="idm45995919544824">
<h2 class="calibre37">Atomics.xor()</h2>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="nx">old</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">xor</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code></pre>

<p class="author1">This method performs <a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.xor() method" id="idm45995919437016" class="calibre6"/>a bitwise <code class="calibre18">xor</code> using <code class="calibre18">value</code> with the existing value in <code class="calibre18">typedArray</code> located at <code class="calibre18">index</code>. The old value is returned. Here’s what the nonatomic version might look like:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
<code class="nx">typedArray</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="nx">old</code> <code class="o">^</code> <code class="nx">value</code><code class="p">;</code>
<code class="kr">return</code> <code class="nx">old</code><code class="p">;</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Atomicity Concerns" class="calibre4"><div class="preface" id="ch_shared_mem_sec_atomicity">
<h1 class="calibre13">Atomicity Concerns</h1>

<p class="author1">The methods covered in <a data-type="xref" href="#ch_shared_mem_sec_atomics" class="calibre6">“Atomic Methods for Data Manipulation”</a> are each guaranteed to execute atomically. For example, consider the <code class="calibre18">Atomics.compareExchange()</code> method. This method <a data-type="indexterm" data-primary="atomicity" data-secondary="concerns" id="atomconc" class="calibre6"/>takes an <code class="calibre18">oldExpectedValue</code> and a new <code class="calibre18">value</code>, replacing the existing value only if it equals <code class="calibre18">oldExpectedValue</code> with the new <code class="calibre18">value</code>. While this operation would take several individual statements to represent with JavaScript, it’s guaranteed that the overall operation will always execute entirely.</p>

<p class="author1">To illustrate this, imagine you have a <code class="calibre18">Uint8Array</code> named <code class="calibre18">typedArray</code>, and the 0th 
<span class="keep-together">element</span> is set to 7. Then, imagine that multiple threads have access to that same 
<span class="keep-together"><code class="calibre18">typedArray</code></span>, and each of them executes some variant of the following line of code:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">let</code> <code class="nx">old1</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">compareExchange</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code> <code class="c">// Thread #1</code>
<code class="kr">let</code> <code class="nx">old2</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">compareExchange</code><code class="p">(</code><code class="nx">typedArray</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code> <code class="c">// Thread #2</code></pre>

<p class="author1">It’s entirely nondeterministic the order that these three methods are called in, or even the timing of their calls. In fact, they could be called simultaneously! However, 
<span class="keep-together">with the atomicity</span> guarantee of the <code class="calibre18">Atomics</code> object, it’s guaranteed that exactly one of the threads will have the initial <code class="calibre18">7</code> value returned, while the other thread will get the 
<span class="keep-together">updated</span> value of <code class="calibre18">1</code> or <code class="calibre18">2</code> returned.
A timeline of how these operations work can be seen in <a data-type="xref" href="#fig_cex_atomic" class="calibre6">Figure 4-2</a>, with the <code class="calibre18">CEX(oldExpectedValue, value)</code> being a shorthand for 
<span class="keep-together"><code class="calibre18">Atomics.compareExchange()</code></span>.</p>

<figure class="calibre29"><div id="fig_cex_atomic" class="figure">
<img src="Images/mtjs_0402.png" alt="Multiple calls to Atomics.compareExchange() are atomic." class="calibre62"/>
<h6 class="calibre30"><span class="keep-together">Figure 4-2. </span>Atomic form of <code class="calibre18">Atomics.compareExchange()</code></h6>
</div></figure>

<p class="author1">On the other hand, if you’re using the nonatomic equivalent of <code class="calibre18">compareExchange()</code>, such as reading and writing to <code class="calibre18">typedArray[0]</code> directly, it is entirely possible that the program will accidentally clobber a value. In this case both threads read the existing value at about the same time, then they both see that the original value is present, then they both write at about the same time. Here is an annotated version of the 
<span class="keep-together">nonatomic</span> <code class="calibre18">compareExchange()</code> code again:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">old</code> <code class="o">=</code> <code class="nx">typedArray</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code> <code class="c">// GET()</code>
<code class="kr">if</code> <code class="p">(</code><code class="nx">old</code> <code class="o">===</code> <code class="nx">oldExpectedValue</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">typedArray</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>   <code class="c">// SET(value)</code>
<code class="p">}</code></pre>

<p class="author1">This code performs multiple interactions with shared data, notably the line where the data is retrieved (labeled as <code class="calibre18">GET()</code>) and later where the data is later set (labeled as <code class="calibre18">SET(value)</code>). For this code to function properly it would need a guarantee that 
<span class="keep-together">other threads</span> aren’t able to read or write to the value while the code is running. This 
<span class="keep-together">guarantees</span> that only one thread gets exclusive access to shared resources is called a <em class="calibre7">critical section</em>.</p>

<p class="author1"><a data-type="xref" href="#fig_cex_not_atomic" class="calibre6">Figure 4-3</a> shows a timeline of how this code might run, as is, without the exclusive access guarantees.</p>

<figure class="calibre29"><div id="fig_cex_not_atomic" class="figure">
<img src="Images/mtjs_0403.png" alt="Nonatomic calls result in data loss." class="calibre63"/>
<h6 class="calibre30"><span class="keep-together">Figure 4-3. </span>Nonatomic form of <code class="calibre18">Atomics.compareExchange()</code></h6>
</div></figure>

<p class="author1">In this case both threads think they have successfully set the value, but the desired outcome only persists for the second thread. This class of bug is referred to as a <em class="calibre7">race condition</em>, where <a data-type="indexterm" data-primary="race condition" id="idm45995919271192" class="calibre6"/><a data-type="indexterm" data-primary="threads" data-secondary="race condition" id="idm45995919270456" class="calibre6"/>two or more threads are racing against each other to perform some action.<sup class="calibre39"><a data-type="noteref" id="idm45995919269384-marker" href="ch04.xhtml#idm45995919269384" class="calibre40">3</a></sup> The worst thing about these bugs is that they don’t happen consistently, are notoriously hard to reproduce, and may only happen in one environment, such as a production server, and not another environment, like your development laptop.</p>

<p class="author1">To benefit from the atomic properties of the <code class="calibre18">Atomics</code> object when interacting with an array buffer, you’ll <a data-type="indexterm" data-primary="Atomics object" data-secondary="buffers, direct array access" id="idm45995919267176" class="calibre6"/>need to take care when mixing <code class="calibre18">Atomics</code> calls with direct array buffer access. If one thread of your application is using the <code class="calibre18">compareExchange()</code> method, and another thread is directly reading and writing to the same buffer location, then the safety mechanisms will have been defeated and your application will have nondeterministic behavior. Essentially, when using <code class="calibre18">Atomics</code> calls, there’s an implicit lock in place to make interactions convenient.</p>

<p class="author1">Sadly, not all of the operations you’ll need to perform with shared memory can be represented using the <code class="calibre18">Atomics</code> methods. When that happens you’ll need to come up with a more manual locking mechanism, allowing you to read and write freely and preventing other threads from doing so. This concept is covered later in <a data-type="xref" href="ch06.xhtml#ch_patterns_sec_basiclock" class="calibre6">“Mutex: A Basic Lock”</a>.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre54"><div class="sidebar" id="idm45995919262616">
<h5 class="calibre55">Return Values Ignore Conversion</h5>
<p class="author1">One caveat concerning the <code class="calibre18">Atomics</code> methods <a data-type="indexterm" data-primary="Atomics object" data-secondary="return values, conversion and" id="idm45995919260760" class="calibre6"/>is that the returned values aren’t necessarily aware of the conversion that the particular <code class="calibre18">TypedArray</code> will go through, but instead consider the value <em class="calibre7">before</em> going through the conversion. For example, consider the following situation where a value is stored that is larger than what can be represented by the given view:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">buffer</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">ret</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">.</code><code class="nx">store</code><code class="p">(</code><code class="nx">view</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">999</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ret</code><code class="p">);</code> <code class="c">// 999</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code> <code class="c">// 231</code></pre>

<p class="author1">This code creates a buffer a<a data-type="indexterm" data-primary="Atomics object" data-secondary="Atomics.store() method" id="idm45995919208392" class="calibre6"/>nd then a <code class="calibre18">Uint8Array</code> view into that array. It then uses <code class="calibre18">Atomics.store()</code> to store the value <code class="calibre18">999</code> using the view. The return value from the <code class="calibre18">Atomics.store()</code> call is the value that was passed in, <code class="calibre18">999</code>, even though the value that was actually stored in the underlying buffer is the value <code class="calibre18">231</code> (999 is greater than the maximum supported 255). You will need to keep this limitation in mind when building your applications. To stay on the safe side, you should craft your application to not rely on this data conversion and only write values that are <a data-type="indexterm" data-primary="atomicity" data-secondary="concerns" data-startref="atomconc" id="idm45995919174408" class="calibre6"/>within range.</p>
</div></aside>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Data Serialization" class="calibre4"><div class="preface" id="ch_shared_mem_sec_serialize">
<h1 class="calibre13">Data Serialization</h1>

<p class="author1">Buffers are extremely powerful tools. That <a data-type="indexterm" data-primary="data serialization" id="idm45995919171256" class="calibre6"/>said, working with them from an entirely numeric point of view can start to get a little difficult. Sometimes you’ll need to store things that represent nonnumeric data using a buffer. When this happens you’ll need to serialize that data in some manner before writing it to the buffer, and you’ll later need to deserialize it when reading from the buffer.</p>

<p class="author1">Depending on the type of data that you’d like to represent, there will be different tools that you can use to serialize it. Some tools will work for different situations, but 
<span class="keep-together">each comes</span> with different trade-offs with regard to storage size and serialization 
<span class="keep-together">performance</span>.</p>








<section data-type="sect2" data-pdf-bookmark="Booleans" class="calibre4"><div class="preface" id="idm45995919167960">
<h2 class="calibre37">Booleans</h2>

<p class="author1">Booleans are easy to represent <a data-type="indexterm" data-primary="data serialization" data-secondary="booleans and" id="idm45995919166200" class="calibre6"/><a data-type="indexterm" data-primary="booleans, data serialization and" id="idm45995919165224" class="calibre6"/>because they take a single bit to store the data, and a bit is less than a byte. So you can then create one of the smallest views, such as a <code class="calibre18">Uint8Array</code>, then point it at an <code class="calibre18">ArrayBuffer</code> with a byte length of 1, and be set. Of course, the interesting thing here is that you can then store up to eight of these booleans using a single byte. In fact, if you’re dealing with a ton of boolean values, you might be able to outperform the JavaScript engine by storing large numbers of them in a buffer since there is additional metadata overhead for each boolean instance. <a data-type="xref" href="#fig_serialize_booleans" class="calibre6">Figure 4-4</a> shows a list of booleans represented as a byte.</p>

<figure class="calibre29"><div id="fig_serialize_booleans" class="figure">
<img src="Images/mtjs_0404.png" alt="Bits are ordered from right to left" class="calibre64"/>
<h6 class="calibre30"><span class="keep-together">Figure 4-4. </span>Boolean values stored in a byte</h6>
</div></figure>

<p class="author1">When storing data in individual bits like this, it’s best to start with the least significant bit, e.g., the bit farthest to the right labeled 0, then move on to more significant bits if you find yourself adding more booleans to the byte that you’re storing them in. The reason for this is simple: as the number of booleans you need to store grows, so too will the size of the buffer, and existing bit locations should remain correct. While the buffer itself can’t grow dynamically, newer releases of your application might need to instantiate large buffers.</p>

<p class="author1">If the buffer that <a data-type="indexterm" data-primary="data serialization" data-secondary="booleans and" data-tertiary="buffers" id="idm45995919158872" class="calibre6"/><a data-type="indexterm" data-primary="booleans, data serialization and" data-secondary="buffers" id="idm45995919157592" class="calibre6"/><a data-type="indexterm" data-primary="buffers" data-secondary="booleans" id="idm45995919156584" class="calibre6"/>stores the booleans is today 1 byte, and tomorrow 2 bytes, by using the least significant digits first the decimal representation of the data will remain either a 0 or a 1. However, if the most significant digit were used, then today the value might be 0 and 128, while tomorrow it might be 32,768 and 0. This could potentially cause issues if you’re persisting these values somewhere and using them between releases.</p>

<p class="author1">The following is an example of how to store and retrieve these boolean values so that they’re backed in an <code class="calibre18">ArrayBuffer</code>:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">buffer</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">ArrayBuffer</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>
<code class="kr">function</code> <code class="nx">setBool</code><code class="p">(</code><code class="nx">slot</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">&amp;</code> <code class="o">~</code><code class="p">(</code><code class="mi">1</code> <code class="o">&lt;&lt;</code> <code class="nx">slot</code><code class="p">))</code> <code class="o">|</code> <code class="p">((</code><code class="nx">value</code><code class="o">|</code><code class="mi">0</code><code class="p">)</code> <code class="o">&lt;&lt;</code> <code class="nx">slot</code><code class="p">);</code>
<code class="p">}</code>
<code class="kr">function</code> <code class="nx">getBool</code><code class="p">(</code><code class="nx">slot</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">return</code> <code class="o">!</code><code class="p">((</code><code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">&amp;</code> <code class="p">(</code><code class="mi">1</code> <code class="o">&lt;&lt;</code> <code class="nx">slot</code><code class="p">))</code> <code class="o">===</code> <code class="mi">0</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">This code creates a one-byte buffer (<code class="calibre18">0b00000000</code> in binary) then creates a view into the buffer. To set the value in the least significant digit in the <code class="calibre18">ArrayBuffer</code> to true, you would use the call <code class="calibre18">setBool(0, true)</code>. To set the second least significant digit to false, you would call <code class="calibre18">setBool(1, false)</code>. To retrieve the values stored at the third least significant digit, you would then call <code class="calibre18">getBool(2)</code>.</p>

<p class="author1">The <code class="calibre18">setBool()</code> function works <a data-type="indexterm" data-primary="data serialization" data-secondary="booleans and" data-tertiary="setBool() function" id="idm45995919050264" class="calibre6"/><a data-type="indexterm" data-primary="booleans, data serialization and" data-secondary="setBool() function" id="idm45995919048328" class="calibre6"/><a data-type="indexterm" data-primary="setBool() function" id="idm45995919047416" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="setBool()" id="idm45995919046744" class="calibre6"/>by taking the boolean <code class="calibre18">value</code> and converting it into an integer (<code class="calibre18">value|0</code> converts <code class="calibre18">false</code> to 0 and <code class="calibre18">true</code> to 1). Then it “shifts the value left” by adding zeros to the right based on which <code class="calibre18">slot</code> to store it in (<code class="calibre18">0b1&lt;&lt;0</code> stays <code class="calibre18">0b1</code>, <code class="calibre18">0b1&lt;&lt;1</code> becomes <code class="calibre18">0b10</code>, etc.). It also takes the number 1 and shifts it based on the <code class="calibre18">slot</code> (so <code class="calibre18">0b1000</code> if the <code class="calibre18">slot</code> is 3), then inverts the bits (using <code class="calibre18">~</code>), and gets a new value by AND-ing (<code class="calibre18">&amp;</code>) the existing value with this new value (<code class="calibre18">view[0] &amp; ~(1 &lt;&lt; slot)</code>). Finally, the modified old value and the new shifted values are OR-ed together (<code class="calibre18">|</code>) and assigned to <code class="calibre18">view[0]</code>. Basically, it reads the existing bits, replaces the appropriate bit, and writes the bits back.</p>

<p class="author1">The <code class="calibre18">getBool()</code> function <a data-type="indexterm" data-primary="data serialization" data-secondary="booleans and" data-tertiary="getBool() function" id="idm45995919037432" class="calibre6"/><a data-type="indexterm" data-primary="booleans, data serialization and" data-secondary="getBool() function" id="idm45995919036152" class="calibre6"/><a data-type="indexterm" data-primary="getBool() function" id="idm45995919035240" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="getBool()" id="idm45995919034568" class="calibre6"/>works by taking the number 1, shifting it based on the slot, then using <code class="calibre18">&amp;</code> to compare it to the existing value. The shifted value (on the right of <code class="calibre18">&amp;</code>) only contains a single 1 and seven 0s. The AND-ing between this modified value and the existing value returns either a number representing the value of the shifted slot, assuming the value at the <code class="calibre18">slot</code> position located at <code class="calibre18">view[0]</code> was truthy; otherwise, it returns 0. This value is then checked to see if it is exactly equal to 0 (<code class="calibre18">===0</code>), and the result of that is negated (<code class="calibre18">!</code>). Basically, it returns the value of the bit at <code class="calibre18">slot</code>.</p>

<p class="author1">This code has some shortcomings and shouldn’t necessarily be used in production. For example, it isn’t meant for working with buffers that are larger than a single byte, and you’ll encounter undefined behavior when reading or writing to entries past 7. A production-ready version would consider the size of storage and do bounds checking, but that’s an exercise left to the reader.</p>
</div></section>













<section data-type="sect2" class="calibre4" data-pdf-bookmark="Strings"><div class="preface" id="idm45995919167304">
<h2 class="calibre37">Strings</h2>

<p class="author1">Strings aren’t as easy to encode as <a data-type="indexterm" data-primary="data serialization" data-secondary="strings" data-startref="datstring" id="idm45995919027736" class="calibre6"/><a data-type="indexterm" data-primary="strings" data-secondary="data serialization and" data-startref="strdat" id="idm45995919026488" class="calibre6"/>they may seem at first glance. It’s easy to assume that each character in a string can be represented using a single byte, and that the <code class="calibre18">.length</code> property of a string is sufficient to choose the size of a buffer to store it in. While this may seem to work sometimes, particularly with simple strings, you’ll soon encounter errors when dealing with more complex data.</p>

<p class="author1">The reason this will work with simple strings is that data represented using ASCII does allow a single character to fit into a single byte. In fact, in the C programming language, the data storage type that represents a single byte of data is referred to as a <code class="calibre18">char</code>.</p>

<p class="author1">There are many ways to encode individual characters using strings. With ASCII the entire range of characters can be represented with a byte, but in a world of many cultures, languages, and emojis, it’s absolutely impossible to represent all these characters in such a manner. Instead, we use encoding systems where a variable number of bytes can be used to represent a single character. Internally, JavaScript engines use a variety of encoding formats to represent strings depending on the situation, and the complexity of this is hidden from our applications. One possible internal format is UTF-16, which uses 2 or 4 bytes to represent a character, or even up to 14 bytes to represent certain emojis. A more universal standard is UTF-8, which uses 1 to 4 bytes of storage per character and is backwards compatible with ASCII.</p>

<p class="author1">The following is an example of what happens when a string is iterated using its <code class="calibre18">.length</code> property and the resulting values are mapped to a <code class="calibre18">Uint8Array</code> instance:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="c">// Warning: Antipattern!</code>
<code class="kr">function</code> <code class="nx">stringToArrayBuffer</code><code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">buffer</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">ArrayBuffer</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">buffer</code><code class="p">);</code>
  <code class="kr">for</code> <code class="p">(</code><code class="kr">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">str</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">view</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">str</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kr">return</code> <code class="nx">view</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">stringToArrayBuffer</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// Uint8Array(3) [ 102, 111, 111 ]</code>
<code class="nx">stringToArrayBuffer</code><code class="p">(</code><code class="s">'€'</code><code class="p">);</code>   <code class="c">// Uint8Array(1) [ 172 ]</code></pre>

<p class="author1">In this case storing the basic string <code class="calibre18">foo</code> is fine. However, the <code class="calibre18">€</code> character, which is really represented by the value 8,364, is greater than the maximum 255 value supported by <code class="calibre18">Uint8Array</code> and has accordingly been truncated to 172. Converting that number back into a character gives the wrong value.</p>

<p class="author1">An API is available to modern JavaScript for encoding and decoding strings directly to <code class="calibre18">ArrayBuffer</code> instances. This API is <a data-type="indexterm" data-primary="ArrayBuffer" data-secondary="strings and" id="idm45995918909640" class="calibre6"/><a data-type="indexterm" data-primary="strings" data-secondary="ArrayBuffer" id="idm45995918908664" class="calibre6"/><a data-type="indexterm" data-primary="TextDecoder, strings" id="idm45995918907720" class="calibre6"/><a data-type="indexterm" data-primary="strings" data-secondary="TextEncoder" id="idm45995918907048" class="calibre6"/>provided by the globals <code class="calibre18">TextEncoder</code> and <code class="calibre18">TextDecoder</code>, both of which are constructors and are globally available in modern JavaScript environments including browsers and Node.js. These APIs encode and decode using the UTF-8 encoding due to its ubiquity.</p>

<p class="author1">Here’s an example of how to safely encode strings into the UTF-8 encoding using this API:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">enc</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">TextEncoder</code><code class="p">();</code>
<code class="nx">enc</code><code class="p">.</code><code class="nx">encode</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// Uint8Array(3) [ 102, 111, 111 ]</code>
<code class="nx">enc</code><code class="p">.</code><code class="nx">encode</code><code class="p">(</code><code class="s">'€'</code><code class="p">);</code>   <code class="c">// Uint8Array(3) [ 226, 130, 172 ]</code></pre>

<p class="author1">And here’s how to decode such values:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">ab</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">ArrayBuffer</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">view</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">ab</code><code class="p">);</code>
<code class="nx">view</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">226</code><code class="p">;</code> <code class="nx">view</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="mi">130</code><code class="p">;</code> <code class="nx">view</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="mi">172</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">dec</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">TextDecoder</code><code class="p">();</code>
<code class="nx">dec</code><code class="p">.</code><code class="nx">decode</code><code class="p">(</code><code class="nx">view</code><code class="p">);</code> <code class="c">// '€'</code>
<code class="nx">dec</code><code class="p">.</code><code class="nx">decode</code><code class="p">(</code><code class="nx">ab</code><code class="p">);</code>   <code class="c">// '€'</code></pre>

<p class="author1">Notice that <code class="calibre18">TextDecoder#decode()</code> works with either the <code class="calibre18">Uint8Array</code> view, or with the underlying <code class="calibre18">ArrayBuffer</code> instance. This makes it convenient to decode data that you might get from a network call without <a data-type="indexterm" data-primary="data serialization" data-secondary="strings" data-startref="datstring" id="idm45995918761336" class="calibre6"/><a data-type="indexterm" data-primary="strings" data-secondary="data serialization and" data-startref="strdat" id="idm45995918760200" class="calibre6"/>the need to first wrap it in a view.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Objects" class="calibre4"><div class="preface" id="idm45995919029080">
<h2 class="calibre37">Objects</h2>

<p class="author1">Considering that objects can already be <a data-type="indexterm" data-primary="data serialization" data-secondary="objects" id="idm45995918757320" class="calibre6"/><a data-type="indexterm" data-primary="objects" data-secondary="data serialization and" id="idm45995918756344" class="calibre6"/>represented as strings using JSON, you do have the option of taking an object that you’d like to make use of across two threads, serializing it into a JSON string, and writing that string to an array buffer using the same <code class="calibre18">TextEncoder</code> API that you worked with in the previous section. This can essentially be performed by running the following code:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="kr">const</code> <code class="nx">enc</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">TextEncoder</code><code class="p">();</code>
<code class="kr">return</code> <code class="nx">enc</code><code class="p">.</code><code class="nx">encode</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">obj</code><code class="p">));</code></pre>

<p class="author1">JSON takes a JavaScript object and converts it into a string representation. When this happens, there are many redundancies in the output format. If you wanted to reduce the size of a payload even more, you could make use of a format like <a href="https://msgpack.org" class="calibre6">MessagePack</a>, which is able to reduce the size of a serialized object even more by representing object metadata using binary data. This makes tools like MessagePack not necessarily a good fit in situations where plain text is appropriate, like an email, but in situations where binary buffers are passed around it might not be as bad. The <code class="calibre18">msgpack5</code> npm package is a browser and Node.js compatible <a data-type="indexterm" data-primary="Node.js" data-secondary="msgpack5" id="idm45995918716728" class="calibre6"/><a data-type="indexterm" data-primary="msgpack5 npm package" id="idm45995918715816" class="calibre6"/><a data-type="indexterm" data-primary="npm packages" data-secondary="msgpack5" id="idm45995918715144" class="calibre6"/>package for doing just that.</p>

<p class="author1">That said, the performance trade-offs when communicating between threads is not usually due to the size of the payload being transferred, but is more than likely due to the cost of serializing and deserializing payloads. For that reason it’s usually better to pass simpler data representations between threads. Even when it comes to passing objects between threads, you might find that the structured clone algorithm, combined with the <code class="calibre18">.onmessage</code> and <code class="calibre18">.postMessage</code> methods, is going to be faster and safer than serializing objects and writing them to buffers.</p>

<p class="author1">If you do find yourself building an application that serializes and deserializes objects and writes them to a <code class="calibre18">SharedArrayBuffer</code>, you might want to reconsider some of the architecture of the application. You’re almost always better off finding a way to take objects that you’re passing around, serializing them using lower-level types, and passing those along instead.</p>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre41"><p data-type="footnote" id="idm45995921045144" class="calibre42"><sup class="calibre43"><a href="ch04.xhtml#idm45995921045144-marker" class="calibre40">1</a></sup> This restriction may change in the future; see <a href="https://oreil.ly/im1CV" class="calibre6">“In-Place Resizable and Growable ArrayBuffers”</a> for a proposal.</p><p data-type="footnote" id="idm45995919889496" class="calibre42"><sup class="calibre43"><a href="ch04.xhtml#idm45995919889496-marker" class="calibre40">2</a></sup> If running JavaScript on rare hardware, it is possible that this method may return a <code class="calibre18">false</code> for 1, 2, or 8. That said, 4 will always return <code class="calibre18">true</code>.</p><p data-type="footnote" id="idm45995919269384" class="calibre42"><sup class="calibre43"><a href="ch04.xhtml#idm45995919269384-marker" class="calibre40">3</a></sup> It’s possible, with the way code is compiled, ordered, and executed, that a racy program can fail in a way that can’t be explained by this diagram of interleaving steps. When this happens you may end up with a value that defies all expectations.</p></div></div></section></div></body></html>