- en: Chapter 2\. Running Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 运行运算符
- en: In the first section of this chapter we outline the requirements for running
    the examples in this book, and offer advice on how to establish access to a Kubernetes
    cluster that satisfies those requirements. In the second section, you’ll use that
    cluster to investigate what Operators do by installing and using one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节中，我们概述了运行本书示例的要求，并提供建议，说明如何建立符合这些要求的 Kubernetes 集群访问权限。在第二节中，您将使用该集群安装和使用运算符，了解运算符的功能。
- en: By the end, you’ll have a Kubernetes cluster to use as an Operator test bed,
    and you’ll know how to deploy an existing Operator on it from a set of manifests.
    You’ll also have seen an Operator managing its application’s specific internal
    state in the face of changes and failures, informing your understanding of the
    Operator architecture and build tools presented in succeeding chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，您将拥有一个 Kubernetes 集群作为运算符测试基地，并且将知道如何从一组清单中在其上部署现有的运算符。您还将看到一个运算符在面对变化和故障时管理其应用程序特定内部状态的示例，这将增强您对运算符架构和后续章节中介绍的构建工具的理解。
- en: Setting Up an Operator Lab
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置运算符实验室
- en: To build, test, and run Operators in the following chapters, you’ll need `cluster-admin`
    access to a cluster running Kubernetes version v1.11.0 or later. If you’ve already
    met these requirements, you can skip ahead to the next section. In this section
    we offer general advice to readers who need to set up a Kubernetes cluster, or
    who need a local environment for Operator development and testing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要在以下章节中构建、测试和运行运算符，您需要`cluster-admin`访问权限，访问运行 Kubernetes 版本 v1.11.0 或更高版本的集群。如果您已经满足这些要求，可以直接跳到下一节。在本节中，我们为需要设置
    Kubernetes 集群或需要运算符开发和测试的本地环境的读者提供一般建议。
- en: Cluster Version Requirements
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群版本要求
- en: We’ve tested the examples in this book with Kubernetes releases v1.11 up to
    v1.16\. We will state when any feature or action we examine requires a release
    later than v1.11.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了本书中的示例，涵盖 Kubernetes 版本 v1.11 到 v1.16。当我们检查的任何功能或操作需要比 v1.11 更高版本时，我们将声明。
- en: Control plane extensibility
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制平面的可扩展性
- en: Kubernetes version 1.2 introduced the API extension mechanism known as the CRD
    in elemental form as the *third party resource* (TPR). Since then, the components
    Operators build on have multiplied and matured, as illustrated in [Figure 2-1](#fig2-1).
    CRDs were formalized with the Kubernetes version 1.7 release.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 1.2 版本引入了 API 扩展机制，被称为*第三方资源*（TPR），基本形式是[图 2-1](#fig2-1)中所示。自那时起，构建运算符的组件已经多样化和成熟化。CRD
    在 Kubernetes 1.7 版本中正式化。
- en: '![Figure 2-1: Extensibility Features per Kubernetes Release](assets/kuop_0201.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图 2-1: Kubernetes 发布的可扩展性功能](assets/kuop_0201.png)'
- en: Figure 2-1\. Extensibility features per Kubernetes release
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. Kubernetes 发布的可扩展性功能
- en: 'As you saw in [Chapter 1](ch01.html#chapter_introduction), a CRD is the definition
    of a new, site-specific resource (or API endpoint) in the Kubernetes API of a
    particular cluster. CRDs are one of two essential building blocks for the most
    basic description of the Operator pattern: a custom controller managing CRs.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第一章](ch01.html#chapter_introduction)中所看到的，CRD 是特定集群 Kubernetes API 中新的、特定站点资源（或
    API 端点）的定义。CRD 是运算符模式的两个基本构建块之一：一个自定义控制器管理 CR。
- en: Authorization Requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权要求
- en: Since Operators extend Kubernetes itself, you’ll need privileged, cluster-wide
    access to a Kubernetes cluster to deploy them, such as the common `cluster-admin`
    cluster role.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运算符扩展了 Kubernetes 本身，您需要拥有特权的、整个集群范围的 Kubernetes 访问权限来部署它们，例如常见的`cluster-admin`集群角色。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Less privileged users can use the services and applications that Operators manage—the
    “operands.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 较低权限的用户可以使用运算符管理的服务和应用程序——“操作数”。
- en: While you should configure more granular Kubernetes Role-Based Access Control
    (RBAC) for production scenarios, having complete control of your cluster means
    you’ll be able to deploy CRDs and Operators immediately. You’ll also have the
    power to declare more detailed RBAC as you develop the roles, service accounts,
    and bindings for your Operators and the applications they manage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在生产环境中应配置更精细的 Kubernetes 基于角色的访问控制（RBAC），但完全控制您的集群意味着您可以立即部署 CRD 和运算符。随着您开发运算符及其管理的应用程序的角色、服务帐户和绑定，您还将有权声明更详细的
    RBAC。
- en: 'You can ask the Kubernetes API about the `cluster-admin` role to see if it
    exists on your cluster. The following shell excerpt shows how to get a summary
    of the role with the `kubectl`’s `describe` subcommand:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以询问 Kubernetes API 关于 `cluster-admin` 角色是否存在于您的集群中。以下 shell 摘录显示了如何使用`kubectl`的`describe`子命令获取角色的摘要：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#comarker1)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#comarker1)'
- en: 'The RBAC `cluster-admin` ClusterRole: anything goes.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC `cluster-admin` ClusterRole：任何事情都可以。
- en: Standard Tools and Techniques
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准工具和技术
- en: Operators aim to make the complex applications they manage first-class citizens
    of the Kubernetes API. We show what that means in the following chapters’ examples.
    At this stage, it means that a recent version of the command-line Kubernetes API
    tool, `kubectl`, is the only requirement for deploying and interacting with basic
    Operators on your cluster.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运营商旨在使其管理的复杂应用程序成为 Kubernetes API 的一级公民。我们将在后续章节的示例中展示这意味着什么。在此阶段，这意味着部署和与集群上的基本运营商交互的唯一要求是使用最新版本的命令行
    Kubernetes API 工具`kubectl`。
- en: Readers who need to install or update `kubectl` should consult the [current
    kubectl documentation](https://oreil.ly/ke6KM).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要安装或更新`kubectl`的读者应参考[当前的 kubectl 文档](https://oreil.ly/ke6KM)。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Users of the Red Hat OpenShift Kubernetes distribution (described below) may
    optionally (and interchangeably) use the `oc` OpenShift API utility in place of
    `kubectl`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Red Hat OpenShift Kubernetes 分发的用户（如下所述），可以选择（并可以互换地）使用`oc` OpenShift API
    实用程序代替`kubectl`。
- en: Suggested Cluster Configurations
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建议的集群配置
- en: There are many ways to run a Kubernetes cluster where you can deploy Operators.
    As mentioned previously, if you are already running a recent Kubernetes version,
    you can skip past this advice and on to [“Running a Simple Operator”](#running_a_simple_operator).
    If you aren’t, we have tested the Kubernetes packagings or distributions described
    in this section enough to expect they will support the exercises in this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以部署运营商的 Kubernetes 集群中，有许多方法。如前所述，如果你已经在运行最新的 Kubernetes 版本，则可以跳过这些建议，直接进入[“运行一个简单的运营商”](#running_a_simple_operator)。如果没有，我们已经测试了本节描述的
    Kubernetes 打包或分发版本，足以支持本书中的练习。
- en: Minikube
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minikube
- en: '[Minikube v1.5.2](https://oreil.ly/dBPzK) deploys Kubernetes v1.16.2\. It runs
    a single-node Kubernetes cluster in a virtual machine (VM) on your local system’s
    hypervisor. By default, Minikube expects to use VirtualBox because of its wide
    availability, but with a few extra steps it can also use your platform’s native
    hypervisor, like KVM on Linux, Hyper-V on Windows, or HyperKit and Hypervisor.framework
    on macOS. We avoid detailed installation instructions here, because they are better
    left to the [Minikube documentation](https://oreil.ly/eRZpQ). We have tested the
    examples in this book most thoroughly with Minikube, and for reasons of convenience
    and cost we are recommending that you start your Operator experiments with a local
    environment like it, CodeReady Containers (see the next section), or with [Kubernetes
    in Docker (kind)](https://oreil.ly/2y6PD).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[Minikube v1.5.2](https://oreil.ly/dBPzK) 部署 Kubernetes v1.16.2。它在您本地系统的虚拟机（VM）上运行单节点
    Kubernetes 集群的超级处理器。默认情况下，Minikube 期望使用 VirtualBox，因为其广泛可用，但通过几个额外步骤，它也可以使用您平台的本机超级处理器，如
    Linux 上的 KVM，Windows 上的 Hyper-V，或 macOS 上的 HyperKit 和 Hypervisor.framework。我们在这里避免详细的安装说明，因为这些最好留给[Minikube
    文档](https://oreil.ly/eRZpQ)。我们已经通过 Minikube 最彻底地测试了本书中的示例，并且基于便利性和成本的考虑，我们建议您使用类似的本地环境，如
    CodeReady Containers（请参阅下一节），或者使用[Kubernetes in Docker (kind)](https://oreil.ly/2y6PD)。'
- en: Red Hat OpenShift
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Red Hat OpenShift
- en: OpenShift is Red Hat’s distribution of Kubernetes. Anything you can do on Kubernetes,
    you can do on OpenShift of an equivalent core version. (There are also OpenShift-specific
    features built atop Kubernetes, but those are beyond the scope of this book.)
    OpenShift version 4 provides a full-featured Kubernetes distribution that is itself
    designed, delivered, and managed using Operators. It’s a “self-hosted” Kubernetes,
    capable of performing in-place platform upgrades without incurring downtime for
    hosted workloads. OpenShift includes Operator Lifecycle Manager, described in
    [Chapter 4](ch04.html#the_operator_framework), and a graphical interface to the
    Operator Catalog distribution mechanism out of the box.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift是Red Hat的Kubernetes发行版。您可以在OpenShift上进行与等效核心版本的Kubernetes相同的操作。（OpenShift还内置了一些基于Kubernetes的特定功能，但这超出了本书的范围。）OpenShift版本4提供了一个全功能的Kubernetes发行版，它本身使用Operators进行设计、交付和管理。它是一个“自托管”的Kubernetes，能够在不影响托管工作负载的情况下执行原地平台升级。OpenShift包括Operator生命周期管理器，详见[第4章](ch04.html#the_operator_framework)，以及一个操作员目录分发机制的图形界面。
- en: You can deploy a fully fledged OpenShift v4 cluster on Amazon Web Services (AWS),
    Microsoft Azure, or Google Cloud Platform with a free trial license by visiting
    Red Hat’s [*https://try.openshift.com*](https://try.openshift.com).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问Red Hat的免费试用许可证，部署完整的OpenShift v4集群到Amazon Web Services（AWS）、Microsoft
    Azure或Google Cloud Platform，网址为[*https://try.openshift.com*](https://try.openshift.com)。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To run OpenShift on your laptop, take a look at Minikube’s equivalent, [Red
    Hat CodeReady Containers](https://github.com/code-ready/crc).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的笔记本上运行OpenShift，请查看Minikube的等效工具，[Red Hat CodeReady Containers](https://github.com/code-ready/crc)。
- en: Checking Your Cluster Version
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查您的集群版本
- en: 'Verify that your cluster is running Kubernetes version v1.11 or later by running
    `kubectl version`. This command will return one API version string for your `kubectl`
    binary and a second version string for the cluster to which it is connecting:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`kubectl version`命令验证您的集群是否运行在Kubernetes v1.11或更高版本。该命令将为您的`kubectl`二进制文件返回一个API版本字符串，并为其连接的集群返回第二个版本字符串：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding output, both client and server are running Kubernetes version
    1.16.2\. While [a `kubectl` client up to one release behind the server should
    work](https://oreil.ly/I7K1e), for simplicity, you should make sure your client
    and server minor versions match. If you have v1.11 or later, you’re ready to start
    experimenting with Operators.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，客户端和服务器均运行Kubernetes版本1.16.2。虽然[a `kubectl`客户端在服务器上的一次更新之后应该能正常工作](https://oreil.ly/I7K1e)，为简单起见，确保您的客户端和服务器次要版本匹配。如果您有v1.11或更高版本，则可以开始尝试使用Operators。
- en: Running a Simple Operator
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行一个简单的Operator
- en: Once you’ve verified that you have privileged access to a Kubernetes cluster
    of a compatible version, you’re ready to deploy an Operator and see what Operators
    can do. You’ll see the skeleton of this same procedure again later, when you deploy
    and test the Operator you build. The etcd Operator’s straightforward automation
    of recovery and upgrades shows the principles and goals of Kubernetes Operators
    in action.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证您具有兼容版本的Kubernetes集群的特权访问权限，您就可以部署一个Operator并查看Operators的功能。稍后，您将再次看到相同过程的框架，当您部署和测试构建的Operator时。etcd
    Operator通过简单的自动化恢复和升级展示了Kubernetes Operators的原理和目标。
- en: A Common Starting Point
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个常见的起点
- en: '[etcd](https://github.com/coreos/etcd) is a distributed key-value store with
    roots at CoreOS, now under the auspices of the Cloud Native Computing Foundation.
    It is the underlying data store at the core of Kubernetes, and a key piece of
    several distributed applications. etcd provides reliable storage by implementing
    a protocol called [Raft](https://raft.github.io/) that guarantees consensus among
    a quorum of members.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[etcd](https://github.com/coreos/etcd)是一个分布式键值存储，起源于CoreOS，现在由Cloud Native
    Computing Foundation管理。它是Kubernetes核心下的基础数据存储，并且是几个分布式应用程序的关键部分。etcd通过实现一种称为[Raft](https://raft.github.io/)的协议来提供可靠的存储，保证了多数成员之间的一致性。'
- en: The etcd Operator often serves as a kind of “Hello World” example of the value
    and mechanics of the Operator pattern, and we follow that tradition here. We return
    to it because the most basic use of etcd is not difficult to illustrate, but etcd
    cluster setup and administration require exactly the kind of application-specific
    know-how you can bake into an Operator. To use etcd, you *put* keys and values
    in, and *get* them back out by name. Creating a reliable etcd cluster of the minimum
    three or more nodes requires configuration of endpoints, auth, and other concerns
    usually left to an etcd expert (or their collection of custom shell scripts).
    Keeping etcd running and upgraded over time requires continued administration.
    The etcd Operator knows how to do all of this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: etcd操作员通常作为操作员模式的价值和机制的“Hello World”示例，我们在这里遵循这一传统。我们之所以回到它，是因为展示etcd的最基本用法并不难，但etcd集群的设置和管理需要精通特定应用程序知识的操作员。要使用etcd，您可以通过名称*put*键和值，并通过名称*get*它们。创建一个可靠的最小三个或更多节点的etcd集群需要配置端点、认证和其他通常留给etcd专家（或其自定义shell脚本集合）的问题。随着时间的推移保持etcd的运行和升级需要持续的管理。etcd操作员知道如何做到这一点。
- en: In the sections that follow, you’ll deploy the etcd Operator, then have it create
    an etcd cluster according to your specifications. You will have the Operator recover
    from failures and perform a version upgrade while the etcd API continues to service
    read and write requests, showing how an Operator automates the lifecycle of a
    piece of foundation software.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将部署etcd操作员，然后让它根据您的规范创建etcd集群。您将让操作员从故障中恢复并执行版本升级，同时etcd API继续服务读写请求，展示了操作员如何自动化基础软件的生命周期。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can follow this example on a running OpenShift cluster without doing any
    setup at the [OpenShift learning portal](https://oreil.ly/j-xKh).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在运行的OpenShift集群上无需任何设置即可按照[OpenShift学习门户](https://oreil.ly/j-xKh)上的示例进行操作。
- en: Fetching the etcd Operator Manifests
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取etcd操作员清单
- en: 'This book provides an [accompanying Git repository](https://github.com/kubernetes-operators-book/chapters.git)
    for each chapter’s example code. Grab the *chapters* repo and change into [Chapter 3](ch03.html#operators_at_the_kubernetes_interface)’s
    examples directory, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本书为每章的示例代码提供了一个[伴随的Git仓库](https://github.com/kubernetes-operators-book/chapters.git)。获取*chapters*仓库并切换到[第三章](ch03.html#operators_at_the_kubernetes_interface)的示例目录，如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'CRs: Custom API Endpoints'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRs：自定义API端点
- en: As with nearly everything in Kubernetes, a YAML manifest describes a CRD. A
    CR is a named endpoint in the Kubernetes API. A CRD named `etcdclusters.etcd.database.coreos.com`
    represents the new type of endpoint.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes中的几乎所有内容一样，YAML清单描述了CRD。CR是Kubernetes API中的命名端点。名为`etcdclusters.etcd.database.coreos.com`的CRD表示新的端点类型。
- en: Creating a CRD
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建CRD
- en: A CRD defines the types and values within an instance of a CR. This example
    defines a new *kind* of resource, the EtcdCluster.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CRD定义了CR实例内的类型和值。此示例定义了新的*kind*资源类型，即EtcdCluster。
- en: 'Use `cat`, `less`, or your preferred pager to read the file named *etcd-operator-crd.yaml*.
    You’ll see something like the following, the YAML that specifies the EtcdCluster
    CRD:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cat`、`less`或您喜欢的分页程序阅读名为*etcd-operator-crd.yaml*的文件。您将看到类似以下内容的YAML，该YAML指定了EtcdCluster
    CRD的规范：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The CRD defines how the Kubernetes API should reference this new resource. The
    shortened nicknames that help you do a little less typing in `kubectl` are defined
    here, too.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CRD定义了Kubernetes API应如何引用此新资源。在这里也定义了缩写的昵称，以帮助您在`kubectl`中少打一些字。
- en: 'Create the CRD on your cluster:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的集群上创建CRD：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A quick check shows the new CRD, `etcdclusters.etcd.database.coreos.com`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一次快速检查显示新的CRD，`etcdclusters.etcd.database.coreos.com`：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The CR’s group, version, and kind together form the fully qualified name of
    a Kubernetes resource type. That canonical name must be unique across a cluster.
    The CRD you created represents a resource in the `etcd.database.coreos.com` group,
    of version `v1beta2` and kind `EtcdCluster`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CR的组、版本和类型共同形成Kubernetes资源类型的完全限定名称。该规范名称在整个集群中必须是唯一的。您创建的CRD代表了`etcd.database.coreos.com`组的`v1beta2`版本和`EtcdCluster`类型的资源。
- en: 'Who Am I: Defining an Operator Service Account'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是谁：定义操作员服务账户
- en: In [Chapter 3](ch03.html#operators_at_the_kubernetes_interface) we give an overview
    of Kubernetes authorization and define service accounts, roles, and other authorization
    concepts. For now, we just want to take a first look at basic declarations for
    a service account and the capabilities that account needs to run the etcd Operator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The file *etcd-operator-sa.yaml* defines the service account:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the service account by using `kubectl create`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you check the list of cluster service accounts, you’ll see that it appears:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The role
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The role governing the service account is defined in a file named *etcd-operator-role.yaml*.
    We’ll leave aside a detailed discussion of RBAC for later chapters and [Appendix C](app03.html#appendix_rbac),
    but the key items are fairly visible in the role manifest. We give the role a
    name that we’ll use to reference it from other places: `etcd-operator-role`. The
    YAML goes on to list the kinds of resources the role may use, and what it can
    do with them, that is, what `verbs` it can say:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As with the service account, `create` the role with `kubectl`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Role binding
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last bit of RBAC configuration, RoleBinding, assigns the role to the service
    account for the etcd Operator. It’s declared in the file *etcd-operator-rolebinding.yaml*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the last line. If you’re on a brand-new OpenShift cluster, like that
    provided by CodeReady Containers, by default your `kubectl` or `oc` commands will
    run in the namespace `myproject`. If you’re on a similarly unconfigured Kubernetes
    cluster, your context’s default will usually be the namespace `default`. Wherever
    you are, the `namespace` value in this RoleBinding must match the namespace on
    the cluster where you are working.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the binding now:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Deploying the etcd Operator
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Operator is a custom controller running in a pod, and it watches the EtcdCluster
    CR you defined earlier. The manifest file *etcd-operator-deployment.yaml* lays
    out the Operator pod’s specification, including the container image for the Operator
    you’re deploying. Notice that it does not define the spec for the etcd cluster.
    You’ll describe the desired etcd cluster to the deployed etcd Operator in a CR
    once the Operator is running:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The deployment provides labels and a name for your Operator. Some key items
    to note here are the container image to run in this deployment’s pods, `etcd-operator:v0.9.4`,
    and the service account the deployment’s resources should use to access the cluster’s
    Kubernetes API. The `etcd-operator` deployment uses the `etcd-operator-sa` service
    account created for it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you can create this resource on the cluster from the manifest:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The etcd Operator is itself a pod running in that deployment. Here you can
    see it starting up:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declaring an etcd Cluster
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, you created a CRD defining a new kind of resource, an EtcdCluster.
    Now that you have an Operator watching EtcdCluster resources, you can declare
    an EtcdCluster with your desired state. To do so, provide the two `spec` elements
    the Operator recognizes: `size`, the number of etcd cluster members, and the `version`
    of etcd each of those members should run.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，您创建了一个CRD来定义一种新的资源类型，即EtcdCluster。现在您有一个监视EtcdCluster资源的Operator，您可以声明一个具有所需状态的EtcdCluster。为此，请提供Operator识别的两个`spec`元素：`size`，etcd集群成员的数量，和每个成员应运行的etcd`version`。
- en: 'You can see the `spec` stanza in the file *etcd-cluster-cr.yaml*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在名为*etcd-cluster-cr.yaml*的文件中看到`spec`部分：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This brief manifest declares a desired state of three cluster members, each
    running version 3.1.10 of the etcd server. Create this etcd cluster using the
    familiar `kubectl` syntax:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这份简短的清单声明了三个集群成员的期望状态，每个成员运行的是etcd服务器的3.1.10版本。使用熟悉的`kubectl`语法创建这个etcd集群：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example etcd cluster is a first-class citizen, an `EtcdCluster` in your
    cluster’s API. Since it’s an API resource, you can get the etcd cluster spec and
    status directly from Kubernetes. Try `kubectl describe` to report on the size,
    etcd version, and status of your etcd cluster, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例etcd集群是您集群API中的一级资源，即`EtcdCluster`。由于它是一个API资源，您可以直接从Kubernetes获取etcd集群的规范和状态。尝试`kubectl
    describe`以报告您的etcd集群的大小、etcd版本和状态，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Exercising etcd
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行etcd
- en: 'You now have a running etcd cluster. The etcd Operator creates a Kubernetes
    [*service*](https://oreil.ly/meXW_) in the etcd cluster’s namespace. A service
    is an endpoint where clients can obtain access to a group of pods, even though
    the members of the group may change. A service by default has a DNS name visible
    in the cluster. The Operator constructs the name of the service used by clients
    of the etcd API by appending `-client` to the etcd cluster name defined in the
    CR. Here, the client service is named `example-etcd-cluster-client`, and it listens
    on the usual etcd client IP port, 2379\. Kubectl can list the services associated
    with the etcd cluster:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在拥有一个运行中的etcd集群。etcd Operator在etcd集群的命名空间中创建了一个Kubernetes [*service*](https://oreil.ly/meXW_)。服务是客户端可以获取访问一组Pod的终结点，即使组成员可能会发生变化的地方。服务默认具有在集群中可见的DNS名称。操作员通过将`-client`附加到CR中定义的etcd集群名称来构造etcd
    API客户端使用的服务名称。在这里，客户端服务名为`example-etcd-cluster-client`，并且监听通常的etcd客户端IP端口2379。kubectl可以列出与etcd集群关联的服务：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The other service created by the etcd Operator, `example-etcd-cluster`, is utilized
    by etcd cluster members rather than etcd API clients.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: etcd Operator创建的另一个服务`example-etcd-cluster`被etcd集群成员使用，而不是etcd API客户端。
- en: 'You can run the etcd client on the cluster and use it to connect to the client
    service and interact with the etcd API. The following command lands you in the
    shell of an etcd container:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在集群上运行etcd客户端，并使用它连接到客户端服务，并与etcd API交互。以下命令将您置于etcd容器的shell中：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From the etcd container’s shell, create and read a key-value pair in etcd with
    `etcdctl`’s `put` and `get` verbs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从etcd容器的shell中，使用`etcdctl`的`put`和`get`动词在etcd中创建和读取键值对：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Repeat these queries or run new `put` and `get` commands in an `etcdctl` shell
    after each of the changes you go on to make. You’ll see the continuing availability
    of the etcd API service as the etcd Operator grows the cluster, replaces members,
    and upgrades the version of etcd.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在您进行每项更改后，重复这些查询或在`etcdctl` shell中运行新的`put`和`get`命令。您将看到etcd Operator在增长集群、替换成员和升级etcd版本时，etcd
    API服务的持续可用性。
- en: Scaling the etcd Cluster
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展etcd集群
- en: 'You can grow the etcd cluster by changing the declared `size` specification.
    Edit *etcd-cluster-cr.yaml* and change `size` from `3` to `4` etcd members. Apply
    the changes to the EtcdCluster CR:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过修改声明的`size`规范来扩展etcd集群。编辑*etcd-cluster-cr.yaml*文件，并将`size`从`3`更改为`4`个etcd成员。将更改应用于EtcdCluster
    CR：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Checking the running pods shows the Operator adding a new etcd member to the
    etcd cluster:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 检查运行中的Pods显示Operator正在向etcd集群添加新的etcd成员：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can also try `kubectl edit etcdcluster/example-etcd-cluster` to drop into
    an editor and make a live change to the cluster size.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以尝试使用`kubectl edit etcdcluster/example-etcd-cluster`进入编辑器，实时更改集群大小。
- en: Failure and Automated Recovery
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败和自动恢复
- en: You saw the etcd Operator replace a failed member back in [Chapter 1](ch01.html#chapter_introduction).
    Before you see it live, it’s worth reiterating the general steps you’d have to
    take to handle this manually. Unlike a stateless program, no etcd pod runs in
    a vacuum. Usually, a human etcd “operator” has to notice a member’s failure, execute
    a new copy, and provide it with configuration so it can join the etcd cluster
    with the remaining members. The etcd Operator understands etcd’s internal state
    and makes the recovery automatic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [第一章](ch01.html#chapter_introduction) 中看到 etcd Operator 替换失败的成员。在你现场看到之前，值得再次强调一下你必须手动处理这个问题的一般步骤。不像无状态程序，没有一个
    etcd pod 是独立运行的。通常，人类 etcd “操作员” 必须注意到成员的失败，执行一个新副本，并提供配置使其能够加入剩余成员的 etcd 集群中。etcd
    Operator 理解 etcd 的内部状态并使恢复过程自动化。
- en: Recovering from a failed etcd member
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从失败的 etcd 成员中恢复
- en: 'Run a quick `kubectl get pods -l app=etc` to get a list of the pods in your
    etcd cluster. Pick one you don’t like the looks of, and tell Kubernetes to delete
    it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `kubectl get pods -l app=etc` 快速获取你的 etcd 集群中的 pod 列表。选择一个你不喜欢的，并告诉 Kubernetes
    删除它：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Operator notices the difference between reality on the cluster and the
    desired state, and adds an etcd member to replace the one you deleted. You can
    see the new etcd cluster member in the `PodInitializing` state when retrieving
    the list of pods, as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 察觉到集群现实状态与期望状态之间的差异，并添加一个 etcd 成员以替换你删除的成员。当检索 pod 列表时，你可以在 `PodInitializing`
    状态中看到新的 etcd 集群成员，如下所示：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `-w` switch tells `kubectl` to “watch” the list of pods and to print updates
    on its standard output with every change to the list. You can stop the watch and
    return to your shell prompt with Ctrl-C.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`-w` 开关告诉 `kubectl` “监视” pod 列表，并在列表的每次更改时通过标准输出打印更新。你可以按 Ctrl-C 停止监视并返回你的
    shell 提示符。'
- en: 'You can check the `Events` to see the recovery actions logged in the `example-etcd-cluster`
    CR:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查 `Events` 查看记录在 `example-etcd-cluster` CR 中的恢复操作：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Throughout the recovery process, if you fire up the etcd client pod again,
    you can make requests to the etcd cluster, including a check on its general health:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复过程中，如果再次启动 etcd 客户端 pod，则可以向 etcd 集群发出请求，包括检查其总体健康状况：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The etcd Operator recovers from failures in its complex, stateful application
    the same way Kubernetes automates recoveries for stateless apps. That is conceptually
    simple but operationally powerful. Building on these concepts, Operators can perform
    more advanced tricks, like upgrading the software they manage. Automating upgrades
    can have a positive impact on security, just by making sure things stay up to
    date. When an Operator performs rolling upgrades of its application while maintaining
    service availability, it’s easier to keep software patched with the latest fixes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: etcd Operator 在其复杂的有状态应用中从故障中恢复的方式与 Kubernetes 自动化处理无状态应用的恢复相同。这在概念上很简单，但在操作上非常强大。建立在这些概念之上，Operators
    可以执行更高级的技巧，比如升级它们管理的软件。自动化升级可以通过确保事物保持最新状态，对安全性产生积极影响。当一个 Operator 在保持服务可用性的同时执行其应用程序的滚动升级时，更容易保持软件补丁更新到最新修复版本。
- en: Upgrading etcd Clusters
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级 etcd 集群
- en: If you happen to be an etcd user already, you may have noticed we specified
    an older version, 3.1.10\. We contrived this so we could explore the etcd Operator’s
    upgrade skills.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是 etcd 的用户，可能会注意到我们指定了一个较旧的版本，3.1.10。我们创造了这个版本以便可以探索 etcd Operator 的升级技能。
- en: Upgrading the hard way
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以困难的方式升级
- en: 'At this point, you have an etcd cluster running version 3.1.10\. To upgrade
    to etcd 3.2.13, you need to perform a series of steps. Since this book is about
    Operators, and not etcd administration, we’ve condensed the process presented
    here, leaving aside networking and host-level concerns to outline the manual upgrade
    process. The steps to follow to upgrade manually are:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你有一个运行版本为 3.1.10 的 etcd 集群。要升级到 etcd 3.2.13，你需要执行一系列步骤。由于本书讨论的是 Operators，而不是
    etcd 管理，我们在这里概述了该过程，略去了网络和主机级别的考虑。手动升级的步骤如下：
- en: Check the version and health of each etcd node.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查每个 etcd 节点的版本和健康状态。
- en: Create a snapshot of the cluster state for disaster recovery.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为灾难恢复创建集群状态的快照。
- en: Stop one etcd server. Replace the existing version with the v3.2.13 binary.
    Start the new version.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止一个 etcd 服务器。用 v3.2.13 二进制文件替换现有版本。启动新版本。
- en: Repeat for each etcd cluster member—at least two more times in a three-member
    cluster.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个三个成员的集群中，至少还需重复两次。
- en: For the gory details, see the [etcd upgrade documentation](https://oreil.ly/II9Pn).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The easy way: Let the Operator do it'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a sense of the repetitive and error-prone process of a manual upgrade,
    it’s easier to see the power of encoding that etcd-specific knowledge in the etcd
    Operator. The Operator can manage the etcd version, and an upgrade becomes a matter
    of declaring a new desired version in an EtcdCluster resource.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Triggering etcd upgrades
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Get the version of the current etcd container image by querying some `etcd-cluster`
    pod, filtering the output to see just the version:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, since you added an EtcdCluster resource to the Kubernetes API, you can
    instead summarize the Operator’s picture of `example-etcd-cluster` directly by
    using `kubectl describe` as you did earlier:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You’ll see the cluster is running etcd version 3.1.10, as specified in the file
    *etcd-cluster-cr.yaml* and the CR created from it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `etcd-cluster-cr.yaml` and change the `version` spec from `3.1.10` to
    `3.2.13`. Then apply the new spec to the resource on the cluster:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Use the `describe` command again and take a look at the current and target
    versions, as well as the member upgrade notices in the `Events` stanza:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Upgrade the upgrade
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With some `kubectl` tricks, you can make the same edit directly through the
    Kubernetes API. This time, let’s upgrade from 3.2.13 to the latest minor version
    of etcd available at the time of this writing, version 3.3.12:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember you can always make this change in the etcd cluster’s CR manifest and
    then `apply` it with `kubectl`, as you did to trigger the first upgrade.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Consecutive `kubectl describe etcdcluster/example-etcd-cluster` commands will
    show the transition from the old version to a target version until that becomes
    the current version, at which point you’ll see `Current Version: 3.3.12`. The
    `Events` section records each of those upgrades:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Cleaning Up
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding, it will be helpful if you remove the resources you created
    and manipulated to experiment with the etcd Operator. As shown in the following
    shell excerpt, you can remove resources with the manifests used to create them.
    First, ensure your current working directory is *ch03* inside the *chapters* Git
    repository you cloned earlier (`cd chapters/ch03`):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the etcd API here with the `etcdctl` tool for the sake of simplicity,
    but an application uses etcd with the same API requests, storing, retrieving,
    and watching keys and ranges. The etcd Operator automates the etcd cluster part,
    making reliable key-value storage available to more applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators get considerably more complex, managing a variety of concerns, as
    you would expect from application-specific extensions. Nevertheless, most Operators
    follow the basic pattern discernable in the etcd Operator: a CR specifies some
    desired state, such as the version of an application, and a custom controller
    watches the resource, maintaining the desired state on the cluster.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: You now have a Kubernetes cluster for working with Operators. You’ve seen how
    to deploy an Operator and triggered it to perform application-specific state reconciliation.
    Next, we’ll introduce the Kubernetes API elements on which Operators build before
    introducing the Operator Framework and SDK, the toolkit you’ll use to construct
    an Operator.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经拥有一个用于处理运算符的Kubernetes集群。您已经看到如何部署运算符并触发其执行特定于应用程序的状态协调。接下来，我们将介绍运算符构建所依赖的Kubernetes
    API元素，然后介绍运算符框架和SDK，这是您用来构建运算符的工具包。
