- en: Chapter 2\. Running Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first section of this chapter we outline the requirements for running
    the examples in this book, and offer advice on how to establish access to a Kubernetes
    cluster that satisfies those requirements. In the second section, you’ll use that
    cluster to investigate what Operators do by installing and using one.
  prefs: []
  type: TYPE_NORMAL
- en: By the end, you’ll have a Kubernetes cluster to use as an Operator test bed,
    and you’ll know how to deploy an existing Operator on it from a set of manifests.
    You’ll also have seen an Operator managing its application’s specific internal
    state in the face of changes and failures, informing your understanding of the
    Operator architecture and build tools presented in succeeding chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up an Operator Lab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build, test, and run Operators in the following chapters, you’ll need `cluster-admin`
    access to a cluster running Kubernetes version v1.11.0 or later. If you’ve already
    met these requirements, you can skip ahead to the next section. In this section
    we offer general advice to readers who need to set up a Kubernetes cluster, or
    who need a local environment for Operator development and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Version Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve tested the examples in this book with Kubernetes releases v1.11 up to
    v1.16\. We will state when any feature or action we examine requires a release
    later than v1.11.
  prefs: []
  type: TYPE_NORMAL
- en: Control plane extensibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes version 1.2 introduced the API extension mechanism known as the CRD
    in elemental form as the *third party resource* (TPR). Since then, the components
    Operators build on have multiplied and matured, as illustrated in [Figure 2-1](#fig2-1).
    CRDs were formalized with the Kubernetes version 1.7 release.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2-1: Extensibility Features per Kubernetes Release](assets/kuop_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Extensibility features per Kubernetes release
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you saw in [Chapter 1](ch01.html#chapter_introduction), a CRD is the definition
    of a new, site-specific resource (or API endpoint) in the Kubernetes API of a
    particular cluster. CRDs are one of two essential building blocks for the most
    basic description of the Operator pattern: a custom controller managing CRs.'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Operators extend Kubernetes itself, you’ll need privileged, cluster-wide
    access to a Kubernetes cluster to deploy them, such as the common `cluster-admin`
    cluster role.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Less privileged users can use the services and applications that Operators manage—the
    “operands.”
  prefs: []
  type: TYPE_NORMAL
- en: While you should configure more granular Kubernetes Role-Based Access Control
    (RBAC) for production scenarios, having complete control of your cluster means
    you’ll be able to deploy CRDs and Operators immediately. You’ll also have the
    power to declare more detailed RBAC as you develop the roles, service accounts,
    and bindings for your Operators and the applications they manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ask the Kubernetes API about the `cluster-admin` role to see if it
    exists on your cluster. The following shell excerpt shows how to get a summary
    of the role with the `kubectl`’s `describe` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The RBAC `cluster-admin` ClusterRole: anything goes.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard Tools and Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators aim to make the complex applications they manage first-class citizens
    of the Kubernetes API. We show what that means in the following chapters’ examples.
    At this stage, it means that a recent version of the command-line Kubernetes API
    tool, `kubectl`, is the only requirement for deploying and interacting with basic
    Operators on your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Readers who need to install or update `kubectl` should consult the [current
    kubectl documentation](https://oreil.ly/ke6KM).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Users of the Red Hat OpenShift Kubernetes distribution (described below) may
    optionally (and interchangeably) use the `oc` OpenShift API utility in place of
    `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Suggested Cluster Configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to run a Kubernetes cluster where you can deploy Operators.
    As mentioned previously, if you are already running a recent Kubernetes version,
    you can skip past this advice and on to [“Running a Simple Operator”](#running_a_simple_operator).
    If you aren’t, we have tested the Kubernetes packagings or distributions described
    in this section enough to expect they will support the exercises in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Minikube v1.5.2](https://oreil.ly/dBPzK) deploys Kubernetes v1.16.2\. It runs
    a single-node Kubernetes cluster in a virtual machine (VM) on your local system’s
    hypervisor. By default, Minikube expects to use VirtualBox because of its wide
    availability, but with a few extra steps it can also use your platform’s native
    hypervisor, like KVM on Linux, Hyper-V on Windows, or HyperKit and Hypervisor.framework
    on macOS. We avoid detailed installation instructions here, because they are better
    left to the [Minikube documentation](https://oreil.ly/eRZpQ). We have tested the
    examples in this book most thoroughly with Minikube, and for reasons of convenience
    and cost we are recommending that you start your Operator experiments with a local
    environment like it, CodeReady Containers (see the next section), or with [Kubernetes
    in Docker (kind)](https://oreil.ly/2y6PD).'
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat OpenShift
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenShift is Red Hat’s distribution of Kubernetes. Anything you can do on Kubernetes,
    you can do on OpenShift of an equivalent core version. (There are also OpenShift-specific
    features built atop Kubernetes, but those are beyond the scope of this book.)
    OpenShift version 4 provides a full-featured Kubernetes distribution that is itself
    designed, delivered, and managed using Operators. It’s a “self-hosted” Kubernetes,
    capable of performing in-place platform upgrades without incurring downtime for
    hosted workloads. OpenShift includes Operator Lifecycle Manager, described in
    [Chapter 4](ch04.html#the_operator_framework), and a graphical interface to the
    Operator Catalog distribution mechanism out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: You can deploy a fully fledged OpenShift v4 cluster on Amazon Web Services (AWS),
    Microsoft Azure, or Google Cloud Platform with a free trial license by visiting
    Red Hat’s [*https://try.openshift.com*](https://try.openshift.com).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To run OpenShift on your laptop, take a look at Minikube’s equivalent, [Red
    Hat CodeReady Containers](https://github.com/code-ready/crc).
  prefs: []
  type: TYPE_NORMAL
- en: Checking Your Cluster Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Verify that your cluster is running Kubernetes version v1.11 or later by running
    `kubectl version`. This command will return one API version string for your `kubectl`
    binary and a second version string for the cluster to which it is connecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, both client and server are running Kubernetes version
    1.16.2\. While [a `kubectl` client up to one release behind the server should
    work](https://oreil.ly/I7K1e), for simplicity, you should make sure your client
    and server minor versions match. If you have v1.11 or later, you’re ready to start
    experimenting with Operators.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Simple Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you’ve verified that you have privileged access to a Kubernetes cluster
    of a compatible version, you’re ready to deploy an Operator and see what Operators
    can do. You’ll see the skeleton of this same procedure again later, when you deploy
    and test the Operator you build. The etcd Operator’s straightforward automation
    of recovery and upgrades shows the principles and goals of Kubernetes Operators
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: A Common Starting Point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[etcd](https://github.com/coreos/etcd) is a distributed key-value store with
    roots at CoreOS, now under the auspices of the Cloud Native Computing Foundation.
    It is the underlying data store at the core of Kubernetes, and a key piece of
    several distributed applications. etcd provides reliable storage by implementing
    a protocol called [Raft](https://raft.github.io/) that guarantees consensus among
    a quorum of members.'
  prefs: []
  type: TYPE_NORMAL
- en: The etcd Operator often serves as a kind of “Hello World” example of the value
    and mechanics of the Operator pattern, and we follow that tradition here. We return
    to it because the most basic use of etcd is not difficult to illustrate, but etcd
    cluster setup and administration require exactly the kind of application-specific
    know-how you can bake into an Operator. To use etcd, you *put* keys and values
    in, and *get* them back out by name. Creating a reliable etcd cluster of the minimum
    three or more nodes requires configuration of endpoints, auth, and other concerns
    usually left to an etcd expert (or their collection of custom shell scripts).
    Keeping etcd running and upgraded over time requires continued administration.
    The etcd Operator knows how to do all of this.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, you’ll deploy the etcd Operator, then have it create
    an etcd cluster according to your specifications. You will have the Operator recover
    from failures and perform a version upgrade while the etcd API continues to service
    read and write requests, showing how an Operator automates the lifecycle of a
    piece of foundation software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can follow this example on a running OpenShift cluster without doing any
    setup at the [OpenShift learning portal](https://oreil.ly/j-xKh).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the etcd Operator Manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book provides an [accompanying Git repository](https://github.com/kubernetes-operators-book/chapters.git)
    for each chapter’s example code. Grab the *chapters* repo and change into [Chapter 3](ch03.html#operators_at_the_kubernetes_interface)’s
    examples directory, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'CRs: Custom API Endpoints'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with nearly everything in Kubernetes, a YAML manifest describes a CRD. A
    CR is a named endpoint in the Kubernetes API. A CRD named `etcdclusters.etcd.database.coreos.com`
    represents the new type of endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CRD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A CRD defines the types and values within an instance of a CR. This example
    defines a new *kind* of resource, the EtcdCluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `cat`, `less`, or your preferred pager to read the file named *etcd-operator-crd.yaml*.
    You’ll see something like the following, the YAML that specifies the EtcdCluster
    CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The CRD defines how the Kubernetes API should reference this new resource. The
    shortened nicknames that help you do a little less typing in `kubectl` are defined
    here, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the CRD on your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick check shows the new CRD, `etcdclusters.etcd.database.coreos.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The CR’s group, version, and kind together form the fully qualified name of
    a Kubernetes resource type. That canonical name must be unique across a cluster.
    The CRD you created represents a resource in the `etcd.database.coreos.com` group,
    of version `v1beta2` and kind `EtcdCluster`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Who Am I: Defining an Operator Service Account'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#operators_at_the_kubernetes_interface) we give an overview
    of Kubernetes authorization and define service accounts, roles, and other authorization
    concepts. For now, we just want to take a first look at basic declarations for
    a service account and the capabilities that account needs to run the etcd Operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file *etcd-operator-sa.yaml* defines the service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the service account by using `kubectl create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the list of cluster service accounts, you’ll see that it appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The role governing the service account is defined in a file named *etcd-operator-role.yaml*.
    We’ll leave aside a detailed discussion of RBAC for later chapters and [Appendix C](app03.html#appendix_rbac),
    but the key items are fairly visible in the role manifest. We give the role a
    name that we’ll use to reference it from other places: `etcd-operator-role`. The
    YAML goes on to list the kinds of resources the role may use, and what it can
    do with them, that is, what `verbs` it can say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the service account, `create` the role with `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Role binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last bit of RBAC configuration, RoleBinding, assigns the role to the service
    account for the etcd Operator. It’s declared in the file *etcd-operator-rolebinding.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice the last line. If you’re on a brand-new OpenShift cluster, like that
    provided by CodeReady Containers, by default your `kubectl` or `oc` commands will
    run in the namespace `myproject`. If you’re on a similarly unconfigured Kubernetes
    cluster, your context’s default will usually be the namespace `default`. Wherever
    you are, the `namespace` value in this RoleBinding must match the namespace on
    the cluster where you are working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the binding now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Deploying the etcd Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Operator is a custom controller running in a pod, and it watches the EtcdCluster
    CR you defined earlier. The manifest file *etcd-operator-deployment.yaml* lays
    out the Operator pod’s specification, including the container image for the Operator
    you’re deploying. Notice that it does not define the spec for the etcd cluster.
    You’ll describe the desired etcd cluster to the deployed etcd Operator in a CR
    once the Operator is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The deployment provides labels and a name for your Operator. Some key items
    to note here are the container image to run in this deployment’s pods, `etcd-operator:v0.9.4`,
    and the service account the deployment’s resources should use to access the cluster’s
    Kubernetes API. The `etcd-operator` deployment uses the `etcd-operator-sa` service
    account created for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you can create this resource on the cluster from the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The etcd Operator is itself a pod running in that deployment. Here you can
    see it starting up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Declaring an etcd Cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, you created a CRD defining a new kind of resource, an EtcdCluster.
    Now that you have an Operator watching EtcdCluster resources, you can declare
    an EtcdCluster with your desired state. To do so, provide the two `spec` elements
    the Operator recognizes: `size`, the number of etcd cluster members, and the `version`
    of etcd each of those members should run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the `spec` stanza in the file *etcd-cluster-cr.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This brief manifest declares a desired state of three cluster members, each
    running version 3.1.10 of the etcd server. Create this etcd cluster using the
    familiar `kubectl` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This example etcd cluster is a first-class citizen, an `EtcdCluster` in your
    cluster’s API. Since it’s an API resource, you can get the etcd cluster spec and
    status directly from Kubernetes. Try `kubectl describe` to report on the size,
    etcd version, and status of your etcd cluster, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Exercising etcd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You now have a running etcd cluster. The etcd Operator creates a Kubernetes
    [*service*](https://oreil.ly/meXW_) in the etcd cluster’s namespace. A service
    is an endpoint where clients can obtain access to a group of pods, even though
    the members of the group may change. A service by default has a DNS name visible
    in the cluster. The Operator constructs the name of the service used by clients
    of the etcd API by appending `-client` to the etcd cluster name defined in the
    CR. Here, the client service is named `example-etcd-cluster-client`, and it listens
    on the usual etcd client IP port, 2379\. Kubectl can list the services associated
    with the etcd cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The other service created by the etcd Operator, `example-etcd-cluster`, is utilized
    by etcd cluster members rather than etcd API clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the etcd client on the cluster and use it to connect to the client
    service and interact with the etcd API. The following command lands you in the
    shell of an etcd container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From the etcd container’s shell, create and read a key-value pair in etcd with
    `etcdctl`’s `put` and `get` verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Repeat these queries or run new `put` and `get` commands in an `etcdctl` shell
    after each of the changes you go on to make. You’ll see the continuing availability
    of the etcd API service as the etcd Operator grows the cluster, replaces members,
    and upgrades the version of etcd.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the etcd Cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can grow the etcd cluster by changing the declared `size` specification.
    Edit *etcd-cluster-cr.yaml* and change `size` from `3` to `4` etcd members. Apply
    the changes to the EtcdCluster CR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the running pods shows the Operator adding a new etcd member to the
    etcd cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also try `kubectl edit etcdcluster/example-etcd-cluster` to drop into
    an editor and make a live change to the cluster size.
  prefs: []
  type: TYPE_NORMAL
- en: Failure and Automated Recovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You saw the etcd Operator replace a failed member back in [Chapter 1](ch01.html#chapter_introduction).
    Before you see it live, it’s worth reiterating the general steps you’d have to
    take to handle this manually. Unlike a stateless program, no etcd pod runs in
    a vacuum. Usually, a human etcd “operator” has to notice a member’s failure, execute
    a new copy, and provide it with configuration so it can join the etcd cluster
    with the remaining members. The etcd Operator understands etcd’s internal state
    and makes the recovery automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering from a failed etcd member
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Run a quick `kubectl get pods -l app=etc` to get a list of the pods in your
    etcd cluster. Pick one you don’t like the looks of, and tell Kubernetes to delete
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The Operator notices the difference between reality on the cluster and the
    desired state, and adds an etcd member to replace the one you deleted. You can
    see the new etcd cluster member in the `PodInitializing` state when retrieving
    the list of pods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `-w` switch tells `kubectl` to “watch” the list of pods and to print updates
    on its standard output with every change to the list. You can stop the watch and
    return to your shell prompt with Ctrl-C.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the `Events` to see the recovery actions logged in the `example-etcd-cluster`
    CR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Throughout the recovery process, if you fire up the etcd client pod again,
    you can make requests to the etcd cluster, including a check on its general health:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The etcd Operator recovers from failures in its complex, stateful application
    the same way Kubernetes automates recoveries for stateless apps. That is conceptually
    simple but operationally powerful. Building on these concepts, Operators can perform
    more advanced tricks, like upgrading the software they manage. Automating upgrades
    can have a positive impact on security, just by making sure things stay up to
    date. When an Operator performs rolling upgrades of its application while maintaining
    service availability, it’s easier to keep software patched with the latest fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading etcd Clusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you happen to be an etcd user already, you may have noticed we specified
    an older version, 3.1.10\. We contrived this so we could explore the etcd Operator’s
    upgrade skills.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the hard way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, you have an etcd cluster running version 3.1.10\. To upgrade
    to etcd 3.2.13, you need to perform a series of steps. Since this book is about
    Operators, and not etcd administration, we’ve condensed the process presented
    here, leaving aside networking and host-level concerns to outline the manual upgrade
    process. The steps to follow to upgrade manually are:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the version and health of each etcd node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a snapshot of the cluster state for disaster recovery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop one etcd server. Replace the existing version with the v3.2.13 binary.
    Start the new version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat for each etcd cluster member—at least two more times in a three-member
    cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the gory details, see the [etcd upgrade documentation](https://oreil.ly/II9Pn).
  prefs: []
  type: TYPE_NORMAL
- en: 'The easy way: Let the Operator do it'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a sense of the repetitive and error-prone process of a manual upgrade,
    it’s easier to see the power of encoding that etcd-specific knowledge in the etcd
    Operator. The Operator can manage the etcd version, and an upgrade becomes a matter
    of declaring a new desired version in an EtcdCluster resource.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering etcd upgrades
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Get the version of the current etcd container image by querying some `etcd-cluster`
    pod, filtering the output to see just the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, since you added an EtcdCluster resource to the Kubernetes API, you can
    instead summarize the Operator’s picture of `example-etcd-cluster` directly by
    using `kubectl describe` as you did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see the cluster is running etcd version 3.1.10, as specified in the file
    *etcd-cluster-cr.yaml* and the CR created from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `etcd-cluster-cr.yaml` and change the `version` spec from `3.1.10` to
    `3.2.13`. Then apply the new spec to the resource on the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `describe` command again and take a look at the current and target
    versions, as well as the member upgrade notices in the `Events` stanza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Upgrade the upgrade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With some `kubectl` tricks, you can make the same edit directly through the
    Kubernetes API. This time, let’s upgrade from 3.2.13 to the latest minor version
    of etcd available at the time of this writing, version 3.3.12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Remember you can always make this change in the etcd cluster’s CR manifest and
    then `apply` it with `kubectl`, as you did to trigger the first upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consecutive `kubectl describe etcdcluster/example-etcd-cluster` commands will
    show the transition from the old version to a target version until that becomes
    the current version, at which point you’ll see `Current Version: 3.3.12`. The
    `Events` section records each of those upgrades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding, it will be helpful if you remove the resources you created
    and manipulated to experiment with the etcd Operator. As shown in the following
    shell excerpt, you can remove resources with the manifests used to create them.
    First, ensure your current working directory is *ch03* inside the *chapters* Git
    repository you cloned earlier (`cd chapters/ch03`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the etcd API here with the `etcdctl` tool for the sake of simplicity,
    but an application uses etcd with the same API requests, storing, retrieving,
    and watching keys and ranges. The etcd Operator automates the etcd cluster part,
    making reliable key-value storage available to more applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators get considerably more complex, managing a variety of concerns, as
    you would expect from application-specific extensions. Nevertheless, most Operators
    follow the basic pattern discernable in the etcd Operator: a CR specifies some
    desired state, such as the version of an application, and a custom controller
    watches the resource, maintaining the desired state on the cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a Kubernetes cluster for working with Operators. You’ve seen how
    to deploy an Operator and triggered it to perform application-specific state reconciliation.
    Next, we’ll introduce the Kubernetes API elements on which Operators build before
    introducing the Operator Framework and SDK, the toolkit you’ll use to construct
    an Operator.
  prefs: []
  type: TYPE_NORMAL
