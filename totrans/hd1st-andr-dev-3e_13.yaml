- en: 'Chapter 11\. View Models: *Model Behavior*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0435-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**As apps grow more complex, fragments have more to juggle.**'
  prefs: []
  type: TYPE_NORMAL
- en: And if you’re not careful, this can lead to **bloated code** that tries to do
    everything. Business logic, navigation, controlling the UI, dealing with configuration
    changes…you name it, it’s in there. In this chapter, you’ll learn how to deal
    with this kind of situation using **view models**. You’ll discover **how they
    simplify your activity and fragment code**. You’ll find out **how they survive
    configuration changes**, keeping your app’s state safe and sound. Finally, we’ll
    show you how to build a **view model factory**, and when this might be needed.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration changes revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you learned in [Chapter 5](ch05.xhtml#the_activity_lifecyclecolon_being_an_act),
    Bad Things can happen when you rotate the screen while running an app. Changing
    the screen orientation is a configuration change, which causes Android to destroy
    and recreate the current activity. As a result, views and properties can lose
    their state and get reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0436-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 5](ch05.xhtml#the_activity_lifecyclecolon_being_an_act), you learned
    how to handle this using the activity’s `onSaveInstanceState` method. This method
    gets triggered before the activity gets destroyed, and it’s used to save any values
    that may get lost in a `Bundle`. When the activity gets recreated, you can use
    these saved values to restore the state of the activity’s views and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Fragments have an onSaveInstanceState method too. Even though we’ve only shown
    you how to use this approach with an activity, it works with fragments as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0436-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a `Bundle` to save state works well for relatively simple apps, but it’s
    not an ideal solution for more complicated ones. This is because `Bundle`s are
    only intended to hold a small amount of data, and only work with a limited number
    of types.
  prefs: []
  type: TYPE_NORMAL
- en: There are other problems, too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another problem apps can have is that the activity and fragment code can quickly
    become bloated. The code may need to control navigation, update the UI, save state,
    and also include more general business logic to control the app’s behavior. Having
    all of this in one place makes the code longer, which can then be harder to read
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’re going to learn how to solve all of these problems using
    a **view model**.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the view model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view model is a separate class that sits alongside the activity or fragment
    code. It’s responsible for all of the data that needs to be displayed on the screen,
    along with any business logic. Whenever a fragment needs to update its layout,
    it asks the view model for the latest values it needs to display, and if it needs
    access to some business logic, it calls the methods held in the view model.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0437-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Why use a view model?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple reasons why you might want to use a view model.
  prefs: []
  type: TYPE_NORMAL
- en: Using a view model simplifies your activity or fragment code. Your fragment
    no longer needs to include code relating to the app’s business logic as this is
    all held in a separate class. Instead, it can focus on things like updating the
    screen or navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is that **the view model can survive configuration changes**.
    It doesn’t get destroyed when the user rotates the device screen, so the state
    of any variables doesn’t get lost. This lets you restore the state of your app
    without having having to store values in a `Bundle`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0437-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re going to find out how to use view models by building a word guessing game.
    Before we start writing the code, let’s go through how the game will work.
  prefs: []
  type: TYPE_NORMAL
- en: What the guessing game will do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of the Guessing Game app is for the user to try and guess a secret word.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, it chooses a word at random from an array, and displays
    a blank for each of the word’s letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0438-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The user suggests a letter that she thinks is in the secret word. If she guesses
    correctly, the game displays the letter where it appears in the secret word. If
    she guesses incorrectly, the game displays the incorrect guess, and she loses
    a life.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0438-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The user continues to make guesses until she finds all of the letters, or runs
    out of lives. When this happens, a new screen appears, telling her what the secret
    word was, and whether she won or lost the game. She’s given the option to start
    another game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0438-03.png)'
  prefs: []
  type: TYPE_IMG
- en: How the app will be structured
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app will contain a single activity (named `MainActivity`), which will be
    used to display the game’s fragments: `GameFragment` and `ResultFragment`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameFragment` is the game’s main screen. It will display blanks for the secret
    word’s letters, let the user make guesses, and show any wrong choices and the
    number of lives left.'
  prefs: []
  type: TYPE_NORMAL
- en: When the game is over, `GameFragment` will use the Navigation component to navigate
    to `ResultFragment`, passing it a `String` for the result. `ResultFragment` will
    display the `String` and a button to let the user start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0439-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll go into more details about how the app is structured when we build it.
    First, let’s run through the steps we’ll take.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what we’re going to do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps that we’ll go through to write the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the basic game.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll create `GameFragment` and `ResultFragment`, write the game logic, and
    use the Navigation component to navigate between the two fragments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0440-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add a view model for GameFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll create a view model, `GameViewModel`, to hold `GameFragment`’s game logic
    and data. This will simplify the `GameFragment` code, and ensure that the game
    survives configuration changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0440-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add a view model for ResultFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll add a second view model, `ResultViewModel`, for `ResultFragment` to use.
    This view model will hold the result of the game that the user’s just played.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0440-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Create the Guessing Game project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to use a new project for the Guessing Game app, so create one now
    using the same steps you used in the previous chapters. Choose the Empty Activity
    option, enter a name of “Guessing Game” and a package name of “com.hfad.guessinggame”,
    and accept the default save location. Make sure the language is set to Kotlin
    and the minimum SDK is API 21 so it will run on most Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: The Guessing Game app will use view binding to reference its views, and the
    Navigation component to navigate between its fragments. Let’s update the project
    and app *build.gradle* files to include these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Update the project build.gradle file…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0441-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re going to add a new variable to the project’s *build.gradle* file to specify
    which version of the Navigation component we’ll be using, along with a Safe Args
    classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *GuessingGame/build.gradle*, and add the following lines (in
    bold) to the sections shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0441-02.png)'
  prefs: []
  type: TYPE_IMG
- en: …and update the app build.gradle file too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the app’s *build.gradle* file, we need to enable view binding, add a dependency
    to the Navigation component library, and apply the Safe Args plug-in so that we
    can pass arguments to fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *GuessingGame/app/build.gradle*, and add the following lines
    (in bold) to the appropriate sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0441-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you’ve made these changes, click on the Sync Now option to sync the changes
    you’ve made with the rest of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create the app’s fragments.
  prefs: []
  type: TYPE_NORMAL
- en: The Guessing Game app has two fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Guessing Game app requires two fragments: `GameFragment` and `ResultFragment`.
    `GameFragment` is the app’s main screen, and `ResultFragment` will be used to
    display the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0442-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s go ahead and add the two fragments to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Create GameFragment…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll add `GameFragment` to the project first.
  prefs: []
  type: TYPE_NORMAL
- en: Highlight the *com.hfad.guessinggame* package in the *app/src/main/java* folder,
    then go to File→New→Fragment→Fragment (Blank). Name the fragment “GameFragment”,
    name its layout “fragment_game”, and make sure the language is set to Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0442-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t worry about the code for these fragments just yet. We’ll update them after
    we’ve added them to a navigation graph.
  prefs: []
  type: TYPE_NORMAL
- en: …and then create ResultFragment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, add `ResultFragment` by highlighting the *com.hfad.guessinggame* package
    in the *app/src/main/java* folder again, and choosing File→New→Fragment→Fragment
    (Blank). This time, name the fragment “ResultFragment”, name its layout “fragment_result”,
    and make sure the language is set to Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0442-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t worry about the code for these fragments just yet. We’ll update them after
    we’ve added them to a navigation graph.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll update the code for these two fragments a few pages ahead. Before that,
    we’ll add a navigation graph to the project, which will tell the app how to navigate
    between the two fragments.
  prefs: []
  type: TYPE_NORMAL
- en: How navigation should work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, a navigation graph tells Android about an app’s possible destinations,
    and how to navigate to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Guessing Game app, we want navigation to work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When the app gets launched, display GameFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0443-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When a game is won or lost, GameFragment navigates to ResultFragment, passing
    it the result.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0443-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user clicks on the New Game button, navigate to GameFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0443-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To implement this, we’ll add `GameFragment` and `ResultFragment` to a new navigation
    graph (which we’ll create), and specify that each fragment can navigate to the
    other.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also say that `GameFragment` will pass a `String` argument to `ResultFragment`,
    specifying a message that indicates whether the user has won or lost the game
    they’ve just played. `ResultFragment` will display this message when it’s navigated
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Create the navigation graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the navigation graph, select the *GuessingGame/app/src/main/res* folder
    in the project explorer, and then choose File→New→Android Resource File. When
    prompted, enter a file name of “nav_graph”, choose a resource type of “Navigation”,
    and click on OK. This creates a navigation graph named *nav_graph.xml*.
  prefs: []
  type: TYPE_NORMAL
- en: We need to update the navigation graph to include `GameFragment` and `ResultFragment`,
    along with navigation actions for each one. We’ll do this next.
  prefs: []
  type: TYPE_NORMAL
- en: '**The navigation graph holds details of all the app’s possible destinations,
    and how to get to them.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Update the navigation graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update the navigation graph, open the file *nav_graph.xml* (if it’s not
    already open), switch to the Code view, and update its code to include the changes
    shown here (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0444-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve updated the navigation graph, let’s link it to `MainActivity`
    so that it displays each fragment when we navigate to it.
  prefs: []
  type: TYPE_NORMAL
- en: Display the current fragment in MainActivity’s layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To display each fragment, we need to add a navigation host to `MainActivity`’s
    layout that’s linked to the navigation graph we just created. We’ll do this using
    a `FragmentContainerView`, just as we did in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re already familiar with the code to do this, so update *activity_main.xml*
    so that it matches the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0445-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you’ve updated the layout, open *MainActivity.kt* and make sure it matches
    the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0445-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything we need for `MainActivity`. Next, let’s update the code for
    the two fragments, starting with `GameFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Update GameFragment’s layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GameFragment` is the app’s main screen, and it’s what the user will use to
    play the guessing game. We need to add several views to its layout to enable this:
    three text views for the word to guess, the number of lives left and the incorrect
    guesses that have been made, an edit text for typing guesses into, and a button
    to make the guess.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these views to the layout by updating the code in *fragment_game.xml* so
    it matches the code shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0446-02.png)![image](Images/f0447-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything we need to include in `GameFragment`’s layout. Next, let’s
    tell the game how to behave by updating its Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: What GameFragment needs to do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first version of the app, *GameFragment.kt* needs to include all of
    the code that’s needed to play the game, as well as updating the screen and enabling
    navigation. It needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/star.png) **Choose a word at random.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll provide it with a list of possible words to choose from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/star.png) **Let the user guess a letter.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/star.png) **Respond to the guess.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user guesses correctly, `GameFragment` needs to add the letter to a list
    of correct guesses, and show where the letter appears in the word. If the guess
    is incorrect, it needs to add the guess to a `String` of incorrect guesses, and
    decrement the number of lives left.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/star.png) **Navigate to ResultFragment when the game is over.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this code is pure Kotlin, or Android code that you’ve seen before. We’ll
    show you the full code over the next few pages.
  prefs: []
  type: TYPE_NORMAL
- en: The GameFragment.kt code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the code for `GameFragment`; update the code in *GameFragment.kt* so
    that it matches the code shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0448-02.png)![image](Images/f0449-02.png)![image](Images/f0450-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all the code that we need for `GameFragment`. Next, let’s write the `ResultFragment`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Update ResultFragment’s layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ResultFragment` uses a text view to tell the user whether she’s won or lost
    the game she’s just played, and a button to let her start another game. We need
    to add both of these views to the fragment’s layout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re already familiar with the code to do this, so open *fragment_result.xml*,
    and update it so that it matches the code shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0451-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We also need to update ResultFragment.kt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we’ve added the text view and button to `ResultFragment`’s layout, we need
    to specify their behavior in the fragment’s Kotlin code. We’ll update the text
    view’s text with the result, and we’ll also make the button navigate back to `GameFragment`
    when it’s clicked.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you the code for *ResultFragment.kt* on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: The ResultFragment.kt code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the code for `ResultFragment`; update *ResultFragment.kt* so it matches
    the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0452-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all the code that we need for this version of the Guessing Game app.
    Let’s go through what happens when the code runs, and take the app for a test
    drive.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The app is launched and GameFragment is displayed in MainActivity.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` sets `livesLeft` to 8, `correctGuesses` and `incorrectGuesses`
    to `""`, `secretWord` to a word it chooses at random, and `secretWordDisplay`
    to the value of `deriveSecretWordDisplay()`. It then calls its `updateScreen()`
    method, which displays the values of `livesLeft`, `incorrectGuesses`, and `secretWordDisplay`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0453-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes a guess, GameFragment calls its makeGuess() method.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method checks if `secretWord` contains the letter the user has guessed.
    If it does, `makeGuess()` adds the letter to `correctGuesses` and updates `secretWordDisplay`.
    If it doesn’t, the method adds the letter to `incorrectGuesses`, and subtracts
    1 from `livesLeft`. It then calls `updateScreen()` again so that the new values
    are displayed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0453-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**After each guess, GameFragment checks if isWon() or isLost() is true.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These methods check if the user has guessed all the letters in the word, or
    if she has run out of lives. If either method returns *true*, `GameFragment` passes
    the result to `ResultFragment`, which displays the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0453-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, `GameFragment` is displayed. It shows how many letters
    the secret word has, and how many lives we have.
  prefs: []
  type: TYPE_NORMAL
- en: We can make a guess by entering a letter in the edit text, and clicking the
    button. If we guess correctly, it places the letter in the secret word, but if
    we get it wrong, we lose a life.
  prefs: []
  type: TYPE_NORMAL
- en: If we guess all the letters or run out of lives, a message telling us whether
    we’ve won or lost is displayed in `ResultFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0454-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The game seems to work, but what happens if we rotate the screen?
  prefs: []
  type: TYPE_NORMAL
- en: The game loses state when the screen rotates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s a problem with the game, however. If we rotate the screen when we’re
    in the middle of a game, the app loses its state and the game starts from the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0455-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The game loses its state because rotating the screen changes the app’s configuration,
    so Android destroys the activity (and the fragment it displays) and immediately
    recreates it. This resets the game’s views and properties.
  prefs: []
  type: TYPE_NORMAL
- en: We *could* solve this problem using the fragment’s `onSaveInstanceState` method
    to save the state of any properties, as we did earlier in the book. This time,
    however, we’re going to fix it by **implementing a view model** instead.
  prefs: []
  type: TYPE_NORMAL
- en: A view model holds business logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0456-01.png)'
  prefs: []
  type: TYPE_IMG
- en: As we said earlier, a view model is a separate class that sits alongside your
    activity or fragment code. It’s responsible for the data that needs to be displayed
    on the screen along with any business logic. In our Guessing Game app, for example,
    this means that the view model needs to hold the game’s properties—like the secret
    word the user needs to guess, and the number of lives left—and any methods that
    control how the game is played.
  prefs: []
  type: TYPE_NORMAL
- en: When you implement a view model, all of the code relating to the app’s data
    or business logic is moved out of the activity or fragment, and into the view
    model. Any code that controls the UI—such as displaying text, or getting user
    input—stays in the activity or fragment code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of architecting Android apps follows a design principle known as *separation
    of concerns*. The app is split into different classes, where each class addresses
    a separate concern. A UI controller—the activity or fragment code—handles the
    UI, and the view model is responsible for the business logic and data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a view model to simplify your activity and fragment code, and hold the
    state of any properties so that they survive configuration changes.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0456-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this sort of app architecture has two key advantages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/star.png) **It simplifies your activity and fragment code.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the app’s data and business logic into a view model means that there’s
    less activity and fragment code for you to maintain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/star.png) **Your app survives configuration changes.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view model is a separate class that sits alongside your activity or fragment
    code. It’s not destroyed when you rotate the device screen, so the state of any
    properties held in the view model survives configuration changes without you having
    to add their values to a `Bundle`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you’ve learned what using a view model buys you, let’s see how to add
    one to the Guessing Game app.
  prefs: []
  type: TYPE_NORMAL
- en: Add a view model dependency to the app build.gradle file…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The view model library is part of Android Jetpack, so you need to update the
    app’s *build.gradle* file to include it as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *GuessingGame/app/build.gradle*, and add the following line (in
    bold) to the dependencies section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0457-02.png)'
  prefs: []
  type: TYPE_IMG
- en: When prompted, sync your changes. You’re now ready to go ahead and create a
    view model.
  prefs: []
  type: TYPE_NORMAL
- en: …and create a view model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to create a view model named `GameViewModel`, which `GameFragment`
    will use for its game logic and data.
  prefs: []
  type: TYPE_NORMAL
- en: Select the *com.hfad.guessinggame* package in the *app/src/main/java* folder,
    then go to File→New→Kotlin Class/File. Name the file “GameViewModel” and choose
    the option to create a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the *GameViewModel.kt* file has been created, update its code to match
    the code below (the changes are in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0457-03.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `GameViewModel` class extends `androidx.lifecycle.ViewModel`.
    `ViewModel` is an abstract class that’s used to turn a plain old class into a
    card-carrying view model.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve added `GameViewModel` to the Guessing Game project and turned
    it into a view model, let’s write the rest of its code.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for GameViewModel.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve already learned, the view model is responsible for an activity or
    fragment’s business logic and data. For the Guessing Game app, this means that
    we need to take all of `GameFragment`’s properties and methods that relate to
    how the game is played, and move them into `GameViewModel`. We’ll leave any code
    relating to navigation or the UI in `GameFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include the
    changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0458-02.png)![image](Images/f0459-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything that we need for `GameViewModel`. Next, let’s link it to `GameFragment`,
    and update the code for that fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Create a GameViewModel object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link a view model to an activity or fragment, you need to add a `ViewModel`
    property to the code, and initialize it with a `ViewModel` object, which you need
    to create. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0460-02.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the above code uses a **view model provider** to create the
    `ViewModel` object. So what does using this class do?
  prefs: []
  type: TYPE_NORMAL
- en: Use a ViewModelProvider to create view models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As its name suggests, `ViewModelProvider` is a special class whose job is to
    provide activities and fragments with view models. It ensures that **a new view
    model object only gets created if one doesn’t already exist**.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, when the screen is rotated, any fragments that are displayed
    on the screen get destroyed and recreated. When this happens, the view model provider
    makes sure that the same view model object continues to be used. The view model
    keeps its state, so any properties that are used by the fragment don’t get reset.
  prefs: []
  type: TYPE_NORMAL
- en: The view model provider keeps hold of the view model so long as the activity
    or fragment stays alive. When a fragment is detached or removed from its activity,
    for example, the view model provider lets go of the fragment’s view model. The
    next time the view model provider is asked to provide a view model object, it
    creates a new one.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0460-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve learned how to link a view model to a fragment, let’s update
    the `GameFragment` code.
  prefs: []
  type: TYPE_NORMAL
- en: The updated code for GameFragment.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to remove the properties and methods from `GameFragment` that we moved
    to `GameViewModel`, and make the fragment use the view model instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the updated code for `GameFragment`; make sure that the file *GameFragment.kt*
    includes the changes shown below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0461-02.png)![image](Images/f0462-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Those are all the changes that we need to make to `GameFragment`. Let’s go through
    what the code does when it runs, and take it for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view model provider sees that there’s no existing `GameViewModel` object
    associated with the fragment, so it creates a new one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0463-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The GameViewModel object is initialized.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets `livesLeft` to 8, `correctGuesses` and `incorrectGuesses` to `""`, `secretWord`
    to a word it chooses at random, and `secretWordDisplay` to `deriveSecretWordDisplay()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0463-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment calls its updateScreen() method.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method accesses the `GameViewModel` object’s `secretWordDisplay`, `livesLeft`,
    and `incorrectGueses` properties, and shows them on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0463-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes a guess, GameFragment calls the GameViewModel object’s
    makeGuess() method.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method checks if `secretWord` contains the letter the user guesses. If it
    does, it adds the letter to `correctGuesses` and updates `secretWordDisplay`.
    If it doesn’t, it adds it to `incorrectGuesses`, and subtracts 1 from `livesLeft`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0464-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment calls its updateScreen() method again.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method gets the updated property values from the `GameViewModel` object,
    and updates the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0464-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**After each guess, GameFragment checks if the view model’s isWon() or isLost()
    methods return true.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either method returns *true*, `GameFragment` passes the result to `ResultFragment`,
    which displays the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0464-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0465-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, `GameFragment` is displayed as before. If we start playing
    the game and rotate the screen, the game retains its state.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0465-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ve now learned how to add a view model to your apps, and used it to avoid
    the problems that can occur when the user rotates the device screen. Before we
    go any further, let’s take a closer look at view models.
  prefs: []
  type: TYPE_NORMAL
- en: BE the View Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The code below describes a view model class named MyViewModel. Your job is
    to play like you’re the view model, and say what problems there are with this
    code and how they could be fixed.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](Images/arr.png) **Answers in [“BE the View Model Solution”](#be_the_view_model_solution).**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a view model for GameFragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0469-01.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we’ve updated the Guessing Game app so that `GameFragment` uses a view
    model named `GameViewModel`, which is responsible for all of the fragment’s business
    logic and data. Using a view model in this way simplifies the code in *GameFragment.kt*,
    and means that the app doesn’t lose its state when the screen is rotated.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0469-02.png)'
  prefs: []
  type: TYPE_IMG
- en: ResultFragment needs a view model too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each view model you create is associated with a single UI controller—an activity
    or fragment. This means that if we want `ResultFragment` to use a view model too,
    we need to create a new one for this fragment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0469-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s do this now. Highlight the *com.hfad.guessinggame* package in the *app/src/main/java*
    folder, then go to File→New→Kotlin Class/File. Name the file “ResultViewModel”
    and choose the option to create a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the *ResultViewModel.kt* file has been created, update its code to match
    ours below (our changes are in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0469-04.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s the basic code you need to define a view model. So what other code do
    we need to add?
  prefs: []
  type: TYPE_NORMAL
- en: ResultViewModel needs to hold the result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may recall, `ResultFragment` displays a message in its layout that tells
    the user whether they’ve won or lost the game they’ve just played. This message
    is passed to `ResultFragment` by `GameFragment` when the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: In the new version of the app, `ResultViewModel` is responsible for `ResultFragment`’s
    game logic and data, so we need to add a property to `ResultViewModel` to store
    the result. We’ll also use a `String` constructor to make sure this property gets
    set as soon as `ResultViewModel` gets created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for *ResultViewModel.kt*; update its code to include the
    changes below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0470-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we’ll update `ResultFragment` so that it uses the new view model.
  prefs: []
  type: TYPE_NORMAL
- en: We need to link ResultViewModel to ResultFragment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we were able to add a `GameViewModel` reference to `GameFragment`
    using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0470-03.png)'
  prefs: []
  type: TYPE_IMG
- en: This tells the view model provider to get the `GameViewModel` object that’s
    linked to the fragment, or create a new one if it doesn’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: The above approach, however, can’t be used to add a `ResultViewModel` reference
    to `ResultFragment`. This is because it **only works for view models with a no
    argument constructor**.
  prefs: []
  type: TYPE_NORMAL
- en: The code worked for `GameViewModel` because we could construct it without passing
    any arguments. The constructor for the `ResultViewModel` class, however, requires
    a `String`, so the above code won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: A view model factory creates view models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An alternative way of creating a view model is to pass the view model provider
    a **view model factory**: a separate class whose sole purpose is to create and
    initialize view models. This approach means that the view model provider doesn’t
    have to worry about creating a view model by itself. Instead, it uses the view
    model factory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While view model factories can be used for any sort of view model, they’re
    mostly used for ones whose constructors require arguments. This is because the
    view model provider can’t pass arguments to the constructor by itself: it needs
    a view model factory to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the view model factory will be used in the Guessing Game app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a view model factory to create a view model that doesn’t have a no-argument
    constructor.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**We’ll define a class named ResultViewModelFactory, which ResultFragment will
    use to create a factory object.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0471-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**ResultFragment will tell the view model provider to use the factory object.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0471-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the view model provider needs a new ResultViewModel object, it will
    use the ResultViewModelFactory.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0471-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s go ahead and add a factory class to the Guessing Game app.
  prefs: []
  type: TYPE_NORMAL
- en: Create the ResultViewModelFactory class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to add a view model factory class named `ResultViewModelFactory`
    to the Guessing Game app. This class will be used by the view model provider to
    create a `ResultViewModel` object.
  prefs: []
  type: TYPE_NORMAL
- en: To create the class, highlight the *com.hfad.guessinggame* package in the *app/src/main/java*
    folder, then go to File→New→Kotlin Class/File. Name the file “ResultViewModelFactory”
    and choose the option to create a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the *ResultViewModelFactory.kt* file has been created, update its code
    to match ours below (our changes are in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0472-02.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `ResultViewModelFactory` class implements an interface named
    `ViewModelProvider.Factory`, and overrides its `create()` method. This turns the
    class into a view model factory, which the view model provider can use to create
    a `ResultViewModel` object.
  prefs: []
  type: TYPE_NORMAL
- en: The above code is everything we need for `ResultViewModelFactory`. Let’s find
    out how to use it in our `ResultFragment` code.
  prefs: []
  type: TYPE_NORMAL
- en: Use the factory to create the view model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said earlier, you use a view model factory to create a view model by passing
    the factory to the view model provider. The view model provider decides when a
    new view model object is required, and when necessary, uses the factory to create
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to make the view model provider use a view model factory is virtually
    identical for every view model you want to create. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0473-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the above code defines two properties: `viewModel` and `viewModelFactory`.
    These are set in the fragment’s `onCreateView()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: In `onCreateView()`, the code uses the result `String` that’s passed to it from
    `GameFragment` to create a new `ResultViewModelFactory` object. It passes the
    factory to the view model provider, which uses it to get a `ResultViewModel` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to use a factory to link a view model to a fragment, let’s
    update the `ResultFragment` code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0473-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The updated code for ResultFragment.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for `ResultFragment`, so update the code in file *ResultFragment.kt*
    so it includes the changes shown below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0474-02.png)![image](Images/f0475-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Those are all the changes that we need to make to `ResultFragment`. After some
    questions, we’ll go through what happens when the app runs.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GameViewModel` object is initialized, and chooses a word at random.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0476-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment interacts with the GameViewModel object.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GameViewModel` object records any guesses the user has made, and keeps
    track of the number of lives left.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0476-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**After each guess, GameFragment checks if the view model’s isWon() or isLost()
    methods return true.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either method is *true*, `GameFragment` navigates to `ResultFragment`, passing
    it the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0476-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**ResultFragment creates a ResultViewModelFactory object, passing it the result
    String.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**ResultFragment asks the ViewModelProvider class for an instance of ResultViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ViewModelProvider` class sees that there’s no existing `ResultViewModel`
    object, so it uses the `ResultViewModelFactory` to create one. The `ResultViewModel`
    object’s `result` property is initialized with the result `String`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0477-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**ResultFragment gets the result String from the ResultViewModel object, and
    displays it on the screen.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0478-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, `GameFragment` is displayed as before.
  prefs: []
  type: TYPE_NORMAL
- en: If we guess all the letters or lose all our lives, the app navigates to `ResultFragment`.
    A message is displayed telling us whether we won or lost, and what the secret
    word was.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0478-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The game behaves in the same way as it did before, but behind the scenes, it’s
    now using view models for its game logic and data.
  prefs: []
  type: TYPE_NORMAL
- en: View Model Magnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the code to define a view model named `GiftViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See if you can piece together the code for the view model factory class that
    will be used to create `GiftViewModel` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0479-01.png)'
  prefs: []
  type: TYPE_IMG
- en: View Model Magnets Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the code to define a view model named `GiftViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See if you can piece together the code for the view model factory class that
    will be used to create `GiftViewModel` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0480-01.png)![image](Images/f0480-02.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the View Model Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The code below describes a view model class named MyViewModel. Your job is
    to play like you’re the view model, and say what problems there are with this
    code and how they could be fixed.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0481-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your Android Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/tools.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You’ve got [Chapter 11](#view_modelscolon_model_behavior) under your belt
    and now you’ve added view models to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0482-01.png)'
  prefs: []
  type: TYPE_IMG
