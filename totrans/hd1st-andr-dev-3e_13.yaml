- en: 'Chapter 11\. View Models: *Model Behavior*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。视图模型：*模型行为*
- en: '![image](Images/f0435-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0435-01.png)'
- en: '**As apps grow more complex, fragments have more to juggle.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**随着应用程序变得更加复杂，片段需要处理的任务变得更多。**'
- en: And if you’re not careful, this can lead to **bloated code** that tries to do
    everything. Business logic, navigation, controlling the UI, dealing with configuration
    changes…you name it, it’s in there. In this chapter, you’ll learn how to deal
    with this kind of situation using **view models**. You’ll discover **how they
    simplify your activity and fragment code**. You’ll find out **how they survive
    configuration changes**, keeping your app’s state safe and sound. Finally, we’ll
    show you how to build a **view model factory**, and when this might be needed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不小心处理不当，这可能导致试图做所有事情的**臃肿代码**。业务逻辑、导航、控制UI、处理配置更改……所有这些都在其中。在本章中，您将学习如何使用**视图模型**来处理这种情况。您将发现它们如何简化您的活动和片段代码。您将了解它们如何在配置更改时保持存活状态，确保应用程序的状态安全和完整。最后，我们将向您展示如何构建**视图模型工厂**，以及何时可能需要它。
- en: Configuration changes revisited
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新讨论配置更改
- en: 'As you learned in [Chapter 5](ch05.xhtml#the_activity_lifecyclecolon_being_an_act),
    Bad Things can happen when you rotate the screen while running an app. Changing
    the screen orientation is a configuration change, which causes Android to destroy
    and recreate the current activity. As a result, views and properties can lose
    their state and get reset:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第5章](ch05.xhtml#the_activity_lifecyclecolon_being_an_act)中学到的，当您在运行应用程序时旋转屏幕，可能会发生一些问题。更改屏幕方向是一种配置更改，这会导致Android销毁并重新创建当前活动。因此，视图和属性可能会丢失其状态并重新设置：
- en: '![image](Images/f0436-01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0436-01.png)'
- en: In [Chapter 5](ch05.xhtml#the_activity_lifecyclecolon_being_an_act), you learned
    how to handle this using the activity’s `onSaveInstanceState` method. This method
    gets triggered before the activity gets destroyed, and it’s used to save any values
    that may get lost in a `Bundle`. When the activity gets recreated, you can use
    these saved values to restore the state of the activity’s views and properties.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#the_activity_lifecyclecolon_being_an_act)中，您学习了如何通过活动的`onSaveInstanceState`方法来处理此问题。此方法在活动被销毁之前触发，并用于保存可能在`Bundle`中丢失的任何值。当活动重新创建时，您可以使用这些保存的值来恢复活动视图和属性的状态。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Fragments have an onSaveInstanceState method too. Even though we’ve only shown
    you how to use this approach with an activity, it works with fragments as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 片段也有一个`onSaveInstanceState`方法。尽管我们只向您展示了如何在活动中使用此方法，但它也适用于片段。
- en: '![image](Images/f0436-03.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0436-03.png)'
- en: Using a `Bundle` to save state works well for relatively simple apps, but it’s
    not an ideal solution for more complicated ones. This is because `Bundle`s are
    only intended to hold a small amount of data, and only work with a limited number
    of types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Bundle`来保存状态对于相对简单的应用程序效果很好，但对于更复杂的应用程序来说并不是理想的解决方案。这是因为`Bundle`只能保存少量数据，并且仅适用于有限数量的类型。
- en: There are other problems, too
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有其他问题
- en: Another problem apps can have is that the activity and fragment code can quickly
    become bloated. The code may need to control navigation, update the UI, save state,
    and also include more general business logic to control the app’s behavior. Having
    all of this in one place makes the code longer, which can then be harder to read
    and maintain.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能面临的另一个问题是，活动和片段代码可能会迅速变得臃肿。代码可能需要控制导航、更新UI、保存状态，并包括更一般的业务逻辑以控制应用程序的行为。将所有这些内容放在一个地方会使代码变得更长，这样就更难阅读和维护。
- en: In this chapter we’re going to learn how to solve all of these problems using
    a **view model**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用**视图模型**来解决所有这些问题。
- en: Introducing the view model
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入视图模型
- en: A view model is a separate class that sits alongside the activity or fragment
    code. It’s responsible for all of the data that needs to be displayed on the screen,
    along with any business logic. Whenever a fragment needs to update its layout,
    it asks the view model for the latest values it needs to display, and if it needs
    access to some business logic, it calls the methods held in the view model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型是一个独立的类，与活动或片段代码并列。它负责屏幕上显示的所有数据，以及任何业务逻辑。每当片段需要更新其布局时，它会请求视图模型提供最新的需要显示的值，如果需要访问一些业务逻辑，则调用视图模型中的方法。
- en: '![image](Images/f0437-01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0437-01.png)'
- en: Why use a view model?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用视图模型？
- en: There are a couple reasons why you might want to use a view model.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望使用视图模型的原因有几个。
- en: Using a view model simplifies your activity or fragment code. Your fragment
    no longer needs to include code relating to the app’s business logic as this is
    all held in a separate class. Instead, it can focus on things like updating the
    screen or navigation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图模型简化您的活动或片段代码。您的片段不再需要包含与应用程序业务逻辑相关的代码，因为这些代码都保存在一个独立的类中。相反，它可以专注于更新屏幕或导航等事项。
- en: Another reason is that **the view model can survive configuration changes**.
    It doesn’t get destroyed when the user rotates the device screen, so the state
    of any variables doesn’t get lost. This lets you restore the state of your app
    without having having to store values in a `Bundle`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是**视图模型可以在配置更改时保持存活**。当用户旋转设备屏幕时，它不会被销毁，因此任何变量的状态不会丢失。这样可以在无需将值存储在`Bundle`中的情况下恢复应用程序的状态。
- en: '![image](Images/f0437-02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0437-02.png)'
- en: We’re going to find out how to use view models by building a word guessing game.
    Before we start writing the code, let’s go through how the game will work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过构建一个猜字游戏来了解如何使用视图模型。在我们开始编写代码之前，让我们先了解游戏的运作方式。
- en: What the guessing game will do
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猜字游戏的功能
- en: The aim of the Guessing Game app is for the user to try and guess a secret word.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 猜字游戏应用程序的目标是让用户尝试猜出一个秘密单词。
- en: 'When the game starts, it chooses a word at random from an array, and displays
    a blank for each of the word’s letters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，它从一个数组中随机选择一个单词，并显示每个字母的空白：
- en: '![image](Images/f0438-01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0438-01.png)'
- en: The user suggests a letter that she thinks is in the secret word. If she guesses
    correctly, the game displays the letter where it appears in the secret word. If
    she guesses incorrectly, the game displays the incorrect guess, and she loses
    a life.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 用户建议一个她认为在秘密单词中的字母。如果她猜对了，游戏会显示字母在秘密单词中的位置。如果她猜错了，游戏会显示错误的猜测，并且她会失去一条生命。
- en: '![image](Images/f0438-02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0438-02.png)'
- en: The user continues to make guesses until she finds all of the letters, or runs
    out of lives. When this happens, a new screen appears, telling her what the secret
    word was, and whether she won or lost the game. She’s given the option to start
    another game.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将继续猜测，直到找到所有的字母或耗尽生命。当这种情况发生时，一个新的屏幕将出现，告诉她秘密单词是什么，以及她是否赢得了游戏。她可以选择开始另一场游戏。
- en: '![image](Images/f0438-03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0438-03.png)'
- en: How the app will be structured
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的结构
- en: 'The app will contain a single activity (named `MainActivity`), which will be
    used to display the game’s fragments: `GameFragment` and `ResultFragment`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将包含一个名为`MainActivity`的单一活动，用于显示游戏的片段：`GameFragment`和`ResultFragment`。
- en: '`GameFragment` is the game’s main screen. It will display blanks for the secret
    word’s letters, let the user make guesses, and show any wrong choices and the
    number of lives left.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameFragment`是游戏的主要屏幕。它将显示秘密单词的空白，让用户进行猜测，并显示任何错误的选择和剩余的生命次数。'
- en: When the game is over, `GameFragment` will use the Navigation component to navigate
    to `ResultFragment`, passing it a `String` for the result. `ResultFragment` will
    display the `String` and a button to let the user start a new game.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，`GameFragment`将使用导航组件导航到`ResultFragment`，并向其传递一个结果的`String`。`ResultFragment`将显示该`String`和一个按钮，让用户开始新游戏。
- en: '![image](Images/f0439-01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0439-01.png)'
- en: We’ll go into more details about how the app is structured when we build it.
    First, let’s run through the steps we’ll take.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在构建应用程序时详细介绍其结构。首先，让我们逐步完成我们将采取的步骤。
- en: Here’s what we’re going to do
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是我们要做的事情
- en: 'Here are the steps that we’ll go through to write the app:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用来编写应用程序的步骤：
- en: '**Write the basic game.**'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写基本游戏。**'
- en: We’ll create `GameFragment` and `ResultFragment`, write the game logic, and
    use the Navigation component to navigate between the two fragments.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建`GameFragment`和`ResultFragment`，编写游戏逻辑，并使用导航组件在这两个片段之间进行导航。
- en: '![image](Images/f0440-01.png)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0440-01.png)'
- en: '**Add a view model for GameFragment.**'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为GameFragment添加一个视图模型。**'
- en: We’ll create a view model, `GameViewModel`, to hold `GameFragment`’s game logic
    and data. This will simplify the `GameFragment` code, and ensure that the game
    survives configuration changes.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建一个视图模型，名为`GameViewModel`，用于保存`GameFragment`的游戏逻辑和数据。这将简化`GameFragment`的代码，并确保游戏在配置更改时仍然存在。
- en: '![image](Images/f0440-02.png)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0440-02.png)'
- en: '**Add a view model for ResultFragment.**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为ResultFragment添加一个视图模型。**'
- en: We’ll add a second view model, `ResultViewModel`, for `ResultFragment` to use.
    This view model will hold the result of the game that the user’s just played.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将为`ResultFragment`添加第二个视图模型`ResultViewModel`。这个视图模型将保存用户刚刚玩过的游戏的结果。
- en: '![image](Images/f0440-03.png)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0440-03.png)'
- en: Create the Guessing Game project
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建猜谜游戏项目
- en: We’re going to use a new project for the Guessing Game app, so create one now
    using the same steps you used in the previous chapters. Choose the Empty Activity
    option, enter a name of “Guessing Game” and a package name of “com.hfad.guessinggame”,
    and accept the default save location. Make sure the language is set to Kotlin
    and the minimum SDK is API 21 so it will run on most Android devices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为猜谜游戏应用使用一个新项目，因此现在使用与前几章相同的步骤创建一个。选择“空活动”选项，输入名称“猜谜游戏”和包名称“com.hfad.guessinggame”，接受默认保存位置。确保语言设置为
    Kotlin，最低 SDK 为 API 21，以便在大多数 Android 设备上运行。
- en: The Guessing Game app will use view binding to reference its views, and the
    Navigation component to navigate between its fragments. Let’s update the project
    and app *build.gradle* files to include these libraries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 猜谜游戏应用将使用视图绑定来引用其视图，并使用导航组件在其片段之间导航。让我们更新项目和应用的*build.gradle*文件以包含这些库。
- en: Update the project build.gradle file…
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新项目的 build.gradle 文件…
- en: '![image](Images/f0441-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0441-01.png)'
- en: We’re going to add a new variable to the project’s *build.gradle* file to specify
    which version of the Navigation component we’ll be using, along with a Safe Args
    classpath.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目的*build.gradle*文件中添加一个新变量，以指定我们将使用的导航组件的版本，以及一个 Safe Args 类路径。
- en: 'Open the file *GuessingGame/build.gradle*, and add the following lines (in
    bold) to the sections shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件*GuessingGame/build.gradle*，并将以下行（用粗体表示）添加到所示的部分：
- en: '![image](Images/f0441-02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0441-02.png)'
- en: …and update the app build.gradle file too
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …并更新应用的 build.gradle 文件
- en: In the app’s *build.gradle* file, we need to enable view binding, add a dependency
    to the Navigation component library, and apply the Safe Args plug-in so that we
    can pass arguments to fragments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的*build.gradle*文件中，我们需要启用视图绑定，添加导航组件库的依赖项，并应用 Safe Args 插件，以便我们可以向片段传递参数。
- en: 'Open the file *GuessingGame/app/build.gradle*, and add the following lines
    (in bold) to the appropriate sections:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件*GuessingGame/app/build.gradle*，并将以下行（用粗体表示）添加到相应的部分：
- en: '![image](Images/f0441-03.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0441-03.png)'
- en: Once you’ve made these changes, click on the Sync Now option to sync the changes
    you’ve made with the rest of your project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，点击“立即同步”选项，将您所做的更改与项目的其余部分同步。
- en: Next, we’ll create the app’s fragments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建应用的片段。
- en: The Guessing Game app has two fragments
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猜谜游戏应用有两个片段
- en: 'The Guessing Game app requires two fragments: `GameFragment` and `ResultFragment`.
    `GameFragment` is the app’s main screen, and `ResultFragment` will be used to
    display the result:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 猜谜游戏应用需要两个片段：`GameFragment` 和 `ResultFragment`。`GameFragment` 是应用的主屏幕，而 `ResultFragment`
    将用于显示结果：
- en: '![image](Images/f0442-02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0442-02.png)'
- en: Let’s go ahead and add the two fragments to the project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向项目添加这两个片段。
- en: Create GameFragment…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GameFragment…
- en: We’ll add `GameFragment` to the project first.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向项目添加`GameFragment`。
- en: Highlight the *com.hfad.guessinggame* package in the *app/src/main/java* folder,
    then go to File→New→Fragment→Fragment (Blank). Name the fragment “GameFragment”,
    name its layout “fragment_game”, and make sure the language is set to Kotlin.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在*app/src/main/java*文件夹中突出显示*com.hfad.guessinggame*包，然后转到文件→新建→片段→片段（空白）。将片段命名为“GameFragment”，将其布局命名为“fragment_game”，并确保语言设置为
    Kotlin。
- en: '![image](Images/f0442-03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0442-03.png)'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry about the code for these fragments just yet. We’ll update them after
    we’ve added them to a navigation graph.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不用担心这些片段的代码。在将它们添加到导航图后，我们将对其进行更新。
- en: …and then create ResultFragment
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …然后创建 ResultFragment
- en: Next, add `ResultFragment` by highlighting the *com.hfad.guessinggame* package
    in the *app/src/main/java* folder again, and choosing File→New→Fragment→Fragment
    (Blank). This time, name the fragment “ResultFragment”, name its layout “fragment_result”,
    and make sure the language is set to Kotlin.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过再次在*app/src/main/java*文件夹中突出显示*com.hfad.guessinggame*包，并选择文件→新建→片段→片段（空白）来添加`ResultFragment`。这次，将片段命名为“ResultFragment”，将其布局命名为“fragment_result”，并确保语言设置为
    Kotlin。
- en: '![image](Images/f0442-04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0442-04.png)'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry about the code for these fragments just yet. We’ll update them after
    we’ve added them to a navigation graph.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不用担心这些片段的代码。在将它们添加到导航图后，我们会更新它们。
- en: We’ll update the code for these two fragments a few pages ahead. Before that,
    we’ll add a navigation graph to the project, which will tell the app how to navigate
    between the two fragments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将更新这两个片段的代码。在此之前，我们将在项目中添加一个导航图，告诉应用如何在这两个片段之间导航。
- en: How navigation should work
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航工作原理
- en: As you know, a navigation graph tells Android about an app’s possible destinations,
    and how to navigate to them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道的，导航图告诉 Android 应用可能的目标位置以及如何导航到它们。
- en: 'In the Guessing Game app, we want navigation to work as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在猜谜游戏应用中，我们希望导航按以下方式工作：
- en: '**When the app gets launched, display GameFragment.**'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当应用启动时，显示 GameFragment。**'
- en: '![image](Images/f0443-02.png)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0443-02.png)'
- en: '**When a game is won or lost, GameFragment navigates to ResultFragment, passing
    it the result.**'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当游戏赢了或输了时，GameFragment 导航到 ResultFragment，并向其传递结果。**'
- en: '![image](Images/f0443-03.png)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0443-03.png)'
- en: '**When the user clicks on the New Game button, navigate to GameFragment.**'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当用户点击“New Game”按钮时，导航到 GameFragment。**'
- en: '![image](Images/f0443-04.png)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0443-04.png)'
- en: To implement this, we’ll add `GameFragment` and `ResultFragment` to a new navigation
    graph (which we’ll create), and specify that each fragment can navigate to the
    other.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将把 `GameFragment` 和 `ResultFragment` 添加到一个新的导航图中（我们将创建），并指定每个片段可以导航到另一个片段。
- en: We’ll also say that `GameFragment` will pass a `String` argument to `ResultFragment`,
    specifying a message that indicates whether the user has won or lost the game
    they’ve just played. `ResultFragment` will display this message when it’s navigated
    to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将说，`GameFragment` 将向 `ResultFragment` 传递一个 `String` 参数，指定一个消息，指示用户是赢了还是输了他们刚刚玩的游戏。当导航到
    `ResultFragment` 时，将显示此消息。
- en: Create the navigation graph
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建导航图
- en: To create the navigation graph, select the *GuessingGame/app/src/main/res* folder
    in the project explorer, and then choose File→New→Android Resource File. When
    prompted, enter a file name of “nav_graph”, choose a resource type of “Navigation”,
    and click on OK. This creates a navigation graph named *nav_graph.xml*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建导航图，选择项目资源管理器中的 *GuessingGame/app/src/main/res* 文件夹，然后选择 文件→新建→Android 资源文件。在提示时，输入文件名“nav_graph”，选择资源类型“导航”，然后点击确定。这将创建一个名为
    *nav_graph.xml* 的导航图。
- en: We need to update the navigation graph to include `GameFragment` and `ResultFragment`,
    along with navigation actions for each one. We’ll do this next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新导航图，包括 `GameFragment` 和 `ResultFragment`，以及每个片段的导航操作。接下来我们将完成这部分工作。
- en: '**The navigation graph holds details of all the app’s possible destinations,
    and how to get to them.**'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**导航图包含了所有应用可能的目标位置的详细信息，以及如何到达它们。**'
- en: Update the navigation graph
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新导航图
- en: 'To update the navigation graph, open the file *nav_graph.xml* (if it’s not
    already open), switch to the Code view, and update its code to include the changes
    shown here (in bold):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新导航图，打开文件 *nav_graph.xml*（如果尚未打开），切换到代码视图，并更新其代码以包含这里显示的更改（用粗体标出）：
- en: '![image](Images/f0444-02.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0444-02.png)'
- en: Now that you’ve updated the navigation graph, let’s link it to `MainActivity`
    so that it displays each fragment when we navigate to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更新了导航图，让我们将其链接到 `MainActivity`，以便在导航到每个片段时显示它。
- en: Display the current fragment in MainActivity’s layout
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 MainActivity 的布局中显示当前片段
- en: To display each fragment, we need to add a navigation host to `MainActivity`’s
    layout that’s linked to the navigation graph we just created. We’ll do this using
    a `FragmentContainerView`, just as we did in previous chapters.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示每个片段，我们需要向 `MainActivity` 的布局添加一个与我们刚刚创建的导航图链接的导航宿主。我们将使用 `FragmentContainerView`
    来实现，就像我们在前几章中所做的那样。
- en: 'You’re already familiar with the code to do this, so update *activity_main.xml*
    so that it matches the code below:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉如何完成这项任务的代码，所以请更新 *activity_main.xml*，使其与下面的代码匹配：
- en: '![image](Images/f0445-01.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0445-01.png)'
- en: 'When you’ve updated the layout, open *MainActivity.kt* and make sure it matches
    the code shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新了布局后，打开 *MainActivity.kt* 并确保其与这里显示的代码匹配：
- en: '![image](Images/f0445-02.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0445-02.png)'
- en: That’s everything we need for `MainActivity`. Next, let’s update the code for
    the two fragments, starting with `GameFragment`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `MainActivity` 需要的一切。接下来，让我们从两个片段的代码开始更新，首先是 `GameFragment`。
- en: Update GameFragment’s layout
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 GameFragment 的布局
- en: '`GameFragment` is the app’s main screen, and it’s what the user will use to
    play the guessing game. We need to add several views to its layout to enable this:
    three text views for the word to guess, the number of lives left and the incorrect
    guesses that have been made, an edit text for typing guesses into, and a button
    to make the guess.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameFragment`是应用程序的主屏幕，用户将使用它来玩猜字游戏。我们需要向其布局中添加几个视图以实现这一点：三个文本视图用于猜测的单词、剩余生命值和已经猜错的猜测，一个用于输入猜测的编辑文本，以及一个用于进行猜测的按钮。'
- en: 'Add these views to the layout by updating the code in *fragment_game.xml* so
    it matches the code shown below:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新*fragment_game.xml*中的代码，将这些视图添加到布局中，使其与下面显示的代码匹配：
- en: '![image](Images/f0446-02.png)![image](Images/f0447-02.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0446-02.png)![图片](Images/f0447-02.png)'
- en: That’s everything we need to include in `GameFragment`’s layout. Next, let’s
    tell the game how to behave by updating its Kotlin code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要包含在`GameFragment`布局中的所有内容。接下来，让我们通过更新其 Kotlin 代码告诉游戏如何行为。
- en: What GameFragment needs to do
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`GameFragment`需要做什么'
- en: 'In the first version of the app, *GameFragment.kt* needs to include all of
    the code that’s needed to play the game, as well as updating the screen and enabling
    navigation. It needs to:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的第一个版本中，*GameFragment.kt*需要包含所有玩游戏所需的代码，以及更新屏幕和启用导航。它需要：
- en: '![Images](Images/star.png) **Choose a word at random.**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **随机选择一个单词。**'
- en: We’ll provide it with a list of possible words to choose from.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将为其提供一个可供选择的可能单词列表。
- en: '![Images](Images/star.png) **Let the user guess a letter.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **让用户猜一个字母。**'
- en: '![Images](Images/star.png) **Respond to the guess.**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **响应猜测。**'
- en: If the user guesses correctly, `GameFragment` needs to add the letter to a list
    of correct guesses, and show where the letter appears in the word. If the guess
    is incorrect, it needs to add the guess to a `String` of incorrect guesses, and
    decrement the number of lives left.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果用户猜对了，`GameFragment`需要将该字母添加到正确猜测列表中，并显示该字母在单词中的位置。如果猜测错误，它需要将猜测添加到错误猜测的`String`中，并减少剩余生命值的数量。
- en: '![Images](Images/star.png) **Navigate to ResultFragment when the game is over.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **在游戏结束时导航到 ResultFragment。**'
- en: All of this code is pure Kotlin, or Android code that you’ve seen before. We’ll
    show you the full code over the next few pages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码都是纯 Kotlin，或者是您之前见过的 Android 代码。我们将在接下来的几页中展示完整的代码。
- en: The GameFragment.kt code
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GameFragment.kt`代码'
- en: 'Here’s the code for `GameFragment`; update the code in *GameFragment.kt* so
    that it matches the code shown below:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`GameFragment`的代码；更新*GameFragment.kt*中的代码，使其与下面显示的代码匹配：
- en: '![image](Images/f0448-02.png)![image](Images/f0449-02.png)![image](Images/f0450-02.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0448-02.png)![图片](Images/f0449-02.png)![图片](Images/f0450-02.png)'
- en: That’s all the code that we need for `GameFragment`. Next, let’s write the `ResultFragment`
    code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有`GameFragment`的代码。接下来，让我们编写`ResultFragment`的代码。
- en: Update ResultFragment’s layout
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 ResultFragment 的布局
- en: '`ResultFragment` uses a text view to tell the user whether she’s won or lost
    the game she’s just played, and a button to let her start another game. We need
    to add both of these views to the fragment’s layout.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultFragment`使用文本视图告诉用户她刚刚玩的游戏是赢了还是输了，并使用按钮让她开始另一场游戏。我们需要将这两个视图都添加到片段的布局中。'
- en: 'You’re already familiar with the code to do this, so open *fragment_result.xml*,
    and update it so that it matches the code shown below:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉如何做到这一点的代码，所以打开*fragment_result.xml*，并更新它，使其与下面显示的代码匹配：
- en: '![image](Images/f0451-02.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0451-02.png)'
- en: We also need to update ResultFragment.kt
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们还需要更新`ResultFragment.kt`
- en: Once we’ve added the text view and button to `ResultFragment`’s layout, we need
    to specify their behavior in the fragment’s Kotlin code. We’ll update the text
    view’s text with the result, and we’ll also make the button navigate back to `GameFragment`
    when it’s clicked.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将文本视图和按钮添加到`ResultFragment`的布局中，我们需要在片段的 Kotlin 代码中指定它们的行为。我们将更新文本视图的文本为结果，并且当点击按钮时，还将使其导航回`GameFragment`。
- en: We’ll show you the code for *ResultFragment.kt* on the next page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一页上展示*ResultFragment.kt*的代码。
- en: The ResultFragment.kt code
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ResultFragment.kt`代码'
- en: 'Here’s the code for `ResultFragment`; update *ResultFragment.kt* so it matches
    the code below:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ResultFragment`的代码；更新*ResultFragment.kt*，使其与下面的代码匹配：
- en: '![image](Images/f0452-02.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0452-02.png)'
- en: That’s all the code that we need for this version of the Guessing Game app.
    Let’s go through what happens when the code runs, and take the app for a test
    drive.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们这个版本的猜字游戏应用程序所需的所有代码。让我们看看代码运行时会发生什么，并测试一下这个应用程序。
- en: What happens when the app runs
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序运行时会发生什么
- en: 'The following things happen when the app runs:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时发生以下事情：
- en: '**The app is launched and GameFragment is displayed in MainActivity.**'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用程序启动并在MainActivity中显示GameFragment。**'
- en: '`GameFragment` sets `livesLeft` to 8, `correctGuesses` and `incorrectGuesses`
    to `""`, `secretWord` to a word it chooses at random, and `secretWordDisplay`
    to the value of `deriveSecretWordDisplay()`. It then calls its `updateScreen()`
    method, which displays the values of `livesLeft`, `incorrectGuesses`, and `secretWordDisplay`.'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameFragment`将`livesLeft`设置为8，`correctGuesses`和`incorrectGuesses`设置为`""`，`secretWord`设置为随机选择的单词，并将`secretWordDisplay`设置为`deriveSecretWordDisplay()`的值。然后调用其`updateScreen()`方法，显示`livesLeft`，`incorrectGuesses`和`secretWordDisplay`的值。'
- en: '![image](Images/f0453-02.png)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0453-02.png)'
- en: '**When the user makes a guess, GameFragment calls its makeGuess() method.**'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当用户猜测时，GameFragment调用其makeGuess()方法。**'
- en: The method checks if `secretWord` contains the letter the user has guessed.
    If it does, `makeGuess()` adds the letter to `correctGuesses` and updates `secretWordDisplay`.
    If it doesn’t, the method adds the letter to `incorrectGuesses`, and subtracts
    1 from `livesLeft`. It then calls `updateScreen()` again so that the new values
    are displayed.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法检查`secretWord`是否包含用户猜测的字母。如果包含，`makeGuess()`将该字母添加到`correctGuesses`并更新`secretWordDisplay`。如果不包含，该方法将字母添加到`incorrectGuesses`，并从`livesLeft`中减去1。然后再次调用`updateScreen()`，以便显示新值。
- en: '![image](Images/f0453-03.png)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0453-03.png)'
- en: '**After each guess, GameFragment checks if isWon() or isLost() is true.**'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**每次猜测后，GameFragment检查isWon()或isLost()是否为true。**'
- en: These methods check if the user has guessed all the letters in the word, or
    if she has run out of lives. If either method returns *true*, `GameFragment` passes
    the result to `ResultFragment`, which displays the result.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法检查用户是否猜出了单词中的所有字母，或者是否已经用完了生命。如果任一方法返回*true*，`GameFragment`将结果传递给`ResultFragment`，后者显示结果。
- en: '![image](Images/f0453-04.png)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0453-04.png)'
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![图片](Images/car.png) 测试驾驶'
- en: When we run the app, `GameFragment` is displayed. It shows how many letters
    the secret word has, and how many lives we have.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，会显示`GameFragment`。它显示秘密单词有多少个字母，以及我们有多少生命。
- en: We can make a guess by entering a letter in the edit text, and clicking the
    button. If we guess correctly, it places the letter in the secret word, but if
    we get it wrong, we lose a life.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在编辑文本中输入一个字母并点击按钮来猜测。如果我们猜对了，它会将字母放入秘密单词中，但如果我们猜错了，我们就会失去一条生命。
- en: If we guess all the letters or run out of lives, a message telling us whether
    we’ve won or lost is displayed in `ResultFragment`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们猜出所有字母或用完生命，将在`ResultFragment`中显示告诉我们是否赢了或输了的消息。
- en: '![image](Images/f0454-02.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0454-02.png)'
- en: The game seems to work, but what happens if we rotate the screen?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏似乎可以运行，但如果我们旋转屏幕会发生什么？
- en: The game loses state when the screen rotates
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕旋转时游戏会丢失状态
- en: There’s a problem with the game, however. If we rotate the screen when we’re
    in the middle of a game, the app loses its state and the game starts from the
    beginning.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，游戏存在一个问题。如果我们在游戏进行中旋转屏幕，应用程序会丢失状态，游戏将从头开始。
- en: '![image](Images/f0455-02.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0455-02.png)'
- en: The game loses its state because rotating the screen changes the app’s configuration,
    so Android destroys the activity (and the fragment it displays) and immediately
    recreates it. This resets the game’s views and properties.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕旋转会改变应用程序的配置，因此游戏会丢失状态，因此Android会销毁活动（以及显示的片段）并立即重新创建。这会重置游戏的视图和属性。
- en: We *could* solve this problem using the fragment’s `onSaveInstanceState` method
    to save the state of any properties, as we did earlier in the book. This time,
    however, we’re going to fix it by **implementing a view model** instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*使用片段的`onSaveInstanceState`方法来保存任何属性的状态，就像我们在本书中之前所做的那样。然而，这一次，我们将通过**实现视图模型**来解决这个问题。
- en: A view model holds business logic
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型保存业务逻辑
- en: '![image](Images/f0456-01.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0456-01.png)'
- en: As we said earlier, a view model is a separate class that sits alongside your
    activity or fragment code. It’s responsible for the data that needs to be displayed
    on the screen along with any business logic. In our Guessing Game app, for example,
    this means that the view model needs to hold the game’s properties—like the secret
    word the user needs to guess, and the number of lives left—and any methods that
    control how the game is played.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，视图模型是一个与您的活动或片段代码并列的独立类。它负责屏幕上需要显示的数据以及任何业务逻辑。在我们的Guessing Game应用中，例如，这意味着视图模型需要保存游戏的属性——例如用户需要猜测的秘密单词和剩余生命值——以及控制游戏如何进行的任何方法。
- en: When you implement a view model, all of the code relating to the app’s data
    or business logic is moved out of the activity or fragment, and into the view
    model. Any code that controls the UI—such as displaying text, or getting user
    input—stays in the activity or fragment code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现一个视图模型时，所有与应用程序数据或业务逻辑相关的代码都会移出活动或片段，并进入视图模型。任何控制UI的代码——例如显示文本或获取用户输入——都留在活动或片段代码中。
- en: 'This way of architecting Android apps follows a design principle known as *separation
    of concerns*. The app is split into different classes, where each class addresses
    a separate concern. A UI controller—the activity or fragment code—handles the
    UI, and the view model is responsible for the business logic and data:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种Android应用程序的架构方式遵循一个被称为*关注点分离*的设计原则。应用程序被分割成不同的类，每个类处理一个单独的关注点。UI控制器——活动或片段代码——负责UI，而视图模型负责业务逻辑和数据：
- en: '**Use a view model to simplify your activity and fragment code, and hold the
    state of any properties so that they survive configuration changes.**'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**使用视图模型简化你的活动和片段代码，并保存任何属性的状态，以便它们在配置更改后保持不变。**'
- en: '![image](Images/f0456-02.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0456-02.png)'
- en: Using this sort of app architecture has two key advantages.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种类型的应用程序架构有两个关键优势。
- en: '![Images](Images/star.png) **It simplifies your activity and fragment code.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **它简化了你的活动和片段代码。**'
- en: Moving the app’s data and business logic into a view model means that there’s
    less activity and fragment code for you to maintain.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将应用的数据和业务逻辑移动到视图模型中意味着你需要维护的活动和片段代码更少。
- en: '![Images](Images/star.png) **Your app survives configuration changes.**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **你的应用在配置更改后依然存在。**'
- en: The view model is a separate class that sits alongside your activity or fragment
    code. It’s not destroyed when you rotate the device screen, so the state of any
    properties held in the view model survives configuration changes without you having
    to add their values to a `Bundle`.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 视图模型是一个独立的类，与您的活动或片段代码并列。当您旋转设备屏幕时，它不会被销毁，因此视图模型中保存的任何属性的状态会在配置更改时保持不变，而不需要将它们的值添加到`Bundle`中。
- en: Now that you’ve learned what using a view model buys you, let’s see how to add
    one to the Guessing Game app.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了使用视图模型的好处，让我们看看如何将其添加到Guessing Game应用程序中。
- en: Add a view model dependency to the app build.gradle file…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用的 build.gradle 文件中添加视图模型依赖项…
- en: The view model library is part of Android Jetpack, so you need to update the
    app’s *build.gradle* file to include it as a dependency.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型库是Android Jetpack的一部分，因此您需要更新应用的*build.gradle*文件，以将其包含为一个依赖项。
- en: 'Open the file *GuessingGame/app/build.gradle*, and add the following line (in
    bold) to the dependencies section:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件*GuessingGame/app/build.gradle*，并在依赖项部分添加以下行（用粗体标注）：
- en: '![image](Images/f0457-02.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0457-02.png)'
- en: When prompted, sync your changes. You’re now ready to go ahead and create a
    view model.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时，同步您的更改。现在您已经准备好继续并创建一个视图模型了。
- en: …and create a view model
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …并创建一个视图模型
- en: We’re going to create a view model named `GameViewModel`, which `GameFragment`
    will use for its game logic and data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`GameViewModel`的视图模型，`GameFragment`将用它来处理游戏逻辑和数据。
- en: Select the *com.hfad.guessinggame* package in the *app/src/main/java* folder,
    then go to File→New→Kotlin Class/File. Name the file “GameViewModel” and choose
    the option to create a class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在*app/src/main/java*文件夹中选择*com.hfad.guessinggame*包，然后转到文件→新建→Kotlin类/文件。将文件命名为“GameViewModel”，并选择创建一个类的选项。
- en: 'When the *GameViewModel.kt* file has been created, update its code to match
    the code below (the changes are in bold):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完*GameViewModel.kt*文件后，更新其代码以匹配以下代码（更改部分已用粗体标注）：
- en: '![image](Images/f0457-03.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0457-03.png)'
- en: As you can see, the `GameViewModel` class extends `androidx.lifecycle.ViewModel`.
    `ViewModel` is an abstract class that’s used to turn a plain old class into a
    card-carrying view model.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`GameViewModel` 类继承自 `androidx.lifecycle.ViewModel`。`ViewModel` 是一个抽象类，用于将普通类转变为一个具备身份的视图模型。
- en: Now that we’ve added `GameViewModel` to the Guessing Game project and turned
    it into a view model, let’s write the rest of its code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `GameViewModel` 添加到猜谜游戏项目并将其转变为视图模型，让我们编写其余代码。
- en: The full code for GameViewModel.kt
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GameViewModel.kt` 的完整代码如下：'
- en: As you’ve already learned, the view model is responsible for an activity or
    fragment’s business logic and data. For the Guessing Game app, this means that
    we need to take all of `GameFragment`’s properties and methods that relate to
    how the game is played, and move them into `GameViewModel`. We’ll leave any code
    relating to navigation or the UI in `GameFragment`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经学到的，视图模型负责活动或片段的业务逻辑和数据。对于猜谜游戏应用程序，这意味着我们需要将所有与游戏进行相关的 `GameFragment` 的属性和方法移动到
    `GameViewModel` 中。我们将任何与导航或 UI 相关的代码留在 `GameFragment` 中。
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include the
    changes (in bold):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *GameViewModel.kt* 的完整代码；请更新代码以包含以下更改（加粗显示）：
- en: '![image](Images/f0458-02.png)![image](Images/f0459-02.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0458-02.png)![image](Images/f0459-02.png)'
- en: That’s everything that we need for `GameViewModel`. Next, let’s link it to `GameFragment`,
    and update the code for that fragment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的关于 `GameViewModel` 的所有内容。接下来，让我们将其链接到 `GameFragment`，并更新该片段的代码。
- en: Create a GameViewModel object
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `GameViewModel` 对象。
- en: 'To link a view model to an activity or fragment, you need to add a `ViewModel`
    property to the code, and initialize it with a `ViewModel` object, which you need
    to create. The code looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要将视图模型链接到活动或片段，您需要在代码中添加 `ViewModel` 属性，并用需要创建的 `ViewModel` 对象进行初始化。代码如下所示：
- en: '![image](Images/f0460-02.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0460-02.png)'
- en: As you can see, the above code uses a **view model provider** to create the
    `ViewModel` object. So what does using this class do?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，上述代码使用 **视图模型提供程序** 创建 `ViewModel` 对象。那么，使用这个类有什么作用呢？
- en: Use a ViewModelProvider to create view models
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `ViewModelProvider` 创建视图模型。
- en: As its name suggests, `ViewModelProvider` is a special class whose job is to
    provide activities and fragments with view models. It ensures that **a new view
    model object only gets created if one doesn’t already exist**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`ViewModelProvider` 是一个特殊的类，其工作是为活动和片段提供视图模型。它确保 **只有在不存在视图模型对象时才会创建一个新的视图模型对象**。
- en: As you already know, when the screen is rotated, any fragments that are displayed
    on the screen get destroyed and recreated. When this happens, the view model provider
    makes sure that the same view model object continues to be used. The view model
    keeps its state, so any properties that are used by the fragment don’t get reset.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你已了解的，当屏幕旋转时，显示在屏幕上的任何片段都会被销毁并重新创建。在此过程中，视图模型提供程序确保继续使用相同的视图模型对象。视图模型保持其状态，因此片段使用的任何属性都不会被重置。
- en: The view model provider keeps hold of the view model so long as the activity
    or fragment stays alive. When a fragment is detached or removed from its activity,
    for example, the view model provider lets go of the fragment’s view model. The
    next time the view model provider is asked to provide a view model object, it
    creates a new one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型提供程序在活动或片段保持活跃时保持视图模型。例如，当片段被分离或从其活动中移除时，视图模型提供程序释放片段的视图模型。下次要求提供视图模型对象时，它会创建一个新的对象。
- en: '![image](Images/f0460-03.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0460-03.png)'
- en: Now that you’ve learned how to link a view model to a fragment, let’s update
    the `GameFragment` code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何将视图模型链接到片段，让我们更新 `GameFragment` 的代码。
- en: The updated code for GameFragment.kt
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GameFragment.kt` 的更新代码如下：'
- en: We need to remove the properties and methods from `GameFragment` that we moved
    to `GameViewModel`, and make the fragment use the view model instead.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 `GameFragment` 中移除已经转移到 `GameViewModel` 中的属性和方法，并确保片段使用视图模型。
- en: 'Here’s the updated code for `GameFragment`; make sure that the file *GameFragment.kt*
    includes the changes shown below (in bold):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的 `GameFragment` 代码；确保文件 *GameFragment.kt* 包含以下所示的更改（加粗显示）：
- en: '![image](Images/f0461-02.png)![image](Images/f0462-02.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0461-02.png)![image](Images/f0462-02.png)'
- en: Those are all the changes that we need to make to `GameFragment`. Let’s go through
    what the code does when it runs, and take it for a test drive.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要对 `GameFragment` 进行的所有更改。让我们仔细分析代码在运行时的行为，并进行测试。
- en: What happens when the app runs
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序运行时会发生什么
- en: 'The following things happen when the app runs:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行时发生以下事件：
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment向ViewModelProvider类请求GameViewModel的实例。**'
- en: The view model provider sees that there’s no existing `GameViewModel` object
    associated with the fragment, so it creates a new one.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 视图模型提供程序发现该片段尚未关联到现有的`GameViewModel`对象，因此创建一个新对象。
- en: '![image](Images/f0463-02.png)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0463-02.png)'
- en: '**The GameViewModel object is initialized.**'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameViewModel对象被初始化。**'
- en: It sets `livesLeft` to 8, `correctGuesses` and `incorrectGuesses` to `""`, `secretWord`
    to a word it chooses at random, and `secretWordDisplay` to `deriveSecretWordDisplay()`.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`livesLeft`设置为8，将`correctGuesses`和`incorrectGuesses`设置为空字符串，将`secretWord`设置为随机选择的单词，并将`secretWordDisplay`设置为`deriveSecretWordDisplay()`。
- en: '![image](Images/f0463-03.png)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0463-03.png)'
- en: '**GameFragment calls its updateScreen() method.**'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment调用其updateScreen()方法。**'
- en: The method accesses the `GameViewModel` object’s `secretWordDisplay`, `livesLeft`,
    and `incorrectGueses` properties, and shows them on the screen.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法访问`GameViewModel`对象的`secretWordDisplay`、`livesLeft`和`incorrectGueses`属性，并在屏幕上显示它们。
- en: '![image](Images/f0463-04.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0463-04.png)'
- en: '**When the user makes a guess, GameFragment calls the GameViewModel object’s
    makeGuess() method.**'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当用户猜测时，GameFragment调用GameViewModel对象的makeGuess()方法。**'
- en: The method checks if `secretWord` contains the letter the user guesses. If it
    does, it adds the letter to `correctGuesses` and updates `secretWordDisplay`.
    If it doesn’t, it adds it to `incorrectGuesses`, and subtracts 1 from `livesLeft`.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法检查`secretWord`是否包含用户猜测的字母。如果是，将字母添加到`correctGuesses`并更新`secretWordDisplay`；如果不是，将其添加到`incorrectGuesses`，并从`livesLeft`中减去1。
- en: '![image](Images/f0464-02.png)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0464-02.png)'
- en: '**GameFragment calls its updateScreen() method again.**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment再次调用其updateScreen()方法。**'
- en: The method gets the updated property values from the `GameViewModel` object,
    and updates the screen.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法从`GameViewModel`对象获取更新的属性值，并更新屏幕。
- en: '![image](Images/f0464-03.png)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0464-03.png)'
- en: '**After each guess, GameFragment checks if the view model’s isWon() or isLost()
    methods return true.**'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**每次猜测后，GameFragment检查视图模型的isWon()或isLost()方法是否返回true。**'
- en: If either method returns *true*, `GameFragment` passes the result to `ResultFragment`,
    which displays the result.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果任一方法返回*true*，`GameFragment`将结果传递给`ResultFragment`，后者显示结果。
- en: '![image](Images/f0464-04.png)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0464-04.png)'
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) Test Drive'
- en: '![image](Images/f0465-01.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0465-01.png)'
- en: When we run the app, `GameFragment` is displayed as before. If we start playing
    the game and rotate the screen, the game retains its state.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，`GameFragment`会像以前一样显示。如果我们开始玩游戏并旋转屏幕，则游戏保留其状态。
- en: '![image](Images/f0465-02.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0465-02.png)'
- en: You’ve now learned how to add a view model to your apps, and used it to avoid
    the problems that can occur when the user rotates the device screen. Before we
    go any further, let’s take a closer look at view models.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经学会了如何向您的应用程序添加视图模型，并使用它来避免用户旋转设备屏幕时可能出现的问题。在继续之前，让我们更深入地了解视图模型。
- en: BE the View Model
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BE the View Model
- en: '![image](Images/common04.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common04.png)'
- en: '**The code below describes a view model class named MyViewModel. Your job is
    to play like you’re the view model, and say what problems there are with this
    code and how they could be fixed.**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下代码描述了名为MyViewModel的视图模型类。你的任务是扮演视图模型，指出此代码存在的问题以及如何修复。**'
- en: '[PRE0]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Images](Images/arr.png) **Answers in [“BE the View Model Solution”](#be_the_view_model_solution).**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在 [“BE the View Model Solution”](#be_the_view_model_solution)。**'
- en: We’ve added a view model for GameFragment
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们已为GameFragment添加了一个视图模型
- en: '![image](Images/f0469-01.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0469-01.png)'
- en: So far, we’ve updated the Guessing Game app so that `GameFragment` uses a view
    model named `GameViewModel`, which is responsible for all of the fragment’s business
    logic and data. Using a view model in this way simplifies the code in *GameFragment.kt*,
    and means that the app doesn’t lose its state when the screen is rotated.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已更新了猜字游戏应用程序，使其使用名为`GameViewModel`的视图模型，该模型负责所有片段的业务逻辑和数据。这种方式使用视图模型简化了*GameFragment.kt*中的代码，并意味着当屏幕旋转时，应用程序不会丢失其状态。
- en: '![image](Images/f0469-02.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0469-02.png)'
- en: ResultFragment needs a view model too
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ResultFragment`也需要一个视图模型'
- en: Each view model you create is associated with a single UI controller—an activity
    or fragment. This means that if we want `ResultFragment` to use a view model too,
    we need to create a new one for this fragment.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的每个视图模型都与单个UI控制器（活动或片段）相关联。这意味着，如果我们希望`ResultFragment`也使用视图模型，我们需要为此片段创建一个新的视图模型。
- en: '![image](Images/f0469-03.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0469-03.png)'
- en: Let’s do this now. Highlight the *com.hfad.guessinggame* package in the *app/src/main/java*
    folder, then go to File→New→Kotlin Class/File. Name the file “ResultViewModel”
    and choose the option to create a class.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始吧。在*app/src/main/java*文件夹中突出显示*com.hfad.guessinggame*包，然后转到文件→新建→Kotlin类/文件。命名文件为“ResultViewModel”，并选择创建类的选项。
- en: 'When the *ResultViewModel.kt* file has been created, update its code to match
    ours below (our changes are in bold):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*ResultViewModel.kt*文件后，请更新其代码以匹配下面的代码（我们的更改用粗体标出）：
- en: '![image](Images/f0469-04.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0469-04.png)'
- en: That’s the basic code you need to define a view model. So what other code do
    we need to add?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义视图模型所需的基本代码。那么我们需要添加哪些其他代码呢？
- en: ResultViewModel needs to hold the result
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResultViewModel需要保存结果
- en: As you may recall, `ResultFragment` displays a message in its layout that tells
    the user whether they’ve won or lost the game they’ve just played. This message
    is passed to `ResultFragment` by `GameFragment` when the game is over.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的那样，`ResultFragment`在其布局中显示一条消息，告诉用户他们刚刚玩的游戏是赢了还是输了。当游戏结束时，`GameFragment`会将此消息传递给`ResultFragment`。
- en: In the new version of the app, `ResultViewModel` is responsible for `ResultFragment`’s
    game logic and data, so we need to add a property to `ResultViewModel` to store
    the result. We’ll also use a `String` constructor to make sure this property gets
    set as soon as `ResultViewModel` gets created.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本的应用程序中，`ResultViewModel`负责`ResultFragment`的游戏逻辑和数据，因此我们需要向`ResultViewModel`添加一个属性来存储结果。我们还将使用一个`String`构造函数，以确保此属性在创建`ResultViewModel`时立即设置。
- en: 'Here’s the full code for *ResultViewModel.kt*; update its code to include the
    changes below (in bold):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*ResultViewModel.kt*的完整代码；更新其代码以包括以下更改（以粗体显示）：
- en: '![image](Images/f0470-02.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0470-02.png)'
- en: Next, we’ll update `ResultFragment` so that it uses the new view model.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`ResultFragment`，以便它使用新的视图模型。
- en: We need to link ResultViewModel to ResultFragment
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要将ResultViewModel链接到ResultFragment
- en: 'Earlier, we were able to add a `GameViewModel` reference to `GameFragment`
    using this code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们能够使用以下代码将`GameViewModel`引用添加到`GameFragment`：
- en: '![image](Images/f0470-03.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0470-03.png)'
- en: This tells the view model provider to get the `GameViewModel` object that’s
    linked to the fragment, or create a new one if it doesn’t already exist.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉视图模型提供者获取与片段链接的`GameViewModel`对象，或者如果不存在则创建一个新的对象。
- en: The above approach, however, can’t be used to add a `ResultViewModel` reference
    to `ResultFragment`. This is because it **only works for view models with a no
    argument constructor**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述方法不能用于向`ResultFragment`添加`ResultViewModel`的引用。这是因为它**仅适用于没有参数构造函数的视图模型**。
- en: The code worked for `GameViewModel` because we could construct it without passing
    any arguments. The constructor for the `ResultViewModel` class, however, requires
    a `String`, so the above code won’t work.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码适用于`GameViewModel`，因为我们可以在不传递任何参数的情况下构造它。但是，`ResultViewModel`类的构造函数需要一个`String`，因此上述代码不起作用。
- en: A view model factory creates view models
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型工厂创建视图模型
- en: 'An alternative way of creating a view model is to pass the view model provider
    a **view model factory**: a separate class whose sole purpose is to create and
    initialize view models. This approach means that the view model provider doesn’t
    have to worry about creating a view model by itself. Instead, it uses the view
    model factory.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图模型的另一种方法是将视图模型提供者传递给**视图模型工厂**：这是一个单独的类，其唯一目的是创建和初始化视图模型。这种方法意味着视图模型提供者无需自己创建视图模型。相反，它使用视图模型工厂。
- en: 'While view model factories can be used for any sort of view model, they’re
    mostly used for ones whose constructors require arguments. This is because the
    view model provider can’t pass arguments to the constructor by itself: it needs
    a view model factory to do so.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然视图模型工厂可用于任何类型的视图模型，但它们主要用于需要参数的视图模型。这是因为视图模型提供者无法自己传递参数到构造函数：它需要视图模型工厂来完成。
- en: 'Here’s how the view model factory will be used in the Guessing Game app:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在猜谜游戏应用程序中使用视图模型工厂的方法：
- en: '**Use a view model factory to create a view model that doesn’t have a no-argument
    constructor.**'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**使用视图模型工厂创建一个没有无参构造函数的视图模型。**'
- en: '**We’ll define a class named ResultViewModelFactory, which ResultFragment will
    use to create a factory object.**'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们将定义一个名为`ResultViewModelFactory`的类，`ResultFragment`将用它来创建一个工厂对象。**'
- en: '![image](Images/f0471-02.png)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0471-02.png)'
- en: '**ResultFragment will tell the view model provider to use the factory object.**'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ResultFragment`将告诉视图模型提供者使用工厂对象。**'
- en: '![image](Images/f0471-03.png)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0471-03.png)'
- en: '**When the view model provider needs a new ResultViewModel object, it will
    use the ResultViewModelFactory.**'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当视图模型提供者需要一个新的`ResultViewModel`对象时，它将使用`ResultViewModelFactory`。**'
- en: '![image](Images/f0471-04.png)'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0471-04.png)'
- en: Let’s go ahead and add a factory class to the Guessing Game app.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在猜谜游戏应用中添加一个工厂类。
- en: Create the ResultViewModelFactory class
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`ResultViewModelFactory`类
- en: We’re going to add a view model factory class named `ResultViewModelFactory`
    to the Guessing Game app. This class will be used by the view model provider to
    create a `ResultViewModel` object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在猜谜游戏应用中添加一个名为`ResultViewModelFactory`的视图模型工厂类。该类将被视图模型提供者用于创建`ResultViewModel`对象。
- en: To create the class, highlight the *com.hfad.guessinggame* package in the *app/src/main/java*
    folder, then go to File→New→Kotlin Class/File. Name the file “ResultViewModelFactory”
    and choose the option to create a class.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建该类，请在*app/src/main/java*文件夹中突出显示*com.hfad.guessinggame*包，然后转到“文件”→“新建”→“Kotlin类/文件”。将文件命名为“ResultViewModelFactory”，并选择创建类。
- en: 'When the *ResultViewModelFactory.kt* file has been created, update its code
    to match ours below (our changes are in bold):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当*ResultViewModelFactory.kt*文件被创建后，请更新其代码以匹配我们下面展示的（我们的更改用粗体标注）：
- en: '![image](Images/f0472-02.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0472-02.png)'
- en: As you can see, the `ResultViewModelFactory` class implements an interface named
    `ViewModelProvider.Factory`, and overrides its `create()` method. This turns the
    class into a view model factory, which the view model provider can use to create
    a `ResultViewModel` object.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`ResultViewModelFactory`类实现了一个名为`ViewModelProvider.Factory`的接口，并重写了其`create()`方法。这将该类转换为视图模型工厂，视图模型提供者可以使用它来创建`ResultViewModel`对象。
- en: The above code is everything we need for `ResultViewModelFactory`. Let’s find
    out how to use it in our `ResultFragment` code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们需要的所有`ResultViewModelFactory`。让我们看看如何在`ResultFragment`代码中使用它。
- en: Use the factory to create the view model
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂创建视图模型
- en: As we said earlier, you use a view model factory to create a view model by passing
    the factory to the view model provider. The view model provider decides when a
    new view model object is required, and when necessary, uses the factory to create
    one.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，您可以通过将工厂传递给视图模型提供者来使用视图模型工厂来创建视图模型。视图模型提供者决定何时需要一个新的视图模型对象，并在必要时使用工厂来创建一个。
- en: 'The code to make the view model provider use a view model factory is virtually
    identical for every view model you want to create. It looks like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让视图模型提供者使用视图模型工厂，创建每个想要的视图模型几乎完全相同的代码。看起来是这样的：
- en: '![image](Images/f0473-02.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0473-02.png)'
- en: 'As you can see, the above code defines two properties: `viewModel` and `viewModelFactory`.
    These are set in the fragment’s `onCreateView()` method.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，上述代码定义了两个属性：`viewModel`和`viewModelFactory`。这些属性在片段的`onCreateView()`方法中设置。
- en: In `onCreateView()`, the code uses the result `String` that’s passed to it from
    `GameFragment` to create a new `ResultViewModelFactory` object. It passes the
    factory to the view model provider, which uses it to get a `ResultViewModel` object.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateView()`中，代码使用从`GameFragment`传递给它的结果`String`来创建一个新的`ResultViewModelFactory`对象。它将工厂传递给视图模型提供者，后者使用它来获取`ResultViewModel`对象。
- en: Now that you know how to use a factory to link a view model to a fragment, let’s
    update the `ResultFragment` code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用工厂将视图模型与片段链接后，让我们更新`ResultFragment`的代码。
- en: '![image](Images/f0473-03.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0473-03.png)'
- en: The updated code for ResultFragment.kt
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ResultFragment.kt`的更新代码'
- en: 'Here’s the full code for `ResultFragment`, so update the code in file *ResultFragment.kt*
    so it includes the changes shown below (in bold):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ResultFragment`的完整代码，请更新*ResultFragment.kt*文件中的代码，包括下面显示的更改（用粗体标注）：
- en: '![image](Images/f0474-02.png)![image](Images/f0475-02.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0474-02.png)![image](Images/f0475-02.png)'
- en: Those are all the changes that we need to make to `ResultFragment`. After some
    questions, we’ll go through what happens when the app runs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要对`ResultFragment`进行的所有更改。经过一些问题后，我们将详细说明应用程序运行时发生的情况。
- en: What happens when the app runs
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序运行时发生的情况
- en: 'The following things happen when the app runs:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，会发生以下事情：
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment请求ViewModelProvider类获取GameViewModel的实例。**'
- en: The `GameViewModel` object is initialized, and chooses a word at random.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameViewModel`对象被初始化，并随机选择一个单词。'
- en: '![image](Images/f0476-02.png)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0476-02.png)'
- en: '**GameFragment interacts with the GameViewModel object.**'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment与GameViewModel对象交互。**'
- en: The `GameViewModel` object records any guesses the user has made, and keeps
    track of the number of lives left.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameViewModel`对象记录用户做出的任何猜测，并跟踪剩余生命次数。'
- en: '![image](Images/f0476-03.png)'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0476-03.png)'
- en: '**After each guess, GameFragment checks if the view model’s isWon() or isLost()
    methods return true.**'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**每次猜测后，GameFragment检查视图模型的isWon()或isLost()方法是否返回true。**'
- en: If either method is *true*, `GameFragment` navigates to `ResultFragment`, passing
    it the result.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果任一方法为*true*，`GameFragment`将导航到`ResultFragment`，并传递结果。
- en: '![image](Images/f0476-04.png)'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0476-04.png)'
- en: '**ResultFragment creates a ResultViewModelFactory object, passing it the result
    String.**'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ResultFragment创建ResultViewModelFactory对象，并传递结果字符串。**'
- en: '![image](Images/f0477-02.png)'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-02.png)'
- en: '**ResultFragment asks the ViewModelProvider class for an instance of ResultViewModel.**'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ResultFragment请求ViewModelProvider类获取ResultViewModel的实例。**'
- en: The `ViewModelProvider` class sees that there’s no existing `ResultViewModel`
    object, so it uses the `ResultViewModelFactory` to create one. The `ResultViewModel`
    object’s `result` property is initialized with the result `String`.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ViewModelProvider`类发现没有现有的`ResultViewModel`对象，因此使用`ResultViewModelFactory`创建一个。`ResultViewModel`对象的`result`属性初始化为结果`String`。'
- en: '![image](Images/f0477-03.png)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-03.png)'
- en: '**ResultFragment gets the result String from the ResultViewModel object, and
    displays it on the screen.**'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ResultFragment从ResultViewModel对象获取结果字符串，并在屏幕上显示。**'
- en: '![image](Images/f0477-04.png)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-04.png)'
- en: Let’s take the app for a test drive.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下这个应用程序。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![图片](Images/car.png) 测试驾驶'
- en: '![image](Images/f0478-01.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0478-01.png)'
- en: When we run the app, `GameFragment` is displayed as before.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，`GameFragment`像以前一样显示。
- en: If we guess all the letters or lose all our lives, the app navigates to `ResultFragment`.
    A message is displayed telling us whether we won or lost, and what the secret
    word was.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们猜对所有字母或失去所有生命，应用程序将导航到`ResultFragment`。会显示一条消息告诉我们是否赢了或输了，以及秘密单词是什么。
- en: '![image](Images/f0478-02.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0478-02.png)'
- en: The game behaves in the same way as it did before, but behind the scenes, it’s
    now using view models for its game logic and data.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的行为方式与以前相同，但在幕后，现在使用视图模型处理游戏逻辑和数据。
- en: View Model Magnets
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型磁铁
- en: '![image](Images/common02.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common02.png)'
- en: 'Here’s the code to define a view model named `GiftViewModel`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义名为`GiftViewModel`的视图模型的代码：
- en: '[PRE1]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See if you can piece together the code for the view model factory class that
    will be used to create `GiftViewModel` objects.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否组合出用于创建`GiftViewModel`对象的视图模型工厂类的代码。
- en: '![image](Images/f0479-01.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0479-01.png)'
- en: View Model Magnets Solution
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型磁铁解决方案
- en: '![image](Images/common02.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common02.png)'
- en: 'Here’s the code to define a view model named `GiftViewModel`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义名为`GiftViewModel`的视图模型的代码：
- en: '[PRE2]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See if you can piece together the code for the view model factory class that
    will be used to create `GiftViewModel` objects.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否组合出用于创建`GiftViewModel`对象的视图模型工厂类的代码。
- en: '![image](Images/f0480-01.png)![image](Images/f0480-02.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0480-01.png)![图片](Images/f0480-02.png)'
- en: BE the View Model Solution
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BE the View Model解决方案
- en: '![image](Images/common04.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common04.png)'
- en: '**The code below describes a view model class named MyViewModel. Your job is
    to play like you’re the view model, and say what problems there are with this
    code and how they could be fixed.**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**下面的代码描述了一个名为MyViewModel的视图模型类。您的工作是扮演视图模型的角色，并指出代码中存在的问题以及如何修复它们。**'
- en: '![image](Images/f0481-01.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0481-01.png)'
- en: Your Android Toolbox
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Android工具箱
- en: '![image](Images/tools.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/tools.png)'
- en: '**You’ve got [Chapter 11](#view_modelscolon_model_behavior) under your belt
    and now you’ve added view models to your toolbox.**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**您已经掌握了[第11章](#view_modelscolon_model_behavior)，现在将视图模型添加到您的工具箱中。**'
- en: '![image](Images/f0482-01.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0482-01.png)'
