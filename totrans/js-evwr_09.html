<html><head></head><body><section data-pdf-bookmark="Chapter 8. User Actions" data-type="chapter" epub:type="chapter"><div class="chapter" id="user-actions">&#13;
<h1><span class="label">Chapter 8. </span>User Actions</h1>&#13;
&#13;
&#13;
<p><a data-primary="user actions" data-type="indexterm" id="ix_ch08-asciidoc0"/>Imagine<a data-primary="user actions" data-secondary="about" data-type="indexterm" id="idm45339504656952"/> you had just joined a club (remember the “Secret Club for Super Cool People”?), but when you showed up for the first time there was nothing to do. The club was a big, empty room with people wandering in and out with no way of interacting with the club or one another. I’m a bit of an introvert, so this doesn’t sound <em>that</em> bad, but I wouldn’t be willing to pay a membership fee for it.</p>&#13;
&#13;
<p>Right now our API is essentially a big, useless club. We have a way to create data and a way for users to sign in, but nothing allows a user to own that data. In this chapter, we’ll be addressing this by adding user interactions. We’ll write the code that will enable a user to own the notes they create, limit who can delete or modify a note, and enable users to “favorite” a note that they like. Additionally, we’ll enable API users to make nested queries, allowing our UIs to write simple queries that relate users to notes.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Before We Get Started" data-type="sect1"><div class="sect1" id="idm45339504654024">&#13;
<h1>Before We Get Started</h1>&#13;
&#13;
<p>In this chapter, we’ll be making some pretty significant changes to our notes files. Since we have a small amount of data in our database, you may find it easier to remove the existing notes from your local database. This isn’t necessary, but can reduce confusion as you work through this chapter.</p>&#13;
&#13;
<p>To do this, we’ll go into the MongoDB shell, ensure that we’re referencing the <code>notedly</code> database (the name of the database in our <em>.env</em> file), and use MongoDB’s <a data-primary=".remove()" data-type="indexterm" id="idm45339504651128"/><code>.remove()</code> method. From your terminal, type the following:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>mongo&#13;
<code class="nv">$ </code>use notedly&#13;
<code class="nv">$ </code>db.notes.remove<code class="o">({})</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Attach a User to New Notes" data-type="sect1"><div class="sect1" id="idm45339504627384">&#13;
<h1>Attach a User to New Notes</h1>&#13;
&#13;
<p><a data-primary="user actions" data-secondary="attaching a user to new notes" data-type="indexterm" id="ix_ch08-asciidoc1"/>In the previous chapter we updated our <em>src/index.js</em> file so that when a user makes a request, we check for a JWT. If the token exists, we decode it and add the current user to our GraphQL context. This allows us to send the user’s information to each resolver function that we call. We’ll update our existing GraphQL mutations to verify the user’s information. To do this we’ll utilize Apollo Server’s <a data-primary="AuthenticationError" data-type="indexterm" id="idm45339504622280"/><code>AuthenticationError</code> and <a data-primary="ForbiddenError" data-type="indexterm" id="idm45339504621192"/><code>ForbiddenError</code> methods, which will allow us to throw appropriate errors. These will help us both debug in development as well as send appropriate responses to the client.</p>&#13;
&#13;
<p>Before we get started, we’ll need to import the <code>mongoose</code> package into our <em>mutations.js</em> resolver file. This will allow us to appropriately assign cross-referencing MongoDB object IDs to our fields. Update the module imports at the top of <em>src/resolvers/</em><span class="keep-together"><em>mutation.js</em></span> as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">mongoose</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'mongoose'</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now, in our <a data-primary="newNote" data-secondary="and user parameters" data-type="indexterm" id="idm45339504614008"/><code>newNote</code> mutation, we’ll add <code>user</code> as a function parameter, then check to see if a user is passed into the function. If a user ID is not found, we’ll throw an <code>AuthenticationError</code>, as a person must be signed in to our service to create a new note. Once we have verified that the request has been made by an authenticated user, we can create the note in the database. In doing so, we will now assign the author  the user ID that is passed to the resolver. This will allow us to reference the creating user from the note itself.</p>&#13;
&#13;
<p>In <em>src/resolvers/mutation.js</em>, add the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// add the users context</code>&#13;
<code class="nx">newNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code><code class="p">,</code> <code class="nx">user</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// if there is no user on the context, throw an authentication error</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">user</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">AuthenticationError</code><code class="p">(</code><code class="s1">'You must be signed in to create a note'</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
    <code class="c1">// reference the author's mongo id</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Types</code><code class="p">.</code><code class="nx">ObjectId</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">},</code></pre>&#13;
&#13;
<p>The last step is to apply the cross-referencing to the data in our database. To do this, we will need to update the <code>author</code> field of our MongoDB notes schema. In <em>/src/models/note.js</em>, update the <code>author</code> field as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">author</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">.</code><code class="nx">Types</code><code class="p">.</code><code class="nx">ObjectId</code><code class="p">,</code>&#13;
  <code class="nx">ref</code><code class="o">:</code> <code class="s1">'User'</code><code class="p">,</code>&#13;
  <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this reference in place, all new notes will accurately record and cross-reference the author from the context of the request. Let’s try this out by writing a <code>newNote</code> mutation in the GraphQL Playground:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code><code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="s2">"Hello! This is a user-created note"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">content</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When writing the mutation, we also must be sure to pass a JWT in the <span class="keep-together"><code>Authorization</code></span> header (see <a data-type="xref" href="#user_newnote">Figure 8-1</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"Authorization"</code><code class="o">:</code> <code class="s2">"&lt;YOUR_JWT&gt;"</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="tip"><h1>How to Retrieve a JWT</h1>&#13;
<p>If you don’t have the JWT handy, you can perform a <code>signIn</code> mutation to retrieve one.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="user_newnote">&#13;
<img alt="Screenshot of the newNote mutation in the GraphQL Playground" src="assets/jsev_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>A newNote mutation in the GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p>For now, our API doesn’t return the author information, but we can verify that the author was added correctly by looking up the note in the MongoDB shell. In a terminal window, type the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mongo</code>&#13;
<code class="nx">db</code><code class="p">.</code><code class="nx">notes</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">_id</code><code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"A DOCUMENT ID HERE"</code><code class="p">)})</code></pre>&#13;
&#13;
<p>The returned value should include an author key, with a value of an object ID.<a data-startref="ix_ch08-asciidoc1" data-type="indexterm" id="idm45339504360248"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="User Permissions for Updates and Deletes" data-type="sect1"><div class="sect1" id="idm45339504626792">&#13;
<h1>User Permissions for Updates and Deletes</h1>&#13;
&#13;
<p><a data-primary="deleteNote mutation" data-type="indexterm" id="idm45339504358328"/><a data-primary="permissions, user" data-type="indexterm" id="idm45339504357400"/><a data-primary="updateNote mutation" data-type="indexterm" id="idm45339504356728"/><a data-primary="user actions" data-secondary="user permissions for updates and deletes" data-type="indexterm" id="idm45339504356056"/><a data-primary="user permissions" data-type="indexterm" id="idm45339504355016"/>Now we can add user checks to our <code>deleteNote</code> and <code>updateNote</code> mutations as well. These will require that we check both that a user is passed to the context and whether that user is the owner of the note. To accomplish this, we’ll check if the user ID stored in the <code>author</code> field of our database matches the user ID that is passed into the resolver context.</p>&#13;
&#13;
<p>In <em>src/resolvers/mutation.js</em>, update the <code>deleteNote</code> mutation as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">deleteNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">id</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code><code class="p">,</code> <code class="nx">user</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// if not a user, throw an Authentication Error</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">user</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">AuthenticationError</code><code class="p">(</code><code class="s1">'You must be signed in to delete a note'</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// find the note</code>&#13;
  <code class="kr">const</code> <code class="nx">note</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="c1">// if the note owner and current user don't match, throw a forbidden error</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">note</code> <code class="o">&amp;&amp;</code> <code class="nb">String</code><code class="p">(</code><code class="nx">note</code><code class="p">.</code><code class="nx">author</code><code class="p">)</code> <code class="o">!==</code> <code class="nx">user</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">ForbiddenError</code><code class="p">(</code><code class="s2">"You don't have permissions to delete the note"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="c1">// if everything checks out, remove the note</code>&#13;
    <code class="nx">await</code> <code class="nx">note</code><code class="p">.</code><code class="nx">remove</code><code class="p">();</code>&#13;
    <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// if there's an error along the way, return false</code>&#13;
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">},</code></pre>&#13;
&#13;
<p>Now, also in <em>src/resolvers/mutation.js</em>, update the <code>updateNote</code> mutation as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">updateNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">content</code><code class="p">,</code> <code class="nx">id</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code><code class="p">,</code> <code class="nx">user</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// if not a user, throw an Authentication Error</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">user</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">AuthenticationError</code><code class="p">(</code><code class="s1">'You must be signed in to update a note'</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// find the note</code>&#13;
  <code class="kr">const</code> <code class="nx">note</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="c1">// if the note owner and current user don't match, throw a forbidden error</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">note</code> <code class="o">&amp;&amp;</code> <code class="nb">String</code><code class="p">(</code><code class="nx">note</code><code class="p">.</code><code class="nx">author</code><code class="p">)</code> <code class="o">!==</code> <code class="nx">user</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">ForbiddenError</code><code class="p">(</code><code class="s2">"You don't have permissions to update the note"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// Update the note in the db and return the updated note</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findOneAndUpdate</code><code class="p">(</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nx">_id</code><code class="o">:</code> <code class="nx">id</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nx">$set</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">content</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code>&#13;
      <code class="k">new</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">},</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="User Queries" data-type="sect1"><div class="sect1" id="idm45339504174888">&#13;
<h1>User Queries</h1>&#13;
&#13;
<p><a data-primary="user actions" data-secondary="user queries" data-type="indexterm" id="ix_ch08-asciidoc2"/><a data-primary="user queries" data-type="indexterm" id="ix_ch08-asciidoc3"/>With our existing mutations updated to include user checks, let’s also add some user-specific queries. To do this, we’ll add three new queries:</p>&#13;
<dl>&#13;
<dt><code>user</code></dt>&#13;
<dd>&#13;
<p>Given a specific username, returns the user’s information</p>&#13;
</dd>&#13;
<dt><code>users</code></dt>&#13;
<dd>&#13;
<p>Returns a list of all users</p>&#13;
</dd>&#13;
<dt><code>me</code></dt>&#13;
<dd>&#13;
<p>Returns the user information for the current user</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Before we write the query resolver code, add these queries to the GraphQL <em>src/schema.js</em> file like so:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Query</code> <code class="p">{</code>&#13;
  <code class="p">...</code>&#13;
  <code class="nx">user</code><code class="p">(</code><code class="nx">username</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nx">User</code>&#13;
  <code class="nx">users</code><code class="o">:</code> <code class="p">[</code><code class="nx">User</code><code class="o">!</code><code class="p">]</code><code class="o">!</code>&#13;
  <code class="nx">me</code><code class="o">:</code> <code class="nx">User</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now in the <em>src/resolvers/query.js</em> file, write the following resolver query code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
  <code class="c1">// add the following to the existing module.exports object:</code>&#13;
  <code class="nx">user</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">username</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// find a user given their username</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">User</code><code class="p">.</code><code class="nx">findOne</code><code class="p">({</code> <code class="nx">username</code> <code class="p">});</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">users</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// find all users</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">User</code><code class="p">.</code><code class="nx">find</code><code class="p">({});</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">me</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code><code class="p">,</code> <code class="nx">user</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// find a user given the current user context</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">User</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s see how these look in our GraphQL Playground. First, we can write a user query to look up the information of a specific user. Be sure to use a username that you’ve already created:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">user</code><code class="p">(</code><code class="nx">username</code><code class="o">:</code><code class="s2">"adam"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">username</code>&#13;
    <code class="nx">email</code>&#13;
    <code class="nx">id</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This will return a data object, containing the username, email, and ID values for the specified user (<a data-type="xref" href="#user_query">Figure 8-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="user_query">&#13;
<img alt="A screenshot of the user query in the GraphQL Playground" src="assets/jsev_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>The user query in the GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Now to look up all of the users in our database, we can use the <code>users</code> query, which will return a data object containing the information of all users (<a data-type="xref" href="#users_query">Figure 8-3</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">users</code> <code class="p">{</code>&#13;
    <code class="nx">username</code>&#13;
    <code class="nx">email</code>&#13;
    <code class="nx">id</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="users_query">&#13;
<img alt="A screenshot of the users query in the GraphQL Playground" src="assets/jsev_0803.png"/>&#13;
<h6><span class="label">Figure 8-3. </span>The users query in GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now we can use a JWT, passed in the HTTP header, to look up information about the signed-in user, using the <code>me</code> query.</p>&#13;
&#13;
<p>First, be sure to include the token in the HTTP header portion of the GraphQL <span class="keep-together">Playground:</span></p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"Authorization"</code><code class="o">:</code> <code class="s2">"&lt;YOUR_JWT&gt;"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, perform the <code>me</code> query like so (<a data-type="xref" href="#me_query">Figure 8-4</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">me</code> <code class="p">{</code>&#13;
    <code class="nx">username</code>&#13;
    <code class="nx">email</code>&#13;
    <code class="nx">id</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="me_query">&#13;
<img alt="A screenshot of the me query in the GraphQL Playground" src="assets/jsev_0804.png"/>&#13;
<h6><span class="label">Figure 8-4. </span>The me query in GraphQL Playground</h6>&#13;
</div></figure>&#13;
&#13;
<p>With these resolvers in place, we can now query our API for user information.<a data-startref="ix_ch08-asciidoc3" data-type="indexterm" id="idm45339503725768"/><a data-startref="ix_ch08-asciidoc2" data-type="indexterm" id="idm45339503725064"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Toggling Note Favorites" data-type="sect1"><div class="sect1" id="idm45339504065496">&#13;
<h1>Toggling Note Favorites</h1>&#13;
&#13;
<p><a data-primary="toggleFavorite" data-type="indexterm" id="ix_ch08-asciidoc4"/><a data-primary="user actions" data-secondary="toggling note favorites" data-type="indexterm" id="ix_ch08-asciidoc5"/>We have one last piece of functionality to add to our user interactions. You may recall that our application specifications stated that “users will be able to favorite the notes of other users as well as retrieve a list of their favorites.” Similar to Twitter “hearts” and Facebook “likes,” we’d like our users to be able to mark (and unmark) a note as a favorite. To implement this behavior, we’ll follow our standard pattern of updating the GraphQL schema, then the database model, and lastly the resolver function.</p>&#13;
&#13;
<p>First, we will update our GraphQL schema in <em>./src/schema.js</em> by adding two new properties to our <code>Note</code> type. <code>favoriteCount</code> will track the total number of “favorites” that a note has received. <code>favoritedBy</code> will contain an array of users who have favorited a note.</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Note</code> <code class="p">{</code>&#13;
  <code class="c1">// add the following properties to the Note type</code>&#13;
  <code class="nx">favoriteCount</code><code class="o">:</code> <code class="nx">Int</code><code class="o">!</code>&#13;
  <code class="nx">favoritedBy</code><code class="o">:</code> <code class="p">[</code><code class="nx">User</code><code class="o">!</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ll also add the list of favorites to our <code>User</code> type:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">User</code> <code class="p">{</code>&#13;
   <code class="c1">// add the favorites property to the User type</code>&#13;
   <code class="nx">favorites</code><code class="o">:</code> <code class="p">[</code><code class="nx">Note</code><code class="o">!</code><code class="p">]</code><code class="o">!</code>&#13;
 <code class="p">}</code></pre>&#13;
&#13;
<p>Next, we will add a mutation in <em>./src/schema.js</em> called <a data-primary="toggleFavorite" data-type="indexterm" id="idm45339503649672"/><code>toggleFavorite</code>, which will resolve by either adding or removing a favorite for the specified note. This mutation will take a  note ID as a parameter and return the specified note.</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Mutation</code> <code class="p">{</code>&#13;
  <code class="c1">// add toggleFavorite to the Mutation type</code>&#13;
  <code class="nx">toggleFavorite</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nx">Note</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Next, we need to update our note model to include the <code>favoriteCount</code> and <span class="keep-together"><code>favoritedBy</code></span> properties in our database. <code>favoriteCount</code> will be a <code>Number</code> type with a default value of <code>0</code>. <code>favoritedBy</code> will be an array of objects, containing references to user object IDs in our database. Our full <em>./src/models/note.js</em> file will look as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">noteSchema</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">(</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">},</code>&#13;
    <code class="c1">// add the favoriteCount property</code>&#13;
    <code class="nx">favoriteCount</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">Number</code><code class="p">,</code>&#13;
      <code class="k">default</code><code class="o">:</code> <code class="mi">0</code>&#13;
    <code class="p">},</code>&#13;
    <code class="c1">// add the favoritedBy property</code>&#13;
    <code class="nx">favoritedBy</code><code class="o">:</code> <code class="p">[</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">type</code><code class="o">:</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">.</code><code class="nx">Types</code><code class="p">.</code><code class="nx">ObjectId</code><code class="p">,</code>&#13;
        <code class="nx">ref</code><code class="o">:</code> <code class="s1">'User'</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">]</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="c1">// Assigns createdAt and updatedAt fields with a Date type</code>&#13;
    <code class="nx">timestamps</code><code class="o">:</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>With our GraphQL schema and database models updated, we can write the <span class="keep-together"><code>toggle</code></span><span class="keep-together"><code>Favorite</code></span> mutation. This mutation will receive a note ID as a parameter and check to see if the user is already listed in the <code>favoritedBy</code> array. If the user is listed, we will remove the favorite by decreasing the <code>favoriteCount</code> and removing the user from the list. If the user has not yet favorited the note, we will increment the <code>favoriteCount</code> by 1 and add the current user to the <code>favoritedBy</code> array. To do all of this, add the following code to the <em>src/resolvers/mutation.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">toggleFavorite</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">id</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">models</code><code class="p">,</code> <code class="nx">user</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// if no user context is passed, throw auth error</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">user</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">AuthenticationError</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// check to see if the user has already favorited the note</code>&#13;
  <code class="kd">let</code> <code class="nx">noteCheck</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">hasUser</code> <code class="o">=</code> <code class="nx">noteCheck</code><code class="p">.</code><code class="nx">favoritedBy</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// if the user exists in the list</code>&#13;
  <code class="c1">// pull them from the list and reduce the favoriteCount by 1</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">hasUser</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findByIdAndUpdate</code><code class="p">(</code>&#13;
      <code class="nx">id</code><code class="p">,</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">$pull</code><code class="o">:</code> <code class="p">{</code>&#13;
          <code class="nx">favoritedBy</code><code class="o">:</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Types</code><code class="p">.</code><code class="nx">ObjectId</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nx">$inc</code><code class="o">:</code> <code class="p">{</code>&#13;
          <code class="nx">favoriteCount</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code>&#13;
        <code class="p">}</code>&#13;
      <code class="p">},</code>&#13;
      <code class="p">{</code>&#13;
        <code class="c1">// Set new to true to return the updated doc</code>&#13;
        <code class="k">new</code><code class="o">:</code> <code class="kc">true</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">);</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="c1">// if the user doesn't exist in the list</code>&#13;
    <code class="c1">// add them to the list and increment the favoriteCount by 1</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findByIdAndUpdate</code><code class="p">(</code>&#13;
      <code class="nx">id</code><code class="p">,</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">$push</code><code class="o">:</code> <code class="p">{</code>&#13;
          <code class="nx">favoritedBy</code><code class="o">:</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Types</code><code class="p">.</code><code class="nx">ObjectId</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nx">$inc</code><code class="o">:</code> <code class="p">{</code>&#13;
          <code class="nx">favoriteCount</code><code class="o">:</code> <code class="mi">1</code>&#13;
        <code class="p">}</code>&#13;
      <code class="p">},</code>&#13;
      <code class="p">{</code>&#13;
        <code class="k">new</code><code class="o">:</code> <code class="kc">true</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">},</code></pre>&#13;
&#13;
<p>With this code in place, let’s test our ability to toggle a note favorite in the GraphQL Playground. Let’s do this with a freshly created note. We’ll begin by writing a <code>newNote</code> mutation, being sure to include an <code>Authorization</code> header with a valid JWT (<a data-type="xref" href="#user_newnote2">Figure 8-5</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code><code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="s2">"Check check it out!"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="nx">favoriteCount</code>&#13;
    <code class="nx">id</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="user_newnote2">&#13;
<img alt="A screenshote of a newNote mutation in the GraphQL Playground" src="assets/jsev_0805.png"/>&#13;
<h6><span class="label">Figure 8-5. </span>A newNote mutation</h6>&#13;
</div></figure>&#13;
&#13;
<p>You’ll notice that the <code>favoriteCount</code> of this new note is automatically set to <code>0</code>, because that’s the default value we set in our data model. Now, let’s write a <span class="keep-together"><code>toggle</code></span><span class="keep-together"><code>Favorite</code></span> mutation to mark it as a favorite, passing the ID of the note as a parameter. Again, be sure to include the <code>Authorization</code> HTTP header, with a valid JWT.</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">toggleFavorite</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="s2">"&lt;YOUR_NOTE_ID_HERE&gt;"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">favoriteCount</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>After you run this mutation, the value of the note’s <code>favoriteCount</code> should be <code>1</code>. If you rerun the mutation, the <code>favoriteCount</code> will reduce to <code>0</code> (<a data-type="xref" href="#favorite_count">Figure 8-6</a>).</p>&#13;
&#13;
<figure><div class="figure" id="favorite_count">&#13;
<img alt="A screenshot of the toggleFavorite mutation in the GraphQL Playground" src="assets/jsev_0806.png"/>&#13;
<h6><span class="label">Figure 8-6. </span>The toggleFavorite mutation</h6>&#13;
</div></figure>&#13;
&#13;
<p>Users can now mark and unmark notes as favorites. More importantly, I hope that this functionality demonstrates how you can add new features to a GraphQL application’s API.<a data-startref="ix_ch08-asciidoc5" data-type="indexterm" id="idm45339503250840"/><a data-startref="ix_ch08-asciidoc4" data-type="indexterm" id="idm45339503250136"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Nested Queries" data-type="sect1"><div class="sect1" id="idm45339503723480">&#13;
<h1>Nested Queries</h1>&#13;
&#13;
<p><a data-primary="nested queries" data-type="indexterm" id="ix_ch08-asciidoc6"/><a data-primary="queries" data-secondary="nested" data-type="indexterm" id="ix_ch08-asciidoc7"/><a data-primary="user actions" data-secondary="nested queries" data-type="indexterm" id="ix_ch08-asciidoc8"/>One of the great things about GraphQL is that we can <em>nest</em> queries, allowing us to write a single query that returns precisely the data we need, rather than multiple queries. Our GraphQL schema’s <code>User</code> type includes a list of notes by the author in an array format, while our <code>Notes</code> type includes a reference to its author. As a result, we can pull a list of notes from a user query or get the author information from a note query.</p>&#13;
&#13;
<p>This means that we can write a query that looks like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">note</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="s2">"5c99fb88ed0ca93a517b1d8e"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="err">#</code> <code class="nx">the</code> <code class="nx">information</code> <code class="nx">about</code> <code class="nx">the</code> <code class="nx">author</code> <code class="nx">note</code>&#13;
    <code class="nx">author</code> <code class="p">{</code>&#13;
      <code class="nx">username</code>&#13;
      <code class="nx">id</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we currently try to run a nested query like the preceding one, we’ll receive an error. This is because we haven’t yet written the resolver code that performs the database lookup for this information.</p>&#13;
&#13;
<p>To enable this functionality, we’ll add two new files in our <em>src/resolvers</em> directory.</p>&#13;
&#13;
<p>In <em>src/resolvers/note.js</em>, add the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// Resolve the author info for a note when requested</code>&#13;
  <code class="nx">author</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">note</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">User</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">note</code><code class="p">.</code><code class="nx">author</code><code class="p">);</code>&#13;
  <code class="p">},</code>&#13;
  <code class="c1">// Resolved the favoritedBy info for a note when requested</code>&#13;
  <code class="nx">favoritedBy</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">note</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">User</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code> <code class="nx">_id</code><code class="o">:</code> <code class="p">{</code> <code class="nx">$in</code><code class="o">:</code> <code class="nx">note</code><code class="p">.</code><code class="nx">favoritedBy</code> <code class="p">}</code> <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>In <em>src/resolvers/user.js</em>, add this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// Resolve the list of notes for a user when requested</code>&#13;
  <code class="nx">notes</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">user</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code> <code class="nx">author</code><code class="o">:</code> <code class="nx">user</code><code class="p">.</code><code class="nx">_id</code> <code class="p">}).</code><code class="nx">sort</code><code class="p">({</code> <code class="nx">_id</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code> <code class="p">});</code>&#13;
  <code class="p">},</code>&#13;
  <code class="c1">// Resolve the list of favorites for a user when requested</code>&#13;
  <code class="nx">favorites</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">user</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="p">{</code> <code class="nx">models</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code> <code class="nx">favoritedBy</code><code class="o">:</code> <code class="nx">user</code><code class="p">.</code><code class="nx">_id</code> <code class="p">}).</code><code class="nx">sort</code><code class="p">({</code> <code class="nx">_id</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code> <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now we need to update our <em>src/resolvers/index.js</em> to import and export these new resolver modules. Overall the <em>src/resolvers/index.js</em> file should now look as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">Query</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./query'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">Mutation</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./mutation'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">Note</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./note'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">User</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./user'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">GraphQLDateTime</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'graphql-iso-date'</code><code class="p">);</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="p">,</code>&#13;
  <code class="nx">Mutation</code><code class="p">,</code>&#13;
  <code class="nx">Note</code><code class="p">,</code>&#13;
  <code class="nx">User</code><code class="p">,</code>&#13;
  <code class="nx">DateTime</code><code class="o">:</code> <code class="nx">GraphQLDateTime</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now if we write a nested GraphQL query or mutation, we will receive the information that we expect. You can try this out by writing the following <code>note</code> query:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">note</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="s2">"&lt;YOUR_NOTE_ID_HERE&gt;"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="err">#</code> <code class="nx">the</code> <code class="nx">information</code> <code class="nx">about</code> <code class="nx">the</code> <code class="nx">author</code> <code class="nx">note</code>&#13;
    <code class="nx">author</code> <code class="p">{</code>&#13;
      <code class="nx">username</code>&#13;
      <code class="nx">id</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This query should correctly resolve with the author’s username and ID. Another practical example would be to return information about users who have “favorited” a note:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">toggleFavorite</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="s2">"&lt;YOUR NOTE ID&gt;"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">favoriteCount</code>&#13;
    <code class="nx">favoritedBy</code> <code class="p">{</code>&#13;
      <code class="nx">username</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With nested resolvers in place, we can write precise queries and mutations that return exactly the data that we need.<a data-startref="ix_ch08-asciidoc8" data-type="indexterm" id="idm45339502698616"/><a data-startref="ix_ch08-asciidoc7" data-type="indexterm" id="idm45339502698008"/><a data-startref="ix_ch08-asciidoc6" data-type="indexterm" id="idm45339502697400"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339503249208">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>Congratulations! In this chapter our API graduated to being something that users can truly interact with. This API demonstrates the true power of GraphQL by integrating user actions, adding new features, and nesting resolvers. We’ve also followed a tried-and-true pattern for adding new code to our projects: first write the GraphQL schema, then write the database model, and finally write the resolver code to query or update the data. By breaking down the process into these three steps, we can add all sorts of features to our applications. In the next chapter we’ll look at the final steps needed to make our API production ready, including pagination and security.<a data-startref="ix_ch08-asciidoc0" data-type="indexterm" id="idm45339502694744"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>