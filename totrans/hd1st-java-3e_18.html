<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Saving Objects (and Text): Serialization and File I/O"><div class="chapter" id="saving_objects_left_parenthesisand_textr">
<h1><span class="label">Chapter 16. </span>Saving Objects (and Text): Serialization and File I/O</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0539-01.png" alt="image" width="894" height="677"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="objects" data-secondary="behavior" data-seealso="classes" id="idm46038388520944"/><a data-type="indexterm" data-primary="objects" data-secondary="saving state" id="idm46038388519504"/><a data-type="indexterm" data-primary="OO (object-oriented) development" data-secondary="saving object state" id="idm46038388518400"/><strong>Objects can be flattened and inflated.</strong> Objects have state and behavior. <em>Behavior</em> lives in the <em>class</em>, but <em>state</em> lives within each individual <em>object</em>. So what happens when it’s time to <em>save</em> the state of an object? If you’re writing a game, you’re gonna need a Save/Restore Game feature. If you’re writing an app that creates charts, you’re gonna need a Save/Open File feature. If your program needs to save state, <em>you can do it the hard way</em>, interrogating each object, then painstakingly writing the value of each instance variable to a file, in a format you create. Or, <strong>you can do it the easy OO way</strong>—you simply freeze-dry/flatten/persist/dehydrate the object itself, and reconstitute/inflate/restore/rehydrate it to get it back. But you’ll still have to do it the hard way <em>sometimes</em>, especially when the file your app saves has to be read by some other non-Java application, so we’ll look at both in this chapter. And since all I/O operations are risky, we’ll take a look at how to do even better exceptions handling.</p>
<section data-type="sect1" data-pdf-bookmark="Capture the beat"><div class="sect1" id="capture_the_beat">
<h1>Capture the beat</h1>
<p><a data-type="indexterm" data-primary="BeatBox app" data-secondary="saving objects" id="idm46038388757024"/><a data-type="indexterm" data-primary="I/O" id="idm46038388761744"/><a data-type="indexterm" data-primary="serialization" id="idm46038390495424"/><a data-type="indexterm" data-primary="text file" data-secondary="saving data to" id="idm46038389350864"/>You’ve <em>made</em> the perfect pattern. You want to <em>save</em> the pattern. You could grab a piece of paper and start scribbling it down, but instead you hit the <strong><em>Save</em></strong> button (or choose Save from the File menu). Then you give it a name, pick a directory, and exhale knowing that your masterpiece won’t go out the window during a random computer crash.</p>
<p>You have lots of options for how to save the state of your Java program, and what you choose will probably depend on how you plan to <em>use</em> the saved state. Here are the options we’ll be looking at in this chapter.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0540-01.png" alt="image" width="588" height="454"/>
<h6/>
</div></figure>
<p><strong>If your data will be used by only the Java program that generated it:</strong></p>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1.png" alt="Images" width="20" height="21"/></span> <strong>Use <u>serialization</u></strong></p>
<p>Write a file that holds flattened (serialized) objects. Then have your program read the serialized objects from the file and inflate them back into living, breathing, heap-inhabiting objects.</p>
<p><strong>If your data will be used by <em>other</em> programs:</strong></p></li>
<li><p><span class="inlineimage"><img src="Images/2.png" alt="Images" width="20" height="21"/></span> <strong>Write a <u>plain-text</u> file</strong></p>
<p>Write a file, with delimiters that other programs can parse. For example, a tab-delimited file that a spreadsheet or database application can use.</p></li>
</ul>
<p>These aren’t the only options, but if we had to pick only two approaches to doing I/O in Java, we’d probably pick these. Of course, you can save data in any format you choose. Instead of writing characters, for example, you can write your data as bytes. Or you can write out any kind of Java primitive <em>as</em> a Java primitive—there are methods to write ints, longs, booleans, etc. But regardless of the method you use, the fundamental I/O techniques are pretty much the same: write some data to <em>something</em>, and usually that something is either a file on disk or a stream coming from a network connection. Reading the data is the same process in reverse: read some data from either a file on disk or a network connection. Everything we talk about in this part is for times when you aren’t using an actual database.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Saving state"><div class="sect1" id="saving_state">
<h1>Saving state</h1>
<p><a data-type="indexterm" data-primary="I/O" data-secondary="saving objects" id="idm46038388500336"/><a data-type="indexterm" data-primary="I/O" data-secondary="serialization" id="idm46038388499376"/><a data-type="indexterm" data-primary="objects" data-secondary="saving state" id="idm46038389280320"/><a data-type="indexterm" data-primary="serialization" id="idm46038389272688"/><a data-type="indexterm" data-primary="text file" data-secondary="writing data to" id="idm46038389274288"/>Imagine you have a program, say, a fantasy adventure game, that takes more than one session to complete. As the game progresses, characters in the game become stronger, weaker, smarter, etc., and gather and use (and lose) weapons. You don’t want to start from scratch each time you launch the game—it took you forever to get your characters in top shape for a spectacular battle. So, you need a way to save the state of the characters, and a way to restore the state when you resume the game. And since you’re also the game programmer, you want the whole save and restore thing to be as easy (and foolproof) as possible.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">Imagine you have three game characters to save...</span></p>
</div>
<figure class="informal"><div class="figure">
<img src="Images/f0541-01.png" alt="image" width="178" height="250"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0541-02.png" alt="image" width="371" height="541"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id00000046">
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1.png" alt="Images" width="20" height="21"/></span> Option one</p>
<p><strong>Write the three serialized character objects to a file</strong></p>
<p>Create a file and write three lines of text, one per character, separating the pieces of state with commas:</p>
<pre data-type="programlisting"><strong><sup>..</sup>srGameCharacter</strong>
<strong><sup>..</sup>%gê8MÛIpowerLjava/lang/</strong>
<strong>String;[weaponst[Ljava/lang/</strong>
<strong>String;xp2tlfur[Ljava.lang.String;≠“VÁ
È{Gxptbowtswordtdustsq˜»tTrolluq˜tb</strong>
<strong>are handstbig axsq˜xtMagicianuq˜tspe</strong>
<strong>llstinvisibility</strong></pre></li>
</ul>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id00000047">
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/2.png" alt="Images" width="20" height="21"/></span> Option two</p>
<p><strong>Write a plain-text file</strong></p>
<p>Create a file and write three lines of text, one per character, separating the pieces of state with commas:</p>
<pre data-type="programlisting"><strong>50,Elf,bow, sword,dust</strong>
<strong>200,Troll,bare hands,big ax</strong>
<strong>120,Magician,spells,invisibility</strong></pre></li>
</ul>
</div></aside>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">The serialized file is much harder for humans to read, but it’s much easier (and safer) for your program to restore the three objects from serialization than from reading in the object’s variable values that were saved to a text file. For example, imagine all the ways in which you could accidentally read back the values in the wrong order! The type might become “dust” instead of “Elf,” while the Elf becomes a weapon...</span></p>
</div>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Writing a serialized object to a file"><div class="sect1" id="writing_a_serialized_object_to_a_file">
<h1>Writing a serialized object to a file</h1>
<p><a data-type="indexterm" data-primary="FileOutputStream" id="idm46038388474240"/><a data-type="indexterm" data-primary="ObjectOutputStream" id="idm46038388928688"/><a data-type="indexterm" data-primary="ObjectOutputStream.close()" id="idm46038388927856"/><a data-type="indexterm" data-primary="ObjectOutputStream.writeObject()" id="idm46038388460000"/><a data-type="indexterm" data-primary="serialization" data-secondary="writing object to file with stream" id="idm46038388459264"/><a data-type="indexterm" data-primary="streams (I/O)" data-secondary="in serialization of object" id="idm46038388458288"/>Here are the steps for serializing (saving) an object. Don’t bother memorizing all this; we’ll go into more detail later in this chapter.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0542-01.png" alt="image" width="1009" height="1022"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Data moves in streams from one place to another"><div class="sect1" id="data_moves_in_streams_from_one_place_to">
<h1>Data moves in streams from one place to another</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0543-01.png" alt="image" width="669" height="407"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="indexterm" data-primary="chained streams" id="idm46038388451600"/><a data-type="indexterm" data-primary="connection streams" id="idm46038388450672"/><a data-type="indexterm" data-primary="FileOutputStream" id="idm46038388449840"/><a data-type="indexterm" data-primary="I/O" data-secondary="streams" id="idm46038388449008"/><a data-type="indexterm" data-primary="ObjectOutputStream" id="idm46038388447904"/><a data-type="indexterm" data-primary="writeObject()" id="idm46038388447072"/><span style="color:#646466;">C<u>onnectio</u>n streams represent a connection to a source or destination (file, network socket, etc.), while c<u>hain</u> streams can’t connect on their own and must be chained to a connection stream.</span></p>
</div>
<p>The Java I/O API has <strong><em>connection</em></strong> streams, which represent connections to destinations and sources such as files or network sockets, and <strong><em>chain</em></strong> streams that work only if chained to other streams.</p>
<p>Often, it takes at least two streams hooked together to do something useful—<em>one</em> to represent the connection and <em>another</em> to call methods on. Why two? Because <em>connection</em> streams are usually too low-level. FileOutputStream (a connection stream), for example, has methods for writing <em>bytes</em>. But we don’t want to write <em>bytes</em>! We want to write <em>objects</em>, so we need a higher-level <em>chain</em> stream.</p>
<p>OK, then why not have just a single stream that does <em>exactly</em> what you want? One that lets you write objects but underneath converts them to bytes? Think good OO. Each class does <em>one</em> thing well. FileOutputStreams write bytes to a file. ObjectOutputStreams turn objects into data that can be written to a stream. So we make a FileOutputStream (a connection stream) that lets us write to a file, and we hook an ObjectOutputStream (a chain stream) on the end of it. When we call writeObject() on the ObjectOutputStream, the object gets pumped into the stream and then moves to the FileOutputStream where it ultimately gets written as bytes to a file.</p>
<p>The ability to mix and match different combinations of connection and chain streams gives you tremendous flexibility! If you were forced to use only a <em>single</em> stream class, you’d be at the mercy of the API designers, hoping they’d thought of <em>everything</em> you might ever want to do. But with chaining, you can patch together your own <em>custom</em> chains.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0543-02.png" alt="image" width="992" height="256"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="What really happens to an object when it’s serialized?"><div class="sect1" id="what_really_happens_to_an_object_when_it">
<h1>What really happens to an object when it’s serialized?</h1>
<ul style="list-style-type:none">
<li><p><a data-type="indexterm" data-primary="instance variables" data-secondary="in serialization process" id="idm46038388456256"/><a data-type="indexterm" data-primary="serialization" data-secondary="process" id="idm46038388432128"/><span class="inlineimage"><img src="Images/1circle.png" alt="Images" width="20" height="20"/></span> <strong>Object on the heap</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0544-01.png" alt="image" width="429" height="283"/>
<h6/>
</div></figure>
<p>Objects on the heap have state—the value of the object’s instance variables. These values make one instance of a class different from another instance of the same class.</p></li>
<li><p><span class="inlineimage"><img src="Images/2circle.png" alt="Images" width="23" height="23"/></span> Object serialized</p>
<figure class="informal"><div class="figure">
<img src="Images/f0544-02.png" alt="image" width="248" height="171"/>
<h6/>
</div></figure>
<p>Serialized objects <strong>save the values of the instance variables</strong> so that an identical instance (object) can be brought back to life on the heap.</p></li>
</ul>
<figure class="informal"><div class="figure">
<img src="Images/f0544-03.png" alt="image" width="1011" height="382"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="But what exactly IS an object’s state? What needs to be saved?"><div class="sect1" id="but_what_exactly_is_an_objectapostrophes">
<h1>But what exactly <u>IS</u> an object’s state? What needs to be saved?</h1>
<p><a data-type="indexterm" data-primary="primitive variables" data-secondary="saving objects" id="idm46038388419760"/>Now it starts to get interesting. Easy enough to save the <em>primitive</em> values 37 and 70. But what if an object has an instance variable that’s an object <em>reference</em>? What about an object that has five instance variables that are object references? What if those object instance variables themselves have instance variables?</p>
<p>Think about it. What part of an object is potentially unique? Imagine what needs to be restored in order to get an object that’s identical to the one that was saved. It will have a different memory location, of course, but we don’t care about that. All we care about is that out there on the heap, we’ll get an object that has the same state the object had when it was saved.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="brain_barbell-id00006">
<h5>Brain Barbell</h5>
<figure class="informal"><div class="figure">
<img src="Images/barbell.png" alt="image" width="163" height="95"/>
<h6/>
</div></figure>
<p>What has to happen for the Car object to be saved in such a way that it can be restored to its original state?</p>
<p>Think of what—and how—you might need to save the Car.</p>
<p>And what happens if an Engine object has a reference to a Carburetor? And what’s inside the Tire[] array object?</p>
<blockquote><strong>The Car object has two instance variables that reference two other objects.</strong></blockquote>
<figure class="informal"><div class="figure">
<img src="Images/f0545-01.png" alt="image" width="442" height="344"/>
<h6/>
</div></figure>
<blockquote><strong>What does it take to save a Car object?</strong></blockquote>
</div></aside>
<p><a data-type="indexterm" data-primary="object graph" id="idm46038388403808"/><strong>When an object is serialized, all the objects it refers to from instance variables are <em>also</em> serialized. And all the objects <em>those</em> objects refer to are serialized. And all the objects those objects refer to are serialized...and the best part is, it happens automatically!</strong></p>
<p>This Kennel object has a reference to a Dog[] array object. The Dog[] holds references to two Dog objects. Each Dog object holds a reference to a String and a Collar object. The String objects have a collection of characters, and the Collar objects have an int.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id00000048">
<p><strong><span style="color:#646466;">Serialization saves the entire</span> object graph<span style="color:#646466;">—all objects referenced by instance variables, starting with the object being serialized.</span></strong></p>
</div></aside>
<figure class="informal"><div class="figure">
<img src="Images/f0546-01.png" alt="image" width="1010" height="825"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="If you want your class to be serializable, implement Serializable"><div class="sect1" id="if_you_want_your_class_to_be_serializabl">
<h1>If you want your class to be serializable, implement <span style="background-color:#231F20; color: #FFFFFF;">Serializable</span></h1>
<p><a data-type="indexterm" data-primary="Serializable interface" id="idm46038388397872"/>The Serializable interface is known as a <em>marker</em> or <em>tag</em> interface, because the interface doesn’t have any methods to implement. Its sole purpose is to announce that the class implementing it is, well, <em>serializable</em>. In other words, objects of that type are saveable through the serialization mechanism. If any superclass of a class is serializable, the subclass is automatically serializable even if the subclass doesn’t explicitly declare “implements Serializable.” (This is how interfaces always work. If your superclass “IS-A” Serializable, you are too.)</p>
<figure class="informal"><div class="figure">
<img src="Images/f0547-01.png" alt="image" width="989" height="797"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="object graph" id="idm46038389319440"/><strong>Serialization is all or nothing.</strong></p>
<p><strong>Can you imagine what would happen if some of the object’s state didn’t save correctly?</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0548-01.png" alt="image" width="640" height="446"/>
<h6/>
</div></figure>
<blockquote><strong>Either the entire object graph is serialized correctly or serialization fails.</strong></blockquote>
<blockquote><strong>You can’t serialize a Pond object if its Duck instance variable refuses to be serialized (by not implementing Serializable).</strong></blockquote>
<figure class="informal"><div class="figure">
<img src="Images/f0548-02.png" alt="image" width="1015" height="642"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0549-01.png" alt="image" width="551" height="832"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="instance variables" data-secondary="transient" id="idm46038388381952"/><a data-type="indexterm" data-primary="transient variables" id="idm46038388380976"/><strong>Mark an instance variable as <u>transient</u> if it can’t (or shouldn’t) be saved.</strong></p>
<p>If you want an instance variable to be skipped by the serialization process, mark the variable with the <strong><code>transient</code></strong> keyword.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0549-02.png" alt="image" width="683" height="229"/>
<h6/>
</div></figure>
<p>If you have an instance variable that can’t be saved because it isn’t serializable, you can mark that variable with the transient keyword and the serialization process will skip right over it.</p>
<p>So why would a variable not be serializable? It could be that the class designer simply <em>forgot</em> to make the class implement Serializable. Or it might be because the object relies on runtime-specific information that simply can’t be saved. Although most things in the Java class libraries are serializable, you can’t save things like network connections, threads, or file objects. They’re all dependent on (and specific to) a particular runtime “experience.” In other words, they’re instantiated in a way that’s unique to a particular run of your program, on a particular platform, in a particular JVM. Once the program shuts down, there’s no way to bring those things back to life in any meaningful way; they have to be created from scratch each time.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00042">
<h5>there are no Dumb Questions</h5>
<p><a data-type="indexterm" data-primary="instance variables" data-secondary="transient" id="idm46038389761360"/><a data-type="indexterm" data-primary="object graph" id="idm46038390954912"/><a data-type="indexterm" data-primary="transient keyword" id="idm46038389836832"/><strong>Q: If serialization is so important, why isn’t it the default for all classes? Why doesn’t class Object implement Serializable, and then all subclasses will be automatically Serializable?</strong></p>
<p><strong>A:</strong> Even though most classes will, and should, implement Serializable, you always have a choice. And you must make a conscious decision on a class-by-class basis, for each class you design, to “enable” serialization by implementing Serializable. First of all, if serialization were the default, how would you turn it off? Interfaces indicate functionality, not a <em>lack</em> of functionality, so the model of polymorphism wouldn’t work correctly if you had to say, “implements NonSerializable” to tell the world that you cannot be saved.</p>
<p><strong>Q: Why would I ever write a class that <em>wasn’t</em> serializable?</strong></p>
<p><strong>A:</strong> There are very few reasons, but you might, for example, have a security issue where you don’t want a password object stored. Or you might have an object that makes no sense to save, because its key instance variables are themselves not serializable, so there’s no useful way for you to make <em>your</em> class serializable.</p>
<p><strong>Q: If a class I’m using isn’t serializable but there’s no good reason, can I subclass the “bad” class and make the <em>subclass</em> serializable?</strong></p>
<p><strong>A:</strong> Yes! If the class itself is extendable (i.e., not final), you can make a serializable subclass and just substitute the subclass everywhere your code is expecting the superclass type. (Remember, polymorphism allows this.) That brings up another interesting issue: what does it <em>mean</em> if the superclass is not serializable?</p>
<p><strong>Q: You brought it up: what <em>does</em> it mean to have a serializable subclass of a non-serializable superclass?</strong></p>
<p><strong>A:</strong> First we have to look at what happens when a class is deserialized, (we’ll talk about that on the next few pages). In a nutshell, when an object is deserialized and its superclass is <em>not</em> serializable, the superclass constructor will run just as though a new object of that type were being created. If there’s no decent reason for a class to not be serializable, making a serializable subclass might be a good solution.</p>
<p><strong>Q: Whoa! I just realized something big...if you make a variable “transient,” this means the variable’s value is skipped over during serialization. Then what happens to it? We solve the problem of having a non-serializable instance variable by making the instance variable transient, but don’t we NEED that variable when the object is brought back to life? In other words, isn’t the whole point of serialization to preserve an object’s state?</strong></p>
<p><strong>A:</strong> Yes, this is an issue, but fortunately there’s a solution. If you serialize an object, a transient reference instance variable will be brought back as <em>null</em>, regardless of the value it had at the time it was saved. That means the entire object graph connected to that particular instance variable won’t be saved. This could be bad, obviously, because you probably need a non-null value for that variable.</p>
<p>You have two options:</p>
<p>1. When the object is brought back, reinitialize that null instance variable back to some default state. This works if your deserialized object isn’t dependent on a particular value for that transient variable. In other words, it might be important that the Dog have a Collar, but perhaps all Collar objects are the same, so it doesn’t matter if you give the resurrected Dog a brand new Collar; nobody will know the difference.</p>
<p>2. If the value of the transient variable <em>does</em> matter (say, if the color and design of the transient Collar are unique for each Dog), then you need to save the key values of the Collar and use them when the Dog is brought back to essentially re-create a brand new Collar that’s identical to the original.</p>
<p><strong>Q: What happens if two objects in the object graph are the same object? Like, if you have two different Cat objects in the Kennel, but both Cats have a reference to the same Owner object. Does the Owner get saved twice? I’m hoping not.</strong></p>
<p><strong>A:</strong> Excellent question! Serialization is smart enough to know when two objects in the graph are the same. In that case, only <em>one</em> of the objects is saved, and during deserialization, any references to that single object are restored.</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Deserialization: restoring an object"><div class="sect1" id="deserialization_restoring_an_object">
<h1>Deserialization: restoring an object</h1>
<p><a data-type="indexterm" data-primary="casting" id="idm46038388476960"/><a data-type="indexterm" data-primary="deserialization" id="idm46038388466192"/><a data-type="indexterm" data-primary="FileInputStream" id="idm46038388343856"/><a data-type="indexterm" data-primary="I/O" data-secondary="deserialization" id="idm46038388343344"/><a data-type="indexterm" data-primary="ObjectInputStream" id="idm46038388342368"/>The whole point of serializing an object is so that you can restore it to its original state at some later date, in a different “run” of the JVM (which might not even be the same JVM that was running at the time the object was serialized). Deserialization is a lot like serialization in reverse.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0551-01.png" alt="image" width="1014" height="614"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0551-02.png" alt="image" width="640" height="360"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="What happens during deserialization?"><div class="sect1" id="what_happens_during_deserializationquest">
<h1>What happens during deserialization?</h1>
<p><a data-type="indexterm" data-primary="constructors" data-secondary="in deserialization" id="idm46038388335840"/>When an object is deserialized, the JVM attempts to bring the object back to life by making a new object on the heap that has the same state the serialized object had at the time it was serialized. Well, except for the transient variables, which come back either null (for object references) or as default primitive values.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0552-01.png" alt="image" width="987" height="360"/>
<h6/>
</div></figure>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1circle.png" alt="Images" width="20" height="20"/></span> The object is <strong>read</strong> from the stream.</p></li>
<li><p><span class="inlineimage"><img src="Images/2circle.png" alt="Images" width="23" height="23"/></span> The JVM determines (through info stored with the serialized object) the object’s <strong>class type.</strong></p></li>
<li><p><span class="inlineimage"><img src="Images/3circle.png" alt="Images" width="23" height="23"/></span> The JVM attempts to <strong>find and load</strong> the object’s <strong>class</strong>. If the JVM can’t find and/or load the class, the JVM throws an exception and the deserialization fails.</p></li>
<li><p><span class="inlineimage"><img src="Images/4circle.png" alt="Images" width="20" height="19"/></span> A new object is given space on the heap, but the <strong>serialized object’s constructor</strong> <strong>does NOT run</strong>! Obviously, if the constructor ran, it would restore the state of the object to its original “new” state, and that’s not what we want. We want the object to be restored to the state it had <em>when it was serialized</em>, not when it was first created.</p></li>
<li><p><span class="inlineimage"><img src="Images/5circle.png" alt="Images" width="20" height="19"/></span> <a data-type="indexterm" data-primary="classes" data-secondary="efficiency of not saving with object" id="idm46038388320368"/><a data-type="indexterm" data-primary="instance variables" data-secondary="transient" id="idm46038388319392"/><a data-type="indexterm" data-primary="remote interface" data-see="RMI" id="idm46038388318416"/><a data-type="indexterm" data-primary="RMI (Remote Method Invocation)" id="idm46038388317440"/><a data-type="indexterm" data-primary="static variables" data-secondary="and serialization" id="idm46038388316704"/><a data-type="indexterm" data-primary="transient variables" id="idm46038388315728"/>If the object has a non-serializable class somewhere up its inheritance tree, the <strong>constructor for that non-serializable class will run</strong> along with any constructors above that (even if they’re serializable). Once the constructor chaining begins, you can’t stop it, which means all superclasses, beginning with the first non-serializable one, will reinitialize their state.</p></li>
<li><p><span class="inlineimage"><img src="Images/6circle.png" alt="Images" width="20" height="20"/></span> The object’s i<strong>nstance variables are given the values from the serialized state</strong>. Transient variables are given a value of null for object references and defaults (0, false, etc.) for primitives.</p></li>
</ul>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00043">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: Why doesn’t the class get saved as part of the object? That way you don’t have the problem with whether the class can be found.</strong></p>
<p><strong>A:</strong> Sure, they could have made serialization work that way. But what a tremendous waste and overhead. And while it might not be such a hardship when you’re using serialization to write objects to a file on a local hard drive, serialization is also used to send objects over a network connection. If a class was bundled with each serialized (shippable) object, bandwidth would become a much larger problem than it already is.</p>
<p>For objects serialized to ship over a network, though, there actually <em>is</em> a mechanism where the serialized object can be “stamped” with a URL for where its class can be found. This is used in Java’s Remote Method Invocation (RMI) so that you can send a serialized object as part of, say, a method argument, and if the JVM receiving the call doesn’t have the class, it can use the URL to fetch the class from the network and load it, all automatically. You may see RMI used in the wild, although you may also see objects serialized to XML or JSON (or other human-readable formats) to send over a network.</p>
<p><strong>Q: What about static variables? Are they serialized?</strong></p>
<p><strong>A:</strong> Nope. Remember, static means “one per class” not “one per object.” Static variables are not saved, and when an object is deserialized, it will have whatever static variable its class <em>currently</em> has. The moral: don’t make serializable objects dependent on a dynamically changing static variable! It might not be the same when the object comes back.</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Saving and restoring the game characters"><div class="sect1" id="saving_and_restoring_the_game_characters">
<h1>Saving and restoring the game characters</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0554-01.png" alt="image" width="981" height="826"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="I/O" data-secondary="serialization" id="idm46038388302432"/><a data-type="indexterm" data-primary="serialization" data-secondary="game characters example" id="idm46038388289952"/></p>
<figure class="informal"><div class="figure"><img src="Images/f0554-02.png" alt="image" width="708" height="330"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="The GameCharacter class"><div class="sect2" id="the_gamecharacter_class">
<h2>The GameCharacter class</h2>
<pre data-type="programlisting"><strong>import java.io.*;</strong>
<strong>import java.util.Arrays;</strong>

<strong>public class GameCharacter implements Serializable {</strong>
  <strong>private final int power;</strong>
  <strong>private final String type;</strong>
  <strong>private final String[] weapons;</strong>

  <strong>public GameCharacter(int power, String type, String[] weapons) {</strong>
    <strong>this.power = power;</strong>
    <strong>this.type = type;</strong>
    <strong>this.weapons = weapons;</strong>
  <strong>}</strong>

  <strong>public int getPower() {</strong>
    <strong>return power;</strong>
  <strong>}</strong>

  <strong>public String getType() {</strong>
    <strong>return type;</strong>
  <strong>}</strong>

  <strong>public String getWeapons() {</strong>
    <strong>return Arrays.toString(weapons);</strong>
  <strong>}</strong>
<strong>}</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">This is a basic class just for testing the Serialization code on the last page. We don’t have an actual game, but we’ll leave that to you to experiment.</span></p>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Version ID: A big serialization gotcha"><div class="sect1" id="version_id_a_big_serialization_gotcha">
<h1>Version ID: A big serialization gotcha</h1>
<p><a data-type="indexterm" data-primary="classes" data-secondary="deserialization and versioning" id="idm46038388284560"/><a data-type="indexterm" data-primary="serialization" data-secondary="versioning" id="idm46038388268544"/><a data-type="indexterm" data-primary="version ID, serialization" id="idm46038388267440"/>Now you’ve seen that I/O in Java is actually pretty simple, especially if you stick to the most common connection/chain combinations. But there’s one issue you might <em>really</em> care about.</p>
<p><strong>Version Control is crucial!</strong></p>
<p>If you serialize an object, you must have the class in order to deserialize and use the object. OK, that’s obvious. But it might be less obvious what happens if you <strong><em>change the class</em></strong> in the meantime. Yikes. Imagine trying to bring back a Dog object when one of its instance variables (non-transient) has changed from a double to a String. That violates Java’s type-safe sensibilities in a Big Way. But that’s not the only change that might hurt compatibility. Think about the following:</p>
<p><strong>Changes to a class that can hurt deserialization:</strong></p>
<ul style="list-style-type:none">
<li><p>Deleting an instance variable</p></li>
<li><p>Changing the declared type of an instance variable</p></li>
<li><p>Changing a non-transient instance variable to transient</p></li>
<li><p>Moving a class up or down the inheritance hierarchy</p></li>
<li><p>Changing a class (anywhere in the object graph) from Serializable to not Serializable (by removing ‘implements Serializable’ from a class declaration)</p></li>
<li><p>Changing an instance variable to static</p></li>
</ul>
<p><strong>Changes to a class that are usually OK:</strong></p>
<ul style="list-style-type:none">
<li><p>Adding new instance variables to the class (existing objects will deserialize with default values for the instance variables they didn’t have when they were serialized)</p></li>
<li><p>Adding classes to the inheritance tree</p></li>
<li><p>Removing classes from the inheritance tree</p></li>
<li><p>Changing the access level (public, private, etc.) of an instance variable has no effect on the ability of deserialization to assign a value to the variable</p></li>
<li><p>Changing an instance variable from transient to non-transient (previously serialized objects will simply have a default value for the previously transient variables)</p></li>
</ul>
<figure class="informal"><div class="figure">
<img src="Images/f0556-01.png" alt="image" width="439" height="1541"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using the serialVersionUID"><div class="sect1" id="using_the_serialversionuid">
<h1>Using the serialVersionUID</h1>
<p><a data-type="indexterm" data-primary="serialVersionUID" id="idm46038388245904"/>Each time an object is serialized, the object (including every object in its graph) is “stamped” with a version ID number for the object’s class. The ID is called the serialVersionUID, and it’s computed based on information about the class structure. As an object is being deserialized, if the class has changed since the object was serialized, the class could have a different serialVersionUID, and deserialization will fail! But you can control this.</p>
<p><strong>If you think there is ANY possibility that your class might <em>evolve</em>, put a serial version ID in your class.</strong></p>
<p>When Java tries to deserialize an object, it compares the serialized object’s serialVersionUID with that of the class the JVM is using for deserializing the object. For example, if a Dog instance was serialized with an ID of, say 23 (in reality a serialVersionUID is much longer), when the JVM deserializes the Dog object, it will first compare the Dog object serialVersionUID with the Dog class serialVersionUID. If the two numbers don’t match, the JVM assumes the class is not compatible with the previously serialized object, and you’ll get an exception during deserialization.</p>
<p>So, the solution is to put a serialVersionUID in your class, and then as the class evolves, the serialVersionUID will remain the same and the JVM will say, “OK, cool, the class is compatible with this serialized object,” even though the class has actually changed.</p>
<p>This works <em>only</em> if you’re careful with your class changes! In other words, <em>you</em> are taking responsibility for any issues that come up when an older object is brought back to life with a newer class.</p>
<p>To get a serialVersionUID for a class, use the serialver tool that ships with your Java development kit.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0557-03.png" alt="image" width="328" height="153"/>
<h6/>
</div></figure>
<blockquote><strong>When you think your class might evolve after someone has serialized objects from it...</strong></blockquote>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1.png" alt="Images" width="20" height="21"/></span> Use the serialver command-line tool to get the version ID for your class.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0557-01.png" alt="image" width="367" height="241"/>
<h6/>
</div></figure></li>
<li><p><span class="inlineimage"><img src="Images/2.png" alt="Images" width="20" height="21"/></span> Paste the output into your class.</p>
<pre data-type="programlisting"><strong>public class Dog {</strong>

  <span style="background-color:#BFC0C3;"><strong>static final long serialVersionUID =</strong></span>
  <span style="background-color:#BFC0C3;">              <strong>-5849794470654667210L;</strong></span>

  <strong>private String name;</strong>
  <strong>private int size;</strong>
  <strong>// method code here</strong>
<strong>}</strong></pre></li>
<li><p><span class="inlineimage"><img src="Images/3.png" alt="Images" width="20" height="21"/></span> Be sure that when you make changes to the class, you take responsibility in your code for the consequences of the changes you made to the class! For example, be sure that your new Dog class can deal with an old Dog being deserialized with default values for instance variables added to the class <em>after</em> the Dog was serialized.</p></li>
</ul>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Object Serialization"><div class="sect1" id="object_serialization">
<h1>Object Serialization</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-id00015">
<h5>Bullet Points</h5>
<ul style="list-style-type:none">
<li><p>You can save an object’s state by serializing the object.</p></li>
<li><p>To serialize an object, you need an ObjectOutputStream (from the java.io package).</p></li>
<li><p>Streams are either connection streams or chain streams.</p></li>
<li><p>Connection streams can represent a connection to a source or destination, typically a file, network socket connection, or the console.</p></li>
<li><p>Chain streams cannot connect to a source or destination and must be chained to a connection (or other) stream.</p></li>
<li><p>To serialize an object to a file, make a FileOutputStream and chain it into an ObjectOutputStream.</p></li>
<li><p>To serialize an object, call <em>writeObject(theObject)</em> on the ObjectOutputStream. You do not need to call methods on the FileOutputStream.</p></li>
<li><p>To be serialized, an object must implement the Serializable interface. If a superclass of the class implements Serializable, the subclass will automatically be serializable even if it does not specifically declare <em>implements Serializable</em>.</p></li>
<li><p>When an object is serialized, its entire object graph is serialized. That means any objects referenced by the serialized object’s instance variables are serialized, and any objects referenced by those objects...and so on.</p></li>
<li><p>If any object in the graph is not serializable, an exception will be thrown at runtime, unless the instance variable referring to the object is skipped.</p></li>
<li><p>Mark an instance variable with the <em>transient</em> keyword if you want serialization to skip that variable. The variable will be restored as null (for object references) or default values (for primitives).</p></li>
<li><p>During deserialization, the class of all objects in the graph must be available to the JVM.</p></li>
<li><p>You read objects in (using readObject()) in the order in which they were originally written.</p></li>
<li><p>The return type of readObject() is type Object, so deserialized objects must be cast to their real type.</p></li>
<li><p>Static variables are not serialized! It doesn’t make sense to save a static variable value as part of a specific object’s state, since all objects of that type share only a single value—the one in the class.</p></li>
<li><p>If a class that implements Serializable might change over time, put a <em>static final long serialVersionUID</em> on that class. This version ID should be changed when the serialized variables in that class change.</p></li>
</ul>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Writing a String to a Text File"><div class="sect1" id="writing_a_string_to_a_text_file">
<h1>Writing a String to a Text File</h1>
<p><a data-type="indexterm" data-primary="FileWriter" id="idm46038388796704"/><a data-type="indexterm" data-primary="I/O" data-secondary="saving data to text file" id="idm46038388219520"/><a data-type="indexterm" data-primary="Strings" data-secondary="saving data to text file" id="idm46038388722704"/><a data-type="indexterm" data-primary="text file" data-secondary="writing data to" id="idm46038388721856"/>Saving objects, through serialization, is the easiest way to save and restore data between runnings of a Java program. But sometimes you need to save data to a plain old text file. Imagine your Java program has to write data to a simple text file that some other (perhaps non-Java) program needs to read. You might, for example, have a servlet (Java code running within your web server) that takes form data the user typed into a browser and writes it to a text file that somebody else loads into a spreadsheet for analysis.</p>
<p>Writing text data (a String, actually) is similar to writing an object, except you write a String instead of an object, and you use something like a FileWriter instead of a FileOutputStream (and you don’t chain it to an ObjectOutputStream).</p>
<figure class="informal"><div class="figure">
<img src="Images/f0559-01.png" alt="image" width="291" height="425"/>
<h6/>
</div></figure>
<p><strong>To write a serialized object:</strong></p>
<p><strong><code>objectOutputStream.writeObject(someObject);</code></strong></p>
<p><strong>To write a String:</strong></p>
<p><strong><code>fileWriter.write("My first String to save");</code></strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0559-02.png" alt="image" width="1006" height="487"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Text file example: e-Flashcards"><div class="sect1" id="text_file_example_e-flashcards">
<h1>Text file example: e-Flashcards</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0560-01.png" alt="image" width="427" height="306"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="e-flashcards example, saving to text file" id="idm46038388207936"/><a data-type="indexterm" data-primary="QuizCardBuilder" id="idm46038388207200"/>Remember those flashcards you used in school? Where you had a question on one side and the answer on the back? They aren’t much help when you’re trying to understand something, but nothing beats ’em for raw drill-and-practice and rote memorization. <em>When you have to burn in a fact.</em> And they’re also great for trivia games.</p>
<p><strong>We’re going to make an electronic version that has three classes:</strong></p>
<p>1. <strong><em>QuizCardBuilder</em></strong>, a simple authoring tool for creating and saving a set of e-Flashcards.</p>
<p>2. <strong><em>QuizCardPlayer</em></strong>, a playback engine that can load a flashcard set and play it for the user.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0560-02.png" alt="image" width="751" height="256"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0560-03.png" alt="image" width="483" height="570"/>
<h6/>
</div></figure>
<p><strong>QuizCardBuilder</strong></p>
<p>Has a File menu with a “Save” option for saving the current set of cards to a text file.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0560-04.png" alt="image" width="568" height="471"/>
<h6/>
</div></figure>
<p><strong>QuizCardPlayer</strong></p>
<p>Has a File menu with a “Load” option for loading a set of cards from a text file.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Quiz Card Builder (code outline)"><div class="sect1" id="quiz_card_builder_left_parenthesiscode_o">
<h1>Quiz Card Builder (code outline)</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0561-01.png" alt="image" width="950" height="616"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="java_isoliduso_to_nio_to_niodot2">
<h5>Java I/O to NIO to NIO.2</h5>
<p><a data-type="indexterm" data-primary="NIO (non-blocking I/O)" id="idm46038388192272"/>The Java API has included I/O features since day one, you know, back in the last millennium. In 2002, Java 1.4 was released, and it included a new approach to I/O called “NIO,” short for non-blocking I/O. In 2011, Java 7 was released, and it included big enhancements to NIO. This yet again newer approach to I/O was dubbed “NIO.2.” Why should you care? When you’re writing new I/O, you should use the latest and greatest features. But you’re almost certainly going to encounter older code that uses the NIO approach. We want you to be covered for both situations, so in this chapter:</p>
<ul>
<li><p>We’ll use original I/O for a while.</p></li>
<li><p>Then we’ll show some NIO.2.</p></li>
</ul>
<p>You’ll see more I/O, NIO, and NIO.2 features in <a data-type="xref" href="ch17.xhtml#make_a_connection_networking_and_threads">Chapter 17</a>, <em>Make a Connection</em>, when we look at network connections.</p>
</div></aside>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Reminder: For the next eight pages or so we’ll be using older-style I/O code!</p>
</div>
<figure class="informal"><div class="figure">
<img src="Images/f0562-01.png" alt="image" width="990" height="1168"/>
<h6/>
</div></figure>
<p/>
<figure class="informal"><div class="figure"><img src="Images/f0563-01.png" alt="image" width="992" height="1208"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The java.io.File class"><div class="sect1" id="the_javadotiodotfile_class">
<h1>The <span style="background-color:#231F20; color: #FFFFFF;">java.io.File</span> class</h1>
<p><a data-type="indexterm" data-primary="classes" data-secondary="File" id="idm46038388178864"/><a data-type="indexterm" data-primary="directories" id="idm46038388177888"/><a data-type="indexterm" data-primary="directories" data-secondary="File object with" id="idm46038388177152"/><a data-type="indexterm" data-primary="File class" id="idm46038388176176"/><a data-type="indexterm" data-primary="File object" id="idm46038388175408"/>The <code>java.io.File</code> class is another example of an older class in the Java API. It’s been “replaced” by two classes in the newer <code>java.nio.file</code> package, but you’ll undoubtedly encounter code that uses the <code>File</code> class. <strong>For new code, we recommend using the <code>java.nio.file</code> package instead of the <code>java.io.File</code> class.</strong> In a few pages, we’ll take a look at a few of the most important capabilities in the <code>java.nio.file</code> package. With that said...</p>
<p>The <code>java.io.File</code> class <em>represents</em> a file on disk but doesn’t actually represent the <em>contents</em> of the file. What? Think of a File object as something more like a <em>path name</em> of a file (or even a <em>directory</em>) rather than The Actual File Itself. The File class does not, for example, have methods for reading and writing. One VERY useful thing about a File object is that it offers a much safer way to represent a file than just using a String filename. For example, most classes that take a String filename in their constructor (like FileWriter or FileInputStream) can take a File object instead. You can construct a File object, verify that you’ve got a valid path, etc., and then give that File object to the FileWriter or FileInputStream.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong><span style="color:#646466;">A</span> <strong>File</strong> <span style="color:#646466;">object represents the name and path of a file or directory on disk, for example:</span></strong></p>
<p><strong><span style="color:#646466;">/Users/Kathy/Data/Game.txt</span></strong></p>
<p><strong><span style="color:#646466;">But it does NOT represent, or give you access to, the data <em>in</em> the file!</span></strong></p>
</div>
<figure class="informal"><div class="figure">
<img src="Images/f0564-01.png" alt="image" width="426" height="192"/>
<h6/>
</div></figure>
<p><strong>Some things you can do with a File object:</strong></p>
<ul style="list-style-type:none">
<li><p><span class="inlineimage"><img src="Images/1.png" alt="Images" width="20" height="21"/></span> <strong>Make a File object representing an existing file</strong></p>
<p><code><strong>File f = new File("MyCode.txt");</strong></code></p></li>
<li><p><span class="inlineimage"><img src="Images/2.png" alt="Images" width="20" height="21"/></span> <strong>Make a new directory</strong></p>
<pre data-type="programlisting"><strong>File dir = new File("Chapter7");</strong>
<strong>dir.mkdir();</strong></pre></li>
<li><p><span class="inlineimage"><img src="Images/3.png" alt="Images" width="20" height="21"/></span> <strong>List the contents of a directory</strong></p>
<pre data-type="programlisting"><strong>if (dir.isDirectory()) {</strong>
  <strong>String[] dirContents = dir.list();</strong>
  <strong>for (String dirContent : dirContents) {</strong>
    <strong>System.out.println(dirContent);</strong>
  <strong>}</strong>
<strong>}</strong></pre></li>
<li><p><span class="inlineimage"><img src="Images/4.png" alt="Images" width="20" height="20"/></span> <strong>Delete a file or directory (returns true if successful)</strong></p>
<pre data-type="programlisting"><strong>boolean isDeleted = f.delete();</strong></pre></li>
</ul>
<figure class="informal"><div class="figure">
<img src="Images/f0564-02.png" alt="image" width="358" height="430"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="BufferedWriter" id="idm46038388138880"/><a data-type="indexterm" data-primary="buffers" id="idm46038388137984"/><a data-type="indexterm" data-primary="FileWriter" id="idm46038388137152"/><strong>The beauty of buffers</strong></p>
<p><strong>If there were no buffers, it would be like shopping without a cart. You’d have to carry each thing out to your car, one soup can or toilet paper roll at a time.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0565-01.png" alt="image" width="694" height="326"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0565-02.png" alt="image" width="993" height="316"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0565-03.png" alt="image" width="960" height="235"/>
<h6/>
</div></figure>
<p>Using buffers is <em>much</em> more efficient than working without them. You can write to a file using FileWriter alone, by calling write(someString), but FileWriter writes each and every thing you pass to the file each and every time. That’s overhead you don’t want or need, since every trip to the disk is a Big Deal compared to manipulating data in memory. By chaining a BufferedWriter onto a FileWriter, the BufferedWriter will hold all the stuff you write to it until it’s full. <em>Only when the buffer is full will the FileWriter actually be told to write to the file on disk.</em></p>
<p>If you do want to send data <em>before</em> the buffer is full, you do have control. <strong><em>Just Flush It</em></strong>. Calls to writer.flush() say, “send whatever’s in the buffer, <strong><em>now</em></strong>!”</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Reading from a text file"><div class="sect1" id="reading_from_a_text_file">
<h1>Reading from a text file</h1>
<p><a data-type="indexterm" data-primary="BufferedReader" id="idm46038388240368"/><a data-type="indexterm" data-primary="buffers" id="idm46038388125056"/><a data-type="indexterm" data-primary="FileReader" id="idm46038388124544"/><a data-type="indexterm" data-primary="loops" data-secondary="while" id="idm46038388123920"/><a data-type="indexterm" data-primary="streams (I/O)" data-secondary="reading text files" id="idm46038388122912"/><a data-type="indexterm" data-primary="text file" id="idm46038388121808"/><a data-type="indexterm" data-primary="text file" data-secondary="reading from" id="idm46038388120976"/><a data-type="indexterm" data-primary="while loops" id="idm46038388241792"/>Reading text from a file is simple, but this time we’ll use a File object to represent the file, a FileReader to do the actual reading, and a BufferedReader to make the reading more efficient.</p>
<p>The read happens by reading lines in a <em>while</em> loop, ending the loop when the result of a readLine() is null. That’s the most common style for reading data (pretty much anything that’s not a Serialized object): read stuff in a while loop (actually a while loop <em>test</em>), terminating when there’s nothing left to read (which we know because the result of whatever read method we’re using is null).</p>
<figure class="informal"><div class="figure">
<img src="Images/f0566-01.png" alt="image" width="279" height="379"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0566-02.png" alt="image" width="1004" height="608"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="java_8_streams_and_isoliduso">
<h5>Java 8 Streams and I/O</h5>
<p>If you’re using Java 8 and you feel comfortable using the Streams API, you can replace all the code inside the try block with the following:</p>
<pre data-type="programlisting">   <strong>Files.lines(Path.of("MyText.txt"))</strong>
        <strong>.forEach(line -&gt; System.out.println(line));</strong></pre>
<p>We’ll see the Files and Path classes later in this chapter.<a data-type="indexterm" data-primary="QuizCardPlayer" id="idm46038388114544"/></p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Quiz Card Player (code outline)"><div class="sect1" id="quiz_card_player_left_parenthesiscode_ou">
<h1>Quiz Card Player (code outline)</h1>
<pre data-type="programlisting">public class QuizCardPlayer {

  public void <strong>go()</strong> {
    // build and display gui
  }

  private void <strong>nextCard()</strong> {
    // if this is a question, show the answer, otherwise show
    // next question set a flag for whether we’re viewing a
    // question or answer
  }

  private void <strong>open()</strong> {
    // bring up a file dialog box
    // let the user navigate to and choose a card set to open
  }

  private void <strong>loadFile(File file)</strong> {
    // must build an ArrayList of cards, by reading them from
    // a text file called from the OpenMenuListener event handler,
    // reads the file one line at a time and tells the makeCard()
    // method to make a new card out of the line (one line in the
    // file holds both the question and answer, separated by a “/”)
  }

  private void <strong>makeCard(String lineToParse)</strong> {
    // called by the loadFile method, takes a line from the text file
    // and parses into two pieces—question and answer—and creates a
    // new QuizCard and adds it to the ArrayList called CardList
  }
}</pre>
<p/>
<figure class="informal"><div class="figure"><img src="Images/f0568-01.png" alt="image" width="993" height="1119"/>
<h6/>
</div></figure>
<p/>
<figure class="informal"><div class="figure"><img src="Images/f0569-01.png" alt="image" width="931" height="354"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0569-02.png" alt="image" width="987" height="826"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Parsing with String split()"><div class="sect1" id="parsing_with_string_splitleft_parenthesi">
<h1>Parsing with String split()</h1>
<table class="border">
<tbody>
<tr>
<td><p><a data-type="indexterm" data-primary="split()" id="idm46038388101632"/><a data-type="indexterm" data-primary="Strings" data-secondary="split()" id="idm46038388100176"/><strong>Imagine you have a flashcard like this:</strong></p>
<p><img src="Images/f0570-01.png" alt="image" width="462" height="304"/></p></td>
<td><p><strong>Saved in a question file like this:</strong></p>
<p><img src="Images/f0570-02.png" alt="image" width="301" height="372"/></p></td>
</tr>
</tbody>
</table>
<p><strong>How do you separate the question and answer?</strong></p>
<p>When you read the file, the question and answer are smooshed together in one line, separated by a forward slash “/” (because that’s how we wrote the file in the QuizCardBuilder code).</p>
<p><strong>String split() lets you break a String into pieces.</strong></p>
<p>The split() method says, “give me a separator, and I’ll break out all the pieces of this String for you and put them in a String array.”</p>
<figure class="informal"><div class="figure">
<img src="Images/f0570-03.png" alt="image" width="650" height="105"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0570-04.png" alt="image" width="905" height="321"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00044">
<h5>there are no Dumb Questions</h5>
<p><a data-type="indexterm" data-primary="chained streams" id="idm46038388092176"/><a data-type="indexterm" data-primary="I/O" id="idm46038388091280"/><strong>Q: OK, I look in the API and there are about five million classes in the java.io package. How the heck do you know which ones to use?</strong></p>
<p><strong>A:</strong> The I/O API uses the modular “chaining” concept so that you can hook together connection streams and chain streams (also called “filter” streams) in a wide range of combinations to get just about anything you could want.</p>
<p>The chains don’t have to stop at two levels; you can hook multiple chain streams to one another to get just the right amount of processing you need.</p>
<p>Most of the time, though, you’ll use the same small handful of classes. If you’re writing text files, BufferedReader and BufferedWriter (chained to FileReader and FileWriter) are probably all you need. If you’re writing serialized objects, you can use ObjectOutputStream and ObjectInputStream (chained to FileInputStream and FileOutputStream).</p>
<p>In other words, 90% of what you might typically do with Java I/O can use what we’ve already covered.</p>
<p><strong>Q: You just said we’ve already learned 90% of what we’ll probably use, but we haven’t seen the fabled NIO.2 stuff yet. What gives?</strong></p>
<p><strong>A:</strong> NIO.2 is coming up on the very next page! But for reading and writing text files, BufferedReaders and BufferedWriters are still usually the way to go. So we’ll be looking at how NIO.2 makes using them easier.</p>
<p><strong>Q: My brain is a little tired, and I’ve heard NIO.2 is pretty complicated.</strong></p>
<p><strong>A:</strong> We’re going to focus on a few key concepts in the java.nio.file package.</p>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id00000049">
<h5><em>Make it Stick</em></h5>
<figure class="informal"><div class="figure">
<img src="Images/make.png" alt="image" width="134" height="117"/>
<h6/>
</div></figure>
<p><em>Roses are first, violets are next.</em></p>
<p><em><strong>Readers</strong> and <strong>Writers</strong> are only for <strong>text.</strong></em></p>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-id00016">
<h5>Bullet Points</h5>
<ul style="list-style-type:none">
<li><p>To write a text file, start with a FileWriter connection stream.</p></li>
<li><p>Chain the FileWriter to a BufferedWriter for efficiency.</p></li>
<li><p>A File object represents a file at a particular path, but does not represent the actual contents of the file.</p></li>
<li><p>With a File object you can create, traverse, and delete directories.</p></li>
<li><p>Most streams that can use a String filename can use a File object as well, and a File object can be safer to use.</p></li>
<li><p>To read a text file, start with a FileReader connection stream.</p></li>
<li><p>Chain the FileReader to a BufferedReader for efficiency.</p></li>
<li><p>To parse a text file, you need to be sure the file is written with some way to recognize the different elements. A common approach is to use some kind of character to separate the individual pieces.</p></li>
<li><p>Use the String split() method to split a String up into individual tokens. A String with one separator will have two tokens, one on each side of the separator. <em>The separator doesn’t count as a token</em>.</p></li>
</ul>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="NIO.2 and the java.nio.file package"><div class="sect1" id="niodot2_and_the_javadotniodotfile_packag">
<h1>NIO.2 and the <span style="background-color:#231F20; color: #FFFFFF;">java.nio.file</span> package</h1>
<p><a data-type="indexterm" data-primary="BufferedWriter" id="idm46038388065808"/><a data-type="indexterm" data-primary="classes" data-secondary="Files" id="idm46038388065184"/><a data-type="indexterm" data-primary="classes" data-secondary="Paths" id="idm46038388064208"/><a data-type="indexterm" data-primary="Files class" id="idm46038388063232"/><a data-type="indexterm" data-primary="metadata" id="idm46038388062496"/><a data-type="indexterm" data-primary="Path interface" id="idm46038388061760"/><a data-type="indexterm" data-primary="Paths class" id="idm46038388060992"/>Java NIO.2 is usually taken to mean two packages added in Java 7:</p>
<pre data-type="programlisting"><strong>java.nio.file</strong>
<strong>java.nio.file.attribute</strong></pre>
<p>The <code>java.nio.file.attribute</code> package lets you manipulate the <em>metadata</em> associated with a computer’s files and directories. For example, you would use the classes in this package if you wanted to read or change a file’s permissions settings. We WON’T be discussing this package further. (phew)</p>
<p>The <code>java.nio.file</code> package is all you need to do common text file reading and writing, and it also provides you with the ability to manipulate a computer’s directories and directory structure. Most of the time you’ll use three types in java.nio.file:</p>
<ul style="list-style-type:none">
<li><p>The Path interface: You’ll always need a Path object to locate the directories or files you want to work with.</p></li>
<li><p>The Paths class: You’ll use the Paths.get() method to make the Path object you’ll need when you use methods in the Files class.</p></li>
<li><p>The Files class: This is the class whose (static) methods do all the work you’ll want to do: making new Readers and Writers, and creating, modifying, and searching through directories and files on file systems.</p></li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong><span style="color:#646466;">A</span> Path <span style="color:#646466;">object represents the location (name and path) of a file or directory on disk, for example:</span></strong></p>
<p><strong><span style="color:#646466;">/Users/Kathy/Data/Game.txt</span></strong></p>
<p><strong><span style="color:#646466;">But it does NOT represent, or give you access to, the data <em>in</em> the file!</span></strong></p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">An advanced but useful capability in the Files class allows you to “walk thru” (search) directory trees.</span></p>
</div>
<p><strong>A mini-tutorial, creating a BufferedWriter with NIO.2</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0572-01.png" alt="image" width="866" height="453"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Path, Paths, and Files (messing with directories)"><div class="sect1" id="pathcomma_pathscomma_and_files_left_pare">
<h1>Path, Paths, and Files (messing with directories)</h1>
<p><a data-type="indexterm" data-primary="directories" data-secondary="packages" id="idm46038388046624"/>In <a data-type="xref" href="app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d">Appendix B</a>, we’ll be discussing how to split your Java app into packages. This includes creating the proper directory structure for all of your app’s files. In most cases you’ll make and move directories and files by hand, using the command line or utilities like the Finder or Windows Explorer. But you can also do it from within your Java code.</p>
<p><strong>Warning!</strong> Goofing around with directories in a Java program is a real “can of worms” topic. To do it correctly you need to learn about paths, absolute paths, relative paths, OS permissions, file attributes, and on and on. Below is a greatly simplified example of messing around with directories, just to give you a feel for what’s possible.</p>
<p>Suppose you wanted to make an installer program to install your killer app. You start with the directory and files on the left, and want to end up with the directory structure and files on the right.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0573-01.png" alt="image" width="825" height="633"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Finally, a closer look at finally"><div class="sect1" id="finallycomma_a_closer_look_at_finally">
<h1>Finally, a closer look at <code>finally</code></h1>
<p><a data-type="indexterm" data-primary="exception handling" data-secondary="finally block" id="idm46038388068480"/><a data-type="indexterm" data-primary="finally block" id="idm46038389206848"/><a data-type="indexterm" data-primary="I/O" data-secondary="exception handling" id="idm46038388293280"/>Several chapters ago we looked at how try-catch-finally worked. Kind of. All we said about finally was that it was a good place to put your “cleanup code.” That’s true, but let’s get more specific. Most of the time, when we talk about “cleanup code,” we mean closing resources we borrowed from the operating system. When we open a file or a socket, the OS is giving us some of its resources. When we’re done with them, we need to give them back. Below is a snippet of code from the QuizCardBuilder class. We highlighted a call to a constructor and three separate method calls...</p>
<p><strong>That’s FOUR places an exception can be thrown!</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0574-01.png" alt="image" width="891" height="263"/>
<h6/>
</div></figure>
<p>If the call to make a new FileWriter fails, if ANY of the many write() invocations fail, or the close() itself fails, an exception will be thrown, the JVM will jump to the catch block, and the writer will never be closed. Yikes!</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Remember, finally ALWAYS runs!!"><div class="sect1" id="remembercomma_finally_always_runsexclama">
<h1>Remember, <code>finally</code> ALWAYS runs!!</h1>
<p>Since we REALLY want to make sure we close the writer file, let’s put the close() invocation in a finally block.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="coding_the_new_finally_block">
<h5>Coding the new finally block</h5>
<figure class="informal"><div class="figure">
<img src="Images/pencil.png" alt="image" width="122" height="80"/>
<h6/>
</div></figure>
<p>What changes will we have to make to the code above to move the close() to a finally block? There might be more than you first imagine.</p>
<p><span class="inlineimage"><img src="Images/arr.png" alt="Images" width="60" height="12"/></span> <strong>Yours to solve.</strong></p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Finally, a closer look at finally, cont."><div class="sect1" id="finallycomma_a_closer_look_at_finallycom">
<h1>Finally, a closer look at <code>finally</code>, cont.</h1>
<p>The amount of code required to put the close() in the finally block might surprise you; let’s take a look.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0575-01.png" alt="image" width="848" height="456"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0575-02.png" alt="image" width="503" height="523"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="There IS a better way!"><div class="sect1" id="there_is_a_better_wayexclamation_mark">
<h1>There IS a better way!</h1>
<p>In the early days of Java, this is how you had to make sure you were really closing a file. You are very likely to encounter finally blocks that look like this when you’re looking at existing code. But for new code, there is a better way:</p>
<p><strong>Try-With-Resources</strong></p>
<p>We’ll look at that next.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The try-with-resources (TWR), statement"><div class="sect1" id="the_try-with-resources_left_parenthesist">
<h1>The try-with-resources (TWR), statement</h1>
<p><a data-type="indexterm" data-primary="exception handling" data-secondary="try-with-resources statement" id="idm46038388014288"/><a data-type="indexterm" data-primary="TWR (try-with-resources) statement" id="idm46038388012992"/>If you’re using Java 7 or later (and we sure hope you are!), you can use the <br/>try-with-resources version of try statements to make doing I/O easier. Let’s compare the try code we’ve been looking at with try-with-resources code that does the same thing:</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">Old style, try-catch-finally code</span></p>
</div>
<pre data-type="programlisting">private void <strong>saveFile(File file)</strong> {
  BufferedWriter writer = null;
  try {
    writer = new BufferedWriter(new FileWriter(file));

    for (QuizCard card : cardList) {
      writer.write(card.getQuestion() + "/");
      writer.write(card.getAnswer() + "\n");
    }

  } catch (IOException e) {
    System.out.println("Couldn't write the cardList out: " + e.getMessage());
  } finally {
    try {
      writer.close();
    } catch (Exception e) {
      System.out.println("Couldn't close writer: " + e.getMessage());
    }
  }
}</pre>
<hr/>
<pre data-type="programlisting">private void saveFile(File file) {
  <span style="background-color:#E7E7E8;"><strong>try (BufferedWriter writer =</strong>          </span> 
        <span style="background-color:#E7E7E8;"><strong>new BufferedWriter(new FileWriter(file))) {</strong></span>

    for (QuizCard card : cardList) {
      writer.write(card.getQuestion() + "/");
      writer.write(card.getAnswer() + "\n");
    }

  } catch (IOException e) {
    System.out.println("Couldn't write the cardList out: " + e.getMessage());
  }
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">Modern, try-with-resources code</span></p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00045">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: Wait, what? You told us that a try statement needs a catch and/or a finally?</strong></p>
<p><strong>A:</strong> Nice catch! It turns out that when you use try-with-resources, the compiler makes a finally block for you. You can’t see it, but it’s there.</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Autocloseable, the very small catch"><div class="sect1" id="autocloseablecomma_the_very_small_catch">
<h1>Autocloseable, the very small catch</h1>
<p><a data-type="indexterm" data-primary="Autocloseable" id="idm46038388083696"/>On the last page we saw a different kind of try statement, the try-with-resources statement (TWR). Let’s take a look at how to write and use TWR statements by first, deconstructing the following:</p>
<pre data-type="programlisting"><strong>try (BufferedWriter writer =</strong>
       <strong>new BufferedWriter(new FileWriter(file))) {</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#646466;">ONLY classes that implement Autocloseable can be used in TWR statements!</span></p>
</div>
<p><strong>Writing a try-with-resources statement</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0577-02.png" alt="image" width="807" height="315"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Autocloseable, it’s everywhere you do I/O"><div class="sect1" id="autocloseablecomma_itapostrophes_everywh">
<h1>Autocloseable, it’s everywhere you do I/O</h1>
<p>Autocloseable is an interface that was added to java.lang in Java 7. Almost all of the I/O you’re ever going to do uses classes that implement Autocloseable. You mostly won’t have to think about it.</p>
<p>There are a few more things worth knowing about TWR statements:</p>
<ul style="list-style-type:none">
<li><p>You can declare and use more than one I/O resource in a single TWR block:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0577-03.png" alt="image" width="795" height="83"/>
<h6/>
</div></figure></li>
<li><p>If you declare more than one resource, they will be closed in the order OPPOSITE to which they were declared; i.e., first declared is last closed.</p></li>
<li><p>If you add catch or finally blocks, the system will handle multiple close() invocations gracefully.</p></li>
</ul>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Code Kitchen"><div class="sect1" id="code_kitchen-id05000">
<h1>Code Kitchen</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0578-01.png" alt="image" width="1028" height="622"/>
<h6/>
</div></figure>
<p><strong>Let’s make the BeatBox save and restore our favorite pattern.</strong></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Saving a BeatBox pattern"><div class="sect1" id="saving_a_beatbox_pattern">
<h1>Saving a BeatBox pattern</h1>
<p><a data-type="indexterm" data-primary="BeatBox app" data-secondary="saving drum pattern" id="idm46038387988560"/><a data-type="indexterm" data-primary="Code Kitchens" data-secondary="saving BeatBox pattern" id="idm46038387985776"/>Remember, in the BeatBox, a drum pattern is nothing more than a bunch of checkboxes. When it’s time to play the sequence, the code walks through the checkboxes to figure out which drums sounds are playing at each of the 16 beats. So to save a pattern, all we need to do is save the state of the checkboxes.</p>
<p>We can make a simple boolean array, holding the state of each of the 256 checkboxes. An array object is serializable as long as the things <em>in</em> the array are serializable, so we’ll have no trouble saving an array of booleans.</p>
<p>To load a pattern back in, we read the single boolean array object (deserialize it) and restore the checkboxes. Most of the code you’ve already seen, in the Code Kitchen where we built the BeatBox GUI, so in this chapter, we look at only the save and restore code.</p>
<p>This CodeKitchen gets us ready for the next chapter, where instead of writing the pattern to a <em>file</em>, we send it over the <em>network</em> to the server. And instead of loading a pattern <em>in</em> from a file, we get patterns from the <em>server</em>, each time a participant sends one to the server.</p>
<p><strong>Serializing a pattern</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0579-01.png" alt="image" width="987" height="493"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Restoring a BeatBox pattern"><div class="sect1" id="restoring_a_beatbox_pattern">
<h1>Restoring a BeatBox pattern</h1>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Sharpen Your Pencil" id="idm46038387975440"/>This is pretty much the save in reverse...read the boolean array and use it to restore the state of the GUI checkboxes. It all happens when the user hits the “restore” button.</p>
<p><strong>Restoring a pattern</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0580-01.png" alt="image" width="987" height="469"/>
<h6/>
</div></figure>
<p><span class="inlineimage"><img src="Images/arr.png" alt="Images" width="60" height="12"/></span> Yours to solve.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil-id00041">
<h5>Sharpen your pencil</h5>
<figure class="informal"><div class="figure">
<img src="Images/pencil.png" alt="image" width="122" height="80"/>
<h6/>
</div></figure>
<p>This version has a huge limitation! When you hit the “serializeIt” button, it serializes automatically, to a file named “Checkbox.ser” (which gets created if it doesn’t exist). But each time you save, you overwrite the previously saved file.</p>
<p>Improve the save and restore feature by incorporating a JFileChooser so that you can name and save as many different patterns as you like, and load/restore from <em>any</em> of your previously saved pattern files.</p>
</div></aside>
<figure class="informal"><div class="figure">
<img src="Images/pencil1.png" alt="image" width="157" height="48"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Can they be saved?"><div class="sect1" id="can_they_be_savedquestion_mark">
<h1>Can they be saved?</h1>
<p><span class="inlineimage"><img src="Images/arr.png" alt="Images" width="60" height="12"/></span> Yours to solve.</p>
<p>Which of these do you think are, or should be, serializable? If not, why not? Not meaningful? Security risk? Only works for the current execution of the JVM? Make your best guess, without looking it up in the API.</p>
<table class="border">
<thead>
<tr>
<th>Object type</th>
<th>Serializable?</th>
<th>If not, why not?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
<tr>
<td>String</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
<tr>
<td>File</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
<tr>
<td>Date</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
<tr>
<td>OutputStream</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
<tr>
<td>JFrame</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
<tr>
<td>Integer</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
<tr>
<td>System</td>
<td>Yes / No</td>
<td>______________________________________</td>
</tr>
</tbody>
</table>
<p><strong>What’s Legal?</strong></p>
<p>Circle the code fragments that would compile (assuming they’re within a legal class).</p>
<figure class="informal"><div class="figure">
<img src="Images/keep.png" alt="image" width="147" height="185"/>
<h6/>
</div></figure>
<p><span class="inlineimage"><img src="Images/arr.png" alt="Images" width="60" height="12"/></span> Yours to solve.</p>
<pre data-type="programlisting"><strong>FileReader fileReader = new FileReader();</strong>
<strong>BufferedReader reader = new BufferedReader(fileReader);</strong></pre>
<hr/>
<pre data-type="programlisting"><strong>FileOutputStream f = new FileOutputStream("Foo.ser");</strong>
<strong>ObjectOutputStream os = new ObjectOutputStream(f);</strong></pre>
<hr/>
<pre data-type="programlisting"><strong>BufferedReader reader = new BufferedReader(new FileReader(file));</strong>
<strong>String line;</strong>
<strong>while ((line = reader.readLine()) != null) {</strong>
  <strong>makeCard(line);</strong>
<strong>}</strong></pre>
<hr/>
<pre data-type="programlisting"><strong>FileOutputStream f = new FileOutputStream("Game.ser");</strong>
<strong>ObjectInputStream is = new ObjectInputStream(f);</strong>
<strong>GameCharacter oneAgain = (GameCharacter) is.readObject();</strong></pre>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Exercise"><div class="sect1" id="exercise-id000026">
<h1>Exercise</h1>
<figure class="informal"><div class="figure">
<img src="Images/exercise.png" alt="image" width="150" height="126"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="True or False" id="idm46038387922768"/>This chapter explored the wonderful world of Java I/O. Your job is to decide whether each of the following I/O-related statements is true or false.</p>
<section data-type="sect2" data-pdf-bookmark="True or False"><div class="sect2" id="true_or_false-id00001">
<h2>True or False</h2>
<figure class="informal"><div class="figure">
<img src="Images/hand.png" alt="image" width="22" height="27"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/hand1.png" alt="image" width="22" height="27"/>
<h6/>
</div></figure>
<ol>
<li><p>Serialization is appropriate when saving data for non-Java programs to use.</p></li>
<li><p>Object state can be saved only by using serialization.</p></li>
<li><p>ObjectOutputStream is a class used to save serializable objects.</p></li>
<li><p>Chain streams can be used on their own or with connection streams.</p></li>
<li><p>A single call to writeObject() can cause many objects to be saved.</p></li>
<li><p>All classes are serializable by default.</p></li>
<li><p>The java.nio.file.Path class can be used to locate files.</p></li>
<li><p>If a superclass is not serializable, then the subclass can’t be serializable.</p></li>
<li><p>Only classes that implement AutoCloseable can be used in try-with-resources statements.</p></li>
<li><p>When an object is deserialized, its constructor does not run.</p></li>
<li><p>Both serialization and saving to a text file can throw exceptions.</p></li>
<li><p>BufferedWriters can be chained to FileWriters.</p></li>
<li><p>File objects represent files, but not directories.</p></li>
<li><p>You can’t force a buffer to send its data before it’s full.</p></li>
<li><p>Both file readers and file writers can optionally be buffered.</p></li>
<li><p>The methods on the Files class let you operate on files and directories.</p></li>
<li><p>Try-with-resources statements cannot include explicit finally blocks.</p></li>
</ol>
<p><span class="inlineimage"><img src="Images/arr.png" alt="Images" width="60" height="12"/></span> <strong>Answers in <a data-type="xref" href="#true_or_false_left_parenthesisf-id0001">“True or False”</a>.</strong></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Code Magnets"><div class="sect2" id="code_magnets-id000006">
<h2>Code Magnets</h2>
<figure class="informal"><div class="figure">
<img src="Images/f0583-01.png" alt="image" width="137" height="93"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0583-02.png" alt="image" width="100" height="146"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Code Magnets" id="idm46038387897024"/>This one’s tricky, so we promoted it from an Exercise to full Puzzle status. Reconstruct the code snippets to make a working Java program that produces the output listed below. (You might not need all of the magnets, and you may reuse a magnet more than once.)</p>
<figure class="informal"><div class="figure">
<img src="Images/f0583-03.png" alt="image" width="1100" height="1168"/>
<h6/>
</div></figure>
<p><span class="inlineimage"><img src="Images/arr.png" alt="Images" width="60" height="12"/></span> <strong>Answers in <a data-type="xref" href="#true_or_false_left_parenthesisf-id0001">“True or False”</a></strong>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Exercise Solutions"><div class="sect1" id="exercise_solutions-id00009">
<h1>Exercise Solutions</h1>
<figure class="informal"><div class="figure">
<img src="Images/exercise.png" alt="image" width="150" height="126"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="True or False"><div class="sect2" id="true_or_false_left_parenthesisf-id0001">
<h2>True or False</h2>
<p>(from <a data-type="xref" href="#true_or_false-id00001">“True or False”</a>)</p>
<table class="border">
<tbody>
<tr>
<td>1. Serialization is appropriate when saving data for non-Java programs to use.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>2. Object state can be saved only by using serialization.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>3. ObjectOutputStream is a class used to save serializable objects.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>4. Chain streams can be used on their own or with connection streams.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>5. A single call to writeObject() can cause many objects to be saved.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>6. All classes are serializable by default.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>7. The java.nio.file.Path class can be used to locate files.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>8. If a superclass is not serializable, then the subclass can’t be serializable.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>9. Only classes that implement AutoCloseable can be used in try-with-resources statements.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>10. When an object is deserialized, its constructor does not run.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>11. Both serialization and saving to a text file can throw exceptions.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>12. BufferedWriters can be chained to FileWriters.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>13. File objects represent files, but not directories.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>14. You can’t force a buffer to send its data before it’s full.</td>
<td><strong>False</strong></td>
</tr>
<tr>
<td>15. Both file readers and file writers can optionally be buffered.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>16. The methods on the Files class let you operate on files and directories.</td>
<td><strong>True</strong></td>
</tr>
<tr>
<td>17. Try-with-resources statements cannot include explicit finally blocks.</td>
<td><strong>False</strong></td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Code Magnets"><div class="sect2" id="code_magnets_left_parenthesisfrom_page-i">
<h2>Code Magnets</h2>
<p>(from <a data-type="xref" href="#true_or_false_left_parenthesisf-id0001">“True or False”</a>)</p>
<figure class="informal"><div class="figure"><img src="Images/f0585-01.png" alt="image" width="137" height="85"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0585-02.png" alt="image" width="487" height="546"/>
<h6/>
</div></figure>
<pre data-type="programlisting">import java.io.*;

class DungeonGame implements Serializable {
  public int x = 3;
  transient long y = 4;
  private short z = 5;

  int getX() {
    return x;
  }
  long getY() {
    return y;
  }
  short getZ() {
    return z;
  }
}

class DungeonTest {
  public static void main(String[] args) {
    DungeonGame d = new DungeonGame();
    System.out.println(d.getX() + d.getY() + d.getZ());
    try {
      FileOutputStream fos = new FileOutputStream("dg.ser");
      ObjectOutputStream oos = new ObjectOutputStream(fos);
      oos.writeObject(d);
      oos.close();
  
      FileInputStream fis = new FileInputStream("dg.ser");
      ObjectInputStream ois = new ObjectInputStream(fis);
      d = (DungeonGame) ois.readObject();
      ois.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
    System.out.println(d.getX() + d.getY() + d.getZ());
  }
}</pre>
<figure class="informal"><div class="figure">
<img src="Images/f0585-03.png" alt="image" width="309" height="143"/>
<h6/>
</div></figure>
</div></section>
</div></section>
</div></section></div></body></html>