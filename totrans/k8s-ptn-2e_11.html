<html><head></head><body><section data-pdf-bookmark="Chapter 8. Periodic Job" data-type="chapter" epub:type="chapter"><div class="chapter" id="PeriodicJob">&#13;
<h1><span class="label">Chapter 8. </span>Periodic Job</h1>&#13;
&#13;
&#13;
<p>The <em>Periodic Job</em> pattern<a data-primary="Periodic Job" data-type="indexterm" id="perjob08"/> extends the<a data-primary="Batch Job" data-type="indexterm" id="idm45902102414736"/><a data-primary="Batch Job" data-secondary="Periodic Job" data-type="indexterm" id="idm45902102414032"/> <em>Batch Job</em> pattern by adding a time dimension and allowing the execution of a unit of work to be<a data-primary="Jobs" data-secondary="triggering by temporal events (Periodic Jobs)" data-type="indexterm" id="idm45902102412544"/> triggered by a temporal event.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902102411408">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>In<a data-primary="problems" data-secondary="Jobs, triggering by temporal events" data-type="indexterm" id="idm45902102410112"/> the world of distributed systems and microservices, there is a clear tendency toward real-time and<a data-primary="event-driven" data-secondary="application interactions" data-type="indexterm" id="idm45902102408848"/> event-driven application interactions using HTTP and lightweight messaging. However, regardless of the latest trends in software development, job scheduling has a long history, and it is still relevant. Periodic jobs are commonly used for automating<a data-primary="system maintenance" data-type="indexterm" id="idm45902102407760"/> system maintenance or administrative tasks. They are also relevant to business applications requiring specific tasks to be performed periodically. Typical examples here are business-to-business integration through file transfer, application integration through database polling, sending newsletter emails, and cleaning up and archiving old files.</p>&#13;
&#13;
<p>The traditional way of handling periodic jobs for system maintenance purposes has been to use specialized scheduling software or<a data-primary="cron" data-type="indexterm" id="cron08"/> cron. However, specialized software can be expensive for simple use cases, and cron jobs running on a single server are difficult to maintain and represent a single point of failure. That is why, very often, developers tend to implement solutions that can handle both the scheduling aspect and the business logic that needs to be performed. For example, in the Java world, libraries such as<a data-primary="Quartz" data-type="indexterm" id="idm45902102404848"/><a data-primary="Spring Batch" data-type="indexterm" id="idm45902102404176"/> Quartz, Spring Batch, and custom implementations with the<a data-primary="ScheduledThreadPoolExecutor" data-type="indexterm" id="idm45902102403376"/> <code>ScheduledThreadPoolExecutor</code> class can run temporal tasks. But similar to cron, the main difficulty with this approach is making the scheduling capability resilient and highly available, which leads to high resource consumption. Also, with this approach, the time-based<a data-primary="scheduler" data-secondary="Periodic Job" data-type="indexterm" id="idm45902102402192"/> job scheduler is part of the application, and to make the scheduler highly available, the whole application must be highly available. Typically, that involves running multiple instances of the application and at the same time ensuring that only a single instance is active and schedules jobs—which involves leader election and other distributed systems challenges.</p>&#13;
&#13;
<p>In the end, a simple service that has to copy a few files once a day may end up requiring multiple nodes, a distributed leader election mechanism, and more. Kubernetes CronJob implementation<a data-primary="CronJobs" data-secondary="benefits of" data-type="indexterm" id="idm45902102400656"/> solves all that by allowing scheduling of Job resources using the well-known cron format and letting developers focus only on implementing the work to be performed rather than the temporal scheduling aspect.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902102399296">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>In <a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.html#BatchJob">Chapter 7, “Batch Job”</a>, we saw the use cases and the capabilities of Kubernetes Jobs. All of that applies to this chapter as well since the CronJob primitive builds on top of a Job. A<a data-primary="CronJobs" data-secondary="resources" data-type="indexterm" id="CJresource08"/> CronJob instance is similar to one line of a Unix<a data-primary="crontab" data-type="indexterm" id="idm45902102395120"/> crontab (cron table) and manages the temporal aspects of a Job. It allows the execution of a Job periodically at a specified point in time. See <a data-type="xref" href="#ex-cron-job">Example 8-1</a> for a sample definition.</p>&#13;
<div data-type="example" id="ex-cron-job">&#13;
<h5><span class="label">Example 8-1. </span>A CronJob resource</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">batch/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CronJob</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">schedule</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">*/3</code><code class="nv"> </code><code class="s">*</code><code class="nv"> </code><code class="s">*</code><code class="nv"> </code><code class="s">*</code><code class="nv"> </code><code class="s">*</code><code class="s">"</code><code class="w">  </code><a class="co" href="#callout_periodic_job_CO1-1" id="co_periodic_job_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">jobTemplate</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">template</code><code class="p">:</code><code class="w">            </code><a class="co" href="#callout_periodic_job_CO1-2" id="co_periodic_job_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">java</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">RandomRunner</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">/numbers.txt</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">10000</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">OnFailure</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_periodic_job_CO1-1" id="callout_periodic_job_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Cron specification for running every three minutes.</p></dd>&#13;
<dt><a class="co" href="#co_periodic_job_CO1-2" id="callout_periodic_job_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Job template that uses the same specification as a regular Job.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Apart from the Job spec, a CronJob has additional fields to define its temporal aspects:</p>&#13;
<dl>&#13;
<dt><code>.spec.schedule</code></dt>&#13;
<dd>&#13;
<p>Crontab entry for specifying the Job’s schedule (e.g., <code>0 * * * *</code>  for running every hour). You can also use shortcuts like <code>@daily</code> or <code>@hourly</code>. Please refer to the <a href="https://oreil.ly/Qc3TA">CronJob documentation</a> for all available options.</p>&#13;
</dd>&#13;
<dt><code>.spec.startingDeadlineSeconds</code></dt>&#13;
<dd>&#13;
<p>Deadline (in seconds) for starting the Job if it misses its scheduled time. In some use cases, a task is valid only if it executed within a certain timeframe, and it is useless when executed late. For example, if a Job is not executed in the desired time because of a lack of compute resources or other missing dependencies, it might be better to skip an execution because the data it is supposed to process is already obsolete. Don’t use a deadline fewer than 10 seconds since Kubernetes will check the Job status only every 10 seconds.</p>&#13;
</dd>&#13;
<dt><code>.spec.concurrencyPolicy</code></dt>&#13;
<dd>&#13;
<p>Specifies how to manage concurrent executions of Jobs created by the same CronJob. The default behavior <code>Allow</code> creates new Job instances even if the previous Jobs have not completed yet. If that is not the desired behavior, it is possible to skip the next run if the current one has not completed yet with <code>Forbid</code> or to cancel the currently running Job and start a new one with <code>Replace</code>.</p>&#13;
</dd>&#13;
<dt><code>.spec.suspend</code></dt>&#13;
<dd>&#13;
<p>Field suspending all subsequent executions without affecting already-started <span class="keep-together">executions</span>. Note that this is different from a Job’s <code>.spec.suspend</code> as the start of new Jobs will be suspended, not the Jobs themselves.</p>&#13;
</dd>&#13;
<dt><code>.spec.successfulJobsHistoryLimit</code> and <code>.spec.failedJobsHistoryLimit</code></dt>&#13;
<dd>&#13;
<p>Fields specifying how many completed and failed Jobs should be kept for auditing purposes.<a data-primary="" data-startref="cron08" data-type="indexterm" id="idm45902102229552"/></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>CronJob is a very specialized primitive, and it applies only when a unit of work has a temporal dimension. Even if CronJob is not a general-purpose primitive, it is an excellent example of how Kubernetes capabilities build on top of one another and support noncloud native use cases as well.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902102227760">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>As you can see, a CronJob is a pretty simple primitive that adds clustered, cron-like behavior to the existing Job definition. But when it is combined with other primitives such as Pods, container resource isolation, and other Kubernetes features such as those described in<a data-primary="Automated Placement" data-secondary="Periodic Job" data-type="indexterm" id="idm45902102226208"/><a data-primary="Automated Placement" data-type="indexterm" id="idm45902102225232"/><a data-primary="Health Probe" data-type="indexterm" id="idm45902102224560"/><a data-primary="Health Probe" data-secondary="Periodic Job" data-type="indexterm" id="idm45902102223888"/> <a data-type="xref" data-xrefstyle="chap-num-title" href="ch06.html#AutomatedPlacement">Chapter 6, “Automated Placement”</a>, or <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.html#HealthProbe">Chapter 4, “Health Probe”</a>, it ends up being a very powerful job-scheduling system. This enables developers to focus solely on the problem domain and implement a containerized application that is responsible only for the business logic to be performed. The scheduling is performed outside the application, as part of the platform with all of its added benefits, such as high availability, resiliency, capacity, and policy-driven Pod placement. Of course, similar to the Job implementation, when implementing a CronJob container, your application has to consider all corner and failure cases of duplicate runs, no runs, parallel runs, or cancellations.<a data-primary="" data-startref="perjob08" data-type="indexterm" id="idm45902102220320"/><a data-primary="" data-startref="CJresource08" data-type="indexterm" id="idm45902102219344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902102218272">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/yINcj">Periodic Job Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/9096p">CronJob</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/ZPavq">Cron</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Oi3b5">Crontab Specification</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/xYymj">Cron Expression Generator</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>