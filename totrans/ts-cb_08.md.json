["```\nfunction concat(arr1, arr2) {\n  return [...arr1, ...arr2];\n}\n```", "```\n// 7 overloads for an empty second array\nfunction concat(arr1: [], arr2: []): [];\nfunction concat<A>(arr1: [A], arr2: []): [A];\nfunction concat<A, B>(arr1: [A, B], arr2: []): [A, B];\nfunction concat<A, B, C>(arr1: [A, B, C], arr2: []): [A, B, C];\nfunction concat<A, B, C, D>(arr1: [A, B, C, D], arr2: []): [A, B, C, D];\nfunction concat<A, B, C, D, E>(\n  arr1: [A, B, C, D, E],\n  arr2: []\n): [A, B, C, D, E];\nfunction concat<A, B, C, D, E, F>(\n  arr1: [A, B, C, D, E, F],\n  arr2: []\n): [A, B, C, D, E, F];\n// 7 more for arr2 having one element\nfunction concat<A2>(arr1: [], arr2: [A2]): [A2];\nfunction concat<A1, A2>(arr1: [A1], arr2: [A2]): [A1, A2];\nfunction concat<A1, B1, A2>(arr1: [A1, B1], arr2: [A2]): [A1, B1, A2];\nfunction concat<A1, B1, C1, A2>(\n  arr1: [A1, B1, C1],\n  arr2: [A2]\n): [A1, B1, C1, A2];\nfunction concat<A1, B1, C1, D1, A2>(\n  arr1: [A1, B1, C1, D1],\n  arr2: [A2]\n): [A1, B1, C1, D1, A2];\nfunction concat<A1, B1, C1, D1, E1, A2>(\n  arr1: [A1, B1, C1, D1, E1],\n  arr2: [A2]\n): [A1, B1, C1, D1, E1, A2];\nfunction concat<A1, B1, C1, D1, E1, F1, A2>(\n  arr1: [A1, B1, C1, D1, E1, F1],\n  arr2: [A2]\n): [A1, B1, C1, D1, E1, F1, A2];\n// and so on, and so forth\n```", "```\ntype PersonProps = [string, number];\n\nconst [name, age]: PersonProps = ['Stefan', 37];\n```", "```\ntype Foo<T extends unknown[]> = [string, ...T, number];\n\ntype T1 = Foo<[boolean]>;  // [string, boolean, number]\ntype T2 = Foo<[number, number]>;  // [string, number, number, number]\ntype T3 = Foo<[]>;  // [string, number]\n```", "```\ntype Bar<\n  T extends unknown[],\n  U extends unknown[]\n> = [...T, string, ...U];\n\ntype T4 = Bar<[boolean], [number]>;  // [boolean, string, number]\ntype T5 = Bar<[number, number], [boolean]>;  // [number, number, string, boolean]\ntype T6 = Bar<[], []>;  // [string]\n```", "```\nfunction concat<T extends unknown[], U extends unknown[]>(\n  arr1: T,\n  arr2: U\n): [...T, ...U] {\n  return [...arr1, ...arr2];\n}\n\n// const test: (string | number)[]\nconst test = concat([1, 2, 3], [6, 7, \"a\"]);\n```", "```\nfunction concat<T extends unknown[], U extends unknown[]>(\n  arr1: [...T],\n  arr2: [...U]\n): [...T, ...U] {\n  return [...arr1, ...arr2];\n}\n```", "```\n// const test: [number, number, number, number, number, string]\nconst test = concat([1, 2, 3], [6, 7, \"a\"]);\n```", "```\ndeclare const a: string[]\ndeclare const b: number[]\n\n// const test: (string | number)[]\nconst test = concat(a, b);\n```", "```\nfunction loadFile(\n  filename: string,\n  encoding: string,\n  callback: (result: File) => void\n) {\n  // TODO\n}\n\nloadFile(\"./data.json\", \"utf-8\", (result) => {\n  // do something with the file\n});\n\nfunction request(url: URL, callback: (result: JSON) => void) {\n  // TODO\n}\n\nrequest(\"https://typescript-cookbook.com\", (result) => {\n  // TODO\n});\n```", "```\nloadFile(\"./data.txt\", \"utf-8\", (file) => {\n  // pseudo API\n  file.readText((url) => {\n    request(url, (data) => {\n      // do something with data\n    })\n  })\n})\n```", "```\nloadFilePromise(\"./data.txt\", \"utf-8\")\n  .then((file) => file.text())\n  .then((url) => request(url))\n  .then((data) => {\n      // do something with data\n  });\n\n// with async/await\n\nconst file = await loadFilePromise(\"./data.txt\". \"utf-8\");\nconst url = await file.text();\nconst data = await request(url);\n// do something with data.\n```", "```\nfunction promisify(fn: unknown): Promise<unknown> {\n  // To be implemented\n}\n\nconst loadFilePromise = promisify(loadFile);\nconst requestPromise = promisify(request);\n```", "```\ndeclare function hello(name: string, msg: string): void;\n```", "```\ndeclare function hello(...args: [string, string]): void;\n```", "```\ndeclare function h(a: string, b: string, c: string): void;\n// equal to\ndeclare function h(a: string, b: string, ...r: [string]): void;\n// equal to\ndeclare function h(a: string, ...r: [string, string]): void;\n// equal to\ndeclare function h(...r: [string, string, string]): void;\n```", "```\nfunction tuple<T extends any[]>(...args: T): T {\n    return args;\n}\n\nconst numbers: number[] = getArrayOfNumbers();\nconst t1 = tuple(\"foo\", 1, true);  // [string, number, boolean]\nconst t2 = tuple(\"bar\", ...numbers);  // [string, ...number[]]\n```", "```\nfunction loadFile(...args: [string, string, (result: File) => void]) {\n  // TODO\n}\n\nfunction request2(...args: [URL, (result: JSON) => void]) {\n  // TODO\n}\n```", "```\ntype Fn<Args extends unknown[], Res> = (\n  ...args: [...Args, (result: Res) => void]\n) => void;\n```", "```\ntype LoadFileFn = Fn<[string, string], File>;\ntype RequestFn = Fn<[URL], JSON>;\n```", "```\nfunction promisify<Args extends unknown[], Res>(\n  fn: (...args: [...Args, (result: Res) => void]) => void\n): (...args: Args) => Promise<Res> {\n  // soon\n}\n```", "```\nfunction promisify<Args extends unknown[], Res>(\n  fn: (...args: [...Args, (result: Res) => void]) => void\n): (...args: Args) => Promise<Res> {\n  return function (...args: Args) { ![1](assets/1.png)\n    return new Promise((resolve) => { ![2](assets/2.png)\n      function callback(res: Res) { ![3](assets/3.png)\n        resolve(res);\n      }\n      fn.call(null, ...[...args, callback]); ![4](assets/4.png)\n    });\n  };\n}\n```", "```\nfunction add(a: number, b: number) {\n  return a + b;\n}\n\nconst curriedAdd = curry(add); // convert: (a: number) => (b: number) => number\nconst add5 = curriedAdd(5); // apply first argument. (b: number) => number\nconst result1 = add5(2); // second argument. Result: 7\nconst result2 = add5(3); // second argument. Result: 8\n```", "```\nfunction applyClass(\n  this: HTMLElement, // for TypeScript only\n  method: \"remove\" | \"add\",\n  className: string,\n  event: Event\n) {\n  if (this === event.target) {\n    this.classList[method](className);\n  }\n}\n\nconst applyClassCurried = curry(applyClass); // convert\nconst removeToggle = applyClassCurried(\"remove\")(\"hidden\");\n\ndocument.querySelector(\".toggle\")?.addEventListener(\"click\", removeToggle);\n```", "```\nfunction add(a: number, b: number, c: number) {\n  return a + b + c;\n}\n\n// Partial application\nconst partialAdd5And3 = add.bind(this, 5, 3);\nconst result = partialAdd5And3(2); // third argument\n```", "```\nfunction curry(fn) {\n  let curried = (...args) => {\n    // if you haven't collected enough arguments\n    if (fn.length !== args.length) {\n      // partially apply arguments and\n      // return the collector function\n      return curried.bind(null, ...args);\n    }\n    // otherwise call all functions\n    return fn(...args);\n  };\n  return curried;\n}\n```", "```\ntype Curried<F> = F extends (...args: infer A) => infer R\n  ? /* to be done */\n  : never; // not a function, this should not happen\n```", "```\ntype Curried<F> = F extends (...args: infer A) => infer R\n  ? A extends [infer F, ...infer L]\n    ? /* to be done */\n    : () => R\n  : never;\n```", "```\ntype Curried<F> = F extends (...args: infer A) => infer R\n  ? A extends [infer F, ...infer L]\n    ? L extends []\n      ? (a: F) => R\n      : (a: F) => Curried<(...args: L) => R>\n    : () => R\n  : never;\n```", "```\nfunction curry<F extends Function>(fn: F): Curried<F> {\n  let curried: Function = (...args: any) => {\n    if (fn.length !== args.length) {\n      return curried.bind(null, ...args);\n    }\n    return fn(...args);\n  };\n  return curried as Curried<F>;\n}\n```", "```\nfunction addThree(a: number, b: number, c: number) {\n  return a + b + c;\n}\n\nconst adder = curried(addThree);\nconst add7 = adder(5)(2);\nconst result = add7(2);\n```", "```\nfunction addThree(a: number, b: number, c: number) {\n  return a + b + c;\n}\n\nconst adder = curried(addThree);\nconst add7 = adder(5, 2); // this is the difference\nconst result = add7(2);\n```", "```\ntype Adder = (a: number) => (b: number) => (c: number) => number;\ntype Adder = (a: number) => (b: number, c: number) => number;\ntype Adder = (a: number, b: number) => (c: number) => number;\ntype Adder = (a: number, b: number, c: number) => number;\n```", "```\nfunction curry<A extends any[], R extends any>(\n  fn: (...args: A) => R\n): Curried<A, R> {\n  // see before, we're not changing the implementation\n}\n```", "```\ntype Curried<A extends any[], R extends any> = A extends [infer F, ...infer L]\n  ? // to be done\n  : R;\n```", "```\ntype Overloads<A extends any[]> = A extends [infer A, ...infer L]\n  ? [A] | [A, ...Overloads<L>] | []\n  : [];\n```", "```\n// type Overloaded = [] | [string, number, string] | [string] | [string, number]\ntype Overloaded = Overloads<[string, number, string]>;\n```", "```\ntype Curried<A extends any[], R extends any> = A extends [infer F, ...infer L]\n  ? <K extends Overloads<L>>(\n      arg: F,\n      ...args: K\n    ) => /* to be done */\n  : R;\n```", "```\ntype Remove<T extends any[], U extends any[]> = U extends [infer _, ...infer UL]\n  ? T extends [infer _, ...infer TL]\n    ? Remove<TL, UL>\n    : never\n  : T;\n```", "```\ntype Curried<A extends any[], R extends any> = A extends [infer F, ...infer L]\n  ? <K extends Overloads<L>>(\n      arg: F,\n      ...args: K\n    ) => Curried<Remove<L, K>, R>\n  : R;\n```", "```\nfunction applyClass(\n  this: HTMLElement, // for TypeScript only\n  method: \"remove\" | \"add\",\n  className: string,\n  event: Event\n) {\n  if (this === event.target) {\n    this.classList[method](className);\n  }\n}\n\nconst removeToggle = curry(applyClass, \"remove\", \"hidden\");\n\ndocument.querySelector(\"button\")?.addEventListener(\"click\", removeToggle);\n```", "```\nfunction curry(f, ...t) {\n  return (...u) => f(...t, ...u);\n}\n```", "```\ntype Fn<T extends any[], U extends any[]> =\n    (...args: [...T, ...U]) => any;\n```", "```\nfunction curry<T extends any[], U extends any[], R>(\n  f: (...args: [...T, ...U]) => R,\n  ...t: T\n) {\n  return (...u: U) => f(...t, ...u);\n}\n```", "```\nconst Direction = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n\n// Get to the const values of Direction\ntype Direction = (typeof Direction)[keyof typeof Direction];\n\n// (typeof Direction)[keyof typeof Direction] yields 0 | 1 | 2 | 3\nfunction move(direction: Direction) {\n  // tbd\n}\n\nmove(30); // This breaks!\n\nmove(0); //This works!\n\nmove(Direction.Left); // This also works!\n```", "```\nconst Commands = {\n  Shift: \"shift\",\n  Xargs: \"xargs\",\n  Tail: \"tail\",\n  Head: \"head\",\n  Uniq: \"uniq\",\n  Cut: \"cut\",\n  Awk: \"awk\",\n  Sed: \"sed\",\n  Grep: \"grep\",\n  Echo: \"echo\",\n} as const;\n```", "```\nconst commandItems = [\n  \"echo\",\n  \"grep\",\n  \"sed\",\n  \"awk\",\n  \"cut\",\n  \"uniq\",\n  \"head\",\n  \"tail\",\n  \"xargs\",\n  \"shift\",\n] as const;\n```", "```\nfunction capitalize(x: string): string {\n  return x.charAt(0).toUpperCase() + x.slice(1);\n}\n\n// Typings to be done\nfunction createEnum(arr, numeric) {\n  let obj = {};\n  for (let [i, el] of arr.entries()) {\n    obj[capitalize(el)] = numeric ? i : el;\n  }\n  return obj;\n}\n\nconst Command = createEnum(commandItems); // string enum\nconst CommandN = createEnum(commandItems, true); // number enum\n```", "```\ntype TupleToUnion<T extends readonly string[]> = T extends readonly [\n  ...infer Rest extends string[],\n  infer Key extends string\n]\n  ? Key | TupleToUnion<Rest>\n  : never;\n```", "```\ntype Enum<T extends readonly string[], N extends boolean = false> = Readonly<\n  {\n    [K in TupleToUnion<T> as Capitalize<K>]: K\n  }\n>;\n```", "```\n// The type we want to convert to a union type\ntype Direction = [\"up\", \"down\", \"left\", \"right\"];\n\n// Calling the helper type\ntype DirectionUnion = TupleToUnion<Direction>;\n\n// Extracting the last, recursively calling TupleToUnion with the Rest\ntype DirectionUnion = \"right\" | TupleToUnion<[\"up\", \"down\", \"left\"]>;\n\n// Extracting the last, recursively calling TupleToUnion with the Rest\ntype DirectionUnion = \"right\" | \"left\" | TupleToUnion<[\"up\", \"down\"]>;\n\n// Extracting the last, recursively calling TupleToUnion with the Rest\ntype DirectionUnion = \"right\" | \"left\" | \"down\" | TupleToUnion<[\"up\"]>;\n\n// Extracting the last, recursively calling TupleToUnion with an empty tuple\ntype DirectionUnion = \"right\" | \"left\" | \"down\" | \"up\" | TupleToUnion<[]>;\n\n// The conditional type goes into the else branch, adding never to the union\ntype DirectionUnion = \"right\" | \"left\" | \"down\" | \"up\" | never;\n\n// never in a union is swallowed\ntype DirectionUnion = \"right\" | \"left\" | \"down\" | \"up\";\n```", "```\ntype DirectionLength = Direction[\"length\"]; // 4\n```", "```\ntype TupleToUnion<T extends readonly string[]> = T extends readonly [\n  ...infer Rest extends string[],\n  infer Key extends string\n]\n  ? { key: Key; val: Rest[\"length\"] } | TupleToUnion<Rest>\n  : never;\n```", "```\ntype Enum<T extends readonly string[], N extends boolean = false> = Readonly<\n  {\n    [K in TupleToUnion<T> as Capitalize<K[\"key\"]>]: N extends true\n      ? K[\"val\"]\n      : K[\"key\"];\n  }\n>;\n```", "```\ntype Values<T> = T[keyof T];\n\nfunction createEnum<T extends readonly string[], B extends boolean>(\n  arr: T,\n  numeric?: B\n) {\n  let obj: any = {};\n  for (let [i, el] of arr.entries()) {\n    obj[capitalize(el)] = numeric ? i : el;\n  }\n  return obj as Enum<T, B>;\n}\n\nconst Command = createEnum(commandItems, false);\ntype Command = Values<typeof Command>;\n```", "```\nfunction defer<Par extends unknown[], Ret>(\n  fn: (...par: Par) => Ret,\n  ...args: Par\n): () => Ret {\n  return () => fn(...args);\n}\n\nconst log = defer(console.log, \"Hello, world!\");\nlog();\n```", "```\ntype Fn = (...args: any[]) => any;\n\nfunction defer<F extends Fn>(\n  fn: F,\n  ...args: Parameters<F>\n): () => ReturnType<F> {\n  return () => fn(...args);\n}\n```", "```\ntype Parameters<F extends (...args: any) => any> =\n  F extends (...args: infer P) => any ? P : never;\n\ntype ReturnType<F extends (...args: any) => any> =\n  F extends (...args: any) => infer R ? R : any;\n```", "```\ntype Result = {\n  page: URL;\n  title: string;\n  description: string;\n};\n\nfunction search(query: string, tags: string[]): Promise<Result[]> {\n  throw \"to be done\";\n}\n```", "```\nconst searchParams: Parameters<typeof search> = [\n  \"Variadic tuple tpyes\",\n  [\"TypeScript\", \"JavaScript\"],\n];\n\nsearch(...searchParams);\nconst deferredSearch = defer(search, ...searchParams);\n```"]