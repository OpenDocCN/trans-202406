["```\ntype EventName = `on${string}`;\n```", "```\nfunction greet(name: string) {\n  return `Hi, ${name}!`;\n}\n\ngreet(\"Stefan\"); // \"Hi, Stefan!\"\n```", "```\ntype Levels = 1 | 2 | 3 | 4 | 5 | 6;\n\n// resolves to \"H1\" | \"H2\" | \"H3\" | \"H4\" | \"H5\" | \"H6\"\ntype Headings = `H${Levels}`;\n```", "```\ntype EventName = `on${string}`;\n```", "```\ntype EventObject<T> = {\n  val: T;\n};\n\ntype Callback<T = any> = (ev: EventObject<T>) => void;\n```", "```\ntype Events = {\n  [x: EventName]: Callback[] | undefined;\n};\n```", "```\nclass EventSystem {\n  events: Events;\n  constructor() {\n    this.events = {};\n  }\n\n  defineEventHandler(ev: EventName, cb: Callback): void {\n    this.events[ev] = this.events[ev] ?? [];\n    this.events[ev]?.push(cb);\n  }\n\n  trigger(ev: EventName, value: any) {\n    let callbacks = this.events[ev];\n    if (callbacks) {\n      callbacks.forEach((cb) => {\n        cb({ val: value });\n      });\n    }\n  }\n}\n```", "```\nconst system = new EventSystem();\nsystem.defineEventHandler(\"click\", () => {});\n// ^ Argument of type '\"click\"' is not assignable to parameter\n//.  of type '`on${string}`'.(2345)\nsystem.defineEventHandler(\"onClick\", () => {});\nsystem.defineEventHandler(\"onchange\", () => {});\n```", "```\nlet person = {\n  name: \"Stefan\",\n  age: 40,\n};\n\nconst watchedPerson = system.watch(person);\n\nwatchedPerson.onAgeChanged((ev) => {\n  console.log(ev.val, \"changed!!\");\n});\n\nwatchedPerson.age = 41; // triggers callbacks\n```", "```\ntype WatchedObject<T> = {\n  [K in string & keyof T as `on${K}Changed`]: (\n    ev: Callback<T[K]>\n  ) => void;\n};\n```", "```\ntype WatchedObject<T> = {\n  [K in string & keyof T as `on${Capitalize<K>}Changed`]: (\n    ev: Callback<T[K]>\n  ) => void;\n};\n```", "```\ntype WatchedPerson = {\n  onNameChanged: (ev: Callback<string>) => void;\n  onAgeChanged: (ev: Callback<number>) => void;\n};\n```", "```\nfunction capitalize(inp: string) {\n  return inp.charAt(0).toUpperCase() + inp.slice(1);\n}\n\nfunction handlerName(name: string): EventName {\n  return `on${capitalize(name)}Changed` as EventName;\n}\n```", "```\nclass EventSystem {\n  // cut for brevity\n  watch<T extends object>(obj: T): T & WatchedObject<T> {\n    const self = this;\n    return new Proxy(obj, {\n      get(target, property) {\n        // (1)\n        if (\n          typeof property === \"string\" &&\n          property.startsWith(\"on\") &&\n          property.endsWith(\"Changed\")\n        ) {\n          // (2)\n          return (cb: Callback) => {\n            self.defineEventHandler(property as EventName, cb);\n          };\n        }\n        // (3)\n        return target[property as keyof T];\n      },\n      // set to be done ...\n    }) as T & WatchedObject<T>;\n  }\n}\n```", "```\nclass EventSystem {\n  // ... cut for brevity\n  watch<T extends object>(obj: T): T & WatchedObject<T> {\n    const self = this;\n    return new Proxy(obj, {\n      // get from above ...\n      set(target, property, value) {\n        if (property in target && typeof property === \"string\") {\n          // (1)\n          target[property as keyof T] = value;\n          // (2)\n          self.trigger(handlerName(property), value);\n          return true;\n        }\n        return false;\n      },\n    }) as T & WatchedObject<T>;\n  }\n}\n```", "```\nlet person = {\n  name: \"Stefan\",\n  age: 40,\n};\n\nconst watchedPerson = system.watch(person);\n\nwatchedPerson.onAgeChanged((ev) => {\n  console.log(ev.val, \"changed!!\");\n});\n\nwatchedPerson.age = 41; // logs \"41 changed!!\"\n```", "```\nformat(\"Hello {world}. My name is {you}.\", {\n  world: \"World\",\n  you: \"Stefan\",\n});\n```", "```\nfunction format(fmtString: string, params: Record<string, any>): string {\n  throw \"unimplemented\";\n}\n```", "```\nfunction format<T extends string>(\n  fmtString: T,\n  params: Record<string, any>\n): string {\n  throw \"unimplemented\";\n}\n```", "```\ntype FormatKeys<\n  T extends string\n> = T extends `${string}{${string}}${string}`\n  ? T\n  : never;\n```", "```\ntype A = FormatKeys<\"Hello {world}\">; // \"Hello {world}\"\ntype B = FormatKeys<\"Hello\">; // never\n```", "```\ntype FormatKeys<\n  T extends string\n> = T extends `${string}{${infer Key}}${string}`\n  ? Key\n  : never;\n```", "```\ntype A = FormatKeys<\"Hello {world}\">; // \"world\"\ntype B = FormatKeys<\"Hello\">; // never\n```", "```\ntype FormatKeys<\n  T extends string\n> = T extends `${string}{${infer Key}}${infer Rest}`\n  ? Key | FormatKeys<Rest>\n  : never;\n```", "```\ntype A = FormatKeys<\"Hello {world}\">; // \"world\"\ntype B = FormatKeys<\"Hello {world}. I'm {you}.\">; // \"world\" | \"you\"\ntype C = FormatKeys<\"Hello\">; // never\n```", "```\nfunction format<T extends string>(\n  fmtString: T,\n  params: Record<FormatKeys<T>, any>\n): string {\n  throw \"unimplemented\";\n}\n```", "```\nfunction format<T extends string>(\n  fmtString: T,\n  params: Record<FormatKeys<T>, any>\n): string {\n  let ret: string = fmtString;\n  for (let k in params) {\n    ret = ret.replaceAll(`{${k}}`, params[k as keyof typeof params]);\n  }\n  return ret;\n}\n```", "```\nfunction format<T extends string, K extends Record<FormatKeys<T>, any>>(\n  fmtString: T,\n  params: K\n): string {\n  let ret: string = fmtString;\n  for (let k in params) {\n    ret = ret.replaceAll(`{${k}}`, params[k]);\n  }\n  return ret;\n}\n```", "```\nformat(\"Hello {world:string}. I'm {you}, {age:number} years old.\", {\n  world: \"World\",\n  age: 40,\n  you: \"Stefan\",\n});\n```", "```\ntype FormatKeys<\n  T extends string\n> = T extends `${string}{${infer Key}}${infer Rest}`\n  ? Key | FormatKeys<Rest>\n  : never;\n\nfunction format<T extends string>(\n  fmtString: T,\n  params: Record<FormatKeys<T>, any>\n): string {\n  let ret: string = fmtString;\n  for (let k in params) {\n    ret = ret.replace(`{${k}}`, params[k as keyof typeof params]);\n  }\n  return ret;\n}\n```", "```\ntype FormatObj<\n  T extends string\n> = T extends `${string}{${infer Key}}${infer Rest}`\n  ? { [K in Key]: any } & FormatObj<Rest>\n  : {};\n```", "```\ntype FormatObj<\n  T extends string\n> = T extends `${string}{${infer Key}:${infer Type}}${infer Rest}`\n  ? { [K in Key]: Type } & FormatObj<Rest>\n  : {};\n```", "```\ntype MapFormatType = {\n  string: string;\n  number: number;\n  boolean: boolean;\n  [x: string]: any;\n};\n```", "```\ntype A = MapFormatType[\"string\"]; // string\ntype B = MapFormatType[\"number\"]; // number\ntype C = MapFormatType[\"notavailable\"]; // any\n```", "```\ntype FormatObj<\n  T extends string\n> = T extends `${string}{${infer Key}:${infer Type}}${infer Rest}`\n  ? { [K in Key]: MapFormatType[Type] } & FormatObj<Rest>\n  : {};\n```", "```\ntype FormatObj<\n  T extends string\n> = T extends `${string}{${infer Key}}${infer Rest}`\n  ? Key extends `${infer KeyPart}:${infer TypePart}`\n    ? { [K in KeyPart]: MapFormatType[TypePart] } & FormatObj<Rest>\n    : { [K in Key]: any } & FormatObj<Rest>\n  : {};\n```", "```\ntype FormatObj<\n  T extends string\n> = T extends `${string}{${infer Key}}${infer Rest}`\n  ? Key extends `${infer KeyPart}:${infer TypePart}`\n    ? { [K in KeyPart]: MapFormatType[TypePart] } & FormatObj<Rest>\n    : { [K in Key]: { toString(): string } } & FormatObj<Rest>\n  : {};\n```", "```\nfunction format<T extends string, K extends FormatObj<T>>(\n  fmtString: T,\n  params: K\n): string {\n  let ret: string = fmtString;\n  for (let k in params) {\n    let val = `${params[k]}`;\n    let searchPattern = new RegExp(`{${k}:?.*?}`, \"g\");\n    ret = ret.replaceAll(searchPattern, val);\n  }\n  return ret;\n}\n```", "```\ntype Trim<T extends string> =\n  T extends ` ${infer X}` ? Trim<X> :\n  T extends `${infer X} ` ? Trim<X> :\n  T;\n```", "```\ntype Trimmed = Trim<\"     key   \">; // \"key\"\n```", "```\ntype RemoveWhiteSpace<T extends string> = T extends `${infer A} ${infer B}`\n  ? RemoveWhiteSpace<`${Uncapitalize<A>}${Capitalize<B>}`>\n  : T;\n```", "```\ntype Identifier = RemoveWhiteSpace<\"Hello World!\">; // \"helloWorld!\"\n```", "```\ntype StringSplit<T extends string> = T extends `${infer Char}${infer Rest}`\n  ? Capitalize<Char> | Uncapitalize<Char> | StringSplit<Rest>\n  : never;\n\ntype Chars = StringSplit<\"abcdefghijklmnopqrstuvwxyz\">;\n//  \"a\" | \"A\" | \"b\" | \"B\" | \"c\" | \"C\" | \"d\" | \"D\" | \"e\" | \"E\" |\n//  \"f\" | \"F\" | \"g\" | \"G\" | \"h\" | \"H\" | \"i\" | \"I\" | \"j\" | \"J\" |\n//  \"k\" | \"K\" | \"l\" | \"L\" | \"m\" | \"M\" | \"n\" | \"N\" | \"o\" | \"O\" |\n//  \"p\" | \"P\" | \"q\" | \"Q\" | \"r\" | \"R\" | \"s\" | \"S\" | \"t\" | \"T\" |\n//  \"u\" | \"U\" | \"v\" | \"V\" | \"w\" | \"W\" | \"x\" | \"X\" | \"y\" | \"Y\" |\n//  \"z\" | \"Z\"\n```", "```\ntype CreateIdentifier<T extends string> =\n  RemoveWhiteSpace<T> extends `${infer A extends Chars}${infer Rest}`\n  ? `${A}${CreateIdentifier<Rest>}`\n//  ^ Type instantiation is excessively deep and possibly infinite.(2589)_.\n  : RemoveWhiteSpace<T> extends `${infer A}${infer Rest}`\n  ? CreateIdentifier<Rest>\n  : T;\n```", "```\ntype CreateIdentifier<T extends string, Acc extends string = \"\"> =\n  RemoveWhiteSpace<T> extends `${infer A extends Chars}${infer Rest}`\n  ? CreateIdentifier<Rest, `${Acc}${A}`>\n  : RemoveWhiteSpace<T> extends `${infer A}${infer Rest}`\n  ? CreateIdentifier<Rest, Acc>\n  : Acc;\n```", "```\ntype Identifier = CreateIdentifier<\"Hello Wor!ld!\">; // \"helloWorld\"\n```", "```\ntype UserRequest =\n  | {\n      state: \"USER_PENDING\";\n    }\n  | {\n      state: \"USER_ERROR\";\n      message: string;\n    }\n  | {\n      state: \"USER_SUCCESS\";\n      data: User;\n    };\n```", "```\ntype OrderRequest =\n  | {\n      state: \"ORDER_PENDING\";\n    }\n  | {\n      state: \"ORDER_ERROR\";\n      message: string;\n    }\n  | {\n      state: \"ORDER_SUCCESS\";\n      data: Order;\n    };\n```", "```\ntype Pending = {\n  state: `${Uppercase<string>}_PENDING`;\n};\n\ntype Err = {\n  state: `${Uppercase<string>}_ERROR`;\n  message: string;\n};\n\ntype Success = {\n  state: `${Uppercase<string>}_SUCCESS`;\n  data: any;\n};\n\ntype BackendRequest = Pending | Err | Success;\n```", "```\nfunction execute(req: BackendRequest) {\n  switch (req.state) {\n    case \"USER_PENDING\":\n      // req: Pending\n      console.log(\"Login pending...\");\n      break;\n    case \"USER_ERROR\":\n      // req: Err\n      throw new Error(`Login failed: ${req.message}`);\n    case \"USER_SUCCESS\":\n      // req: Success\n      login(req.data);\n      break;\n    case \"ORDER_PENDING\":\n      // req: Pending\n      console.log(\"Fetching orders pending\");\n      break;\n    case \"ORDER_ERROR\":\n      // req: Err\n      throw new Error(`Fetching orders failed: ${req.message}`);\n    case \"ORDER_SUCCESS\":\n      // req: Success\n      displayOrder(req.data);\n      break;\n  }\n}\n```", "```\ntype RequestConstants = \"user\" | \"order\";\n\ntype Pending = {\n  state: `${Uppercase<RequestConstants>}_PENDING`;\n};\n\ntype Err = {\n  state: `${Uppercase<RequestConstants>}_ERROR`;\n  message: string;\n};\n\ntype Success = {\n  state: `${Uppercase<RequestConstants>}_SUCCESS`;\n  data: any;\n};\n```", "```\ntype Data = {\n  user: User | null;\n  order: Order | null;\n};\n\ntype RequestConstants = keyof Data;\n\ntype Pending = {\n  state: `${Uppercase<RequestConstants>}_PENDING`;\n};\n\ntype Err = {\n  state: `${Uppercase<RequestConstants>}_ERROR`;\n  message: string;\n};\n```", "```\ntype Success = {\n  state: `${Uppercase<RequestConstants>}_SUCCESS`;\n  data: NonNullable<Data[RequestConstants]>;\n};\n```", "```\ntype Success = {\n  [K in RequestConstants]: {\n    state: `${Uppercase<K>}_SUCCESS`;\n    data: NonNullable<Data[K]>;\n  };\n}[RequestConstants];\n```", "```\ntype Success = {\n    state: \"USER_SUCCESS\";\n    data: User;\n} | {\n    state: \"ORDER_SUCCESS\";\n    data: Order;\n};\n```"]