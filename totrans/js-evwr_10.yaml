- en: Chapter 9\. Details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the now-near-ubiquitous air freshener Febreze was first released, it was
    a dud. The original ads showed people using the product to remove specific bad
    smells, such as cigarette smoke, resulting in poor sales. Faced with this disappointing
    outcome, the marketing team shifted focus to using Febreze as a finishing detail.
    Now, the ads depicted someone cleaning a room, fluffing the pillows, and completing
    the tasks of refreshing a room with a spritz of Febreze. This reframing of the
    product caused sales to skyrocket.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great example of the fact that *details matter*. Right now we have
    a working API, but it’s lacking the finishing touches that will allow us to put
    it into production. In this chapter we’ll implement some web and GraphQL application
    security and user experience best practices. These details, far exceeding a spritz
    of air freshener, will be critical to the safety, security, and usability of our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Web Application and Express.js Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js is the underlying web application framework that powers our API.
    We can make a few small tweaks to our Express.js code to provide a solid basis
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Express Helmet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Express [Helmet middleware](https://oreil.ly/NGae1) is a collection of small
    security-minded middleware functions. These will adjust our application’s HTTP
    headers to be more secure. While many of these are specific to browser-based applications,
    enabling Helmet is a simple step to protect our application from common web vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Helmet, we’ll require the middleware in our application and instruct
    Express to use it early in our middleware stack. In the *./src/index.js* file,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By adding the Helmet middleware, we’re quickly enabling common web security
    best practices for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS) is the means by which we allow resources
    to be requested from another domain. Because our API and UI code will live separately,
    we’ll want to enable credentials from other origins. If you’re interested in learning
    the ins and outs of CORS, I highly recommend the [Mozilla CORS Guide](https://oreil.ly/E1lXZ).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable CORS, we’ll use the Express.js [CORS middleware](https://oreil.ly/lYr7g)
    package in our *.src/index.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By adding the middleware in this way, we are enabling cross-origin requests
    from *all* domains. This works well for us for now, as we’re in development mode
    and will likely be using domains generated by our hosting providers, but by using
    the middleware, we could also limit the requests to those of specific origins.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently our `notes` and `users` queries return the full list of notes and
    users in the database. This works fine for local development, but as our application
    grows it will become unsustainable, as a query that returns potentially hundreds
    (or thousands) of notes is expensive and will slow down our database, server,
    and network. Instead, we can paginate those queries, returning only a set number
    of results.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common types of pagination that we could implement. The first
    type, *offset pagination*, works by the client passing an offset number and returning
    a limited amount of data. For example, if each page of data were limited to 10
    records, and we wanted to request the third page of data, we could pass an offset
    of 20\. While this is the most straightforward approach conceptually, it can run
    into scaling and performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of pagination is *cursor-based pagination*, in which a time-based
    cursor or unique identifier is passed as a starting point. We then request a specific
    amount of data that follows this record. This approach gives us the greatest control
    over our pagination. Additionally, because Mongo’s object IDs are ordered (they
    begin with a 4-byte time value), we can easily utilize them as our cursor. To
    learn more about Mongo’s object ID, I recommend reading [the corresponding MongoDB
    documentation](https://oreil.ly/GPE1c).
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds overly conceptual to you, that’s OK. Let’s walk through implementing
    a paginated feed of notes as a GraphQL query. First, let’s define what we’ll be
    creating, followed by our schema updates, and lastly our resolver code. For our
    feed we’ll want to query our API while optionally passing a cursor as a parameter.
    The API should then return a limited amount of data, a cursor point representing
    the last item in the data set, and a Boolean value if there is an additional page
    of data to query.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this description, we can update our *src/schema.js* file to define this
    new query. First, we’ll need to add a `NoteFeed` type to our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll add our `noteFeed` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With our schema updated, we can write the resolver code for our query. In *./src/resolvers/query.js*,
    add the following to the exported object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this resolver in place, we can query our `noteFeed`, which will return
    a maximum of 10 results. In the GraphQL Playground, we can write a query as follows
    to receive a list of notes, their object IDs, their “created at” timestamp, the
    cursor, and the next page boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have more than 10 notes in our database, this returns a cursor as
    well as a `hasNextPage` value of `true`. With that cursor, we can query the second
    page of the feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can continue to do this for each cursor where the `hasNextPage` value is
    `true`. With this implementation in place, we’ve created a paginated feed of notes.
    This will both allow our UI to request a specific feed of data as well as reduce
    the burden on our server and database.
  prefs: []
  type: TYPE_NORMAL
- en: Data Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to establishing pagination, we’ll want to limit the amount of data
    that can be requested through our API. This prevent queries that could overload
    our server or database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple first step in this process is to limit the amount of data that a query
    can return. Two of our queries, `users` and `notes`, return all of the matching
    data from the database. We could address this by setting a `limit()` method on
    our database queries. For example, in our *.src/resolvers/query.js* file, we can
    update our `notes` query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While limiting data is a solid start, currently our queries can be written with
    an unlimited depth. This means that a single query could be written to retrieve
    a list of notes, the author information for each of those notes, the list of favorites
    of each author, the author information for each of those favorites, and so on.
    That’s a lot of data in one query, and we could keep going! To prevent these types
    of overnested queries, we can *limit the depth* of queries against our API.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we might have complex queries that are not overly nested, but
    still require heavy computation to return the data. We can protect against these
    types of requests by *limiting query complexity*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement these limits by using the `graphql-depth-limit` and `graphql-validation-complexity`
    packages in our *./src/index.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With these package additions, we’ve added extra query protection to our API.
    For more information on securing a GraphQL API from malicious queries, check out
    the [fantastic article](https://oreil.ly/_r5tl) from Max Stoiber, CTO of Spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: Other Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After building our API, you should have a solid understanding of the fundamentals
    of GraphQL development. If you’re eager to dig in more on the topics, some excellent
    places to go next would be testing, GraphQL subscriptions, and Apollo Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK, I’ll admit it: I feel guilty for not writing about tests in this book.
    Testing our code is important because it allows us to comfortably make changes
    and improves our collaboration with other developers. One of the great things
    about our GraphQL setup is that resolvers are simply functions, taking some parameters
    and returning data. This makes our GraphQL logic straightforward to test.'
  prefs: []
  type: TYPE_NORMAL
- en: Subscriptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subscriptions are an incredibly powerful feature of GraphQL, which offers a
    straightforward way to integrate the publish-subscribe pattern in our application.
    This means that a UI can subscribe to be notified or updated when data is published
    on the server. This makes GraphQL servers an ideal solution for applications that
    work with real-time data. For more information about GraphQL subscriptions, take
    a look at the [Apollo Server documentation](https://oreil.ly/YwI5_).
  prefs: []
  type: TYPE_NORMAL
- en: Apollo GraphQL Platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the development of our API, we’ve been using the Apollo GraphQL library.
    In future chapters we’ll also be using the Apollo client libraries to interface
    with our API. I’ve chosen these libraries because they are industry standards
    and offer a great developer experience for working with GraphQL. If you take your
    application to production, Apollo, the company who maintains these libraries,
    also offers a platform that provides monitoring and tooling for GraphQL APIs.
    You can learn more at [Apollo’s website](https://www.apollographql.com).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we added some finishing touches to our application. Though there
    are many other options we could implement, at this point we have developed a solid
    MVP (minimum viable product). In this state, we are ready to launch our API! In
    the next chapter, we’ll deploy our API to a public web server.
  prefs: []
  type: TYPE_NORMAL
