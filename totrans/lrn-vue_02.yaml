- en: 'Chapter 2\. How Vue Works: The Basics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned the essential tools for building a Vue
    application and also created your first Vue application, preparing you for the
    next step: learning how Vue works by writing Vue code.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the concepts of Virtual Document Object Model
    (Virtual DOM) and the fundamentals of writing a Vue component with Vue Options
    API. It also explores further Vue directives and the Vue reactivity mechanism.
    By the end of the chapter, you will understand how Vue works and be able to write
    and register a Vue component for use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM Under the Hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue doesn’t work directly with the Document Object Model (DOM). Instead, it
    implements its Virtual DOM to optimize the application’s performance on run-time.
  prefs: []
  type: TYPE_NORMAL
- en: To build a solid understanding of how Virtual DOM works, we start with the concept
    of the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM represents the HTML (or XML) document content on the web, in the form
    of an in-memory tree-like data structure (as shown in [Figure 2-1](#figure_01)).
    It acts as a programming interface that connects the web page and the actual programming
    code (such as JavaScript). Tags, such as `<div>` or `<section>`, in the HTML document
    are represented as programmatic nodes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![An image illustrated different HTML elements connected, distributing by nesting
    levels](assets/lvue_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Example of a DOM tree
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After the browser parses the HTML document, the DOM will be available for interaction
    immediately. Upon any layout changes, the browser then paints and repaints the
    DOM constantly in the background. We call the process parsing, and painting the
    DOM screen rasterization or the *pixel-to-screen* pipeline. [Figure 2-2](#figure_02)
    demonstrates how rasterization works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An image illustrated a flow diagram consisting of five major steps, including
    parsing HTML and CSS code, calculating the CSS styles for elements, planning for
    screen layout, then painting the visual elements, and finally applying the composition
    layer on them on the browsers. It also highlights where repaint and reflow happens
    whenever layout changes happen.](assets/lvue_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Browser rasterization process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Layout Update Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each paint is costly to the browser’s performance. Since the DOM may consist
    of many nodes, querying and updating single or multiple nodes can be extremely
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of a list of `li` elements in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adding/removing a `li` element or modifying its content requires querying the
    DOM for that item using `document.getElementById` (or `document.getElementsByClassName`).
    Then you need to perform the desired updates using the appropriate DOM APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you want to add a new item to the previous example, you need
    to do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Query the containing list element by its `id` attribute’s value—`"todo-list"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new `li` element using `document.createElement()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `textContent` and the relevant attributes to match other element’s standard
    using `setAttribute()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Append that element to the list element found in step 1 as its child using
    `appendChild()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, suppose you want to change the text content of the 2nd `li` item
    to `"buy groceries"`. In that case, you perform step 1 to get the containing list
    element, then query the target element using `getElementsByClassName()`, and finally
    change its `textContent` to the new content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Querying and updating the DOM on a small scale usually do not enormously impact
    performance. However, these actions can slow the page if performed more repetitively
    (within a few seconds) and on a more complex web page. The performance impact
    is significant when there are consecutive minor updates. Many frameworks, such
    as Angular 1.x, fail to acknowledge and address this performance issue as the
    codebase grows. The Virtual DOM is designed to solve the layout update problem.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Virtual DOM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtual DOM is the *in-memory virtual copy version* of the actual DOM in the
    browser, but it is lighter weight and has extra functionalities. It mimics the
    real DOM structure, with a different data structure (usually `Object`) (see [Figure 2-3](#figure_03)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The left side of the image is a sample DOM structure with three nesting levels.
    The first level is a single div element. The second level contains two div and
    single h2 elements. The third level contains a ul and button elements nested in
    the first div of the second level, a text element nested in the second div of
    the second level, and a paragraph element nested in the h2 element. The right
    side of the image is the virtual DOM tree structure, with the same levels and
    relationships of the DOM on the left side, and all the elements changed to JSON
    objects with one property named tag for each. The tag property contains the name
    of the actual component, representing the related DOM element that appeared in
    the DOM tree on the left side.](assets/lvue_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. The browser DOM vs. the Virtual DOM
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Behind the scenes, the Virtual DOM still uses the DOM API to construct and render
    updated elements in the browser. Thus, it still causes the browser’s repainting
    process, but more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In short, Virtual DOM is an abstract pattern aiming to free the DOM from all
    the actions that can lead to performance inefficiencies, such as manipulating
    attributes, handling events, and manually updating DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: How Virtual DOM Works in Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Virtual DOM sits between the real DOM and the Vue application code. The
    following is an example of what a node in the Virtual DOM looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call this node VNode. VNode is a *virtual node* that resides within the
    Virtual DOM and represents the actual DOM element in the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Through UI interactions, the user tells Vue what state they wish the element
    to be in; Vue then triggers the Virtual DOM to update that element’s represented
    object (`node`) to the desired shape while keeping track of those changes. Finally,
    it communicates with the actual DOM and performs accurate updates on the changed
    nodes accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Virtual DOM is a tree of custom JavaScript objects, updating a component
    equals updating a custom JavaScript object. This process doesn’t take long. Because
    we don’t call any DOM API, this update action doesn’t cause a DOM repainting.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Virtual DOM finishes updating itself, it syncs in batch with the actual
    DOM, leading the changes to be reflected on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-4](#figure_04) illustrates how updates from the Virtual DOM to the
    actual DOM work when adding a new list item and changing the list item’s text.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram demonstrates how an update happens in actual DOM by comparing the
    differences between actual DOM and virtual DOM and performing a patch update to
    actual DOM.](assets/lvue_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Updating from Virtual DOM to actual DOM adding a new element and
    updating the text of an existing element in the list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since the Virtual DOM is a tree of objects, we can easily track the specific
    updates that need to be synced with the actual DOM when modifying the Virtual
    DOM. Instead of querying and updating directly on the actual DOM, we can now schedule
    and call the updated APIs with a single render function in one update cycle to
    maintain performance efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how Virtual DOM works, we will explore the Vue instance
    and the Vue Options API.
  prefs: []
  type: TYPE_NORMAL
- en: The Vue App Instance and Options API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Vue application starts with a single Vue component instance as the application
    root. Any other Vue component created in the same application needs to be nested
    inside this root component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can find the initialization code example in `main.ts` of our Vue project.
    Vite automatically generates the code as part of its scaffolding process.
  prefs: []
  type: TYPE_NORMAL
- en: You will also find the example code of this chapter within this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Vue 2, Vue exposes a `Vue` class (or JavaScript function) for you to create
    a Vue component instance based on a set of configuration options, using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Vue` receives a component, or the component’s configuration to be more precise.
    A component’s configuration is an `Object` containing all the component’s initial
    configuration options. We call the structure of this argument *Options API*, which
    is another of Vue’s core APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with Vue 3, you can no longer call `new Vue()` directly. Instead,
    you create the application instance using the `createApp()` method from the `vue`
    package. This change in functionality enhances the isolation of each Vue instance
    created both on dependencies and shared components (if any) and the code readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`createApp()` also accepts an `Object` of the component’s configurations. Based
    on these configurations, Vue creates a Vue component instance as its application
    root `app`. Then you need to mount the root component `app` to the desired HTML
    element using the `app.mount()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`#app` is the unique id selector for the application’s root element. The Vue
    engine queries for the element using this id, mounts the app instance to it, then
    renders the application in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to provide the configurations for Vue to build a component
    instance according to Options API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From this point on, we write code according to Vue 3 API standards.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Options API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Options API is Vue’s core API for initializing a Vue component. It contains
    the component’s configurations structured in an Object format.
  prefs: []
  type: TYPE_NORMAL
- en: 'We divide its essential properties into four main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: State handling
  prefs: []
  type: TYPE_NORMAL
- en: Including `data()`, which returns the local data state for the component, `computed`,
    `methods`, and `watch` for enabling observation on specific local data, and `props`
    for the incoming data.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs: []
  type: TYPE_NORMAL
- en: '`template` for the HTML view template and `render()` as the rendering logic
    for the component.'
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs: []
  type: TYPE_NORMAL
- en: Such as `beforeCreate()`, `created()`, `mounted()`, etc., for handling different
    stages of a component’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Others
  prefs: []
  type: TYPE_NORMAL
- en: Such as `provide()`, `inject()` for handling different customization and communication
    between components. And `components`, a collection of nested component templates
    to use within the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example structure of our root `App` component based on
    Options API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, an HTML template displays regular text. We can also define
    a local `data` state using `data()` function, which we will discuss further in
    [“Creating Local State with Data Properties”](#local_state).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also rewrite the previous code to use the `render()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both codes will generate the same result ([Figure 2-5](#figure_05)).
  prefs: []
  type: TYPE_NORMAL
- en: '![An image displays a text saying this is the app''s entrance.](assets/lvue_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Sample output of writing a root component using Options API
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you open the Elements tab in the browser’s Developer Tools, you will see
    the actual DOM now contains a div with `id="app"` and a text content `*This is
    the app’s entrance*` ([Figure 2-6](#figure_06)).
  prefs: []
  type: TYPE_NORMAL
- en: '![An image displays the actual DOM with the rendered HTML code.](assets/lvue_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. The DOM tree in the browser has a div containing the app’s text
    content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also create a new component, `Description`, which renders a static text
    and passes it to `components` of the `App`. Then you can use it as a nested component
    in the `template`, like in [Example 2-1](#nest_components).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Declare an internal component template to use in the `App`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output stays the same as in [Figure 2-6](#figure_06).
  prefs: []
  type: TYPE_NORMAL
- en: Note here you must declare either `template` or `render()` function (see [“The
    Render Function and JSX”](ch07.html#render_function)) for the component. However,
    you don’t need these properties in case you are writing the component in Single
    File Component (SFC) standard. We will discuss this component standard in [Chapter 3](ch03.html#unique_chapter_id_03).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the `template` property syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The Template Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Options API, `template` accepts a single string that contains valid HTML-based
    code and represents the component’s UI layout. The Vue engine parses this value
    and compiles it into optimized JavaScript code, then accordingly renders the relevant
    DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates our root component `App`, whose layout is a
    single `div` displaying text—`This is the app’s entrance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For multi-level HTML template code, we can use backtick characters (JavaScript
    template literals), denoted by `` ` `` symbol, and maintain the readability. We
    can rewrite `App`’s template in the previous example to include other `h1` and
    `h2` elements, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Vue engine will render to the DOM with two headings ([Figure 2-7](#figure_10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The image displays two headings, one says This is the app''s entrance in
    large bold font, the other says We are exploring template syntax in smaller bold
    font](assets/lvue_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Output of a multi-level template for a component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `template` property syntax is essential for creating the binding between
    a specific DOM element and the component’s local data using directives and a dedicated
    syntax. We will explore how to define the data we want to display in the UI next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Local State with Data Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most components keep their local state (or local data) or receive data from
    an external source. In Vue, we store the component’s local state using the Options
    API `data()` function property.
  prefs: []
  type: TYPE_NORMAL
- en: '`data()` is an anonymous function that returns an object representing the local
    data state of a component. We call that returned object the *data object*. When
    initializing the component instance, the Vue engine will add each property of
    this data object to its reactivity system for tracking its changes and triggering
    the re-rendering of the UI template accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, the data object is the reactive state of a component.
  prefs: []
  type: TYPE_NORMAL
- en: To inject the data property in the template, we use the *mustache* syntax, denoted
    by double curly braces `{{}}`. Within the HTML template, we wrap the data property
    with the curly braces where we need to inject its value, as seen in [Example 2-2](#mustache).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Inject title to display in the HTML template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we declare the local data property `title` and inject
    its value in the template of `App` by using the `{{ title }}` expression. The
    output in the DOM equals the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine an inline static text with double curly braces within
    the same element tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Vue automatically preserves the static text and replaces only the expression
    with the correct value. The result equals the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All data object properties are available for access directly and internally
    through the component instance `this`. And `this` is accessible in any component’s
    local methods, computed properties, and lifecycle hooks. For example, we can print
    out `title` to the console after creating a component with the hook `created()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We cast `this` as a `ComponentOptions<Data>` type. We will enable full TypeScript
    support for the Vue component in Vue 3 using `defineComponent`, which we will
    discuss further in [“Using defineComponent() for TypeScript Support”](ch03.html#define_component).
  prefs: []
  type: TYPE_NORMAL
- en: You can debug the reactivity of a data property by using the Vue Devtools. On
    the main page of our application, open the browser’s Developer Tools, head to
    the Vue tab, and select the `Root` component displayed in the Inspector panel.
    Once this is selected, a right-side panel will appear, showing the component data
    object’s properties. When you hover on the `title` property, a pen icon will appear,
    allowing you to edit the property value ([Figure 2-8](#figure_18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displays the Vue Devtool, with title property is highlighted
    and a pen icon appeared on the right of the row next to the property value.](assets/lvue_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. How to debug and edit a data property using Vue Devtools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on that edit icon button, modify the `title` value, and hit Enter; the
    application UI instantly reflects the new value.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to use `data()` and double curly braces `{{}}` to inject
    the local data to the UI template. This is a type of one-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explore the two-way binding and other directives in Vue, let’s look
    at reactivity in Vue.
  prefs: []
  type: TYPE_NORMAL
- en: How Reactivity in Vue Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how reactivity works, let’s take a quick look at how the Virtual
    DOM processes all the received information, creates, and keeps track of created
    VNodes before yielding to the actual DOM ([Figure 2-9](#figure_05_01)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram demonstrates how a render happens from Virtual DOM to actual DOM
    when a component data changes, in five different flow states.](assets/lvue_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. The flow of Virtual DOM’s rendering process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can describe the previous process diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you define the local data, in Vue.js 2.0, the internal Vue engine uses
    JavaScript’s built-in `Object.defineProperty()` to establish the *getters and
    setters* for each related piece of data and enables relevant data reactivity.
    In Vue.js 3.0, however, the Vue engine uses the ES5 Proxy-based mechanism^([1](ch02.html#id564))
    for performance enhancement, doubling run-time performance and reducing the memory
    needed by half. We will explain more about this reactivity mechanism in [Chapter 3](ch03.html#unique_chapter_id_03).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting up the reactivity mechanism, the Vue engine uses *watcher* objects
    to keep track of any data update triggered by the setters. Watchers help the Vue
    engine detect changes and update the Virtual DOM and the actual DOM through a
    *Queue* system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vue uses the Queue system to avoid inefficient multiple updates of the DOM within
    a short time. A watcher adds itself to the Queue upon a related component’s data
    change. The Vue engine sorts it by a specific order for consumption. Until the
    Vue engine finishes consuming and flushing that watcher from the Queue, only one
    watcher of the same component exists within the Queue, regardless of the number
    of data changes. This consumption process is done by `nextTick()` API, which is
    a Vue function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, after the Vue engine consumes and flushes all the watchers, it triggers
    the `run()` function of each watcher to update the component’s real DOM and Virtual
    DOM automatically, and the application renders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s perform another example. This time we use `data()` and the help of `created()`
    to demonstrate reactivity in the application. `created()` is the lifecycle hook
    that the Vue engine triggers after creating the component instance and before
    mounting it to the DOM element. At this point, we won’t discuss this hook further
    but use this hook to perform a timer update on a data property `counter` with
    `setInterval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code increments the `counter` every one second.^([2](ch02.html#id574))
    We also use `setTimeout()` to clear the interval after 5 seconds. On the browser,
    you can see the displayed value changing from 0 to 5 every second. The final output
    will equal the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After understanding the concept of reactivity and rendering in Vue, we are ready
    to explore how to perform two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Two-Way Binding with v-model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two-way binding refers to how we sync data between a component’s logic and its
    view template. When a component’s data field changes programmatically, the new
    value reflects on its UI view. And vice versa, when a user makes changes to the
    data field on the UI view, the component automatically gets and saves the updated
    value, keeping both the internal logic and the UI synchronized. A good example
    of two-way binding is the form input field.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding is a complex yet beneficial use case for application development.
    One common scenario for two-way binding is form input synchronization. Proper
    implementation saves developing time and reduces complexity to maintain data consistency
    between the actual DOM and component data. But implementing two-way binding is
    a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Vue makes two-way binding much simpler with the `v-model` directive.
    Binding the `v-model` directive to a component’s data model will automatically
    trigger updating the template when the data model changes, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is straightforward; the value passing to `v-model` is the name alias
    declared in the `data` return object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have a `NameInput` component that receives text input from the user,
    with the following `template` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to sync the the input value received with a local data model, naming
    `name`. To do so, we add `v-model="name"` to the `input` element and declare the
    data model in `data()` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The value of `name` will change whenever the user changes the `input` field
    on run-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have this component render in the browser, we add `NameInput` as one of
    the components for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can track this data change by opening the Vue tab in the browser’s Developer
    Tools. Within the Inspector tab, find and select the `NameInput` element under
    the `Root` element, and you will see the component’s data displayed on the right
    panel of the Vue tab ([Figure 2-10](#figure_15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of developer tools opened at the bottom of the browser, with
    Vue is the active tab and displays the component''s information on the right panel.](assets/lvue_0210.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10\. Debug the input component using the Vue tab in Developer Tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you change the input field, the `name` property under `data` displayed
    on the right side of the Vue tab also will get the updated value ([Figure 2-11](#figure_16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displays how the input field with new value typed will also
    reflect on the ''name'' data property seen in Vue tab.](assets/lvue_0211.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-11\. Input value changes sync with the relevant component’s data model
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use the same approach for building a checklist with multiple options.
    In this scenario, you need to declare the data model as an `Array` and add the
    `v-model` binding on each checkbox input field. [Example 2-3](#course_checklist)
    demonstrates how it looks for a `Course``Checklist`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Create a course checklist using `v-model` and checkbox input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Vue automatically adds or removes an input value to the `list` array according
    to the user’s interaction ([Figure 2-12](#figure_17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displays a course checklist, with three options presented as
    checkbox for selecting.](assets/lvue_0212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-12\. Screenshot of the list value after the user makes a selection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using v-model.lazy Modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Updating a data value on every user keystroke can be too much, especially when
    displaying that input value in other places. Remember Vue re-renders the template
    UI according to the data changes. By enabling two-way syncing on every input key
    received, you expose your application to potential unnecessary re-rendering. To
    reduce this overhead, you can use the `v-model.lazy` modifier instead of the regular
    `v-model` to bind with the data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This modifier ensures the `v-model` will only track changes triggered by the
    `onChange` event of that input element.
  prefs: []
  type: TYPE_NORMAL
- en: Using `v-model.number` and `v-model.trim` Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the data model you are binding to `v-model` should be a number type, you
    can use the modifier `v-model.number` to convert the input value to a number.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you want to ensure the string data model free from trailing whitespaces,
    you can use `v-model.trim` instead.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all for two-way binding. Next we’ll examine the more common directive
    `v-bind` for one-way binding.
  prefs: []
  type: TYPE_NORMAL
- en: Binding Reactive Data and Passing Props Data with v-bind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously we learned to use `v-model` for two-way binding and double curly
    braces `{{}}` for one-way data injection. But to perform one-way binding of data
    to another element as an attribute’s values or other Vue components as props,
    we use `v-bind`.
  prefs: []
  type: TYPE_NORMAL
- en: '`v-bind`, denoted by `:`, is the most used Vue directive in any application.
    We can bind an element’s attribute (or component’s props) or more to JavaScript
    expressions, following this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for short, with `:` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we have `imageSrc` data, an image URL. To display the image using
    `<img>` tag, we perform the following binding to its `src` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Binding a source to an image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Vue takes the value of `imageSrc` and binds it to the `src` attribute, resulting
    in the following code on the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Vue updates the `src` whenever `imageSrc`’s value changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can add `v-bind` on an element as a standalone attribute. `v-bind`
    accepts an object containing all the attributes to bind as properties and the
    expressions as their values. [Example 2-5](#v_bind_02) rewrites [Example 2-4](#v_bind_01)
    to demonstrate this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Binding source and alt text to an image using an object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Example 2-5](#v_bind_02), we bind an object `image` with two properties,
    `src` for the image URL and `alt` for its alt text to the element `<img>`. The
    Vue engine will automatically parse `image` into relevant attributes by its properties’
    names, and then generate the following HTML code in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Binding to Class and Style Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When binding to `class` or `style` attributes, you can pass expressions in array
    or object type. The Vue engine knows how to parse and unite them into the proper
    styling or class name string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s add some classes to our `img` in [Example 2-5](#v_bind_02):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates an `<img>` element with the class as a single string `"cat
    image"`, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also perform dynamic class names by binding the `class` attribute to
    an object whose properties’ values are according to the Boolean `isVisible` data
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define the `img` element to have `cat` class when `isVisible` is `true`,
    and `image` otherwise. The generated DOM element for when `isVisible` is `true`
    now becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Output is similar when `isVisible` is `false`, with `image` instead of `cat`
    for the class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the same approach with the `style` attribute or pass an object
    containing CSS rules in CamelCase format. For example, let’s add some margins
    to our image in [Example 2-5](#v_bind_02):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates inline stylings for the `img` element with `margin-block:
    10px` and `margin-inline: 15px` applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also combine several style objects into a single `style` array. Vue
    knows how to unite them into a single style rule string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output DOM element will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using v-bind for Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, inline style is not a good practice. Hence I don’t recommend using
    `v-bind` for organizing component stylings. We will discuss the proper way of
    working with styling in Vue in [Chapter 3](ch03.html#unique_chapter_id_03).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s iterate over a data collection in a Vue component.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over Data Collection Using v-for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic list rendering is essential to reduce repetitive code, increase code
    reusability, and maintain the format consistency between a group of similar element
    types. Some examples are a list of articles, active users, and TikTok accounts
    you follow. The data is dynamic in these examples, while the type of content and
    the UI layout remain similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue provides a `v-for` directive to accomplish the goal of iterating through
    an iterative data collection, such as an array or object. We use this directive
    directly on an element, following this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`elem` is just an alias for each element in the data source `list`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to iterate through an array of numbers `[1, 2, 3, 4,
    5]` and print out the element value, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code equals writing the following native HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: One significant advantage of using `v-for` is to keep the template consistent
    and map the data content dynamically to the relevant element, regardless of how
    the data source may change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Each block generated by the `v-for` iteration has access to other components’
    data and the specific list item. Take [Example 2-6](#tasks), for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Writing a task list component using `v-for`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-13](#figure_11) displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output is a list with each row display description of a task](assets/lvue_0213.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-13\. Output of tasks list with the default title for each row
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keeping the Uniqueness with the Key Attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we *must* define a unique `key` attribute for each iterated element. Vue
    uses this attribute to keep track of each element rendered for a later update.
    See [“Make the Element Binding Unique with Key Attribute”](#key_attribute) for
    discussion on its importance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, `v-for` supports an optional second argument, `index`, the current element’s
    appearance index in the iterating collection. We can rewrite [Example 2-6](#tasks)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block generates the following output ([Figure 2-14](#figure_12)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output is the list of 3 rows, with a prefix of the index for each row, from
    0 to 2](assets/lvue_0214.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-14\. Output of the task list with each task’s index
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So far, we have covered iteration with array collection. Let’s look at how we
    iterate through the properties of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Through Object Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, an `Object` is a type of *key-value map table*, with each object’s
    property being the *unique key* of the table. To iterate through the properties
    of an object, we use similar syntax with array iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here `value` stands for the value of a property and `name` for that property’s
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows how we iterate through properties of an object collection
    and print out each property’s `name` and `value` according to the format `<name>:
    <value>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_how_vue_works__the_basics_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `collection` object with three properties: `title`, `description`,
    and `priority`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_how_vue_works__the_basics_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the properties of `collection`
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-15](#figure_13) shows the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output is a list with each row display the title, description, and priority
    of a collection object](assets/lvue_0215.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-15\. Output of collection object with default title
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We still have access to the index appearance of the present pair as the third
    argument, as in the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As noted earlier, we always have to define a `key` attribute value for each
    iterating element. This attribute is significant in making the element update
    binding unique. We will explore the `key` attribute next.
  prefs: []
  type: TYPE_NORMAL
- en: Make the Element Binding Unique with Key Attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Vue engine tracks and updates the elements rendered with `v-for` by a simple
    in-place patch strategy. However, in various scenarios, we need to take complete
    control over list reordering or prevent unwanted behavior when the list element
    relies on its child component’s state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue provides an additional attribute: a `key`, as a *unique identity for each
    node element*, binds to a specific iterated list item. The Vue engine uses it
    as a hint to track, reuse, and reorder the rendered nodes and their nested elements
    instead of in-place patching.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax usage of a `key` attribute is straightforward. We use `v-bind:key`
    (`:key` for short) and bind a *unique* value to that list element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the Key’s Uniqueness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `key` should be the item’s *distinct identifier* (id) or its *appearance
    index* in the list.
  prefs: []
  type: TYPE_NORMAL
- en: As a good practice, you must always provide the `key` attribute when using `v-for`.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, Vue will throw a warning on the browser console if no `key` is
    presented. Also, if you enable ESLint in your application, it throws an error
    and instantly warns you about the missing `key` attribute, as shown in [Figure 2-16](#figure_14).
  prefs: []
  type: TYPE_NORMAL
- en: '![ESLint tool highlights and displays warning when we try to iterate a list
    with item key presented](assets/lvue_0216.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-16\. ESLint warning when no key is presented
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Valid Values for the Key Attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key should be a string or numeric value. An object or array is *not* a valid
    key to use.
  prefs: []
  type: TYPE_NORMAL
- en: The `key` attribute is helpful, even beyond the scope of `v-for`. Without a
    `key` attribute, applying the built-in list transition and animation effect is
    impossible. We’ll discuss more about the benefits of `key` in [Chapter 8](ch08.html#unique_chapter_id_07).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Event Listener to Elements with v-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To bind a DOM event to a listener, Vue exposes the built-in directive `v-on`
    (for short `@`) for element tags. The `v-on` directive accepts the following value
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: Some inline JavaScript statements in the form of a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name of the component method declared in the component options under `methods`
    property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use `v-on` with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with the shorter version using `@`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From this point on, we will use `@` to denote `v-on`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then add this directive directly on any element as an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For code readability, especially in a complex codebase, I recommend keeping
    the JavaScript expression inside a component’s method and exposing the use through
    its name on the directive, as in [Example 2-7](#click_print).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Change `printMsg`’s value on button click using `v-on` directive
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the user hasn’t clicked the button, the display message below the button
    will be “Nothing to print yet” ([Figure 2-17](#figure_22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows a message ''Nothing to print yet!''](assets/lvue_0217.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-17\. “Nothing to print yet” message appears as default
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Otherwise, the message will change to “Button is clicked!” ([Figure 2-18](#figure_23)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A text showing ''Button is clicked!'' appears after the Click me button ](assets/lvue_0218.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-18\. “Button is clicked!” message appears after user clicks the button
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Handling Events with v-on Event Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before the browser dispatches an event on a target element, it constructs that
    event’s propagation path list using the current DOM tree structure. The last node
    in this path is the target itself, and the other preceding nodes are its ancestors,
    respectively, in order. Once dispatched, the event travels through one or all
    three main event phases ([Figure 2-19](#figure_24)):'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing (or capture phase)
  prefs: []
  type: TYPE_NORMAL
- en: The event travels (or propagates) from the top ancestor down to the target element.
  prefs: []
  type: TYPE_NORMAL
- en: Target
  prefs: []
  type: TYPE_NORMAL
- en: The event is at the target element.
  prefs: []
  type: TYPE_NORMAL
- en: Bubbling
  prefs: []
  type: TYPE_NORMAL
- en: The event travels (or bubbles) from the target element up to its ancestor.
  prefs: []
  type: TYPE_NORMAL
- en: We usually interfere with this event propagation flow programmatically within
    the listener logic. With `v-on`’s modifiers, we can interfere directly on the
    directive level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `v-on` modifiers following this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![A diagram shows the levels of propagation phases, from bottom up and top
    down.](assets/lvue_0219.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-19\. Flow of propagation for a click event
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One advantage of modifiers is that they keep the listener as generic and reusable
    as possible. We do not need to worry internally about event-specific details,
    such as `preventDefault` or `stopPropagation`.
  prefs: []
  type: TYPE_NORMAL
- en: Take [Example 2-8](#event_propagation), for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Manually stop the propagation using `stopPropagation()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here we have to stop the propagation ourselves with `e.stopPropagation`, adding
    another validation layer to make sure `e` exists. [Example 2-9](#v_on_stop) shows
    how we can rewrite [Example 2-8](#event_propagation) using the `@click.stop` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. Stop propagation using `@click.stop` modifier
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 2-1](#on_modifiers_table) shows the complete list of event modifiers
    available, briefly explaining the equivalent event functionalities or behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Event modifiers for `v-on` directive
  prefs: []
  type: TYPE_NORMAL
- en: '| Modifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.stop` | Instead of calling `event.stopPropagation()` |'
  prefs: []
  type: TYPE_TB
- en: '| `.prevent` | Instead of calling `event.preventDefault()` |'
  prefs: []
  type: TYPE_TB
- en: '| `.self` | Trigger the event listener *only if* the event’s target is the
    element where we attach the listener. |'
  prefs: []
  type: TYPE_TB
- en: '| `.once` | Trigger the event listener *at most once* |'
  prefs: []
  type: TYPE_TB
- en: '| `.capture` | Instead of passing `{ capture: true }` as the third parameter
    for `addEventListener()`, or `capture="true"` in the element. This modifier triggers
    the listener in the *capturing phase* order, instead of regular bubbling phase
    order. |'
  prefs: []
  type: TYPE_TB
- en: '| `.passive` | Mainly to opt-in for *better scroll performance* and prevent
    triggering `event.preventDefault()`. We use it instead of passing `{ passive:
    true }` as the third parameter for `addEventListener()` or adding `passive="true"`
    to the element. |'
  prefs: []
  type: TYPE_TB
- en: Chaining Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event modifiers support chaining. This means you can write expressions such
    as `@click.stop.prevent=" printMessage">` on the element tag. This expression
    equals calling both `event.stop` `Propagation()` and `event.preventDefault()`
    inside the event handler, in the order in which they appear.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Keyboard Events with Key Code Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While event modifiers are for interfering with the event propagation flow, *key
    modifiers* help detect special keys of keyboard events such as `keyup`, `keydown`,
    and `keypress`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, to detect a specific key, we need to perform two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the key code, `key`, or the `code` represented by that key. For instance,
    the `keyCode` for `Enter` is 13, its `key` is “Enter”, and its `code` is “Enter.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When firing the event handler, within the handler, we need to check manually
    that `event.keyCode` (or `event.code` or `event.key`) matches the target key code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach is not efficient for maintaining reusable and clean code in a
    large codebase. `v-on` comes with built-in key modifiers as a better alternative.
    If we want to detect if the user types the *Enter* key, we add the modifier `.enter`
    to the related `keydown` event, following the same syntax when using event modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we have an input element, and we log a message to the console whenever
    a user presses *Enter*, as seen in [Example 2-10](#enter_key_check).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Manual check if `keyCode` is 13 stands for Enter key
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We now can rewrite it using `@keydown.enter`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. Checking for Enter key pressed by `@keydown.enter` modifier
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The app behaves the same in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: A few other commonly used key modifiers are `.tab`, `.delete`, `.esc`, and `.space`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another popular use case is to capture a special keys combination, such as
    *Ctrl & Enter* (*CMD & Enter* for MacOS) or *Shift + S*. In these scenarios, we
    chain the *system* key modifiers (`.shift`, `.ctrl`, `.alt` and `.meta` for *CMD*
    key in MacOS) with *key code* modifiers, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or chaining the shift modifier and key code modifier for `S` key (`keyCode`
    is `83`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Chaining System Modifiers and Key Code Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You *must* use key code modifiers instead of standard key modifiers, meaning
    `.13` in place of `.enter` for this type of chaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, to capture the exact key combinations for triggering an event, we use
    the `.exact` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Combining `.shift` and `.exact` makes sure the click event fires when the user
    presses *only* the Shift key while clicking the button.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Rendering Elements with v-if, v-else, and v-else-if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also can generate or remove an element from the DOM, a scenario called *conditional
    rendering*.
  prefs: []
  type: TYPE_NORMAL
- en: Assume we have a Boolean data property `isVisible`, which decides if Vue should
    render a text element into the DOM and make it visible to the user. Binding directive
    `v-if` to `isVisible` by placing `v-if="isVisible"` on the text element enables
    reactively rendering the element only when `isVisible` is `true` ([Example 2-12](#example_v_if)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. Example usage for `v-if`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When setting `isVisible` to `false`, the generated DOM elements will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, the text element will be visible in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If we want to render a different component for the opposite condition (`isVisible`
    is `false`), `v-else` is the right choice. Unlike `v-if`, you use `v-else` without
    binding to any data property. It takes the correct condition value based on the
    immediate preceding `v-if` usage in the same context level.
  prefs: []
  type: TYPE_NORMAL
- en: Using v-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`v-else` works only when `v-if` exists, and it must always present last in
    a chaining conditional rendering.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, as [Example 2-13](#v_if_simple) shows, we can create a component
    with the following code block with both `v-if` and `v-else`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13\. Conditional display of different texts using `v-if` and `v-else`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, you can translate the previous conditions into similar logical expressions
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As in any `if…else` logic expression, we can always extend the condition check
    with an `else if` condition block. This condition block equals a `v-else-if` directive
    and also requires a JavaScript condition statement. [Example 2-14](#v_else_if)
    shows how to display a text, `I’m the subtitle text`, when `isVisible` is `false`
    and `showSubtitle` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. Condition chaining with `v-if`, `v-else-if`, and `v-else`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Order of v-else-if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use `v-else-if`, we *must* present it on elements appearing after the
    element with assigned `v-if` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: While using `v-if` means to render an element conditionally, there are situations
    where it won’t be efficient to mount/unmount an element from the DOM so frequently.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, it’s better to use `v-show`.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Displaying Elements with v-show
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike `v-if`, `v-show` only toggles the visibility of the target element. Vue
    still renders the target element regardless of the status of the condition check.
    Once rendered, Vue controls the visibility using the CSS `display` rule to hide/show
    the element conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take [Example 2-12](#example_v_if) and change the directive from `v-if`
    to `v-show`, as in [Example 2-15](#event_propagation_2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. Hide/show the element using `v-show`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI output is the same as when we use `v-if`. However, in the browser DOM
    (*you can debug in the Elements tab of the Developer Tools*), the text element
    exists in the DOM but is not visible to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The target element has an inline `style` with `display:none` applied. When toggling
    `isVisible` to `true`, Vue will remove this inline style.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`v-show` is more efficient if the toggling frequency is high at runtime, while
    `v-if` is an ultimate choice if the condition is not likely to change.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically Displaying HTML Code with v-html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use `v-html` to inject plain HTML code into the DOM dynamically, in the form
    of a string, as in [Example 2-16](#v_html_code).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-16\. Using v-html to render inner HTML content
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vue engine will parse the directive value as *static HTML code* and place
    it into the `innerHTML` property of the `div` element. The result should look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Security Concern with v-html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should use `v-html` to render only trusted content or perform server-side
    rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a valid HTML string can contain a `script` tag and the browser will trigger
    the code within this `script` tag, leading to a potential security threat. Thus,
    using this directive on client-side rendering is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying Text Content with v-text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`v-text` is an alternative way of injecting data as the element’s content besides
    the double curly braces `{{}}`. However, unlike `{{}}`, Vue won’t update the text
    rendered if there are any changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This directive is beneficial when you need to predefine a placeholder text,
    then override the text only once after a component finishes loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here Vue will render the application displaying *placeholder text* and will
    eventually replace it with “Hello World” received from `text`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Renders with v-once and v-memo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`v-once` helps render static content and preserves performance from the re-rendering
    static element. Vue renders elements with this directive presented *only once*
    and will not update it regardless of any re-rendering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `v-once`, place the directive as is on the element tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, Vue renders `name` once for the `div` tag, and regardless
    of what value `name` receives from the user through `input` field and by `v-model`,
    the content of this `div` won’t be updated ([Figure 2-20](#figure_25)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Input field display new value as Maya Shavin, while the below text is still
    Maya.](assets/lvue_0220.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-20\. Text remains the same though the input value has changed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While `v-once` is excellent for defining a block of elements as static content,
    we use `v-memo` to memorize a block of parts (or components) within a template
    conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: '`v-memo` accepts an array of JavaScript expressions as its value. We place
    it on the top element where we want to control its and its children’s re-rendering.
    Vue then validates these JavaScript conditional expressions and only triggers
    the re-rendering on the target block of elements when fulfilling those condition(s).'
  prefs: []
  type: TYPE_NORMAL
- en: Take rendering a gallery of image cards, for instance. Assume we have an array
    of images. Each image is an object with a `title`, `url`, and `id`. Users can
    select an image card by clicking on the card, and the selected card will have
    a blue border.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define the `images` data array and `selected` image card id in
    the component data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the layout for the list rendering to the `template`, adding
    a conditional memorization `v-memo` for the list item to re-render only if the
    image item is no longer selected, or vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_how_vue_works__the_basics_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We set the re-rendering to only if the condition check `selected === image.id`
    results differently from the previous check.
  prefs: []
  type: TYPE_NORMAL
- en: The output will look like [Figure 2-21](#figure_26).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displays a gallery of cat images, each image with a title text
    at the bottom.](assets/lvue_0221.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-21\. Images gallery output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Every time you select an image by clicking on the image card, Vue will only
    re-render two items: the previously selected item and the currently selected one.
    For optimizing large list rendering, this directive can be very powerful.'
  prefs: []
  type: TYPE_NORMAL
- en: '`v-memo` Availability'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`v-memo` is available only in Vue 3.2 and above.'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to write a component using the `template` syntax and some
    common Vue directives, except `v-slot`. We will resume discussing the power of
    `v-slot` in [Chapter 3](ch03.html#unique_chapter_id_03).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to register a component globally, making it available
    for use in other components of the same application without explicitly importing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a Component Globally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `components` property of Options API to register a component only
    enables its availability explicitly within the current component. Any of the present
    component’s nested elements won’t have access to use the registered one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue exposes the instance method `Vue.component()`, which receives two input
    parameters as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A string stands for the component’s registered name (alias).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A component instance, either an SFC imported as a module or an object containing
    the component’s configurations, following Options API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To register a component globally, we trigger `component()` on the created `app`
    instance, as seen in [Example 2-17](#global_component).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17\. Register `MyComponent` as global component and use it in the
    `App` template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a `MyComponent` as an SFC file (see [Chapter 3](ch03.html#unique_chapter_id_03)),
    you can rewrite [Example 2-17](#global_component) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: And `MyComponent` will always be available for reuse in any component nested
    within the `app` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the same component again in every component file can be repetitive
    and inconvenient. In reality, sometimes you need to reuse a component multiple
    times across an application. In this scenario, registering components as global
    components is an excellent practice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored Virtual DOM and how Vue uses it to achieve its performance
    goal. We learned how to control the component rendering with JSX and functional
    components, handle built-in Vue directives, and use them to process the component’s
    local data for displaying on the UI template reactively. We also learned about
    the reactivity fundamentals and how to create and register the Vue component using
    Options API with the template syntax. These are the basics for going further into
    the Vue component mechanism in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#id564-marker)) Visit the [JavaScript Proxy documentation](https://oreil.ly/SRqbn).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#id574-marker)) 1 second = 1000 milliseconds
  prefs: []
  type: TYPE_NORMAL
