<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Network Policy"><div class="chapter" id="network_policy">
    <h1><span class="label">Chapter 7. </span>Network Policy</h1>
    <p>In this chapter, we will describe network policy and discuss its importance in securing a Kubernetes cluster. We
        will review various network policy implementations and tooling to support network policy implementations. We
        will also cover network policy best practices with examples.</p>
    <section data-type="sect1" data-pdf-bookmark="What Is Network Policy?"><div class="sect1" id="what_is_network_policyquestion_mark">
        <h1>What Is Network Policy?</h1>
        <p>Network policy is the primary tool for securing a Kubernetes network.<a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="about" id="idm45326826295616"/><a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="network policies" id="idm45326826294160"/> It allows you to easily restrict the network traffic in
            your cluster so only the traffic that you want to flow is allowed.</p>
        <p>To understand the significance of network policy, let’s briefly explore how network security was typically
            achieved prior to network policy. Historically in enterprise networks, network security was provided by
            designing a physical topology of network devices (switches, routers, firewalls) and their associated
            configuration. The physical topology defined the security boundaries of the network. In the first phase of
            virtualization, the same network and network device constructs were virtualized in the cloud, and the same
            techniques for creating specific network topologies of (virtual) network devices were used to provide
            network security. Adding new applications or services often required additional network design to update the
            network topology and network device configuration to provide the desired security.</p>
        <p>In contrast, the Kubernetes network model defines a “flat” network<a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="flat network of Kubernetes" id="idm45326826290752"/><a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="about networking" data-tertiary="flat network" id="idm45326826289280"/> in which, by default, every
            pod can communicate directly with all other pods in the cluster. This approach massively simplifies network
            design and allows new workloads to be scheduled dynamically anywhere in the cluster with no dependencies on
            the network design.</p>
        <p>In this model, rather than network security being defined by network topology boundaries, it is defined using
            network policies that are independent of the network topology. Network policies are further abstracted from
            the network by using label selectors as their primary mechanism for defining which workloads can talk to
            which workloads, rather than IP addresses or IP address ranges.</p>
        <p>Network policy enforcement can be thought of as each pod being protected by its own dedicated virtual
            firewall that is automatically programmed and updated in real time based on the network policy that has been
            defined. <a data-type="xref" href="#pod_secured_by_a_virtual_firewall">Figure 7-1</a> shows network policy
            enforcement at a pod using its dedicated virtual firewall.</p>
        <figure><div id="pod_secured_by_a_virtual_firewall" class="figure">
            <img src="Images/ksao_0701.png" alt="" width="1095" height="175"/>
            <h6><span class="label">Figure 7-1. </span>Pod secured by a virtual firewall</h6>
        </div></figure>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Why Is Network Policy Important?"><div class="sect1" id="why_is_network_policy_importantquestion">
        <h1>Why Is Network Policy Important?</h1>
        <p>In an age where attackers are becoming more and more sophisticated, <a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="about" data-tertiary="importance of" id="idm45326826280688"/>network security as a line of defense is more important than
            ever.</p>
        <p>While you can (and should) use firewalls to restrict traffic at the <a contenteditable="false" data-type="indexterm" data-primary="firewalls" data-secondary="network policy in addition" id="idm45326826278416"/>perimeters of your network (commonly referred to
            as north-south traffic), their ability to police Kubernetes traffic is often limited to a granularity of the
            cluster as a whole, rather than to specific groups of pods, due to the dynamic nature of pod scheduling and
            pod IP addresses. In addition, the goal of most attackers once they gain a small foothold inside the
            perimeter is to move laterally (east-west) to gain access to higher-value targets,
            which perimeter-based firewalls can’t police against. With application architectures evolving from monoliths
            to microservices, the amount of east-west traffic, and therefore attack surface for lateral movement, is
            continuing to grow.</p>
        <p>Network policy, on the other hand, is designed for the dynamic nature of Kubernetes by following the standard
            Kubernetes paradigm of using label selectors to define groups of pods, rather than IP addresses. And because
            network policy is enforced within the cluster itself, it can secure both north-south and east-west traffic.
        </p>
        <p>Network policy represents an important evolution of network security, not just because it handles the dynamic
            nature of modern microservices, but because it empowers dev and DevOps engineers to easily define network
            security themselves, rather than needing to learn low-level networking details. Network policy makes it easy
            to define intent, such as <em>only this microservice gets to connect to the database</em>, write that intent
            as code (typically in <em>.yaml</em> files), and integrate authoring of network policies into Git workflows
            and CI/CD processes.</p>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Network Policy Implementations"><div class="sect1" id="network_policy_implementations">
        <h1>Network Policy Implementations</h1>
        <p>Kubernetes defines a standard network policy API, so there’s a base <a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="implementations" id="ch07-imp"/>set of features you can expect on any cluster. But Kubernetes itself doesn’t do
            anything with the network policy other than store it. <a contenteditable="false" data-type="indexterm" data-primary="plug-ins" data-secondary="network policy enforcement" id="idm45326826269472"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="implementations" data-tertiary="enforcement by plug-ins" id="idm45326826268032"/>Enforcement of network policies is delegated to
            network plug-ins, allowing for a range of implementations. Most network plug-ins support the mainline
            elements of Kubernetes network policies, though many do not implement every feature of the specification. It’s worth noting that most implementations are coupled with the network plug-in’s specific pod
            networking implementation. However, some network policy implementations can enforce network policy on top of
            a variety of different pod networking plug-ins. <a data-type="xref" href="#network_policy_that_is_stored_in_kubern">Figure 7-2</a> shows
            network policies stored in the Kubernetes datastore being used by network plug-ins for enforcement.</p>
        <figure><div id="network_policy_that_is_stored_in_kubern" class="figure">
            <img src="Images/ksao_0702.png" alt="" width="1095" height="442"/>
            <h6><span class="label">Figure 7-2. </span>Network policy that is stored in Kubernetes enforced by network plug-ins</h6>
        </div></figure>
        <p>There are a number of networking and network policy implementations to choose from, as shown in <a data-type="xref" href="#adoption_of_top_networking_technology_i">Figure 7-3</a>.</p>
        <figure><div id="adoption_of_top_networking_technology_i" class="figure">
            <img src="Images/ksao_0703.png" alt="" width="1208" height="660"/>
            <h6><span class="label">Figure 7-3. </span>Adoption of top networking technology implementations</h6>
        </div></figure>
        <p>No matter what network policy implementation you choose, we recommend using one for the following reasons:</p>
        <ul>
        <li>It implements the complete Kubernetes network policy specification.</li>
        <li>In addition to supporting the Kubernetes network policy specification, its own policy model provides
            additional capabilities, which can be used alongside Kubernetes network policies to support additional
            enterprise security use cases.</li>
        <li>A few network plug-ins, like Weave Net, Kube-router, and Calico, <a contenteditable="false" data-type="indexterm" data-primary="Calico Enterprise" data-secondary="network policies" id="idm45326826256224"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="implementations" data-tertiary="plug-ins that enforce" id="idm45326826254768"/><a contenteditable="false" data-type="indexterm" data-primary="plug-ins" data-secondary="network policy enforcement" data-tertiary="plug-ins that enforce" id="idm45326826253120"/><a contenteditable="false" data-type="indexterm" data-primary="Elastic Kubernetes Service plug-ins enforcing network policy" id="idm45326826251504"/><a contenteditable="false" data-type="indexterm" data-primary="Azure Kubernetes Service plug-ins enforcing network policy" id="idm45326826250352"/><a contenteditable="false" data-type="indexterm" data-primary="Google Kubernetes Engine (GKE)" data-secondary="plug-ins that enforce network policy" id="idm45326826249200"/>can enforce network policy on top of
            their own rich set of networking capabilities, or on top of several other networking options, including the
            network plug-ins used by Amazon’s Elastic Kubernetes Service (EKS), Azure Kubernetes Service (AKS), and
            Google Kubernetes Engine (GKE). This makes them a particularly strong choice as part of a multicloud
            strategy, because it gives you the flexibility to select the best networking for your environment from a
            broad range of options with the same rich set of network policy features available across all environments.
        </li>
        <li>The network policy can be applied to host endpoints/interfaces, allowing the same flexible policy model to be
            used to secure Kubernetes nodes or noncluster hosts/VMs.</li>
        <li>It supports network policy that is enforced both at the network/infrastructure layer and at the layers above,
            including supporting L5–L7 match criteria with its policy rules such as HTTP methods and paths. The multiple
            enforcement points help protect your infrastructure from compromised workloads and protect your workloads
            from compromised infrastructure. It also avoids the need for dual provisioning of security at the
            application and infrastructure layers, or having to learn different policy models for each layer.</li>
        <li>It needs to be production-grade, which means it must perform very well in clusters of any size, from
            single-node clusters to several-thousand-node clusters.</li>
        <li>It provides the ability for enterprises to add new capabilities and serves as a building block for an
            enterprise-grade Kubernetes network security solution.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch07-imp" id="idm45326826244176"/></li>
                </ul>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Network Policy Best Practices"><div class="sect1" id="network_policy_best_practices">
        <h1>Network Policy Best Practices</h1>
        <p>In this section we’ll explore how to implement network policy with examples and cover best practices for implementation. <a contenteditable="false" data-type="indexterm" data-primary="Calico Enterprise" data-secondary="network policies" data-tertiary="best practices" id="ch07-bp"/>The following examples use the Calico network policy schema, which extends the Kubernetes network policy schema. We’re using these examples due to our familiarity with Calico network policy, but these best practices can be implemented with other available network policy models as well.</p>
        <section data-type="sect2" data-pdf-bookmark="Ingress and Egress"><div class="sect2" id="ingress_and_egress">
            <h2>Ingress and Egress</h2>
            <p>When people think about network security, the first thought is often<a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="best practices" data-tertiary="ingress and egress" id="idm45326826236560"/><a contenteditable="false" data-type="indexterm" data-primary="best practices" data-secondary="network policy" data-tertiary="ingress and egress" id="idm45326826234832"/> of how to protect your workloads from north-south
                external attackers. To help defend against this, you can use network policy to restrict ingress traffic
                to any pods that are reachable from outside the cluster.</p>
            <p>However, when an attacker does manage to find a vulnerability, they often use the compromised workload as
                the place from which to move laterally, probing the rest of your network to exploit additional
                vulnerabilities that give them access to more valuable resources or allow them to elevate privileges to
                mount more powerful attacks or exfiltrate sensitive data.</p>
            <p>Even if you have network policies to restrict ingress traffic on all pods in the cluster, the lateral
                movement may target assets outside of the cluster, which are less well protected. Consequently, the best
                practice is to always define both ingress and egress network policy rules for every pod in the cluster.
            </p>
            <p>While this doesn’t guarantee an attacker cannot find additional vulnerabilities, it does significantly
                reduce the available attack surface, making the attacker’s job much harder. In addition, if combined
                with suitable alerting of policy violations, the time to identify that a workload has been compromised
                can be massively reduced. <a contenteditable="false" data-type="indexterm" data-primary="data breach cost report (IBM; 2020)" id="idm45326826230352"/><a contenteditable="false" data-type="indexterm" data-primary="IBM Cost of a Data Breach Report (2020)" id="idm45326826229232"/><a contenteditable="false" data-type="indexterm" data-primary="Cost of a Data Breach Report (IBM; 2020)" id="idm45326826228112"/>To put this into perspective, in
                the 2020 IBM Cost of a Data Breach Report, IBM reported that on average it took enterprises 207 days to
                identify a breach, and a further 73 days to contain it! With correctly authored network policies and
                alerting of violations, the breach can be prevented or reduced potentially to minutes or seconds and
                even opens the possibility of automated responses to quarantine the suspect workload if desired.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Not Just Mission-Critical Workloads"><div class="sect2" id="not_just_mission_critical_workloads">
            <h2>Not Just Mission-Critical Workloads</h2>
            <p>Best practice already recommends ensuring every pod has a network policy<a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="best practices" data-tertiary="not just mission-critical workloads" id="idm45326826224608"/><a contenteditable="false" data-type="indexterm" data-primary="best practices" data-secondary="network policy" data-tertiary="not just mission-critical workloads" id="idm45326826222704"/> that restricts its ingress and egress
                traffic. What this means is that when you are thinking about how to protect your mission-critical
                workloads, you really need to be protecting all workloads. If you don’t, then some seemingly
                unimportant, innocuous workload could end up being used as the base for attacks across the rest of your
                network, ultimately leading to the downfall of your most critical workloads.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Policy and Label Schemas"><div class="sect2" id="policy_and_label_schemas">
            <h2>Policy and Label Schemas</h2>
            <p>One of the strengths of Kubernetes labels and network policies<a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="labels" data-tertiary="best practice schemas" id="idm45326826218240"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="best practices" data-tertiary="policy and label schemas" id="idm45326826216512"/><a contenteditable="false" data-type="indexterm" data-primary="best practices" data-secondary="network policy" data-tertiary="policy and label schemas" id="idm45326826214800"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="pod labels for identification" data-tertiary="best practice schemas" id="idm45326826213136"/> is the flexibility in how you can use them. However, as a result there are often multiple different ways of labeling and writing policies that can achieve the same particular goal. So another best practice is to consider standardizing the way you label your pods and write your network policies using a consistent schema or design pattern. This can
                make <span class="keep-together">authoring</span> and understanding the intent of each network policy much more straightforward, especially
                if your clusters are hosting a large number of microservices.</p>
            <p>For example, you might say every pod will have an “app” label that identifies which microservice it is,
                and every pod will have a single network policy applied to it using that app label, with the policy
                defining ingress and egress rules for the microservices it is expected to interact with, again using the
                app label:</p>
            <pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">NetworkPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">back-end-policy</code>
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">production</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">app == 'back-end'</code>
  <code class="nt">ingress</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code>
    <code class="nt">protocol</code><code class="p">:</code> <code class="l-Scalar-Plain">TCP</code>
    <code class="nt">source</code><code class="p">:</code>
      <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">app == 'front-end'</code>
    <code class="nt">destination</code><code class="p">:</code>
      <code class="nt">ports</code><code class="p">:</code>
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">80</code>
  <code class="nt">egress</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code>
    <code class="nt">protocol</code><code class="p">:</code> <code class="l-Scalar-Plain">TCP</code>
    <code class="nt">destination</code><code class="p">:</code>
      <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">app == 'database'</code>
      <code class="nt">ports</code><code class="p">:</code>
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">80</code></pre>
            <p>Or you might decide to use permission-style labels in the policy rules so that rather than listing the
                microservices that are allowed to access each service in its ingress rules, any microservice that has
                the permission label is allowed:</p>
            <pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">NetworkPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">database-policy</code>
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">production</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">app == 'database'</code>
  <code class="nt">ingress</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code>
    <code class="nt">protocol</code><code class="p">:</code> <code class="l-Scalar-Plain">TCP</code>
    <code class="nt">source</code><code class="p">:</code>
      <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">database-client == 'true'</code>
    <code class="nt">destination</code><code class="p">:</code>
      <code class="nt">ports</code><code class="p">:</code>
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">80</code>
  <code class="nt">egress</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Deny</code></pre>
            <p>This could make it easier for individual microservice teams to author their own network policies without
                needing to know the full list of other microservices that must consume the service.</p>
            <p>There are plenty of other ways you could go about it, and there is no right or wrong here. But taking the
                time to define how to approach labeling and defining network policies up front can make life
                significantly easier in the long run.</p>
            <p>If you are not sure which approach will work best for you, then a simple “app” approach is a good place
                to start. This can always be expanded later to include the ideas of permission-style labels for
                microservices that have a lot of clients if maintaining the policy rules becomes time-consuming.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Default Deny and Default App Policy"><div class="sect2" id="default_deny_and_default_app_policy">
            <h2>Default Deny and Default App Policy</h2>
            <p>The Kubernetes network policy specification allows all ingress pod traffic, <a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="best practices" data-tertiary="default deny policy" id="ch07-deny"/><a contenteditable="false" data-type="indexterm" data-primary="best practices" data-secondary="network policy" data-tertiary="default deny policy" id="ch07-deny2"/><a contenteditable="false" data-type="indexterm" data-primary="default deny network policies" id="ch07-deny3"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="default deny–style best practices" id="ch07-deny4"/>unless there is one or
                more network policy with an ingress rule that applies to the pod, and then only the ingress traffic that
                is explicitly allowed by the policies is allowed. And likewise for egress pod traffic. As a result, if
                you forget to write a network policy for a new microservice, it will be left unsecured. And if you
                forget to write both ingress and egress rules for the microservice, then it will be left partially
                unsecured.</p>
            <p>Given this, a good practice is to put in place a “default deny policy” that prevents any traffic that is
                not explicitly allowed by another network policy. The way this is normally done is to have a policy that
                specifies it applies to all pods, with both ingress and egress rules, but does not explicitly allow any
                traffic itself. As a result, if no other network policy applies that explicitly allows the traffic, then
                the traffic will be denied:</p>
            <pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">networking.k8s.io/v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">NetworkPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default-deny</code>
  <code class="nt">Namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">my-namespace</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">podSelector</code><code class="p">:</code> <code class="p-Indicator">{}</code>
  <code class="nt">policyTypes</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Ingress</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Egress</code></pre>
            <p>Since Kubernetes network policy is namespaced, the network policy mentioned previously needs repeating
                for each namespace and ideally needs to be built into the standard operating procedure for provisioning
                new namespaces in the cluster. Alternatively, some network policy implementations go beyond Kubernetes
                network policy and provide the ability to specify cluster-wide network policies (that are not limited to
                a single namespace). The following example shows how to create a policy that switches the whole cluster
                to default deny behavior, including any namespaces that are created in the future:</p>
            <pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">GlobalNetworkPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default-deny</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">all()</code>
  <code class="nt">types</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Ingress</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Egress</code></pre>
            <p>However, it’s worth noting that this policy applies to all pods, not just application pods, including
                control plane pods for Kubernetes. If you do not have the right network policies in place or failsafe
                ports configured before you create such a policy, you can break your cluster in pretty bad ways.</p>
            <p>A much less high-stakes best practice is to define a network policy that applies only to pods, excluding
                control plane pods. As well as triggering default deny behavior, this policy can include any rules
                that you want to apply to all application pods. For example, you could include a rule that allows all
                application pods to access kube-DNS. This helps simplify any per-microservice policies that need writing
                so they can focus solely on the desired per-microservice specific behaviors:</p>
            <pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">GlobalNetworkPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default-app-policy</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">namespaceSelector</code><code class="p">:</code> <code class="l-Scalar-Plain">has(projectcalico.org/name) &amp;&amp;</code>
<code class="l-Scalar-Plain">projectcalico.org/name not in {"kube-system", "calico-system"}</code>
  <code class="l-Scalar-Plain">types</code><code class="p-Indicator">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Ingress</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Egress</code>
  <code class="nt">egress</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code>
      <code class="nt">protocol</code><code class="p">:</code> <code class="l-Scalar-Plain">UDP</code>
      <code class="nt">destination</code><code class="p">:</code>
        <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">k8s-app == "kube-dns"</code>
        <code class="nt">ports</code><code class="p">:</code>
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">53</code></pre>
            <p>As this policy deliberately excludes control plane components, to secure the control plane you can write
                specific policies for each control plane component. It is best to do any such policy creation at cluster
                creation time before the cluster is hosting workloads, since getting these policies wrong can leave your
                cluster in a broken state that might result in a significant production outage. In addition, it is
                highly recommended you always make sure you have in place the correct failsafe ports for the network
                plug-in you are using before you start trying to create any policies for the control plane.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch07-deny" id="idm45326825944512"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch07-deny2" id="idm45326825841104"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch07-deny3" id="idm45326825839760"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch07-deny4" id="idm45326825838384"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch07-bp" id="idm45326825837008"/></p>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Policy Tooling"><div class="sect1" id="policy_tooling">
        <h1>Policy Tooling</h1>
        <p>In this section we explore tools at your disposal to effectively add network policies to your Kubernetes
            cluster.</p>
        <section data-type="sect2" data-pdf-bookmark="Development Processes and Microservices Benefits"><div class="sect2" id="development_processes_and_microservices">
            <h2>Development Processes and Microservices Benefits</h2>
            <p>One of the advantages of network policy compared with traditional <a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="development process benefits" id="idm45326825831808"/>network security controls is that defining
                network policy does not require networking or firewall expertise. Network policies use the same concepts
                and paradigms as other Kubernetes resources. In theory, any team that is familiar with deploying
                microservices in Kubernetes can easily master network policies. As a result, network policy represents
                an opportunity to adopt a shift-left philosophy for network security, where network security is defined
                earlier in the development cycle, rather than being defined late in the process. This is a great
                opportunity for the security and development teams to collaborate to secure your Kubernetes cluster.</p>
            <p>At the same time, many organizations are moving from monolith<a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="microservices benefits" id="idm45326825829104"/><a contenteditable="false" data-type="indexterm" data-primary="microservices" data-secondary="network policy and" id="idm45326825827728"/> application
                architectures to microservice architectures, often with one of the goals being to increase development
                and organizational agility. In such an approach, each microservice is typically maintained by a single
                development team, with that team having significant expertise on the microservice, but not necessarily
                the whole of the application that the microservice is a part of. The move to microservices complements
                the shift-left opportunity of network policy. The team responsible for the development of a microservice
                normally has a good understanding of which other microservices it consumes and depends on. They may also
                have a good understanding of which microservices consume their microservice.</p>
            <p>When coupled with a well-defined, standardized approach to policy and label schemas, this puts them in a
                strong position to implement network policies for their microservice as part of the development of the
                microservice. In this model, network policy is treated as code built into and tested during the
                development process, just like any other critical part of a microservice’s code.</p>
            <p>An equally valid approach is to have development teams focus purely on the internals of the microservices
                they are responsible for and leave responsibility for operating the microservices with DevOps teams.
                However, the same ideas still apply. Such a DevOps team typically needs a good understanding of the
                dependencies between the microservices they are responsible for operating in order to manage the
                operation of the application and life cycle of the microservices. Network security can be defined as
                code by the DevOps team and tested just like they would any other operational code or scripts they
                develop before using in production.</p>
            <p class="pagebreak-before">The reality today, of course, is that many organizations are some way off from achieving this nirvana of
                microservices, agility, and shift-left security. Network security may come much later in the
                organization’s processes, or even as an afterthought on a system already in production. In such
                scenarios, defining network policies may be significantly more challenging, and getting network policies
                wrong could have significant production impacts. The good news is that there are a range of tools to
                help with network policy life cycle management to make this easier, including policy recommendations,
                policy impact previews, and policy staging/audit modes.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Policy Recommendations"><div class="sect2" id="policy_recommendations">
            <h2>Policy Recommendations</h2>
            <p>Policy recommendation tools are a great help in scenarios where <a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="tools for" data-tertiary="policy recommendation tools" id="idm45326825820000"/>the team responsible for network security does
                not have a good, confident understanding of all the network dependencies between the applications or
                microservices they need to secure. These tools also help you get started with authoring network policies
                the right way, and make the creation of network policy significantly easier than writing it by hand.</p>
            <p>The way recommendation tools usually work is to analyze the network traffic to and from each
                microservices over a period of time. This means to get recommendations, the microservice needs to be
                running in production, or a staging or test environment that accurately reflects the production
                interactions between the microservice and the rest of the application.</p>
            <p>There are many policy recommendation tools available to choose from, often with varying levels of
                sophistication, degrees of Kubernetes awareness, and policy schema approaches. It is recommended that
                you use a Kubernetes-aware policy recommendation engine built into your network policy solution.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Policy Impact Previews"><div class="sect2" id="policy_impact_previews">
            <h2>Policy Impact Previews</h2>
            <p>Policy impact preview tools provide a way of sanity-checking a network <a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="tools for" data-tertiary="policy imact preview tools" id="idm45326825814320"/>policy before it is applied to the cluster.
                Like policy recommendations, this is usually done by analyzing the cluster’s historical network traffic
                over a period of time and calculating which network flows would have been impacted by the new policy.
                An example is to identify any flows that were previously allowed that would now be denied, and any flows
                that were previously denied that would now be allowed.</p>
            <p>Policy impact previews are a great help in any scenarios where you are not relying completely on policy
                recommendations. For example, this could be if you are defining network policies by hand or 
                modifying a policy recommendation to align with a particular standardized approach to policy and label
                schemas. Even if the team defining the network policy for a microservice has high confidence in their
                understanding of the microservice’s network dependencies, policy impact previews can be invaluable to
                help catch any accidental mistakes, such as hard-to-spot typos, that might significantly impact
                legitimate network traffic.</p>
            <p>Policy impact preview tools are less common than policy recommendations. <a contenteditable="false" data-type="indexterm" data-primary="visualizations" data-secondary="network policy impact preview tools" id="idm45326825810512"/>It is very useful to use a tool that
                provides a visual representation of the impact based on analysis of the flow log data it collects over
                any desired time period. This will help in reducing issues due to incorrectly authored policies or
                outages due to operator error.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Policy Staging and Audit Modes"><div class="sect2" id="policy_staging_and_audit_modes">
            <h2>Policy Staging and Audit Modes</h2>
            <p>Even less common than policy impact previews, but potentially<a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="policy staging (policy audit modes)" id="idm45326825806816"/> even more valuable, is support for
                policy staging, sometimes called policy audit mode.</p>
            <p>Policy staging allows network policy changes to be applied to the cluster without impacting network
                traffic. The staged policy then records the full details of all the flows it would have interacted with,
                without actually impacting any of the flows. This is incredibly useful in scenarios where a policy
                impact preview of an individual policy against historical data may be overly simplistic given the
                complexity of the applications running in the cluster. For example, this could be if multiple
                interdependent policies need to be updated in unison, or if there’s a desire to monitor the policy
                impact with live rather than historical network flows.</p>
            <p>In order to make the task of authoring effective network policies less daunting, you need to use policy
                recommendations and then stage policies to understand the impact of the policy before you promote it for
                enforcement. This cycle of policy recommendation (based on historical network flows), followed by
                staging (applying policies to current and future network flows), followed by making desired adjustments
                and then finally enforcing the policy is the best way to ensure the policy change would do exactly what
                you want.</p>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000012">
        <h1>Conclusion</h1>
        <p>In this chapter we discussed the importance of network policy and various network policy implementations and
            tooling to help you with implementation. The following are some key aspects of network policy:</p>
        <ul>
            <li>
                <p>Network policy should be used to secure a Kubernetes network, and it complements the firewalls that
                    are implemented at the perimeter of your cluster.</p>
            </li>
            <li>
                <p>It is recommended that you choose a Kubernetes-aware implementation that extends the basic Kubernetes
                    network policy.</p>
            </li>
            <li>
                <p>There are a lot of network policy implementations that offer tooling to help with the implementation of
                    network policy in a Kubernetes cluster.</p>
            </li>
        </ul>
    </div></section>
</div></section></div></body></html>