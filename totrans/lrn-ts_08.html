<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Arrays"><div class="chapter" id="arrays_chapter">
<h1><span class="label">Chapter 6. </span>Arrays</h1>

<blockquote>
<p>Arrays and tuples</p>

<p>One flexible and one fixed</p>

<p>Choose your adventure</p></blockquote>

<p>JavaScript arrays<a data-type="indexterm" data-primary="arrays" data-secondary="described" id="idm45584686958640"/> are wildly flexible and can hold any mixture of values inside:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">elements</code> <code class="o">=</code> <code class="p">[</code><code class="kc">true</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">42</code><code class="p">];</code>

<code class="nx">elements</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"even"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"more"</code><code class="p">]);</code>
<code class="c1">// Value of elements: [true, null, undefined, 42, "even", ["more"]]</code></pre>

<p>In most cases, though, individual JavaScript arrays are intended to hold only one specific type of value.
Adding values of a different type may be confusing to readers, or worse, the result of an error that could cause problems in the program.</p>

<p>TypeScript respects the best practice of keeping to one data type per array by remembering what type of data is initially inside an array, and only allowing the array to operate on that kind of data.</p>

<p>In this example, TypeScript knows the <code>warriors</code> array initially contains <code>string</code> typed values, so while adding more <code>string</code> typed values is allowed, adding any other type of data is not:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">warriors</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Artemisia"</code><code class="p">,</code> <code class="s2">"Boudica"</code><code class="p">];</code>

<code class="c1">// Ok: "Zenobia" is a string</code>
<code class="nx">warriors</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"Zenobia"</code><code class="p">);</code>

<code class="nx">warriors</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code>
<code class="c1">//            ~~~~</code>
<code class="c1">// Argument of type 'boolean' is not assignable to parameter of type 'string'.</code></pre>

<p>You can think of TypeScript’s inference of an array’s type from its initial members as similar to how it understands variable types from their initial values.
TypeScript generally tries to understand the intended types of your code from how values are assigned, and arrays are no exception.</p>






<section data-type="sect1" data-pdf-bookmark="Array Types"><div class="sect1" id="idm45584686929344">
<h1>Array Types</h1>

<p>As with<a data-type="indexterm" data-primary="arrays" data-secondary="as types" data-tertiary="type annotations for" data-secondary-sortas="types" id="idm45584686927936"/><a data-type="indexterm" data-primary="types" data-secondary="arrays as" data-tertiary="type annotations for" id="idm45584686879696"/><a data-type="indexterm" data-primary="type annotations" data-secondary="for arrays" data-secondary-sortas="arrays" id="idm45584686878480"/> other variable declarations, variables meant to store arrays don’t need to have an initial value.
The variables can start off <code>undefined</code> and receive an array value later.</p>

<p>TypeScript will want you to let it know what types of values are meant to go in the array by giving the variable a type annotation.
The type annotation for an array requires the type of elements in the array followed by a <code>[]</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">arrayOfNumbers</code>: <code class="nx">number</code><code class="p">[];</code>

<code class="nx">arrayOfNumbers</code> <code class="o">=</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">];</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Array types<a data-type="indexterm" data-primary="class generics for arrays" id="idm45584686826512"/> can also be written in a syntax like <code>Array&lt;number&gt;</code> called <em>class generics</em>.
Most developers prefer the simpler <code>number[]</code>.
Classes are covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch08.xhtml#classes">Chapter 8, “Classes”</a>, and generics are covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch09.xhtml#type_modifiers_chapter">Chapter 9, “Type Modifiers”</a>.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Array and Function Types"><div class="sect2" id="idm45584686821904">
<h2>Array and Function Types</h2>

<p>Array types<a data-type="indexterm" data-primary="arrays" data-secondary="as types" data-tertiary="function types and" data-secondary-sortas="types" id="idm45584686820576"/><a data-type="indexterm" data-primary="types" data-secondary="arrays as" data-tertiary="function types and" id="idm45584686819024"/><a data-type="indexterm" data-primary="types" data-secondary="functions as" data-tertiary="array types and" id="idm45584686817808"/><a data-type="indexterm" data-primary="functions" data-secondary="as types" data-tertiary="array types and" data-secondary-sortas="types" id="idm45584686816592"/><a data-type="indexterm" data-primary="parentheses ()" data-secondary="arrays and" id="idm45584686815104"/><a data-type="indexterm" data-primary="() (parentheses)" data-secondary="arrays and" id="idm45584686814160"/> are an example of a syntax container where function types may need parentheses to distinguish what’s in the function type or not.
Parentheses may be used to indicate which part of an annotation is the function return or the surrounding array type.</p>

<p>The <code>createStrings</code> type here, which is a function type, is not the same as 
<span class="keep-together"><code>stringCreators</code>,</span> which is an array type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type is a function that returns an array of strings</code>
<code class="kd">let</code> <code class="nx">createStrings</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">[];</code>

<code class="c1">// Type is an array of functions that each return a string</code>
<code class="kd">let</code> <code class="nx">stringCreators</code><code class="o">:</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">)[];</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Union-Type Arrays"><div class="sect2" id="idm45584686774656">
<h2>Union-Type Arrays</h2>

<p>You <a data-type="indexterm" data-primary="arrays" data-secondary="as types" data-tertiary="union types and" data-secondary-sortas="types" id="array-type-union"/><a data-type="indexterm" data-primary="types" data-secondary="arrays as" data-tertiary="union types and" id="type-array-union"/><a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="array types and" id="type-union-array"/><a data-type="indexterm" data-primary="unions" data-secondary="array types and" id="union-array"/>can use a union type to indicate that each element of an array can be one of multiple select types.</p>

<p>When using array types with unions, parentheses may need to be used to indicate which part of an annotation is the contents of the array or the surrounding union type.
Using parentheses in array union types is important—the following two types are not the same:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="c1">// Type is either a number or an array of strings</code>
<code class="kd">let</code> <code class="nx">stringOrArrayOfNumbers</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">[];</code>

<code class="c1">// Type is an array of elements that are each either a number or a string</code>
<code class="kd">let</code> <code class="nx">arrayOfStringOrNumbers</code><code class="o">:</code> <code class="p">(</code><code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">)[];</code></pre>

<p>TypeScript will understand from an array’s declaration that it is a union-type array if it contains more than one type of element.
In other words, the type of an array’s elements is the union of all possible types for elements in the array.</p>

<p>Here, <code>namesMaybe</code> is <code>(string | undefined)[]</code> because it has both <code>string</code> values and<a data-type="indexterm" data-primary="arrays" data-secondary="as types" data-tertiary="union types and" data-secondary-sortas="types" data-startref="array-type-union" id="idm45584686713360"/><a data-type="indexterm" data-primary="types" data-secondary="arrays as" data-tertiary="union types and" data-startref="type-array-union" id="idm45584686711536"/><a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="array types and" data-startref="type-union-array" id="idm45584686710048"/><a data-type="indexterm" data-primary="unions" data-secondary="array types and" data-startref="union-array" id="idm45584686708560"/> an <code>undefined</code> value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type is (string | undefined)[]</code>
<code class="kr">const</code> <code class="nx">namesMaybe</code> <code class="o">=</code> <code class="p">[</code>
  <code class="s2">"Aqualtune"</code><code class="p">,</code>
  <code class="s2">"Blenda"</code><code class="p">,</code>
  <code class="kc">undefined</code><code class="p">,</code>
<code class="p">];</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Evolving Any Arrays"><div class="sect2" id="idm45584686785632">
<h2>Evolving Any Arrays</h2>

<p>If you<a data-type="indexterm" data-primary="arrays" data-secondary="as types" data-tertiary="evolving any arrays" data-secondary-sortas="types" id="idm45584686683264"/><a data-type="indexterm" data-primary="types" data-secondary="arrays as" data-tertiary="evolving any arrays" id="idm45584686681712"/><a data-type="indexterm" data-primary="evolving any type" id="idm45584686680496"/><a data-type="indexterm" data-primary="any type" data-secondary="evolving any" id="idm45584686679824"/> don’t include a type annotation on a variable initially set to an empty array, TypeScript will treat the array as evolving <code>any[]</code>, meaning it can receive any content.
As with evolving <code>any</code> variables, we don’t like evolving <code>any[]</code> arrays.
They partially negate the benefits of TypeScript’s type checker by allowing you to add potentially incorrect values.</p>

<p>This <code>values</code> array starts off containing <code>any</code> elements, evolves to contain <code>string</code> elements, then again evolves to include <code>number | string</code> elements:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: any[]</code>
<code class="kd">let</code> <code class="nx">values</code> <code class="o">=</code> <code class="p">[];</code>

<code class="c1">// Type: string[]</code>
<code class="nx">values</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">''</code><code class="p">);</code>

<code class="c1">// Type: (number | string)[]</code>
<code class="nx">values</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code></pre>

<p>As with variables, allowing arrays to be evolving <code>any</code> typed—and using the <code>any</code> type in general—partially defeats the purpose of TypeScript’s type checking.
TypeScript works best when it knows what types your values are meant to be.</p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Multidimensional Arrays"><div class="sect2" id="idm45584686629856">
<h2>Multidimensional Arrays</h2>

<p>A<a data-type="indexterm" data-primary="arrays" data-secondary="as types" data-tertiary="multidimensional arrays" data-secondary-sortas="types" id="array-type-multi"/><a data-type="indexterm" data-primary="types" data-secondary="arrays as" data-tertiary="multidimensional arrays" id="type-array-multi"/><a data-type="indexterm" data-primary="multidimensional arrays" id="multi-arrays"/> 2D array, or an array of arrays, will have two “[]”s:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">arrayOfArraysOfNumbers</code>: <code class="nx">number</code><code class="p">[][];</code>

<code class="nx">arrayOfArraysOfNumbers</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
  <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code>
  <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">9</code><code class="p">],</code>
<code class="p">];</code></pre>

<p>A 3D array, or an array of arrays of arrays, will have three “[]”s.
4D arrays have four “[]”s.
5D arrays have five “[]”s.
You can guess where this is going for 6D arrays and beyond.</p>

<p>These multidimensional array types don’t introduce any new concepts to array types.
Think of a 2D array as taking in the original type, which just so happens to have <code>[]</code> at the end, and adding a <code>[]</code> after it.</p>

<p>This <code>arrayOfArraysOfNumbers</code> array is of type <code>number[][]</code>, which is also 
<span class="keep-together">representable</span> by <code>(number[])[]</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: number[][]</code>
<code class="kd">let</code> <code class="nx">arrayOfArraysOfNumbers</code><code class="o">:</code> <code class="p">(</code><code class="kt">number</code><code class="p">[])[];</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Array Members"><div class="sect1" id="idm45584686517216">
<h1>Array Members</h1>

<p>TypeScript <a data-type="indexterm" data-primary="arrays" data-secondary="members, retrieving" id="array-member-retrieve"/><a data-type="indexterm" data-primary="members of arrays, retrieving" id="member-retrieve"/><a data-type="indexterm" data-primary="retrieving array members" id="retrieve-array-member"/>understands typical index-based access for retrieving members of an array to give back an element of that array’s type.</p>

<p>This <code>defenders</code> array is of type <code>string[]</code>, so <code>defender</code> is a <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">defenders</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Clarenza"</code><code class="p">,</code> <code class="s2">"Dina"</code><code class="p">];</code>

<code class="c1">// Type: string</code>
<code class="kr">const</code> <code class="nx">defender</code> <code class="o">=</code> <code class="nx">defenders</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code></pre>

<p>Members of union typed arrays are themselves that same union type.</p>

<p>Here, <code>soldiersOrDates</code> is of type <code>(string | Date)[]</code>, so the <code>soldierOrDate</code> variable is of type <code>string | Date</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">soldiersOrDates</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Deborah Sampson"</code><code class="p">,</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="mi">1782</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">3</code><code class="p">)];</code>

<code class="c1">// Type: Date | string</code>
<code class="kr">const</code> <code class="nx">soldierOrDate</code> <code class="o">=</code> <code class="nx">soldiersOrDates</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code></pre>








<section data-type="sect2" data-pdf-bookmark="Caveat: Unsound Members"><div class="sect2" id="idm45584686462832">
<h2>Caveat: Unsound Members</h2>

<p>The TypeScript type system is known to be technically <em>unsound</em>: it can get types mostly right, but sometimes its understanding about the types of values may be incorrect.
Arrays in particular are a source of unsoundness in the type system.
By default, TypeScript assumes all array member accesses return a member of that array, even though in JavaScript, accessing an array element with an index greater than the array’s length gives <code>undefined</code>.</p>

<p>This code gives no complaints with the default TypeScript compiler settings:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">withElements</code><code class="p">(</code><code class="nx">elements</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">elements</code><code class="p">[</code><code class="mi">9001</code><code class="p">].</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// No type error</code>
<code class="p">}</code>

<code class="nx">withElements</code><code class="p">([</code><code class="s2">"It's"</code><code class="p">,</code> <code class="s2">"over"</code><code class="p">]);</code></pre>

<p>We as readers can deduce that it’ll crash at runtime with “<code>Cannot read property 'length' of undefined</code>”, but TypeScript intentionally does not make sure retrieved array members exist.
It sees <code>elements[9001]</code> in the code snippet as being type <code>string</code>, not <code>undefined</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>TypeScript does have a <code>--noUncheckedIndexedAccess</code> flag that makes array lookups more restricted and type safe, but it’s quite strict and most projects don’t use it.
I don’t cover it in this book.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch12.xhtml#using_ide_features">Chapter 12, “Using IDE Features”</a> links to resources that explain all of TypeScript’s configuration options in <a data-type="indexterm" data-primary="arrays" data-secondary="members, retrieving" data-startref="array-member-retrieve" id="idm45584686378240"/><a data-type="indexterm" data-primary="members of arrays, retrieving" data-startref="member-retrieve" id="idm45584686376992"/><a data-type="indexterm" data-primary="retrieving array members" data-startref="retrieve-array-member" id="idm45584686376080"/><a data-type="indexterm" data-primary="types" data-secondary="arrays as" data-tertiary="unsound members" data-startref="type-array-unsound" id="idm45584686375168"/><a data-type="indexterm" data-primary="unsound array members" data-startref="unsound" id="idm45584686373680"/>depth.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Spreads and Rests"><div class="sect1" id="idm45584686372352">
<h1>Spreads and Rests</h1>

<p>Remember <code>...</code> rest parameters for functions from <a data-type="xref" data-xrefstyle="chap-num-title" href="ch05.xhtml#functions">Chapter 5, “Functions”</a>?
Rest parameters and array spreading, both with the <code>...</code> operator, are key ways to interact with arrays in JavaScript.
TypeScript understands both of them.</p>








<section data-type="sect2" data-pdf-bookmark="Spreads"><div class="sect2" id="idm45584686368688">
<h2>Spreads</h2>

<p>Arrays<a data-type="indexterm" data-primary="arrays" data-secondary="joining with spread operator" id="idm45584686367120"/><a data-type="indexterm" data-primary="joining arrays with spread operator" id="idm45584686366144"/><a data-type="indexterm" data-primary="spread operator (. . .)" data-secondary="for arrays" id="idm45584686365504"/><a data-type="indexterm" data-primary="ellipsis (. . .), spread operator" data-secondary="for arrays" id="idm45584686364560"/><a data-type="indexterm" data-primary=". . . (ellipsis), spread operator" data-secondary="for arrays" id="idm45584686363648"/> can be joined together using the <code>...</code> spread operator.
TypeScript understands the result array will contain values that can be from either of the input arrays.</p>

<p>If the input arrays are the same type, the output array will be that same type.
If two arrays of different types are spread together to create a new array, the new array will be understood to be a union type array of elements that are either of the two original types.</p>

<p>Here, the <code>conjoined</code> array is known to contain both values that are type <code>string</code> and values that are type <code>number</code>, so its type is inferred to be <code>(string | number)[]</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: string[]</code>
<code class="kr">const</code> <code class="nx">soldiers</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Harriet Tubman"</code><code class="p">,</code> <code class="s2">"Joan of Arc"</code><code class="p">,</code> <code class="s2">"Khutulun"</code><code class="p">];</code>

<code class="c1">// Type: number[]</code>
<code class="kr">const</code> <code class="nx">soldierAges</code> <code class="o">=</code> <code class="p">[</code><code class="mi">90</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code> <code class="mi">45</code><code class="p">];</code>

<code class="c1">// Type: (string | number)[]</code>
<code class="kr">const</code> <code class="nx">conjoined</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">soldiers</code><code class="p">,</code> <code class="p">...</code><code class="nx">soldierAges</code><code class="p">];</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Spreading Rest Parameters"><div class="sect2" id="idm45584686261952">
<h2>Spreading Rest Parameters</h2>

<p>TypeScript recognizes and will perform type checking on the JavaScript practice of <code>...</code> spreading an array as a rest parameter.
Arrays used as arguments for rest parameters must have the same array type as the rest parameter.</p>

<p>The <code>logWarriors</code> function below takes in only <code>string</code> values for its <code>...names</code> rest parameter.
Spreading an array of type <code>string[]</code> is allowed, but a <code>number[]</code> is not:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">logWarriors</code><code class="p">(</code><code class="nx">greeting</code>: <code class="nx">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">names</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">name</code> <code class="nx">of</code> <code class="nx">names</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">greeting</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">warriors</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Cathay Williams"</code><code class="p">,</code> <code class="s2">"Lozen"</code><code class="p">,</code> <code class="s2">"Nzinga"</code><code class="p">];</code>

<code class="nx">logWarriors</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">,</code> <code class="p">...</code><code class="nx">warriors</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">birthYears</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1844</code><code class="p">,</code> <code class="mi">1840</code><code class="p">,</code> <code class="mi">1583</code><code class="p">];</code>

<code class="nx">logWarriors</code><code class="p">(</code><code class="s2">"Born in"</code><code class="p">,</code> <code class="p">...</code><code class="nx">birthYears</code><code class="p">);</code>
<code class="c1">//                     ~~~~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type 'number' is not</code>
<code class="c1">// assignable to parameter of type 'string'.</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Tuples"><div class="sect1" id="idm45584686257360">
<h1>Tuples</h1>

<p>Although<a data-type="indexterm" data-primary="arrays" data-secondary="tuples" data-tertiary="described" id="idm45584686169248"/><a data-type="indexterm" data-primary="tuples" data-secondary="described" id="idm45584686167968"/><a data-type="indexterm" data-primary="fixed-size arrays" data-see="tuples" id="idm45584686167024"/> JavaScript arrays may be any size in theory, it is sometimes useful to use an array of a fixed size—also known as a <em>tuple</em>.
Tuple arrays have a specific known type at each index that may be more specific than a union type of all possible members of the array.
The syntax to declare a tuple type looks like an array literal, but with types in place of element values.</p>

<p>Here, the array <code>yearAndWarrior</code> is declared as being a tuple type with a <code>number</code> at index 0 and a <code>string</code> at index 1:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">yearAndWarrior</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">];</code>

<code class="nx">yearAndWarrior</code> <code class="o">=</code> <code class="p">[</code><code class="mi">530</code><code class="p">,</code> <code class="s2">"Tomyris"</code><code class="p">];</code> <code class="c1">// Ok</code>

<code class="nx">yearAndWarrior</code> <code class="o">=</code> <code class="p">[</code><code class="kc">false</code><code class="p">,</code> <code class="s2">"Tomyris"</code><code class="p">];</code>
<code class="c1">//                ~~~~~</code>
<code class="c1">// Error: Type 'boolean' is not assignable to type 'number'.</code>

<code class="nx">yearAndWarrior</code> <code class="o">=</code> <code class="p">[</code><code class="mi">530</code><code class="p">];</code>
<code class="c1">// Error: Type '[number]' is not assignable to type '[number, string]'.</code>
<code class="c1">//   Source has 1 element(s) but target requires 2.</code></pre>

<p>Tuples are often used in JavaScript alongside array destructuring to be able to assign multiple values at once, such as setting two variables to initial values based on a single condition.</p>

<p>For example, TypeScript recognizes here that <code>year</code> is always going to be a <code>number</code> and <code>warrior</code> is always going to be a <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// year type: number</code>
<code class="c1">// warrior type: string</code>
<code class="kd">let</code> <code class="p">[</code><code class="nx">year</code><code class="p">,</code> <code class="nx">warrior</code><code class="p">]</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
  <code class="o">?</code> <code class="p">[</code><code class="mi">340</code><code class="p">,</code> <code class="s2">"Archidamia"</code><code class="p">]</code>
  <code class="o">:</code> <code class="p">[</code><code class="mi">1828</code><code class="p">,</code> <code class="s2">"Rani of Jhansi"</code><code class="p">];</code></pre>








<section data-type="sect2" data-pdf-bookmark="Tuple Assignability"><div class="sect2" id="idm45584686020000">
<h2>Tuple Assignability</h2>

<p>Tuple types <a data-type="indexterm" data-primary="arrays" data-secondary="tuples" data-tertiary="assignability" id="array-tuple-assign"/><a data-type="indexterm" data-primary="tuples" data-secondary="assignability" id="tuples-assign"/><a data-type="indexterm" data-primary="assignability" data-secondary="of tuples" data-secondary-sortas="tuples" id="assign-tuple"/>are treated by TypeScript as more specific than variable length array types.
That means variable length array types aren’t assignable to tuple types.</p>

<p>Here, although we as humans may see <code>pairLoose</code> as having <code>[boolean, number]</code> inside, TypeScript infers it to be the more general <code>(boolean | number)[]</code> type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (boolean | number)[]</code>
<code class="kr">const</code> <code class="nx">pairLoose</code> <code class="o">=</code> <code class="p">[</code><code class="kc">false</code><code class="p">,</code> <code class="mi">123</code><code class="p">];</code>

<code class="kr">const</code> <code class="nx">pairTupleLoose</code><code class="o">:</code> <code class="p">[</code><code class="kr">boolean</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="nx">pairLoose</code><code class="p">;</code>
<code class="c1">//    ~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Type '(number | boolean)[]' is not</code>
<code class="c1">// assignable to type '[boolean, number]'.</code>
<code class="c1">//   Target requires 2 element(s) but source may have fewer.</code></pre>

<p>If <code>pairLoose</code> had been declared as a <code>[boolean, number]</code> itself, the assignment of its value to <code>pairTuple</code> would have been permitted.</p>

<p>Tuples of different lengths are also not assignable to each other, as TypeScript includes knowing how many members are in the tuple in tuple types.</p>

<p>Here, <code>tupleTwoExtra</code> must have exactly two members, so although <code>tupleThree</code> starts with the correct members, its third member prevents it from being assignable to <code>tupleTwoExtra</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">tupleThree</code><code class="o">:</code> <code class="p">[</code><code class="kr">boolean</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="kc">false</code><code class="p">,</code> <code class="mi">1583</code><code class="p">,</code> <code class="s2">"Nzinga"</code><code class="p">];</code>

<code class="kr">const</code> <code class="nx">tupleTwoExact</code><code class="o">:</code> <code class="p">[</code><code class="kr">boolean</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">tupleThree</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">tupleThree</code><code class="p">[</code><code class="mi">1</code><code class="p">]];</code>

<code class="kr">const</code> <code class="nx">tupleTwoExtra</code><code class="o">:</code> <code class="p">[</code><code class="kr">boolean</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="nx">tupleThree</code><code class="p">;</code>
<code class="c1">//    ~~~~~~~~~~~~~</code>
<code class="c1">// Error: Type '[boolean, number, string]' is</code>
<code class="c1">// not assignable to type '[boolean, number]'.</code>
<code class="c1">//   Source has 3 element(s) but target allows only 2.</code></pre>










<section data-type="sect3" data-pdf-bookmark="Tuples as rest parameters"><div class="sect3" id="idm45584685908544">
<h3>Tuples as rest parameters</h3>

<p>Because <a data-type="indexterm" data-primary="arrays" data-secondary="tuples" data-tertiary="as rest parameters" data-tertiary-sortas="rest parameters" id="array-tuple-rest"/><a data-type="indexterm" data-primary="tuples" data-secondary="as rest parameters" data-secondary-sortas="rest parameters" id="tuple-rest"/><a data-type="indexterm" data-primary="rest parameters" data-secondary="tuples as" id="rest-tuple"/><a data-type="indexterm" data-primary="parameters" data-secondary="rest" data-tertiary="tuples as" id="parameters-rest-tuple"/><a data-type="indexterm" data-primary=". . . (ellipsis), spread operator" data-secondary="tuples as rest parameters" id="ellipsis-sym-tuple"/><a data-type="indexterm" data-primary="ellipsis (. . .), spread operator" data-secondary="tuples as rest parameters" id="ellipsis-tuple"/><a data-type="indexterm" data-primary="spread operator (. . .)" data-secondary="tuples as rest parameters" id="spread-tuple"/>tuples are seen as arrays with more specific type information on length and element types, they can be particularly useful for storing arguments to be passed to a function.
TypeScript is able to provide accurate type checking for tuples passed as <code>...</code> rest parameters.</p>

<p>Here, the <code>logPair</code> function’s parameters are typed <code>string</code> and <code>number</code>.
Trying to pass in a value of type <code>(string | number)[]</code> as arguments wouldn’t be type safe as the contents might not match up: they could both be the same type, or one of each type in the wrong order.
However, if TypeScript knows the value to be a <code>[string, number]</code> tuple, it understands the values match up:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">logPair</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">value</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb"> has </code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">pairArray</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Amage"</code><code class="p">,</code> <code class="mi">1</code><code class="p">];</code>

<code class="nx">logPair</code><code class="p">(...</code><code class="nx">pairArray</code><code class="p">);</code>
<code class="c1">// Error: A spread argument must either have a</code>
<code class="c1">// tuple type or be passed to a rest parameter.</code>

<code class="kr">const</code> <code class="nx">pairTupleIncorrect</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="s2">"Amage"</code><code class="p">];</code>

<code class="nx">logPair</code><code class="p">(...</code><code class="nx">pairTupleIncorrect</code><code class="p">);</code>
<code class="c1">// Error: Argument of type 'number' is not</code>
<code class="c1">// assignable to parameter of type 'string'.</code>

<code class="kr">const</code> <code class="nx">pairTupleCorrect</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Amage"</code><code class="p">,</code> <code class="mi">1</code><code class="p">];</code>

<code class="nx">logPair</code><code class="p">(...</code><code class="nx">pairTupleCorrect</code><code class="p">);</code> <code class="c1">// Ok</code></pre>

<p>If you really want to go wild with your rest parameters tuples, you can mix them with arrays to store a list of arguments for multiple function calls.
Here, <code>trios</code> is an array of tuples, where each tuple also has a tuple for its second member.

<span class="keep-together"><code>trios.forEach(trio =&gt; logTrio(...trio))</code></span> is known to be safe because each <code>...trio</code> happens to match the parameter types of 
<span class="keep-together"><code>logTrio</code>.</span>

<span class="keep-together"><code>trios.forEach(logTrio)</code>,</span> however, is not assignable because that is attempting to pass the entire <code>[string, [number, boolean]</code> as the first parameter, which is type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">logTrio</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kr">boolean</code><code class="p">])</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb"> has </code><code class="si">${</code><code class="nx">value</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="si">}</code><code class="sb"> (</code><code class="si">${</code><code class="nx">value</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">trios</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kr">boolean</code><code class="p">]][]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">[</code><code class="s2">"Amanitore"</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="kc">true</code><code class="p">]],</code>
  <code class="p">[</code><code class="s2">"Æthelflæd"</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="kc">false</code><code class="p">]],</code>
  <code class="p">[</code><code class="s2">"Ann E. Dunwoody"</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="kc">false</code><code class="p">]]</code>
<code class="p">];</code>

<code class="nx">trios</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">trio</code> <code class="o">=&gt;</code> <code class="nx">logTrio</code><code class="p">(...</code><code class="nx">trio</code><code class="p">));</code> <code class="c1">// Ok</code>

<code class="nx">trios</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">logTrio</code><code class="p">);</code>
<code class="c1">//            ~~~~~~~</code>
<code class="c1">// Argument of type '(name: string, value: [number, boolean]) =&gt; void'</code>
<code class="c1">// is not assignable to parameter of type</code>
<code class="c1">// '(value: [string, [number, boolean]], ...) =&gt; void'.</code>
<code class="c1">//   Types of parameters 'name' and 'value' are incompatible.</code>
<code class="c1">//     Type '[string, [number, boolean]]' is not assignable to type 'string'.</code></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Tuple Inferences"><div class="sect2" id="idm45584685702816">
<h2>Tuple Inferences</h2>

<p>TypeScript <a data-type="indexterm" data-primary="arrays" data-secondary="tuples" data-tertiary="inferring" id="idm45584685622032"/><a data-type="indexterm" data-primary="tuples" data-secondary="inferring" id="idm45584685620752"/><a data-type="indexterm" data-primary="inferred tuples" id="idm45584685619808"/>generally treats created arrays as variable length arrays, not tuples.
If it sees an array being used as a variable’s initial value or the returned value for a function, then it will assume a flexible size array rather than a fixed size tuple.</p>

<p>The following <code>firstCharAndSize</code> function is inferred as returning <code>(string |</code> 
<span class="keep-together"><code>number)[]</code>,</span> not <code>[string, number]</code>, because that’s the type inferred for its returned array literal:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Return type: (string | number)[]</code>
<code class="kd">function</code> <code class="nx">firstCharAndSize</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">[</code><code class="nx">input</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">];</code>
<code class="p">}</code>

<code class="c1">// firstChar type: string | number</code>
<code class="c1">// size type: string | number</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">firstChar</code><code class="p">,</code> <code class="nx">size</code><code class="p">]</code> <code class="o">=</code> <code class="nx">firstCharAndSize</code><code class="p">(</code><code class="s2">"Gudit"</code><code class="p">);</code></pre>

<p>There are two common ways in TypeScript to indicate that a value should be a more specific tuple type instead of a general array type: explicit tuple types and <code>const</code> assertions.</p>










<section data-type="sect3" data-pdf-bookmark="Explicit tuple types"><div class="sect3" id="idm45584685569408">
<h3>Explicit tuple types</h3>

<p>Tuple types <a data-type="indexterm" data-primary="arrays" data-secondary="tuples" data-tertiary="explicit types" id="idm45584685568176"/><a data-type="indexterm" data-primary="tuples" data-secondary="explicit types" id="idm45584685566896"/><a data-type="indexterm" data-primary="explicit tuple types" id="idm45584685565952"/><a data-type="indexterm" data-primary="types" data-secondary="tuples as" data-tertiary="explicit tuple types" id="idm45584685512688"/>may be used in type annotations, such as the return type annotation for a function.
If the function is declared as returning a tuple type and returns an array literal, that array literal will be inferred to be a tuple instead of a more general variable-length array.</p>

<p>This <code>firstCharAndSizeExplicit</code> function version explicitly states that it returns a tuple of a <code>string</code> and <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Return type: [string, number]</code>
<code class="kd">function</code> <code class="nx">firstCharAndSizeExplicit</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">[</code><code class="nx">input</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">];</code>
<code class="p">}</code>

<code class="c1">// firstChar type: string</code>
<code class="c1">// size type: number</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">firstChar</code><code class="p">,</code> <code class="nx">size</code><code class="p">]</code> <code class="o">=</code> <code class="nx">firstCharAndSizeExplicit</code><code class="p">(</code><code class="s2">"Cathay Williams"</code><code class="p">);</code></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Const asserted tuples"><div class="sect3" id="idm45584685451600">
<h3>Const asserted tuples</h3>

<p>Typing out<a data-type="indexterm" data-primary="arrays" data-secondary="tuples" data-tertiary="const assertions" id="array-tuple-const"/><a data-type="indexterm" data-primary="tuples" data-secondary="const assertions" id="tuples-const"/><a data-type="indexterm" data-primary="const assertions" id="const-assert"/><a data-type="indexterm" data-primary="types" data-secondary="tuples as" data-tertiary="const assertions" id="type-tuple-const"/><a data-type="indexterm" data-primary="as const operator" id="as-const"/> tuple types in explicit type annotations can be a pain for the same reasons as typing out any explicit type annotations.
It’s extra syntax for you to write and update as code changes.</p>

<p>As an alternative, TypeScript provides an <code>as const</code> operator known as a <em>const assertion</em> that can be placed after a value.
Const assertions tell TypeScript to use the most literal, read-only possible form of the value when inferring its type.
If one is placed after an array literal, it will indicate that the array should be treated as a tuple:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (string | number)[]</code>
<code class="kr">const</code> <code class="nx">unionArray</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1157</code><code class="p">,</code> <code class="s2">"Tomoe"</code><code class="p">];</code>

<code class="c1">// Type: readonly [1157, "Tomoe"]</code>
<code class="kr">const</code> <code class="nx">readonlyTuple</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1157</code><code class="p">,</code> <code class="s2">"Tomoe"</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code></pre>

<p>Note that <code>as const</code> assertions go beyond switching from flexible sized arrays to fixed size tuples: they also indicate to TypeScript that the tuple is read-only and cannot be used in a place that expects it should be allowed to modify the value.</p>

<p>In this example, <code>pairMutable</code> is allowed to be modified because it has a traditional explicit tuple type.
However, the <code>as const</code> makes the value not assignable to the mutable <code>pairAlsoMutable</code>, and members of the constant <code>pairConst</code> are not allowed to be modified:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">pairMutable</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1157</code><code class="p">,</code> <code class="s2">"Tomoe"</code><code class="p">];</code>
<code class="nx">pairMutable</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1247</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kr">const</code> <code class="nx">pairAlsoMutable</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1157</code><code class="p">,</code> <code class="s2">"Tomoe"</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>
<code class="c1">//    ~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: The type 'readonly [1157, "Tomoe"]' is 'readonly'</code>
<code class="c1">// and cannot be assigned to the mutable type '[number, string]'.</code>

<code class="kr">const</code> <code class="nx">pairConst</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1157</code><code class="p">,</code> <code class="s2">"Tomoe"</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>
<code class="nx">pairConst</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1247</code><code class="p">;</code>
<code class="c1">//        ~</code>
<code class="c1">// Error: Cannot assign to '0' because it is a read-only property.</code></pre>

<p>In practice, read-only tuples are convenient for function returns.
Returned values from functions that return a tuple are often destructured immediately anyway, so the tuple being read-only does not get in the way of using the function.</p>

<p>This <code>firstCharAndSizeAsConst</code> returns a <code>readonly [string, number]</code>, but the consuming code only cares about retrieving the values from that tuple:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Return type: readonly [string, number]</code>
<code class="kd">function</code> <code class="nx">firstCharAndSizeAsConst</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">[</code><code class="nx">input</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// firstChar type: string</code>
<code class="c1">// size type: number</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">firstChar</code><code class="p">,</code> <code class="nx">size</code><code class="p">]</code> <code class="o">=</code> <code class="nx">firstCharAndSizeAsConst</code><code class="p">(</code><code class="s2">"Ching Shih"</code><code class="p">);</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Read-only objects and <code>as const</code> assertions are covered more <a data-type="indexterm" data-primary="arrays" data-secondary="tuples" data-tertiary="const assertions" data-startref="array-tuple-const" id="idm45584685253856"/><a data-type="indexterm" data-primary="tuples" data-secondary="const assertions" data-startref="tuples-const" id="idm45584685252368"/><a data-type="indexterm" data-primary="const assertions" data-startref="const-assert" id="idm45584685251152"/><a data-type="indexterm" data-primary="types" data-secondary="tuples as" data-tertiary="const assertions" data-startref="type-tuple-const" id="idm45584685250208"/><a data-type="indexterm" data-primary="as const operator" data-startref="as-const" id="idm45584685248720"/>deeply in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch09.xhtml#type_modifiers_chapter">Chapter 9, “Type Modifiers”</a>.</p>
</div>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584685433936">
<h1>Summary</h1>

<p>In this chapter, you worked with declaring arrays and retrieving their members:</p>

<ul>
<li>
<p>Declaring array types with <code>[]</code></p>
</li>
<li>
<p>Using parentheses to declare arrays of functions or union types</p>
</li>
<li>
<p>How TypeScript understands array elements as the type of the array</p>
</li>
<li>
<p>Working with <code>...</code> spreads and rests</p>
</li>
<li>
<p>Declaring tuple types to represent fixed-size arrays</p>
</li>
<li>
<p>Using type annotations or <code>as const</code> assertions to create tuples</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/arrays"><em class="hyperlink">https://learningtypescript.com/arrays</em></a>.</p>
</div>
<blockquote class="joke">
<p>What’s a pirate’s favorite data structure?</p>

<p>Arrrrr-ays!</p></blockquote>
</div></section>







</div></section></div></body></html>