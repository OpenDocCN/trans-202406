["```\nSET @p_val = (SELECT pilot_id FROM pilot WHERE available = 'yes' LIMIT 1);\nUPDATE pilot SET available = 'no' WHERE pilot_id = @p_val;\nUPDATE flight SET pilot_id = @p_val WHERE flight_id = 578;\n```", "```\nmysql> `SELECT ENGINE FROM INFORMATION_SCHEMA.ENGINES`\n    -> `WHERE SUPPORT IN ('YES','DEFAULT') AND TRANSACTIONS='YES';`\n+--------+\n| ENGINE |\n+--------+\n| InnoDB |\n+--------+\n```", "```\nCREATE TABLE *`t`* (i INT) ENGINE = InnoDB;\n```", "```\nALTER TABLE *`t`* ENGINE = InnoDB;\n```", "```\n    mysql> `CREATE TABLE t (i INT) ENGINE = InnoDB;`\n    mysql> `START TRANSACTION;`\n    mysql> `INSERT INTO t (i) VALUES(1);`\n    mysql> `INSERT INTO t (i) VALUES(2);`\n    mysql> `COMMIT;`\n    mysql> `SELECT * FROM t;`\n    +------+\n    | i    |\n    +------+\n    |    1 |\n    |    2 |\n    +------+\n    ```", "```\n    mysql> `CREATE TABLE t (i INT) ENGINE = InnoDB;`\n    mysql> `START TRANSACTION;`\n    mysql> `INSERT INTO t (i) VALUES(1);`\n    mysql> `INSERT INTO t (x) VALUES(2);`\n    ERROR 1054 (42S22): Unknown column 'x' in 'field list'\n    mysql> `ROLLBACK;`\n    mysql> `SELECT * FROM t;`\n    Empty set (0.00 sec)\n    ```", "```\n    mysql> `CREATE TABLE t (i INT) ENGINE = InnoDB;`\n    mysql> `SET autocommit = 0;`\n    mysql> `INSERT INTO t (i) VALUES(1);`\n    mysql> `INSERT INTO t (i) VALUES(2);`\n    mysql> `COMMIT;`\n    mysql> `SELECT * FROM t;`\n    +------+\n    | i    |\n    +------+\n    |    1 |\n    |    2 |\n    +------+\n    ```", "```\n    mysql> `SET autocommit = 1;`\n    ```", "```\n+------+------+\n| name | amt  |\n+------+------+\n| Eve  |   10 |\n| Ida  |    0 |\n+------+------+\n```", "```\nUPDATE money SET amt = amt - 6 WHERE name = 'Eve';\nUPDATE money SET amt = amt + 6 WHERE name = 'Ida';\n```", "```\n+------+------+\n| name | amt  |\n+------+------+\n| Eve  |    4 |\n| Ida  |    6 |\n+------+------+\n```", "```\nblock:\n  statement 1\n  statement 2\n  ...\n  statement *`n`*\n  commit\nif the block failed:\n  roll back\n```", "```\nsub transaction_init\n{\nmy $dbh = shift;\nmy $attr_ref = {};  # create hash in which to save attributes\n\n  $attr_ref->{RaiseError} = $dbh->{RaiseError};\n  $attr_ref->{PrintError} = $dbh->{PrintError};\n  $attr_ref->{AutoCommit} = $dbh->{AutoCommit};\n  $dbh->{RaiseError} = 1; # raise exception if an error occurs\n  $dbh->{PrintError} = 0; # don't print an error message\n  $dbh->{AutoCommit} = 0; # disable auto-commit\n  return $attr_ref;       # return attributes to caller\n}\n\nsub transaction_finish\n{\nmy ($dbh, $attr_ref, $error) = @_;\n\n  if ($error) # an error occurred\n  {\n    print \"Transaction failed, rolling back. Error was:\\n$error\\n\";\n    # roll back within eval to prevent rollback\n    # failure from terminating the script\n    eval { $dbh->rollback (); };\n  }\n  # restore error-handling and auto-commit attributes\n  $dbh->{AutoCommit} = $attr_ref->{AutoCommit};\n  $dbh->{PrintError} = $attr_ref->{PrintError};\n  $dbh->{RaiseError} = $attr_ref->{RaiseError};\n}\n```", "```\n$ref = transaction_init ($dbh);\neval\n{\n  # move some money from one person to the other\n  $dbh->do (\"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\");\n  $dbh->do (\"UPDATE money SET amt = amt + 6 WHERE name = 'Ida'\");\n  # all statements succeeded; commit transaction\n  $dbh->commit ();\n};\ntransaction_finish ($dbh, $ref, $@);\n```", "```\nbegin\n  client.query(\"START TRANSACTION\")\n  client.query(\"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\")\n  client.query(\"UPDATE money SET amt = amt + 6 WHERE name = 'Ida'\")\n  client.query(\"COMMIT\")\nrescue Mysql2::Error => e\n  puts \"Transaction failed, rolling back. Error was:\"\n  puts \"#{e.errno}: #{e.message}\"\n  begin           # empty exception handler in case rollback fails\n    client.query(\"ROLLBACK\")\n  rescue\n  end\nend\n```", "```\ntry\n{\n  $dbh->beginTransaction ();\n  $dbh->exec (\"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\");\n  $dbh->exec (\"UPDATE money SET amt = amt + 6 WHERE name = 'Ida'\");\n  $dbh->commit ();\n}\ncatch (Exception $e)\n{\n  print (\"Transaction failed, rolling back. Error was:\\n\");\n  print ($e->getMessage () . \"\\n\");\n  # empty exception handler in case rollback fails\n  try\n  {\n    $dbh->rollback ();\n  }\n  catch (Exception $e2) { }\n}\n```", "```\ntry:\n  cursor = conn.cursor()\n  # move some money from one person to the other\n  cursor.execute(\"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\")\n  cursor.execute(\"UPDATE money SET amt = amt + 6 WHERE name = 'Ida'\")\n  cursor.close()\n  conn.commit()\nexcept mysql.connector.Error as e:\n  print(\"Transaction failed, rolling back. Error was:\")\n  print(e)\n  try:  # empty exception handler in case rollback fails\n    conn.rollback()\n  except:\n    pass\n```", "```\nvar queries = []string{\n  \"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\",\n  \"UPDATE money SET amt = amt + 6 WHERE name = 'Ida'\",\n}\n\ntx, err := db.Begin()\nif err != nil {\n  log.Fatal(err)\n}\n\nfor _, query := range queries {\n  _, err := tx.Exec(query)\n  if err != nil {\n    fmt.Printf(\"Transaction failed, rolling back.\\nError was: %s\\n\",\n               err.Error())\n    if txerr := tx.Rollback(); txerr != nil {\n      fmt.Println(\"Rollback failed\")\n      log.Fatal(txerr)\n    }\n  }\n}\n\nif err := tx.Commit(); err != nil {\n  log.Fatal(err)\n}\n```", "```\n// transaction_context.go: simple transaction demonstration \n//                         with use of Context\n\n// By default, this creates an InnoDB table.  If you specify a storage\n// engine on the command line, that will be used instead.  Normally,\n// this should be a transaction-safe engine that is supported by your\n// server.  However, you can pass a nontransactional storage engine\n// to verify that rollback doesn't work properly for such engines.\n\n// The script uses a table named \"money\" and drops it if necessary.\n// Change the name if you have a valuable table with that name. :-)\npackage main\n\nimport (\n  \"log\"\n  \"fmt\"\n  \"flag\"\n  \"context\" ![1](Images/1.png)\n  \"database/sql\"\n  \"github.com/svetasmirnova/mysqlcookbook/recipes/lib\"\n)\n\nfunc initTable(ctx context.Context, db *sql.DB, tblEngine string) (error) { ![2](Images/2.png)\n  queries := [4]string {\n    \"DROP TABLE IF EXISTS money\",\n    \"CREATE TABLE money (name CHAR(5), amt INT, PRIMARY KEY(name)) ENGINE = \" + tblEngine,\n    \"INSERT INTO money (name, amt) VALUES('Eve', 10)\",\n    \"INSERT INTO money (name, amt) VALUES('Ida', 0)\",\n  }\n\n  for _, query := range queries {\n    _, err = db.ExecContext(ctx, query) ![3](Images/3.png)\n    if err != nil {\n      fmt.Println(\"Cannot initialize test table\")\n      fmt.Printf(\"Error: %s\\n\", err.Error())\n      return err\n    }\n  }\n\n  return nil\n}\n\nfunc displayTable(ctx context.Context, db *sql.DB) (error) {\n  rows, err := db.QueryContext(ctx, \"SELECT name, amt FROM money\") ![4](Images/4.png)\n  if err != nil {\n    return err\n  }\n  defer rows.Close()\n\n  for rows.Next() {\n    var (\n      name string\n      amt  int32\n    )\n    if err := rows.Scan(&name, &amt); err != nil {\n      fmt.Println(\"Cannot display contents of test table\")\n      fmt.Printf(\"Error: %s\\n\", err.Error())\n      return err\n    }\n\n    fmt.Printf(\"%s has $%d\\n\", name, amt)\n  }\n\n  return nil\n}\n\nfunc runTransaction(ctx context.Context, \n                    db *sql.DB, queries []string) (error) {\n  tx, err := db.BeginTx(ctx, nil) ![5](Images/5.png)\n  if err != nil {\n    return err\n  }\n\n  for _, query := range queries {\n    _, err := tx.ExecContext(ctx, query) ![6](Images/6.png)\n    if err != nil {\n      fmt.Printf(\"Transaction failed, rolling back.\\nError was: %s\\n\",\n                 err.Error())\n      if txerr := tx.Rollback(); err != nil {\n        return txerr\n      }\n      return err\n    }\n  }\n\n  if err := tx.Commit(); err != nil {\n    return err\n  }\n\n  return nil\n}\n\nfunc main() {\n  db, err := cookbook.Connect()\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer db.Close()\n\n  var tblEngine string = \"InnoDB\"\n  flag.Parse()\n  values := flag.Args()\n  if len(values) > 0 {\n    tblEngine = values[0]\n  }\n  fmt.Printf(\"Using storage engine %s to test transactions\\n\", tblEngine)\n\n  ctx, cancel := context.WithCancel(context.Background()) ![7](Images/7.png)\n  defer cancel()\n\n  fmt.Println(\"----------\")\n  fmt.Println(\"This transaction should succeed.\")\n  fmt.Println(\"Table contents before transaction:\")\n\n  if err := initTable(ctx, db, tblEngine); err != nil {\n    log.Fatal(err)\n  }\n\n  if err = displayTable(ctx, db); err != nil {\n    log.Fatal(err)\n  }\n\n  var trx = []string{\n    \"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\",\n    \"UPDATE money SET amt = amt + 6 WHERE name = 'Ida'\",\n  }\n\n  if err = runTransaction(ctx, db, trx); err != nil {\n    log.Fatal(err)\n  }\n\n  fmt.Println(\"Table contents after transaction:\")\n  if err = displayTable(ctx, db); err != nil {\n    log.Fatal(err)\n  }\n\n  fmt.Println(\"----------\")\n  fmt.Println(\"This transaction should fail.\")\n  fmt.Println(\"Table contents before transaction:\")\n\n  if err := initTable(ctx, db, tblEngine); err != nil {\n    log.Fatal(err)\n  }\n\n  if err = displayTable(ctx, db); err != nil {\n    log.Fatal(err)\n  }\n\n  trx = []string{\n    \"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\",\n    \"UPDATE money SET xamt = amt + 6 WHERE name = 'Ida'\",\n  }\n\n  if err = runTransaction(ctx, db, trx); err != nil {\n    log.Fatal(err)\n  }\n\n  fmt.Println(\"Table contents after transaction:\")\n  if err = displayTable(ctx, db); err != nil {\n    log.Fatal(err)\n  }\n}\n```", "```\ntry\n{\n  conn.setAutoCommit (false);\n  Statement s = conn.createStatement ();\n  // move some money from one person to the other\n  s.executeUpdate (\"UPDATE money SET amt = amt - 6 WHERE name = 'Eve'\");\n  s.executeUpdate (\"UPDATE money SET amt = amt + 6 WHERE name = 'Ida'\");\n  s.close ();\n  conn.commit ();\n  conn.setAutoCommit (true);\n}\ncatch (SQLException e)\n{\n  System.err.println (\"Transaction failed, rolling back. Error was:\");\n  Cookbook.printErrorMessage (e);\n  // empty exception handler in case rollback fails\n  try\n  {\n    conn.rollback ();\n    conn.setAutoCommit (true);\n  }\n  catch (Exception e2) { }\n}\n```"]