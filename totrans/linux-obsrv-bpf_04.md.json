["```\nunion bpf_attr {\n  struct {\n    __u32 map_type;     /* one of the values from bpf_map_type */\n    __u32 key_size;     /* size of the keys, in bytes */\n    __u32 value_size;   /* size of the values, in bytes */\n    __u32 max_entries;  /* maximum number of entries in the map */\n    __u32 map_flags;    /* flags to modify how we create the map */\n  };\n}\n```", "```\nunion bpf_attr my_map {\n  .map_type = BPF_MAP_TYPE_HASH,\n  .key_size = sizeof(int),\n  .value_size = sizeof(int),\n  .max_entries = 100,\n  .map_flags = BPF_F_NO_PREALLOC,\n};\n\nint fd = bpf(BPF_MAP_CREATE, &my_map, sizeof(my_map));\n```", "```\nint fd;\nfd = bpf_create_map(BPF_MAP_TYPE_HASH, sizeof(int), sizeof(int), 100,\n    BPF_F_NO_PREALOC);\n```", "```\nstruct bpf_map_def SEC(\"maps\") my_map = {\n      .type        = BPF_MAP_TYPE_HASH,\n      .key_size    = sizeof(int),\n      .value_size  = sizeof(int),\n      .max_entries = 100,\n      .map_flags   = BPF_F_NO_PREALLOC,\n};\n```", "```\nfd = map_data[0].fd;\n```", "```\nint key, value, result;\nkey = 1, value = 1234;\n\nresult = bpf_map_update_elem(&my_map, &key, &value, BPF_ANY);\nif (result == 0)\n  printf(\"Map updated with new element\\n\");\nelse\n  printf(\"Failed to update map with new value: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint key, value, result;\nkey = 1, value = 5678;\n\nresult = bpf_map_update_elem(&my_map, &key, &value, BPF_NOEXIST);\nif (result == 0)\n  printf(\"Map updated with new element\\n\");\nelse\n  printf(\"Failed to update map with new value: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint key, value, result;\nkey = 1234, value = 5678;\n\nresult = bpf_map_update_elem(&my_map, &key, &value, BPF_EXIST);\nif (result == 0)\n  printf(\"Map updated with new element\\n\");\nelse\n  printf(\"Failed to update map with new value: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint key, value, result;\nkey = 1, value = 1234;\n\nresult = bpf_map_update_elem(map_data[0].fd, &key, &value, BPF_ANY);\nif (result == 0)\n  printf(\"Map updated with new element\\n\");\nelse\n  printf(\"Failed to update map with new value: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint key, value, result; // value is going to store the expected element's value\nkey = 1;\n\nresult = bpf_map_lookup_elem(&my_map, &key, &value);\nif (result == 0)\n  printf(\"Value read from the map: '%d'\\n\", value);\nelse\n  printf(\"Failed to read value from the map: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint key, value, result; // value is going to store the expected element's value\nkey = 1;\n\nresult = bpf_map_lookup_elem(map_data[0].fd, &key, &value);\nif (result == 0)\n  printf(\"Value read from the map: '%d'\\n\", value);\nelse\n  printf(\"Failed to read value from the map: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint key, result;\nkey = 1;\n\nresult = bpf_map_delete_element(&my_map, &key);\nif (result == 0)\n  printf(\"Element deleted from the map\\n\");\nelse\n  printf(\"Failed to delete element from the map: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint key, result;\nkey = 1;\n\nresult = bpf_map_delete_element(map_data[0].fd, &key);\nif (result == 0)\n  printf(\"Element deleted from the map\\n\");\nelse\n  printf(\"Failed to delete element from the map: %d (%s)\\n\",\n      result, strerror(errno));\n```", "```\nint new_key, new_value, it;\n\nfor (it = 2; it < 6 ; it++) {\n  new_key = it;\n  new_value = 1234 + it;\n  bpf_map_update_elem(map_data[0].fd, &new_key, &new_value, BPF_NOEXIST);\n}\n```", "```\nint next_key, lookup_key;\nlookup_key = -1;\n\nwhile(bpf_map_get_next_key(map_data[0].fd, &lookup_key, &next_key) == 0) {\n  printf(\"The next key in the map is: '%d'\\n\", next_key);\n  lookup_key = next_key;\n}\n```", "```\nThe next key in the map is: '1'\nThe next key in the map is: '2'\nThe next key in the map is: '3'\nThe next key in the map is: '4'\nThe next key in the map is: '5'\n```", "```\nint next_key, lookup_key;\nlookup_key = -1;\n\nwhile(bpf_map_get_next_key(map_data[0].fd, &lookup_key, &next_key) == 0) {\n  printf(\"The next key in the map is: '%d'\\n\", next_key);\n  if (next_key == 2) {\n    printf(\"Deleting key '2'\\n\");\n    bpf_map_delete_element(map_data[0].fd &next_key);\n  }\n  lookup_key = next_key;\n}\n```", "```\nThe next key in the map is: '1'\nThe next key in the map is: '2'\nDeleteing key '2'\nThe next key in the map is: '1'\nThe next key in the map is: '3'\nThe next key in the map is: '4'\nThe next key in the map is: '5'\n```", "```\nint key, value, result, it;\nkey = 1;\n\nfor (it = 0; it < 2; it++) {\n  result = bpf_map_lookup_and_delete_element(map_data[0].fd, &key, &value);\n  if (result == 0)\n    printf(\"Value read from the map: '%d'\\n\", value);\n  else\n    printf(\"Failed to read value from the map: %d (%s)\\n\",\n        result, strerror(errno));\n}\n```", "```\nstruct concurrent_element {\n  struct bpf_spin_lock semaphore;\n  int count;\n}\n```", "```\nstruct bpf_map_def SEC(\"maps\") concurrent_map = {\n      .type        = BPF_MAP_TYPE_HASH,\n      .key_size    = sizeof(int),\n      .value_size  = sizeof(struct concurrent_element),\n      .max_entries = 100,\n};\n\nBPF_ANNOTATE_KV_PAIR(concurrent_map, int, struct concurrent_element);\n```", "```\nint bpf_program(struct pt_regs *ctx) {\n  int key = 0;\n  struct concurrent_element init_value = {};\n  struct concurrent_element *read_value;\n\n  bpf_map_create_elem(&concurrent_map, &key, &init_value, BPF_NOEXIST);\n\n  read_value = bpf_map_lookup_elem(&concurrent_map, &key);\n  bpf_spin_lock(&read_value->semaphore);\n  read_value->count += 100;\n  bpf_spin_unlock(&read_value->semaphore);\n}\n```", "```\n#define IPV4_FAMILY 1\nstruct ip_key {\n  union {\n    __u32 v4_addr;\n    __u8 v6_addr[16];\n  };\n  __u8 family;\n};\n\nstruct bpf_map_def SEC(\"maps\") counters = {\n      .type        = BPF_MAP_TYPE_HASH,\n      .key_size    = sizeof(struct ip_key),\n      .value_size  = sizeof(uint64_t),\n      .max_entries = 100,\n      .map_flags   = BPF_F_NO_PREALLOC\n};\n```", "```\nuint64_t update_counter(uint32_t ipv4) {\n  uint64_t value;\n  struct ip_key key = {};\n  key.v4_addr = ip4;\n  key.family = IPV4_FAMILY;\n\n  bpf_map_lookup_elem(counters, &key, &value);\n  (*value) += 1;\n}\n```", "```\nstruct bpf_map_def SEC(\"maps\") programs = {\n  .type = BPF_MAP_TYPE_PROG_ARRAY,\n  .key_size = 4,\n  .value_size = 4,\n  .max_entries = 1024,\n};\n```", "```\nint key = 1;\nstruct bpf_insn prog[] = {\n  BPF_MOV64_IMM(BPF_REG_0, 0), // assign r0 = 0\n  BPF_EXIT_INSN(),  // return r0\n};\n\nprog_fd = bpf_prog_load(BPF_PROG_TYPE_KPROBE, prog, sizeof(prog), \"GPL\");\nbpf_map_update_elem(&programs, &key, &prog_fd, BPF_ANY);\n```", "```\nSEC(\"kprobe/seccomp_phase1\")\nint bpf_kprobe_program(struct pt_regs *ctx) {\n  int key = 1;\n  /* dispatch into next BPF program */\n  bpf_tail_call(ctx, &programs, &key);\n\n  /* fall through when the program descriptor is not in the map */\n  char fmt[] = \"missing program in prog_array map\\n\";\n  bpf_trace_printk(fmt, sizeof(fmt));\n  return 0;\n}\n```", "```\nstruct data_t {\n  u32 pid;\n  char program_name[16];\n};\n```", "```\nstruct bpf_map_def SEC(\"maps\") events = {\n  .type = BPF_MAP_TYPE_PERF_EVENT_ARRAY,\n  .key_size = sizeof(int),\n  .value_size = sizeof(u32),\n  .max_entries = 2,\n};\n```", "```\nSEC(\"kprobe/sys_exec\")\nint bpf_capture_exec(struct pt_regs *ctx) {\n  data_t data;\n  // bpf_get_current_pid_tgid returns the current process identifier\n  data.pid = bpf_get_current_pid_tgid() >> 32;\n  // bpf_get_current_comm loads the current executable name\n  bpf_get_current_comm(&data.program_name, sizeof(data.program_name));\n  bpf_perf_event_output(ctx, &events, 0, &data, sizeof(data));\n  return 0;\n}\n```", "```\nstruct bpf_map_def SEC(\"maps\") cgroups_map = {\n  .type = BPF_MAP_TYPE_CGROUP_ARRAY,\n  .key_size = sizeof(uint32_t),\n  .value_size = sizeof(uint32_t),\n  .max_entries = 1,\n};\n```", "```\nint cgroup_fd, key = 0;\ncgroup_fd = open(\"/sys/fs/cgroup/cpu/docker/cpu.shares\", O_RDONLY);\n\nbpf_update_elem(&cgroups_map, &key, &cgroup_fd, 0);\n```", "```\nstruct bpf_map_def SEC(\"maps\") routing_map = {\n  .type = BPF_MAP_TYPE_LPM_TRIE,\n  .key_size = 8,\n  .value_size = sizeof(uint64_t),\n  .max_entries = 10000,\n  .map_flags = BPF_F_NO_PREALLOC,\n};\n```", "```\nuint64_t value_1 = 1;\nstruct bpf_lpm_trie_key route_1 = {.data = {192, 168, 0, 0}, .prefixlen = 16};\nuint64_t value_2 = 2;\nstruct bpf_lpm_trie_key route_2 = {.data = {192, 168, 0, 0}, .prefixlen = 24};\nuint64_t value_3 = 3;\nstruct bpf_lpm_trie_key route_3 = {.data = {192, 168, 1, 0}, .prefixlen = 24};\n\nbpf_map_update_elem(&routing_map, &route_1, &value_1, BPF_ANY);\nbpf_map_update_elem(&routing_map, &route_2, &value_2, BPF_ANY);\nbpf_map_update_elem(&routing_map, &route_3, &value_3, BPF_ANY);\n```", "```\nuint64_t result;\nstruct bpf_lpm_trie_key lookup = {.data = {192, 168, 1, 1}, .prefixlen = 32};\n\nint ret = bpf_map_lookup_elem(&routing_map, &lookup, &result);\nif (ret == 0)\n  printf(\"Value read from the map: '%d'\\n\", result);\n```", "```\n struct bpf_map_def SEC(\"maps\") queue_map = {\n   .type = BPF_MAP_TYPE_QUEUE,\n   .key_size = 0,\n   .value_size = sizeof(int),\n   .max_entries = 100,\n   .map_flags = 0,\n };\n```", "```\nint i;\nfor (i = 0; i < 5; i++)\n  bpf_map_update_elem(&queue_map, NULL, &i, BPF_ANY);\n\nint value;\nfor (i = 0; i < 5; i++) {\n  bpf_map_lookup_and_delete(&queue_map, NULL, &value);\n  printf(\"Value read from the map: '%d'\\n\", value);\n}\n```", "```\nValue read from the map: '0'\nValue read from the map: '1'\nValue read from the map: '2'\nValue read from the map: '3'\nValue read from the map: '4'\n```", "```\nstruct bpf_map_def SEC(\"maps\") stack_map = {\n  .type = BPF_MAP_TYPE_STACK,\n  .key_size = 0,\n  .value_size = sizeof(int),\n  .max_entries = 100,\n  .map_flags = 0,\n};\n```", "```\nint i;\nfor (i = 0; i < 5; i++)\n  bpf_map_update_elem(&stack_map, NULL, &i, BPF_ANY);\n\nint value;\nfor (i = 0; i < 5; i++) {\n  bpf_map_lookup_and_delete(&stack_map, NULL, &value);\n  printf(\"Value read from the map: '%d'\\n\", value);\n}\n```", "```\nValue read from the map: '4'\nValue read from the map: '3'\nValue read from the map: '2'\nValue read from the map: '1'\nValue read from the map: '0'\n```", "```\n# mount -t bpf /sys/fs/bpf /sys/fs/bpf\n```", "```\nstatic const char * file_path = \"/sys/fs/bpf/my_array\";\n\nint main(int argc, char **argv) {\n  int key, value, fd, added, pinned;\n\n  fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(int), 100, 0); ![1](assets/1.png)\n  if (fd < 0) {\n    printf(\"Failed to create map: %d (%s)\\n\", fd, strerror(errno));\n    return -1;\n  }\n\n  key = 1, value = 1234;\n  added = bpf_map_update_elem(fd, &key, &value, BPF_ANY);\n  if (added < 0) {\n    printf(\"Failed to update map: %d (%s)\\n\", added, strerror(errno));\n    return -1;\n  }\n\n  pinned = bpf_obj_pin(fd, file_path);\n  if (pinned < 0) {\n    printf(\"Failed to pin map to the file system: %d (%s)\\n\",\n        pinned, strerror(errno));\n    return -1;\n  }\n\n  return 0;\n}\n```", "```\nls -la /sys/fs/bpf\ntotal 0\ndrwxrwxrwt 2 root  root  0 Nov 24 13:56 .\ndrwxr-xr-x 9 root  root  0 Nov 24 09:29 ..\n-rw------- 1 david david 0 Nov 24 13:56 my_map\n```", "```\nstatic const char * file_path = \"/sys/fs/bpf/my_array\";\n\nint main(int argc, char **argv) {\n  int fd, key, value, result;\n\n  fd = bpf_obj_get(file_path);\n  if (fd < 0) {\n    printf(\"Failed to fetch the map: %d (%s)\\n\", fd, strerror(errno));\n    return -1;\n  }\n\n  key = 1;\n  result = bpf_map_lookup_elem(fd, &key, &value);\n  if (result < 0) {\n    printf(\"Failed to read value from the map: %d (%s)\\n\",\n        result, strerror(errno));\n    return -1;\n  }\n\n  printf(\"Value read from the map: '%d'\\n\", value);\n  return 0;\n```"]