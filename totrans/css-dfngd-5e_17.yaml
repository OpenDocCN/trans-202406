- en: Chapter 17\. Transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since the inception of CSS, elements have been rectangular and firmly oriented
    on the horizontal and vertical axes. Several tricks arose to make elements look
    like they were tilted and so on, but underneath it all was a rigid grid.
  prefs: []
  type: TYPE_NORMAL
- en: With CSS *transforms*, you have the ability to break that visual grid and shake
    up the way your elements are presented. Whether it’s as simple as rotating some
    photographs a bit to make them appear more natural, or creating interfaces where
    information can be revealed by flipping over elements, or doing interesting perspective
    tricks with sidebars, CSS transforms can—if you’ll pardon the obvious expression—transform
    the way you design.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before embarking on this journey, let’s take a moment to orient ourselves. Specifically,
    let’s review the *coordinate systems* used to define positions or movement in
    space as a sequence of measurements. Two types of coordinate systems are used
    in transforms, and it’s a good idea to be familiar with both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the *Cartesian coordinate system*, often called the *x/y/z coordinate
    system*. This system describes the position of a point in space by using two numbers
    (for two-dimensional placement) or three numbers (for three-dimensional placement).
    In CSS, the system uses three axes: the x-axis (horizontal); the y-axis (vertical);
    and the z-axis (depth). This is illustrated in [Figure 17-1](#tf_fig01).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1701](assets/css5_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. The three Cartesian axes used in CSS transforms
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For any two-dimensional (2D) transform, you need to worry about only the x-
    and y-axes. By convention, positive x values go to the right, and negative values
    go to the left. Similarly, positive y values go downward along the y-axis, while
    negative values go upward along the y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'That might seem a little weird, since we tend to think that higher numbers
    should place something higher up, not lower down, as many of us learned in pre-algebra.
    (This is why the “y” label is at the bottom of the y-axis in [Figure 17-1](#tf_fig01):
    the labels are placed in the positive direction on all three axes.) If you are
    experienced with absolute positioning in CSS, think of the `top` property values
    for absolutely positioned elements: they get moved downward for positive `top`
    values, and upward when `top` has a negative length.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, in order to move an element leftward and down, you would give it
    a negative x and a positive y value. Here is one way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That is, in fact, a valid transform value, as you’ll see in just a bit. Its
    effect is to translate (move) the element 5 ems to the left and 33 pixels down,
    in that order.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to transform something in three-dimensional (3D) space, you add
    a z-axis value. This axis is the one that “sticks out” of the display and runs
    straight through your head—in a theoretical sense, that is. Positive z values
    are closer to you, and negative z values are farther away from you. In this regard,
    it’s very much like the `z-index` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s say that we want to take the element we moved before and add a z-axis
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now the element will appear 200 pixels closer to us than it would be without
    the z value.
  prefs: []
  type: TYPE_NORMAL
- en: Well, you might wonder exactly how an element can be moved 200 pixels closer
    to you, given that holographic displays are regrettably rare and expensive. How
    many molecules of air between you and your monitor are equivalent to 200 pixels?
    What does an element moving closer to you even look like, and what happens if
    it gets *too* close? These are excellent questions that we’ll get to later. For
    now, just accept that moving an element along the z-axis appears to move it closer
    or farther away.
  prefs: []
  type: TYPE_NORMAL
- en: The really important thing to remember is that every element carries its own
    frame of reference and so considers its axes with respect to itself. If you rotate
    an element, the axes rotate along with it, as illustrated in [Figure 17-2](#tf_fig02).
    Any further transforms are calculated with respect to those rotated axes, not
    the axes of the display.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1702](assets/css5_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. Elemental frames of reference
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, suppose you want to rotate an element 45 degrees clockwise in the plane
    of the display (i.e., around the z-axis). Here’s the transform value you’re most
    likely to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Change that to `–45deg`, and the element will rotate counterclockwise (anticlockwise
    for our international friends) around the z-axis. In other words, it will rotate
    in the *xy* plane, as illustrated in [Figure 17-3](#tf_fig05).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1703](assets/css5_1703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. Rotations in the xy plane
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Speaking of rotations, the other coordinate system used in CSS transforms is
    a *spherical system*, which describes angles in 3D space. It’s illustrated in
    [Figure 17-4](#tf_fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1704](assets/css5_1704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-4\. The spherical coordinate system used in CSS transforms
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the purposes of 2D transforms, you have to worry about only a single 360-degree
    polar system: the one that sits on the plane described by the x- and y-axes. When
    it comes to rotations, a 2D rotation actually describes a rotation around the
    z-axis. Similarly, rotations around the x-axis tilt the element toward or away
    from you, and rotations around the y-axis turn the element from side to side.
    These are illustrated in [Figure 17-5](#tf_fig04).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1705](assets/css5_1705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-5\. Rotations around the three axes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All right, now that we have our bearings, let’s get started with using CSS transforms!
  prefs: []
  type: TYPE_NORMAL
- en: Transforming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One property applies all transforms as a single operation, and a few ancillary
    properties affect exactly how the transforms are applied or allow transforms in
    a single manner. We’ll start with the big cheese.
  prefs: []
  type: TYPE_NORMAL
- en: A <*`transform-list`*> is a space-separated list of functions defining different
    transformations, like the examples used in the preceding section. We’ll dig into
    the specific functions you can use in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: First off, let’s clear up the matter of the bounding box. For any element being
    affected by CSS, the *bounding box* is the border box—the outermost edge of the
    element’s border. Any outlines and margins are ignored for the purposes of calculating
    the bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a table-display element is being transformed, its bounding box is the table
    wrapper box, which encloses the table box and any associated caption box.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re transforming an SVG element with CSS, its bounding box is its SVG-defined
    *object bounding box*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all transformed elements (e.g., elements with `transform` set to a
    value other than `none`) have their own stacking context. (See [“Placement on
    the Z-Axis”](ch10.html#placement-on-the-z-axis) for an explanation.)
  prefs: []
  type: TYPE_NORMAL
- en: 'While a scaled element may be much smaller or larger than it was before the
    transform was applied, the actual space on the page that the element occupies
    remains the same as before the transform was applied. This is true for all the
    transform functions: when you translate or rotate an element, its siblings don’t
    automatically move out of the way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the value entry <*`transform-list`*> requires some explanation. It refers
    to a list of one or more transform functions, one after the other, in space-separated
    format. It looks something like this, with the result shown in [Figure 17-6](#tf_fig06):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1706](assets/css5_1706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-6\. A transformed `<div>` element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The functions are processed one at a time, starting with the first (leftmost)
    and proceeding to the last (rightmost). This first-to-last processing order is
    important, because changing the order can lead to drastically different results.
    Consider the following two rules, which have the results shown in [Figure 17-7](#tf_fig07):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1707](assets/css5_1707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-7\. Different transform lists, different results
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first instance, an image is translated (moved) 200 pixels along its x-axis
    and then rotated 45 degrees. In the second instance, an image is rotated 45 degrees
    and then moved 200 pixels along its x-axis—that’s the x-axis of the transformed
    element, *not* of the parent element, page, or viewport. In other words, when
    an element is rotated, its x-axis (along with its other axes) rotates along with
    it. All element transforms are conducted with respect to the element’s own frame
    of reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when you have a series of transform functions, all of them must be
    properly formatted; that is, they must be valid. If even one function is invalid,
    it renders the entire value invalid. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because the value for `rotate()` is invalid—rotational values must be an <*`angle`*>—the
    entire value is dropped. The image in question will just sit there in its initial
    untransformed state, neither translated nor scaled, let alone rotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, transforms are not usually cumulative. If you apply a transform
    to an element and then later want to add a transformation, you need to restate
    the original transform. Consider the following scenarios, illustrated in [Figure 17-8](#tf_fig08):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1708](assets/css5_1708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-8\. Overwriting or modifying transforms
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first case, the second rule completely replaces the first, meaning that
    the element is scaled only along the y-axis. This makes some sense; it’s the same
    as if you declare a font size and then elsewhere declare a different font size
    for the same element. You don’t get a cumulative font size that way. You just
    get one size or the other. In the second example, the entirety of the first set
    of transforms is included in the second set, so they all are applied along with
    the `scaleY()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re wishing for properties that apply to just a single type of transformation,
    such as a property that only rotates or a property that only scales elements,
    you’ll see some later in the chapter, so hang in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one important caveat: as of this writing, transforms are not applied
    to *atomic inline-level* boxes. These are inline boxes like spans, hyperlinks,
    and so on. Those elements can be transformed if their block-level parent is transformed,
    in which case they go along for the ride. But you can’t just rotate a `<span>`
    unless you’ve changed its display role via `display: block`, `display: inline-block`,
    or something along those lines. The reason for this limitation boils down to an
    uncertainty. Suppose you have a `<span>` (or any inline-level box) that breaks
    across multiple lines. If you rotate it, what happens? Does each line box rotate
    with respect to itself, or should all the line boxes be rotated as a single group?
    There’s no clear answer, and the debate continues, so for now you can’t directly
    transform inline-level boxes.'
  prefs: []
  type: TYPE_NORMAL
- en: The Transform Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS has 21 transform functions, as of early 2023, employing various value patterns
    to get their jobs done. The following is a list of all the available transform
    functions, minus their value patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `translate()` `translate3d()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`translateX()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`translateY()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`translateZ()` | `scale()` `scale3d()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scaleX()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scaleY()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scaleZ()` | `rotate()` `rotate3d()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`rotateX()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`rotateY()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`rotateZ()` | `skew()` `skewX()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`skewY()` | `matrix()` `matrix3d()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`perspective()` |'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll tackle the most common types of transforms first, along with their associated
    properties if they exist, and then deal with the more obscure or difficult ones.
  prefs: []
  type: TYPE_NORMAL
- en: Translation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *translation transform* is just a move along one or more axes. For example,
    `translateX()` moves an element along its own x-axis, `translateY()` moves it
    along its y-axis, and `translateZ()` moves it along its z-axis.
  prefs: []
  type: TYPE_NORMAL
- en: These are usually referred to as the 2D *translation functions*, since they
    can slide an element up and down, or side to side, but not forward or backward
    along the z-axis. Each of these functions accepts a single distance value, expressed
    as either a length or a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: If the value is a length, the effect is about what you’d expect. Translate an
    element 200 pixels along the x-axis with `translateX(200px)`, and it will move
    200 pixels to its right. Change that to `translateX(-200px)`, and the element
    will move 200 pixels to its left. For `translateY()`, positive values move the
    element downward, while negative values move it upward.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that translations are always declared with respect to the element
    itself. Thus, for example, if you flip the element upside down by rotation, positive
    `translateY()` values will move the element downward on the page, because that’s
    a move upward from the upside-down element’s point of view.
  prefs: []
  type: TYPE_NORMAL
- en: If the value is a percentage, the distance is calculated as a percentage of
    the element’s own size. Thus, if an element is 300 pixels wide and 200 pixels
    tall, `translateX(50%)` will move it 150 pixels to its right, and `translateY(-10%)`
    will move that same element upward (with respect to itself) by 20 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to translate an element along both the x- and y-axes at the same
    time, `translate()` makes it easy. Just supply the x value first and the y value
    second, separated by a comma, which is the same as if you included both a `translateX()`
    and a `translateY()`. If you omit the y value, it’s assumed to be 0\. Thus, `translate(2em)`
    is treated as if it were `translate(2em,0)`, which is also the same as `translateX(2em)`.
    See [Figure 17-9](#tf_fig09) for some examples of 2D translation.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1709](assets/css5_1709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-9\. Translating in two dimensions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `translateZ()` function translates elements along the z-axis, thus moving
    them into the third dimension. Unlike the 2D translation functions, `translateZ()`
    accepts only length values. Percentage values are *not* permitted for `translateZ()`,
    or indeed for any z-axis value.
  prefs: []
  type: TYPE_NORMAL
- en: Much like `translate()` does for x and y translations, `translate3d()` is a
    shorthand function that incorporates the x, y, and z translation values into a
    single function. This is handy if you want to move an element over, up, and forward
    in one fell swoop.
  prefs: []
  type: TYPE_NORMAL
- en: See [Figure 17-10](#tf_fig10) for an illustration of how 3D translation works.
    Each arrow represents the translation along that axis, arriving at a point in
    3D space. The dashed lines show the distance and direction from the origin point
    (the intersection of the three axes) and the distance above the x*y* plane.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `translate()`, there is no fallback if `translate3d()` does not contain
    three values. Thus, `translate3d(1em,-50px)` should be treated as invalid by browsers,
    with no actual translation taking place as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1710](assets/css5_1710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-10\. Translating in three dimensions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The translate property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want to translate an element without having to go through the `transform`
    property, you can use the `translate` property instead.
  prefs: []
  type: TYPE_NORMAL
- en: Very much like the `translate()` function, the `translate` property accepts
    from one to three length values, or two percentages and a length value, or more
    reduced patterns such as a single length. Unlike the `translate()` function, the
    `transform` property does not use commas to separate its values.
  prefs: []
  type: TYPE_NORMAL
- en: If only one value is given, it is used as an x-axis translation. With two values,
    the first is the x-axis translation, and the second is the y-axis translation.
    With three values, they are taken in the order `x y z`. Any missing values default
    to `0px`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refer back to [Figure 17-9](#tf_fig09), the following would yield the
    same results as are shown there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the following would have the same effect diagrammed in [Figure 17-10](#tf_fig10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The default value, `none`, means that no translation is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *scale transform* makes an element larger or smaller, depending on the value
    you supply. These values are unitless real numbers, either positive or negative.
    On the 2D plane, you can scale along the x- and y-axes individually or scale them
    together.
  prefs: []
  type: TYPE_NORMAL
- en: A number value supplied to a scale function is a multiplier; thus, `scaleX(2)`
    will make an element twice as wide as it was before the transformation, whereas
    `scaleY(0.5)` will make it half as tall. Percentage values are equivalent to number
    values at a ratio of 100:1; that is, `50%` will have the same effect as `0.5`,
    and `200%` will have the same effect as `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to scale along both axes simultaneously, use `scale()`. The x value
    is always first, and the y always second, so `scale(2,0.5)` will make the element
    twice as wide and half as tall as it was before being transformed. If you supply
    only one number, it is used as the scaling value for both axes; thus, `scale(2)`
    will make the element twice as wide *and* twice as tall. This is in contrast to
    `translate()`, where an omitted second value is always set to 0\. Using `scale(1)`
    will scale an element to be exactly the same size it was before you scaled it,
    as will `scale(1,1)`—just in case you were dying to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-11](#tf_fig11) shows a few examples of element scaling, using the
    single-axis scaling functions as well as the combined `scale()`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you can scale in two dimensions, you can also scale in three. CSS offers
    `scaleZ()` for scaling just along the z-axis, and `scale3d()` for scaling along
    all three axes at once. These have an effect only if the element has any depth,
    which elements don’t by default. If you do make a change that conveys depth—say,
    rotating an element around the x- or y-axis—then there is a depth that can be
    scaled, and either `scaleZ()` or `scale3d()` can do so.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1711](assets/css5_1711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-11\. Scaled elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similar to `translate3d()`, the `scale3d()` function requires all three numbers
    to be valid. If you fail to do this, the malformed `scale3d()` will invalidate
    the entire transform value to which it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that scaling an element will change the effective distance of any
    translations. For example, the following will cause the element to be translated
    50 pixels to its right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is because the element is shrunk by 50%, and then moved to the right by
    100 pixels *within its own frame of reference*, which is half-size. Switch the
    order of the functions, and the element will be translated 100 pixels to its right
    and then shrunk 50% from that spot.
  prefs: []
  type: TYPE_NORMAL
- en: The scale property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also similarly to translation, the `scale` property allows you to scale elements
    up or down without having to use the `transform` property.
  prefs: []
  type: TYPE_NORMAL
- en: The way `scale` handles its values differs little from the `translate` property.
    If you give only one value, such as `scale(2)`, that value is used to scale in
    both the x and y directions. With two values, the first is used to scale in the
    x-axis direction, and the second in the y-axis direction. With three values, the
    third is used to scale in the z-axis direction.
  prefs: []
  type: TYPE_NORMAL
- en: The following would have the same results as shown in [Figure 17-11](#tf_fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The default value, `none`, means that no scaling is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Element Rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *rotation function* causes an element to be rotated around an axis, or around
    an arbitrary vector in 3D space. CSS has four simple rotation functions, and one
    less-simple function meant specifically for 3D.
  prefs: []
  type: TYPE_NORMAL
- en: 'All four basic rotation functions accept just one value: an angle. This can
    be expressed using a number, either positive or negative, and then any of the
    valid angle units (`deg`, `grad`, `rad`, and `turn`). (See [“Angles”](ch05.html#angles)
    for more details.) If a value’s number runs outside the usual range for the given
    unit, it will look as if it were given a value in the allowed range. In other
    words, a value of `437deg` will be tilted the same as if it were `77deg`, or,
    for that matter, `-283deg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that these are visually equivalent only if you don’t animate
    the rotation in some fashion. That is to say, animating a rotation of `1100deg`
    will spin the element around several times before coming to rest at a tilt of
    –20 degrees (or 340 degrees, if you like). By contrast, animating a rotation of
    `-20deg` will tilt the element a bit to the left, with no spinning; and animating
    a rotation of `340deg` will animate an almost full spin to the right. All three
    animations come to the same end state, but the process of getting there is very
    different in each case.
  prefs: []
  type: TYPE_NORMAL
- en: The `rotate()` function is a straight 2D rotation, and the one you’re most likely
    to use. It is visually equivalent to `rotateZ()` because it rotates the element
    around the z-axis. In a similar manner, `rotateX()` causes rotation around the
    x-axis, thus causing the element to tilt toward or away from you; and `rotateY()`
    rotates the element around its y-axis, as though it were a door. These are all
    illustrated in [Figure 17-12](#tf_fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1712](assets/css5_1712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-12\. Rotations around the three axes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Several of the examples in [Figure 17-12](#tf_fig12) present a fully 3D appearance.
    This is possible with certain values of the `transform-style` and `perspective`
    properties, described in [“Choosing a 3D Style”](#choosing-a-3d-style) and [“Changing
    Perspective”](#changing-perspective) and omitted here for clarity. This will be
    true throughout this text anytime 3D-transformed elements appear to be fully three-dimensional.
    This is important to keep in mind because if you just try to apply the transform
    functions shown, you won’t get the same visual results as in the figures.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re comfortable with vectors and want to rotate an element through 3D
    space, `rotate3d()` is for you. The first three numbers specify the x, y, and
    z components of a vector in 3D space, and the degree value (angle) determines
    the amount of rotation around the declared 3D vector.
  prefs: []
  type: TYPE_NORMAL
- en: To start with a basic example, the 3D equivalent of `rotateZ(45deg)` is `rotate3d(0,0,1,45deg)`.
    This specifies a vector of zero magnitude on the x- and y-axes, and a magnitude
    of 1 along the z-axis; in other words, the z-axis. The element is thus rotated
    45 degrees around that vector, as shown in [Figure 17-13](#tf_fig13). This figure
    also shows the appropriate `rotate3d()` values to rotate an element by 45 degrees
    around the x- and y-axes.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1713](assets/css5_1713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-13\. Rotations around 3D vectors
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A little more complicated is something like `rotate3d(-0.95,0.5,1,45deg)`,
    where the described vector points off into 3D space between the axes. To understand
    how this works, let’s start with a basic example: `rotateZ(45deg)` (illustrated
    in [Figure 17-13](#tf_fig13)). The equivalent is `rotate3d(0,0,1,45deg)`. The
    first three numbers describe the components of a vector that has no x or y magnitude,
    and a z magnitude of 1\. Thus, it points along the z-axis in a positive direction—that
    is, toward the viewer. The element is then rotated clockwise as you look toward
    the origin of the vector.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the 3D equivalent of `rotateX(45deg)` is `rotate3d(1,0,0,45deg)`.
    The vector points along the x-axis in the positive direction (to the right). If
    you stand at the end of that vector and look toward its origin, you rotate the
    element 45 degrees clockwise around the vector. Thus, from the usual viewer placement,
    the top of the element rotates away from, and the bottom rotates toward, the viewer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make the example slightly more complex: suppose you have `rotate3d(1,1,0,45deg)`.
    When viewed on your monitor, that describes a vector running from the top-left
    to bottom-right corner, going right through the center of the element (by default,
    anyway; we’ll see how to change that later). So the element’s rectangle has a
    line running through it at a 45-degree angle, effectively spearing it. Then the
    vector rotates 45 degrees, taking the element with it. The rotation is clockwise
    as you look back toward the vector’s origin, so again, the top of the element
    rotates away from the viewer, while the bottom rotates toward the viewer. If we
    were to change the rotation to `rotate3d(1,1,0,90deg)`, the element would be edge-on
    to the viewer, tilted at a 45-degree angle and facing off toward the upper right.
    Try it with a piece of paper: draw a line from the top left to bottom right, and
    then rotate the paper around that line.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, so given all of that, now try visualizing how the vector is determined for
    `rotate3d(-0.95,0.5,1,45deg)`. If we assume a cube 200 pixels on a side, the vector’s
    components are 190 pixels to the *left* along the x-axis, 100 pixels down along
    the y-axis, and 200 pixels toward the views along the z-axis. The vector goes
    from the origin point (0, 0, 0) to the point (–190 px, 100 px, 200 px). [Figure 17-14](#tf_fig14)
    depicts that vector, as well as the final result presented to the viewer.
  prefs: []
  type: TYPE_NORMAL
- en: So the vector is like a metal rod speared through the element being rotated.
    As we look back along the line of the vector, the rotation is 45 degrees clockwise.
    But since the vector points left, down, and forward, that means the top-left corner
    of the element rotates toward the viewer, and the bottom right rotates away, as
    shown in [Figure 17-14](#tf_fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1714](assets/css5_1714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-14\. Rotation around a 3D vector, and how that vector is determined
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just to be crystal clear, `rotate3d(1,1,0,45deg)` is *not* equivalent to `rotateX(45deg)
    rotateY(45deg) rotateZ(0deg)`! It’s an easy mistake to make, and many people—including
    your humble correspondent—have made it. It seems like it should be equivalent,
    but it really isn’t. If we place that vector inside the imaginary 200 × 200 ×
    200 cube previously mentioned, the axis of rotation would go from the origin point
    to a point 200 pixels right and 200 pixels down (200, 200, 0).
  prefs: []
  type: TYPE_NORMAL
- en: Having done that, the axis of rotation is shooting through the element from
    the top left to the bottom right, at a 45-degree angle. The element then rotates
    45 degrees clockwise around that diagonal, as you look back toward its origin
    (the top left), which rotates the top-right corner of the element away and a bit
    to the left, while the bottom-left corner rotates closer and a bit to the right.
    This is distinctly different from the result of `rotateX(45deg) rotateY(45deg)
    rotateZ(0deg)`, as you can see in [Figure 17-15](#tf_fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1715](assets/css5_1715.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-15\. The difference between rotating around a 3D axis and rotating
    in sequence around three different axes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The rotate property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with translations and scaling, CSS has a `rotate` property that allows you
    to rotate elements around various axes without having to use the `transform` property
    to do so. The value syntax to make that possible is a bit different, however.
  prefs: []
  type: TYPE_NORMAL
- en: The valid values are divided into three mutually exclusive syntax options. The
    simplest is that the default value of `none` means no rotation is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to rotate around a single axis, it’s easiest to give the axis identifier
    along with the angle you want to rotate. In the following code, each line contains
    two equivalent ways of rotating an element around a given axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is similar to the handling of the `rotate()` function discussed
    earlier: a rotation with a single degree value is a 2D rotation on the *xy* plane.
    (See [Figure 17-12](#tf_fig12) for a refresher.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to define a 3D vector as the axis of rotation, the value of `rotate`
    looks a little different. For example, suppose we want to rotate an element 45
    degrees around the vector –0.95, 0.5, 1, as illustrated in [Figure 17-14](#tf_fig14).
    Either of the following two declarations will have this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want, you can use this pattern to rotate around the cardinal axes; that
    is, `rotate: z 23deg` and `rotate: 0 0 1 23deg` will have that same effect (as
    will `rotate: 23deg`). This can be useful when changing the vector of rotation
    via JavaScript, but is rarely useful in other cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `transform` has a power that `rotate` cannot duplicate: the ability
    to chain rotations in sequence. For example, `transform: rotateZ(20deg) rotateY(30deg)`
    will first rotate the element 20 degrees around the z-axis, and then the result
    of that rotation is rotated around the y-axis. The `rotate` property can do only
    one or the other of these on its own. The only way to get the same result is to
    figure out the vector and angle that will leave the element in the same state
    as the `transform` operation did. The math to do that certainly exists, but is
    outside the scope of this book (although see [“Matrix Functions”](#matrix_functions)).'
  prefs: []
  type: TYPE_NORMAL
- en: Individual Transform Property Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the individual transform properties, the effects are always applied
    in the order `translate`, then `rotate`, then `scale`. The following two rules
    are functionally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This matters because, for example, translating and then rotating is very different
    from rotating and then translating. If you need to have an element’s transforms
    happen in an order other than transform-rotate-scale, use `transform` instead
    of the individual properties.
  prefs: []
  type: TYPE_NORMAL
- en: Skewing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you *skew* an element, you slant it along one or both of the x- and y-axes.
    There is no z-axis or 3D skewing.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, you supply an angle value, and the element is skewed to match
    that angle. It’s much easier to show skewing rather than try to explain it in
    words, so [Figure 17-16](#tf_fig16) shows skew examples along the x- and y-axes.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1716](assets/css5_1716.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-16\. Skewing along the x- and y-axes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using `skew(a,b)` is different from including `skewX(a)` with `skewY(b)`. The
    former specifies a 2D skew using the matrix operation `[ax,ay]`. [Figure 17-17](#tf_fig17)
    shows examples of this matrix skewing and how they differ from double-skew transforms
    that look the same at first but aren’t.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For a variety of reasons, including the way `skew(a,b)` is different from `skewX(a)
    skewY(b)`, the CSS specification explicitly discourages the use of `skew()`. You
    should avoid using it if at all possible; we document it here in case you find
    yourself coming across it in legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1717](assets/css5_1717.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-17\. Skewed elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you supply two values, the x skew angle is always first, and the y skew angle
    comes second. If you leave out a y skew angle, it’s treated as 0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike for translation, rotation, and scaling, CSS has no `skew` property as
    of late 2022, so any skewing has to be managed via the `transform` property.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re a particular fan of advanced math, or stale jokes derived from the
    Wachowski siblings’ movies, the matrix functions will be your favorites. CSS has
    no `matrix` properties, to be clear.
  prefs: []
  type: TYPE_NORMAL
- en: In the CSS transforms specification, we find the trenchant description of `matrix()`
    as a function that “specifies a 2D transformation in the form of a transformation
    matrix of the six values *a*–*f*.”
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: a valid `matrix()` value is a list of six comma-separated
    numbers. No more, no less. The values can be positive or negative. Second, the
    value describes the final transformed state of the element, combining all of the
    other transform types (rotation, skewing, and so on) into a compact syntax. Third,
    very few people use this syntax to write code themselves, though it is often generated
    by drawing or animation software.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not going to go through the complicated process of doing the matrix math.
    For most readers, it would be an eye-watering wall of apparent gibberish; for
    the rest, it would be time wasted on familiar territory. You can certainly research
    the intricacies of matrix calculations online, and we encourage anyone with an
    interest to do so. We’ll just look at the basics of syntax and usage in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief rundown of how it works. Say you have this function applied
    to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s the CSS syntax used to describe this transformation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Right. So what does that do? It has the result shown in [Figure 17-18](#tf_fig20),
    which is exactly the same result as writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1718](assets/css5_1718.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-18\. A matrix-transformed element and its functional equivalent
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What this comes down to is that if you’re familiar with or need to use matrix
    calculations, you can and should. Otherwise, you can chain much more human-readable
    transform functions together and get the element to the same end state.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that was for plain old 2D transforms. What if you want to use a matrix
    to transform through three dimensions?
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, just for kicks, we’ll savor the definition of `matrix3d()` from the
    CSS Transforms specification: “specifies a 3D transformation as a 4 × 4 homogeneous
    matrix of 16 values in column-major order.” This means the parameter of `matrix3d()`
    *must* be a list of 16 comma-separated numbers, no more or less. Those numbers
    are arranged in a 4 × 4 grid in column order, so the first column of the matrix
    is formed by the first set of four numbers in the value, the second column by
    the second set of four numbers, the third column by the third set, and so on.
    Thus, you can take the following function,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'and write it out as this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Both have an end state equivalent to the following, which is depicted in [Figure 17-19](#tf_fig21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1719](assets/css5_1719.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-19\. A `matrix3d()`-transformed element and its functional equivalent
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A note on end-state equivalence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s important to keep in mind that only the end states of a `matrix()` function,
    and of an equivalent chain of transform functions, can be considered identical.
    This is for the same reason discussed in [“Element Rotation”](#element_rotation):
    because a rotation angle of `393deg` will end with the same visible rotation as
    an angle of `33deg`. This matters if you are animating the transformation, since
    the former will cause the element to do a barrel roll in the animation, whereas
    the latter will not. The `matrix()` version of this end state won’t include the
    barrel roll, either. Instead, it will always use the shortest possible rotation
    to reach the end state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate what this means, consider the following, a transform chain and
    its `matrix()` equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the rotation of 200 degrees. We naturally interpret this to mean a clockwise
    rotation of 200 degrees, which it is. If these two transforms are animated, however,
    they will act differently: the chained-functions version will indeed rotate 200
    degrees clockwise, whereas the `matrix()` version will rotate 160 degrees counterclockwise.
    Both will end up in the same place but will get there in different ways.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other differences can arise even when you might think they wouldn’t. Once again,
    this is because a `matrix()` transformation will always take the shortest possible
    route to the end state, whereas a transform chain might not. (In fact, it probably
    doesn’t.) Consider these apparently equivalent transforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As ever, they end up in the same place. When animated, though, the elements
    will take different paths to reach that end state. They might not be obviously
    different at first glance, but the difference is still there.
  prefs: []
  type: TYPE_NORMAL
- en: None of this matters if you aren’t animating the transformation, but it’s an
    important distinction to make nevertheless, because you never know when you’ll
    decide to start animating things. (Hopefully after reading Chapters [18](ch18.html#x-transitions)
    and [19](ch19.html#animation)!)
  prefs: []
  type: TYPE_NORMAL
- en: Setting Element Perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re transforming an element in 3D space, you most likely want it to have
    some perspective. *Perspective* gives the appearance of front-to-back depth, and
    you can vary the degree of perspective applied to an element.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem a bit weird to specify perspective as a distance. After all, `perspective(200px)`
    seems odd when you can’t really measure pixels along the z-axis. And yet, here
    we are. You supply a length, and the illusion of depth is constructed around that
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Smaller numbers create a more extreme perspective, as though you are up close
    to the element. Higher numbers create a gentler perspective, as though viewing
    the element through a zoom lens from far away. *Really* high perspective values
    create an isometric effect, which looks the same as no perspective at all.
  prefs: []
  type: TYPE_NORMAL
- en: This makes a certain amount of sense. You can visualize perspective as a pyramid,
    with its apex point at the perspective origin (by default, the center of the untransformed
    element’s position) and its base as the browser window that you’re looking through.
    A shorter distance between apex and base will create a shallower pyramid, and
    thus a more extreme distortion. This is illustrated in [Figure 17-20](#tf_fig18),
    with hypothetical pyramids representing 200-pixel, 800-pixel, and 2,000-pixel
    perspective distances.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1720](assets/css5_1720.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-20\. Different perspective pyramids
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [documentation for Safari](https://developer.apple.com/library/archive/documentation/InternetWeb/Conceptual/SafariVisualEffectsProgGuide/Using2Dand3DTransforms/Using2Dand3DTransforms.html),
    Apple writes that perspective values below `300px` tend to be extremely distorted,
    values above `2000px` create “very mild” distortion, and values between `500px`
    and `1000px` create “moderate perspective.” To illustrate this, [Figure 17-21](#tf_fig19)
    shows a series of elements with the exact same rotation as displayed with varying
    perspective values.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1721](assets/css5_1721.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-21\. The effects of varying perspective values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Perspective values must always be positive, nonzero lengths. Any other value
    will cause the `perspective()` function to be ignored. Also note that its placement
    in the list of functions is important. If you look at the code for [Figure 17-21](#tf_fig19),
    the `perspective()` function comes before the `rotateY()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you were to reverse the order, the rotation would happen before the perspective
    is applied, so all four examples in [Figure 17-21](#tf_fig19) would look exactly
    the same. So if you plan to apply a perspective value via the list of transform
    functions, make sure it comes first, or at the very least before any transforms
    that depend on it. This serves as a stark reminder that the order in which you
    write `transform` functions can be very important.
  prefs: []
  type: TYPE_NORMAL
- en: More Transform Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the base `transform` property and the standalone transform properties
    like `rotate`, a few related properties help to define how the elements transform
    the origin point of a transform, the perspective used for a “scene,” and more.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the Transform’s Origin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, all of our transforms have shared one thing in common: we’ve used the
    precise center of the element as the *transform origin*. For example, when rotating
    the element, it rotated around its center, instead of, say, a corner. This is
    the default behavior, but with the property `transform-origin`, you can change
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax definition looks really abstruse and confusing, but it’s fairly
    simple in practice. With `transform-origin`, you supply two or three lengths or
    keywords to define the point around which transforms should be made: first the
    horizontal, then the vertical, and optionally a length along the z-axis. For the
    horizontal and vertical axes, you can use plain-English keywords like `top` and
    `right`, percentages, lengths, or a combination of keywords and percentage or
    length values. For the z-axis, you can’t use plain-English keywords or percentages,
    but can use any length value. Pixels are by far the most common.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Length values are taken as a distance starting from the top-left corner of
    the element. Thus, `transform-origin: 5em 22px` will place the transform origin
    5 ems in from the left side of the element, and 22 pixels down from the top of
    the element. Similarly, `transform-origin: 5em 22px -200px` will place it 5 ems
    over, 22 pixels down, and 200 pixels away (that is, 200 pixels behind the untransformed
    position of the element).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Percentages are calculated with respect to the corresponding axis and size
    of the element’s bounding box, as offsets from the element’s top-left corner.
    For example, `transform-origin: 67% 40%` will place the transform origin 67 percent
    of the width to the right of the element’s left side, and 40 percent of the element’s
    height down from the element’s top side. [Figure 17-22](#tf_fig22) illustrates
    a few origin calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1722](assets/css5_1722.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-22\. Various origin calculations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All right, so if you change the origin, what happens? The easiest way to visualize
    this is with 2D rotations. Suppose you rotate an element 45 degrees to the right.
    Its final placement will depend on its origin. [Figure 17-23](#tf_fig23) illustrates
    the effects of several transform origins; in each case, the transform origin is
    marked with a circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1723](assets/css5_1723.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-23\. Rotational effects using various transform origins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The origin matters for other transform types, such as skews and scales. Scaling
    down an element with its origin in the center will pull in all sides equally,
    whereas scaling down an element with a bottom-right origin will cause it to shrink
    toward that corner. Similarly, skewing an element with respect to its center will
    result in the same shape as if it’s skewed with respect to the top-right corner,
    but the placement of the shape will be different. Some examples are shown in [Figure 17-24](#tf_fig24);
    again, each transform origin is marked with a circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1724](assets/css5_1724.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-24\. Skew and scale effects using various transform origins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The one transform type that isn’t really affected by changing the transform
    origin is translation. If you move an element around with `translate()` or its
    cousins like `translateX()` and `translateY()`, or the `translate` property, the
    element is going to end up in the same place regardless of where the transform’s
    origin is located. If that’s all the transforming you plan to do, setting the
    transform origin is irrelevant. If you ever do anything besides translating, though,
    the origin will matter. Use it wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Transform’s Box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We wrote the previous section as though the transform origin is always calculated
    with respect to the outer border edge, and that is indeed the default in HTML,
    but not always in SVG. You can change this, at least in theory, with the property
    `transform-box`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two of the values are directly related to CSS when styling HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '`border-box`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the element’s border box (defined by the outer border edge) as the reference
    box for transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '`content-box`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the element’s content box as the reference box for transforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining three are designed for SVG purposes, though they can also apply
    in HTML contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fill-box`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the element’s object bounding box as the reference box.
  prefs: []
  type: TYPE_NORMAL
- en: '`stroke-box`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the element’s stroke bounding box as the reference box.
  prefs: []
  type: TYPE_NORMAL
- en: '`view-box`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the element’s nearest SVG viewport as the reference box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `fill-box` in an SVG context causes transforms to be performed on the
    element in question, as we would expect from HTML. The default `view-box`, on
    the other hand, causes all transforms to be calculated with respect to the origin
    of the coordinate system established by the SVG `viewBox` attribute. The difference
    is illustrated in [Figure 17-25](#transform-box-compare), which is the result
    of the following SVG file and the CSS it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1725](assets/css5_1725.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-25\. A square rotated around the SVG origin and its own origin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first square, on the left, is rotated 20 degrees from its starting point,
    with the center of rotation as the top left of the entire SVG file (the top-left
    corner of the dashed-line box). This is because the value of `transform-box` for
    this square is `view-box`. The second square has a `transform-box` of `fill-box`,
    so it uses the top left of its own fill box—what in HTML we would call the background
    area—as the center of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a 3D Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re setting elements to be transformed through three dimensions—using,
    say, `translate3d()` or `rotateY()`—you probably expect that the elements will
    be presented as though they’re in a 3D space. The `transform-style` property helps
    bring that to life.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to move an element “closer” to your eye, and then tilt it
    away a bit, with a moderate amount of perspective. You might use something like
    this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So you do that and get the result shown in [Figure 17-26](#tf_fig25)—more or
    less what you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1726](assets/css5_1726.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-26\. A 3D-transformed inner `<div>`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But then you decide to rotate the outer `<div>` to one side, and suddenly nothing
    makes sense anymore. The inner `<div>` isn’t where you envisioned it. In fact,
    it just looks like a picture pasted to the front of the outer `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that’s exactly what it is, because the default value of `transform-style`
    is `flat`. The inner `div` got drawn in its moved-forward, tilted-back state,
    and that was applied to the front of the outer `<div>` as if it were an image.
    So when you rotated the outer `<div>`, as shown in [Figure 17-27](#tf_fig27),
    the flat picture rotated right along with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the value to `preserve-3d`, however, and the result is very different.
    The inner `div` will be drawn as a full 3D object with respect to its parent outer
    `<div>`, floating in space nearby, and *not* as a picture pasted on the front
    of the outer `<div>`. You can see the results of this change in [Figure 17-27](#tf_fig27):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1727](assets/css5_1727.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-27\. The effects of a flat versus a 3D-preserved transform style
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One important aspect of `transform-style` is that it can be overridden by other
    properties. The reason is that some values of these other properties require a
    flattened presentation of an element and its children in order to work. In such
    cases, the value of `transform-style` is forced to be `flat`, regardless of what
    you may have declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to avoid this overriding behavior, make sure the following properties are
    set to the listed values on any 3D-transformed container elements that also have
    3D-transformed children:'
  prefs: []
  type: TYPE_NORMAL
- en: '`overflow: visible`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: none`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clip: auto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clip-path: none`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mask-image: none`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mask-border-source: none`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mix-blend-mode: normal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isolation: auto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are all the default values for those properties, so as long as you don’t
    try to change any of them for your preserved 3D elements, you’re fine! But if
    you find that editing some CSS suddenly flattens out your lovely 3D transforms,
    one of these properties might be the culprit.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two properties are used to define the way perspective is handled: one to define
    the perspective distance, as with the `perspective()` function discussed in an
    earlier section; and another to define the perspective’s origin point.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a group perspective
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s consider the property `perspective`, which accepts a length that
    defines the depth of the perspective pyramid. At first glance, it looks just like
    the `perspective()` function discussed earlier, but some critical differences
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick example, if you want to create a very deep perspective, one mimicking
    the results you’d get from a zoom lens, you might declare something like `perspective:
    2500px`. For a shallow depth, one that mimics a close-up fish-eye lens effect,
    you might declare `perspective: 200px`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So how does this differ from the `perspective()` function? When you use `perspective()`,
    you’re defining the perspective effect for the element that is given that function.
    So if you write `transform: perspective(800px) rotateY(-50grad);`, you’re applying
    that perspective to each element that has the rule applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `perspective` property, on the other hand, you’re creating a shared
    perspective for all the child elements of the element that received the property.
    Here’s an illustration of the difference, as shown in [Figure 17-28](#tf_fig28):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1728](assets/css5_1728.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-28\. No perspective, individual `perspective()`, and shared `perspective`,
    respectively
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [Figure 17-28](#tf_fig28), we first see a line of images that haven’t been
    transformed. In the second line, each image has been rotated 50 gradians (equivalent
    to 45 degrees) toward us, but each one within its own individual perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third line of images, none has an individual perspective. Instead, all
    are drawn within the perspective defined by `perspective: 800px;` that’s been
    set on the `<div>` that contains them. Since they all operate within a shared
    perspective, they look “correct”—that is, as we would expect if we had three physical
    pictures mounted on a clear sheet of glass and rotated that toward us around its
    center horizontal axis.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the critical difference between `perspective`, the property, and `perspective()`,
    the function. The former creates a 3D space shared by all its children. The latter
    affects only the element to which it’s applied. Another difference is that the
    effect of the `perspective()` function is different depending on when it is called
    in the chain of transforms. The `perspective` property is always applied before
    all other transforms, which is what you normally want to create a 3D effect.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you’re going to use the `perspective` property instead of the
    `perspective()` function. In fact, container `<div>`s (or other elements) are
    a common feature of 3D transforms—the way they used to be for page layout—largely
    to establish a shared perspective. In the previous example, the `<div id="two">`
    is there solely to serve as a perspective container, so to speak. On the other
    hand, we couldn’t have done what we did without it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the perspective’s origin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When transforming elements in three dimensions, a perspective will be used.
    (See `transform-style` and `perspective` in previous sections.) That perspective
    will have an origin, which is also known as the *vanishing point*, and you can
    change its location with the `perspective-origin` property.
  prefs: []
  type: TYPE_NORMAL
- en: With `perspective-origin`, you define the point on which sight lines converge,
    and as with `perspective`, that point is defined relative to a parent container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most 3D transform properties, this is more easily demonstrated than
    described. Consider the following CSS and markup, illustrated in [Figure 17-29](#tf_fig29):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1729](assets/css5_1729.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-29\. A basic “ruler”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have a repeated background image of tick marks on a ruler, with the `<div>`
    that contains them tilted away from us by 60 degrees. All the lines point at a
    common vanishing point, the top center of the container `<div>` (because of the
    `50% 0%` value for `perspective-origin`).
  prefs: []
  type: TYPE_NORMAL
- en: Now consider that same setup with various perspective origins ([Figure 17-30](#tf_fig30)).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1730](assets/css5_1730.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-30\. A basic “ruler” with different perspective origins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, moving the perspective origin changes the rendering of the 3D-transformed
    element. Note that these have an effect only because we supplied a value for `perspective`.
    If the value of `perspective` is ever the default `none`, any value given for
    `perspective-origin` will be ignored. That makes sense, since you can’t have a
    perspective origin when there’s no perspective at all!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Backfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over all the years you’ve been laying out elements, you’ve probably never thought,
    “What would it look like if we could see the back side of the element?” With 3D
    transforms, if there comes a day when you *do* see the back side of an element,
    CSS has you covered. What happens is determined by the property `backface-visibility`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many of the other properties and functions we’ve already talked about,
    this one is pretty uncomplicated. All it does is determine whether the back side
    of an element is rendered when it’s facing toward the viewer, or not. That’s it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s say you flip over two elements, one with `backface-visibility` set
    to the default value of `visible` and the other set to `hidden`. You get the result
    shown in [Figure 17-31](#tf_fig31):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1731](assets/css5_1731.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-31\. Visible and hidden backfaces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, the first image is unchanged. The second is flipped over its
    x-axis, so we see it from the back. The third has also been flipped, but we can’t
    see it at all because its backface has been hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property can come in handy in several situations. In the simplest, you
    have two elements that represent the two sides of a UI element that flips over—say,
    a search area with preference settings on its back, or a photo with some information
    on the back. Let’s take the latter case. The CSS and markup might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: (This would be a lot more interesting with an animated rotation, causing the
    card to flip over in 3D space.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A variant of this example uses the same markup, but slightly different CSS
    to show the image’s backface when it’s flipped over. This is probably more what
    was intended, since it makes information look like it’s literally written on the
    back of the image. It leads to the end result shown in [Figure 17-32](#tf_fig32):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1732](assets/css5_1732.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-32\. Photo on the front, information on the back
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'All we had to do to make that happen was shift `backface-visibility: hidden`
    to the `<div>` instead of applying it to both the `<img>` and the `<div>`. Thus,
    the `<div>`’s backface is hidden when it’s flipped over, but that of the image
    is not. (Well, that and use a semitransparent background so we could see both
    the text and the flipped image underneath it.)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the ability to transform elements in two- and three-dimensional space,
    CSS transforms provide a great deal of power to designers. From creating interesting
    combinations of 2D transforms, to creating a fully 3D-acting interface, transforms
    open up a great deal of new territory in the design space. Some dependencies exist
    between properties, which is something that not every CSS author will find natural
    at first, but they become second nature with practice.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things authors often do with transforms is animate them, so that
    a card flips over, an element scales and rotates smoothly, and so on. In the next
    two chapters, we’ll get into the details of how those transitions and animations
    are defined.
  prefs: []
  type: TYPE_NORMAL
