- en: Chapter 9\. React Server Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we dove into the world of React frameworks, particularly
    focusing on Next.js and Remix. We explored the reasons why you might choose to
    use a framework in the first place, including the benefits of abstraction, the
    conventions that speed up development, the comprehensive solutions they offer
    for common problems, and their overall impact on enhancing productivity.
  prefs: []
  type: TYPE_NORMAL
- en: We delved into the details of Remix and Next.js, demonstrating the common approaches
    each framework takes to solve similar problems by implementing our own bare-bones
    framework, and teased Next.js’ server-first direction, fully embracing React Server
    Components (RSCs).
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of RSCs, they are an interesting trend in the React ecosystem designed
    to improve the performance, efficiency, and user experience of React applications.
    This advanced application architecture combines the best aspects of server rendered
    multipage apps (MPAs) and client-rendered SPAs, delivering a seamless user experience
    without compromising on performance or maintainability. In this chapter, we will
    discuss the core concepts, benefits, and underlying mental models and mechanisms
    around which RSCs work. For the latest information, always visit [react.dev](https://react.dev).
  prefs: []
  type: TYPE_NORMAL
- en: RSCs introduce a new type of component that “runs” on the server and is otherwise
    excluded from the client-side JavaScript bundle. These components can run during
    build time, allowing you to read from the filesystem, fetch static content, or
    access your data layer. By passing data as props from server components to interactive
    client components in the browser, RSCs maintain a highly efficient and performant
    application.
  prefs: []
  type: TYPE_NORMAL
- en: How then do server components work? Let’s dive a little deeper into what server
    components are to understand this with a little more fidelity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As just described, a server component is a special type of component that is
    executed on the server alone. To understand this better, let’s remember that a
    React component is nothing more than a function that returns a React element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `Component` is a function that returns `<div>hi!</div>`. Of
    course, `<div>hi!</div>` returns another React element since `<` in React is an
    alias for `React.createElement`. We covered this in [Chapter 2](ch02.html#ch02)
    on JSX. In case you’re drawing blanks here, now’s a good time to quickly refresh
    that information and come back. Ultimately, all components return React elements,
    which is virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Server components are no different. If `Component` is executed either on the
    server or the client, it returns vDOM. In [Chapter 3](ch03.html#ch03), we saw
    how React elements are just JavaScript objects that have the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Invoking our `Component` function in both client and server environments will
    return a React element, as shown.
  prefs: []
  type: TYPE_NORMAL
- en: With server components, they are *only* invoked (or called) on the server, and
    the resulting JavaScript object representing an element is sent over the network
    to a client. Of course, client components are the regular React components we’re
    used to.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding this, we start to see some of the benefits of server components:'
  prefs: []
  type: TYPE_NORMAL
- en: They execute only on the server side, on machines whose computational power
    *we* control. This leads to more predictable performance, as we don’t do computations
    on unpredictable client devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They execute in our secure server environments, so we can do secure operations
    in server components without worrying about leaking tokens and other secure information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server components can be asynchronous since we can wait for them to complete
    executing on our servers before we share them with clients over the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the true power of server components. Going forward, let’s explore how
    server components interplay with server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Server Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered server rendering at length in prior chapters, so we won’t go too
    far into its details here. Instead, we’ll focus specifically on the interplay
    between server components and server rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, server components and server rendering can be thought of as two
    separate independent processes where one process solely takes care of rendering
    components on the server and generating a tree of React elements, and another
    process—the server renderer—further takes this tree of React elements and converts
    it into markup that can be streamed to clients over the network.
  prefs: []
  type: TYPE_NORMAL
- en: If we consider these two processes, one to render components to React elements,
    and another to render React elements to HTML strings or streams, we start understanding
    how these two concepts fit together. Let’s call the first process the *RSCs renderer*
    that turns server components into a tree of React elements, and the second process
    the *server renderer* that turns the React elements into a stream of HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this understanding, the interplay between server components and server
    rendering can be understood as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the server, a tree of JSX is turned into a tree of elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This tree of JSX:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Becomes this tree of elements:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the server, this tree of elements is then further serialized into a string
    or stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is sent to a client as a big stringified JSON object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React on the client side can read this parsed JSON and render it as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we illustrate this as code from the server side, it would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This server code snippet is taken directly from [Chapter 6](ch06.html#ch06)
    where we discussed server-side React, except we’ve added a step to process server
    components before passing them to the server-side renderer—the second process
    in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically, this is exactly how server components and server-side rendering
    fit together: they are complementary processes.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, it’s worth noting that we’re using `renderToString` just for illustrative
    purposes and—as mentioned in [Chapter 6](ch06.html#ch06)—it’s almost always better
    to lean on a more asynchronous, interruptible API like `renderToPipeableStream`
    or similar for the vast majority of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the interplay between server rendering and server components,
    let’s dive a little bit deeper into this magical `turnServerComponentsIntoTree​OfElements`
    function we invoked in the previous code snippet. What is it doing? How does it
    turn server components into a tree of elements? Is it a React renderer? Let’s
    find out.
  prefs: []
  type: TYPE_NORMAL
- en: Under the Hood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The short and potentially oversimplified answer is yes, `turnServerComponentsIntoTreeOfElements`
    is a kind of React renderer. It recursively goes into a React tree, starting from
    a high level like `<App />`, and recursively calls each component to get the React
    element (the plain JavaScript object) it returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s lay out a reference implementation of this and then discuss what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While this snippet can look a little scary, let’s be clear: it’s just a big
    `if/else` tree that returns things based on its arguments. Let’s go branch by
    branch and understand what happens, starting with its input argument `jsx`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first branch, if we consider a React element like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The child `"hi!"` is just a string. If we pass this string to our server component
    renderer, we want to return the string as is. The idea is to return types of things
    that React on the client side and on the server side can understand. React can
    understand and render strings, numbers, and booleans on the client and on the
    server side, so we’ll leave them as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, if we’ve got an array, let’s map over it and recursively process each
    element through our function. Arrays can be a bunch of children, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Fragments, for example, represent children as arrays. So similarly, let’s just
    process them by recursively calling our function on each child and move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is where it gets really interesting: we process objects. Let’s keep in
    mind that all React elements are objects, but not all objects are React elements.
    How do we know an object is a React element? It has a `$$typeOf` property with
    a symbol value—specifically `Symbol.for(''react.element'')`. Therefore, we check
    if the object has this key/value pair, and if it does, we process it as a React
    element. We do it in this section from the snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Nested within the truthy branch of the `if` statement, we do another check:
    is the `jsx.type` a `"string"` or a `"function"`? We do this because React elements
    can have both as a type. Strings are used for built-in DOM elements like `"div"`,
    `"span"`, etc. Functions are used for custom components like `<Footer />`. If
    it’s a string, we know it’s a built-in DOM element, so we can just return it as
    is, but recursively call our function on its props—since its props can have children
    that are concurrent React components. If it’s a function, we know it’s a custom
    component, so we call it with its props and recursively call our function on the
    JSX it returns until it finally returns a string, number, boolean, array of those
    types, or a React element with a string type, which would fall into the other
    branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the `await` before we call the function component? Since this is executed
    on the server side, we can `await` the function component in case it’s a server
    component! This is the magic of server components: we can `await` them on the
    server side, and they’ll return a React element that we can then pass to `renderToString`
    or `renderToPipeableStream` to render it to a string or a stream of strings that
    we can send to the client. Indeed, this is what our function is doing: it’s just
    `await`ing all the `async` things recursively to produce a tree of elements (a
    JavaScript object) with all of its data dependencies resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the object is not a React element, we know it’s just a regular object,
    so we recursively call our function on each value in the object and return the
    result. The object is usually just props, so in the `else` branch, we’re just
    recursively calling our function on each prop value and return the result, effectively
    unwrapping any components that might be passed as props using patterns like render
    props, as discussed in [Chapter 5](ch05.html#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! That’s our little minimal RSCs renderer. It’s not perfect, but it’s
    a good start. We can use it to render our server components to React elements
    that we can then send to clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have that, we just pass it to `renderToString` or `renderToPipeableStream`,
    or even serialize it and send it directly to a browser, and React on the client
    side will be able to render it because it’s literally just a tree of React elements
    that React can understand. There is, however, one more challenge to doing this
    that we need to address: serialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Things get a little tricky when we try to serialize React elements. Serializing
    React elements is a fundamental aspect of ensuring that your application is rendered
    correctly and efficiently during the initial load, because the same rendered output
    from the server needs to match the client for React to correctly reconcile and
    diff things. When your application is being rendered on the server, the React
    elements created need to be turned into HTML strings that can be sent to the browser.
    This process of turning React elements into strings is referred to as *serialization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a typical React application, React elements are objects in memory. They’re
    created by invoking `React.createElement` or using JSX syntax. These elements
    represent the intended rendering of a component, but they are not yet actual DOM
    elements. They’re more like instructions for how the DOM should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendering on the server using a function like `ReactDOMServer.renderToString`,
    these React elements are serialized into HTML strings. This serialization process
    traverses the React element tree, generates the corresponding HTML for each element,
    and concatenates it all into a single HTML string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This HTML string can then be sent to the client, where it will be used as the
    initial markup for the page. Once the JavaScript bundle is loaded on the client,
    React will “hydrate” the DOM, attaching event handlers and filling in any dynamic
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The serialization step is crucial for several reasons. First, it allows the
    server to send a complete, ready-to-display HTML page to the client as quickly
    as possible. This improves the perceived load time of the page, as users can start
    interacting with the content sooner.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, serializing React elements into an HTML string allows for a consistent
    and predictable initial render, irrespective of the environment. The HTML produced
    is static and will look the same whether rendered on the server or the client.
    This consistency is essential for ensuring a smooth user experience, as it prevents
    any flickering or layout shifts that might occur if the initial render were different
    from the final render.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, serialization facilitates the process of hydration on the client side.
    When the JavaScript bundle loads on the client, React needs to attach event handlers
    and fill in any dynamic content. Having a serialized HTML string as the initial
    markup ensures that React has a solid base to work from, making the rehydration
    process more efficient and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we need to serialize components to strings, we can’t just use `JSON.stringify`
    because React elements are not regular JavaScript objects. They’re objects with
    a special `$$typeof` property that React uses to identify them, and the value
    of these properties is a symbol. Symbols cannot be serialized and sent over the
    network, so we need to do something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn’t actually that difficult thanks to built-in support from JavaScript
    runtimes, including the browser and Node.js where our server lives. This built-in
    support comes to us in the form of `JSON.stringify` and `JSON.parse`. These functions
    recursively either serialize or deserialize JSON objects, which React elements
    are. Their API is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'where `replacer` is a function that receives a key and a value, and can return
    a replacement value if certain conditions are met. In our case, we want to replace
    the value of `$$typeof` with a serializable type, like a string. Here’s how we’d
    do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! We’re done. To deserialize this on the client side, we do the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! We can now serialize and deserialize React elements. We can now
    render server components on the server and send them to clients. This handles
    our first load; however, we still need to handle updates and navigation. Let’s
    tackle navigation first and deal with updates later.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we have a link in our RSCs-enabled app, something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'clicking on this would do a full-page navigation, which would cause the browser
    to make a request to the server, which would then render the page and send it
    back to the browser. This is how we used to do things in PHP-land so many years
    ago, and it comes with certain friction and a feeling of slowness. We can do better:
    with RSCs, we can implement soft navigation, where state is persisted between
    route transitions. We do this by sending the server the URL we want to navigate
    to, and the server sends us back the JSX tree for that page. Then, React in the
    browser rerenders the entire page with the new JSX tree, and we have a new page
    without a full-page refresh. This is exactly what we’re going to do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to tweak our client-side code a little bit. We need to
    add an event listener to all links in our app that prevents the default behavior
    of the link, and instead sends a request to the server for the new page. We can
    do that like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re adding the event listener to the `window` because of performance: we
    don’t want to add an event listener to every single link in our app, which could
    be a large number of event listeners that could slow things down. Instead, we
    add one event listener to the `window` and check if the target of the click is
    a link. This is called *event delegation*.'
  prefs: []
  type: TYPE_NORMAL
- en: If the user does click on an `A` element, we then prevent the default behavior
    of the link, and instead call a `navigate` function that we’ll define in a second.
    This function will send a request to the server for the new page, and then we’ll
    have React render it on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the `navigate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'What we’re doing here is pretty straightforward: we’re sending a request to
    the server for the new page, deserializing the response into a React element,
    and then rendering that element into the root of our app. This will cause React
    to rerender the page with the new JSX tree, and we’ll have a new page without
    a full-page refresh. But what is `root`? To understand that, we need to look at
    our full client-side JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We get a root from React when we initially hydrate the page, and we can use
    that root to render new elements into it. This is how React works under the hood,
    and we’re just using the same API that React uses internally. This is a good thing
    because it means we’re not doing anything special or hacky, we’re just using React’s
    public API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to have our server respond with just the JSX tree object for
    the next page when given a `jsx-only` header instead of responding with a full
    HTML string. We can do that like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice how when the header is present, we’re not sending JSON but just a string?
    This is because we need to `JSON.parse` this on the client side, and `JSON.parse`
    expects a string, not a JSON object. This is just a quirk of the API, but it’s
    not too bad.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a way to navigate to new pages without a full-page refresh. We
    can now handle navigation in our RSCs-enabled app. All anchor link navigations
    happen smoothly and fluently without a full-page refresh. But what about updates?
    How do we handle updates? Let’s tackle that next.
  prefs: []
  type: TYPE_NORMAL
- en: Making Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While there are a ton of positives to RSCs, there are also some limitations
    to be aware of, namely the added mental overhead of having to think about two
    different types of components (server and client). This is because not all components
    can be server components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this simple counter component that increments the counter
    value by 1 when a user clicks the + button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This component can never be a server component for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses `useState`, which is a client-side-only API. This means that the server
    doesn’t know what the initial value of `count` is, so it can’t render the initial
    HTML. This is a problem because the server needs to render the initial HTML before
    the client can take over and render the interactive UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a serverful environment, the concept of “state” is shared among multiple
    clients. However, in React, prior to the introduction of RSCs, state was localized
    to the current application. This difference poses a risk. It could lead to the
    leakage of state between multiple clients, potentially exposing sensitive information.
    Due to this discrepancy and the associated security risks, RSCs do not support
    the use of `useState` on the server side. This is because server-side state is
    fundamentally different from client-side state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moreover, the dispatcher (`setState`) function from `useState` would need to
    be serialized to be sent over the network to the client, and functions are not
    serializable, so this would be impossible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It uses `onClick`, which is a client-side-only API. This is because servers
    aren’t interactive: you can’t click on a running process in a server, so `onClick`
    in server components is a bit of an impossible state. Moreover, all props for
    server components are supposed to be serializable because the server needs to
    be able to serialize the props and send them to the client, and functions are
    not serializable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, what used to be a simple counter now needs to be broken apart into
    a server part and a client part *if* we want to harness the power of server components,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit of a contrived example, but it illustrates the point that you
    can’t just take any React component and turn it into a server component. You need
    to think about what parts of your component are server renderable and what parts
    are client renderable. This introduces a bit of friction where even though in
    this example it’s pretty obvious what parts are server renderable and what parts
    are client renderable, in a real-world application at scale, it may not be so
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: The outcome of this, though, is largely rewarding because what we just did was
    factor out a tiny portion of our counter application that is intended to be interactive,
    and *only* this portion of our app will actually make it to our users as part
    of a JavaScript bundle; the rest will not. As a consequence, we ship drastically
    smaller JavaScript bundles over the network, which means faster load times and
    better performance for our users both in terms of CPU, with less work needing
    to be done to parse and execute the JavaScript, and in terms of network, with
    less data needing to be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we want to render *as much as we can safely* on the server to leave
    the code out of client-side bundles.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The extra mental overhead aside, let’s talk about how React delineates and works
    with server components and client components separately under the hood. This is
    important to understand because it will help us understand how to make updates
    to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Client components are designated as such by adding a `"use client"` directive
    at the top of a file containing a client component. RSCs require next-generation
    tooling to differentiate server and client components based on the use of such
    directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the use of a next-generation bundler or bundler configuration, bundlers
    are able to produce separate module graphs for React apps: a server graph and
    a client graph. The server graph is never rolled into a bundle since it’s never
    served to users, but all files that start with the `"use client"` directive are
    rolled into either one client bundle or multiple bundles per component that can
    be lazy loaded. This implementation detail is dependent on the frameworks that
    are built on top of RSCs.'
  prefs: []
  type: TYPE_NORMAL
- en: So conceptually, we’ve got a server graph that executes on the server, and one
    or more client bundles that are downloaded and executed when they’re required
    on the client. But how does React know when to import and execute client components?
    To understand this, we’ll have to consider a typical React tree. Let’s do this
    using our counter example.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 9-1](#figure9-1), we visualize the tree of components for our counter
    application where orange components are rendered on the server, and green ones
    on the client. Since the root of the tree is a server component, the entire tree
    is rendered on the server. However, the `InteractiveClientPart` component is a
    client component, so it’s not rendered on the server. Instead, the server renders
    a placeholder for the client component, which is a reference to the specific module
    that the client bundler produced. This module reference essentially says, “when
    you get to this point in the tree, it’s time to use this specific module.”
  prefs: []
  type: TYPE_NORMAL
- en: '![RSCs and Client Components](assets/frea_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. A component tree showing client and server components
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The module isn’t necessarily always only lazy loaded, but can be loaded from
    the initial bundle as well, since bundlers add a whole bunch of modules in the
    bundles we ship to users. It could literally be `getModuleFromBundleAtPosition([0,4])`
    or something similar. The point is that the server sends a reference to the right
    client module, and React on the client side fills in the gap.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this happens, React will replace the module reference with the actual
    module from the client bundle. This is a bit of a simplification, but it should
    give us a good enough understanding of the mechanism. The client component is
    then rendered on the client, and the client component can then be interacted with
    as usual. This is why RSCs require a next-generation bundler: they need to be
    able to produce separate module graphs for server and client components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, this means that in the case of our counter example, the server
    would render the following tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This tree would be sent to the client side, and as React renders it and encounters
    the module reference, React would intelligently replace the module reference with
    the actual module from the client bundle. This is how React knows when to import
    and execute client components.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can see that the bundler is able to still render an entire tree on
    the server, and only leave “holes” to be filled in on the client while rendering
    even the children of client components recursively on the server, producing a
    full tree. The client then fills any holes necessary by downloading and executing
    client bundles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Server components can also be wrapped into Suspense boundaries, with frameworks
    doing the requisite work to stream them down to users from the server side as
    they become “ready”: that is, as any data they require is fetched and any other
    operations needed are completed asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, hopefully now we understand how client components are split from server
    components, enabling updates in RSCs-oriented applications. Client components
    marked with `"use client"` can contain localized state and event handlers like
    `onClick` without issue.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we’ve now closed the loop with client components and understand how
    server components are executed on the server and how client components are included
    in client bundles, we need to discuss some nuance around these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Nuance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a common misconception that server components execute only on the server
    and client components execute only on the client. This isn’t true. Server components
    do indeed execute only on the server and output objects representing React elements,
    but client components do not execute exclusively on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this deeper, let’s discuss what “components execute” even means.
    When we say “components execute,” we mean that the function that represents the
    component is called. For example, let’s say we have a component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we say "`MyComponent` executes,” we mean that the function `MyComponent`
    is called with its props and returns a React element—which is a plain JavaScript
    object that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is what we mean when we say “components execute.”
  prefs: []
  type: TYPE_NORMAL
- en: During server rendering, client components execute on the server and output
    objects representing React elements. These elements are then serialized into a
    string of HTML and sent to the client where the browser renders the HTML markup.
    Thus, client components also execute on the server, return some objects representing
    React elements, and then the server serializes them into HTML and sends them to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a more accurate representation of this, we can make the following true
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Server components execute on the server, output objects representing React elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client components execute on the server, output objects representing React elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A big object representing all React elements from both client and server components
    exists on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is turned into a string and sent to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this point, server components are never executed on the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client components are executed exclusively on the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this perspective, the execution boundaries of both server and client components
    become more clear. We may be splitting hairs here, but it’s worth adding more
    detail to fully understand and appreciate the interplay between both types of
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of Server Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how server components work under the hood, let’s discuss
    some rules that we need to follow when working with server components, or more
    broadly, things to keep in mind when working with server components.
  prefs: []
  type: TYPE_NORMAL
- en: Serializability Is King
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With server components, all props must be serializable. This is because the
    server needs to be able to serialize the props and send them to the client, as
    we’ve discussed earlier. Therefore, props cannot be functions or other nonserializable
    values in server components. This makes the render props pattern we discussed
    in [Chapter 5](ch05.html#ch05) effectively obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, based on our understanding of how RSCs are rendered on the server
    and then sent to the client on soft navigation, we should understand why this
    rule exists. Let’s say we have a server component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This would cause an error. We could, however, work around this by encapsulating
    the `onClick` prop inside the `ClientComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: No Effectful Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server is a vastly different environment from the client. It’s not interactive,
    it doesn’t have a DOM, and it doesn’t have a window. Therefore, hooks that are
    effectful are not supported in server components.
  prefs: []
  type: TYPE_NORMAL
- en: Some frameworks, like Next.js, have lint rules that completely ban all hooks
    in server components, but this is not entirely necessary. RSCs can use hooks that
    do not depend on state, effects, or browser-only APIs. For example, the `useRef`
    hook is perfectly fine to use in server components because it doesn’t depend on
    state, effects, or browser-only APIs. However, this may not be all bad, since
    it biases us toward more safely working with components.
  prefs: []
  type: TYPE_NORMAL
- en: State Is Not State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State in server components is not the same as state in client components. This
    is because server components are rendered on the server, and client components
    are rendered on the client. This means that state in server components may be
    shared between clients since server-client relationships are broadcast-style relationships
    instead of unicast (one client, one state), and thus the risks of leaking state
    between clients is high.
  prefs: []
  type: TYPE_NORMAL
- en: Combined with the hooks rule, this means that any components that require state
    via `useState` or `useReducer` or similar are best suited to be client components.
  prefs: []
  type: TYPE_NORMAL
- en: Client Components Cannot Import Server Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client components cannot import server components. This is because server components
    are executed only on the server, but client components are executed on both, including
    on browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we have a client component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: it would cause an error because the client component is trying to import a server
    component. This is impossible because, since server components execute only on
    the server, the server component we’re importing here may further import things
    that are not available in the client runtime environment, like Node.js APIs. This
    would cause errors on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all we know, the server component could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we try to run this on the client side because a client component imported
    it, we’d get an error because the `readFile` function and the `"node:fs/promises"`
    module are not available in the browser. This is why client components cannot
    import server components.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, client components can *compose* server components via props. For example,
    we could rewrite our client component to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'and then in whatever parent server component contains this client component,
    we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This would work because there’s no explicit import of a server component from
    a client component, but the parent server component is passing a server component
    as a prop to the client component. The only reason the imports are forbidden is
    to prevent the possibility of including server components in the client bundle,
    and bundlers only pay attention to import statements, not prop composition.
  prefs: []
  type: TYPE_NORMAL
- en: Client Components Are Not Bad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s worth noting that up until server components were introduced, client components
    were the only type of component we had in React. This means that all of our existing
    components are client components, and that’s OK. Client components are not bad,
    and they’re not going away. They’re still the bread and butter of React applications,
    and they’re still the most common type of component we’ll be writing.
  prefs: []
  type: TYPE_NORMAL
- en: We mention that here because there has been some confusion around this topic,
    and server components have been perceived by some as a superior replacement for
    client components. This is not true. Server components are a new type of component
    that we can use in addition to client components, but they’re not a replacement
    for client components.
  prefs: []
  type: TYPE_NORMAL
- en: Server Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server components are a powerful new feature in React, but they’re not the only
    new feature. RSCs also work in tandem with a new directive `"use server"` that
    marks server-side functions that can be called from client-side code. We call
    these functions *server actions*.
  prefs: []
  type: TYPE_NORMAL
- en: Any async function can have `"use server"` as the first line of its body to
    signal to React and to the bundler that this function can be called from client-side
    code, but must only execute on the server. When calling a server action on the
    client, it will make a network request to the server that includes a serialized
    copy of any arguments passed. If the server action returns a value, that value
    will be serialized and returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of individually marking functions with `"use server"`, you can also
    add the directive to the top of a file to mark all exports within that file as
    server actions that can be used anywhere, including imported in client code.
  prefs: []
  type: TYPE_NORMAL
- en: Forms and Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.html#ch08), we discussed how Next.js and Remix handle forms
    and mutations. React is adding (or has added) first-class primitives for these
    as well. Consider this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `requestUsername` is a server action passed to a `<form>`.
    When a user submits this form, there is a network request to the server function
    `requestUsername`. When calling a server action in a form, React will supply the
    form’s `FormData` as the first argument to the server action.
  prefs: []
  type: TYPE_NORMAL
- en: By passing a server action to the form action, React can progressively enhance
    the form. This means that forms can be submitted before the JavaScript bundle
    is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s worth noting that server actions are exposed server endpoints and can be
    called anywhere in client code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a server action outside of a form, we can call the server action
    in a transition, which allows us to display a loading indicator, show optimistic
    state updates, and handle unexpected errors. Here’s an example of a server action
    outside of a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we can see that server actions are a powerful new feature in React that
    allow us to call server-side functions from client-side code. This really is intended
    only to be used in libraries or frameworks, as working with these directives in
    vanilla React is a bit cumbersome and requires quite a bit of work wiring things
    up. However, it’s a powerful feature that enables a lot of interesting use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Future of React Server Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RSCs are expected to evolve and improve over time. The React team is actively
    working on refining the implementation, addressing potential issues, and expanding
    the feature set. Some areas of ongoing development include:'
  prefs: []
  type: TYPE_NORMAL
- en: Better bundler integration
  prefs: []
  type: TYPE_NORMAL
- en: The React team is partnering with bundler developers to ensure better support
    for RSCs in bundlers like Webpack, Rollup, and others. This will make it easier
    to build RSCs-compatible frameworks and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ecosystem support
  prefs: []
  type: TYPE_NORMAL
- en: As RSCs gain traction, more tools, libraries, and frameworks will likely emerge
    to support and extend this new application architecture. This will enable developers
    to more easily adopt RSCs in their projects and benefit from their performance
    and efficiency improvements.
  prefs: []
  type: TYPE_NORMAL
- en: RSCs represent a significant advancement in the React ecosystem, offering improved
    performance, simplified data fetching, and a better user experience. As RSCs continue
    to evolve and gain adoption, they’re expected to become an essential tool for
    building modern, efficient, and user-friendly React applications. With this comprehensive
    understanding of RSCs, you are now well-equipped to explore and experiment with
    this cutting-edge experimental feature in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we exclusively focused on React Server Components (RSCs), a
    significant advancement in the React ecosystem aimed at enhancing the performance,
    efficiency, and user experience of React applications. RSCs represent an innovative
    application architecture that combines the best attributes of server-rendered
    multipage apps (MPAs) and client-rendered single-page apps (SPAs). This approach
    delivers a seamless user experience without compromising on performance or maintainability.
    We delved into the core concepts, benefits, and the underlying mental models and
    mechanisms of RSCs. A key highlight was the introduction of a new type of component
    that operates on the server, excluded from the client-side JavaScript bundle,
    and can run during build time. This advancement leads to a more efficient and
    effective application structure.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that, at the time of writing, RSCs are a hot topic in the
    React and web engineering space, and some of the details we covered may have changed.
    As always, we recommend having a look at [react.dev](https://react.dev) and React’s
    various community channels for the latest information.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main value of React server components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can client components import server components? Why or why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some trade-offs between server components and traditional client-only
    React apps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are module references and how does React process them during reconciliation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do server actions make React apps more accessible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following chapter, we are going to take a slightly different path. We’ve
    spent most of our journey so far deeply embedded in the world of React, exploring
    its intricate inner workings, innovative strategies for state management, asynchronous
    rendering capabilities, and finally, its powerful frameworks. Now, we’re going
    to take a step back and broaden our perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to venture beyond React, diving into the world of alternative UI
    libraries and frameworks that have grown alongside and sometimes in response to
    React’s dominance. These alternatives have not only adopted some of React’s best
    features, but have also introduced unique innovations of their own, giving us
    exciting new paradigms and possibilities in UI development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the forthcoming exploration, we will be delving into the workings and philosophies
    of some of these other UI libraries, such as Vue, Angular, Solid, Qwik, and Svelte.
    We will look at their unique strategies for managing state, handling side effects,
    and how they compare to React in terms of performance and developer experience.
    Each alternative comes with its own set of pros and cons, which might make it
    a better fit for certain types of projects or developer preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: Vue
  prefs: []
  type: TYPE_NORMAL
- en: Vue offers a progressive framework that is incrementally adoptable, meaning
    you can start small and gradually adopt more of Vue’s features as you need them.
    Vue is renowned for its elegant API and focus on developer experience. It introduces
    a reactivity model that’s simple yet powerful, driven by its core concept of reactive
    dependencies tracked during render.
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs: []
  type: TYPE_NORMAL
- en: Angular is a complete, opinionated framework with a steeper learning curve,
    but offers robust solutions out of the box. Its dependency injection system and
    declarative templates offer a different approach to application structure and
    state management compared to React.
  prefs: []
  type: TYPE_NORMAL
- en: Solid
  prefs: []
  type: TYPE_NORMAL
- en: Solid is another contender that is gaining attention in the JavaScript community.
    It promises fine-grained reactivity with a programming model similar to React,
    but with a focus on faster, more efficient rendering. How Solid tracks dependencies
    could be a breath of fresh air for developers looking for more efficiency at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The Qwik framework
  prefs: []
  type: TYPE_NORMAL
- en: Qwik introduces an interesting approach by focusing on optimal loading performance
    with “predictable” prefetching. It brings a unique perspective to how we can structure
    and deliver our JavaScript for optimal user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte
  prefs: []
  type: TYPE_NORMAL
- en: Svelte has been turning heads by compiling components at build time into imperative
    code that directly manipulates the DOM, leading to faster initial load times and
    smooth updates. Its reactivity model, marked by reactive statements, offers an
    intriguing contrast to the virtual DOM diffing strategy adopted by React.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring these frameworks and libraries, we’ll keep our knowledge of
    React as a touchstone. This will not only help us understand the other libraries
    better but also deepen our understanding of React by offering points of comparison
    and contrast.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready to uncover the unique ways these alternate UI libraries approach reactivity,
    state management, side effects, and more. By studying these alternatives, we can
    glean insights that might inform our approach to problem-solving, regardless of
    the library or framework we choose to use. It’s a big, diverse world of JavaScript
    out there, and we’re about to dive in headfirst.
  prefs: []
  type: TYPE_NORMAL
- en: Buckle up! The journey is about to get even more exciting.
  prefs: []
  type: TYPE_NORMAL
