- en: Chapter 19\. Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章 动画
- en: CSS transitions, covered in the previous chapter, enable simple animations that
    are triggered by changes in the DOM state and proceed from a beginning state to
    an end state. CSS *animations* are similar to transitions in that values of CSS
    properties change over time, but animations provide much more control over the
    way those changes happen. Specifically, CSS keyframe animations let us decide
    if and how an animation repeats, give us granular control over what happens throughout
    the animation, and more. While transitions trigger implicit property value changes,
    animations are explicitly executed when keyframe animations are applied.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章介绍的 CSS 过渡中，简单的动画是由 DOM 状态的变化触发的，并从开始状态过渡到结束状态。CSS *动画* 类似于过渡，因为 CSS 属性值随时间变化，但动画可以更精确地控制这些变化的方式。具体来说，CSS
    关键帧动画让我们决定动画是否重复，以及如何重复，还可以详细控制动画的每个阶段等。虽然过渡触发隐含的属性值变化，但动画则在应用关键帧动画时明确执行。
- en: With CSS animations, you can change property values that are not part of the
    set pre- or post-state of an element. The property values set on the animated
    element don’t necessarily have to be part of the animation progression. For example,
    when using a transition, going from black to white will animate only through various
    shades of gray. With animation, that same element doesn’t have to be black or
    white or even in-between shades of gray during the animation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CSS 动画，您可以更改元素的非预设或后置状态的属性值。在动画元素上设置的属性值不一定需要是动画过程中的一部分。例如，使用过渡时，从黑色到白色只会动画过各种灰色阶段。但是在动画中，该元素不必在动画期间始终是黑色、白色或甚至中间色。
- en: While you *can* transition through shades of gray, you could instead turn the
    element yellow, then animate from yellow to orange. Alternatively, you could animate
    through various colors, starting with black and ending with white, but progressing
    through the entire rainbow along the way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您*可以*通过灰度过渡，但您也可以将元素变为黄色，然后从黄色动画到橙色。或者，您可以通过各种颜色进行动画，从黑色开始，到白色结束，但在此过程中穿过整个彩虹。
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Look for the Play symbol ![](assets/play-icon-round.png) to know when an online
    example is available. All of the examples in this chapter can be found at [*https://meyerweb.github.io/csstdg5figs/19-animation*](https://meyerweb.github.io/csstdg5figs/19-animation).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 查找播放符号 ![](assets/play-icon-round.png) ，以了解在线示例是否可用。本章中的所有示例都可以在 [*https://meyerweb.github.io/csstdg5figs/19-animation*](https://meyerweb.github.io/csstdg5figs/19-animation)
    找到。
- en: Accommodating Seizure and Vestibular Disorders
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应癫痫和前庭障碍
- en: Warning
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While you can use animations to create ever-changing content, *repeated rapid
    changing of content can lead to seizures in some users.* Always keep this in mind,
    and ensure the accessibility of your website for people with epilepsy and other
    seizure disorders.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用动画创建不断变化的内容，*但是重复快速变化的内容可能会导致某些用户癫痫发作*。请始终记住这一点，并确保您的网站对癫痫和其他癫痫症状的用户具有较好的可访问性。
- en: We don’t usually start a chapter with a warning, but in this case, it’s warranted.
    Visual change, especially rapid visual change, can trigger medical emergencies
    in users who are prone to seizures. They can also cause severe unease in users
    who are prone to vestibular disorder (motion sickness).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不会以警告开始一章，但在这种情况下确实有必要。视觉变化，特别是快速的视觉变化，可能会触发容易引起癫痫的用户的医疗紧急情况。它们还可能会导致容易患前庭障碍（晕动病）的用户感到严重不适。
- en: 'To reduce or eliminate this risk, use the `prefers-reduced-motion` media query
    (see [Chapter 21](ch21.html#css-at-rules)). This allows you to apply styles when
    the user has a “Reduce motion” or similar preference set for their browser or
    operating system. An approach such as this may be considered:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少或消除这种风险，请使用 `prefers-reduced-motion` 媒体查询（参见[第21章](ch21.html#css-at-rules)）。这允许您在用户为其浏览器或操作系统设置了“减少运动”或类似偏好时应用样式。可以考虑如下方法：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This disables all animations and transitions, assuming no other `!important`
    animations are specified (and they shouldn’t be). This is not a nuanced or perfect
    solution, but it’s a first step. You can invert this approach by segregating all
    of your animations and transitions in a media block for those who do *not* have
    motion reduction enabled, like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将禁用所有动画和过渡效果，假设没有指定其他 `!important` 的动画（它们不应该有）。这并不是一个微妙或完美的解决方案，但这是第一步。您可以通过将所有动画和过渡效果放在一个媒体块中，以便为不启用运动减少功能的用户隔离，来反转此方法，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Not all animations are dangerous or disorienting, and having at least some animations
    for all users may be necessary. Transitions and animations can be very helpful
    in informing users what has changed and guiding them to focus on specific content.
    In such cases, use `prefers-reduced-motion` to tone down animations that are essential
    to understanding the UI, and to switch off those that are not essential.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有动画都危险或令人迷失方向，对所有用户至少进行一些动画可能是必要的。过渡和动画在告知用户发生了什么变化和引导他们关注特定内容方面非常有帮助。在这种情况下，使用`prefers-reduced-motion`来减少对理解UI至关重要的动画，并关闭那些不必要的动画。
- en: Defining Keyframes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义关键帧
- en: To animate an element, you need to refer to the name of a keyframe animation;
    to do *that*, we need a named keyframe animation. The first step is to define
    this reusable CSS keyframe animation by using the `@keyframes` at-rule, thus giving
    our animation a name.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要对元素进行动画处理，需要引用关键帧动画的名称；为了*这样做*，我们需要一个命名的关键帧动画。第一步是使用`@keyframes` at规则定义这个可重用的CSS关键帧动画，从而为我们的动画命名。
- en: A `@keyframes` at-rule includes the *animation identifier*, or name, and one
    or more *keyframe blocks*. Each keyframe block includes one or more keyframe selectors
    with declaration blocks of property-value pairs. The entire `@keyframes` at-rule
    specifies the behavior of a single full iteration of the animation. The animation
    can iterate zero or more times, depending mainly on the `animation-iteration-count`
    property value, which we’ll discuss in [“Declaring Animation Iterations”](#defining-animation-iterations).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`@keyframes` at规则包括*动画标识符*或名称，以及一个或多个*关键帧块*。每个关键帧块包含一个或多个带有属性-值对声明块的关键帧选择器。整个`@keyframes`
    at规则指定了单次完整动画的行为。动画可以零次或多次迭代，主要取决于`animation-iteration-count`属性值，我们将在[“声明动画迭代次数”](#defining-animation-iterations)中讨论。'
- en: 'Each keyframe block includes one or more *keyframe selectors*. These are percentage-of-time
    positions along the duration of the animation; they are declared either as percentages
    or with the keywords `from` or `to`. Here’s the generic structure of an animation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关键帧块包含一个或多个*关键帧选择器*。这些是沿动画持续时间的百分比时间位置；它们声明为百分比或使用关键字`from`或`to`。以下是动画的通用结构：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are a couple of basic examples:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是几个基本示例：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first set of keyframes shown takes an element, sets its `opacity` to `1`
    (fully opaque), and animates it to `0` opacity (fully transparent). The second
    keyframe set animates an element’s foreground to black and its background to white,
    then animates the foreground from black to gray and then white, and the background
    from white to yellow and then orange.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的第一组关键帧将元素的`opacity`设置为`1`（完全不透明），并将其动画化为`0`不透明度（完全透明）。第二组关键帧将元素的前景动画化为黑色，背景为白色，然后将前景从黑色动画到灰色，然后是白色，背景从白色动画到黄色，然后是橙色。
- en: Note that the keyframes don’t say how long this animation should take—that’s
    handled by a CSS property dedicated to the purpose. Instead they say, “Go from
    this state to that state” or “Hit these various states at these percentage points
    of the total animation.” That’s why keyframe selectors are always percentages,
    or `from` and `to`. If you try to use time values (like `1.5s`) as your keyframe
    selectors, you’ll render them invalid.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，关键帧不指定动画应该持续多长时间——这由专门用于此目的的CSS属性处理。而是它们说，“从这种状态过渡到那种状态”或“在总动画的这些百分比点上达到这些各种状态”。这就是为什么关键帧选择器总是百分比，或者`from`和`to`。如果尝试使用时间值（如`1.5s`）作为关键帧选择器，将使其无效。
- en: Setting Up Keyframe Animations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置关键帧动画
- en: Within the opening and closing curly braces of a keyframe set, you include a
    series of keyframe selectors with blocks of CSS that declare the properties you
    want to animate. Once the keyframes are defined, you “attach” the animation to
    an element by using the `animation-name` property. We’ll discuss that property
    shortly, in [“Invoking a Named Animation”](#the-animation-name-property).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键帧集的大括号中，包含一系列带有CSS块的关键帧选择器，声明您要动画化的属性。一旦定义了关键帧，您可以通过使用`animation-name`属性将动画“附加”到元素来“激活”它。我们将很快讨论该属性，在[“调用命名动画”](#the-animation-name-property)中。
- en: 'Start with the at-rule declaration, followed by the animation name and braces:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从at规则声明开始，后跟动画名称和大括号：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The name, which you create, is an identifier or a string. Originally, the keyframe
    names had to be an identifier, but both the specification and the browsers also
    support quoted strings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的名称是标识符或字符串。最初，关键帧名称必须是标识符，但规范和浏览器也支持带引号的字符串。
- en: Identifiers are unquoted and have specific rules. You can use any characters
    `a-z`, `A-Z`, and `0-9`, the hyphen (`-`), underscore (`_`), and any ISO 10646
    character U+00A0 and higher. ISO 10646 is the universal character set; this means
    you can use any character in the Unicode standard that matches the regular expression
    `[-_a-zA-Z0-9\u00A0-\u10FFFF]`.[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/name.html)
    The identifier can’t start with a digit (0–9) and should not start with two hyphens
    (though some browsers allow this). One hyphen is fine, as long as it is not followed
    by a digit—unless you escape the digit or hyphen with a backslash.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符是未引用的，并且有特定的规则。你可以使用任何字符 `a-z`、`A-Z` 和 `0-9`，连字符 (`-`)，下划线 (`_`)，以及 ISO 10646
    字符集中的任何字符 U+00A0 及以上。ISO 10646 是通用字符集；这意味着你可以使用 Unicode 标准中匹配正则表达式 `[-_a-zA-Z0-9\u00A0-\u10FFFF]`
    的任何字符。标识符不能以数字（0–9）开头，也不应以两个连字符开头（尽管某些浏览器允许这样）。一个连字符是可以的，只要它后面不跟随数字，除非你用反斜杠转义数字或连字符。
- en: If you include any escape characters within your animation name, make sure to
    escape them with a backslash (`\`). For example, `Q&A!` must be written as `Q\&A\!`.
    The name `âœŽ` can be left as `âœŽ` (no, that’s not a typo), and `✎` is a valid
    name as well. But if you’re going to use any keyboard characters that aren’t letters
    or digits in an identifier, like `!`, `@`, `#`, `$`, and so on, escape them with
    a backslash.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的动画名称中包含任何转义字符，请确保用反斜杠 (`\`) 转义它们。例如，`Q&A!` 必须写成 `Q\&A\!`。名称 `âœŽ` 可以保留为
    `âœŽ`（不，这不是拼写错误），而 `✎` 也是一个有效的名称。但是，如果你要在标识符中使用任何不是字母或数字的键盘字符，比如 `!`、`@`、`#`、`$`
    等，记得用反斜杠转义它们。
- en: Also, don’t use any of the keywords covered in this chapter as the name of your
    animation. For example, possible values for the various animation properties we’ll
    be covering later in the chapter include `none`, `paused`, `running`, `infinite`,
    `backwards`, and `forwards`. Using an animation property keyword, while not prohibited
    by the spec, will likely break your animation [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/badnames.html)
    when using the `animation` shorthand property (discussed in [“Bringing It All
    Together”](#the-animation-shorthand-property)). So, while you can legally name
    your animation `paused` (or another keyword,) we *strongly* recommend against
    it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在动画名称中不要使用本章中涵盖的任何关键字。例如，我们稍后将讨论的各种动画属性的可能值包括 `none`、`paused`、`running`、`infinite`、`backwards`
    和 `forwards`。尽管规范没有禁止使用动画属性关键字作为动画名称，但这很可能会破坏你的动画效果，特别是在使用 `animation` 简写属性时（在
    [“汇总”](#the-animation-shorthand-property) 中讨论）。因此，尽管你可以合法地将你的动画命名为 `paused`（或其他关键字），我们*强烈建议*不要这样做。
- en: Defining Keyframe Selectors
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义关键帧选择器
- en: '*Keyframe selectors* define points during an animation where we set the values
    of the properties we want to animate. If you want a value at the start of the
    animation, you declare it at the `0%` mark. If you want a different value at the
    end of the animation, you declare the property value at the `100%` mark. If you
    want a value a third of the way through the animation, you declare it at the `33%`
    mark. These marks are defined with keyframe selectors.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键帧选择器* 定义了动画过程中我们想要动画化的属性值。如果你想要在动画开始时设置一个数值，你需要在 `0%` 处声明它。如果你想在动画结束时设置一个不同的数值，你需要在
    `100%` 处声明属性值。如果你想要在动画进行到三分之一时设置一个数值，你需要在 `33%` 处声明它。这些标记是由关键帧选择器定义的。'
- en: 'Keyframe selectors consist of a comma-separated list of one or more percentage
    values or the keywords `from` or `to`. The keyword `from` is equal to `0%`. The
    keyword `to` equals `100%`. The keyframe selectors are used to specify the percentage
    along the duration of the animation the keyframe represents. The keyframe itself
    is specified by the block of property values declared on the selector. The `%`
    unit must be used on percentage values. In other words, `0` is invalid as a keyframe
    selector:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关键帧选择器由一个逗号分隔的百分比值或关键字 `from` 或 `to` 的列表组成。关键字 `from` 等同于 `0%`。关键字 `to` 等同于
    `100%`。关键帧选择器用于指定动画时段内关键帧所代表的百分比。关键帧本身由在选择器上声明的属性值块指定。百分比值必须使用 `%` 单位。换句话说，`0`
    作为关键帧选择器是无效的：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This `@keyframes` animation, named `W`, when attached to a nonstatically positioned
    element, would move that element along a W-shaped path. `W` has five keyframes:
    one each at the `0%`, `25%`, `50%`, `75%`, and `100%` marks. The `from` is the
    `0%` mark, while the `to` is the `100%` mark. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/02_W.html)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当此`@keyframes`动画命名为`W`并附加到非静态定位元素时，会使该元素沿着W形路径移动。`W`有五个关键帧：分别位于`0%`、`25%`、`50%`、`75%`和`100%`的标记。`from`是`0%`标记，而`to`是`100%`标记。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/02_W.html)
- en: Because the property values we set for the `25%` and `75%` mark are the same,
    we can put the two keyframe selectors together as a comma-separated list. This
    is very similar to regular selectors, which you can group together with commas.
    Whether you keep those selectors on one line (as in the example) or put each selector
    on its own line is up to your personal preference.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们为`25%`和`75%`标记设置的属性值相同，所以我们可以将这两个关键帧选择器放在一个逗号分隔的列表中。这与常规选择器非常相似，你可以用逗号将它们组合在一起。无论你将这些选择器保留在一行（如示例中）还是将每个选择器放在自己的一行中，都取决于个人偏好。
- en: Notice that keyframe selectors do not need to be listed in ascending order.
    In the preceding example, we have the `25%` and `75%` on the same line, with the
    `50%` mark coming after that declaration. For legibility, it is highly encouraged
    to progress from the `0%` to the `100%` mark. However, as demonstrated by the
    `75%` keyframe in this example, it is not required. You could define your keyframes
    with the last first and the first last, or scramble them up randomly, or whatever
    works for you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，关键帧选择器不需要按升序列出。在前面的示例中，我们在同一行上有`25%`和`75%`，然后是`50%`标记。为了可读性，强烈建议从`0%`到`100%`的标记递进。然而，就像本例中的`75%`关键帧所示，这并不是必需的。你可以从最后一个开始定义你的关键帧，然后从第一个开始，或者随意打乱它们，或者任何你认为适合的方式。
- en: Omitting from and to Values
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 省略`from`和`to`值
- en: If a `0%` or `from` keyframe is not specified, the user agent (browser) constructs
    a `0%` keyframe. The implicit `0%` keyframe uses the original values of the properties
    being animated, as if the `0%` keyframe were declared with the same property values
    that impact the element when no animation was applied—that is, unless another
    animation applied to that element is currently animating the same property (see
    [“Invoking a Named Animation”](#the-animation-name-property) for details). Similarly,
    if the `100%` or `to` keyframe is not defined and no other animations are being
    applied, the browser creates a faux `100%` keyframe using the value the element
    would have had if no animation had been set on it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定`0%`或`from`关键帧，则用户代理（浏览器）会构建一个`0%`关键帧。隐式的`0%`关键帧使用被动画化属性的原始值，就好像在元素上未应用动画时声明了具有相同属性值的`0%`关键帧一样，即除非另一个动画正在该元素上动画化相同的属性（详情见[“调用命名动画”](#the-animation-name-property)）。同样地，如果未定义`100%`或`to`关键帧且未应用其他动画，则浏览器将使用元素在未设置动画时的值创建一个伪`100%`关键帧。
- en: 'Say we have a `background-color` change animation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`background-color`的变化动画：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the element originally had `background-color: red` set on it, it would be
    as if the animation were as follows: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/no0or100.html)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '如果元素原本设置了`background-color: red`，则动画就好像如下所示：[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/no0or100.html)'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, remembering that we can include multiple identical keyframes as a comma-separated
    list, this faux animation also could be written as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，记住我们可以将多个相同的关键帧作为逗号分隔的列表包含，这个伪动画也可以像这里显示的那样编写：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note the `background-color: red;` declarations are not part of the original
    keyframe animation; they’ve just been filled in here for clarity. We can include
    this `change_bgcolor` animation on many elements, and the perceived animation
    will differ based on the element’s value for the `background-color` property in
    the nonanimated state. Thus, an element that has a yellow background will animate
    from yellow to green to blue and then back to yellow.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，`background-color: red;`的声明不是原始关键帧动画的一部分；它们只是为了清晰起见在此处填写。我们可以在许多元素上包含这个`change_bgcolor`动画，且感知到的动画会根据非动画状态下元素`background-color`属性的值而有所不同。因此，具有黄色背景的元素将从黄色动画到绿色再到蓝色，然后回到黄色。'
- en: Although we’ve been using exclusively integer values for our percentages, noninteger
    percentage values, such as `33.33%`, are perfectly valid. Negative percentages,
    values greater than `100%`, and values that aren’t otherwise percentages or the
    keywords `to` or `from` are invalid and will be ignored.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们一直在使用百分比的整数值作为百分比，但非整数百分比值（例如`33.33%`）是完全有效的。负百分比、大于`100%`的值以及不是百分比或关键字`to`或`from`的值都是无效的，并将被忽略。
- en: Repeating Keyframe Properties
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复关键帧属性
- en: 'Much like the rest of CSS, the values in keyframe declaration blocks with identical
    keyframe values cascade. Thus, the earlier `W` animation can be written with the
    `to`, or `100%`, declared twice, overriding the value of the `left` property:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 CSS 的其余部分一样，具有相同关键帧值的关键帧声明块中的值是级联的。因此，可以通过两次声明`to`或`100%`来编写先前的`W`动画，从而覆盖`left`属性的值：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that `to` is declared along with `from` as keyframe selectors for the
    first code block? That sets both `top` and `left` for the `to` keyframe. Then,
    the `left` value is overridden for the `to` in the last keyframe block.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个代码块的关键帧选择器中，`to`与`from`一起声明？这为`to`关键帧设置了`top`和`left`。然后，最后一个关键帧块中覆盖了`to`的`left`值。
- en: Animatable Properties
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可动画化属性
- en: It’s worth taking a moment to note that not all properties are *animatable*.
    If you list a property that can’t be animated within an animation’s keyframes,
    it’s simply ignored. (For that matter, so are properties and values that the browser
    doesn’t recognize at all, just like any other part of CSS.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，并非所有属性都可以*动画化*。如果在动画的关键帧中列出了无法动画化的属性，它们会被简单地忽略。（同样，浏览器完全不认识的属性和值也会被忽略，就像
    CSS 的其他部分一样。）
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Exceptions to the midpoint rule include `animating-timing-function` and `visibility`,
    which are discussed in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 中点规则的例外包括`animating-timing-function`和`visibility`，这些在下一节中讨论。
- en: As long as an animatable property is included in at least one block with a value
    that is different from the nonanimated attribute value, and there is a calculable
    midpoint between those two values, that property will animate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 只要可动画化属性在至少一个具有与非动画化属性值不同的值的块中包含，并且这两个值之间有可计算的中点，该属性就会动画化。
- en: 'If an animation is set between two property values that don’t have a calculable
    midpoint, the property may not animate correctly—or at all. For example, you shouldn’t
    declare an element’s height to animate between `height: auto` and `height: 300px`,
    because there is no easily defined midpoint between `auto` and `300px`. The element
    will still animate, but browsers will jump from the preanimated state to the postanimated
    state halfway through the animation. Thus, for a 1-second animation, the element
    will jump from `auto` height to `300px` height at the 500-millisecond point in
    the animation. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/nomidpoint.html)
    Other properties may animate over the length of the same animation; e.g., if you
    change the background color, it will animate smoothly over the animation. Only
    those properties that can’t be animated between will jump halfway through.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '如果动画设置在两个属性值之间，这两个值之间没有可计算的中点，那么属性可能无法正确或根本无法动画化。例如，不应该声明元素的高度在`height: auto`和`height:
    300px`之间进行动画，因为`auto`和`300px`之间没有明确定义的中点。元素仍会动画化，但浏览器会在动画的一半时从预动画状态跳到后动画状态。因此，对于1秒的动画，元素将在动画的500毫秒处从`auto`高度跳到`300px`高度。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/nomidpoint.html)
    其他属性可能会在相同的动画长度内动画化；例如，如果更改背景颜色，它会在动画过程中平滑过渡。只有不能在其间进行动画的属性会在一半时跳跃。'
- en: 'The behavior of your animation will be most predictable if you declare both
    a 0% and a 100% value for every property you animate. For example, if you declare
    `border-radius: 50%;` in your animation, you may want to declare `border-radius:
    0%;` as well, because the default value of `border-radius` is `none`, not `0`,
    and there is no midpoint between `none` and other values. Consider the difference
    in the following two animations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您为每个要动画化的属性声明了0%和100%的值，则动画的行为将更可预测。例如，如果在动画中声明了`border-radius: 50%;`，您可能也想声明`border-radius:
    0%;`，因为`border-radius`的默认值是`none`而不是`0`，`none`与其他值之间没有中点。考虑以下两个动画之间的差异：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `round` animation will animate an element from the original `border-radius`
    value of that element to `border-radius`: `50%` over the duration of the animation.
    The `square_to_round` animation will animate an element from `border-radius: 0%`
    to `border-radius: 50%` over the duration of the animation. If the element starts
    out with square corners, the two animations will have exactly the same effect.
    But if the element starts out with rounded corners, `square_to_round` will jump
    to rectangular corners before it starts animating.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`round` 动画将从元素的原始 `border-radius` 值动画到 `border-radius: 50%` 的值。`square_to_round`
    动画将从 `border-radius: 0%` 动画到 `border-radius: 50%`。如果元素起始为方形角，两个动画将完全相同。但是如果元素起始为圆角，`square_to_round`
    将在开始动画之前跳转到矩形角。'
- en: Using Nonanimatable Properties That Aren’t Ignored
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非可动画属性，这些属性不会被忽略
- en: Exceptions to the midpoint rule include `visibility` and `animation-timing-function`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况中点规则包括 `visibility` 和 `animation-timing-function`。
- en: 'The `visibility` property is animatable, even though there is no midpoint between
    `visibility:` `hidden` and `visibility: visible`. When you animate from `hidden`
    to `visible`, the visibility value jumps from one value to the next at the keyframe
    where the change is declared. So you don’t get a smooth fade from visible to hidden,
    or vice versa. The state changes in an instant.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`visibility` 属性是可动画化的，即使 `visibility:` `hidden` 和 `visibility: visible` 之间没有中点。当您从
    `hidden` 动画到 `visible` 时，可见性值在声明变化的关键帧上瞬间跳转。因此，您不会得到从可见到隐藏或反之的平滑淡入淡出效果。状态会瞬间变化。'
- en: While the `animation-timing-function` is not, in fact, an animatable property,
    when included in a keyframe block, the animation timing will switch to the newly
    declared value at that point in the animation for the properties within that keyframe
    selector block. The change in animation timing is not animated; it simply switches
    to the new value for those properties only, and only until the next keyframe.
    This allows you to vary the timing function from one keyframe to another. (This
    is covered in [“Changing the Internal Timing of Animations”](#changing-the-internal-timing-of-animations).)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `animation-timing-function` 实际上并非可动画化属性，但当包含在关键帧块中时，动画时间将在动画的该点切换到新声明的值，仅适用于该关键帧选择器块内的属性。动画时间的变化不是动画的；它只是简单地切换到这些属性的新值，并且仅持续到下一个关键帧。这使得您可以在一个关键帧与另一个关键帧之间变化时间函数。（详见[“更改动画的内部时间”](#changing-the-internal-timing-of-animations)。）
- en: Scripting @keyframes Animations
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本化 @keyframes 动画
- en: 'The CSSKeyframesRule API enables finding, appending, and deleting keyframe
    rules. You can change the content of a keyframe block within a given `@keyframes`
    declaration with `appendRule(`*`n`*`)` or `deleteRule(`*`n`*`)`, where *`n`* is
    the full selector of that keyframe. You can return the contents of a keyframe
    with `findRule(`*`n`*`)`. Consider this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CSSKeyframesRule API 允许查找、追加和删除关键帧规则。您可以使用 `appendRule(`*`n`*`)` 或 `deleteRule(`*`n`*`)`
    改变给定 `@keyframes` 声明中关键帧块的内容，其中 *`n`* 是该关键帧的完整选择器。您可以使用 `findRule(`*`n`*`)` 返回关键帧的内容。考虑以下情况：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `appendRule()`, `deleteRule()`, and `findRule()` methods take the full
    keyframe selector as an argument, as shown in the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendRule()`、`deleteRule()` 和 `findRule()` 方法以完整的关键帧选择器作为参数，如下所示：'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The statement `myAnimation.findRule(''25%, 75%'').cssText`, where `myAnimation`
    is pointing to a keyframe animation, returns the keyframe that matches `25%, 75%`.
    It would not match any block using either `25%` or `75%` only. If `myAnimation`
    refers to the `W` animation, `myAnimation.findRule(''25%, 75%'').cssText` returns
    `25%, 75% { top: 100%; }`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '语句 `myAnimation.findRule(''25%, 75%'').cssText` 中，`myAnimation` 指向关键帧动画，则返回与
    `25%, 75%` 匹配的关键帧。它不会匹配任何仅使用 `25%` 或 `75%` 的块。如果 `myAnimation` 指向 `W` 动画，则 `myAnimation.findRule(''25%,
    75%'').cssText` 返回 `25%, 75% { top: 100%; }`。'
- en: 'Similarly, `myAnimation.deleteRule(''50%'')` will delete the *last* 50% keyframe—so
    if we have multiple `50%` keyframes, the last one listed will be the first to
    go. Conversely, `myAnimation.appendRule(''53% {top: 50%;}'')` appends a 53% keyframe
    after the last keyframe of the `@keyframes` block. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/appendRule.html)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '类似地，`myAnimation.deleteRule(''50%'')` 将删除最后一个 `50%` 关键帧 — 如果我们有多个 `50%` 关键帧，则列出的最后一个将首先被删除。相反，`myAnimation.appendRule(''53%
    {top: 50%;}'')` 在 `@keyframes` 块的最后一个关键帧之后追加一个 `53%` 关键帧。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/appendRule.html)'
- en: 'CSS has four animation events: `animationstart`, `animationend`, `animationiteration`,
    and `animationcancel`. The first two occur at the start and end of an animation,
    and the last between the end of an iteration and the start of a subsequent iteration.
    Any animation for which a valid keyframe rule is defined will generate the start
    and end events, even animations with empty keyframe rules. The `animationiteration`
    event occurs only when an animation has more than one iteration, as the `animationiteration`
    event does not fire if the `animationend` event would fire at the same time. The
    `animationcancel` event is fired whenever a running animation is stopped before
    reaching its last keyframe.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: CSS有四个动画事件：`animationstart`，`animationend`，`animationiteration`和`animationcancel`。前两者发生在动画开始和结束时，最后一个在迭代结束和下一次迭代开始之间触发。任何定义了有效关键帧规则的动画都会生成开始和结束事件，即使是空的关键帧规则的动画也是如此。`animationiteration`事件仅在动画有多个迭代时发生，因为如果`animationend`事件与之同时发生，则`animationiteration`事件不会触发。`animationcancel`事件在运行中的动画在达到最后关键帧之前停止时触发。
- en: Animating Elements
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对元素进行动画处理
- en: Once you have created a keyframe animation, you can apply that animation to
    elements and/or pseudo-elements. CSS provides numerous animation properties to
    attach a keyframe animation to an element and control its progression. At a minimum,
    you need to include the name of the animation for the element to animate, and
    a duration if you want the animation to be visible. (Without a duration, the animation
    will happen in zero time.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了关键帧动画，就可以将该动画应用于元素和/或伪元素。CSS提供了许多动画属性来将关键帧动画附加到元素并控制其进度。至少，您需要为元素动画包含动画的名称，并在希望动画可见时指定持续时间。（如果没有持续时间，动画将在零时间内完成。）
- en: 'You can attach animation properties to an element in two ways: include all
    the animation properties separately, or declare all the properties in one line
    by using the `animation` shorthand property (or a combination of shorthand and
    longhand properties). Let’s start with the individual properties.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式将动画属性附加到元素：分别包含所有动画属性，或者使用`animation`简写属性（或简写和长手写结合）。让我们从单独的属性开始。
- en: Invoking a Named Animation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用命名动画
- en: The `animation-name` property takes as its value a comma-separated list of names
    of keyframe animations you want to apply to the selected elements. The names are
    the unquoted identifiers or quoted strings (or a mixture of both) you created
    in your `@keyframes` rules.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-name`属性的值是要应用于所选元素的关键帧动画名称的逗号分隔列表。这些名称是您在`@keyframes`规则中创建的未引用的标识符或引用的字符串（或两者的混合）。'
- en: The default value is `none`, which means no animation is applied to the selected
    elements. The `none` value can be used to override any animation applied elsewhere
    in the CSS cascade. (This is also the reason you don’t want to name your animation
    `none`, unless you’re a masochist.) [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/badnames.html)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是`none`，这意味着未对所选元素应用任何动画。`none`值可用于覆盖CSS层叠中的任何其他动画。（这也是为什么你不想将你的动画命名为`none`，除非你是一个受虐狂。）[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/badnames.html)
- en: 'Using the `change_bgcolor` keyframe animation defined in [“Omitting from and
    to Values”](#omitting-from-and-to-values), we have this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[“省略from和to值”](#omitting-from-and-to-values)中定义的`change_bgcolor`关键帧动画，我们有以下内容：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This simple rule applies the `change_bgcolor` animation to all `<div>` elements,
    however many or few are on the page. To apply more than one animation, include
    more than one comma-separated animation name:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单规则将`change_bgcolor`动画应用到所有`<div>`元素上，无论页面上有多少个或多少个。要应用多个动画，请包含多个逗号分隔的动画名称：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If one of the included keyframe identifiers does not exist, the series of animations
    will not fail; rather, the failed animation will be ignored, and the valid animations
    will be applied. While ignored initially, the failed animation will be applied
    if and when that keyframe animation comes into existence as a valid animation.
    Consider the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含的关键帧标识符之一不存在，则动画系列不会失败；相反，失败的动画将被忽略，并且有效的动画将被应用。虽然最初被忽略，但如果该关键帧动画随后作为有效动画存在时，将被应用。考虑以下情况：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, assume that no `spin` keyframe animation is defined. The `spin`
    animation will not be applied, while the `change_bgcolor`, `round`, and `W` animations
    will occur. Should a `spin` keyframe animation come into existence through scripting,
    it will be applied at that time. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/nameaddedlater.html)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设没有定义`spin`关键帧动画。`spin`动画将不会被应用，而`change_bgcolor`、`round`和`W`动画将会发生。如果通过脚本存在`spin`关键帧动画，则会在那时应用。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/nameaddedlater.html)
- en: If more than one animation is applied to an element and those animations have
    repeated properties, the later animations override the property values in the
    earlier animations. For example, if more than two background color changes are
    applied concurrently in two different keyframe animations, whichever animation
    was listed later will override the background property declarations of animations
    earlier in the list, but *only* if the properties (background colors, in this
    case) are being animated at the same time. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/no0or100.html)
    For more on this, see [“Animation, Specificity, and Precedence Order”](#animation-specificity-and-precedence-order).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个元素应用了多个动画，并且这些动画具有重复的属性，则后面的动画会覆盖先前动画中的属性值。例如，如果两个不同的关键帧动画同时应用了超过两个背景颜色更改，那么排在后面的动画将覆盖动画列表中先前动画的背景属性声明，但*仅当*这些属性（在本例中为背景颜色）同时被动画化时。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/no0or100.html)欲了解更多，请参阅[“动画、特异性和优先级顺序”](#animation-specificity-and-precedence-order)。
- en: 'For example, assume the following, and further assume that the animations happen
    over a period of 10 seconds:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设如下，并进一步假设动画发生在10秒内：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The background will animate from cyan to orange to red to purple and then back
    to cyan, thanks to `bg-shift`. Because it comes last in the list of animations,
    its keyframes take precedence. Anytime multiple animations specify behavior for
    the same property at the same point in time, the animation listed last in the
    value of `animation-name` will be in effect.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 背景颜色将从青色渐变到橙色，再到红色，最后到紫色，然后再回到青色，这要归功于`bg-shift`。因为它在动画列表中排在最后，所以其关键帧优先生效。每当多个动画在同一时间点为同一属性指定行为时，`animation-name`值列表中排在最后的动画将生效。
- en: 'What’s interesting is what happens if the `from` (`0%`) or `to` (`100%`) keyframes
    are omitted from the animation in force. For example, let’s remove the first keyframes
    defined in `bg-shift`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果强制动画中省略了`from`（`0%`）或`to`（`100%`）关键帧会发生什么。例如，让我们移除`bg-shift`中定义的第一个关键帧：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now no background colors are defined at the beginning and end of `bg-shift`.
    In a situation like this, when a `0%` or `100%` keyframe is not specified, the
    user agent constructs a `0%`/`100%` keyframe by using the computed values of the
    properties being animated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`bg-shift`的开始和结束处没有定义背景颜色。在这种情况下，当未指定`0%`或`100%`关键帧时，用户代理会通过使用正在动画化的属性的计算值来构建`0%`/`100%`关键帧。
- en: These are concerns only when two different keyframe blocks are trying to change
    the same property’s values. In this case, it is `background-color`. On the other
    hand, if one keyframe block animates `background-color` while another animates
    `padding`, the two animations will not collide, and both the background color
    and padding will be animated together.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是在两个不同的关键帧块试图改变同一属性值时的考虑。在这种情况下，该属性是`background-color`。另一方面，如果一个关键帧块动画化了`background-color`，而另一个动画化了`padding`，则这两个动画不会发生冲突，背景颜色和填充都会一起动画化。
- en: Simply applying an animation to an element is not enough for the element to
    visibly animate. For that to happen, the animation must take place over some amount
    of time. For that, we have the `animation-duration` property.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅将动画应用到一个元素并不足以使元素可见动画化。为了实现动画效果，动画必须在一段时间内发生。为此，我们有`animation-duration`属性。
- en: Defining Animation Lengths
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义动画长度
- en: The `animation-duration` property defines how long a single animation iteration
    should take in seconds (`s`) or milliseconds (`ms`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-duration`属性定义了单个动画迭代应该花费的时间，单位可以是秒（`s`）或毫秒（`ms`）。'
- en: The `animation-duration` property defines the length of time, either in seconds
    (`s`) or milliseconds (`ms`), it should take to complete one cycle through all
    the keyframes of the animation. If you don’t declare `animation-duration`, the
    animation will still be run with a duration of `0s`, with `animationstart` and
    `animationend` still being fired even though the animation, taking `0s`, is imperceptible.
    Negative time values are not permitted for `animation-duration`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-duration`属性定义了动画完成所有关键帧循环所需的时间长度，单位可以是秒（`s`）或毫秒（`ms`）。如果不声明`animation-duration`，动画将仍然以`0s`的持续时间运行，尽管动画是不可察觉的，`animationstart`和`animationend`仍将被触发。`animation-duration`不允许负时间值。'
- en: 'When specifying a duration, you must include the second (`s`) or millisecond
    (`ms`) unit. If you have more than one animation, you can include a different
    `animation-duration` for each by including more than one comma-separated time
    duration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定持续时间时，必须包括秒（`s`）或毫秒（`ms`）单位。如果有多个动画，可以为每个动画包括不同的`animation-duration`，通过包括逗号分隔的多个时间持续值：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you supply an invalid value within your comma-separated list of durations
    (e.g., `animation-duration: 200ms, 0, 0.5s`) the entire declaration will fail,
    and it will behave as if `animation-duration: 0s` had been declared; `0` is not
    a valid time value. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/duration_broken_value.html)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '如果在持续时间的逗号分隔列表中提供了无效值（例如`animation-duration: 200ms, 0, 0.5s`），整个声明将失败，并且会表现为声明了`animation-duration:
    0s`一样；`0`不是有效的时间值。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/duration_broken_value.html)'
- en: 'Generally, you will want to include an `animation-duration` value for each
    `animation-name` provided. If you have only one duration, all the animations will
    last the same amount of time. Having fewer `animation-duration` values than `animation-name`
    values in your comma-separated property value list will not fail: rather, the
    values will be repeated as a group. Say we have the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于提供的每个`animation-name`，您会想要包含一个`animation-duration`值。如果只有一个持续时间，所有动画将持续相同的时间。在逗号分隔的属性值列表中，如果`animation-duration`值少于`animation-name`值，不会失败：而是作为一个组重复这些值。假设我们有以下情况：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `change_bgcolor` and `round` animations will be run over `200ms`, and the
    `spin` and `W` animations will run for `5s`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`change_bgcolor`和`round`动画将持续`200ms`，`spin`和`W`动画将持续`5s`。'
- en: 'If you have a greater number of `animation-duration` values than `animation-name`
    values, the extra values will be ignored. If one of the included animations does
    not exist, the series of animations and animation durations will not fail; the
    failed animation, along with its duration, is ignored:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`animation-duration`值多于`animation-name`值，额外的值将被忽略。如果其中一个动画不存在，动画序列和动画持续时间不会失败；失败的动画及其持续时间将被忽略：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the duration `5s` is associated with `spinner`. There is no
    `spinner` animation, though, so `spinner` doesn’t exist, and the `5s` and `spinner`
    are both ignored. Should a `spinner` animation come into existence, it will be
    applied to `<div>` elements and last 5 seconds.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，持续时间`5s`与`spinner`相关联。不过，`spinner`并不存在，因此`5s`和`spinner`都将被忽略。如果`spinner`动画出现，它将应用于`<div>`元素，并持续5秒。
- en: Declaring Animation Iterations
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明动画迭代
- en: Simply including the required `animation-name` will lead to the animation playing
    once, and only once, resetting to the initial state at the end of the animation.
    If you want to iterate through the animation more or fewer times than the default
    one time, use the `animation-iteration-count` property.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 只需包含所需的`animation-name`将导致动画播放一次，仅一次，在动画结束时重置到初始状态。如果希望比默认的一次更多或更少地迭代动画，请使用`animation-iteration-count`属性。
- en: 'By default, the animation will occur once (because the default value is `1`).
    If another value is given for `animation-iteration-count`, and there isn’t a negative
    value for the `animation-delay` property, the animation will repeat the number
    of times specified by the value of the property, which can be any number or the
    keyword `infinite`. The following declarations will cause their animations to
    be repeated 2, 5, and 13 times, respectively:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，动画将只播放一次（因为默认值为`1`）。如果为`animation-iteration-count`指定了其他值，并且`animation-delay`属性没有负值，则动画将重复指定属性值的次数，该值可以是任意数字或关键字`infinite`。以下声明将导致它们的动画分别重复2次、5次和13次：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the value of `animation-iteration-count` is not an integer, the animation
    will still run, but will cut off mid-iteration on the final iteration. For example,
    `animation-iteration-count: 1.25` will iterate through the animation one and a
    quarter times, cutting off 25% of the way through the second iteration. If the
    value is `0.25` on an 8-second animation, the animation will play about 25% of
    the way through, ending after 2 seconds.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `animation-iteration-count` 的值不是整数，则动画仍会运行，但会在最后一次迭代中间截断。例如，`animation-iteration-count:
    1.25` 会使动画运行一次并且四分之一次，即第二次迭代进行到 25% 的时候结束。如果值为 `0.25`，则在 8 秒动画中大约播放 25% 的时间后结束，总共
    2 秒。'
- en: Negative numbers are not permitted. If an invalid value is given, the default
    value of `1` will lead to a default single iteration. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/odditeration.html)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许使用负数。如果提供了无效的值，则默认值 `1` 会导致默认的单次迭代。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/odditeration.html)
- en: 'Interestingly, `0` is a valid value for the `animation-iteration-count` property.
    When set to `0`, the animation still occurs, but zero times. This is similar to
    setting `animation-duration: 0s`: it will throw both an `animationstart` and an
    `animationend` event.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '有趣的是，`0` 是 `animation-iteration-count` 属性的有效值。当设置为 `0` 时，动画仍然会发生，但不执行任何次数。这类似于设置
    `animation-duration: 0s`：它会触发 `animationstart` 和 `animationend` 事件。'
- en: 'If you are attaching more than one animation to an element or pseudo-element,
    include a comma-separated list of values for `animation-name`, `animation-duration`,
    and `animation-iteration-count`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要将多个动画附加到一个元素或伪元素上，请在 `animation-name`、`animation-duration` 和 `animation-iteration-count`
    的值中包含逗号分隔的列表：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `iteration-count` values (and all other animation property values) will
    be assigned in the order of the comma-separated `animation-name` property value.
    Extra values are ignored. Missing values cause the existing values to be repeated,
    as with `animation-iteration-count` in the preceding scenario.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`iteration-count` 值（和所有其他动画属性值）将按逗号分隔的 `animation-name` 属性值的顺序赋值。多余的值将被忽略。缺少的值会导致现有值重复，就像前述情况中的
    `animation-iteration-count` 一样。'
- en: 'The preceding example has more name values than count values, so the count
    values will repeat: `red` and `blue` will iterate three times, and `white` will
    iterate five times. We have the same number of name values as duration values;
    therefore, the duration values will not repeat. The `red` animation lasts 2 seconds,
    iterating three times, and therefore will run for a total of 6 seconds. The `white`
    animation lasts 4 seconds, iterating five times, for a total of 20 seconds. The
    `blue` animation is 6 seconds per iteration with the repeated three iterations
    value, animating for a total of 18 seconds.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子中名称值比计数值多，因此计数值将重复：`red` 和 `blue` 将迭代三次，而 `white` 将迭代五次。名称值和持续时间值数量相同，因此持续时间值不会重复。`red`
    动画持续 2 秒，迭代三次，因此总计运行 6 秒。`white` 动画持续 4 秒，迭代五次，总计运行 20 秒。`blue` 动画每次迭代 6 秒，重复三次，总共动画了
    18 秒。
- en: Invalid values will invalidate the entire declaration, leading to the animations
    being played once each.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的值会使整个声明无效，导致每个动画只播放一次。
- en: 'If we want all three animations to end at the same time, even though their
    durations differ, we can control that with `animation-iteration-count`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望所有三个动画在相同的时间结束，即使它们的持续时间不同，我们可以通过 `animation-iteration-count` 控制：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, the `red`, `white`, and `blue` animations will last for a total
    of 12 seconds each, because the product of the durations and iteration counts
    in each case totals 12 seconds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`red`、`white` 和 `blue` 动画每个持续 12 秒，因为每种情况下持续时间和迭代次数的乘积总共为 12 秒。
- en: You can also include the keyword `infinite` instead of a number, for a duration.
    This will make the animation iterate forever, or until something makes it stop,
    such as removing the animation name, removing the element from the DOM, or pausing
    the play state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以用关键词 `infinite` 替代数字，表示动画将永远迭代，或者直到某些条件使其停止，比如移除动画名称、从 DOM 中移除元素或者暂停播放状态。
- en: Setting an Animation Direction
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置动画方向
- en: With the `animation-direction` property, you can control whether the animation
    progresses from the 0% keyframe to the 100% keyframe, or from the 100% keyframe
    to the 0% keyframe. You can also define whether all the iterations progress in
    the same direction, or set every other animation cycle to progress in the opposite
    direction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`animation-direction`属性，您可以控制动画是从0%关键帧到100%关键帧，还是从100%关键帧到0%关键帧进行。您还可以定义所有迭代是否按相同方向进行，或者设置每隔一个动画周期以相反方向进行。
- en: 'The `animation-direction` property defines the direction of the animation’s
    progression through the keyframes. It has four possible values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-direction`属性定义了动画通过关键帧的进度方向。它有四个可能的值：'
- en: '`normal`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`normal`'
- en: Each iteration of the animation progresses from the 0% keyframe to the 100%
    keyframe; this value is the default.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的每个迭代都从0%关键帧进展到100%关键帧；这个值是默认值。
- en: '`reverse`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`'
- en: Sets each iteration to play in reverse keyframe order, always progressing from
    the 100% keyframe to the 0% keyframe. Reversing the animation direction also reverses
    the `animation-timing-function` (which is described in [“Changing the Internal
    Timing of Animations”](#changing-the-internal-timing-of-animations)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个迭代设置为以反向关键帧顺序播放，始终从100%关键帧进展到0%关键帧。反转动画方向还会反转`animation-timing-function`（在[“更改动画的内部时间”](#changing-the-internal-timing-of-animations)中描述）。
- en: '`alternate`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`alternate`'
- en: The first iteration (and each subsequent odd-numbered iteration) proceeds from
    0% to 100%, and the second iteration (and each subsequent even-numbered cycle)
    reverses direction, proceeding from 100% to 0%. This has an effect only if you
    have more than one iteration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个迭代（以及每个后续的奇数迭代）从0%到100%进行，而第二个迭代（以及每个后续的偶数周期）将反向进行，从100%到0%进行。只有当你有多个迭代时才会产生影响。
- en: '`alternate-reverse`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`alternate-reverse`'
- en: 'Similar to the `alternate` value, except it’s the reverse. The first iteration
    (and each subsequent odd-numbered iteration) will proceed from 100% to 0%, and
    the second iteration (and each subsequent even-numbered cycle) reverses direction,
    proceeding from 100% to 0%:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与`alternate`值类似，只是它是反向的。第一个迭代（以及每个后续的奇数迭代）将从100%到0%进行，而第二个迭代（以及每个后续的偶数周期）将反向进行，从100%到0%进行：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we are bouncing a ball, but we want to start by dropping it,
    not by throwing it up in the air: we want it to alternate between going down and
    up, rather than up and down, so `animation-direction: alternate-reverse` is the
    most appropriate value for our needs. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball6.html)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们弹跳一个球，但我们想从扔它而不是向上抛它开始：我们希望它在下落和上升之间交替，而不是上升和下降，所以`animation-direction:
    alternate-reverse`是我们需求的最合适的值。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball6.html)'
- en: This is a rudimentary way of making a ball bounce. When balls are bouncing,
    they are moving slowest when they reach their apex and fastest when they reach
    their nadir. We include this example here to illustrate the `alternate-reverse`
    animation directions. We’ll revisit the bouncing animation to make it more realistic
    with the addition of timing (in [“Changing the Internal Timing of Animations”](#changing-the-internal-timing-of-animations)).
    We’ll also discuss how, when the animation is iterating in the reverse direction,
    the `animation-timing-function` is reversed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个制作球反弹的基本方法。当球反弹时，它们在达到最高点时移动最慢，在达到最低点时移动最快。我们在这里包含这个例子是为了说明`alternate-reverse`动画方向。我们将重新审视弹跳动画，通过添加时间（在[“更改动画的内部时间”](#changing-the-internal-timing-of-animations)中）使其更加逼真。我们还将讨论当动画以反向迭代时，`animation-timing-function`如何反转。
- en: Delaying Animations
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟动画
- en: The `animation-delay` property defines how long the browser waits after the
    animation is attached to the element before beginning the first animation iteration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-delay`属性定义了动画附加到元素后在开始第一次动画迭代之前浏览器等待的时间。'
- en: By default, an animation begins iterating as soon as it is applied to the element,
    with a 0-second delay. A positive value for `animation-delay` delays the start
    of the animation until the time listed as the value of the property has elapsed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，动画在附加到元素时立即开始迭代，延迟为0秒。`animation-delay`为正值将延迟动画的开始，直到属性值所列时间已过。
- en: 'Negative values for `animation-delay` are allowed and create interesting effects.
    A negative delay will execute the animation immediately but will begin animating
    the element partway through the attached animation. For example, if `animation-delay:
    -4s` and `animation-duration: 10s` are set on an element, the animation will begin
    immediately but will start approximately 40% of the way through the first animation,
    and will end 6 seconds later.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-delay`的负值是允许的，并且能产生有趣的效果。负延迟会立即执行动画，但会在所附的动画的中途开始动画元素。例如，如果在一个元素上设置了`animation-delay:
    -4s`和`animation-duration: 10s`，动画会立即开始，但会大约从第一个动画的40%处开始，并在之后的6秒结束。'
- en: 'We say *approximately* because the animation will not necessarily start at
    precisely the 40% keyframe block: when the 40% mark of an animation occurs depends
    on the value of the `animation-timing-function`. If `animation-timing-function:
    linear` is set, the animation state will start 40% of the way through the animation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '我们说*大约*，因为动画不一定会准确地从40%关键帧块开始：动画的40%标记发生的时间取决于`animation-timing-function`的值。如果设置了`animation-timing-function:
    linear`，动画状态将从动画的40%处开始：'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this `linear` animation example, we have a 10-second animation with a delay
    of –4 seconds. In this case, the animation will start immediately 40% of the way
    through the animation, with the `<div>` translated 400 pixels to the right of
    its original position, and last only 6 seconds. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/fortypercent.html)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`linear`动画示例中，我们有一个持续10秒的动画，延迟为-4秒。在这种情况下，动画将立即开始，从动画的40%处开始，`<div>`元素向右移动400像素，持续时间仅为6秒。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/fortypercent.html)
- en: 'If an animation is set to occur 10 times, with a delay of –600 milliseconds
    and an animation duration of 200 milliseconds, the element will start animating
    right away, at the beginning of the fourth iteration:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画设置为发生10次，延迟为-600毫秒，动画持续时间为200毫秒，元素将立即开始动画，即在第四次迭代开始时：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instead of animating for 2,000 milliseconds (200 ms × 10 = 2,000 ms, or 2 seconds),
    starting in the normal direction, the ball will animate for 1,400 milliseconds
    (or 1.4 seconds) with the animation starting immediately—but at the start of the
    fourth iteration, *and* in the reverse direction.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是以正常方向开始进行2000毫秒（200毫秒 × 10 = 2000毫秒，或2秒）的动画，球将以1400毫秒（或1.4秒）的动画时间立即开始，但在第四次迭代的开始处，并且是在反向方向上。
- en: The animation starts out in reverse because `animation-direction` is set to
    `alternate`, meaning every even-numbered iteration proceeds from the 100% keyframe
    to the 0% keyframe. The fourth iteration, which is an even-numbered iteration,
    is the first visible iteration. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball_animation_delay_negative.html)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 动画从反向开始，因为`animation-direction`设置为`alternate`，意味着每个偶数次迭代从100%关键帧到0%关键帧。第四次迭代，即偶数次迭代，是第一个可见的迭代。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball_animation_delay_negative.html)
- en: In this case, the animation will throw the `animationstart` event immediately.
    The `animationend` event will occur at the 1,400-millisecond mark. The ball will
    be tossed up, rather than bounced, throwing six `animationiteration` events, after
    200, 400, 600, 800, 1,000, and 1,200 milliseconds. While the iteration count is
    set to 10, we get only six `animationiteration` events because we are getting
    only seven iterations; three iterations don’t occur because of the negative `animation-delay`,
    and the last iteration concludes at the same time as the `animationend` event.
    Remember, when an `animationiteration` event would occur at the same time as an
    `animationend` event, the `animationiteration` event does not occur.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，动画将立即抛出`animationstart`事件。`animationend`事件将在1400毫秒时发生。球会被抛起，而不是弹跳，产生六次`animationiteration`事件，分别在200、400、600、800、1000和1200毫秒后。虽然迭代次数设置为10，但只有六次`animationiteration`事件，因为由于负的`animation-delay`，有三次迭代不会发生，并且最后一次迭代与`animationend`事件同时结束。请记住，当`animationiteration`事件与`animationend`事件同时发生时，`animationiteration`事件不会发生。
- en: Let’s take a deeper look at animation events before continuing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们深入了解动画事件。
- en: Exploring Animation Events
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索动画事件
- en: 'The three types of animation events are `animationstart`, `animationiteration`,
    and `animationend`. Each event has three read-only properties: `animationName`,
    `elapsedTime`, and `pseudoElement`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 三种类型的动画事件是`animationstart`、`animationiteration`和`animationend`。每个事件都有三个只读属性：`animationName`、`elapsedTime`和`pseudoElement`。
- en: 'The `animationstart` event fires at the start of the animation: after the `animation-delay`
    (if present) has expired, or immediately if no delay is set. If a negative `animation-delay`
    value is present, the `animationstart` will fire immediately, with an `elapsedTime`
    equal to the absolute value of the delay.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`animationstart`事件在动画开始时触发：在`animation-delay`（如果存在）过期后触发，如果没有设置延迟，则立即触发。如果存在负的`animation-delay`值，则`animationstart`将立即触发，`elapsedTime`等于延迟的绝对值。'
- en: 'The `animationend` event fires when the animation finishes. If the `animation-iteration-count`
    is set to `infinite`, then as long as the `animation-duration` is set to a time
    greater than `0`, the `animationend` event will never fire. If the `animation-duration`
    is set or defaults to 0 seconds, even when the iteration count is infinite, `animationstart`
    and `animationend` will occur virtually simultaneously, and in that order. These
    are illustrated in the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`animationend`事件在动画结束时触发。如果`animation-iteration-count`设置为`infinite`，则只要`animation-duration`设置为大于`0`的时间，`animationend`事件就永远不会触发。如果`animation-duration`设置或默认为0秒，即使迭代次数为无限，`animationstart`和`animationend`也会几乎同时发生，且顺序如上。'
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `animationiteration` event fires *between* iterations. The `animationend`
    event [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/events.html)
    fires at the conclusion of iterations that do not occur at the same time as the
    conclusion of the animation itself; thus, the `animationiteration` and `animationend`
    events do *not* fire simultaneously:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`animationiteration`事件在迭代之间触发。`animationend`事件在不同时发生的迭代的结束时触发；因此，`animationiteration`和`animationend`事件不会同时触发。'
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the `.noAnimationIteration` example, with the `animation-iteration-count`
    set to a single occurrence, the animation ends at the conclusion of the first
    and only iteration. Whenever the `animationiteration` event would occur at the
    same time as an `animationend` event, the `animationend` event occurs but the
    `animationiteration` event does not.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.noAnimationIteration`示例中，将`animation-iteration-count`设置为一次时，动画在第一次迭代结束时结束。每当`animationiteration`事件与`animationend`事件同时发生时，`animationend`事件会发生，但`animationiteration`事件不会发生。
- en: 'When the `animation-iteration-count` property is omitted, or when its value
    is `1` or less, no `animationiteration` event will be fired. As long as an iteration
    finishes (even if it’s a partial iteration) and another iteration begins, if the
    duration of that subsequent iteration is greater than `0s`, an `animationiteration`
    event will be fired:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当省略`animation-iteration-count`属性或其值为`1`或更少时，不会触发`animationiteration`事件。只要一个迭代完成（即使是部分迭代）并且另一个迭代开始，如果后续迭代的持续时间大于`0s`，将触发`animationiteration`事件。
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When an animation iterates through fewer cycles than listed in the `animation-iteration-count`
    because of a negative `animation-delay`, there are no `animationiteration` events
    for the cycles that didn’t occur. The preceding example code has no `animationiteration`
    events, as the first three cycles do not occur (because of the `-3s` `animation-delay`),
    and the last cycle finishes at the same time the animation ends. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/events2.html)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画由于负的`animation-delay`而迭代的周期少于`animation-iteration-count`中列出的周期时，未发生的周期没有`animationiteration`事件。前面的示例代码没有`animationiteration`事件，因为前三个周期不会发生（由于`-3s`的`animation-delay`），最后一个周期在动画结束时同时完成。
- en: In that example, the `elapsedTime` on the `animationstart` event is `3`, as
    it is equal to the absolute value of the delay.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在该示例中，`animationstart`事件的`elapsedTime`为`3`，因为它等于延迟的绝对值。
- en: Animation chaining
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画串联
- en: 'You can use `animation-delay` to chain animations together so the next animation
    starts immediately after the conclusion of the preceding animation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`animation-delay`来串联动画，使下一个动画在前一个动画结束后立即开始：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the `red` animation starts after a 3-second delay and lasts
    1 second, meaning the `animationend` event occurs at the 4-second mark. This example
    starts each subsequent animation at the conclusion of the previous animation.
    This is known as *CSS animation chaining*. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain.html)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`red`动画在延迟3秒后开始，并持续1秒，这意味着`animationend`事件在第4秒发生。这个示例在每个后续动画开始时都会接续前一个动画。这被称为*CSS动画链接*。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain.html)
- en: By including a 4-second delay on the second animation, the `orange` animation
    will begin interpolating the `@keyframe` property values at the 4-second mark,
    starting the `orange` animation immediately at the conclusion of the `red` animation.
    The `orange` animation concludes at the 7-second mark—it lasts 3 seconds, starting
    after a 4-second delay—which is the delay set on the third, or `yellow`, animation,
    making the `yellow` animation begin immediately after the `orange` animation ends.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个动画上包含4秒的延迟，`orange`动画将在第4秒标记处开始插值`@keyframe`属性值，立即在`red`动画结束时开始`orange`动画。`orange`动画在第7秒结束，它持续3秒，从第三个或`yellow`动画上设置的延迟开始，使得`yellow`动画在`orange`动画结束后立即开始。
- en: 'This is an example of chaining animations on a single element. You can also
    use the `animation-delay` property to chain the animations for different elements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在单个元素上链接动画的一个示例。你也可以使用`animation-delay`属性来链接不同元素的动画：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you want a group of list items to animate in order, [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain2a.html)
    appearing as if the animations were chained in sequence, the `animation-delay`
    of each list item should be the combined time of the `animation-duration` and
    `animation-delay` of the previous animation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一组列表项按顺序动画，[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain2a.html)
    看起来像是动画按顺序链接，每个列表项的`animation-delay`应该是前一个动画的`animation-duration`和`animation-delay`的总和。
- en: 'While you can use JavaScript and the `animationend` event from one animation
    to determine when to attach a subsequent animation, which we discuss shortly,
    the `animation-delay` property is an appropriate method of using CSS animation
    properties to chain animations. There is one caveat: animations are the lowest
    priority on the UI thread. Therefore, if you have a script running that is occupying
    the UI thread, depending on the browser and which properties are being animated
    and what property values are set on the element, the browser may let the delays
    expire while waiting until the UI thread is available before starting more animations.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用JavaScript和从一个动画的`animationend`事件来确定何时附加下一个动画（我们稍后会讨论），但是`animation-delay`属性是使用CSS动画属性链接动画的合适方法。有一个警告：动画是UI线程上的最低优先级。因此，如果你有一个占用UI线程的脚本在运行，根据浏览器和哪些属性正在被动画化以及元素上设置了什么属性值，浏览器可能会在等待UI线程可用之前让延迟过期，然后再开始更多动画。
- en: 'If you are able to rely on JavaScript, another way of chaining animations is
    listening for `animationend` events to start subsequent animations: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain2.html)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能依赖JavaScript，另一种链接动画的方法是监听`animationend`事件来启动后续动画：[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain2.html)
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, there is an event handler on each of the first four list items,
    listening for that list item’s `animationend` event. When the `animationend` event
    occurs, the event listeners add an `animation-name` to the subsequent list item.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，前四个列表项都有一个事件处理程序，监听该列表项的`animationend`事件。当`animationend`事件发生时，事件监听器会向后续的列表项添加一个`animation-name`。
- en: As you can see in the styles, this animation chaining method doesn’t employ
    `animation-delay` at all. Instead, the JavaScript event listeners attach animations
    to each element by setting the `animation-name` property when the `animationend`
    event is thrown.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在样式中看到的那样，这种动画链接方法根本不使用`animation-delay`。相反，JavaScript事件监听器在抛出`animationend`事件时通过设置`animation-name`属性向每个元素附加动画。
- en: You’ll also note that the `animation-name` is included for only the first list
    item. The other list items have only an `animation-duration` with no `animation-name`,
    and therefore no attached animations. Adding `animation-name` via JavaScript is
    what attaches and starts the animation, at least in this example. To start or
    restart an animation, the animation name must be removed and then added back—at
    which point all the animation properties take effect, including `animation-delay`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，`animation-name`仅包含在第一个列表项中。其他列表项仅具有`animation-duration`而没有`animation-name`，因此没有附加的动画。通过JavaScript添加`animation-name`是附加并启动动画的方法，至少在此示例中是这样。要启动或重新启动动画，必须删除然后重新添加动画名称，此时所有动画属性均生效，包括`animation-delay`。
- en: 'Instead of writing the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是写以下内容：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'we could have written this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写成这样：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the `blue` animation name is added to the fifth list item at the same time
    we added `green`, the delay on the fifth element takes effect at that point in
    time and starts expiring.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当`blue`动画名称与我们添加`green`同时添加到第五个列表项时，第五个元素上的延迟会在此时生效并开始计时。
- en: While changing the values of animation properties (other than name) on the element
    during an animation has no effect on the animation, removing or adding an `animation-name`
    does have an impact. You can’t change the animation duration from `100ms` to `400ms`
    in the middle of an animation. You can’t switch the delay from `-200ms` to `5s`
    once the delay has already been applied. You can, however, stop and start the
    animation by removing it and reapplying it. In the preceding JavaScript example,
    we started the animations by applying them to the elements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在动画过程中改变元素上的动画属性值（除名称外）不会影响动画，但添加或移除`animation-name`确实会产生影响。您无法在动画中间将动画持续时间从`100ms`更改为`400ms`。一旦已经应用了延迟，您就无法将延迟从`-200ms`切换到`5s`。但是，您可以通过删除并重新应用来停止和启动动画。在前面的JavaScript示例中，我们通过将动画应用于元素来启动动画。
- en: 'In addition, setting `display: none` on an element terminates any animation.
    Updating the `display` back to a visible value restarts the animation from the
    beginning. If `animation-delay` has a positive value, the delay will have to expire
    before the `animationstart` event happens and any animations occur. If the delay
    is negative, the animation will start midway through an iteration, exactly as
    it would have if the animation had been applied any other way.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，将`display: none`设置为一个元素会终止任何动画。将`display`更新回可见值会从头开始动画。如果`animation-delay`有一个正值，那么在`animationstart`事件发生和任何动画发生之前必须等待延迟时间。如果延迟是负值，则动画将在迭代的中途开始，正如任何其他应用动画一样。'
- en: Animation iteration delay
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画迭代延迟
- en: What is an animation iteration delay? Sometimes you want an animation to occur
    multiple times but want to wait a specific amount of time between each iteration.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是动画迭代延迟？有时您希望动画多次发生，但想在每次迭代之间等待特定的时间。
- en: While there is no such thing as an animation iteration delay property, you can
    employ the `animation-delay` property, incorporate delays within your keyframe
    declaration, or use JavaScript to fake it. The best method for faking it depends
    on the number of iterations, performance, and whether the delays are all equal
    in length.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不存在动画迭代延迟属性，但可以使用`animation-delay`属性，在关键帧声明中加入延迟，或使用JavaScript来模拟。模拟的最佳方法取决于迭代次数、性能以及延迟是否均匀。
- en: 'Let’s say you want your element to grow three times, but want to wait 4 seconds
    between each 1-second iteration. You can include the delay within your keyframe
    definition and iterate through it three times:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望您的元素增长三次，但希望在每个1秒的迭代之间等待4秒钟。您可以在关键帧定义中包含延迟，并通过它进行三次迭代：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note the first keyframe selector is at the 80% mark and matches the default
    state. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay1.html)
    This will animate your element three times: it stays in the default state for
    80% of the 5-second animation (not changing for 4 seconds) and then moves from
    green to yellow and small to big over the last 1 second of the animation before
    iterating again, stopping after three iterations.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个关键帧选择器位于80%的位置，并与默认状态匹配。 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay1.html)
    这将使您的元素动画化三次：它在5秒动画的80%时间内保持默认状态（4秒内不变化），然后在动画的最后1秒内从绿色变为黄色、从小变大，然后再次迭代，在三次迭代后停止。
- en: This method works for any number of iterations of the animation. Unfortunately,
    it is a good solution only if the delay between each iteration is identical and
    you don’t want to reuse the animation with any other timing, such as a delay of
    6 seconds. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay.html)
    If you want to change the delay between each iteration while not changing the
    duration of the change in size and color, you have to write a new `@keyframes`
    definition.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于动画的任意迭代次数。不幸的是，它只在每次迭代之间的延迟相同且不想以任何其他时序重复使用动画时才是一个好的解决方案，例如6秒的延迟。 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay.html)
    如果你想要改变每次迭代之间的延迟而不改变大小和颜色变化的持续时间，你必须编写一个新的`@keyframes`定义。
- en: 'To enable multiple iteration delays between animations, we could create a single
    animation and bake the effect of three different delays into the animation keyframe
    definition:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要在动画之间启用多个迭代延迟，我们可以创建一个单独的动画，并将三种不同延迟的效果编码到动画关键帧定义中：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This method may be more difficult to code and maintain, however. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay2.html)
    It works for only a single cycle of the animation. To change the number of animations
    or the iteration delay durations, another `@keyframes` declaration would be required.
    This example is even less robust than the previous one, but it does allow for
    different between-iteration delays.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法可能更难编码和维护。 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay2.html)
    它仅适用于动画的单个周期。要更改动画的数量或迭代延迟持续时间，需要另一个`@keyframes`声明。这个示例甚至比前一个更不健壮，但它确实允许在迭代之间使用不同的延迟。
- en: 'A solution is specifically allowed in the animation specification: declare
    an animation multiple times, each with a different `animation-delay` value: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay3.html)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别允许在动画规范中的解决方案是：多次声明动画，每次使用不同的`animation-delay`值： [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay3.html)
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we’ve attached the animation three times, each with a different delay.
    In this case, each animation iteration concludes before the next one proceeds.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将动画附加了三次，每次使用不同的延迟。在这种情况下，每次动画迭代结束后才会进行下一次。
- en: If animations overlap while they’re concurrently animating, the values will
    be the values from the last declared animation. As is true whenever multiple animations
    are changing an element’s property at the same time, the animation that occurs
    last in the sequence of animation names will override any animations occurring
    before it in the list of names. In declaring three `color_and_scale` animations
    but at different intervals, the value of the property of the last iteration of
    the `color_and_scale` animation will override the values of the previous ones
    that haven’t yet concluded. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay4.html)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画在同时进行时重叠，值将是最后声明的动画的值。与同时更改元素属性的多个动画一样，序列中最后声明的动画将覆盖列表中之前动画的任何动画。声明三个不同间隔的`color_and_scale`动画，`color_and_scale`动画的最后一次迭代的属性值将覆盖尚未结束的前几次迭代的值。
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay4.html)
- en: 'The safest, most robust, and most cross-browser-friendly method of faking an
    animation iteration delay property is to use JavaScript’s animation events. Detach
    the animation from the element on `animationend`, and then reattach it after the
    iteration delay. If all the iteration delays are the same, you can use `setInterval`;
    if they vary, use `setTimeout`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟动画迭代延迟属性的最安全、最健壮且最跨浏览器友好的方法是使用JavaScript的动画事件。在`animationend`时从元素上分离动画，然后在迭代延迟后重新附加它。如果所有迭代延迟都相同，可以使用`setInterval`；如果它们不同，使用`setTimeout`：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Changing the Internal Timing of Animations
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变动画的内部时序
- en: All right! The scripting was fun, but let’s get back to straight CSS and talk
    about timing functions. Similar to the `transition-timing-function` property,
    the `animation-timing-function` property describes how the animation will progress
    from one keyframe to the next.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！脚本编写很有趣，但让我们回到纯CSS并谈论时间函数。类似于`transition-timing-function`属性，`animation-timing-function`属性描述了动画如何从一个关键帧进展到下一个。
- en: Other than the step timing functions, described in [“Using step timing functions”](#step-timing-functions),
    the timing functions are all Bézier curves. Just like the `transition-timing-function`,
    the CSS specification provides for five predefined Bézier curve keywords, which
    we described in the preceding chapter (see [Table 18-1](ch18.html#cubic_bezier)
    and [Figure 18-3](ch18.html#tr_fig0203)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了步进时间函数，描述在[“使用步进时间函数”](#step-timing-functions)中，所有时间函数都是贝塞尔曲线。就像`transition-timing-function`一样，CSS规范提供了五个预定义的贝塞尔曲线关键字，我们在前一章中描述了这些（参见[表18-1](ch18.html#cubic_bezier)和[图18-3](ch18.html#tr_fig0203)）。
- en: A handy tool to visualize Bézier curves and to create your own is [Lea Verou’s
    cubic Bézier visualizer](https://cubic-bezier.com).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的工具用于可视化贝塞尔曲线并创建自定义曲线是[Lea Verou的贝塞尔曲线可视化器](https://cubic-bezier.com)。
- en: The default `ease` has a slow start, then speeds up, and ends slowly. This function
    is similar to `ease-in-out`, which has a greater acceleration at the beginning.
    The `linear` timing function, as the name describes, creates an animation that
    animates at a constant speed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`ease`具有缓慢开始，然后加速，并以缓慢结束。这个函数类似于`ease-in-out`，其开始时加速度更大。`linear`时间函数，如其名称所示，创建动画以恒定速度运行。
- en: The `ease-in` timing function creates an animation that is slow to start, gains
    speed, and then stops abruptly. The opposite `ease-out` timing function starts
    at full speed, then slows progressively as it reaches the conclusion of the animation
    iteration.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ease-in`时间函数创建一个缓慢开始、加速，然后突然停止的动画。相反的`ease-out`时间函数从全速开始，然后随着动画迭代的结束逐渐减速。'
- en: 'If none of these suit your needs, you can create your own Bézier curve timing
    function by passing four values, such as the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些都不符合您的需求，您可以通过传递四个值来创建自己的贝塞尔曲线时间函数，如下所示：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While the *x* values must be between 0 and 1, by using values for *y* that
    are greater than 1 or less than 0, you can create a bouncing effect, making the
    animation bounce up and down between values, rather than going consistently in
    a single direction. Consider the following timing function, whose rather outlandish
    Bézier curve is (partly) illustrated in [Figure 19-1](#an-outlandish-bezier-curve):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*x*值必须在0和1之间，但通过使用*y*值大于1或小于0的值，您可以创建一个反弹效果，使动画在值之间上下弹跳，而不是在单一方向上连续进行。考虑以下时间函数，其相当奇异的贝塞尔曲线部分显示在[图19-1](#an-outlandish-bezier-curve)中：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![css5 1901](assets/css5_1901.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1901](assets/css5_1901.png)'
- en: Figure 19-1\. An outlandish Bézier curve
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图19-1\. 一个奇异的贝塞尔曲线
- en: This `animation-timing-function` curve makes the animated property’s values
    go outside the boundaries of the values set in the `0%` and `100%` keyframes.
    In this example, we are shrinking an element from `500px` to `100px`. However,
    because of the `cubic-bezier` values, the element we’re shrinking will actually
    grow to be wider than the `500px` width defined in the `0%` keyframe and narrower
    than the `100px` width defined in the `100%` keyframe, as shown in [Figure 19-2](#an_fig0303).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此`animation-timing-function`曲线使动画属性的值超出了在`0%`和`100%`关键帧中设置的值的范围。在此示例中，我们正在将一个元素从`500px`缩小到`100px`。但由于`cubic-bezier`值的影响，我们要缩小的元素实际上会比在`0%`关键帧中定义的`500px`宽度更宽，并且比在`100%`关键帧中定义的`100px`宽度更窄，如[图19-2](#an_fig0303)所示。
- en: '![css5 1902](assets/css5_1902.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1902](assets/css5_1902.png)'
- en: Figure 19-2\. Effect of outlandish Bézier curve
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图19-2\. 奇异贝塞尔曲线的效果
- en: 'In this scenario, the element starts with a width of `500px`, defined in the
    `0%` keyframe. It then quickly shrinks to a width of about `40px`, which is narrower
    than `width: 100px` defined in the `100%` keyframe. From there, it slowly expands
    to about `750px` wide, which is larger than the original width of `500px`. It
    then quickly shrinks back to `width: 100px`, ending the animation iteration. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/cubicbezierprint.html)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，元素从`500px`的宽度开始，在`0%`关键帧中定义。然后它迅速收缩到约`40px`的宽度，比`100%`关键帧中定义的`width:
    100px`还要窄。从那里开始，它慢慢扩展到约`750px`宽，这比原始的`500px`宽度还要大。然后它迅速收缩回到`width: 100px`，结束动画迭代。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/cubicbezierprint.html)'
- en: You may have realized that the curve created by our animation is the same curve
    as the Bézier curve. Just as the S-curve goes outside the normal bounding box,
    the width of the animated element goes narrower than the smaller width we set
    of `100px`, and wider than the larger width we set of `500px`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，我们动画生成的曲线与贝塞尔曲线相同。正如 S 曲线超出了正常边界框一样，动画元素的宽度比我们设置的 `100px` 更窄，并且比设置的
    `500px` 更宽。
- en: The Bézier curve has the appearance of a snake because one *y* coordinate is
    positive, and the other negative. If both are positive values greater than 1 or
    both are negative values less than –1, the Bézier curve is arc-shaped, going above
    or below one of the values set, but not bouncing out of bounds on both ends like
    the S-curve.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线的外观像一条蛇，因为一个 *y* 坐标为正，另一个为负。如果两个值都是大于1的正值或者都是小于–1的负值，贝塞尔曲线是弧形的，超过或低于设置的一个值，但不像
    S 曲线那样两端都超出边界。
- en: Any timing function declared with `animation-timing-function` sets the timing
    for the normal animation direction, when the animation is progressing from the
    `0%` keyframe to the `100%` keyframe. When the animation is running in the reverse
    direction, from the `100%` keyframe to the `0%` keyframe, the animation timing
    function is reversed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用 `animation-timing-function` 声明的时间函数都设置了正常动画方向的时间，当动画从 `0%` 关键帧进展到 `100%`
    关键帧时。当动画以反向方式运行时，从 `100%` 关键帧到 `0%` 关键帧，动画时间函数被反转。
- en: 'Remember the bouncing-ball example in [“animation-direction”](#animation-direction)?
    The bouncing wasn’t very realistic, because the original example defaulted to
    `ease` for its timing function. With `animation-timing-function`, we can apply
    `ease-in` to the animation so that when the ball is dropping, it gets faster as
    it nears its nadir at the `100%` keyframe. When it is bouncing upward, it animates
    in the reverse direction, from `100%` to `0%`, so the `animating-timing-function`
    is reversed as well—in this case, to `ease-out`—slowing down as it reaches the
    apex: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball1.html)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得[“动画方向”](#animation-direction)中的反弹球示例吗？反弹效果并不是很真实，因为原始示例默认使用 `ease` 作为其时间函数。使用
    `animation-timing-function`，我们可以将 `ease-in` 应用于动画，使得球在下降时在接近 `100%` 关键帧时变得更快。当它向上反弹时，动画以相反方向进行，从
    `100%` 到 `0%`，因此动画时间函数也被反转——在这种情况下是 `ease-out`，在达到顶点时减慢速度：[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball1.html)
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using step timing functions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用步进时间函数
- en: The step timing functions, `step-start`, `step-end`, and `steps()`, aren’t Bézier
    curves. They’re not curves at all. Rather, they’re *tweening* definitions. The
    `steps()` function is most useful when it comes to character or sprite animation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 步进时间函数 `step-start`、`step-end` 和 `steps()` 不是贝塞尔曲线。它们根本不是曲线。相反，它们是 *tweening*
    定义。在角色或精灵动画中，`steps()` 函数最有用。
- en: 'The `steps()` function divides the animation into a series of equal-length
    steps. The function takes two parameters: the number of steps and the change point
    (more on that in a moment).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`steps()` 函数将动画分为一系列相等长度的步骤。该函数接受两个参数：步数和变化点（稍后详细介绍）。'
- en: The number-of-steps parameter value must be a positive integer. The animation
    length will be divided equally into the number of steps provided. For example,
    if the animation duration is 1 second and the number of steps is 5, the animation
    will be divided into five 200-millisecond steps, with the element being redrawn
    to the page five times, at 200-millisecond intervals, moving 20% through the animation
    at each interval.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 步数参数值必须是正整数。动画长度将被均等地分成提供的步数。例如，如果动画持续时间为1秒，步数为5，则动画将被分为五个200毫秒的步骤，元素将在每个间隔的200毫秒内重新绘制到页面上，每个间隔移动动画的20%。
- en: To understand how this works, think of a flip book. Each page in a flip book
    contains a single drawing or picture that changes slightly from one page to the
    next, like one frame from a movie reel stamped onto each page. When the pages
    of a flip book are rapidly flipped through (hence the name), the pictures appear
    as an animated motion. You can create similar animations with CSS by using an
    image sprite, the `background-position` property, and the `steps()` timing function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解其工作原理，请想象一本翻页书。翻页书中的每一页都包含一幅稍有不同的绘画或图片，就像电影胶片中的一帧图像被印在每一页上一样。当快速翻动翻页书的页面时（因此得名），图片就会呈现出动画效果。通过使用图像雪碧图、`background-position`
    属性和 `steps()` 时间函数，您可以使用 CSS 创建类似的动画效果。
- en: '[Figure 19-3](#an_sprite) shows an image sprite containing several images that
    change just slightly, like the drawings on the individual pages of a flip book.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19-3](#an_sprite) 展示了一个包含几个图像的雪碧图，这些图像仅略有不同，就像翻页书的各个页面上的绘画一样。'
- en: '![css5 1903](assets/css5_1903.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1903](assets/css5_1903.png)'
- en: Figure 19-3\. Sprite of dancing
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-3\. 舞蹈雪碧图
- en: We put all of our slightly differing images into a single image called a *sprite*.
    Each image in our sprite is a frame in the single animated image we’re creating.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有略有不同的图像放入一个称为 *雪碧图* 的单个图像中。我们雪碧图中的每个图像都是我们正在创建的单个动画图像中的一帧。
- en: We then create a container element that is the size of a single image of our
    sprite, and attach the sprite as the container element’s background image. We
    animate the `background-position`, using the `steps()` timing function so we see
    only a single instance of the changing image of our sprite at a time. The number
    of steps in our `steps()` timing function is the number of occurrences of the
    image in our sprite. The number of steps defines how many stops our background
    image makes to complete a single animation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个容器元素，大小与我们雪碧图中单个图像的大小相同，并将雪碧图作为容器元素的背景图像。我们使用 `steps()` 时间函数来动画 `background-position`，这样我们一次只看到雪碧图中变化的单个图像实例。在
    `steps()` 时间函数中的步数是我们雪碧图中图像的数量。步数定义了我们的背景图像在完成单个动画时所需的停止次数。
- en: 'The sprite in [Figure 19-3](#an_sprite) has 22 images, each 56 × 100 pixels.
    The total size of our sprite is 1,232 × 100 pixels. We set our container to the
    individual image size: 56 × 100 pixels. We set our sprite as our background image:
    the initial or default value of `background-position` is `top left`, which is
    the same as `0 0`. Our image will appear at `0 0`, which is a good default. Browsers
    that don’t support CSS animation, like Opera Mini, will simply display the first
    image from our sprite:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19-3](#an_sprite) 中的雪碧图包含 22 张图像，每张图像大小为 56 × 100 像素。我们雪碧图的总大小为 1,232 ×
    100 像素。我们将容器设置为单个图像大小：56 × 100 像素。我们将雪碧图设置为我们的背景图像：`background-position` 的初始或默认值是
    `top left`，与 `0 0` 相同。我们的图像将显示在 `0 0` 处，这是一个良好的默认值。不支持 CSS 动画的浏览器（如 Opera Mini）将仅显示我们雪碧图中的第一张图像：'
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The trick is to use `steps()` to change the `background-position` value so that
    each frame is a view of a separate image within the sprite. Instead of sliding
    in the background image from the left, the `steps()` timing function will pop
    in the background image in the number of steps we declared.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是使用 `steps()` 来改变 `background-position` 的值，以便每帧都是雪碧图中单独图像的视图。使用 `steps()`
    时间函数不是从左边滑入背景图像，而是在我们声明的步数中弹出背景图像。
- en: So we create an animation that simply changes the left-right value of the `background-position`.
    The image is 1,232 pixels wide, so we move the background image from `0 0`, which
    is the left top, to `0 -1232px`, putting the sprite fully outside of our 56 ×
    100 pixel `<div>` viewport.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们创建了一个动画，简单地改变了`background-position`的左右值。图片宽度为1,232像素，所以我们将背景图片从`0 0`，即左上角，移动到`0
    -1232px`，完全超出我们的 56 × 100 像素的 `<div>` 视口。
- en: The values of `-1232px 0` will move the image completely to the left, outside
    of our containing block viewport. It will no longer show up as a background image
    in our 100 × 56 pixel `<div>` at the 100% mark unless `background-repeat` is set
    to repeat along the x-axis. We don’t want that to happen!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`-1232px 0` 的值将完全将图像移动到左侧，超出我们包含块的视口。除非 `background-repeat` 设置为沿 x 轴重复，否则它将不会在我们的
    100 × 56 像素的 `<div>` 中的 100% 位置显示为背景图像。我们不希望发生这种情况！'
- en: 'This is what we want:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们想要的效果：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What may have seemed like a complex animation is very simple: just as in a
    flip book, we see one frame of the sprite at a time. Our keyframe animation simply
    moves the background. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/sprite.html)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或许看起来像是复杂动画的东西实际上非常简单：就像在翻书中，我们一次只看到精灵的一个帧。我们的关键帧动画只是移动背景。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/sprite.html)
- en: 'So that covers the first parameter, the number of steps. The second parameter
    takes one of a few values: `step-start`, `start`, `step-end`, `end`, `jump-none`,
    and `jump-both`. The given value specifies whether the change for the first step’s
    interval takes place at the beginning or at the end of a given interval. ([Chapter 18](ch18.html#x-transitions)
    describes these values in more detail.)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就覆盖了第一个参数，即步骤数。第二个参数接受几个值之一：`step-start`、`start`、`step-end`、`end`、`jump-none`和`jump-both`。给定的值指定第一个步骤间隔的变更是在给定间隔的开始还是结束时发生。（[第18章](ch18.html#x-transitions)详细描述了这些值。）
- en: 'With the default value, `end`, or its equivalent `step-end`, the change take
    place at the end of the first step. In other words, given 200-ms step lengths,
    the first change in the animation will not occur until 200 ms into the animation’s
    overall duration. With `start` or `step-start`, the first change will take place
    at the beginning of the first step’s interval; that is to say, the instant the
    animation begins. [Figure 19-4](#step-timing-change-point) provides a timeline
    diagram of how the two values work, based on the following styles:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认值`end`或其等效值`step-end`，变更将发生在第一步的末尾。换句话说，给定200毫秒的步长，动画的第一个变更将在动画总时长的200毫秒后才发生。使用`start`或`step-start`，第一个变更将在第一个步骤间隔的开始处发生；也就是说，动画开始时立即发生变化。[Figure 19-4](#step-timing-change-point)提供了基于以下样式的两个值如何工作的时间轴图示：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![css5 1904](assets/css5_1904.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1904](assets/css5_1904.png)'
- en: Figure 19-4\. Visualizing start and end change points
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图19-4。可视化开始和结束变更点
- en: The boxes embedded into each timeline represent the background color during
    that step interval. Notice that in the `end` timeline, the first interval is the
    same as the background before the animation started. This is because the animation
    waits until the end of the first frame to make the color change for the first
    step (the color between “Step 1” and “Step 2”).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入到每个时间轴中的方框表示该步骤间隔期间的背景颜色。请注意，在`end`时间轴上，第一个间隔与动画开始前的背景相同。这是因为动画等到第一帧结束后才进行第一步的颜色更改（即“Step
    1”和“Step 2”之间的颜色）。
- en: In the `start` timeline, on the other hand, the first interval makes that color
    change at the start of the interval, instantly switching from the starting background
    color to the color between “Step 1” and “Step 2.” This is sort of like jumping
    ahead one interval, an impression reinforced by the fact that the background color
    in “Step 2” of the `end` timeline is the same as that in “Step 1” of the `start`
    timeline.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在`start`时间轴上，第一个间隔使得颜色在间隔开始时发生变化，立即从起始背景颜色切换到“Step 1”和“Step 2”之间的颜色。这有点像提前跳过一个间隔，这种印象被这样一个事实加强：`end`时间轴上的“Step
    2”背景颜色与`start`时间轴上的“Step 1”相同。
- en: A similar effect can be seen at the end of each animation, where the background
    in the fifth step of the `start` timeline is the same as the ending background
    color. In the `end` timeline, it’s the color at the point between “Step 4” and
    “Step 5,” and doesn’t switch to the ending background color until the end of “Step
    5,” when the animation is finished.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次动画结束时都可以看到类似的效果，其中第`start`时间轴的第五步背景与结束背景颜色相同。在`end`时间轴上，它是在“Step 4”和“Step
    5”之间的点处的颜色，直到动画结束时才切换到结束背景颜色。
- en: 'The change parameter can be hard to keep straight. If it helps, think of it
    this way: in a normal animation direction, the `start` value “skips” the 0% keyframe,
    because it makes the first change as soon as the animation starts, and the `end`
    value “skips” the `100%` keyframe.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 更改参数可能很难理清。如果有帮助的话，可以这样想：在正常的动画方向中，`start`值“跳过”了0%关键帧，因为它在动画开始时就进行了第一个更改，而`end`值“跳过”了`100%`关键帧。
- en: The `step-start` value is equal to `steps(1, start)`, with only a single step
    displaying the `100%` keyframe. The `step-end` value is equal to `steps(1, end)`,
    which displays only the `0%` keyframe.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`step-start`值等于`steps(1, start)`，只显示`100%`关键帧。`step-end`值等于`steps(1, end)`，仅显示`0%`关键帧。'
- en: Animating the timing function
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画化时间函数
- en: The `animation-timing-function` is not an animatable property, but it can be
    included in keyframes to alter the current timing of the animation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-timing-function` 不是可动画属性，但可以包含在关键帧中以改变动画的当前时间。'
- en: 'Unlike animatable properties, the `animation-timing-function` values aren’t
    interpolated over time. When included in a keyframe within the `@keyframes` definition,
    the timing function for the properties declared within that same keyframe will
    change to the new `animation-timing-function` value when that keyframe is reached,
    as shown in [Figure 19-5](#an_timing):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与可动画属性不同，`animation-timing-function` 值不会随时间插值。在 `@keyframes` 定义中的关键帧中包含时，当达到该关键帧时，声明在同一关键帧内的属性的时间函数将更改为新的
    `animation-timing-function` 值，如 [图 19-5](#an_timing) 所示：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding example, as shown in [Figure 19-5](#an_timing), halfway through
    the animation, we switch from a linear animation progression for the `width` property
    to one that eases in. The `ease-in` timing starts from the keyframe in which the
    timing function changes. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/cubicbezierprint2.html)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如 [图 19-5](#an_timing) 所示，在动画的一半处，我们从 `width` 属性的线性动画进度切换到缓入动画。缓入时间函数从更改时间函数的关键帧开始。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/cubicbezierprint2.html)
- en: Specifying the `animation-timing-function` within the `to` or `100%` keyframe
    will have no effect on the animation. When included in any other keyframe, the
    animation will follow the `animation-timing-function` specified in that keyframe
    definition until it reaches the next keyframe, overriding the element’s default
    or declared `animation-timing-function`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `to` 或 `100%` 关键帧中指定 `animation-timing-function` 将不会影响动画。在任何其他关键帧中包含时，动画将遵循该关键帧定义中指定的
    `animation-timing-function`，直到达到下一个关键帧，覆盖元素的默认或声明的 `animation-timing-function`。
- en: '![css5 1905](assets/css5_1905.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1905](assets/css5_1905.png)'
- en: Figure 19-5\. Changing the animation timing function mid-animation
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-5\. 更改动画时间函数的中途动画
- en: 'If the `animation-timing-function` property is included in a keyframe, only
    the properties also included in that keyframe block will have their timing function
    impacted. The new timing function will be in play on that property until the next
    keyframe containing that property is reached, at which point it will change to
    the timing function declared within that block, or revert back to the original
    timing function assigned to that element. Take our `W` animation as an example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在关键帧中包含了 `animation-timing-function` 属性，则仅在该关键帧块中还包含该属性的属性才会受其时间函数的影响。新的时间函数将在该属性上起作用，直到达到下一个包含该属性的关键帧为止，此时它将更改为该块内声明的时间函数，或者恢复到分配给该元素的原始时间函数。以我们的
    `W` 动画为例：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This follows the idea that conceptually, when an animation is set on an element
    or pseudo-element, it is as if a set of keyframes is created for each property
    present in any of the keyframes, as if an animation is run independently for each
    property being animated. It’s as if the `W` animation were made up of two animations
    that run simultaneously—`W_part1` and `W_part2`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循的概念是，概念上，当在元素或伪元素上设置动画时，就好像为每个出现在任何关键帧中的属性创建了一组关键帧，好像每个属性的动画都是独立运行的。就像 `W`
    动画由两个同时运行的动画组成一样 — `W_part1` 和 `W_part2`：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `animation-timing-function` that is set on any of the keyframes is added
    to the progression of only the properties defined at that keyframe:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在任何关键帧中设置的 `animation-timing-function` 才会添加到仅在该关键帧定义的属性的进度中：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code will change the `animation-timing-function` from whatever
    was set on the CSS selector block to `ease-in` for the `top` property only, not
    the `left` property, impacting only the `W_part1` section of our `W` animation,
    and only from the middle of the animation to the 75% mark.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码将把 `animation-timing-function` 从 CSS 选择器块上设置的任何内容更改为仅对 `top` 属性为 `ease-in`，而不影响
    `left` 属性，仅在动画的中间到 75% 的标记。
- en: 'However, with the following animation, the `animation-timing-function` will
    have no effect, because it’s been placed in a keyframe block that has no property-value
    declarations:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于以下动画，`animation-timing-function` 将没有效果，因为它被放置在一个没有属性值声明的关键帧块中：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'How is it useful to change the timing function mid-animation? In the bounce
    animation, we had a frictionless environment: the ball bounced forever, never
    losing momentum. The ball sped up as it dropped, and slowed as it rose, because
    the timing function was inverted from `ease-in` to `ease-out` by default as the
    animation proceeded from the `normal` to `reverse` direction every other iteration.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画中间改变时间函数有什么用？在弹跳动画中，我们处于无摩擦的环境：球永远弹跳，永不失去动量。球下落时加速，上升时减速，因为默认情况下，随着动画从`normal`到`reverse`方向的进行，时间函数从`ease-in`反转为`ease-out`。每隔一次迭代。
- en: 'In reality, friction exists; momentum is lost. Balls will not continue to bounce
    indefinitely. If we want our bouncing ball to look natural, we have to make it
    bounce less high as it loses energy with each impact. To do this, we need a single
    animation that bounces multiple times, losing momentum on each bounce, while switching
    between `ease-in` and `ease-out` at each apex and nadir:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，存在摩擦；动量会丢失。球不会无限地继续弹跳。如果我们希望我们的弹跳球看起来自然，我们必须使其在每次碰撞时能量减少而弹跳得不那么高。为此，我们需要一个单一动画，多次弹跳，每次弹跳时动量减少，同时在每个顶点和谷底之间在`ease-in`和`ease-out`之间切换：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This animation loses height after a few bounces, eventually stopping. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball3.html)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画在几次弹跳后高度减少，最终停止。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball3.html)
- en: Since this new animation uses a single iteration, we can’t rely on `animation-direction`
    to change our timing function. We need to ensure that while each bounce causes
    the ball to lose momentum, it still speeds up with gravity and slows down as it
    reaches its apex. Because we will have only a single iteration, we control the
    timing by including `animation-timing-function` within our keyframes. At every
    apex, we switch to `ease-in`, and at every nadir, or bounce, we switch to `ease-out`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个新动画只使用一个迭代，我们不能依赖`animation-direction`来改变我们的时间函数。我们需要确保每次弹跳都会使球失去动量，但仍会受到重力加速并在达到顶点时减速。因为我们只有一个迭代，我们通过在关键帧中包含`animation-timing-function`来控制时间。在每个顶点处，我们切换到`ease-in`，在每个谷底或弹跳处，我们切换到`ease-out`。
- en: Setting the Animation Play State
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置动画播放状态
- en: If you need to pause and resume animations, the `animation-play-state` property
    defines whether the animation is running or paused.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要暂停和恢复动画，`animation-play-state` 属性定义动画是运行还是暂停。
- en: When set to the default value of `running`, the animation proceeds as normal.
    If set to `paused`, the animation will be, well, paused. When `paused`, the animation
    is still applied to the element, just frozen at the progress it had made before
    being paused. If stopped mid-iteration, the properties that were in the process
    of animating stay at their mid-iteration values. When set back to `running`, the
    animation restarts from where it left off, as if the “clock” that controls the
    animation had stopped and started again.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为默认值`running`时，动画会正常进行。如果设置为`paused`，动画将被暂停。在`paused`状态下，动画仍然应用于元素，只是在暂停之前的进度上被冻结。如果在迭代过程中停止，正在进行动画的属性将保持在中间值。当设置回`running`时，动画将从暂停的地方重新开始，就好像控制动画的“时钟”已经停止并重新启动一样。
- en: If the property is set to `paused` during the delay phase of the animation,
    the delay clock is also paused and resumes as soon as `animation-play-state` is
    set back to running. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball4.html)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在动画的延迟阶段将属性设置为`paused`，则延迟时钟也会暂停，并在`animation-play-state`重新设置为运行时恢复。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball4.html)
- en: Animation Fill Modes
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画填充模式
- en: The `animation-fill-mode` property enables us to define whether an element’s
    property values continue to be applied by the animation outside of the animation’s
    duration time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-fill-mode` 属性使我们能够定义元素的属性值在动画持续时间之外是否继续应用。'
- en: This property is useful because, by default, the changes in an animation apply
    only during the animation itself. Before the animation starts, the animation property
    values aren’t applied. Once the animation is done, the values will all revert
    to their pre-animation values. Thus, if you take an element whose background is
    red, and then animate the background from green to blue, the background will (by
    default) stay red until the animation delay expires, and instantly revert to red
    after the animation finishes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性很有用，因为默认情况下，动画中的更改仅在动画本身期间应用。在动画开始之前，不会应用动画属性值。一旦动画完成，所有值将立即恢复为它们的动画前值。因此，如果您将背景从红色动画到蓝色，动画完成之前背景将保持为红色，并且在动画完成后立即恢复为红色。
- en: Similarly, an animation will not affect the property values of the element immediately
    if a positive `animation-delay` is applied. Rather, animation property values
    are applied when the `animation-delay` expires, at the moment the `animationstart`
    event is fired.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果应用了正的 `animation-delay`，动画将不会立即影响元素的属性值。相反，动画属性值将在 `animation-delay` 到期时，即在
    `animationstart` 事件触发时应用。
- en: With `animation-fill-mode`, we can define how the animation impacts the element
    on which it is set before the `animationstart` and after the `animationend` events
    are fired. Property values set in the 0% keyframe can be applied to the element
    during the expiration of any animation delay, and property values can persist
    after the `animationend` event is fired.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `animation-fill-mode`，我们可以定义动画在附加到元素之前和 `animationend` 事件触发后对元素产生的影响。在任何动画延迟到期期间，可以将0%关键帧中设置的属性值应用于元素，并且这些属性值可以在
    `animationend` 事件触发后继续存在。
- en: The default value for `animation-fill-mode` is `none`, which means the animation
    has no effect when it is not executing. Property values from the animation’s 0%
    keyframe (or the 100% keyframe in reverse animations) are not applied to the animated
    element until the `animation-delay` has expired, when the `animationstart` event
    is fired.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-fill-mode` 的默认值是 `none`，这意味着在动画未执行时动画没有任何效果。动画的0%关键帧（或反向动画的100%关键帧）的属性值在动画延迟到期并触发
    `animationstart` 事件时才会应用于动画元素。'
- en: When the value is set to `backwards` and the `animation-direction` is either
    `normal` or `alternate`, the property values from the `0%` keyframe are applied
    immediately, without waiting for the `animation-delay` time to expire. If the
    `animation-direction` is either `reversed` or `reversed-alternate`, the property
    values from the `100%` keyframe are applied.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当值设置为 `backwards` 且 `animation-direction` 是 `normal` 或 `alternate` 时，将立即应用 `0%`
    关键帧的属性值，无需等待 `animation-delay` 时间到期。如果 `animation-direction` 是 `reversed` 或 `reversed-alternate`，则将应用
    `100%` 关键帧的属性值。
- en: The value of `forwards` means that when the animation is done executing—that
    is, has concluded the last part of the last iteration as defined by the `animation-iteration-count`
    value, and the `animationend` event has fired—it continues to apply the values
    of the properties as they were when the `animationend` event occurred. If the
    `iteration-count` has an integer value, this will be either the `100%` keyframe,
    or, if the last iteration was in the reverse direction, the `0%` keyframe.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`forwards` 值意味着当动画执行完成——即按照 `animation-iteration-count` 值定义的最后迭代的最后部分，并且触发了
    `animationend` 事件后——它将继续应用属性值，这些属性值是在 `animationend` 事件发生时的状态。如果 `iteration-count`
    具有整数值，则此值将是 `100%` 关键帧，或者如果最后一个迭代是反向的，则是 `0%` 关键帧。'
- en: The `both` value applies both the `backwards` effect of applying the property
    values as soon as the animation is attached to the element, *and* the `forwards`
    value of persisting the property values past the `animationend` event. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/halfiterationforwards.html)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`both` 值同时应用 `backwards` 效果，即在动画附加到元素时立即应用属性值，并且 `forwards` 效果，即在 `animationend`
    事件之后持续应用属性值。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/halfiterationforwards.html)'
- en: If the `animation-iteration-count` is a float value, and not an integer, the
    last iteration will not end on the `0%` or `100%` keyframe; the animation will
    instead end its execution partway through an animation cycle. If the `animation-fill-mode`
    is set to `forwards` or `both`, the element maintains the property values it had
    when the `animationend` event occurred. For example, if the `animation-iteration-count`
    is `6.5`, and the `animation-timing-function` is linear, the `animationend` event
    fires and the values of the properties at the 50% mark (whether or not a 50% keyframe
    is explicitly declared) will stick, as if the `animation-play-state` had been
    set to `pause` at that point.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`animation-iteration-count`是浮点值而不是整数，则最后一个迭代不会在`0%`或`100%`关键帧结束；相反，动画将在动画周期的中途结束其执行。如果`animation-fill-mode`设置为`forwards`或`both`，元素将保持在`animationend`事件发生时的属性值。例如，如果`animation-iteration-count`为`6.5`，并且`animation-timing-function`为linear，则`animationend`事件触发时，属性在50%标记处的值将保持不变，就好像在该点设置了`animation-play-state`为`pause`一样。
- en: 'For example, consider the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The animation will go through only 0.6 iterations. Being a linear 10-second
    animation, it will stop at the 60% mark, 6 seconds into the animation, when the
    element is translated 600 pixels to the right. With `animation-fill-mode` set
    to `forwards` or `both`, the animation will stop animating when it is translated
    600 pixels to the right, holding the moved element 600 pixels to the right of
    its original position. This will keep it translated indefinitely, or at least
    until the animation is detached from the element. Without the `animation-fill-mode`:
    `forwards`, the element with class `moved` will pop back to its original transform:
    `translateX(0)`, as defined in the moved selector code block.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '动画将只进行0.6次迭代。作为线性的10秒动画，它将在60%的位置停止，即动画进行到第6秒时，元素向右移动600像素。当`animation-fill-mode`设置为`forwards`或`both`时，动画在元素被移动到右侧600像素时停止动画，保持元素在其原始位置的右侧600像素处。这将使其永久地保持平移状态，至少在动画与元素分离之前是这样。如果没有`animation-fill-mode`:
    `forwards`，则具有`moved`类的元素将弹回其原始的`transform: translateX(0)`，如在移动选择器代码块中定义的那样。'
- en: Bringing It All Together
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 综合所有内容
- en: The `animation` shorthand property allows you to use one declaration, instead
    of eight, to define all the parameters for an element’s animation. The `animation`
    property value is a list of space-separated values for the various longhand animation
    properties. If you are setting multiple animations on an element or pseudo-element,
    you can use a comma-separated list of animations.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation`简写属性允许您使用一个声明来定义元素动画的所有参数，而不是八个。`animation`属性值是各种长手动画属性的以空格分隔的值列表。如果您在元素或伪元素上设置多个动画，可以使用以逗号分隔的动画列表。'
- en: 'The animation shorthand takes as its value all the other preceding animation
    properties, including `animation-duration`, `animation-timing-function`, `animation-delay`,
    `animation-iteration-count`, `animation-direction`, `animation-fill-mode`, `animation-play-state`,
    and `animation-name`. For example, the following two rules are precisely equivalent:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 动画简写属性作为其值接受了所有其他先前的动画属性，包括`animation-duration`、`animation-timing-function`、`animation-delay`、`animation-iteration-count`、`animation-direction`、`animation-fill-mode`、`animation-play-state`和`animation-name`。例如，以下两个规则完全等效：
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We didn’t have to declare all of the values in the animation shorthand; any
    values that aren’t declared are set to the default or initial values. In the preceding
    example, three of the properties are set to their default values, so they are
    not strictly necessary, though sometimes it’s a good idea to write them in as
    a reminder to future you (or whoever takes over maintenance of your code).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必在动画简写中声明所有值；未声明的任何值都设置为默认或初始值。在前面的示例中，三个属性设置为它们的默认值，因此它们并不严格必要，尽管有时将它们写入作为未来参考（或接管代码维护的人）的提醒是个好主意。
- en: The order of the shorthand is important in two specific ways. First, two time
    properties are permitted, for <*`animation-duration`*> and <*`animation-delay`*>.
    When two are listed, the first is *always* the duration. The second, if present,
    is interpreted as the delay.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 简写的顺序在两个特定方面很重要。首先，允许两个时间属性，用于<*`animation-duration`*>和<*`animation-delay`*>。当列出两个时，第一个始终是持续时间。第二个（如果存在）被解释为延迟。
- en: 'Second, the placement of the `animation-name` is also important. If you use
    an animation property value as an animation name—which you shouldn’t, but let’s
    say you do—then the `animation-name` should be placed as the *last* property value
    in the `animation` shorthand. The first occurrence of a keyword that is a valid
    value for any of the other animation properties, such as `ease` or `running`,
    is assumed to be part of the shorthand of the animation property the keyword is
    associated with, rather than the `animation-name`. The following rules are equivalent:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`animation-name`的放置位置也很重要。如果将动画属性值用作动画名称（虽然不推荐，但假设你这样做了），则`animation-name`应放置在`animation`速记中的*最后*一个属性值。关键字的第一次出现，如果它是其他任何动画属性的有效值（如`ease`或`running`），则假定它是速记动画属性的一部分，而不是`animation-name`。以下规则是等效的：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This happens because `paused` is a valid animation name. While it may seem that
    the animation named `paused` with a duration of `2s` is being attached to the
    element, that is not what happens. Because words within the shorthand animation
    are first checked against possible valid values of all animation properties other
    than `animation-name`, `paused` is set as the value of the `animation-play-state`
    property. Because no recognizable animation names are found, the `animation-name`
    value remains at its default, `none`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`paused`是一个有效的动画名称。尽管看起来似乎将持续时间为`2s`的名为`paused`的动画附加到元素上，但实际情况并非如此。因为在速记动画中，除`animation-name`之外的所有动画属性的可能有效值都首先与单词进行比较，所以`paused`被设置为`animation-play-state`属性的值。因为没有可识别的动画名称，所以`animation-name`的值保持默认值`none`。
- en: 'Here’s another example of what you shouldn’t do:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你不应该做的例子：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, the author probably has a keyframe animation called `running`. The browser,
    however, sees the term and assigns it to the `animation-play-state` property rather
    than the `animation-name` property. With no `animation-name` declared, no animation
    is attached to the element.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，作者可能有一个名为`running`的关键帧动画。然而，浏览器看到这个术语，并将其分配给`animation-play-state`属性，而不是`animation-name`属性。因为没有声明`animation-name`，所以没有动画附加到元素上。
- en: 'The way to get around this is shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法如下所示：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This will apply the first `running` to `animation-play-state`, and the second
    `running` to `animation-name`. Again: this is *not* advised. The potential for
    confusion and error is too great.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将将第一个`running`应用于`animation-play-state`，将第二个`running`应用于`animation-name`。再次强调：*不*建议这样做。这样做可能导致混淆和错误。
- en: 'In light of all this, `animation: 2s 3s 4s;` may seem valid, as if the following
    were being set:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '根据这一切，`animation: 2s 3s 4s;`可能看起来是有效的，就好像正在设置以下内容：'
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'But as mentioned in [“Setting Up Keyframe Animations”](#setting-up-your-keyframe-animation),
    `4s` is *not* a valid identifier. Identifiers cannot start with a digit unless
    escaped. For this animation to be valid, it would have to be written as `animation:
    2s 3s \4s;`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '但正如在[“设置关键帧动画”](#setting-up-your-keyframe-animation)中提到的，`4s`*不*是一个有效的标识符。除非转义，标识符不能以数字开头。为了使此动画有效，必须写成`animation:
    2s 3s \4s;`。'
- en: 'To attach multiple animations to a single element or pseudo-element, comma-separate
    the animations:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要将多个动画附加到单个元素或伪元素上，请用逗号分隔动画：
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Each snowflake will fall while spinning for 96 seconds, spinning twice during
    each 3-second fall. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/snowflake.html)
    At the end of the last animation cycle, the snowflake will stay fixed on the `100%`
    keyframe of the `falling` animation. We declared six of the eight animation properties
    for the `falling` animation and five for the spinning animation, separating the
    two animations with a comma.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 每个雪花将在旋转96秒的同时落下，每次3秒的下落中旋转两次。[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/snowflake.html)
    在最后一个动画周期结束时，雪花将停留在`falling`动画的`100%`关键帧上。我们为`falling`动画声明了八个动画属性中的六个，并为旋转动画声明了五个，用逗号分隔了这两个动画。
- en: While you’ll most often see the animation name as the first value—it’s easier
    to read that way, because of the issue with animation property keywords being
    valid keyframe identifiers—it is not a best practice. That is why we put the animation
    name at the end.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你经常会看到动画名称作为第一个值——这样更容易阅读，因为动画属性关键字作为有效的关键帧标识符可能会导致问题，但这并不是最佳实践。这就是为什么我们把动画名称放在最后的原因。
- en: 'To sum up: using the `animation` shorthand is a fine idea. Just remember that
    the placements of the duration, delay, and name within that shorthand are important,
    and omitted values will be set to their default values.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 总之：使用`animation`简写是个好主意。只需记住，在该简写中，持续时间、延迟和名称的位置很重要，省略的值将被设置为它们的默认值。
- en: Also note that although `none` is basically the only word that can’t be a valid
    animation name, using any animation keywords as your identifier is never a good
    idea.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，虽然`none`基本上是唯一不能作为有效动画名称的词，但使用任何动画关键词作为您的标识符从来不是一个好主意。
- en: Animation, Specificity, and Precedence Order
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画、特异性和优先级顺序
- en: In terms of specificity, the cascade, and which property values get applied
    to an element, animations supersede all other values in the cascade.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 就特异性、级联以及哪些属性值应用于元素而言，动画优先于级联中的所有其他值。
- en: Specificity and !important
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特异性和!important
- en: In general, the weight of a property attached with an ID selector `1-0-0` should
    take precedence over a property applied by an element selector `0-0-1`. However,
    if that property value is changed via a keyframe animation, the new value will
    be applied as if that property-value pair were added as an inline style and override
    the previous value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用ID选择器`1-0-0`附加的属性权重应优先于通过元素选择器`0-0-1`应用的属性。但是，如果通过关键帧动画更改了该属性值，新值将被应用，就好像该属性值对被添加为内联样式并覆盖了先前的值一样。
- en: The animation specification states, “Animations override all normal rules, but
    are overridden by `!important` rules.” That being said, don’t add `!important`
    to properties set inside your animation declaration block; this use is invalid,
    and the property-value combination to which `!important` is added will be ignored.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 动画规范说明：“动画覆盖所有普通规则，但会被`!important`规则覆盖。”因此，在动画声明块内不要添加`!important`到属性，这样做是无效的，被添加了`!important`的属性-值组合将被忽略。
- en: 'Animation Iteration and display: none;'
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画迭代和显示：none;
- en: 'If the `display` property is set to `none` on an element, any animation iterating
    on that element or its descendants will cease, as if the animation were detached
    from the element. Updating the `display` property back to a visible value will
    reattach all the animation properties, restarting the animation from scratch:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在元素上将`display`属性设置为`none`，则在该元素或其后代上迭代的任何动画都将停止，就好像动画从元素上解除绑定一样。将`display`属性更新回可见值将重新附加所有动画属性，从头开始重新启动动画：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this case, the snowflake will spin 20 times; each spin takes 2 seconds,
    with the first spin starting after 5 seconds. If the snowflake element’s `display`
    property gets set to `none` after 15 seconds, it would have completed 5 spins
    before disappearing (after getting through the 5-second delay, then executing
    5 spins at 2 seconds each). If the snowflake `display` property changes back to
    anything other than `none`, the animation starts from scratch: a 5-second delay
    will elapse again before it starts spinning 20 times. It makes no difference how
    many animation cycles iterated before it disappeared from view the first time.
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/snowflake2.html)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，雪花将旋转20次；每次旋转需要2秒钟，第一次旋转在5秒后开始。如果雪花元素的`display`属性在15秒后被设置为`none`，它将在消失之前完成5次旋转（在经过5秒延迟后执行5次每次2秒的旋转）。如果雪花的`display`属性再次改为除了`none`之外的任何其他值，则动画将从头开始：再次等待5秒延迟，然后开始旋转20次。无论第一次从视图中消失之前迭代了多少动画周期，都不会有任何影响。
- en: Animation and the UI Thread
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画和UI线程
- en: CSS animations have the *lowest* priority on the UI thread. If you attach multiple
    animations on page load with positive values for `animation-delay`, the delays
    expire as specified, but the animations may not begin until the UI thread is available
    to animate.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: CSS动画在UI线程上具有*最低*优先级。如果在页面加载时附加了多个带有正值`animation-delay`的动画，延迟将如指定的那样到期，但动画可能要等到UI线程可用于动画时才会开始。
- en: 'Assume the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下情况：
- en: The animations all require the UI thread (that is, they aren’t on the GPU as
    described in [“Animation chaining”](#animation-chaining)).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有动画都需要UI线程（也就是说，它们不在GPU上，如[“动画链”](#animation-chaining)所述）。
- en: You have 20 animations with the `animation-delay` property set to `1s`, `2s`,
    `3s`, `4s`, and so on in order to start each subsequent animation 1 second after
    the previous animation.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有20个动画，每个动画的`animation-delay`属性设置为`1s`、`2s`、`3s`、`4s`等，以便依次在前一个动画后延迟1秒启动每个后续动画。
- en: The document or application takes a long time to load, with 11 seconds between
    the time the animated elements were drawn to the page and the time the JavaScript
    finished being downloaded, parsed, and executed.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档或应用程序加载时间很长，从绘制动画元素到页面上的时间开始，到 JavaScript 完成下载、解析和执行，整整 11 秒钟。
- en: Given all that, the delays of the first 11 animations will have expired once
    the UI thread is available, and those first 11 animations will all commence simultaneously.
    Each remaining animation will then begin animating at 1-second intervals.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 给定所有这些，当 UI 线程可用时，前 11 个动画的延迟将会过期，并且这些前 11 个动画将同时开始。每个剩余的动画然后将以 1 秒间隔开始动画。
- en: Using the will-change Property
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `will-change` 属性
- en: You could create animations so complex that they render badly, stuttering or
    displaying what’s sometimes referred to as *jank*. In situations such as these,
    it may be helpful to tell the browser what needs to be animated ahead of time
    via the `will-change` property.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建如此复杂的动画，以至于它们呈现得很差，会出现卡顿或所谓的 *jank*。在这种情况下，告诉浏览器提前通过 `will-change` 属性动画化需求可能会有所帮助。
- en: The general idea here is to give the browser hints about the sorts of pre-optimizations
    it can make if expensive calculations may be required.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思想是向浏览器提供关于可能需要昂贵计算的预优化提示。
- en: Warning
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You should use `will-change` only when you have animation problems that you
    have been unable to resolve through other methods, such as simplifying the animation
    in subtle but significant ways, and that you believe pre-optimizations will address.
    If you try `will-change` and see no worthwhile improvement, you should remove
    `will-change` rather than leaving it in place.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在通过其他方法（例如以微妙但显著的方式简化动画）无法解决动画问题，并且您认为预优化会解决问题时，才应使用 `will-change`。如果尝试使用
    `will-change` 并且没有看到值得的改善，应将其移除而不是留在原位。
- en: The default value of `auto` leaves optimization work to the browser, as per
    usual. The `scroll-position` value says that animation of, or at least some change
    of, the document’s scroll position is expected. By default, browsers generally
    take only the contents of the viewport and a little of the content to either side
    of it into account. The `scroll-position` value might cause the browser to bring
    more of the content to either side of the viewport into its layout calculations.
    Although this might produce smoother scroll animations, the expanded scope could
    easily slow the rendering of the content visible in the viewport.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值 `auto` 将优化工作留给浏览器，与通常一样。`scroll-position` 值表示预期文档滚动位置的动画，或至少会发生一些变化。默认情况下，浏览器通常仅考虑视口的内容及其两侧的少量内容。`scroll-position`
    值可能会导致浏览器在其布局计算中引入更多视口两侧的内容。尽管这可能会产生更平滑的滚动动画，但扩展的范围可能会显著减慢视口内可见内容的渲染速度。
- en: With `contents`, the browser is told to expect animation of the element’s contents.
    This is most likely to cause browsers to reduce or eliminate caching of the layout
    of the viewport’s contents. This would require the browser to recompute the layout
    of the page from scratch every frame. Having to constantly recompute the page
    layout could slow the rendering of the page to slower than 60 frames per second,
    which is the benchmark that browser makers usually try to meet. On the other hand,
    if the contents will be changed and animated quite a lot, telling the browser
    to cache less can make sense. Again, try this only if you already know the animations
    are overtaxing the browser—never assume ahead of time.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `contents`，告诉浏览器预期元素内容的动画。这最有可能导致浏览器减少或消除视口内容的缓存。这将要求浏览器每帧从头开始重新计算页面布局。不断重新计算页面布局可能会导致页面的渲染速度低于每秒
    60 帧，这通常是浏览器制造商试图达到的基准。另一方面，如果内容将被频繁更改和动画化，告诉浏览器减少缓存可能是有道理的。再次强调，只有在已经知道动画对浏览器负荷过重时才应尝试这样做——切勿提前假设。
- en: 'It’s also possible to tell the browser which properties to watch out for by
    using a <*`custom-ident`*>, which, in this case, is a fancy way of saying “properties.”
    For example, if you have a complicated animation set that changes position, filter,
    and text shadow, and they’re proving to be slow or stuttery, you could try this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过使用 <*`custom-ident`*> 告诉浏览器要注意的属性，这在这种情况下是指“属性”。例如，如果您有一个复杂的动画集，会改变位置、滤镜和文本阴影，并且它们被证明速度慢或有卡顿现象，您可以尝试这样做：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If this smooths out the animation, it’s worth removing one property at a time
    to see if the smoothness remains. You might, for example, discover that removing
    the `top` and `left` properties doesn’t affect the new smoothness, but removing
    either `filter` or `text-shadow` causes the stuttering to return. In that case,
    keep it at `will-change: filter, text-shadow`.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '如果这使动画变得平滑，逐个移除属性以查看平滑度是否保持是值得的。例如，你可能会发现移除`top`和`left`属性并不影响新的平滑度，但移除`filter`或`text-shadow`会导致卡顿问题再次出现。在这种情况下，将其保留为`will-change:
    filter, text-shadow`。'
- en: 'Also keep in mind that listing a shorthand property like `font` or `background`
    causes all of the longhand properties to be considered changeable. Thus, the following
    two rules are equivalent:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，像`font`或`background`这样列出简写属性会导致所有长手属性被视为可更改。因此，以下两条规则是等效的：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is why, in nearly any case, a shorthand property should not be listed in
    `will-change`. Instead, identify the longhand properties being animated, and list
    those.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在几乎任何情况下，简写属性不应列在`will-change`中的原因。而是要识别正在进行动画的长手属性，并将其列出。
- en: Printing Animations
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印动画
- en: When an animated element is printed, its end state should print. You can’t see
    the element animating on a piece of paper; but if, for example, an animation causes
    an element to have a `border-radius` of `50%`, the printed element will have a
    `border-radius` of `50%`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印动画元素时，应打印其最终状态。你无法在纸上看到元素动画；但是，例如，如果动画导致元素具有`border-radius`为`50%`，打印的元素将具有`border-radius`为`50%`。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we hope this chapter shows, animations can be powerful additions to a user
    interface, as well as to decorative parts of a design. Whether an animation is
    simple, complex, short, or lengthy, all these aspects and more are in your hands.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们希望本章所展示的那样，动画可以成为用户界面以及设计的装饰部分的强大补充。无论动画是简单的、复杂的、短暂的还是长久的，所有这些方面都掌握在你的手中。
- en: Always exercise caution, as animation can affect some users negatively, whether
    they have vestibular disorders or simply are sensitive to motion. Fortunately,
    `prefers-reduced-motion` is available to reduce or eliminate animations for those
    who do not want them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要谨慎行事，因为动画可能会对一些用户产生负面影响，无论他们是否患有前庭障碍或仅对运动敏感。幸运的是，`prefers-reduced-motion`可以减少或消除不希望动画的用户的动画。
