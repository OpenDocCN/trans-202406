- en: Chapter 19\. Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS transitions, covered in the previous chapter, enable simple animations that
    are triggered by changes in the DOM state and proceed from a beginning state to
    an end state. CSS *animations* are similar to transitions in that values of CSS
    properties change over time, but animations provide much more control over the
    way those changes happen. Specifically, CSS keyframe animations let us decide
    if and how an animation repeats, give us granular control over what happens throughout
    the animation, and more. While transitions trigger implicit property value changes,
    animations are explicitly executed when keyframe animations are applied.
  prefs: []
  type: TYPE_NORMAL
- en: With CSS animations, you can change property values that are not part of the
    set pre- or post-state of an element. The property values set on the animated
    element don’t necessarily have to be part of the animation progression. For example,
    when using a transition, going from black to white will animate only through various
    shades of gray. With animation, that same element doesn’t have to be black or
    white or even in-between shades of gray during the animation.
  prefs: []
  type: TYPE_NORMAL
- en: While you *can* transition through shades of gray, you could instead turn the
    element yellow, then animate from yellow to orange. Alternatively, you could animate
    through various colors, starting with black and ending with white, but progressing
    through the entire rainbow along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Look for the Play symbol ![](assets/play-icon-round.png) to know when an online
    example is available. All of the examples in this chapter can be found at [*https://meyerweb.github.io/csstdg5figs/19-animation*](https://meyerweb.github.io/csstdg5figs/19-animation).
  prefs: []
  type: TYPE_NORMAL
- en: Accommodating Seizure and Vestibular Disorders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While you can use animations to create ever-changing content, *repeated rapid
    changing of content can lead to seizures in some users.* Always keep this in mind,
    and ensure the accessibility of your website for people with epilepsy and other
    seizure disorders.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t usually start a chapter with a warning, but in this case, it’s warranted.
    Visual change, especially rapid visual change, can trigger medical emergencies
    in users who are prone to seizures. They can also cause severe unease in users
    who are prone to vestibular disorder (motion sickness).
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce or eliminate this risk, use the `prefers-reduced-motion` media query
    (see [Chapter 21](ch21.html#css-at-rules)). This allows you to apply styles when
    the user has a “Reduce motion” or similar preference set for their browser or
    operating system. An approach such as this may be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This disables all animations and transitions, assuming no other `!important`
    animations are specified (and they shouldn’t be). This is not a nuanced or perfect
    solution, but it’s a first step. You can invert this approach by segregating all
    of your animations and transitions in a media block for those who do *not* have
    motion reduction enabled, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Not all animations are dangerous or disorienting, and having at least some animations
    for all users may be necessary. Transitions and animations can be very helpful
    in informing users what has changed and guiding them to focus on specific content.
    In such cases, use `prefers-reduced-motion` to tone down animations that are essential
    to understanding the UI, and to switch off those that are not essential.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Keyframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To animate an element, you need to refer to the name of a keyframe animation;
    to do *that*, we need a named keyframe animation. The first step is to define
    this reusable CSS keyframe animation by using the `@keyframes` at-rule, thus giving
    our animation a name.
  prefs: []
  type: TYPE_NORMAL
- en: A `@keyframes` at-rule includes the *animation identifier*, or name, and one
    or more *keyframe blocks*. Each keyframe block includes one or more keyframe selectors
    with declaration blocks of property-value pairs. The entire `@keyframes` at-rule
    specifies the behavior of a single full iteration of the animation. The animation
    can iterate zero or more times, depending mainly on the `animation-iteration-count`
    property value, which we’ll discuss in [“Declaring Animation Iterations”](#defining-animation-iterations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each keyframe block includes one or more *keyframe selectors*. These are percentage-of-time
    positions along the duration of the animation; they are declared either as percentages
    or with the keywords `from` or `to`. Here’s the generic structure of an animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first set of keyframes shown takes an element, sets its `opacity` to `1`
    (fully opaque), and animates it to `0` opacity (fully transparent). The second
    keyframe set animates an element’s foreground to black and its background to white,
    then animates the foreground from black to gray and then white, and the background
    from white to yellow and then orange.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the keyframes don’t say how long this animation should take—that’s
    handled by a CSS property dedicated to the purpose. Instead they say, “Go from
    this state to that state” or “Hit these various states at these percentage points
    of the total animation.” That’s why keyframe selectors are always percentages,
    or `from` and `to`. If you try to use time values (like `1.5s`) as your keyframe
    selectors, you’ll render them invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Keyframe Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the opening and closing curly braces of a keyframe set, you include a
    series of keyframe selectors with blocks of CSS that declare the properties you
    want to animate. Once the keyframes are defined, you “attach” the animation to
    an element by using the `animation-name` property. We’ll discuss that property
    shortly, in [“Invoking a Named Animation”](#the-animation-name-property).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the at-rule declaration, followed by the animation name and braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The name, which you create, is an identifier or a string. Originally, the keyframe
    names had to be an identifier, but both the specification and the browsers also
    support quoted strings.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers are unquoted and have specific rules. You can use any characters
    `a-z`, `A-Z`, and `0-9`, the hyphen (`-`), underscore (`_`), and any ISO 10646
    character U+00A0 and higher. ISO 10646 is the universal character set; this means
    you can use any character in the Unicode standard that matches the regular expression
    `[-_a-zA-Z0-9\u00A0-\u10FFFF]`.[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/name.html)
    The identifier can’t start with a digit (0–9) and should not start with two hyphens
    (though some browsers allow this). One hyphen is fine, as long as it is not followed
    by a digit—unless you escape the digit or hyphen with a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: If you include any escape characters within your animation name, make sure to
    escape them with a backslash (`\`). For example, `Q&A!` must be written as `Q\&A\!`.
    The name `âœŽ` can be left as `âœŽ` (no, that’s not a typo), and `✎` is a valid
    name as well. But if you’re going to use any keyboard characters that aren’t letters
    or digits in an identifier, like `!`, `@`, `#`, `$`, and so on, escape them with
    a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: Also, don’t use any of the keywords covered in this chapter as the name of your
    animation. For example, possible values for the various animation properties we’ll
    be covering later in the chapter include `none`, `paused`, `running`, `infinite`,
    `backwards`, and `forwards`. Using an animation property keyword, while not prohibited
    by the spec, will likely break your animation [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/badnames.html)
    when using the `animation` shorthand property (discussed in [“Bringing It All
    Together”](#the-animation-shorthand-property)). So, while you can legally name
    your animation `paused` (or another keyword,) we *strongly* recommend against
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Keyframe Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Keyframe selectors* define points during an animation where we set the values
    of the properties we want to animate. If you want a value at the start of the
    animation, you declare it at the `0%` mark. If you want a different value at the
    end of the animation, you declare the property value at the `100%` mark. If you
    want a value a third of the way through the animation, you declare it at the `33%`
    mark. These marks are defined with keyframe selectors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyframe selectors consist of a comma-separated list of one or more percentage
    values or the keywords `from` or `to`. The keyword `from` is equal to `0%`. The
    keyword `to` equals `100%`. The keyframe selectors are used to specify the percentage
    along the duration of the animation the keyframe represents. The keyframe itself
    is specified by the block of property values declared on the selector. The `%`
    unit must be used on percentage values. In other words, `0` is invalid as a keyframe
    selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This `@keyframes` animation, named `W`, when attached to a nonstatically positioned
    element, would move that element along a W-shaped path. `W` has five keyframes:
    one each at the `0%`, `25%`, `50%`, `75%`, and `100%` marks. The `from` is the
    `0%` mark, while the `to` is the `100%` mark. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/02_W.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Because the property values we set for the `25%` and `75%` mark are the same,
    we can put the two keyframe selectors together as a comma-separated list. This
    is very similar to regular selectors, which you can group together with commas.
    Whether you keep those selectors on one line (as in the example) or put each selector
    on its own line is up to your personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that keyframe selectors do not need to be listed in ascending order.
    In the preceding example, we have the `25%` and `75%` on the same line, with the
    `50%` mark coming after that declaration. For legibility, it is highly encouraged
    to progress from the `0%` to the `100%` mark. However, as demonstrated by the
    `75%` keyframe in this example, it is not required. You could define your keyframes
    with the last first and the first last, or scramble them up randomly, or whatever
    works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Omitting from and to Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a `0%` or `from` keyframe is not specified, the user agent (browser) constructs
    a `0%` keyframe. The implicit `0%` keyframe uses the original values of the properties
    being animated, as if the `0%` keyframe were declared with the same property values
    that impact the element when no animation was applied—that is, unless another
    animation applied to that element is currently animating the same property (see
    [“Invoking a Named Animation”](#the-animation-name-property) for details). Similarly,
    if the `100%` or `to` keyframe is not defined and no other animations are being
    applied, the browser creates a faux `100%` keyframe using the value the element
    would have had if no animation had been set on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a `background-color` change animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the element originally had `background-color: red` set on it, it would be
    as if the animation were as follows: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/no0or100.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, remembering that we can include multiple identical keyframes as a comma-separated
    list, this faux animation also could be written as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `background-color: red;` declarations are not part of the original
    keyframe animation; they’ve just been filled in here for clarity. We can include
    this `change_bgcolor` animation on many elements, and the perceived animation
    will differ based on the element’s value for the `background-color` property in
    the nonanimated state. Thus, an element that has a yellow background will animate
    from yellow to green to blue and then back to yellow.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we’ve been using exclusively integer values for our percentages, noninteger
    percentage values, such as `33.33%`, are perfectly valid. Negative percentages,
    values greater than `100%`, and values that aren’t otherwise percentages or the
    keywords `to` or `from` are invalid and will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating Keyframe Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much like the rest of CSS, the values in keyframe declaration blocks with identical
    keyframe values cascade. Thus, the earlier `W` animation can be written with the
    `to`, or `100%`, declared twice, overriding the value of the `left` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `to` is declared along with `from` as keyframe selectors for the
    first code block? That sets both `top` and `left` for the `to` keyframe. Then,
    the `left` value is overridden for the `to` in the last keyframe block.
  prefs: []
  type: TYPE_NORMAL
- en: Animatable Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s worth taking a moment to note that not all properties are *animatable*.
    If you list a property that can’t be animated within an animation’s keyframes,
    it’s simply ignored. (For that matter, so are properties and values that the browser
    doesn’t recognize at all, just like any other part of CSS.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Exceptions to the midpoint rule include `animating-timing-function` and `visibility`,
    which are discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: As long as an animatable property is included in at least one block with a value
    that is different from the nonanimated attribute value, and there is a calculable
    midpoint between those two values, that property will animate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an animation is set between two property values that don’t have a calculable
    midpoint, the property may not animate correctly—or at all. For example, you shouldn’t
    declare an element’s height to animate between `height: auto` and `height: 300px`,
    because there is no easily defined midpoint between `auto` and `300px`. The element
    will still animate, but browsers will jump from the preanimated state to the postanimated
    state halfway through the animation. Thus, for a 1-second animation, the element
    will jump from `auto` height to `300px` height at the 500-millisecond point in
    the animation. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/nomidpoint.html)
    Other properties may animate over the length of the same animation; e.g., if you
    change the background color, it will animate smoothly over the animation. Only
    those properties that can’t be animated between will jump halfway through.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of your animation will be most predictable if you declare both
    a 0% and a 100% value for every property you animate. For example, if you declare
    `border-radius: 50%;` in your animation, you may want to declare `border-radius:
    0%;` as well, because the default value of `border-radius` is `none`, not `0`,
    and there is no midpoint between `none` and other values. Consider the difference
    in the following two animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `round` animation will animate an element from the original `border-radius`
    value of that element to `border-radius`: `50%` over the duration of the animation.
    The `square_to_round` animation will animate an element from `border-radius: 0%`
    to `border-radius: 50%` over the duration of the animation. If the element starts
    out with square corners, the two animations will have exactly the same effect.
    But if the element starts out with rounded corners, `square_to_round` will jump
    to rectangular corners before it starts animating.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Nonanimatable Properties That Aren’t Ignored
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions to the midpoint rule include `visibility` and `animation-timing-function`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `visibility` property is animatable, even though there is no midpoint between
    `visibility:` `hidden` and `visibility: visible`. When you animate from `hidden`
    to `visible`, the visibility value jumps from one value to the next at the keyframe
    where the change is declared. So you don’t get a smooth fade from visible to hidden,
    or vice versa. The state changes in an instant.'
  prefs: []
  type: TYPE_NORMAL
- en: While the `animation-timing-function` is not, in fact, an animatable property,
    when included in a keyframe block, the animation timing will switch to the newly
    declared value at that point in the animation for the properties within that keyframe
    selector block. The change in animation timing is not animated; it simply switches
    to the new value for those properties only, and only until the next keyframe.
    This allows you to vary the timing function from one keyframe to another. (This
    is covered in [“Changing the Internal Timing of Animations”](#changing-the-internal-timing-of-animations).)
  prefs: []
  type: TYPE_NORMAL
- en: Scripting @keyframes Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CSSKeyframesRule API enables finding, appending, and deleting keyframe
    rules. You can change the content of a keyframe block within a given `@keyframes`
    declaration with `appendRule(`*`n`*`)` or `deleteRule(`*`n`*`)`, where *`n`* is
    the full selector of that keyframe. You can return the contents of a keyframe
    with `findRule(`*`n`*`)`. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `appendRule()`, `deleteRule()`, and `findRule()` methods take the full
    keyframe selector as an argument, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement `myAnimation.findRule(''25%, 75%'').cssText`, where `myAnimation`
    is pointing to a keyframe animation, returns the keyframe that matches `25%, 75%`.
    It would not match any block using either `25%` or `75%` only. If `myAnimation`
    refers to the `W` animation, `myAnimation.findRule(''25%, 75%'').cssText` returns
    `25%, 75% { top: 100%; }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `myAnimation.deleteRule(''50%'')` will delete the *last* 50% keyframe—so
    if we have multiple `50%` keyframes, the last one listed will be the first to
    go. Conversely, `myAnimation.appendRule(''53% {top: 50%;}'')` appends a 53% keyframe
    after the last keyframe of the `@keyframes` block. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/appendRule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS has four animation events: `animationstart`, `animationend`, `animationiteration`,
    and `animationcancel`. The first two occur at the start and end of an animation,
    and the last between the end of an iteration and the start of a subsequent iteration.
    Any animation for which a valid keyframe rule is defined will generate the start
    and end events, even animations with empty keyframe rules. The `animationiteration`
    event occurs only when an animation has more than one iteration, as the `animationiteration`
    event does not fire if the `animationend` event would fire at the same time. The
    `animationcancel` event is fired whenever a running animation is stopped before
    reaching its last keyframe.'
  prefs: []
  type: TYPE_NORMAL
- en: Animating Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created a keyframe animation, you can apply that animation to
    elements and/or pseudo-elements. CSS provides numerous animation properties to
    attach a keyframe animation to an element and control its progression. At a minimum,
    you need to include the name of the animation for the element to animate, and
    a duration if you want the animation to be visible. (Without a duration, the animation
    will happen in zero time.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can attach animation properties to an element in two ways: include all
    the animation properties separately, or declare all the properties in one line
    by using the `animation` shorthand property (or a combination of shorthand and
    longhand properties). Let’s start with the individual properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a Named Animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `animation-name` property takes as its value a comma-separated list of names
    of keyframe animations you want to apply to the selected elements. The names are
    the unquoted identifiers or quoted strings (or a mixture of both) you created
    in your `@keyframes` rules.
  prefs: []
  type: TYPE_NORMAL
- en: The default value is `none`, which means no animation is applied to the selected
    elements. The `none` value can be used to override any animation applied elsewhere
    in the CSS cascade. (This is also the reason you don’t want to name your animation
    `none`, unless you’re a masochist.) [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/badnames.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `change_bgcolor` keyframe animation defined in [“Omitting from and
    to Values”](#omitting-from-and-to-values), we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple rule applies the `change_bgcolor` animation to all `<div>` elements,
    however many or few are on the page. To apply more than one animation, include
    more than one comma-separated animation name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If one of the included keyframe identifiers does not exist, the series of animations
    will not fail; rather, the failed animation will be ignored, and the valid animations
    will be applied. While ignored initially, the failed animation will be applied
    if and when that keyframe animation comes into existence as a valid animation.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, assume that no `spin` keyframe animation is defined. The `spin`
    animation will not be applied, while the `change_bgcolor`, `round`, and `W` animations
    will occur. Should a `spin` keyframe animation come into existence through scripting,
    it will be applied at that time. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/nameaddedlater.html)
  prefs: []
  type: TYPE_NORMAL
- en: If more than one animation is applied to an element and those animations have
    repeated properties, the later animations override the property values in the
    earlier animations. For example, if more than two background color changes are
    applied concurrently in two different keyframe animations, whichever animation
    was listed later will override the background property declarations of animations
    earlier in the list, but *only* if the properties (background colors, in this
    case) are being animated at the same time. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/no0or100.html)
    For more on this, see [“Animation, Specificity, and Precedence Order”](#animation-specificity-and-precedence-order).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume the following, and further assume that the animations happen
    over a period of 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The background will animate from cyan to orange to red to purple and then back
    to cyan, thanks to `bg-shift`. Because it comes last in the list of animations,
    its keyframes take precedence. Anytime multiple animations specify behavior for
    the same property at the same point in time, the animation listed last in the
    value of `animation-name` will be in effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s interesting is what happens if the `from` (`0%`) or `to` (`100%`) keyframes
    are omitted from the animation in force. For example, let’s remove the first keyframes
    defined in `bg-shift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now no background colors are defined at the beginning and end of `bg-shift`.
    In a situation like this, when a `0%` or `100%` keyframe is not specified, the
    user agent constructs a `0%`/`100%` keyframe by using the computed values of the
    properties being animated.
  prefs: []
  type: TYPE_NORMAL
- en: These are concerns only when two different keyframe blocks are trying to change
    the same property’s values. In this case, it is `background-color`. On the other
    hand, if one keyframe block animates `background-color` while another animates
    `padding`, the two animations will not collide, and both the background color
    and padding will be animated together.
  prefs: []
  type: TYPE_NORMAL
- en: Simply applying an animation to an element is not enough for the element to
    visibly animate. For that to happen, the animation must take place over some amount
    of time. For that, we have the `animation-duration` property.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Animation Lengths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `animation-duration` property defines how long a single animation iteration
    should take in seconds (`s`) or milliseconds (`ms`).
  prefs: []
  type: TYPE_NORMAL
- en: The `animation-duration` property defines the length of time, either in seconds
    (`s`) or milliseconds (`ms`), it should take to complete one cycle through all
    the keyframes of the animation. If you don’t declare `animation-duration`, the
    animation will still be run with a duration of `0s`, with `animationstart` and
    `animationend` still being fired even though the animation, taking `0s`, is imperceptible.
    Negative time values are not permitted for `animation-duration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When specifying a duration, you must include the second (`s`) or millisecond
    (`ms`) unit. If you have more than one animation, you can include a different
    `animation-duration` for each by including more than one comma-separated time
    duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you supply an invalid value within your comma-separated list of durations
    (e.g., `animation-duration: 200ms, 0, 0.5s`) the entire declaration will fail,
    and it will behave as if `animation-duration: 0s` had been declared; `0` is not
    a valid time value. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/duration_broken_value.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, you will want to include an `animation-duration` value for each
    `animation-name` provided. If you have only one duration, all the animations will
    last the same amount of time. Having fewer `animation-duration` values than `animation-name`
    values in your comma-separated property value list will not fail: rather, the
    values will be repeated as a group. Say we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `change_bgcolor` and `round` animations will be run over `200ms`, and the
    `spin` and `W` animations will run for `5s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a greater number of `animation-duration` values than `animation-name`
    values, the extra values will be ignored. If one of the included animations does
    not exist, the series of animations and animation durations will not fail; the
    failed animation, along with its duration, is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the duration `5s` is associated with `spinner`. There is no
    `spinner` animation, though, so `spinner` doesn’t exist, and the `5s` and `spinner`
    are both ignored. Should a `spinner` animation come into existence, it will be
    applied to `<div>` elements and last 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Animation Iterations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply including the required `animation-name` will lead to the animation playing
    once, and only once, resetting to the initial state at the end of the animation.
    If you want to iterate through the animation more or fewer times than the default
    one time, use the `animation-iteration-count` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the animation will occur once (because the default value is `1`).
    If another value is given for `animation-iteration-count`, and there isn’t a negative
    value for the `animation-delay` property, the animation will repeat the number
    of times specified by the value of the property, which can be any number or the
    keyword `infinite`. The following declarations will cause their animations to
    be repeated 2, 5, and 13 times, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value of `animation-iteration-count` is not an integer, the animation
    will still run, but will cut off mid-iteration on the final iteration. For example,
    `animation-iteration-count: 1.25` will iterate through the animation one and a
    quarter times, cutting off 25% of the way through the second iteration. If the
    value is `0.25` on an 8-second animation, the animation will play about 25% of
    the way through, ending after 2 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Negative numbers are not permitted. If an invalid value is given, the default
    value of `1` will lead to a default single iteration. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/odditeration.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, `0` is a valid value for the `animation-iteration-count` property.
    When set to `0`, the animation still occurs, but zero times. This is similar to
    setting `animation-duration: 0s`: it will throw both an `animationstart` and an
    `animationend` event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are attaching more than one animation to an element or pseudo-element,
    include a comma-separated list of values for `animation-name`, `animation-duration`,
    and `animation-iteration-count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `iteration-count` values (and all other animation property values) will
    be assigned in the order of the comma-separated `animation-name` property value.
    Extra values are ignored. Missing values cause the existing values to be repeated,
    as with `animation-iteration-count` in the preceding scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example has more name values than count values, so the count
    values will repeat: `red` and `blue` will iterate three times, and `white` will
    iterate five times. We have the same number of name values as duration values;
    therefore, the duration values will not repeat. The `red` animation lasts 2 seconds,
    iterating three times, and therefore will run for a total of 6 seconds. The `white`
    animation lasts 4 seconds, iterating five times, for a total of 20 seconds. The
    `blue` animation is 6 seconds per iteration with the repeated three iterations
    value, animating for a total of 18 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Invalid values will invalidate the entire declaration, leading to the animations
    being played once each.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want all three animations to end at the same time, even though their
    durations differ, we can control that with `animation-iteration-count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `red`, `white`, and `blue` animations will last for a total
    of 12 seconds each, because the product of the durations and iteration counts
    in each case totals 12 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include the keyword `infinite` instead of a number, for a duration.
    This will make the animation iterate forever, or until something makes it stop,
    such as removing the animation name, removing the element from the DOM, or pausing
    the play state.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an Animation Direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `animation-direction` property, you can control whether the animation
    progresses from the 0% keyframe to the 100% keyframe, or from the 100% keyframe
    to the 0% keyframe. You can also define whether all the iterations progress in
    the same direction, or set every other animation cycle to progress in the opposite
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `animation-direction` property defines the direction of the animation’s
    progression through the keyframes. It has four possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`normal`'
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration of the animation progresses from the 0% keyframe to the 100%
    keyframe; this value is the default.
  prefs: []
  type: TYPE_NORMAL
- en: '`reverse`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets each iteration to play in reverse keyframe order, always progressing from
    the 100% keyframe to the 0% keyframe. Reversing the animation direction also reverses
    the `animation-timing-function` (which is described in [“Changing the Internal
    Timing of Animations”](#changing-the-internal-timing-of-animations)).
  prefs: []
  type: TYPE_NORMAL
- en: '`alternate`'
  prefs: []
  type: TYPE_NORMAL
- en: The first iteration (and each subsequent odd-numbered iteration) proceeds from
    0% to 100%, and the second iteration (and each subsequent even-numbered cycle)
    reverses direction, proceeding from 100% to 0%. This has an effect only if you
    have more than one iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '`alternate-reverse`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `alternate` value, except it’s the reverse. The first iteration
    (and each subsequent odd-numbered iteration) will proceed from 100% to 0%, and
    the second iteration (and each subsequent even-numbered cycle) reverses direction,
    proceeding from 100% to 0%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are bouncing a ball, but we want to start by dropping it,
    not by throwing it up in the air: we want it to alternate between going down and
    up, rather than up and down, so `animation-direction: alternate-reverse` is the
    most appropriate value for our needs. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball6.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a rudimentary way of making a ball bounce. When balls are bouncing,
    they are moving slowest when they reach their apex and fastest when they reach
    their nadir. We include this example here to illustrate the `alternate-reverse`
    animation directions. We’ll revisit the bouncing animation to make it more realistic
    with the addition of timing (in [“Changing the Internal Timing of Animations”](#changing-the-internal-timing-of-animations)).
    We’ll also discuss how, when the animation is iterating in the reverse direction,
    the `animation-timing-function` is reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Delaying Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `animation-delay` property defines how long the browser waits after the
    animation is attached to the element before beginning the first animation iteration.
  prefs: []
  type: TYPE_NORMAL
- en: By default, an animation begins iterating as soon as it is applied to the element,
    with a 0-second delay. A positive value for `animation-delay` delays the start
    of the animation until the time listed as the value of the property has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Negative values for `animation-delay` are allowed and create interesting effects.
    A negative delay will execute the animation immediately but will begin animating
    the element partway through the attached animation. For example, if `animation-delay:
    -4s` and `animation-duration: 10s` are set on an element, the animation will begin
    immediately but will start approximately 40% of the way through the first animation,
    and will end 6 seconds later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We say *approximately* because the animation will not necessarily start at
    precisely the 40% keyframe block: when the 40% mark of an animation occurs depends
    on the value of the `animation-timing-function`. If `animation-timing-function:
    linear` is set, the animation state will start 40% of the way through the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this `linear` animation example, we have a 10-second animation with a delay
    of –4 seconds. In this case, the animation will start immediately 40% of the way
    through the animation, with the `<div>` translated 400 pixels to the right of
    its original position, and last only 6 seconds. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/fortypercent.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'If an animation is set to occur 10 times, with a delay of –600 milliseconds
    and an animation duration of 200 milliseconds, the element will start animating
    right away, at the beginning of the fourth iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Instead of animating for 2,000 milliseconds (200 ms × 10 = 2,000 ms, or 2 seconds),
    starting in the normal direction, the ball will animate for 1,400 milliseconds
    (or 1.4 seconds) with the animation starting immediately—but at the start of the
    fourth iteration, *and* in the reverse direction.
  prefs: []
  type: TYPE_NORMAL
- en: The animation starts out in reverse because `animation-direction` is set to
    `alternate`, meaning every even-numbered iteration proceeds from the 100% keyframe
    to the 0% keyframe. The fourth iteration, which is an even-numbered iteration,
    is the first visible iteration. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball_animation_delay_negative.html)
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the animation will throw the `animationstart` event immediately.
    The `animationend` event will occur at the 1,400-millisecond mark. The ball will
    be tossed up, rather than bounced, throwing six `animationiteration` events, after
    200, 400, 600, 800, 1,000, and 1,200 milliseconds. While the iteration count is
    set to 10, we get only six `animationiteration` events because we are getting
    only seven iterations; three iterations don’t occur because of the negative `animation-delay`,
    and the last iteration concludes at the same time as the `animationend` event.
    Remember, when an `animationiteration` event would occur at the same time as an
    `animationend` event, the `animationiteration` event does not occur.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a deeper look at animation events before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Animation Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three types of animation events are `animationstart`, `animationiteration`,
    and `animationend`. Each event has three read-only properties: `animationName`,
    `elapsedTime`, and `pseudoElement`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `animationstart` event fires at the start of the animation: after the `animation-delay`
    (if present) has expired, or immediately if no delay is set. If a negative `animation-delay`
    value is present, the `animationstart` will fire immediately, with an `elapsedTime`
    equal to the absolute value of the delay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `animationend` event fires when the animation finishes. If the `animation-iteration-count`
    is set to `infinite`, then as long as the `animation-duration` is set to a time
    greater than `0`, the `animationend` event will never fire. If the `animation-duration`
    is set or defaults to 0 seconds, even when the iteration count is infinite, `animationstart`
    and `animationend` will occur virtually simultaneously, and in that order. These
    are illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `animationiteration` event fires *between* iterations. The `animationend`
    event [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/events.html)
    fires at the conclusion of iterations that do not occur at the same time as the
    conclusion of the animation itself; thus, the `animationiteration` and `animationend`
    events do *not* fire simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the `.noAnimationIteration` example, with the `animation-iteration-count`
    set to a single occurrence, the animation ends at the conclusion of the first
    and only iteration. Whenever the `animationiteration` event would occur at the
    same time as an `animationend` event, the `animationend` event occurs but the
    `animationiteration` event does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `animation-iteration-count` property is omitted, or when its value
    is `1` or less, no `animationiteration` event will be fired. As long as an iteration
    finishes (even if it’s a partial iteration) and another iteration begins, if the
    duration of that subsequent iteration is greater than `0s`, an `animationiteration`
    event will be fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When an animation iterates through fewer cycles than listed in the `animation-iteration-count`
    because of a negative `animation-delay`, there are no `animationiteration` events
    for the cycles that didn’t occur. The preceding example code has no `animationiteration`
    events, as the first three cycles do not occur (because of the `-3s` `animation-delay`),
    and the last cycle finishes at the same time the animation ends. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/events2.html)
  prefs: []
  type: TYPE_NORMAL
- en: In that example, the `elapsedTime` on the `animationstart` event is `3`, as
    it is equal to the absolute value of the delay.
  prefs: []
  type: TYPE_NORMAL
- en: Animation chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use `animation-delay` to chain animations together so the next animation
    starts immediately after the conclusion of the preceding animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `red` animation starts after a 3-second delay and lasts
    1 second, meaning the `animationend` event occurs at the 4-second mark. This example
    starts each subsequent animation at the conclusion of the previous animation.
    This is known as *CSS animation chaining*. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain.html)
  prefs: []
  type: TYPE_NORMAL
- en: By including a 4-second delay on the second animation, the `orange` animation
    will begin interpolating the `@keyframe` property values at the 4-second mark,
    starting the `orange` animation immediately at the conclusion of the `red` animation.
    The `orange` animation concludes at the 7-second mark—it lasts 3 seconds, starting
    after a 4-second delay—which is the delay set on the third, or `yellow`, animation,
    making the `yellow` animation begin immediately after the `orange` animation ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of chaining animations on a single element. You can also
    use the `animation-delay` property to chain the animations for different elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you want a group of list items to animate in order, [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain2a.html)
    appearing as if the animations were chained in sequence, the `animation-delay`
    of each list item should be the combined time of the `animation-duration` and
    `animation-delay` of the previous animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can use JavaScript and the `animationend` event from one animation
    to determine when to attach a subsequent animation, which we discuss shortly,
    the `animation-delay` property is an appropriate method of using CSS animation
    properties to chain animations. There is one caveat: animations are the lowest
    priority on the UI thread. Therefore, if you have a script running that is occupying
    the UI thread, depending on the browser and which properties are being animated
    and what property values are set on the element, the browser may let the delays
    expire while waiting until the UI thread is available before starting more animations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are able to rely on JavaScript, another way of chaining animations is
    listening for `animationend` events to start subsequent animations: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animationchain2.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, there is an event handler on each of the first four list items,
    listening for that list item’s `animationend` event. When the `animationend` event
    occurs, the event listeners add an `animation-name` to the subsequent list item.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the styles, this animation chaining method doesn’t employ
    `animation-delay` at all. Instead, the JavaScript event listeners attach animations
    to each element by setting the `animation-name` property when the `animationend`
    event is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also note that the `animation-name` is included for only the first list
    item. The other list items have only an `animation-duration` with no `animation-name`,
    and therefore no attached animations. Adding `animation-name` via JavaScript is
    what attaches and starts the animation, at least in this example. To start or
    restart an animation, the animation name must be removed and then added back—at
    which point all the animation properties take effect, including `animation-delay`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'we could have written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When the `blue` animation name is added to the fifth list item at the same time
    we added `green`, the delay on the fifth element takes effect at that point in
    time and starts expiring.
  prefs: []
  type: TYPE_NORMAL
- en: While changing the values of animation properties (other than name) on the element
    during an animation has no effect on the animation, removing or adding an `animation-name`
    does have an impact. You can’t change the animation duration from `100ms` to `400ms`
    in the middle of an animation. You can’t switch the delay from `-200ms` to `5s`
    once the delay has already been applied. You can, however, stop and start the
    animation by removing it and reapplying it. In the preceding JavaScript example,
    we started the animations by applying them to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, setting `display: none` on an element terminates any animation.
    Updating the `display` back to a visible value restarts the animation from the
    beginning. If `animation-delay` has a positive value, the delay will have to expire
    before the `animationstart` event happens and any animations occur. If the delay
    is negative, the animation will start midway through an iteration, exactly as
    it would have if the animation had been applied any other way.'
  prefs: []
  type: TYPE_NORMAL
- en: Animation iteration delay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is an animation iteration delay? Sometimes you want an animation to occur
    multiple times but want to wait a specific amount of time between each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: While there is no such thing as an animation iteration delay property, you can
    employ the `animation-delay` property, incorporate delays within your keyframe
    declaration, or use JavaScript to fake it. The best method for faking it depends
    on the number of iterations, performance, and whether the delays are all equal
    in length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want your element to grow three times, but want to wait 4 seconds
    between each 1-second iteration. You can include the delay within your keyframe
    definition and iterate through it three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the first keyframe selector is at the 80% mark and matches the default
    state. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay1.html)
    This will animate your element three times: it stays in the default state for
    80% of the 5-second animation (not changing for 4 seconds) and then moves from
    green to yellow and small to big over the last 1 second of the animation before
    iterating again, stopping after three iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: This method works for any number of iterations of the animation. Unfortunately,
    it is a good solution only if the delay between each iteration is identical and
    you don’t want to reuse the animation with any other timing, such as a delay of
    6 seconds. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay.html)
    If you want to change the delay between each iteration while not changing the
    duration of the change in size and color, you have to write a new `@keyframes`
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable multiple iteration delays between animations, we could create a single
    animation and bake the effect of three different delays into the animation keyframe
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This method may be more difficult to code and maintain, however. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay2.html)
    It works for only a single cycle of the animation. To change the number of animations
    or the iteration delay durations, another `@keyframes` declaration would be required.
    This example is even less robust than the previous one, but it does allow for
    different between-iteration delays.
  prefs: []
  type: TYPE_NORMAL
- en: 'A solution is specifically allowed in the animation specification: declare
    an animation multiple times, each with a different `animation-delay` value: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay3.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve attached the animation three times, each with a different delay.
    In this case, each animation iteration concludes before the next one proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: If animations overlap while they’re concurrently animating, the values will
    be the values from the last declared animation. As is true whenever multiple animations
    are changing an element’s property at the same time, the animation that occurs
    last in the sequence of animation names will override any animations occurring
    before it in the list of names. In declaring three `color_and_scale` animations
    but at different intervals, the value of the property of the last iteration of
    the `color_and_scale` animation will override the values of the previous ones
    that haven’t yet concluded. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/animation-iteration-delay4.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'The safest, most robust, and most cross-browser-friendly method of faking an
    animation iteration delay property is to use JavaScript’s animation events. Detach
    the animation from the element on `animationend`, and then reattach it after the
    iteration delay. If all the iteration delays are the same, you can use `setInterval`;
    if they vary, use `setTimeout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Changing the Internal Timing of Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right! The scripting was fun, but let’s get back to straight CSS and talk
    about timing functions. Similar to the `transition-timing-function` property,
    the `animation-timing-function` property describes how the animation will progress
    from one keyframe to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the step timing functions, described in [“Using step timing functions”](#step-timing-functions),
    the timing functions are all Bézier curves. Just like the `transition-timing-function`,
    the CSS specification provides for five predefined Bézier curve keywords, which
    we described in the preceding chapter (see [Table 18-1](ch18.html#cubic_bezier)
    and [Figure 18-3](ch18.html#tr_fig0203)).
  prefs: []
  type: TYPE_NORMAL
- en: A handy tool to visualize Bézier curves and to create your own is [Lea Verou’s
    cubic Bézier visualizer](https://cubic-bezier.com).
  prefs: []
  type: TYPE_NORMAL
- en: The default `ease` has a slow start, then speeds up, and ends slowly. This function
    is similar to `ease-in-out`, which has a greater acceleration at the beginning.
    The `linear` timing function, as the name describes, creates an animation that
    animates at a constant speed.
  prefs: []
  type: TYPE_NORMAL
- en: The `ease-in` timing function creates an animation that is slow to start, gains
    speed, and then stops abruptly. The opposite `ease-out` timing function starts
    at full speed, then slows progressively as it reaches the conclusion of the animation
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If none of these suit your needs, you can create your own Bézier curve timing
    function by passing four values, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'While the *x* values must be between 0 and 1, by using values for *y* that
    are greater than 1 or less than 0, you can create a bouncing effect, making the
    animation bounce up and down between values, rather than going consistently in
    a single direction. Consider the following timing function, whose rather outlandish
    Bézier curve is (partly) illustrated in [Figure 19-1](#an-outlandish-bezier-curve):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1901](assets/css5_1901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-1\. An outlandish Bézier curve
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This `animation-timing-function` curve makes the animated property’s values
    go outside the boundaries of the values set in the `0%` and `100%` keyframes.
    In this example, we are shrinking an element from `500px` to `100px`. However,
    because of the `cubic-bezier` values, the element we’re shrinking will actually
    grow to be wider than the `500px` width defined in the `0%` keyframe and narrower
    than the `100px` width defined in the `100%` keyframe, as shown in [Figure 19-2](#an_fig0303).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1902](assets/css5_1902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-2\. Effect of outlandish Bézier curve
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this scenario, the element starts with a width of `500px`, defined in the
    `0%` keyframe. It then quickly shrinks to a width of about `40px`, which is narrower
    than `width: 100px` defined in the `100%` keyframe. From there, it slowly expands
    to about `750px` wide, which is larger than the original width of `500px`. It
    then quickly shrinks back to `width: 100px`, ending the animation iteration. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/cubicbezierprint.html)'
  prefs: []
  type: TYPE_NORMAL
- en: You may have realized that the curve created by our animation is the same curve
    as the Bézier curve. Just as the S-curve goes outside the normal bounding box,
    the width of the animated element goes narrower than the smaller width we set
    of `100px`, and wider than the larger width we set of `500px`.
  prefs: []
  type: TYPE_NORMAL
- en: The Bézier curve has the appearance of a snake because one *y* coordinate is
    positive, and the other negative. If both are positive values greater than 1 or
    both are negative values less than –1, the Bézier curve is arc-shaped, going above
    or below one of the values set, but not bouncing out of bounds on both ends like
    the S-curve.
  prefs: []
  type: TYPE_NORMAL
- en: Any timing function declared with `animation-timing-function` sets the timing
    for the normal animation direction, when the animation is progressing from the
    `0%` keyframe to the `100%` keyframe. When the animation is running in the reverse
    direction, from the `100%` keyframe to the `0%` keyframe, the animation timing
    function is reversed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the bouncing-ball example in [“animation-direction”](#animation-direction)?
    The bouncing wasn’t very realistic, because the original example defaulted to
    `ease` for its timing function. With `animation-timing-function`, we can apply
    `ease-in` to the animation so that when the ball is dropping, it gets faster as
    it nears its nadir at the `100%` keyframe. When it is bouncing upward, it animates
    in the reverse direction, from `100%` to `0%`, so the `animating-timing-function`
    is reversed as well—in this case, to `ease-out`—slowing down as it reaches the
    apex: [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball1.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using step timing functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The step timing functions, `step-start`, `step-end`, and `steps()`, aren’t Bézier
    curves. They’re not curves at all. Rather, they’re *tweening* definitions. The
    `steps()` function is most useful when it comes to character or sprite animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `steps()` function divides the animation into a series of equal-length
    steps. The function takes two parameters: the number of steps and the change point
    (more on that in a moment).'
  prefs: []
  type: TYPE_NORMAL
- en: The number-of-steps parameter value must be a positive integer. The animation
    length will be divided equally into the number of steps provided. For example,
    if the animation duration is 1 second and the number of steps is 5, the animation
    will be divided into five 200-millisecond steps, with the element being redrawn
    to the page five times, at 200-millisecond intervals, moving 20% through the animation
    at each interval.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, think of a flip book. Each page in a flip book
    contains a single drawing or picture that changes slightly from one page to the
    next, like one frame from a movie reel stamped onto each page. When the pages
    of a flip book are rapidly flipped through (hence the name), the pictures appear
    as an animated motion. You can create similar animations with CSS by using an
    image sprite, the `background-position` property, and the `steps()` timing function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-3](#an_sprite) shows an image sprite containing several images that
    change just slightly, like the drawings on the individual pages of a flip book.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1903](assets/css5_1903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-3\. Sprite of dancing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We put all of our slightly differing images into a single image called a *sprite*.
    Each image in our sprite is a frame in the single animated image we’re creating.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a container element that is the size of a single image of our
    sprite, and attach the sprite as the container element’s background image. We
    animate the `background-position`, using the `steps()` timing function so we see
    only a single instance of the changing image of our sprite at a time. The number
    of steps in our `steps()` timing function is the number of occurrences of the
    image in our sprite. The number of steps defines how many stops our background
    image makes to complete a single animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sprite in [Figure 19-3](#an_sprite) has 22 images, each 56 × 100 pixels.
    The total size of our sprite is 1,232 × 100 pixels. We set our container to the
    individual image size: 56 × 100 pixels. We set our sprite as our background image:
    the initial or default value of `background-position` is `top left`, which is
    the same as `0 0`. Our image will appear at `0 0`, which is a good default. Browsers
    that don’t support CSS animation, like Opera Mini, will simply display the first
    image from our sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The trick is to use `steps()` to change the `background-position` value so that
    each frame is a view of a separate image within the sprite. Instead of sliding
    in the background image from the left, the `steps()` timing function will pop
    in the background image in the number of steps we declared.
  prefs: []
  type: TYPE_NORMAL
- en: So we create an animation that simply changes the left-right value of the `background-position`.
    The image is 1,232 pixels wide, so we move the background image from `0 0`, which
    is the left top, to `0 -1232px`, putting the sprite fully outside of our 56 ×
    100 pixel `<div>` viewport.
  prefs: []
  type: TYPE_NORMAL
- en: The values of `-1232px 0` will move the image completely to the left, outside
    of our containing block viewport. It will no longer show up as a background image
    in our 100 × 56 pixel `<div>` at the 100% mark unless `background-repeat` is set
    to repeat along the x-axis. We don’t want that to happen!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What may have seemed like a complex animation is very simple: just as in a
    flip book, we see one frame of the sprite at a time. Our keyframe animation simply
    moves the background. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/sprite.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So that covers the first parameter, the number of steps. The second parameter
    takes one of a few values: `step-start`, `start`, `step-end`, `end`, `jump-none`,
    and `jump-both`. The given value specifies whether the change for the first step’s
    interval takes place at the beginning or at the end of a given interval. ([Chapter 18](ch18.html#x-transitions)
    describes these values in more detail.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the default value, `end`, or its equivalent `step-end`, the change take
    place at the end of the first step. In other words, given 200-ms step lengths,
    the first change in the animation will not occur until 200 ms into the animation’s
    overall duration. With `start` or `step-start`, the first change will take place
    at the beginning of the first step’s interval; that is to say, the instant the
    animation begins. [Figure 19-4](#step-timing-change-point) provides a timeline
    diagram of how the two values work, based on the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1904](assets/css5_1904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-4\. Visualizing start and end change points
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The boxes embedded into each timeline represent the background color during
    that step interval. Notice that in the `end` timeline, the first interval is the
    same as the background before the animation started. This is because the animation
    waits until the end of the first frame to make the color change for the first
    step (the color between “Step 1” and “Step 2”).
  prefs: []
  type: TYPE_NORMAL
- en: In the `start` timeline, on the other hand, the first interval makes that color
    change at the start of the interval, instantly switching from the starting background
    color to the color between “Step 1” and “Step 2.” This is sort of like jumping
    ahead one interval, an impression reinforced by the fact that the background color
    in “Step 2” of the `end` timeline is the same as that in “Step 1” of the `start`
    timeline.
  prefs: []
  type: TYPE_NORMAL
- en: A similar effect can be seen at the end of each animation, where the background
    in the fifth step of the `start` timeline is the same as the ending background
    color. In the `end` timeline, it’s the color at the point between “Step 4” and
    “Step 5,” and doesn’t switch to the ending background color until the end of “Step
    5,” when the animation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change parameter can be hard to keep straight. If it helps, think of it
    this way: in a normal animation direction, the `start` value “skips” the 0% keyframe,
    because it makes the first change as soon as the animation starts, and the `end`
    value “skips” the `100%` keyframe.'
  prefs: []
  type: TYPE_NORMAL
- en: The `step-start` value is equal to `steps(1, start)`, with only a single step
    displaying the `100%` keyframe. The `step-end` value is equal to `steps(1, end)`,
    which displays only the `0%` keyframe.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the timing function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `animation-timing-function` is not an animatable property, but it can be
    included in keyframes to alter the current timing of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike animatable properties, the `animation-timing-function` values aren’t
    interpolated over time. When included in a keyframe within the `@keyframes` definition,
    the timing function for the properties declared within that same keyframe will
    change to the new `animation-timing-function` value when that keyframe is reached,
    as shown in [Figure 19-5](#an_timing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, as shown in [Figure 19-5](#an_timing), halfway through
    the animation, we switch from a linear animation progression for the `width` property
    to one that eases in. The `ease-in` timing starts from the keyframe in which the
    timing function changes. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/cubicbezierprint2.html)
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the `animation-timing-function` within the `to` or `100%` keyframe
    will have no effect on the animation. When included in any other keyframe, the
    animation will follow the `animation-timing-function` specified in that keyframe
    definition until it reaches the next keyframe, overriding the element’s default
    or declared `animation-timing-function`.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1905](assets/css5_1905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-5\. Changing the animation timing function mid-animation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If the `animation-timing-function` property is included in a keyframe, only
    the properties also included in that keyframe block will have their timing function
    impacted. The new timing function will be in play on that property until the next
    keyframe containing that property is reached, at which point it will change to
    the timing function declared within that block, or revert back to the original
    timing function assigned to that element. Take our `W` animation as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows the idea that conceptually, when an animation is set on an element
    or pseudo-element, it is as if a set of keyframes is created for each property
    present in any of the keyframes, as if an animation is run independently for each
    property being animated. It’s as if the `W` animation were made up of two animations
    that run simultaneously—`W_part1` and `W_part2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `animation-timing-function` that is set on any of the keyframes is added
    to the progression of only the properties defined at that keyframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will change the `animation-timing-function` from whatever
    was set on the CSS selector block to `ease-in` for the `top` property only, not
    the `left` property, impacting only the `W_part1` section of our `W` animation,
    and only from the middle of the animation to the 75% mark.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with the following animation, the `animation-timing-function` will
    have no effect, because it’s been placed in a keyframe block that has no property-value
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'How is it useful to change the timing function mid-animation? In the bounce
    animation, we had a frictionless environment: the ball bounced forever, never
    losing momentum. The ball sped up as it dropped, and slowed as it rose, because
    the timing function was inverted from `ease-in` to `ease-out` by default as the
    animation proceeded from the `normal` to `reverse` direction every other iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, friction exists; momentum is lost. Balls will not continue to bounce
    indefinitely. If we want our bouncing ball to look natural, we have to make it
    bounce less high as it loses energy with each impact. To do this, we need a single
    animation that bounces multiple times, losing momentum on each bounce, while switching
    between `ease-in` and `ease-out` at each apex and nadir:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This animation loses height after a few bounces, eventually stopping. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball3.html)
  prefs: []
  type: TYPE_NORMAL
- en: Since this new animation uses a single iteration, we can’t rely on `animation-direction`
    to change our timing function. We need to ensure that while each bounce causes
    the ball to lose momentum, it still speeds up with gravity and slows down as it
    reaches its apex. Because we will have only a single iteration, we control the
    timing by including `animation-timing-function` within our keyframes. At every
    apex, we switch to `ease-in`, and at every nadir, or bounce, we switch to `ease-out`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Animation Play State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to pause and resume animations, the `animation-play-state` property
    defines whether the animation is running or paused.
  prefs: []
  type: TYPE_NORMAL
- en: When set to the default value of `running`, the animation proceeds as normal.
    If set to `paused`, the animation will be, well, paused. When `paused`, the animation
    is still applied to the element, just frozen at the progress it had made before
    being paused. If stopped mid-iteration, the properties that were in the process
    of animating stay at their mid-iteration values. When set back to `running`, the
    animation restarts from where it left off, as if the “clock” that controls the
    animation had stopped and started again.
  prefs: []
  type: TYPE_NORMAL
- en: If the property is set to `paused` during the delay phase of the animation,
    the delay clock is also paused and resumes as soon as `animation-play-state` is
    set back to running. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/ball4.html)
  prefs: []
  type: TYPE_NORMAL
- en: Animation Fill Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `animation-fill-mode` property enables us to define whether an element’s
    property values continue to be applied by the animation outside of the animation’s
    duration time.
  prefs: []
  type: TYPE_NORMAL
- en: This property is useful because, by default, the changes in an animation apply
    only during the animation itself. Before the animation starts, the animation property
    values aren’t applied. Once the animation is done, the values will all revert
    to their pre-animation values. Thus, if you take an element whose background is
    red, and then animate the background from green to blue, the background will (by
    default) stay red until the animation delay expires, and instantly revert to red
    after the animation finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, an animation will not affect the property values of the element immediately
    if a positive `animation-delay` is applied. Rather, animation property values
    are applied when the `animation-delay` expires, at the moment the `animationstart`
    event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: With `animation-fill-mode`, we can define how the animation impacts the element
    on which it is set before the `animationstart` and after the `animationend` events
    are fired. Property values set in the 0% keyframe can be applied to the element
    during the expiration of any animation delay, and property values can persist
    after the `animationend` event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: The default value for `animation-fill-mode` is `none`, which means the animation
    has no effect when it is not executing. Property values from the animation’s 0%
    keyframe (or the 100% keyframe in reverse animations) are not applied to the animated
    element until the `animation-delay` has expired, when the `animationstart` event
    is fired.
  prefs: []
  type: TYPE_NORMAL
- en: When the value is set to `backwards` and the `animation-direction` is either
    `normal` or `alternate`, the property values from the `0%` keyframe are applied
    immediately, without waiting for the `animation-delay` time to expire. If the
    `animation-direction` is either `reversed` or `reversed-alternate`, the property
    values from the `100%` keyframe are applied.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `forwards` means that when the animation is done executing—that
    is, has concluded the last part of the last iteration as defined by the `animation-iteration-count`
    value, and the `animationend` event has fired—it continues to apply the values
    of the properties as they were when the `animationend` event occurred. If the
    `iteration-count` has an integer value, this will be either the `100%` keyframe,
    or, if the last iteration was in the reverse direction, the `0%` keyframe.
  prefs: []
  type: TYPE_NORMAL
- en: The `both` value applies both the `backwards` effect of applying the property
    values as soon as the animation is attached to the element, *and* the `forwards`
    value of persisting the property values past the `animationend` event. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/halfiterationforwards.html)
  prefs: []
  type: TYPE_NORMAL
- en: If the `animation-iteration-count` is a float value, and not an integer, the
    last iteration will not end on the `0%` or `100%` keyframe; the animation will
    instead end its execution partway through an animation cycle. If the `animation-fill-mode`
    is set to `forwards` or `both`, the element maintains the property values it had
    when the `animationend` event occurred. For example, if the `animation-iteration-count`
    is `6.5`, and the `animation-timing-function` is linear, the `animationend` event
    fires and the values of the properties at the 50% mark (whether or not a 50% keyframe
    is explicitly declared) will stick, as if the `animation-play-state` had been
    set to `pause` at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The animation will go through only 0.6 iterations. Being a linear 10-second
    animation, it will stop at the 60% mark, 6 seconds into the animation, when the
    element is translated 600 pixels to the right. With `animation-fill-mode` set
    to `forwards` or `both`, the animation will stop animating when it is translated
    600 pixels to the right, holding the moved element 600 pixels to the right of
    its original position. This will keep it translated indefinitely, or at least
    until the animation is detached from the element. Without the `animation-fill-mode`:
    `forwards`, the element with class `moved` will pop back to its original transform:
    `translateX(0)`, as defined in the moved selector code block.'
  prefs: []
  type: TYPE_NORMAL
- en: Bringing It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `animation` shorthand property allows you to use one declaration, instead
    of eight, to define all the parameters for an element’s animation. The `animation`
    property value is a list of space-separated values for the various longhand animation
    properties. If you are setting multiple animations on an element or pseudo-element,
    you can use a comma-separated list of animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation shorthand takes as its value all the other preceding animation
    properties, including `animation-duration`, `animation-timing-function`, `animation-delay`,
    `animation-iteration-count`, `animation-direction`, `animation-fill-mode`, `animation-play-state`,
    and `animation-name`. For example, the following two rules are precisely equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We didn’t have to declare all of the values in the animation shorthand; any
    values that aren’t declared are set to the default or initial values. In the preceding
    example, three of the properties are set to their default values, so they are
    not strictly necessary, though sometimes it’s a good idea to write them in as
    a reminder to future you (or whoever takes over maintenance of your code).
  prefs: []
  type: TYPE_NORMAL
- en: The order of the shorthand is important in two specific ways. First, two time
    properties are permitted, for <*`animation-duration`*> and <*`animation-delay`*>.
    When two are listed, the first is *always* the duration. The second, if present,
    is interpreted as the delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the placement of the `animation-name` is also important. If you use
    an animation property value as an animation name—which you shouldn’t, but let’s
    say you do—then the `animation-name` should be placed as the *last* property value
    in the `animation` shorthand. The first occurrence of a keyword that is a valid
    value for any of the other animation properties, such as `ease` or `running`,
    is assumed to be part of the shorthand of the animation property the keyword is
    associated with, rather than the `animation-name`. The following rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This happens because `paused` is a valid animation name. While it may seem that
    the animation named `paused` with a duration of `2s` is being attached to the
    element, that is not what happens. Because words within the shorthand animation
    are first checked against possible valid values of all animation properties other
    than `animation-name`, `paused` is set as the value of the `animation-play-state`
    property. Because no recognizable animation names are found, the `animation-name`
    value remains at its default, `none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example of what you shouldn’t do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, the author probably has a keyframe animation called `running`. The browser,
    however, sees the term and assigns it to the `animation-play-state` property rather
    than the `animation-name` property. With no `animation-name` declared, no animation
    is attached to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to get around this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This will apply the first `running` to `animation-play-state`, and the second
    `running` to `animation-name`. Again: this is *not* advised. The potential for
    confusion and error is too great.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In light of all this, `animation: 2s 3s 4s;` may seem valid, as if the following
    were being set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'But as mentioned in [“Setting Up Keyframe Animations”](#setting-up-your-keyframe-animation),
    `4s` is *not* a valid identifier. Identifiers cannot start with a digit unless
    escaped. For this animation to be valid, it would have to be written as `animation:
    2s 3s \4s;`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach multiple animations to a single element or pseudo-element, comma-separate
    the animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Each snowflake will fall while spinning for 96 seconds, spinning twice during
    each 3-second fall. [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/snowflake.html)
    At the end of the last animation cycle, the snowflake will stay fixed on the `100%`
    keyframe of the `falling` animation. We declared six of the eight animation properties
    for the `falling` animation and five for the spinning animation, separating the
    two animations with a comma.
  prefs: []
  type: TYPE_NORMAL
- en: While you’ll most often see the animation name as the first value—it’s easier
    to read that way, because of the issue with animation property keywords being
    valid keyframe identifiers—it is not a best practice. That is why we put the animation
    name at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up: using the `animation` shorthand is a fine idea. Just remember that
    the placements of the duration, delay, and name within that shorthand are important,
    and omitted values will be set to their default values.'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that although `none` is basically the only word that can’t be a valid
    animation name, using any animation keywords as your identifier is never a good
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: Animation, Specificity, and Precedence Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of specificity, the cascade, and which property values get applied
    to an element, animations supersede all other values in the cascade.
  prefs: []
  type: TYPE_NORMAL
- en: Specificity and !important
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, the weight of a property attached with an ID selector `1-0-0` should
    take precedence over a property applied by an element selector `0-0-1`. However,
    if that property value is changed via a keyframe animation, the new value will
    be applied as if that property-value pair were added as an inline style and override
    the previous value.
  prefs: []
  type: TYPE_NORMAL
- en: The animation specification states, “Animations override all normal rules, but
    are overridden by `!important` rules.” That being said, don’t add `!important`
    to properties set inside your animation declaration block; this use is invalid,
    and the property-value combination to which `!important` is added will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Animation Iteration and display: none;'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the `display` property is set to `none` on an element, any animation iterating
    on that element or its descendants will cease, as if the animation were detached
    from the element. Updating the `display` property back to a visible value will
    reattach all the animation properties, restarting the animation from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the snowflake will spin 20 times; each spin takes 2 seconds,
    with the first spin starting after 5 seconds. If the snowflake element’s `display`
    property gets set to `none` after 15 seconds, it would have completed 5 spins
    before disappearing (after getting through the 5-second delay, then executing
    5 spins at 2 seconds each). If the snowflake `display` property changes back to
    anything other than `none`, the animation starts from scratch: a 5-second delay
    will elapse again before it starts spinning 20 times. It makes no difference how
    many animation cycles iterated before it disappeared from view the first time.
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/19-animation/snowflake2.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Animation and the UI Thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS animations have the *lowest* priority on the UI thread. If you attach multiple
    animations on page load with positive values for `animation-delay`, the delays
    expire as specified, but the animations may not begin until the UI thread is available
    to animate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The animations all require the UI thread (that is, they aren’t on the GPU as
    described in [“Animation chaining”](#animation-chaining)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have 20 animations with the `animation-delay` property set to `1s`, `2s`,
    `3s`, `4s`, and so on in order to start each subsequent animation 1 second after
    the previous animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document or application takes a long time to load, with 11 seconds between
    the time the animated elements were drawn to the page and the time the JavaScript
    finished being downloaded, parsed, and executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given all that, the delays of the first 11 animations will have expired once
    the UI thread is available, and those first 11 animations will all commence simultaneously.
    Each remaining animation will then begin animating at 1-second intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Using the will-change Property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could create animations so complex that they render badly, stuttering or
    displaying what’s sometimes referred to as *jank*. In situations such as these,
    it may be helpful to tell the browser what needs to be animated ahead of time
    via the `will-change` property.
  prefs: []
  type: TYPE_NORMAL
- en: The general idea here is to give the browser hints about the sorts of pre-optimizations
    it can make if expensive calculations may be required.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should use `will-change` only when you have animation problems that you
    have been unable to resolve through other methods, such as simplifying the animation
    in subtle but significant ways, and that you believe pre-optimizations will address.
    If you try `will-change` and see no worthwhile improvement, you should remove
    `will-change` rather than leaving it in place.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `auto` leaves optimization work to the browser, as per
    usual. The `scroll-position` value says that animation of, or at least some change
    of, the document’s scroll position is expected. By default, browsers generally
    take only the contents of the viewport and a little of the content to either side
    of it into account. The `scroll-position` value might cause the browser to bring
    more of the content to either side of the viewport into its layout calculations.
    Although this might produce smoother scroll animations, the expanded scope could
    easily slow the rendering of the content visible in the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: With `contents`, the browser is told to expect animation of the element’s contents.
    This is most likely to cause browsers to reduce or eliminate caching of the layout
    of the viewport’s contents. This would require the browser to recompute the layout
    of the page from scratch every frame. Having to constantly recompute the page
    layout could slow the rendering of the page to slower than 60 frames per second,
    which is the benchmark that browser makers usually try to meet. On the other hand,
    if the contents will be changed and animated quite a lot, telling the browser
    to cache less can make sense. Again, try this only if you already know the animations
    are overtaxing the browser—never assume ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to tell the browser which properties to watch out for by
    using a <*`custom-ident`*>, which, in this case, is a fancy way of saying “properties.”
    For example, if you have a complicated animation set that changes position, filter,
    and text shadow, and they’re proving to be slow or stuttery, you could try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If this smooths out the animation, it’s worth removing one property at a time
    to see if the smoothness remains. You might, for example, discover that removing
    the `top` and `left` properties doesn’t affect the new smoothness, but removing
    either `filter` or `text-shadow` causes the stuttering to return. In that case,
    keep it at `will-change: filter, text-shadow`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also keep in mind that listing a shorthand property like `font` or `background`
    causes all of the longhand properties to be considered changeable. Thus, the following
    two rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is why, in nearly any case, a shorthand property should not be listed in
    `will-change`. Instead, identify the longhand properties being animated, and list
    those.
  prefs: []
  type: TYPE_NORMAL
- en: Printing Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an animated element is printed, its end state should print. You can’t see
    the element animating on a piece of paper; but if, for example, an animation causes
    an element to have a `border-radius` of `50%`, the printed element will have a
    `border-radius` of `50%`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we hope this chapter shows, animations can be powerful additions to a user
    interface, as well as to decorative parts of a design. Whether an animation is
    simple, complex, short, or lengthy, all these aspects and more are in your hands.
  prefs: []
  type: TYPE_NORMAL
- en: Always exercise caution, as animation can affect some users negatively, whether
    they have vestibular disorders or simply are sensitive to motion. Fortunately,
    `prefers-reduced-motion` is available to reduce or eliminate animations for those
    who do not want them.
  prefs: []
  type: TYPE_NORMAL
