<html><head></head><body><section data-pdf-bookmark="Chapter 7. Exploring the Kubernetes API and&#xA0;Key&#xA0;Metadata" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_kube_api">&#13;
<h1><span class="label">Chapter 7. </span>Exploring the Kubernetes API and Key Metadata</h1>&#13;
&#13;
&#13;
<p>In this chapter, we present recipes that address basic interactions with Kubernetes objects as well as the API. <a data-primary="APIs" data-secondary="Kubernetes API" data-type="indexterm" id="id857"/><a data-primary="objects (Kubernetes)" data-type="indexterm" id="id858"/>Every <a href="https://oreil.ly/kMcj7">object in Kubernetes</a>, no matter if namespaced like a deployment or cluster-wide like a node, has certain fields available—​for example, <code>metadata</code>, <code>spec</code>, and <code>status</code>. The <code>spec</code> describes the desired state for an object (the specification), and the <code>status</code> captures the actual state of the object, managed by the Kubernetes API server.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.1 Discovering the Kubernetes API Server’s Endpoints" data-type="sect1"><div class="sect1" id="api_endpoints">&#13;
<h1>7.1 Discovering the Kubernetes API Server’s Endpoints</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id216">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to discover the various API endpoints available on the Kubernetes API server.<a data-primary="APIs" data-secondary="discovering Kubernetes API server endpoints" data-type="indexterm" id="ix_APIKubserend"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id61">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Here we assume you’ve spun up a development cluster like kind or Minikube locally. You can run <code>kubectl proxy</code> in a separate terminal. <a data-primary="kubectl" data-secondary="proxy command" data-type="indexterm" id="id859"/><a data-primary="proxy command (kubectl)" data-secondary="using to reach Kubernetes API server" data-type="indexterm" id="id860"/><a data-primary="curl utility" data-type="indexterm" id="id861"/>The proxy lets you easily access the Kubernetes server API with an HTTP client such as <code>curl</code>, without needing to worry about authentication and certificates. After running <code>kubectl proxy</code>, you should be able to reach the API server on port 8001, as shown here:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl http://localhost:8001/api/v1/</strong>&#13;
{&#13;
  "kind": "APIResourceList",&#13;
  "groupVersion": "v1",&#13;
  "resources": [&#13;
    {&#13;
      "name": "bindings",&#13;
      "singularName": "",&#13;
      "namespaced": true,&#13;
      "kind": "Binding",&#13;
      "verbs": [&#13;
        "create"&#13;
      ]&#13;
    },&#13;
    {&#13;
      "name": "componentstatuses",&#13;
      "singularName": "",&#13;
      "namespaced": false,&#13;
      ...</pre>&#13;
&#13;
<p>This lists all the objects exposed by the Kubernetes API. At the top of the list you can see an example of an object with <code>kind</code> set to <code>Binding</code> as well as the allowed operations on this object (here, <code>create</code>).<a data-primary="kind field" data-secondary="Binding" data-type="indexterm" id="id862"/><a data-primary="bindings" data-type="indexterm" id="id863"/></p>&#13;
&#13;
<p>Note that another convenient way to discover the API endpoints is to use the <code>kubectl api-resources</code> command.<a data-primary="kubectl" data-secondary="api-resources command" data-type="indexterm" id="id864"/><a data-primary="api-resources command (kubectl)" data-type="indexterm" id="id865"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id62">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You can discover all the API groups by calling<a data-primary="API groups" data-type="indexterm" id="id866"/> the following endpoint:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl http://localhost:8001/apis/</strong>&#13;
{&#13;
  "kind": "APIGroupList",&#13;
  "apiVersion": "v1",&#13;
  "groups": [&#13;
    {&#13;
      "name": "apiregistration.k8s.io",&#13;
      "versions": [&#13;
        {&#13;
          "groupVersion": "apiregistration.k8s.io/v1",&#13;
          "version": "v1"&#13;
        }&#13;
      ],&#13;
      "preferredVersion": {&#13;
        "groupVersion": "apiregistration.k8s.io/v1",&#13;
        "version": "v1"&#13;
      }&#13;
    },&#13;
    {&#13;
      "name": "apps",&#13;
      "versions": [&#13;
      ...</pre>&#13;
&#13;
<p class="pagebreak-before">Pick some API groups to explore <a data-primary="API groups" data-type="indexterm" id="id867"/>from this list, such as the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>/apis/apps</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>/apis/storage.k8s.io</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>/apis/flowcontrol.apiserver.k8s.io</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>/apis/autoscaling</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Each of these endpoints corresponds to an API group. The core API objects are available in the <code>v1</code> group at <code>/api/v1</code>, whereas other newer API objects are available in named groups under the <code>/apis/</code> endpoint, such as <code>storage.k8s.io/v1</code> and <code>apps/v1</code>. <a data-primary="core API objects" data-type="indexterm" id="id868"/><a data-primary="objects (Kubernetes)" data-secondary="core API objects" data-type="indexterm" id="id869"/>Within a group, API objects are versioned (e.g., <code>v1</code>, <code>v2</code>, <code>v1alpha</code>, <code>v1beta1</code>) to indicate the maturity of the objects. Pods, services, config maps, and secrets, for example, are all part of the <code>/api/v1</code> API group, whereas the <code>/apis/autoscaling</code> group has <code>v1</code> and <code>v2</code> versions.<a data-primary="apiVersion field" data-type="indexterm" id="id870"/></p>&#13;
&#13;
<p>The group an object is part of is what is referred to as the <code>apiVersion</code> in the object specification, available via the <a href="https://oreil.ly/fvO82">API reference</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id871">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/sANzL">API overview</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/ScJvH">API conventions</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.2 Understanding the Structure of a Kubernetes Manifest" data-type="sect1"><div class="sect1" id="api_spec">&#13;
<h1>7.2 Understanding the Structure of a Kubernetes Manifest</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id217">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Although Kubernetes does have convenient generators like <code>kubectl run</code> and <code>kubectl create</code>, you must to learn how to write Kubernetes manifests to embrace the declarative nature of Kubernetes object specifications.<a data-primary="manifests" data-secondary="understanding structure of" data-type="indexterm" id="ix_manistrct"/><a data-primary="APIs" data-secondary="discovering Kubernetes API server endpoints" data-startref="ix_APIKubserend" data-type="indexterm" id="id872"/> To do this, you need to understand the general structure of manifests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id63">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>In <a data-type="xref" href="#api_endpoints">Recipe 7.1</a>, you learned about the various API groups and how to discover which group a particular object is in.</p>&#13;
&#13;
<p>All API resources are either objects or lists. <a data-primary="resources" data-secondary="API" data-type="indexterm" id="id873"/>All resources have a <code>kind</code> and an <code>ap⁠i​Ve⁠rs⁠ion</code>. <a data-primary="objects (Kubernetes)" data-secondary="manifests for" data-type="indexterm" id="id874"/><a data-primary="metadata" data-secondary="metadata field" data-type="indexterm" id="id875"/><a data-primary="kind field" data-secondary="metadata" data-type="indexterm" id="id876"/>In addition, every object <code>kind</code> must have <code>metadata</code>. The <code>metadata</code> contains the name of the object, the namespace it is in (see <a data-type="xref" href="#namespace">Recipe 7.3</a>), and optionally some labels (see <a data-type="xref" href="#labels">Recipe 7.6</a>) and annotations (see <a data-type="xref" href="#easy_annotate">Recipe 7.7</a>).</p>&#13;
&#13;
<p>A pod, for <a data-primary="pods" data-secondary="manifest for, example" data-type="indexterm" id="id877"/>example, will be of <code>kind Pod</code> and <code>apiVersion v1</code>, and the beginning of a simple manifest written in YAML will look like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mypod</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>To complete a manifest, most objects will have a <code>spec</code> and, once created, will also return a <code>status</code> that describes <a data-primary="spec field" data-type="indexterm" id="id878"/><a data-primary="status field" data-type="indexterm" id="id879"/>the current state of the object:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mypod</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">...</code><code class="w"/>&#13;
<code class="nt">status</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">...</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id64">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Kubernetes manifests can be used to define the desired state of your cluster. Because manifests are files, they can be stored in a version control system like Git. <a data-primary="version control systems" data-type="indexterm" id="id880"/>This allows for distributed and asynchronous collaboration among developers and operators and also enables the creation of automation pipelines for continuous integration and deployment. This is the basic idea behind GitOps, in which any changes to a system are made by changing a source of truth in a version control system. Because all changes are logged in the system, it is possible to revert to previous states or reproduce a given state multiple times. Infrastructure as code (IaC) is a term often used when the declarative source of truth is describing the state of infrastructure (as opposed to applications).<a data-primary="infrastructure as code (IaC)" data-type="indexterm" id="id881"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id882">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/EONxU">Objects in Kubernetes</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.3 Creating Namespaces to Avoid Name Collisions" data-type="sect1"><div class="sect1" id="namespace">&#13;
<h1>7.3 Creating Namespaces to Avoid Name Collisions</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id218">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to create two objects with the same name but want to avoid naming collisions.<a data-primary="manifests" data-secondary="understanding structure of" data-startref="ix_manistrct" data-type="indexterm" id="id883"/><a data-primary="namespaces" data-secondary="creating to avoid name collisions" data-type="indexterm" id="id884"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id65">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create two namespaces and create one object in each.<a data-primary="default namespace" data-type="indexterm" id="id885"/></p>&#13;
&#13;
<p>If you don’t specify anything, objects are created in the <code>default</code> namespace. Try creating a second namespace called <code>my-app</code>, as shown here, and list the existing namespaces. You will see the <code>default</code> namespace, other namespaces that were created on start-up (<code>kube-system</code>, <code>kube-public</code>, and <code>kube-node-lease</code>), and the <code>my-app</code> namespace you just created:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create namespace my-app</strong>&#13;
namespace/my-app created&#13;
&#13;
$ <strong>kubectl get ns</strong>&#13;
NAME                 STATUS   AGE&#13;
default              Active   5d20h&#13;
kube-node-lease      Active   5d20h&#13;
kube-public          Active   5d20h&#13;
kube-system          Active   5d20h&#13;
my-app               Active   13s&#13;
&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Alternatively, you can write a manifest to create your namespace. <a data-primary="manifests" data-secondary="writing to create a namespace" data-type="indexterm" id="id886"/><a data-primary="kubectl" data-secondary="apply command" data-type="indexterm" id="id887"/>If you save the following manifest as <em>app.yaml</em>, you can then create the namespace with the <code>kubectl apply -f app.yaml</code> command:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">apiVersion:<code class="w"> </code>v1<code class="w"/>&#13;
kind:<code class="w"> </code>Namespace<code class="w"/>&#13;
metadata:<code class="w"/>&#13;
<code class="w">  </code>name:<code class="w"> </code>my-app<code class="w"/></pre>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id66">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Attempting to start two objects with the same name in the same namespace (e.g., <code>default</code>) leads to a collision, and an error is returned by the Kubernetes API server. However, if you start the second object in a different namespace, the API server will create it:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run foobar --image=nginx:latest</strong>&#13;
pod/foobar created&#13;
&#13;
$ <strong>kubectl run foobar --image=nginx:latest</strong>&#13;
Error from server (AlreadyExists): pods "foobar" already exists&#13;
&#13;
$ <strong>kubectl run foobar --image=nginx:latest --namespace my-app</strong>&#13;
pod/foobar created&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <code>kube-system</code> namespace is reserved for administrators, whereas <a data-primary="kube-system namespace" data-type="indexterm" id="id888"/>the <a href="https://oreil.ly/kQFsq"><code>kube-public</code> namespace</a> is meant to store public objects available to any users of the cluster.<a data-primary="kube-public namespace" data-type="indexterm" id="id889"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.4 Setting Quotas Within a Namespace" data-type="sect1"><div class="sect1" id="quota">&#13;
<h1>7.4 Setting Quotas Within a Namespace</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id219">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to limit the resources available in a namespace—​for example, the overall number of pods that can run in the namespace.<a data-primary="namespaces" data-secondary="setting quotas in" data-type="indexterm" id="id890"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id67">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a <code>ResourceQuota</code> object to specify the limitations on a namespace basis.<a data-primary="ResourceQuota object" data-type="indexterm" id="id891"/><a data-primary="quotas (resource)" data-type="indexterm" id="id892"/></p>&#13;
&#13;
<p>Start by creating a manifest <a data-primary="manifests" data-secondary="creating for resource quota" data-type="indexterm" id="id893"/>for a resource quota and saving it in a file called <em>resource-quota-pods.yaml</em>:</p>&#13;
<pre data-type="programlisting">&#13;
apiVersion: v1&#13;
kind: ResourceQuota&#13;
metadata:&#13;
  name: podquota&#13;
spec:&#13;
  hard:&#13;
    pods: "10"&#13;
</pre>&#13;
&#13;
<p>Then create a new namespace and apply the quota to it:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create namespace my-app</strong>&#13;
namespace/my-app created&#13;
&#13;
$ <strong>kubectl apply -f resource-quota-pods.yaml --namespace=my-app</strong>&#13;
resourcequota/podquota created&#13;
&#13;
$ <strong>kubectl describe resourcequota podquota --namespace=my-app</strong>&#13;
Name:       podquota&#13;
Namespace:  my-app&#13;
Resource    Used  Hard&#13;
--------    ----  ----&#13;
pods        1     10&#13;
&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id894">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You can set a number of quotas on a per-namespace basis, including but not limited to pods, secrets, and config maps.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id895">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/jneBT">Configure Quotas for API Objects</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.5 Labeling an Object" data-type="sect1"><div class="sect1" id="easy_label">&#13;
<h1>7.5 Labeling an Object</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id220">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to label an object so that you can easily find it later. <a data-primary="labels" data-secondary="labeling an object" data-type="indexterm" id="id896"/><a data-primary="objects (Kubernetes)" data-secondary="labeling" data-type="indexterm" id="id897"/>The label can be used for further end-user queries (see <a data-type="xref" href="#labels">Recipe 7.6</a>) or in the context of system automation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id221">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>kubectl label</code> command. <a data-primary="key/value pairs" data-secondary="in labels" data-type="indexterm" id="id898"/>For example, to label <a data-primary="kubectl" data-secondary="label command" data-type="indexterm" id="id899"/>a pod named <code>foobar</code> with the key/value pair <code>tier=frontend</code>, do this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl label pods foobar tier=frontend</strong>&#13;
pod/foobar labeled&#13;
</pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Check the complete help for the command (<code>kubectl label <span class="keep-together">--help</span></code>). You can use it to find out how to remove labels, overwrite existing ones, and even label all resources in a namespace.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id222">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In Kubernetes, you use labels to organize objects in a flexible, nonhierarchical manner. A label is a key/value pair without any predefined meaning for Kubernetes. In other words, the content of the key/value pair is not interpreted by the system. You can use labels to express membership (e.g., object X belongs to department ABC), environments (e.g., this service runs in production), or really anything you need to organize your objects.<a data-primary="labels" data-secondary="common useful labels, documentation" data-type="indexterm" id="id900"/> There are some common useful labels that you can read about in the <a href="https://oreil.ly/SMl_N">Kubernetes documentation</a>. <a data-primary="labels" data-secondary="restrictions on length and allowed values" data-type="indexterm" id="id901"/>Note that labels do have restrictions concerning their <a href="https://oreil.ly/AzeM8">length and allowed values</a>. However, there is a <a href="https://oreil.ly/lTkhW">community guideline</a> for naming keys.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.6 Using Labels for Queries" data-type="sect1"><div class="sect1" id="labels">&#13;
<h1>7.6 Using Labels for Queries</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id223">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to query objects efficiently.<a data-primary="labels" data-secondary="using to query objects" data-type="indexterm" id="id902"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id224">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>kubectl get --selector</code> command.<a data-primary="kubectl" data-secondary="get command" data-tertiary="get --selector" data-type="indexterm" id="id903"/><a data-primary="objects (Kubernetes)" data-secondary="querying, using labels" data-type="indexterm" id="id904"/> For example, given the following pods:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pods --show-labels</strong>&#13;
NAME         READY   STATUS    RESTARTS        AGE     LABELS&#13;
foobar       1/1     Running   0               18m     run=foobar,tier=frontend&#13;
nginx1       1/1     Running   0               72s     app=nginx,run=nginx1&#13;
nginx2       1/1     Running   0               68s     app=nginx,run=nginx2&#13;
nginx3       1/1     Running   0               65s     app=nginx,run=nginx3&#13;
&#13;
</pre>&#13;
&#13;
<p>you can select the pods that belong to the NGINX app (<code>app=nginx</code>):</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pods --selector app=nginx</strong>&#13;
NAME     READY   STATUS    RESTARTS   AGE&#13;
nginx1   1/1     Running   0          3m45s&#13;
nginx2   1/1     Running   0          3m41s&#13;
nginx3   1/1     Running   0          3m38s&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id225">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Labels are part of an object’s metadata. <a data-primary="metadata" data-secondary="labels as part of object metadata" data-type="indexterm" id="id905"/>Any object in Kubernetes can be labeled. Labels are also used by Kubernetes itself for pod selection by deployments (see <a data-type="xref" href="ch04.html#kubectl_run">Recipe 4.1</a>) and services (see <a data-type="xref" href="ch05.html#ch_services">Chapter 5</a>).</p>&#13;
&#13;
<p>Labels can be added manually  with the <code>kubectl label</code> command (see <a data-type="xref" href="#easy_label">Recipe 7.5</a>), or you can define labels in an object manifest, like so:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">foobar</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">tier</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>Once labels are <a data-primary="manifests" data-secondary="defining labels in" data-type="indexterm" id="id906"/>present, you can list them with <code>kubectl get</code>, noting the <a data-primary="kubectl" data-secondary="get command" data-tertiary="listing labels with" data-type="indexterm" id="id907"/>following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>-l</code> is the short form of <code>--selector</code> and will query objects with a specified <code><em>key</em></code><code>=</code><code><em>value</em></code> pair.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>--show-labels</code> will show all the labels of each object returned.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>-L</code> will add a column to the results returned with the value of the specified label.</p>&#13;
</li>&#13;
<li>&#13;
<p>Many object kinds support set-based querying, meaning you can state a query in a form like “must be labeled with X and/or Y.” For example, <code>kubectl get pods -l 'env in (production, development)'</code> would give you pods that are in either the production or development environment.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With two pods running, one with label <code>run=barfoo</code> and the other with label <code>ru⁠n=​fo⁠oba⁠r</code>, you would get outputs similar to the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pods --show-labels</strong>&#13;
NAME                      READY   ...    LABELS&#13;
barfoo-76081199-h3gwx     1/1     ...    pod-template-hash=76081199,run=barfoo&#13;
foobar-1123019601-6x9w1   1/1     ...    pod-template-hash=1123019601,run=foobar&#13;
&#13;
$ <strong>kubectl get pods -L run</strong>&#13;
NAME                      READY   ...    RUN&#13;
barfoo-76081199-h3gwx     1/1     ...    barfoo&#13;
foobar-1123019601-6x9w1   1/1     ...    foobar&#13;
&#13;
$ <strong>kubectl get pods -l run=foobar</strong>&#13;
NAME                      READY   ...&#13;
foobar-1123019601-6x9w1   1/1     ...&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id908">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes documentation on <a href="https://oreil.ly/ku1Sc">labels and selectors</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.7 Annotating a Resource with One Command" data-type="sect1"><div class="sect1" id="easy_annotate">&#13;
<h1>7.7 Annotating a Resource with One Command</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id226">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to annotate a resource with a generic, nonidentifying key/value pair, &#13;
<span class="keep-together">possibly</span> using non-human-readable data.<a data-primary="key/value pairs" data-secondary="in annotations" data-type="indexterm" id="id909"/><a data-primary="resources" data-secondary="annotating with kubectl annotate" data-type="indexterm" id="id910"/><a data-primary="kubectl" data-secondary="annotate command" data-type="indexterm" id="id911"/><a data-primary="annotations" data-secondary="annotating a resource with kubectl annotate" data-type="indexterm" id="id912"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id913">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>kubectl annotate</code> command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl annotate pods foobar \&#13;
    description='something that you can use for automation'</strong>&#13;
pod/foobar annotated&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id68">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Annotations tend to be used for added automation of Kubernetes. <a data-primary="deployments" data-secondary="recording commands that cause changes to" data-type="indexterm" id="id914"/><a data-primary="change-cause key" data-type="indexterm" id="id915"/>For example, when you create a deployment with the <code>kubectl create deployment</code> command, you will notice that the <code>change-cause</code> column in your rollout history (see <a data-type="xref" href="ch04.html#updating-deployments">Recipe 4.6</a>) is empty.&#13;
As of Kubernetes v1.6.0, to start recording the commands that cause changes to the deployment, you can annotate it  with the <code>kubernetes.io/change-cause</code> key. Given a deployment <code>foobar</code>, you might annotate it with the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl annotate deployment foobar \&#13;
    kubernetes.io/change-cause="Reason for creating a new revision"</strong>&#13;
</pre>&#13;
&#13;
<p>Subsequent changes to the deployment will be recorded.</p>&#13;
&#13;
<p>One of the major differences between annotations and labels is that labels can be used as filtering criteria, whereas annotations cannot.<a data-primary="labels" data-secondary="annotations versus" data-type="indexterm" id="id916"/><a data-primary="annotations" data-secondary="labels versus" data-type="indexterm" id="id917"/> Unless you plan to use your metadata for filtering, then it is generally preferable to use annotations.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>