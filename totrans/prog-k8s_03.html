<html><head></head><body><section data-pdf-bookmark="Chapter 3. Basics of client-go" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_client-go">&#13;
<h1><span class="label">Chapter 3. </span>Basics of client-go</h1>&#13;
&#13;
&#13;
<p>We’ll now focus on the Kubernetes programming interface<a data-primary="Go programming language" data-type="indexterm" id="idm46336866946760"/><a data-primary="Go programming language" data-see="also client-go" data-type="indexterm" id="idm46336866946056"/> in Go. You’ll learn how to access the Kubernetes API of the well-known native types like pods, services, and deployment. In later chapters, these techniques will be extended to user-defined types. Here, though, we first concentrate on all API objects that are shipped with every Kubernetes cluster.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Repositories" data-type="sect1"><div class="sect1" id="idm46336866944536">&#13;
<h1>The Repositories</h1>&#13;
&#13;
<p>The<a data-primary="repositories" data-secondary="importing" data-type="indexterm" id="idm46336866942776"/><a data-primary="client-go" data-secondary="repositories" data-type="indexterm" id="CGrepo03"/> Kubernetes project provides a number of third-party consumable Git repositories under the <em>kubernetes</em> organization on GitHub. You’ll need to import all of these with the domain alias <em>k8s.io/…</em> (not <em>github.com/kubernetes/…</em>) into your project. We’ll present the most important of these repositories in the following <span class="keep-together">sections</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Client Library" data-type="sect2"><div class="sect2" id="client-go">&#13;
<h2>The Client Library</h2>&#13;
&#13;
<p>The<a data-primary="repositories" data-secondary="client library" data-type="indexterm" id="idm46336866936200"/> Kubernetes programming interface in Go mainly consists of the <em>k8s.io/client-go</em> library (for brevity we will just call it <code>client-go</code> going forward). <em>client-go</em> is a typical web service client library that supports all API types that are officially part of Kubernetes. It can be used to execute the usual<a data-primary="HTTP interface" data-type="indexterm" id="idm46336866933576"/><a data-primary="REST verbs" data-type="indexterm" id="idm46336866932872"/> REST verbs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Create</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Get</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>List</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Update</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Delete</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Patch</em></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Each of these REST verbs are implemented using the <a data-type="xref" href="ch02.html#api-server-http-interface">“The HTTP Interface of the API Server”</a>. Furthermore<a data-primary="WATCH verb" data-type="indexterm" id="idm46336866924200"/>, the verb <code>Watch</code> is supported, which is special for Kubernetes-like APIs, and one of the main differentiators compared to other APIs.</p>&#13;
&#13;
<p><a href="http://bit.ly/2RryyLM"><code>client-go</code></a> is<a data-primary="client-go" data-secondary="downloading" data-type="indexterm" id="idm46336866921528"/> available on GitHub (see <a data-type="xref" href="#github-client-go">Figure 3-1</a>), and used in Go code with the <em>k8s.io/client-go</em> package name. It is shipped in parallel to Kubernetes itself; that is, for each Kubernetes <code>1.x.y</code> release, there is a <code>client-go</code> release with a matching tag <code>kubernetes-1.x.y</code>.</p>&#13;
&#13;
<figure><div class="figure" id="github-client-go">&#13;
<img alt="The `client-go` repository on Github" src="assets/prku_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>The client-go repository on GitHub</h6>&#13;
</div></figure>&#13;
&#13;
<p>In addition, there is a semantic<a data-primary="client-go" data-secondary="versioning scheme" data-type="indexterm" id="idm46336866915272"/> versioning scheme. For example, <code>client-go</code> 9.0.0 matches the Kubernetes 1.12 release, <code>client-go</code> 10.0.0 matches Kubernetes 1.13, and so on. There may be more fine-grained releases in the future. Besides the client code for Kubernetes API objects, <code>client-go</code> also contains a lot of generic library code. This is also used for user-defined API objects in <a data-type="xref" href="ch04.html#ch_crds">Chapter 4</a>. See <a data-type="xref" href="#github-client-go">Figure 3-1</a> for a list of packages.</p>&#13;
&#13;
<p>While all packages have their use, most of your code that speaks to Kubernetes APIs will use <em>tools/clientcmd/</em> to set up a client from a <code>kubeconfig</code> file and <em>kubernetes/</em> for the actual Kubernetes API clients. We will see code doing this very soon. Before that, let’s finish a quick walk through with other relevant repositories and packages.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes API Types" data-type="sect2"><div class="sect2" id="idm46336866908888">&#13;
<h2>Kubernetes API Types</h2>&#13;
&#13;
<p>As<a data-primary="Kubernetes API" data-secondary="Go types repository" data-type="indexterm" id="idm46336866907096"/><a data-primary="repositories" data-secondary="Kubernetes API Go types" data-type="indexterm" id="idm46336866906088"/><a data-primary="Go types" data-type="indexterm" id="idm46336866905144"/> we have seen, <code>client-go</code> holds the client interfaces. The Kubernetes API Go types for objects like pods, services, and deployments are located in <a href="http://bit.ly/2ZA6dWH">their own repository</a>. It is accessed as <code>k8s.io/api</code> in Go code.</p>&#13;
&#13;
<p>Pods are part of the legacy API group (often also called the “core” group) version <code>v1</code>. Hence, the <code>Pod</code> Go type is found in <em>k8s.io/api/core/v1</em>, and similarly for all other API types in Kubernetes. See<a data-primary="package management" data-type="indexterm" id="idm46336866900792"/> <a data-type="xref" href="#github-api">Figure 3-2</a> for a list of packages, most of which correspond to Kubernetes API groups and their versions.</p>&#13;
&#13;
<p>The actual Go types are contained in a <em>types.go</em> file (e.g., <em>k8s.io/api/core/v1/types.go</em>). In addition, there are other files, most of them automatically generated by a code <span class="keep-together">generator</span>.</p>&#13;
&#13;
<figure><div class="figure" id="github-api">&#13;
<img alt="API repository on Github" src="assets/prku_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>The API repository on GitHub</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="API Machinery" data-type="sect2"><div class="sect2" id="idm46336866894920">&#13;
<h2>API Machinery</h2>&#13;
&#13;
<p>Last<a data-primary="repositories" data-secondary="API Machinery" data-type="indexterm" id="idm46336866893704"/><a data-primary="Kubernetes API" data-secondary="API Machinery repository" data-type="indexterm" id="idm46336866892696"/> but not least, there is a third repository called <a href="http://bit.ly/2xAZiR2">API Machinery</a>, which is used as <code>k8s.io/apimachinery</code> in Go. It includes all the generic building blocks to implement a Kubernetes-like API. API Machinery is not restricted to container management, so, for example, it could be used to build APIs for an online shop or any other business-specific domain.</p>&#13;
&#13;
<p>Nevertheless, you’ll meet a lot of API Machinery packages in Kubernetes-native Go code. An important one is <em>k8s.io/apimachinery/pkg/apis/meta/v1.</em> It contains many of the generic API types such as <code>ObjectMeta</code>, <code>TypeMeta</code>, <code>GetOptions</code>, and <code>ListOptions</code> (see <a data-type="xref" href="#github-apimachinery">Figure 3-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="github-apimachinery">&#13;
<img alt="API Machinery repository on Github" src="assets/prku_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>The API Machinery repository on GitHub</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating and Using a Client" data-type="sect2"><div class="sect2" id="rest-client-config">&#13;
<h2>Creating and Using a Client</h2>&#13;
&#13;
<p>Now<a data-primary="clients" data-secondary="creating and using" data-type="indexterm" id="idm46336866810376"/><a data-primary="repositories" data-secondary="creating and using clients" data-type="indexterm" id="idm46336866809368"/><a data-primary="kubectl" data-type="indexterm" id="idm46336866808360"/> we know all the building blocks to create a Kubernetes client object, which means we can access resources in a Kubernetes cluster. Assuming you have access to a cluster in your local environment (i.e., <code>kubectl</code> is properly set up and credentials are configured), the following code illustrates how you can use <code>client-go</code> in a Go project:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="nx">metav1</code> <code class="s">"k8s.io/apimachinery/pkg/apis/meta/v1"</code>&#13;
    <code class="s">"k8s.io/client-go/tools/clientcmd"</code>&#13;
    <code class="s">"k8s.io/client-go/kubernetes"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">kubeconfig</code> <code class="p">=</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"kubeconfig"</code><code class="p">,</code> <code class="s">"~/.kube/config"</code><code class="p">,</code> <code class="s">"kubeconfig file"</code><code class="p">)</code>&#13;
<code class="nx">flag</code><code class="p">.</code><code class="nx">Parse</code><code class="p">()</code>&#13;
<code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="o">*</code><code class="nx">kubeconfig</code><code class="p">)</code>&#13;
<code class="nx">clientset</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">kubernetes</code><code class="p">.</code><code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">config</code><code class="p">)</code>&#13;
&#13;
<code class="nx">pod</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientset</code><code class="p">.</code><code class="nx">CoreV1</code><code class="p">().</code><code class="nx">Pods</code><code class="p">(</code><code class="s">"book"</code><code class="p">).</code><code class="nx">Get</code><code class="p">(</code><code class="s">"example"</code><code class="p">,</code> <code class="nx">metav1</code><code class="p">.</code><code class="nx">GetOptions</code><code class="p">{})</code></pre>&#13;
&#13;
<p>The code imports the <code>meta/v1</code> package to get access to <code>metav1.GetOptions</code>. Furthermore, it imports <code>clientcmd</code> from <code>client-go</code> in order to read and parse the<a data-primary="kubeconfig" data-type="indexterm" id="idm46336866726552"/> <span class="keep-together">kubeconfig</span> (i.e., the client configuration with server name, credentials, etc.). Then it imports the <code>client-go</code> <code>kubernetes</code> package with the client sets for Kubernetes resources.</p>&#13;
&#13;
<p>The default location for the kubeconfig file is in <em>.kube/config</em> in the user’s home directory. This is also where <code>kubectl</code> gets the credentials for the Kubernetes clusters.</p>&#13;
&#13;
<p>That kubeconfig is then read and parsed using <code>clientcmd.BuildConfigFromFlags</code>. We omitted the mandatory error handling throughout this code, but the <code>err</code> variable would normally contain, for example, the syntax error if a kubeconfig is not well formed. As syntax errors are common in Go code, such an error ought to be checked for properly, like so:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="o">*</code><code class="nx">kubeconfig</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"The kubeconfig cannot be loaded: %v\n"</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="nx">os</code><code class="p">.</code><code class="nx">Exit</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>From <code>clientcmd.BuildConfigFromFlags</code> we get a <code>rest.Config</code>, which you can find in the <em>k8s.io/client-go/rest</em> package). This<a data-primary="client sets" data-secondary="creating" data-type="indexterm" id="idm46336866616280"/> is passed to <code>kubernetes.NewForConfig</code> in order to create the actual Kubernetes <em>client set</em>. It’s called a <em>client set</em> because it contains multiple clients for all native Kubernetes resources.</p>&#13;
&#13;
<p>When running a binary inside of a pod in a cluster, the <code>kubelet</code> will automatically mount a service account into the container at <em>/var/run/secrets/kubernetes.io/serviceaccount</em>. It<a data-primary="in-cluster config" data-type="indexterm" id="idm46336866612392"/> replaces the kubeconfig file just mentioned and can easily be turned into a <code>rest.Config</code> via the <code>rest.InClusterConfig()</code> method. You’ll often find the following combination of <code>rest.InClusterConfig()</code> and <code>clientcmd.BuildConfigFromFlags()</code>, including support for the <code>KUBECONFIG</code> environment variable:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">rest</code><code class="p">.</code><code class="nx">InClusterConfig</code><code class="p">()</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="c1">// fallback to kubeconfig</code>&#13;
    <code class="nx">kubeconfig</code> <code class="o">:=</code> <code class="nx">filepath</code><code class="p">.</code><code class="nx">Join</code><code class="p">(</code><code class="s">"~"</code><code class="p">,</code> <code class="s">".kube"</code><code class="p">,</code> <code class="s">"config"</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">envvar</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"KUBECONFIG"</code><code class="p">);</code> <code class="nb">len</code><code class="p">(</code><code class="nx">envvar</code><code class="p">)</code> <code class="p">&gt;</code><code class="mi">0</code> <code class="p">{</code>&#13;
        <code class="nx">kubeconfig</code> <code class="p">=</code> <code class="nx">envvar</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="nx">kubeconfig</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"The kubeconfig cannot be loaded: %v\n"</code><code class="p">,</code> <code class="nx">err</code>&#13;
        <code class="nx">os</code><code class="p">.</code><code class="nx">Exit</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the following example code we select the core group in <code>v1</code> with <code>clientset.CoreV1()</code> and then access the pod <code>"example"</code> in the <code>"book"</code> namespace:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"> <code class="nx">pod</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientset</code><code class="p">.</code><code class="nx">CoreV1</code><code class="p">().</code><code class="nx">Pods</code><code class="p">(</code><code class="s">"book"</code><code class="p">).</code><code class="nx">Get</code><code class="p">(</code><code class="s">"example"</code><code class="p">,</code> <code class="nx">metav1</code><code class="p">.</code><code class="nx">GetOptions</code><code class="p">{})</code></pre>&#13;
&#13;
<p>Note that only the last function call, <code>Get</code>, actually accesses the server. Both <code>CoreV1</code> and <code>Pods</code> select the client and set the namespace only for the following <code>Get</code> call (this is often called<a data-primary="builder pattern" data-type="indexterm" id="idm46336866512504"/> the <em>builder pattern</em>, in this case to build a request).</p>&#13;
&#13;
<p>The <code>Get</code> call sends an HTTP <code>GET</code> request to <em>/api/v1/namespaces/book/pods/example</em> on the server, which is set in the kubeconfig. If the Kubernetes API server answers with HTTP code <code>200</code>, the body of the response will carry the encoded pod objects, either as JSON—which is the default wire format of <code>client-go</code>—or as protocol buffers.</p>&#13;
<div data-type="note" epub:type="note" id="protobuf"><h6>Note</h6>&#13;
<p>You<a data-primary="protocol buffers (protobuf)" data-type="indexterm" id="idm46336866497800"/> can enable protobuf for native Kubernetes resource clients by modifying the REST config before creating a client from it:</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="nx">cfg</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="o">*</code><code class="nx">kubeconfig</code><code class="p">)</code>&#13;
<code class="nx">cfg</code><code class="p">.</code><code class="nx">AcceptContentTypes</code> <code class="p">=</code> <code class="s">"application/vnd.kubernetes.protobuf,</code>&#13;
<code class="s">                          application/json"</code>&#13;
<code class="nx">cfg</code><code class="p">.</code><code class="nx">ContentType</code> <code class="p">=</code> <code class="s">"application/vnd.kubernetes.protobuf"</code>&#13;
<code class="nx">clientset</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">kubernetes</code><code class="p">.</code><code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">cfg</code><code class="p">)</code></pre>&#13;
&#13;
<p>Note that the custom resources presented in <a data-type="xref" href="ch04.html#ch_crds">Chapter 4</a> do not support protocol buffers.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Versioning and Compatibility" data-type="sect2"><div class="sect2" id="versioning-capability">&#13;
<h2>Versioning and Compatibility</h2>&#13;
&#13;
<p>Kubernetes APIs are<a data-primary="versions, in Kubernetes API" data-type="indexterm" id="idm46336866397544"/><a data-primary="Kubernetes API" data-secondary="API versioning" data-type="indexterm" id="idm46336866396792"/><a data-primary="repositories" data-secondary="versioning and compatibility" data-type="indexterm" id="idm46336866395848"/><a data-primary="compatibility" data-secondary="versioning and" data-type="indexterm" id="idm46336866394888"/> versioned. We have seen in the previous section that pods are in <code>v1</code> of the core group. The core group actually exists in only one version today. There are other groups, though—for example, the <code>apps</code> group, which exists in <code>v1</code>, <code>v1beta2,</code> and <code>v1beta1</code> (as of this writing). If you look into the <a href="http://bit.ly/2L1Nyio"><em>k8s.io/api/apps</em></a> package, you will find all the API objects of these versions. In the <a href="http://bit.ly/2x45Uab"><em>k8s.io/client-go/kubernetes/typed/apps</em></a> package, you’ll see the client implementations for all of these versions.</p>&#13;
&#13;
<p>All of this is only the client side. It does not say anything about the Kubernetes cluster and its API server. Using a client with a version of an API group that the API server does not support will fail. Clients are hardcoded to a version, and the application developer has to select the right API group version in order to speak to the cluster at hand. See <a data-type="xref" href="#api-versions">“API Versions and Compatibility Guarantees”</a> for more on API group compatibility guarantees.</p>&#13;
&#13;
<p>A second aspect of compatibility is the meta API features of the API server that <code>client-go</code> is speaking to. For example, there are option structs for<a data-primary="CRUD verbs" data-type="indexterm" id="idm46336866387112"/> CRUD verbs, like <code>CreateOptions</code>, <code>GetOptions</code>, <code>UpdateOptions</code>, and <code>DeleteOptions</code>. Another important one is <code>ObjectMeta</code> (discussed in detail in <a data-type="xref" href="#ObjectMeta">“ObjectMeta”</a>), which is part of every kind. All of these are frequently extended with new features; we<a data-primary="API Machinery features" data-type="indexterm" id="idm46336866383160"/><a data-primary="API Machinery features" data-see="also Kubernetes API" data-type="indexterm" id="idm46336866382488"/> usually call them <em>API machinery features</em>. In the Go documentation of their fields, comments specify when features are considered alpha or beta. The same API compatibility guarantees apply as for any other API fields.</p>&#13;
&#13;
<p>In the example that follows, the <code>DeleteOptions</code> struct is defined in the package <a href="http://bit.ly/2MZ9flL"><em>k8s.io/apimachinery/pkg/apis/meta/v1/types.go</em></a>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// DeleteOptions may be provided when deleting an API object.</code>&#13;
<code class="kd">type</code> <code class="nx">DeleteOptions</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">TypeMeta</code> <code class="s">`json:",inline"`</code>&#13;
&#13;
    <code class="nx">GracePeriodSeconds</code> <code class="o">*</code><code class="kt">int64</code> <code class="s">`json:"gracePeriodSeconds,omitempty"`</code>&#13;
    <code class="nx">Preconditions</code> <code class="o">*</code><code class="nx">Preconditions</code> <code class="s">`json:"preconditions,omitempty"`</code>&#13;
    <code class="nx">OrphanDependents</code> <code class="o">*</code><code class="kt">bool</code> <code class="s">`json:"orphanDependents,omitempty"`</code>&#13;
    <code class="nx">PropagationPolicy</code> <code class="o">*</code><code class="nx">DeletionPropagation</code> <code class="s">`json:"propagationPolicy,omitempty"`</code>&#13;
&#13;
    <code class="c1">// When present, indicates that modifications should not be</code>&#13;
    <code class="c1">// persisted. An invalid or unrecognized dryRun directive will</code>&#13;
    <code class="c1">// result in an error response and no further processing of the</code>&#13;
    <code class="c1">// request. Valid values are:</code>&#13;
    <code class="c1">// - All: all dry run stages will be processed</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">DryRun</code> <code class="p">[]</code><code class="kt">string</code> <code class="s">`json:"dryRun,omitempty" protobuf:"bytes,5,rep,name=dryRun"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The last field, <code>DryRun</code>, was added in Kubernetes 1.12 as alpha and in 1.13 as beta (enabled by default). It is not understood by the API server in earlier versions. Depending on the feature, passing such an option might simply be ignored or even rejected. So it is important to have a <code>client-go</code> version that is not too far off from the cluster version.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The reference for which fields are available in which quality level is the sources in <em>k8s.io/api</em>, which are accessible, for example, for Kubernetes 1.13 in the <a href="http://bit.ly/2Yrhjgq"><code>release-1.13</code> branch</a>. Alpha fields are marked as such in their description.</p>&#13;
&#13;
<p>There<a data-primary="Kubernetes" data-secondary="documentation" data-type="indexterm" id="idm46336866307288"/> is <a href="http://bit.ly/2YrfiB2">generated API documentation</a> for easier consumption. It is the same information, though, as in <em>k8s.io/api</em>.</p>&#13;
&#13;
<p>Last but not least, many alpha and beta features have corresponding <a href="http://bit.ly/2RP5nmi">feature gates</a> (check here for the <a href="http://bit.ly/2FPZPTT">primary source</a>). Features are tracked in <a href="http://bit.ly/2YuHYcd">issues</a>.</p>&#13;
</div>&#13;
&#13;
<p>The<a data-primary="compatibility" data-secondary="formally guaranteed support matrix" data-type="indexterm" id="idm46336866301640"/> formally guaranteed support matrix between cluster and <code>client-go</code> versions is published in the <code>client-go</code> <a href="http://bit.ly/2RryyLM">README</a> (see <a data-type="xref" href="#client-go-compatibility">Table 3-1</a>).</p>&#13;
<table class="pagebreak-before" id="client-go-compatibility">&#13;
<caption><span class="label">Table 3-1. </span>client-go compatibility with Kubernetes versions</caption>&#13;
<thead>&#13;
<tr>&#13;
<th/>&#13;
<th>Kubernetes 1.9</th>&#13;
<th>Kubernetes 1.10</th>&#13;
<th>Kubernetes 1.11</th>&#13;
<th>Kubernetes 1.12</th>&#13;
<th>Kubernetes 1.13</th>&#13;
<th>Kubernetes 1.14</th>&#13;
<th>Kubernetes 1.15</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>client-go 6.0</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>client-go 7.0</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>client-go 8.0</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>client-go 9.0</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>client-go 10.0</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>client-go 11.0</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>+–</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>client-go 12.0</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>client-go HEAD</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
<td><p>+–</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>✓: both <code>client-go</code> and the Kubernetes version have the same features and the same API group versions.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>+</code>: <code>client-go</code> has features or API group versions that may be absent from the Kubernetes cluster. This may be because of added functionality in <code>client-go</code> or because Kubernetes removed old, deprecated functionality. However, everything they have in common (i.e., most APIs) will work.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>–</code>: <code>client-go</code> is knowingly incompatible with the Kubernetes cluster.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The takeaway from <a data-type="xref" href="#client-go-compatibility">Table 3-1</a> is that the <code>client-go</code> library is supported with its corresponding cluster version. In case of version skew, developers have to carefully consider which features and which API groups they use and whether these are supported in the cluster version the application speaks to.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#client-go-compatibility">Table 3-1</a>, the <code>client-go</code> versions are listed. We briefly mentioned in <a data-type="xref" href="#client-go">“The Client Library”</a> that <code>client-go</code> uses<a data-primary="semantic versioning (semver)" data-type="indexterm" id="idm46336866226680"/> semantic versioning (semver) formally, though by increasing the major version of <code>client-go</code> each time the minor version of Kubernetes (the 13 in 1.13.2) is increased. With <code>client-go</code> 1.0 being released for Kubernetes 1.4, we are now at <code>client-go</code> 12.0 (at the time of this writing) for Kubernetes 1.15.</p>&#13;
&#13;
<p>This semver applies only to <code>client-go</code> itself, not to API Machinery or the API repository. Instead, the latter are tagged using Kubernetes versions, as seen in <a data-type="xref" href="#client-go-versioning">Figure 3-4</a>. See <a data-type="xref" href="#vendoring">“Vendoring”</a> to see what this means for vendoring <em>k8s.io/client-go</em>, <em>k8s.io/apimachinery</em>, and <em>k8s.io/api</em> in your project.</p>&#13;
&#13;
<figure><div class="figure" id="client-go-versioning">&#13;
<img alt="Client-go versioning" src="assets/prku_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>client-go versioning</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="API Versions and Compatibility Guarantees" data-type="sect2"><div class="sect2" id="api-versions">&#13;
<h2>API Versions and Compatibility Guarantees</h2>&#13;
&#13;
<p>As<a data-primary="repositories" data-secondary="API versions and compatibility guarantees" data-type="indexterm" id="idm46336866216792"/><a data-primary="compatibility" data-secondary="compatibility guarantees" data-type="indexterm" id="idm46336866215688"/> seen in the previous section, the selection of the right API group versions may be crucial if you target different cluster versions with your code. Kubernetes versions all API groups. A common Kubernetes-style versioning scheme is used, which consists of alpha, beta, and GA (general availability) versions.</p>&#13;
&#13;
<p>The pattern is:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>v1alpha1</code>, <code>v1alpha2</code>, <code>v2alpha1</code>, and so on are<a data-primary="alpha versions" data-type="indexterm" id="idm46336866211672"/> called <em>alpha versions</em> and considered unstable. This means:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>They might go away or change at any time, in any incompatible way.</p>&#13;
</li>&#13;
<li>&#13;
<p>Data might be dropped, get lost, or become inaccessible from Kubernetes version to version.</p>&#13;
</li>&#13;
<li>&#13;
<p>They are often disabled by default, if the administrator does not opt in <span class="keep-together">manually</span>.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p><code>v1beta1</code>, <code>v1beta2</code>, <code>v2beta1</code>, and so on, are<a data-primary="beta versions" data-type="indexterm" id="idm46336866204104"/> called <em>beta versions</em>. They are on the way to stability, which means:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>They will still exist for at least one Kubernetes release in parallel to the corresponding stable API version.</p>&#13;
</li>&#13;
<li>&#13;
<p>They will usually not change in incompatible ways, but there is no strict guarantee of that.</p>&#13;
</li>&#13;
<li>&#13;
<p>Objects stored in a beta version will not be dropped or become inaccessible.</p>&#13;
</li>&#13;
<li>&#13;
<p>Beta versions are often enabled in clusters by default. But this might depend on the Kubernetes distribution or cloud provider used.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p><code>v1</code>, <code>v2</code>, and so on are stable, generally available APIs; that is:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>They will stay.</p>&#13;
</li>&#13;
<li>&#13;
<p>They will be compatible.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Kubernetes has a <a href="http://bit.ly/2FOrKU8">formal deprecation policy</a> behind these rules of thumb. You can find many more details about which APIs constructs are considered compatible at the <a href="http://bit.ly/2XKPWAX">Kubernetes community GitHub</a>.</p>&#13;
</div>&#13;
&#13;
<p>In connection to API group versions, there are two important points to keep in mind:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>API group versions apply to API resources as a whole, like the format of pods or services. In addition to API group versions, API resources might have single fields that are versioned orthogonally; for example, fields in stable APIs might be marked as alpha quality in their Go inline code documentation. The same rules as those just listed for API groups will apply to those fields. For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An alpha field in a stable API could become incompatible, lose data, or go away at any time. For example, the <code>ObjectMeta.Initializers</code> field, which was never promoted beyond alpha, will go away in the near future (it is deprecated in 1.14):</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="c1">// DEPRECATED - initializers are an alpha field and will be removed</code>&#13;
<code class="c1">// in v1.15.</code>&#13;
<code class="nx">Initializers</code> <code class="o">*</code><code class="nx">Initializers</code> <code class="err">`</code><code class="nx">json</code><code class="p">:</code><code class="s">"initializers,omitempty"</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>It usually will be disabled by default and must be enabled with an API server feature gate, like so:</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">JobSpec</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
    <code class="c1">// This field is alpha-level and is only honored by servers that</code>&#13;
    <code class="c1">// enable the TTLAfterFinished feature.</code>&#13;
    <code class="nx">TTLSecondsAfterFinished</code> <code class="o">*</code><code class="kt">int32</code> <code class="err">`</code><code class="nx">json</code><code class="p">:</code><code class="s">"ttlSecondsAfterFinished,omitempty"</code>&#13;
<code class="p">}</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>The behavior of the API server will differ from field to field. Some alpha fields will be rejected and some will be ignored if the corresponding feature gate is not enabled. This is documented in the field description (see <code>TTLSecondsAfterFinished</code> in the previous example).</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Furthermore, API group versions play a role in accessing the API. Between different versions of the same resource, there is an<a data-primary="conversion" data-secondary="on-the-fly" data-type="indexterm" id="idm46336866163400"/> on-the-fly conversion done by the API server. That is, you can access objects created in one version (e.g., <code>v1beta1</code>) in any of the other supported versions (e.g., <code>v1</code>) without any further work in your application. This is very convenient for building backward- and forward-compatible applications.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Each object stored in <code>etcd</code> is stored in a specific version. By<a data-primary="storage versions" data-type="indexterm" id="idm46336866159656"/> default, this is called the <em>storage version</em> of that resource. While the storage version can change from Kubernetes version to version, the object stored in <code>etcd</code> will not automatically be updated as of this writing. Hence, the cluster administrator has to make sure migration happens in time when Kubernetes clusters are updated, before old version support is dropped. There is no generic migration mechanism for that, and migration differs from Kubernetes distribution to distribution.</p>&#13;
</li>&#13;
<li>&#13;
<p>For the application developer, though, this operational work should not matter at all. On-the-fly conversion will make sure the application has a unified picture of the objects in the cluster. The application will not even notice which storage version is in use. Storage versioning will be transparent to the written Go code.<a data-primary="" data-startref="CGrepo03" data-type="indexterm" id="idm46336866130600"/></p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes Objects in Go" data-type="sect1"><div class="sect1" id="kube-objects">&#13;
<h1>Kubernetes Objects in Go</h1>&#13;
&#13;
<p>In <a data-type="xref" href="#rest-client-config">“Creating and Using a Client”</a>, we<a data-primary="Kubernetes objects in Go" data-secondary="overview of" data-type="indexterm" id="idm46336866126296"/><a data-primary="client-go" data-secondary="Kubernetes objects in Go" data-type="indexterm" id="CGobjects03"/> saw how to create a client for the core group in order to access pods in a Kubernetes cluster. In the following, we want to look in more detail at what a pod—or any other Kubernetes resource, for that matter—is in the world of Go.</p>&#13;
&#13;
<p>Kubernetes resources—or more precisely the objects—that are instances of a kind<sup><a data-type="noteref" href="ch03.html#idm46336866123400" id="idm46336866123400-marker">1</a></sup> and are served as a resource by the API server are represented as structs. Depending on the kind in question, their fields of course differ. But on the other hand, they share a common structure.</p>&#13;
&#13;
<p>From the type system point of view, Kubernetes objects fulfill a Go interface called<a data-primary="runtime.Object" data-type="indexterm" id="idm46336866121256"/> <code>runtime.Object</code> from the package <em>k8s.io/apimachinery/pkg/runtime</em>, which actually is very simple:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Object interface must be supported by all API types registered with Scheme.</code>&#13;
<code class="c1">// Since objects in a scheme are expected to be serialized to the wire, the</code>&#13;
<code class="c1">// interface an Object must provide to the Scheme allows serializers to set</code>&#13;
<code class="c1">// the kind, version, and group the object is represented as. An Object may</code>&#13;
<code class="c1">// choose to return a no-op ObjectKindAccessor in cases where it is not</code>&#13;
<code class="c1">// expected to be serialized.</code>&#13;
<code class="kd">type</code> <code class="nx">Object</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">GetObjectKind</code><code class="p">()</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">ObjectKind</code>&#13;
    <code class="nx">DeepCopyObject</code><code class="p">()</code> <code class="nx">Object</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, <code>schema.ObjectKind</code> (from the <em>k8s.io/apimachinery/pkg/runtime/schema</em> package) is another simple interface:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// All objects that are serialized from a Scheme encode their type information.</code>&#13;
<code class="c1">// This interface is used by serialization to set type information from the</code>&#13;
<code class="c1">// Scheme onto the serialized version of an object. For objects that cannot</code>&#13;
<code class="c1">// be serialized or have unique requirements, this interface may be a no-op.</code>&#13;
<code class="kd">type</code> <code class="nx">ObjectKind</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="c1">// SetGroupVersionKind sets or clears the intended serialized kind of an</code>&#13;
    <code class="c1">// object. Passing kind nil should clear the current setting.</code>&#13;
    <code class="nx">SetGroupVersionKind</code><code class="p">(</code><code class="nx">kind</code> <code class="nx">GroupVersionKind</code><code class="p">)</code>&#13;
    <code class="c1">// GroupVersionKind returns the stored group, version, and kind of an</code>&#13;
    <code class="c1">// object, or nil if the object does not expose or provide these fields.</code>&#13;
    <code class="nx">GroupVersionKind</code><code class="p">()</code> <code class="nx">GroupVersionKind</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In other words, a Kubernetes object in Go is a data structure that can:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Return <em>and</em> set the <a data-primary="GroupVersionKind (GVK)" data-type="indexterm" id="idm46336866060264"/>GroupVersionKind</p>&#13;
</li>&#13;
<li>&#13;
<p>Be <em>deep-copied</em></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A <em>deep copy</em> is<a data-primary="deep copy" data-type="indexterm" id="idm46336866015256"/> a clone of the data structure such that it does not share any memory with the original object. It is used wherever code has to mutate an object without modifying the original. See <a data-type="xref" href="ch05.html#global-tags">“Global Tags”</a> about code generation for details on how deep copy is implemented in Kubernetes.</p>&#13;
&#13;
<p>Put simply, an object stores its type and allows cloning.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TypeMeta" data-type="sect2"><div class="sect2" id="TypeMeta">&#13;
<h2>TypeMeta</h2>&#13;
&#13;
<p>While <code>runtime.Object</code> is<a data-primary="Kubernetes objects in Go" data-secondary="TypeMeta" data-type="indexterm" id="idm46336866010216"/><a data-primary="TypeMeta" data-type="indexterm" id="idm46336866009240"/> only an interface, we want to know how it is actually implemented. Kubernetes objects from <em>k8s.io/api</em> implement the type getter and setter of <code>schema.ObjectKind</code> by embedding the <code>metav1.TypeMeta</code> struct from the package <em>k8s.io/apimachinery/meta/v1</em>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// TypeMeta describes an individual object in an API response or request</code>&#13;
<code class="c1">// with strings representing the type of the object and its API schema version.</code>&#13;
<code class="c1">// Structures that are versioned or persisted should inline TypeMeta.</code>&#13;
<code class="c1">//</code>&#13;
<code class="c1">// +k8s:deepcopy-gen=false</code>&#13;
<code class="kd">type</code> <code class="nx">TypeMeta</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Kind is a string value representing the REST resource this object</code>&#13;
    <code class="c1">// represents. Servers may infer this from the endpoint the client submits</code>&#13;
    <code class="c1">// requests to.</code>&#13;
    <code class="c1">// Cannot be updated.</code>&#13;
    <code class="c1">// In CamelCase.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Kind</code> <code class="kt">string</code> <code class="s">`json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`</code>&#13;
&#13;
    <code class="c1">// APIVersion defines the versioned schema of this representation of an</code>&#13;
    <code class="c1">// object. Servers should convert recognized schemas to the latest internal</code>&#13;
    <code class="c1">// value, and may reject unrecognized values.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">APIVersion</code> <code class="kt">string</code> <code class="s">`json:"apiVersion,omitempty"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this, a pod declaration in Go looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Pod is a collection of containers that can run on a host. This resource is</code>&#13;
<code class="c1">// created by clients and scheduled onto hosts.</code>&#13;
<code class="kd">type</code> <code class="nx">Pod</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">TypeMeta</code> <code class="s">`json:",inline"`</code>&#13;
    <code class="c1">// Standard object's metadata.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">ObjectMeta</code> <code class="s">`json:"metadata,omitempty"`</code>&#13;
&#13;
    <code class="c1">// Specification of the desired behavior of the pod.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Spec</code> <code class="nx">PodSpec</code> <code class="s">`json:"spec,omitempty"`</code>&#13;
&#13;
    <code class="c1">// Most recently observed status of the pod.</code>&#13;
    <code class="c1">// This data may not be up to date.</code>&#13;
    <code class="c1">// Populated by the system.</code>&#13;
    <code class="c1">// Read-only.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Status</code> <code class="nx">PodStatus</code> <code class="s">`json:"status,omitempty"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, <code>TypeMeta</code> is embedded. Moreover, the pod type has JSON tags that also declare <code>TypeMeta</code> as being inlined.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This <code>",inline"</code> tag is actually superfluous with the Golang JSON en/decoders: embedded structs are automatically inlined.</p>&#13;
&#13;
<p>This is different in the <a href="http://bit.ly/2ZuPZy2">YAML en/decoder <em>go-yaml/yaml</em></a>, which was used in very early Kubernetes code in parallel to JSON. We inherited the <a href="http://bit.ly/2IUGwcC">inline tag from that time</a>, but today it is merely documentation without any effect.</p>&#13;
&#13;
<p>The YAML serializers foudn in <em>k8s.io/apimachinery/pkg/runtime/serializer/yaml</em> use the <em>sigs.k8s.io/yaml</em> marshal and unmarshal functions. And these in turn encode and decode YAML via <code>interface{}</code>, and use the JSON encoder into and decoder from Golang API structs.</p>&#13;
</div>&#13;
&#13;
<p>This matches the YAML representation of a pod, which all Kubernetes users know:<sup><a data-type="noteref" href="ch03.html#idm46336865870888" id="idm46336865870888-marker">2</a></sup></p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">containers</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">hello</code>&#13;
    <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">debian:latest</code>&#13;
    <code class="nt">command</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">/bin/sh</code>&#13;
    <code class="nt">args</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">-c</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">echo "hello world"; sleep 10000</code></pre>&#13;
&#13;
<p>The version is stored in <code>TypeMeta.APIVersion</code>, the kind in <code>TypeMeta.Kind</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336865814888">&#13;
<h5>The Core Group Is Different for Historic Reasons</h5>&#13;
<p>Pods<a data-primary="core group" data-type="indexterm" id="idm46336865813512"/><a data-primary="legacy group" data-type="indexterm" id="idm46336865812776"/> and many other types that were added to Kubernetes very early on are part of the <em>core group</em>—often also called the <em>legacy group</em>—which is represented by the empty string. Hence, <code>apiVersion</code> is just set to "<code>v1</code>.”</p>&#13;
&#13;
<p>Eventually API groups were added to Kubernetes, and the group name, separated by a slash, was prepended to <code>apiVersion</code>. In the case of <code>apps</code>, the version would be <code>apps/v1</code>. Hence, the <code>apiVersion</code> field is actually misnamed; it stores the API group name and the version string. This is for historic reasons because <code>apiVersion</code> was defined when only the core group—and none of these other API groups—existed.</p>&#13;
</div></aside>&#13;
&#13;
<p>When running the example in <a data-type="xref" href="#rest-client-config">“Creating and Using a Client”</a> to get a pod from the cluster, notice that the pod object returned by the client does not actually have the kind and the version set. The convention in <code>client-go</code>–based applications is that these fields are empty in memory, and they are filled with the actual values on the wire only when they’re marshaled to JSON or protobuf. This is done automatically by the client, however, or, more precisely, by a versioning serializer.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336865805112">&#13;
<h5>Behind the Scenes: How Do Go Type, Packages, Kinds, and Group Names Relate?</h5>&#13;
<p>You<a data-primary="Go types" data-type="indexterm" id="idm46336865803816"/><a data-primary="kinds" data-secondary="relation to Go type, packages, and group names" data-type="indexterm" id="idm46336865803080"/> might be wondering how the client knows the kind and the API group to fill in the <code>TypeMeta</code> field. Although this question sounds trivial at first, it is not:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It looks like the kind is just the Go type name, which could be derived from an object via reflection. This is mostly true—maybe in 99% of the cases—but there are exceptions (in <a data-type="xref" href="ch04.html#ch_crds">Chapter 4</a> you will learn about custom resources where this does not work).</p>&#13;
</li>&#13;
<li>&#13;
<p>It looks like the group is just the Go package name (types for the <code>apps</code> API group are declared in <em>k8s.io/api/apps</em>). This often matches, but not in all cases: the core group has the empty group name string, as we have seen. The types for the group <code>rbac.authorization.k8s.io</code>, for example, are in <em>k8s.io/api/rbac</em>, not in <em>k8s.io/api/rbac.authorization.k8s.io</em>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The correct answer to the question of how to fill in the <code>TypeMeta</code> field involves the concept of a scheme, which will be discussed in more detail in <a data-type="xref" href="#scheme">“Scheme”</a>.</p>&#13;
</div></aside>&#13;
&#13;
<p>In other words, <code>client-go</code>–based applications check the Golang type of objects to determine the object at hand. This might differ in other frameworks, like the Operator SDK (see <a data-type="xref" href="ch06.html#operator-sdk">“The Operator SDK”</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ObjectMeta" data-type="sect2"><div class="sect2" id="ObjectMeta">&#13;
<h2>ObjectMeta</h2>&#13;
&#13;
<p>In<a data-primary="Kubernetes objects in Go" data-secondary="ObjectMeta" data-type="indexterm" id="idm46336865790440"/><a data-primary="ObjectMeta" data-type="indexterm" id="idm46336865789416"/> addition to <code>TypeMeta</code>, most top-level objects have a field of type <code>metav1.ObjectMeta</code>, again from the <em>k8s.io/apimachinery/pkg/meta/v1</em> package:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">ObjectMeta</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Name</code> <code class="kt">string</code> <code class="s">`json:"name,omitempty"`</code>&#13;
    <code class="nx">Namespace</code> <code class="kt">string</code> <code class="s">`json:"namespace,omitempty"`</code>&#13;
    <code class="nx">UID</code> <code class="nx">types</code><code class="p">.</code><code class="nx">UID</code> <code class="s">`json:"uid,omitempty"`</code>&#13;
    <code class="nx">ResourceVersion</code> <code class="kt">string</code> <code class="s">`json:"resourceVersion,omitempty"`</code>&#13;
    <code class="nx">CreationTimestamp</code> <code class="nx">Time</code> <code class="s">`json:"creationTimestamp,omitempty"`</code>&#13;
    <code class="nx">DeletionTimestamp</code> <code class="o">*</code><code class="nx">Time</code> <code class="s">`json:"deletionTimestamp,omitempty"`</code>&#13;
    <code class="nx">Labels</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code> <code class="s">`json:"labels,omitempty"`</code>&#13;
    <code class="nx">Annotations</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code> <code class="s">`json:"annotations,omitempty"`</code>&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In<a data-primary="metadata" data-type="indexterm" id="idm46336865665096"/> JSON or YAML these fields are under <em>metadata</em>. For example, for the previous pod, <code>metav1.ObjectMeta</code> stores:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example</code></pre>&#13;
&#13;
<p>In general, it contains all metalevel information like name, namespace, resource version (not to be confused with the API group version), several timestamps, and the well-known labels and annotations is part of <code>ObjectMeta</code>. See <a data-type="xref" href="ch04.html#anatomy-of-CRD-types">“Anatomy of a type”</a> for a deeper discussion of <code>ObjectMeta</code> fields.</p>&#13;
&#13;
<p>The resource version was discussed earlier in <a data-type="xref" href="ch01.html#optimistic-concurrency">“Optimistic Concurrency”</a>. It is hardly ever read or written from <code>client-go</code> code. But it is one of the fields in Kubernetes that makes the whole system work. <code>resourceVersion</code> is part of <code>ObjectMeta</code> because each object with embedded <code>ObjectMeta</code> corresponds to a key in <code>etcd</code> where the <code>resourceVersion</code> value originated.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="spec and status" data-type="sect2"><div class="sect2" id="idm46336865701176">&#13;
<h2>spec and status</h2>&#13;
&#13;
<p>Finally, nearly<a data-primary="Kubernetes objects in Go" data-secondary="spec and a status section" data-type="indexterm" id="idm46336865675576"/><a data-primary="spec and a status section" data-type="indexterm" id="idm46336865674632"/> every top-level object has a <code>spec</code> and a <code>status</code> section. This convention comes from the declarative nature of the Kubernetes API: <code>spec</code> is the user desire, and <code>status</code> is the outcome of that desire, usually filled by a controller in the system. See <a data-type="xref" href="ch01.html#ch_controllers-operators">“Controllers and Operators”</a> for a detailed discussion of controllers in Kubernetes.</p>&#13;
&#13;
<p>There are only a few exceptions to the <code>spec</code> and <code>status</code> convention in the system—for example, endpoints in the core group, or RBAC objects like <code>ClusterRole</code>.<a data-primary="" data-startref="CGobjects03" data-type="indexterm" id="idm46336865669656"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Client Sets" data-type="sect1"><div class="sect1" id="clientsets">&#13;
<h1>Client Sets</h1>&#13;
&#13;
<p>In<a data-primary="client-go" data-secondary="client sets" data-type="indexterm" id="CGsets03"/><a data-primary="client sets" data-secondary="role of" data-type="indexterm" id="idm46336865692808"/> the introductory example in <a data-type="xref" href="#rest-client-config">“Creating and Using a Client”</a>, we saw that <code>kubernetes.NewForConfig(config)</code> gives us a <em>client set</em>. A client set gives access to clients for multiple API groups and resources. In the case of <code>kubernetes.NewForConfig(config)</code> from <em>k8s.io/client-go/kubernetes</em>, we get access to all API groups and resources defined in <em>k8s.io/api</em>. This is, with a few exceptions—such as <code>APIServices</code> (for aggregated API servers) and <code>CustomResourceDefinition</code> (see <a data-type="xref" href="ch04.html#ch_crds">Chapter 4</a>)—the whole set of resources served by the Kubernetes API server.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch05.html#ch_autocodegen">Chapter 5</a>, we will explain how these client sets are actually generated from the API types (<em>k8s.io/api</em>, in this case). Third-party projects with custom APIs use more than just the Kubernetes client sets. What all of the client sets have in common is a<a data-primary="REST config" data-type="indexterm" id="idm46336865685384"/> REST config (e.g., returned by <code>clientcmd.BuildConfigFromFlags("", *kubeconfig)</code>, like in the example).</p>&#13;
&#13;
<p>The<a data-primary="client sets" data-secondary="main interface" data-type="indexterm" id="idm46336865683640"/> client set main interface in <em>k8s.io/client-go/kubernetes/typed</em> for Kubernetes-native resources looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Discovery</code><code class="p">()</code> <code class="nx">discovery</code><code class="p">.</code><code class="nx">DiscoveryInterface</code>&#13;
    <code class="nx">AppsV1</code><code class="p">()</code> <code class="nx">appsv1</code><code class="p">.</code><code class="nx">AppsV1Interface</code>&#13;
    <code class="nx">AppsV1beta1</code><code class="p">()</code> <code class="nx">appsv1beta1</code><code class="p">.</code><code class="nx">AppsV1beta1Interface</code>&#13;
    <code class="nx">AppsV1beta2</code><code class="p">()</code> <code class="nx">appsv1beta2</code><code class="p">.</code><code class="nx">AppsV1beta2Interface</code>&#13;
    <code class="nx">AuthenticationV1</code><code class="p">()</code> <code class="nx">authenticationv1</code><code class="p">.</code><code class="nx">AuthenticationV1Interface</code>&#13;
    <code class="nx">AuthenticationV1beta1</code><code class="p">()</code> <code class="nx">authenticationv1beta1</code><code class="p">.</code><code class="nx">AuthenticationV1beta1Interface</code>&#13;
    <code class="nx">AuthorizationV1</code><code class="p">()</code> <code class="nx">authorizationv1</code><code class="p">.</code><code class="nx">AuthorizationV1Interface</code>&#13;
    <code class="nx">AuthorizationV1beta1</code><code class="p">()</code> <code class="nx">authorizationv1beta1</code><code class="p">.</code><code class="nx">AuthorizationV1beta1Interface</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There used to be unversioned methods in this interface—for example, just <code>Apps() appsv1.AppsV1Interface</code>—but they were deprecated as of Kubernetes 1.14–based <code>client-go</code> 11.0. As mentioned before, it is seen as a good practice to be very explicit about the version of an API group that an application uses.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="internal-clients">&#13;
<h5>Versioned Clients and Internal Clients in the Past</h5>&#13;
<p>In<a data-primary="client sets" data-secondary="versioned clients and internal clients" data-type="indexterm" id="idm46336865577064"/> the past, Kubernetes had so-called <em>internal</em> clients. These used a generalized in-memory version for objects called “internal” with conversions to and from the on-the-wire version.</p>&#13;
&#13;
<p>The hope was to abstract controller code from the actual API version in use, and to be able to switch to another version with a one-line change. In practice, the huge additional complexity of implementing conversions and the amount of knowledge this conversion code required about the semantics of the objects led to the conclusion that this pattern wasn’t worth it.</p>&#13;
&#13;
<p>Furthermore, there was never any kind of autonegotiation between the client and the API server. Even with internal types and clients, the controllers were hardcoded to a specific version on the wire. So controllers using internal types were no more compatible in the case of version skew between client and server than those using versioned API types.</p>&#13;
&#13;
<p>In recent Kubernetes releases, a lot of code was rewritten to get rid of these internal versions completely. Today there are neither internal versions in <em>k8s.io/api</em> nor clients available in <em>k8s.io/client-go</em>.</p>&#13;
</div></aside>&#13;
&#13;
<p>Every<a data-primary="discovery client" data-type="indexterm" id="idm46336865571864"/><a data-primary="client sets" data-secondary="discovery client" data-type="indexterm" id="idm46336865571240"/> client set also gives access to the discovery client (it will be used by the <code>RESTMappers</code>; see <a data-type="xref" href="#RESTMapping">“REST Mapping”</a> and <a data-type="xref" href="ch02.html#api-cli">“Using the API from the Command Line”</a>).</p>&#13;
&#13;
<p>Behind<a data-primary="GroupVersion (GV)" data-type="indexterm" id="idm46336865567672"/> each <code>GroupVersion</code> method (e.g., <code>AppsV1beta1</code>), we find the resources of the API group—for example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">AppsV1beta1Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">RESTClient</code><code class="p">()</code> <code class="nx">rest</code><code class="p">.</code><code class="nx">Interface</code>&#13;
    <code class="nx">ControllerRevisionsGetter</code>&#13;
    <code class="nx">DeploymentsGetter</code>&#13;
    <code class="nx">StatefulSetsGetter</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>with<a data-primary="REST client" data-type="indexterm" id="idm46336865489240"/> <code>RESTClient</code> being a generic <em>REST client</em>, and one interface per resource, as in:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// DeploymentsGetter has a method to return a DeploymentInterface.</code>&#13;
<code class="c1">// A group's client should implement this interface.</code>&#13;
<code class="kd">type</code> <code class="nx">DeploymentsGetter</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Deployments</code><code class="p">(</code><code class="nx">namespace</code> <code class="kt">string</code><code class="p">)</code> <code class="nx">DeploymentInterface</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// DeploymentInterface has methods to work with Deployment resources.</code>&#13;
<code class="kd">type</code> <code class="nx">DeploymentInterface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Create</code><code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Update</code><code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">UpdateStatus</code><code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Delete</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">options</code> <code class="o">*</code><code class="nx">v1</code><code class="p">.</code><code class="nx">DeleteOptions</code><code class="p">)</code> <code class="kt">error</code>&#13;
    <code class="nx">DeleteCollection</code><code class="p">(</code><code class="nx">options</code> <code class="o">*</code><code class="nx">v1</code><code class="p">.</code><code class="nx">DeleteOptions</code><code class="p">,</code> <code class="nx">listOptions</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">)</code> <code class="kt">error</code>&#13;
    <code class="nx">Get</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">options</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">GetOptions</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">List</code><code class="p">(</code><code class="nx">opts</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">DeploymentList</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Watch</code><code class="p">(</code><code class="nx">opts</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">)</code> <code class="p">(</code><code class="nx">watch</code><code class="p">.</code><code class="nx">Interface</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Patch</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">pt</code> <code class="nx">types</code><code class="p">.</code><code class="nx">PatchType</code><code class="p">,</code> <code class="nx">data</code> <code class="p">[]</code><code class="kt">byte</code><code class="p">,</code> <code class="nx">subresources</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="nx">result</code> <code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">Deployment</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">DeploymentExpansion</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Depending on the scope of the resource—that is, whether it is cluster or namespace scoped—the accessor (here <code>DeploymentGetter</code>) may or may not have a <code>namespace</code> argument.</p>&#13;
&#13;
<p>The <code>DeploymentInterface</code> gives access to all the supported verbs of the resource. Most of them are self-explanatory, but those requiring additional commentary are described next.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Status Subresources: UpdateStatus" data-type="sect2"><div class="sect2" id="client-go-subresource">&#13;
<h2>Status Subresources: UpdateStatus</h2>&#13;
&#13;
<p>Deployments<a data-primary="client sets" data-secondary="status subresources" data-type="indexterm" id="idm46336865285848"/><a data-primary="status subresources" data-type="indexterm" id="idm46336865284840"/> have a so-called <em>status subresource</em>. This means that <code>UpdateStatus</code> uses an additional HTTP endpoint suffixed with <code>/status</code>. While updates on the <em>/apis/apps/v1beta1/namespaces/<em><code>ns</code></em>/deployments/<em><code>name</code></em></em> endpoint can change only the spec of the deployment, the endpoint /<em>apis/apps/v1beta1/namespaces/<em><code>ns</code></em>/deployments/<em><code>name</code></em>/status</em> can change only the status of the object. This is useful in order to set different permissions for spec updates (done by a human) and status updates (done by a controller).</p>&#13;
&#13;
<p>By<a data-primary="generator" data-secondary="client-gen" data-type="indexterm" id="idm46336865279112"/> default the <code>client-gen</code> (see <a data-type="xref" href="ch05.html#clientgen-tags">“client-gen Tags”</a>) generates the <span class="keep-together"><code>UpdateStatus()</code></span> method. The existence of the method does not guarantee that the resource actually supports the subresource. This will be important when we’re working with CRDs in <a data-type="xref" href="ch04.html#crd-subresources">“Subresources”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Listings and Deletions" data-type="sect2"><div class="sect2" id="idm46336865274744">&#13;
<h2>Listings and Deletions</h2>&#13;
&#13;
<p><code>DeleteCollection</code> allows<a data-primary="client sets" data-secondary="listings and deletions" data-type="indexterm" id="idm46336865272904"/> us to delete multiple objects of a namespace at once. The <code>ListOptions</code> parameter allows us to define which objects should be deleted<a data-primary="field selector" data-type="indexterm" id="idm46336865271384"/><a data-primary="label selector" data-type="indexterm" id="idm46336865270680"/> using a <em>field</em> or <em>label selector</em>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">ListOptions</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
&#13;
    <code class="c1">// A selector to restrict the list of returned objects by their labels.</code>&#13;
    <code class="c1">// Defaults to everything.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">LabelSelector</code> <code class="kt">string</code> <code class="s">`json:"labelSelector,omitempty"`</code>&#13;
    <code class="c1">// A selector to restrict the list of returned objects by their fields.</code>&#13;
    <code class="c1">// Defaults to everything.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">FieldSelector</code> <code class="kt">string</code> <code class="s">`json:"fieldSelector,omitempty"`</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Watches" data-type="sect2"><div class="sect2" id="client-go-watches">&#13;
<h2>Watches</h2>&#13;
&#13;
<p><code>Watch</code> gives<a data-primary="client sets" data-secondary="watches" data-type="indexterm" id="idm46336865238520"/><a data-primary="watches" data-type="indexterm" id="idm46336865237544"/> an event interface for all changes (adds, removes, and updates) to objects. The returned <code>watch.Interface</code> from <em>k8s.io/apimachinery/pkg/watch</em> looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Interface can be implemented by anything that knows how to watch and</code>&#13;
<code class="c1">// report changes.</code>&#13;
<code class="kd">type</code> <code class="nx">Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="c1">// Stops watching. Will close the channel returned by ResultChan(). Releases</code>&#13;
    <code class="c1">// any resources used by the watch.</code>&#13;
    <code class="nx">Stop</code><code class="p">()</code>&#13;
&#13;
    <code class="c1">// Returns a chan which will receive all the events. If an error occurs</code>&#13;
    <code class="c1">// or Stop() is called, this channel will be closed, in which case the</code>&#13;
    <code class="c1">// watch should be completely cleaned up.</code>&#13;
    <code class="nx">ResultChan</code><code class="p">()</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="nx">Event</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The result channel of the <code>watch</code> interface returns three kinds of events:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// EventType defines the possible types of events.</code>&#13;
<code class="kd">type</code> <code class="nx">EventType</code> <code class="kt">string</code>&#13;
&#13;
<code class="kd">const</code> <code class="p">(</code>&#13;
    <code class="nx">Added</code>    <code class="nx">EventType</code> <code class="p">=</code> <code class="s">"ADDED"</code>&#13;
    <code class="nx">Modified</code> <code class="nx">EventType</code> <code class="p">=</code> <code class="s">"MODIFIED"</code>&#13;
    <code class="nx">Deleted</code>  <code class="nx">EventType</code> <code class="p">=</code> <code class="s">"DELETED"</code>&#13;
    <code class="nx">Error</code>    <code class="nx">EventType</code> <code class="p">=</code> <code class="s">"ERROR"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Event represents a single event to a watched resource.</code>&#13;
<code class="c1">// +k8s:deepcopy-gen=true</code>&#13;
<code class="kd">type</code> <code class="nx">Event</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Type</code> <code class="nx">EventType</code>&#13;
&#13;
    <code class="c1">// Object is:</code>&#13;
    <code class="c1">//  * If Type is Added or Modified: the new state of the object.</code>&#13;
    <code class="c1">//  * If Type is Deleted: the state of the object immediately before</code>&#13;
    <code class="c1">//    deletion.</code>&#13;
    <code class="c1">//  * If Type is Error: *api.Status is recommended; other types may</code>&#13;
    <code class="c1">//    make sense depending on context.</code>&#13;
    <code class="nx">Object</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>While it is tempting to use this interface directly, in practice it is actually discouraged in favor of informers (see <a data-type="xref" href="#informers">“Informers and Caching”</a>). Informers are a combination of this event interface and an in-memory cache with indexed lookup. This is by far the most common use case for watches. Under the hood informers first call <code>List</code> on the client to get the set of all objects (as a baseline for the cache) and then <code>Watch</code> to update the cache. They handle error conditions correctly—that is, recover from network issues or other cluster problems.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Client Expansion" data-type="sect2"><div class="sect2" id="idm46336865258552">&#13;
<h2>Client Expansion</h2>&#13;
&#13;
<p><code>DeploymentExpansion</code> is<a data-primary="client sets" data-secondary="client expansion" data-type="indexterm" id="idm46336865090792"/> actually an empty interface. It is used to add custom client behavior, but it’s hardly used in Kubernetes nowadays. Instead, the client generator allows us to add custom methods in a declarative way (see <a data-type="xref" href="ch05.html#clientgen-tags">“client-gen Tags”</a>).</p>&#13;
&#13;
<p>Note again that all of those methods in <code>DeploymentInterface</code> neither expect valid information in the <code>TypeMeta</code> fields <code>Kind</code> and <code>APIVersion</code>, nor set those fields on <code>Get()</code> and <code>List()</code> (see also <a data-type="xref" href="#TypeMeta">“TypeMeta”</a>). These fields are filled with real values only on the wire.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Client Options" data-type="sect2"><div class="sect2" id="idm46336865084280">&#13;
<h2>Client Options</h2>&#13;
&#13;
<p>It<a data-primary="client sets" data-secondary="client options" data-type="indexterm" id="idm46336865082744"/> is worth looking at the different options we can set when creating a client set. In the note before <a data-type="xref" href="#versioning-capability">“Versioning and Compatibility”</a>, we saw that we can switch to the protobuf wire format for native Kubernetes types. Protobuf is more efficient than JSON (both spacewise and for the CPU load of the client and server) and therefore preferable.</p>&#13;
&#13;
<p>For debugging purposes and readability of metrics, it is often helpful to differentiate between different clients accessing the API server. To<a data-primary="user agents" data-type="indexterm" id="idm46336865079704"/> do so, we can set the <em>user agent</em> field in the REST config. The default value is <code>binary/version (os/arch) kubernetes/commit</code>; for example, <code>kubectl</code> will use a user agent like <code>kubectl/v1.14.0 (darwin/amd64) kubernetes/d654b49</code>. If that pattern does not suffice for the setup, it can be customized like so:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">cfg</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="o">*</code><code class="nx">kubeconfig</code><code class="p">)</code>&#13;
<code class="nx">cfg</code><code class="p">.</code><code class="nx">AcceptContentTypes</code> <code class="p">=</code> <code class="s">"application/vnd.kubernetes.protobuf,application/json"</code>&#13;
<code class="nx">cfg</code><code class="p">.</code><code class="nx">UserAgent</code> <code class="p">=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code>&#13;
    <code class="s">"book-example/v1.0 (%s/%s) kubernetes/v1.0"</code><code class="p">,</code>&#13;
    <code class="nx">runtime</code><code class="p">.</code><code class="nx">GOOS</code><code class="p">,</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">GOARCH</code>&#13;
<code class="p">)</code>&#13;
<code class="nx">clientset</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">kubernetes</code><code class="p">.</code><code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">cfg</code><code class="p">)</code></pre>&#13;
&#13;
<p>Other<a data-primary="rate limiting" data-type="indexterm" id="idm46336864949160"/><a data-primary="timeouts" data-type="indexterm" id="idm46336864996840"/><a data-primary="throttling" data-type="indexterm" id="idm46336864996232"/> values often overridden in the REST config are those for client-side <em>rate limiting</em> and <em>timeouts</em>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Config holds the common attributes that can be passed to a Kubernetes</code>&#13;
<code class="c1">// client on initialization.</code>&#13;
<code class="kd">type</code> <code class="nx">Config</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
&#13;
    <code class="c1">// QPS indicates the maximum QPS to the master from this client.</code>&#13;
    <code class="c1">// If it's zero, the created RESTClient will use DefaultQPS: 5</code>&#13;
    <code class="nx">QPS</code> <code class="kt">float32</code>&#13;
&#13;
    <code class="c1">// Maximum burst for throttle.</code>&#13;
    <code class="c1">// If it's zero, the created RESTClient will use DefaultBurst: 10.</code>&#13;
    <code class="nx">Burst</code> <code class="kt">int</code>&#13;
&#13;
    <code class="c1">// The maximum length of time to wait before giving up on a server request.</code>&#13;
    <code class="c1">// A value of zero means no timeout.</code>&#13;
    <code class="nx">Timeout</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>QPS</code> value defaults to <code>5</code> requests<a data-primary="throttling" data-secondary="queries per second" data-type="indexterm" id="idm46336864974456"/> per second, with<a data-primary="throttling" data-secondary="burst" data-type="indexterm" id="idm46336864919032"/> a burst of <code>10</code>.</p>&#13;
&#13;
<p>The<a data-primary="long-running requests" data-type="indexterm" id="idm46336864916968"/><a data-primary="request processing" data-type="indexterm" id="idm46336864916232"/><a data-primary="Kubernetes API" data-secondary="request processing" data-type="indexterm" id="idm46336864915560"/><a data-primary="server request processing" data-type="indexterm" id="idm46336864914616"/> timeout has no default value, at least not in the client REST config. By default the Kubernetes API server will timeout every request that is not a <em>long-running</em> request after 60 seconds. A long-running request can be a watch request or unbounded requests to subresources like <em>/exec</em>, <em>/portforward</em>, or <em>/proxy</em>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336864911864">&#13;
<h5>Graceful Shutdown and Being Resilient to Connection Errors</h5>&#13;
<p>Requests<a data-primary="graceful shutdowns" data-type="indexterm" id="idm46336864910296"/> are split into long-running and non-long-running. Watches are long-running, while <code>GET</code>, <code>LIST</code>, <code>UPDATE</code>, and the like are non-long-running. Many subresources (e.g., for log streaming, exec, port-forward) are long-running as well.</p>&#13;
&#13;
<p>When the Kubernetes API server is restarted (e.g., during an update), it waits for up to 60 seconds to gracefully shut down. During that time, it finishes non-long-running requests and then terminates. When it terminates, long-running requests like ongoing watch connections are cut off.</p>&#13;
&#13;
<p>Non-long-running requests are bounded by 60 seconds anyway (and then they timeout). Hence, from the client point of view, the shutdown is graceful.</p>&#13;
&#13;
<p>In general, application code should always be prepared for requests that are not successful and should respond in such a way that they are not fatal for the application. In the world of distributed systems, those<a data-primary="connection errors" data-type="indexterm" id="idm46336864906072"/><a data-primary="errors" data-secondary="connection errors" data-type="indexterm" id="idm46336864905368"/> connection errors are normal and nothing to worry about. But special attention is required to carefully handle error conditions and recover from them.</p>&#13;
&#13;
<p>Error handling is especially important for<a data-primary="watches" data-type="indexterm" id="idm46336864903752"/> watches. Watches are long-running, but they can fail at any time. The informers described in the next section provide a resilient implementation around watches and handle errors gracefully—that is, they recover from disconnects with a new connection. Application code usually will not notice.<a data-primary="" data-startref="CGsets03" data-type="indexterm" id="idm46336864972040"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Informers and Caching" data-type="sect1"><div class="sect1" id="informers">&#13;
<h1>Informers and Caching</h1>&#13;
&#13;
<p>The<a data-primary="informers" data-secondary="caching and" data-type="indexterm" id="INcach03"/><a data-primary="caching" data-secondary="in-memory" data-type="indexterm" id="Cinmem03"/><a data-primary="client-go" data-secondary="informers and caching" data-type="indexterm" id="CGinform03"/> client interface in <a data-type="xref" href="#clientsets">“Client Sets”</a> includes the <code>Watch</code> verb, which offers an event interface that reacts to changes (adds, removes, updates) of objects. Informers give a higher-level programming interface for the most common use case for watches: in-memory caching and fast, indexed lookup of objects by name or other properties in-memory.</p>&#13;
&#13;
<p>A controller that accesses the API server every time it needs an object creates a high load on the system. In-memory caching using informers is the solution to this problem. Moreover, informers can react to changes of objects nearly in real-time instead of requiring polling requests.</p>&#13;
&#13;
<p><a data-type="xref" href="#informers-figure">Figure 3-5</a> shows the conceptional pattern of informers; specifically, they:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Get input from the API server as events.</p>&#13;
</li>&#13;
<li>&#13;
<p>Offer a client-like interface called <code>Lister</code> to get and list objects from the in-memory cache.</p>&#13;
</li>&#13;
<li>&#13;
<p>Register event handlers for adds, removes, and updates.</p>&#13;
</li>&#13;
<li>&#13;
<p>Implement the in-memory cache<a data-primary="stores" data-type="indexterm" id="idm46336864957816"/> using a <em>store</em>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="informers-figure">&#13;
<img alt="Informers" src="assets/prku_0305.png"/>&#13;
<h6><span class="label">Figure 3-5. </span>Informers</h6>&#13;
</div></figure>&#13;
&#13;
<p>Informers<a data-primary="errors" data-secondary="advanced error behavior of informers" data-type="indexterm" id="idm46336864874648"/> also have advanced error behavior: when the long-running watch connection breaks down, they recover from it by trying another watch request, picking up the event stream without losing any events. If the outage is long, and the API server lost events because <code>etcd</code> purged them from its database before the new watch request was successful, the informer will<a data-primary="relist period" data-type="indexterm" id="idm46336864873032"/> relist all objects.</p>&#13;
&#13;
<p>Next to <em>relists</em>, there is a<a data-primary="resync period" data-type="indexterm" id="idm46336864871432"/> configurable <em>resync period</em> for reconciliation between the in-memory cache and the business logic: the registered event handlers will be called for all objects each time this period has passed. Common values are in minutes (e.g., 10 or 30 minutes).</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The resync is purely in-memory and <em>does not trigger a call to the server</em>. This used to be different but was <a href="http://bit.ly/2FmeMge">eventually changed</a> because the error behavior of the watch mechanism had been improved enough to make relists unnecessary.</p>&#13;
</div>&#13;
&#13;
<p>All this advanced and battle-proven error behavior is a good reason for using informers instead of rolling out custom logic using the client <code>Watch()</code> method directly. Informers are used everywhere in Kubernetes itself and are one of the main architectural concepts in the Kubernetes API design.</p>&#13;
&#13;
<p>While informers are preferred over polling, they create load on the API server. One binary should instantiate only one informer per GroupVersionResource. To<a data-primary="shared informer factory" data-type="indexterm" id="idm46336864865736"/> make sharing of informers easy, we can instantiate an informer by using the <em>shared informer factory</em>.</p>&#13;
&#13;
<p>The shared informer factory allows informers to be shared for the same resource in an application. In other words, different control loops can use the same watch <span class="keep-together">connection</span> to the API server under the hood. For<a data-primary="kube-controller-manager" data-type="indexterm" id="idm46336864863160"/> example, the <code>kube-controller-manager</code>, one of the main Kubernetes cluster components (see <a data-type="xref" href="ch02.html#api-server">“The API Server”</a>), has a larger, two-digit number of controllers. But for each resource (e.g., pods), there is only one informer in the process.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Always use a shared informer factory to instantiate informers. Don’t try to instantiate informers manually. The overhead is minimal, and a nontrivial controller binary that does not use shared informers probably is opening multiple watch connections for the same resource somewhere.</p>&#13;
</div>&#13;
&#13;
<p>Starting with a<a data-primary="REST config" data-type="indexterm" id="idm46336864859048"/> REST config (see <a data-type="xref" href="#rest-client-config">“Creating and Using a Client”</a>), it is easy to create a shared informer factory using a client set. The informers are generated by a code generator and shipped as part of <code>client-go</code> for the standard Kubernetes resources in <em>k8s.io/client-go/informers</em>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="o">...</code>&#13;
    <code class="s">"k8s.io/client-go/informers"</code>&#13;
<code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="nx">clientset</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">kubernetes</code><code class="p">.</code><code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">config</code><code class="p">)</code>&#13;
<code class="nx">informerFactory</code> <code class="o">:=</code> <code class="nx">informers</code><code class="p">.</code><code class="nx">NewSharedInformerFactory</code><code class="p">(</code><code class="nx">clientset</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="o">*</code><code class="mi">30</code><code class="p">)</code>&#13;
<code class="nx">podInformer</code> <code class="o">:=</code> <code class="nx">informerFactory</code><code class="p">.</code><code class="nx">Core</code><code class="p">().</code><code class="nx">V1</code><code class="p">().</code><code class="nx">Pods</code><code class="p">()</code>&#13;
<code class="nx">podInformer</code><code class="p">.</code><code class="nx">Informer</code><code class="p">().</code><code class="nx">AddEventHandler</code><code class="p">(</code><code class="nx">cache</code><code class="p">.</code><code class="nx">ResourceEventHandlerFuncs</code><code class="p">{</code>&#13;
    <code class="nx">AddFunc</code><code class="p">:</code> <code class="kd">func</code><code class="p">(</code><code class="nx">new</code> <code class="kd">interface</code><code class="p">{})</code> <code class="p">{</code><code class="o">...</code><code class="p">},</code>&#13;
    <code class="nx">UpdateFunc</code><code class="p">:</code> <code class="kd">func</code><code class="p">(</code><code class="nx">old</code><code class="p">,</code> <code class="nx">new</code> <code class="kd">interface</code><code class="p">{})</code> <code class="p">{</code><code class="o">...</code><code class="p">},</code>&#13;
    <code class="nx">DeleteFunc</code><code class="p">:</code> <code class="kd">func</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">interface</code><code class="p">{})</code> <code class="p">{</code><code class="o">...</code><code class="p">},</code>&#13;
<code class="p">})</code>&#13;
<code class="nx">informerFactory</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">wait</code><code class="p">.</code><code class="nx">NeverStop</code><code class="p">)</code>&#13;
<code class="nx">informerFactory</code><code class="p">.</code><code class="nx">WaitForCacheSync</code><code class="p">(</code><code class="nx">wait</code><code class="p">.</code><code class="nx">NeverStop</code><code class="p">)</code>&#13;
<code class="nx">pod</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">podInformer</code><code class="p">.</code><code class="nx">Lister</code><code class="p">().</code><code class="nx">Pods</code><code class="p">(</code><code class="s">"programming-kubernetes"</code><code class="p">).</code><code class="nx">Get</code><code class="p">(</code><code class="s">"client-go"</code><code class="p">)</code></pre>&#13;
&#13;
<p>The example shows how to get a shared informer for pods.</p>&#13;
&#13;
<p>You can see that informers allow for the addition of<a data-primary="event handlers" data-type="indexterm" id="idm46336864853432"/> event handlers for the three cases <em>add</em>, <em>update</em>, and <em>delete</em>. These are usually used to trigger the business logic of a <span class="keep-together">controller</span>—that is, to process a certain object again (see <a data-type="xref" href="ch01.html#ch_controllers-operators">“Controllers and Operators”</a>). Often those handlers just add the modified object into a work queue.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336864764808">&#13;
<h5>Additional Event Handlers and the Internal Store Update Logic</h5>&#13;
<p>Don’t confuse these handlers with the update logic of the in-memory store (accessible through the lister in the last line of the example) inside the informer. The informer will always update its store, but the additional event handlers just described are optional and meant to be used by the consumer of the informer.</p>&#13;
</div></aside>&#13;
&#13;
<p>Also note that many event handlers can be added. The whole shared informer factory concept exists only because this is so common in controller binaries with many control loops, each installing event handlers to add objects to their own work queue.</p>&#13;
&#13;
<p>After registering handlers, the shared informer factory has to be started. There are Go routines under the hood that do the actual calls to the API server. The <code>Start</code> method (with a stop channel to control the lifecycle) starts these Go routines, and the <code>WaitForCacheSync()</code> method makes the code wait for the first <code>List</code> calls to the clients to finish. If the controller logic requires that the cache is filled, this <code>WaitForCacheSync</code> call is essential.</p>&#13;
&#13;
<p>In general, the event interface of the watches behind the scenes leads to a certain lag. In a setup with proper capacity planning, this lag is not huge. Of course, it is good practice to measure this lag using metrics. But the lag exists regardless, so the application logic has be built in such a way that the lag does not harm the behavior of the code.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The lag of informers can lead to races between changes the controller makes with <code>client-go</code> directly on the API server, and the state of the world as known by the informers.</p>&#13;
&#13;
<p>If the controller changes an object, the informer in the same process has to wait until the corresponding event arrives and the in-memory store is then updated. This process is not instantaneous, and another controller work loop run might be started through another trigger before the previous change has become visible.</p>&#13;
</div>&#13;
&#13;
<p>The resync interval of 30 seconds in this example leads to a complete set of events being sent to the registered <code>UpdateFunc</code> such that the controller logic is able to reconcile its state with that of the API server. By comparing the <code>ObjectMeta.resourceVersion</code> field, it is possible to distinguish a real update from a resync.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Choosing a good resync interval depends on the context. For example, 30 seconds is pretty short. In many situations several minutes, or even 30 minutes, is a good choice. In the worst case, 30 minutes means that it takes 30 minutes until a bug in the code (e.g., a lost signal due to bad error handling) is repaired via <span class="keep-together">reconciliation</span>.</p>&#13;
</div>&#13;
&#13;
<p>Also note that the final line in the example calling <code>Get("client-go")</code> is purely in-memory; there is no access to the API server. Objects in the in-memory store cannot be modified directly. Instead, the client set must be used for any write access to the resources. The informer will then get events from the API server and update its in-memory store.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336864751512">&#13;
<h5>Never Mutate Objects from Informers</h5>&#13;
<p>It is very important to remember that any object passed from the listers to the event handlers is owned by the informers. If you mutate it in any way, you risk introducing hard-to-debug<a data-primary="caching" data-secondary="cache coherency issues" data-type="indexterm" id="idm46336864749960"/><a data-primary="errors" data-secondary="cache coherency issues" data-type="indexterm" id="idm46336864748984"/> cache coherency issues into your application. Always do a deep copy (see <a data-type="xref" href="#kube-objects">“Kubernetes Objects in Go”</a>) before changing an object.</p>&#13;
&#13;
<p>In general: before mutating an object, always ask yourself who owns this object or the data structures in it. As a rule of thumb:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Informers and listers own objects they return. Hence, consumers have to deep-copy before mutation.</p>&#13;
</li>&#13;
<li>&#13;
<p>Clients return fresh objects, which the caller owns.</p>&#13;
</li>&#13;
<li>&#13;
<p>Conversions return shared objects. If the caller does own the input object, it does not own the output.</p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
&#13;
<p>The informer constructor <code>NewSharedInformerFactory</code> in the example caches all objects of a resource in all namespaces in the store. If this is too much for the application, there is an alternative constructor with more flexibility:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// NewFilteredSharedInformerFactory constructs a new instance of</code>&#13;
<code class="c1">// sharedInformerFactory. Listers obtained via this sharedInformerFactory will be</code>&#13;
<code class="c1">// subject to the same filters as specified here.</code>&#13;
<code class="kd">func</code> <code class="nx">NewFilteredSharedInformerFactory</code><code class="p">(</code>&#13;
    <code class="nx">client</code> <code class="nx">versioned</code><code class="p">.</code><code class="nx">Interface</code><code class="p">,</code> <code class="nx">defaultResync</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">,</code>&#13;
    <code class="nx">namespace</code> <code class="kt">string</code><code class="p">,</code>&#13;
    <code class="nx">tweakListOptions</code> <code class="nx">internalinterfaces</code><code class="p">.</code><code class="nx">TweakListOptionsFunc</code>&#13;
<code class="p">)</code> <code class="nx">SharedInformerFactor</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">TweakListOptionsFunc</code> <code class="kd">func</code><code class="p">(</code><code class="o">*</code><code class="nx">v1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">)</code></pre>&#13;
&#13;
<p>It allows us to specify a namespace and to pass a <code>TweakListOptionsFunc</code>, which may mutate the <code>ListOptions</code> struct used to list and watch objects using the <code>List</code> and <code>Watch</code> calls of the client. It can be used to set <em>label</em> or <em>field selectors</em>, for example.</p>&#13;
&#13;
<p>Informers are one of the building blocks of controllers. In <a data-type="xref" href="ch06.html#ch_operator-solutions">Chapter 6</a> we will see what a typical <code>client-go</code>-based controller looks like. After the clients and informers, the third main building block is the work queue. Let’s look at it now.<a data-primary="" data-startref="INcach03" data-type="indexterm" id="idm46336864580392"/><a data-primary="" data-startref="Cinmem03" data-type="indexterm" id="idm46336864579416"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Work Queue" data-type="sect2"><div class="sect2" id="workqueue">&#13;
<h2>Work Queue</h2>&#13;
&#13;
<p>A<a data-primary="informers" data-secondary="work queues" data-type="indexterm" id="idm46336864713336"/><a data-primary="caching" data-secondary="work queues" data-type="indexterm" id="idm46336864712328"/><a data-primary="work queues" data-type="indexterm" id="idm46336864711384"/><a data-primary="priority queues" data-type="indexterm" id="idm46336864710712"/> work queue is a data structure. You can add elements and take elements out of the queue, in an order predefined by the queue. Formally, this kind of queue is called a <em>priority queue</em>. <code>client-go</code> provides a powerful implementation for the purpose of building controllers in <a href="http://bit.ly/2IV0JPz"><em>k8s.io/client-go/util/workqueue</em></a>.</p>&#13;
&#13;
<p>More precisely, the package contains a number of variants for different purposes. The base interface implemented by all variants looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Add</code><code class="p">(</code><code class="nx">item</code> <code class="kd">interface</code><code class="p">{})</code>&#13;
    <code class="nx">Len</code><code class="p">()</code> <code class="kt">int</code>&#13;
    <code class="nx">Get</code><code class="p">()</code> <code class="p">(</code><code class="nx">item</code> <code class="kd">interface</code><code class="p">{},</code> <code class="nx">shutdown</code> <code class="kt">bool</code><code class="p">)</code>&#13;
    <code class="nx">Done</code><code class="p">(</code><code class="nx">item</code> <code class="kd">interface</code><code class="p">{})</code>&#13;
    <code class="nx">ShutDown</code><code class="p">()</code>&#13;
    <code class="nx">ShuttingDown</code><code class="p">()</code> <code class="kt">bool</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here <code>Add(item)</code> adds an item, <code>Len()</code> gives the length, and <code>Get()</code> returns an item with the highest priority (and it blocks until one is available). Every item returned by <code>Get()</code> needs a <code>Done(item)</code> call when the controller has finished processing it. Meanwhile, a repeated <code>Add(item)</code> will only mark the item as dirty such that it is readded when <code>Done(item)</code> has been called.</p>&#13;
&#13;
<p>The following queue types are derived from this generic interface:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>DelayingInterface</code> can add an item at a later time. This makes it easier to&#13;
requeue items after failures without ending up in a hot-loop:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">DelayingInterface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Interface</code>&#13;
    <code class="c1">// AddAfter adds an item to the workqueue after the</code>&#13;
    <code class="c1">// indicated duration has passed.</code>&#13;
    <code class="nx">AddAfter</code><code class="p">(</code><code class="nx">item</code> <code class="kd">interface</code><code class="p">{},</code> <code class="nx">duration</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
</li>&#13;
<li>&#13;
<p><code>RateLimitingInterface</code> rate-limits items being added to the queue. It extends the <code>DelayingInterface:</code></p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">RateLimitingInterface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">DelayingInterface</code>&#13;
&#13;
    <code class="c1">// AddRateLimited adds an item to the workqueue after the rate</code>&#13;
    <code class="c1">// limiter says it's OK.</code>&#13;
    <code class="nx">AddRateLimited</code><code class="p">(</code><code class="nx">item</code> <code class="kd">interface</code><code class="p">{})</code>&#13;
&#13;
    <code class="c1">// Forget indicates that an item is finished being retried.</code>&#13;
    <code class="c1">// It doesn't matter whether it's for perm failing or success;</code>&#13;
    <code class="c1">// we'll stop the rate limiter from tracking it. This only clears</code>&#13;
    <code class="c1">// the `rateLimiter`; you still have to call `Done` on the queue.</code>&#13;
    <code class="nx">Forget</code><code class="p">(</code><code class="nx">item</code> <code class="kd">interface</code><code class="p">{})</code>&#13;
&#13;
    <code class="c1">// NumRequeues returns back how many times the item was requeued.</code>&#13;
    <code class="nx">NumRequeues</code><code class="p">(</code><code class="nx">item</code> <code class="kd">interface</code><code class="p">{})</code> <code class="kt">int</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Most interesting here is the <code>Forget(item)</code> method: it resets the back-off of the given item. Usually, it will be called when an item has been processed successfully.</p>&#13;
&#13;
<p>The rate limiting algorithm can be passed to the constructor <code>NewRateLimitingQueue</code>. There are several rate limiters defined in the same package, such as the <span class="keep-together"><code>BucketRateLimiter</code></span>, the <code>ItemExponentialFailureRateLimiter</code>, the <code>ItemFastSlowRateLimiter</code>, and the <code>MaxOfRateLimiter</code>. For more details, you can refer to the package documentation. Most controllers will just use the <code>DefaultControllerRateLimiter() *RateLimiter</code> functions, which gives:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An exponential back-off starting at 5 ms and going up to 1,000 seconds, doubling the delay on each error</p>&#13;
</li>&#13;
<li>&#13;
<p>A maximal rate of 10 items per second and 100 items burst</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Depending on the context, you might want to customize the values. A 1,000 seconds maximal back-off per item is a lot for certain controller applications.<a data-primary="" data-startref="CGinform03" data-type="indexterm" id="idm46336864434520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="API Machinery in Depth" data-type="sect1"><div class="sect1" id="api-machinery-core">&#13;
<h1>API Machinery in Depth</h1>&#13;
&#13;
<p>The<a data-primary="API Machinery features" data-type="indexterm" id="APImachine03"/><a data-primary="client-go" data-secondary="API Machinery repository" data-type="indexterm" id="CGapi03"/> API Machinery repository implements the basics of the Kubernetes type system. But what is this type system exactly? What is a type to begin with?</p>&#13;
&#13;
<p>The<a data-primary="type system" data-type="indexterm" id="idm46336864429224"/> term <em>type</em> actually does not exist in the terminology of API Machinery. Instead, it refers to <em>kinds</em>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kinds" data-type="sect2"><div class="sect2" id="kinds">&#13;
<h2>Kinds</h2>&#13;
&#13;
<p>Kinds<a data-primary="kinds" data-secondary="GroupVersionKind (GVK)" data-type="indexterm" id="idm46336864425528"/><a data-primary="GroupVersionKind (GVK)" data-type="indexterm" id="idm46336864424520"/> are divided into API groups and are versioned, as we already have seen in <a data-type="xref" href="ch02.html#terminology">“API Terminology”</a>. Therefore, a core term in the API Machinery repository is GroupVersionKind, or <em>GVK</em> for short.</p>&#13;
&#13;
<p>In Go, each GVK corresponds to one Go type. In contrast, a Go type can belong to multiple GVKs.</p>&#13;
&#13;
<p>Kinds do not formally map one-to-one to HTTP paths. Many kinds have HTTP REST endpoints that are used to access objects of the given kind. But there are also kinds without any HTTP endpoint (e.g., <a href="http://bit.ly/2XJXBQD"><em>admission.k8s.io/v1beta1.AdmissionReview</em></a>, which is used to call out to a webhook). There are also kinds that are returned from many endpoints—for example, <a href="http://bit.ly/31Ktjvz"><em>meta.k8s.io/v1.Status</em></a>, which is returned by all endpoints to report a nonobject status like an error.</p>&#13;
&#13;
<p>By<a data-primary="kinds" data-secondary="formatting of" data-type="indexterm" id="idm46336864419208"/> convention, kinds are formatted in <a href="http://bit.ly/31IqMSC">CamelCase</a> like words and are usually singular. Depending on the context, their concrete format differs. For CustomResourceDefinition kinds, it must be a DNS path label (RFC 1035).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Resources" data-type="sect2"><div class="sect2" id="resources">&#13;
<h2>Resources</h2>&#13;
&#13;
<p>In<a data-primary="resources" data-secondary="GroupVersionResource (GVR)" data-type="indexterm" id="idm46336864415192"/><a data-primary="GroupVersionResource (GVR)" data-type="indexterm" id="idm46336864414216"/> parallel to kinds, as we saw in <a data-type="xref" href="ch02.html#terminology">“API Terminology”</a>, there is the concept of a <em>resource</em>. Resources are again grouped and versioned, leading to the term <em>GroupVersionResource</em>, or <em>GVR</em> for short.</p>&#13;
&#13;
<p>Each GVR corresponds to one HTTP (base) path. GVRs are used to identify REST endpoints of the Kubernetes API. For example, the GVR <em>apps/v1.deployments</em> maps to <em>/apis/apps/v1/namespaces/<code>namespace</code>/deployments</em>.</p>&#13;
&#13;
<p>Client libraries use this mapping to construct the HTTP path to access a GVR.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336864409032">&#13;
<h5>Knowing Whether a Resource Is Namespaced or Cluster-Scoped</h5>&#13;
<p>You<a data-primary="resources" data-secondary="namespaces versus cluster-scoped" data-type="indexterm" id="idm46336864407736"/> have to know whether a GVR is namespaced or cluster-scoped in order to know the HTTP path. Deployments, for example, are namespaced and therefore get the namespace as part of their HTTP path. Other GVRs, such as <em>rbac.authorization.k8s.io/v1.clusterroles</em>, are cluster-scoped; for example, cluster roles can be accessed at <em>apis/rbac.authorization.k8s.io/v1/clusterroles</em>.</p>&#13;
</div></aside>&#13;
&#13;
<p>By<a data-primary="resources" data-secondary="formatting of" data-type="indexterm" id="idm46336864404776"/> convention, resources are lowercase and plural, usually corresponding to the plural words of the parallel kind. They must conform to the DNS path label format (RFC 1025). As resources map directly to HTTP paths, this is not surprising.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="REST Mapping" data-type="sect2"><div class="sect2" id="RESTMapping">&#13;
<h2>REST Mapping</h2>&#13;
&#13;
<p>The<a data-primary="REST mapping" data-type="indexterm" id="idm46336864401288"/><a data-primary="discovery" data-secondary="RESTMapper" data-type="indexterm" id="idm46336864400552"/> mapping of a GVK to a GVR is called <em>REST mapping</em>.</p>&#13;
&#13;
<p>A <code>RESTMapper</code> is the <a href="http://bit.ly/2Y7wYS8">Golang interface</a> that enables us to request the GVR for a GVK:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">RESTMapping</code><code class="p">(</code><code class="nx">gk</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupKind</code><code class="p">,</code> <code class="nx">versions</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">RESTMapping</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>where the type <code>RESTMapping</code> on the right looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">RESTMapping</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Resource is the GroupVersionResource (location) for this endpoint.</code>&#13;
    <code class="nx">Resource</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">.</code>&#13;
&#13;
    <code class="c1">// GroupVersionKind is the GroupVersionKind (data format) to submit</code>&#13;
    <code class="c1">// to this endpoint.</code>&#13;
    <code class="nx">GroupVersionKind</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionKind</code>&#13;
&#13;
    <code class="c1">// Scope contains the information needed to deal with REST Resources</code>&#13;
    <code class="c1">// that are in a resource hierarchy.</code>&#13;
    <code class="nx">Scope</code> <code class="nx">RESTScope</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In addition, a <code>RESTMapper</code> provides a number of convenience functions:</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="c1">// KindFor takes a partial resource and returns the single match.</code>&#13;
<code class="c1">// Returns an error if there are multiple matches.</code>&#13;
<code class="nx">KindFor</code><code class="p">(</code><code class="nx">resource</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">)</code> <code class="p">(</code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionKind</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// KindsFor takes a partial resource and returns the list of potential</code>&#13;
<code class="c1">// kinds in priority order.</code>&#13;
<code class="nx">KindsFor</code><code class="p">(</code><code class="nx">resource</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">)</code> <code class="p">([]</code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionKind</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// ResourceFor takes a partial resource and returns the single match.</code>&#13;
<code class="c1">// Returns an error if there are multiple matches.</code>&#13;
<code class="nx">ResourceFor</code><code class="p">(</code><code class="nx">input</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">)</code> <code class="p">(</code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// ResourcesFor takes a partial resource and returns the list of potential</code>&#13;
<code class="c1">// resource in priority order.</code>&#13;
<code class="nx">ResourcesFor</code><code class="p">(</code><code class="nx">input</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">)</code> <code class="p">([]</code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// RESTMappings returns all resource mappings for the provided group kind</code>&#13;
<code class="c1">// if no version search is provided. Otherwise identifies a preferred resource</code>&#13;
<code class="c1">// mapping for the provided version(s).</code>&#13;
<code class="nx">RESTMappings</code><code class="p">(</code><code class="nx">gk</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupKind</code><code class="p">,</code> <code class="nx">versions</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code> <code class="p">([]</code><code class="o">*</code><code class="nx">RESTMapping</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>Here, a partial GVR means that not all fields are set. For example, imagine you type <code><strong>kubectl get pods</strong></code>. In that case, the group and the version are missing. A <code>RESTMapper</code> with enough information might still manage to map it to the <code>v1 Pods</code> kind.</p>&#13;
&#13;
<p>For the preceding deployment example, a <code>RESTMapper</code> that knows about deployments (more about what this means in a bit) will map <a href="http://bit.ly/2IujaLU"><em>apps/v1.Deployment</em></a> to <em>apps/v1.deployments</em> as a namespaced resource.</p>&#13;
&#13;
<p>There are multiple different implementations of the <code>RESTMapper</code> interface. The most important one for client applications is the discovery-based <a href="http://bit.ly/2XroxUq"><code>DeferredDiscoveryRESTMapper</code></a> in the package <em>k8s.io/client-go/restmapper</em>: it uses discovery information from the Kubernetes API server to dynamically build up the REST mapping. It will also work with non-core resources like custom resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scheme" data-type="sect2"><div class="sect2" id="scheme">&#13;
<h2>Scheme</h2>&#13;
&#13;
<p>The<a data-primary="schemes" data-type="indexterm" id="idm46336864160440"/><a data-primary="runtime.Object" data-type="indexterm" id="idm46336864159704"/> final core concept we want to present here in the context of the Kubernetes type system is the <a href="http://bit.ly/2N1PGJB"><em>scheme</em></a> in the package <em>k8s.io/apimachinery/pkg/runtime</em>.</p>&#13;
&#13;
<p>A scheme connects the world of Golang with the implementation-independent world of GVKs. The main feature of a scheme is the mapping of Golang types to possible GVKs:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">Scheme</code><code class="p">)</code> <code class="nx">ObjectKinds</code><code class="p">(</code><code class="nx">obj</code> <code class="nx">Object</code><code class="p">)</code> <code class="p">([]</code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionKind</code><code class="p">,</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>As we saw in <a data-type="xref" href="#kube-objects">“Kubernetes Objects in Go”</a>, an object can return its group and kind via the <code>GetObjectKind() schema.ObjectKind</code> method. However, these values are empty most of the time and are therefore pretty useless for identification.</p>&#13;
&#13;
<p>Instead, the scheme takes the Golang type of the given object via<a data-primary="reflection" data-type="indexterm" id="idm46336864146456"/> reflection and maps it to the registered GVK(s) of that Golang type. For that to work, of course, the Golang types have to be registered into the scheme like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">scheme</code><code class="p">.</code><code class="nx">AddKnownTypes</code><code class="p">(</code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionKind</code><code class="p">{</code><code class="s">""</code><code class="p">,</code> <code class="s">"v1"</code><code class="p">,</code> <code class="s">"Pod"</code><code class="p">},</code> <code class="o">&amp;</code><code class="nx">Pod</code><code class="p">{})</code></pre>&#13;
&#13;
<p>The scheme is used not only to register the Golang types and their GVK, but also to  store a list of conversion functions and defaulters (see <a data-type="xref" href="#scheme-spider">Figure 3-6</a>). We’ll discuss conversions and defaulters in more detail in <a data-type="xref" href="ch08.html#ch_custom-api-servers">Chapter 8</a>. It is the data source to implement encoders and decoders as well.</p>&#13;
&#13;
<figure><div class="figure" id="scheme-spider">&#13;
<img alt="The scheme, connecting Golang data types with the GVK, conversions and defaulters" src="assets/prku_0306.png"/>&#13;
<h6><span class="label">Figure 3-6. </span>The scheme, connecting Golang data types with the GVK, conversions, and defaulters</h6>&#13;
</div></figure>&#13;
&#13;
<p>For Kubernetes core types there is a <a href="http://bit.ly/2FkXDn2">predefined scheme in the <code>client-go</code> client set</a> in the package <em>k8s.io/client-go/kubernetes/scheme</em>, with all the types preregistered. Actually, every client set generated by the<a data-primary="generator" data-secondary="client-gen" data-type="indexterm" id="idm46336864130296"/> <code>client-gen</code> code generator (see <a data-type="xref" href="ch05.html#ch_autocodegen">Chapter 5</a>) has the subpackage <code>scheme</code> with all types in all groups and versions in the client set.</p>&#13;
&#13;
<p>With<a data-primary="" data-startref="CGapi03" data-type="indexterm" id="idm46336864127240"/><a data-primary="" data-startref="APImachine03" data-type="indexterm" id="idm46336864126232"/> the scheme we conclude our deep dive into API Machinery concepts. If you only remember one thing about these concepts, let it be <a data-type="xref" href="#scheme-restmapper-http-path">Figure 3-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="scheme-restmapper-http-path">&#13;
<img alt="From Golang types to GVKs to GVRs to an HTTP path — API machinery in a nutshell" src="assets/prku_0307.png"/>&#13;
<h6><span class="label">Figure 3-7. </span>From Golang types to GVKs to GVRs to an HTTP path—API Machinery in a nutshell</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Vendoring" data-type="sect1"><div class="sect1" id="vendoring">&#13;
<h1>Vendoring</h1>&#13;
&#13;
<p>We<a data-primary="client-go" data-secondary="vendoring" data-type="indexterm" id="CGvendor03"/><a data-primary="third-party applications" data-type="indexterm" id="idm46336864059384"/><a data-primary="vendoring" data-secondary="role of" data-type="indexterm" id="idm46336864058744"/><a data-primary="repositories" data-secondary="third-party applications" data-type="indexterm" id="idm46336864057800"/> have seen in this chapter that <em>k8s.io/client-go</em>, <em>k8s.io/api</em>, and <em>k8s.io/apimachinery</em> are central to Kubernetes programming in Golang. Golang uses <em>vendoring</em> to include these libraries in a third-party application source code repository.</p>&#13;
&#13;
<p>Vendoring<a data-primary="vendoring" data-secondary="tools for" data-type="indexterm" id="idm46336864054776"/> is a moving target in the Golang community. At the time of this writing, several vendoring tools are common, such as <em>godeps</em>, <em>dep</em>, and <em>glide</em>. At the same time, Go 1.12 is getting support for Go modules, which will probably become the standard vendoring method in the Go community in the future, but is not ready in the Kubernetes ecosystem at this time.</p>&#13;
&#13;
<p>Most projects nowadays use either <code>dep</code> or <code>glide</code>. Kubernetes itself in <em>github.com/kubernetes/kubernetes</em> made the jump to Go modules for the 1.15 development cycle. The following comments are relevant for all of these vendoring tools.</p>&#13;
&#13;
<p>The source of truth for supported dependency versions in each of the <em>k8s.io/*</em> repositories is the shipped <em>Godeps/Godeps.json</em> file. It is important to stress that any other dependency selection can break the functionality of the library.</p>&#13;
&#13;
<p>See <a data-type="xref" href="#client-go">“The Client Library”</a> for more on the published tags of <em>k8s.io/client-go</em>, <em>k8s.io/api</em>, and <em>k8s.io/apimachinery</em> and which tags are compatible with each other.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="glide" data-type="sect2"><div class="sect2" id="idm46336864024648">&#13;
<h2>glide</h2>&#13;
&#13;
<p>Projects<a data-primary="vendoring" data-secondary="glide" data-type="indexterm" id="idm46336864022920"/><a data-primary="glide (vendoring tool)" data-type="indexterm" id="idm46336864021944"/> using <code>glide</code> can use its ability to read the <em>Godeps/Godeps.json</em> file on any dependency change. This has proven to work pretty reliably: the developer has only to declare the right <em>k8s.io/client-go</em> version, and <code>glide</code> will select the right version of <em>k8s.io/apimachinery</em>, <em>k8s.io/api</em>, and other dependencies.</p>&#13;
&#13;
<p>For some projects on GitHub, the <em>glide.yaml</em> file might look like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">package</code><code class="p">:</code> <code class="l-Scalar-Plain">github.com/book/example</code>&#13;
<code class="nt">import</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">package</code><code class="p">:</code> <code class="l-Scalar-Plain">k8s.io/client-go</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v10.0.0</code>&#13;
<code class="nn">...</code></pre>&#13;
&#13;
<p>With that, <code>glide install -v</code> will download <em>k8s.io/client-go</em> and its dependencies into the local <em>vendor/</em> package. Here, <code>-v</code> means to drop <em>vendor/</em> packages from vendored libraries. This is required for our purposes.</p>&#13;
&#13;
<p>If you update to a new version of <code>client-go</code> by editing <em>glide.yaml</em>, <code>glide update -v</code> will download the new dependencies, again in the right versions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="dep" data-type="sect2"><div class="sect2" id="idm46336863995720">&#13;
<h2>dep</h2>&#13;
&#13;
<p><code>dep</code><a data-primary="vendoring" data-secondary="dep" data-type="indexterm" id="idm46336863994152"/><a data-primary="dep (vendoring tool)" data-type="indexterm" id="idm46336863993176"/> is often considered more powerful and advanced than <code>glide</code>. For a long time it was seen as the successor to <code>glide</code> in the ecosystem and seemed destined to be <em>the</em> Go vendoring tool. At the time of this writing, its future is not clear, and Go modules seem to be the path forward.</p>&#13;
&#13;
<p>In the context of <code>client-go</code>, it is very important to be aware of a couple of restrictions of <code>dep</code>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>dep</code> does read <em>Godeps/Godeps.json</em> on the first run of <code>dep init</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>dep</code> does not read <em>Godeps/Godeps.json</em> on later <code>dep ensure -update</code> calls.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This means that the resolution for dependencies of <code>client-go</code> is most probably wrong when the <code>client-go</code> version is updated in <em>Godep.toml</em>. This is unfortunate, because it requires the developer to explicitly and usually manually declare <em>all</em> dependencies.</p>&#13;
&#13;
<p>A working and consistent <em>Godep.toml</em> file looks like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting" id="dep-example"><code class="p-Indicator">[[</code><code class="nv">constraint</code><code class="p-Indicator">]]</code>&#13;
  <code class="l-Scalar-Plain">name = "k8s.io/api"</code>&#13;
  <code class="l-Scalar-Plain">version = "kubernetes-1.13.0"</code>&#13;
&#13;
<code class="l-Scalar-Plain">[[constraint]]</code>&#13;
  <code class="l-Scalar-Plain">name = "k8s.io/apimachinery"</code>&#13;
  <code class="l-Scalar-Plain">version = "kubernetes-1.13.0"</code>&#13;
&#13;
<code class="l-Scalar-Plain">[[constraint]]</code>&#13;
  <code class="l-Scalar-Plain">name = "k8s.io/client-go"</code>&#13;
  <code class="l-Scalar-Plain">version = "10.0.0"</code>&#13;
&#13;
<code class="l-Scalar-Plain">[prune]</code>&#13;
  <code class="l-Scalar-Plain">go-tests = true</code>&#13;
  <code class="l-Scalar-Plain">unused-packages = true</code>&#13;
&#13;
<code class="l-Scalar-Plain"># the following overrides are necessary to enforce</code>&#13;
<code class="l-Scalar-Plain"># the given version, even though our</code>&#13;
<code class="l-Scalar-Plain"># code does not import the packages directly.</code>&#13;
<code class="l-Scalar-Plain">[[override]]</code>&#13;
  <code class="l-Scalar-Plain">name = "k8s.io/api"</code>&#13;
  <code class="l-Scalar-Plain">version = "kubernetes-1.13.0"</code>&#13;
&#13;
<code class="l-Scalar-Plain">[[override]]</code>&#13;
  <code class="l-Scalar-Plain">name = "k8s.io/apimachinery"</code>&#13;
  <code class="l-Scalar-Plain">version = "kubernetes-1.13.0"</code>&#13;
&#13;
<code class="l-Scalar-Plain">[[override]]</code>&#13;
  <code class="l-Scalar-Plain">name = "k8s.io/client-go"</code>&#13;
  <code class="l-Scalar-Plain">version = "10.0.0"</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Not<a data-primary="package management" data-type="indexterm" id="idm46336863939800"/> only does <em>Gopkg.toml</em> declare explicit versions for both <em><span class="keep-together">k8s.io/apimachinery</span></em> and <em>k8s.io/api</em>, it also has overrides for them. This is necessary for when the project is started without explicit imports of packages from those two repositories. In that case, without these overrides <code>dep</code> would ignore the constraints in the beginning, and the developer would get wrong dependencies from the beginning.</p>&#13;
&#13;
<p>Even the <em>Gopkg.toml</em> file shown here is technically not correct because it is incomplete, as it does not declare dependencies <em>on all</em> other libraries required by <code>client-go</code>. In the past, an upstream library broke compilation of <code>client-go</code>. So be prepared for this to happen if you use <code>dep</code> for dependency management.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Go Modules" data-type="sect2"><div class="sect2" id="idm46336863921624">&#13;
<h2>Go Modules</h2>&#13;
&#13;
<p>Go modules<a data-primary="vendoring" data-secondary="Go modules" data-type="indexterm" id="idm46336863919832"/><a data-primary="Go modules" data-type="indexterm" id="idm46336863918824"/> are the future of dependency management in Golang. They were introduced in Go 1.11 with <a href="http://bit.ly/2FmBp3Y">preliminary support</a> and were further stabilized in 1.12. A number of commands, like <code>go run</code> and <code>go get</code>, work with Go modules by setting the <code>GO111MODULE=on</code> environment variable. In Go 1.13 this will be the default setting.</p>&#13;
&#13;
<p>Go modules are driven by a <em>go.mod</em> file in the root of a project. Here is an excerpt of the <em>go.mod</em> file for our <em>github.com/programming-kubernetes/pizza-apiserver</em> project in <a data-type="xref" href="ch08.html#ch_custom-api-servers">Chapter 8</a>:</p>&#13;
&#13;
<pre data-type="programlisting">module github.com/programming-kubernetes/pizza-apiserver&#13;
&#13;
require (&#13;
    ...&#13;
    k8s.io/api v0.0.0-20190222213804-5cb15d344471 // indirect&#13;
    k8s.io/apimachinery v0.0.0-20190221213512-86fb29eff628&#13;
    k8s.io/apiserver v0.0.0-20190319190228-a4358799e4fe&#13;
    k8s.io/client-go v2.0.0-alpha.0.0.20190307161346-7621a5ebb88b+incompatible&#13;
    k8s.io/klog v0.2.1-0.20190311220638-291f19f84ceb&#13;
    k8s.io/kube-openapi v0.0.0-20190320154901-c59034cc13d5 // indirect&#13;
    k8s.io/utils v0.0.0-20190308190857-21c4ce38f2a7 // indirect&#13;
    sigs.k8s.io/yaml v1.1.0 // indirect&#13;
)</pre>&#13;
&#13;
<p><code>client-go</code> <code>v11.0.0</code>—matching Kubernetes 1.14—and older versions do not have explicit support for Go modules. Still, it is possible to use Go modules with the Kubernetes libraries, as you see in the preceding example.</p>&#13;
&#13;
<p>As long as <code>client-go</code> and the other Kubernetes repositories do not ship a <em>go.mod</em> file, though (at least until Kubernetes 1.15), the right versions must be selected manually. That is, you’ll need a complete list of all dependencies matching the revisions of dependencies of the <em>Godeps/Godeps.json</em> in <code>client-go</code>.</p>&#13;
&#13;
<p>Also note the not-very-readable revisions in the previous example. They are pseudo-versions derived from existing tags, or using <code>v0.0.0</code> as the prefix if there are no tags. Even worse, you can reference tagged versions in that file, but the Go module commands will replace those on the next run with the pseudo-versions.</p>&#13;
&#13;
<p>With <code>client-go</code> <code>v12.0.0</code>—matching Kubernetes 1.15—we ship a <em>go.mod</em> file and deprecate support for all other vendoring tools (see the <a href="http://bit.ly/2IZ9MPg">corresponding proposal document</a>). The shipped <em>go.mod</em> file includes all dependencies, and your project <em>go.mod</em> file no longer has to list all transitive dependencies manually. In later releases, it’s also possible that the tagging scheme will be changed to fix the ugly pseudo-revisions and replace them with proper<a data-primary="semantic versioning (semver)" data-type="indexterm" id="idm46336863903480"/> semver tags. But at the time of this writing, this is still not fully implemented or decided.<a data-primary="" data-startref="CGvendor03" data-type="indexterm" id="idm46336863902472"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46336864062424">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter our focus was on the Kubernetes programming interface in Go. We discussed accessing the Kubernetes API of well-known core types—that is, the API objects that are shipped with every Kubernetes cluster.</p>&#13;
&#13;
<p>With this we’ve covered the basics of the Kubernetes API and its representation in Go. Now we’re ready to move on to the topic of custom resources, one of the pillars of operators.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46336866123400"><sup><a href="ch03.html#idm46336866123400-marker">1</a></sup> See <a data-type="xref" href="ch02.html#terminology">“API Terminology”</a>.</p><p data-type="footnote" id="idm46336865870888"><sup><a href="ch03.html#idm46336865870888-marker">2</a></sup> <code>kubectl</code> <code>explain</code> <code>pod</code> lets you query the API server for the schema of an object, including field <span class="keep-together">documentation</span>.</p></div></div></section></body></html>