<html><head></head><body><section data-pdf-bookmark="Chapter 7. Variadic Tuple Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch07">&#13;
<h1><span class="label">Chapter 7. </span>Variadic Tuple Types</h1>&#13;
&#13;
&#13;
<p><a data-primary="variadic tuple types" data-secondary="overview" data-type="indexterm" id="id725"/>Tuple types are arrays with a fixed length and where every type of each element is defined. Tuples are heavily used in libraries like React as it’s easy to destructure and name elements, but outside of React they also have gained recognition as a nice alternative to objects.</p>&#13;
&#13;
<p><a data-primary="variadic tuple types" data-secondary="defined" data-type="indexterm" id="id726"/>A <em>variadic tuple type</em> is a tuple type that has the same properties—defined length and the type of each element is known—but where the <em>exact shape</em> is yet to be defined. They basically tell the type system that there will be some elements, but we don’t know yet which ones they will be. They are generic and meant to be substituted with real types.</p>&#13;
&#13;
<p>What sounds like a fairly boring feature is much more exciting when we understand that tuple types can also be used to describe function signatures, as tuples can be spread out to function calls as arguments. This means we can use variadic tuple types to get the most information out of functions and function calls, and functions that accept functions as parameters.</p>&#13;
&#13;
<p>This chapter provides a lot of use cases on how we can use variadic tuple types to describe several scenarios where we use functions as parameters and need to get the most information from them. Without variadic tuple types, these scenarios would be hard to develop or outright impossible. After reading through, you will see variadic tuple types as a key feature for functional programming patterns.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.1 Typing a concat Function" data-type="sect1"><div class="sect1" id="c07_concat">&#13;
<h1>7.1 Typing a concat Function</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id106">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="arrays" data-secondary="typing a concat function for" data-type="indexterm" id="ix_07-01-asciidoc0"/><a data-primary="concat function" data-type="indexterm" id="ix_07-01-asciidoc1"/><a data-primary="helper function" data-type="indexterm" id="ix_07-01-asciidoc2"/><a data-primary="variadic tuple types" data-secondary="typing a concat function" data-type="indexterm" id="ix_07-01-asciidoc3"/>You have a <code>concat</code> function that takes two arrays and concatenates them. You want to have exact types, but using function overloads is too cumbersome.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id727">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use variadic tuple types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id107">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>concat</code> is a lovely helper function that takes two arrays and combines them. It uses array spreading and is short, nice, and readable:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">concat</code><code class="p">(</code><code class="nx">arr1</code><code class="p">,</code> <code class="nx">arr2</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[...</code><code class="nx">arr1</code><code class="p">,</code> <code class="p">...</code><code class="nx">arr2</code><code class="p">];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Creating types for this function can be hard, especially if you have certain expectations from your types. Passing in two arrays is easy, but what should the return type look like? Are you happy with a single array type in return, or do you want to know the types of each element in this array?</p>&#13;
&#13;
<p>Let’s go for the latter: we want tuples so we know the type of each element we pass to this function. To correctly type a function like this so that it takes all possible edge cases into account, we would end up in a sea of overloads:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// 7 overloads for an empty second array</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">,</code> <code class="nx">F</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">,</code> <code class="nx">F</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">,</code> <code class="nx">F</code><code class="p">];</code>&#13;
<code class="c1">// 7 more for arr2 having one element</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">F1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">F1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">F1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="c1">// and so on, and so forth</code></pre>&#13;
&#13;
<p>And this only takes into account arrays that have up to six elements. The combinations for typing a function like this with overloads is exhausting. But there is an easier way: variadic tuple types.</p>&#13;
&#13;
<p><a data-primary="tuple types" data-secondary="defined" data-type="indexterm" id="id728"/>A tuple type in TypeScript is an array with the following features:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The length of the array is defined.</p>&#13;
</li>&#13;
<li>&#13;
<p>The type of each element is known (and does not have to be the same).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For example, this is a tuple type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonProps</code> <code class="o">=</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">]</code><code class="o">: </code><code class="kr">Person</code><code class="nx">Props</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Stefan'</code><code class="p">,</code> <code class="mi">37</code><code class="p">];</code></pre>&#13;
&#13;
<p><a data-primary="variadic tuple types" data-secondary="tuple type versus" data-type="indexterm" id="id729"/>A <em>variadic</em> tuple type is a tuple type that has the same properties—defined length and the type of each element is known—but where the <em>exact shape</em> is yet to be defined. Since we don’t know the type and length yet, we can only use variadic tuple types in generics:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Foo</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[]</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">T</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">T1</code> <code class="o">=</code> <code class="nx">Foo</code><code class="o">&lt;</code><code class="p">[</code><code class="kr">boolean</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c1">// [string, boolean, number]</code>&#13;
<code class="kr">type</code> <code class="nx">T2</code> <code class="o">=</code> <code class="nx">Foo</code><code class="o">&lt;</code><code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c1">// [string, number, number, number]</code>&#13;
<code class="kr">type</code> <code class="nx">T3</code> <code class="o">=</code> <code class="nx">Foo</code><code class="o">&lt;</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c1">// [string, number]</code></pre>&#13;
&#13;
<p>This is similar to rest elements in functions, but the big difference is that variadic tuple types can happen anywhere in the tuple, and multiple times:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Bar</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[],</code>&#13;
  <code class="nx">U</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[]</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">T</code><code class="p">,</code> <code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">U</code><code class="p">];</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">T4</code> <code class="o">=</code> <code class="nx">Bar</code><code class="o">&lt;</code><code class="p">[</code><code class="kr">boolean</code><code class="p">],</code> <code class="p">[</code><code class="kt">number</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c1">// [boolean, string, number]</code>&#13;
<code class="kr">type</code> <code class="nx">T5</code> <code class="o">=</code> <code class="nx">Bar</code><code class="o">&lt;</code><code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">],</code> <code class="p">[</code><code class="kr">boolean</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c1">// [number, number, string, boolean]</code>&#13;
<code class="kr">type</code> <code class="nx">T6</code> <code class="o">=</code> <code class="nx">Bar</code><code class="o">&lt;</code><code class="p">[],</code> <code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c1">// [string]</code></pre>&#13;
&#13;
<p>When we apply this to the <code>concat</code> function, we have to introduce two generic parameters, one for each array. Both need to be constrained to arrays. Then, we can create a return type that combines both array types in a newly created tuple type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[],</code> <code class="nx">U</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="nx">U</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[...</code><code class="nx">T</code><code class="p">,</code> <code class="p">...</code><code class="nx">U</code><code class="p">]</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[...</code><code class="nx">arr1</code><code class="p">,</code> <code class="p">...</code><code class="nx">arr2</code><code class="p">];</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// const test: (string | number)[]</code>&#13;
<code class="kr">const</code> <code class="nx">test</code> <code class="o">=</code> <code class="nx">concat</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="s2">"a"</code><code class="p">]);</code></pre>&#13;
&#13;
<p>The syntax is beautiful; it’s very similar to the actual concatenation in JavaScript. The result is also really good: we get a <code>(string | number)[]</code>, which is already something we can work with.</p>&#13;
&#13;
<p>But we work with tuple types. If we want to know <em>exactly</em> which elements we are concatenating, we have to transform the array types into tuple types, by spreading out the generic array type into a tuple type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[],</code> <code class="nx">U</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[...</code><code class="nx">T</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[...</code><code class="nx">U</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[...</code><code class="nx">T</code><code class="p">,</code> <code class="p">...</code><code class="nx">U</code><code class="p">]</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[...</code><code class="nx">arr1</code><code class="p">,</code> <code class="p">...</code><code class="nx">arr2</code><code class="p">];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And with that, we also get a tuple type in return:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// const test: [number, number, number, number, number, string]</code>&#13;
<code class="kr">const</code> <code class="nx">test</code> <code class="o">=</code> <code class="nx">concat</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="s2">"a"</code><code class="p">]);</code></pre>&#13;
&#13;
<p>The good news is that we don’t lose anything. If we pass arrays where we don’t know each element up front, we still get array types in return:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kr">const</code> <code class="nx">a</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code>&#13;
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">[]</code>&#13;
&#13;
<code class="c1">// const test: (string | number)[]</code>&#13;
<code class="kr">const</code> <code class="nx">test</code> <code class="o">=</code> <code class="nx">concat</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">);</code></pre>&#13;
&#13;
<p>Being able to describe this behavior in a single type is definitely much more flexible and readable than writing every possible combination in a function overload.<a data-startref="ix_07-01-asciidoc3" data-type="indexterm" id="id730"/><a data-startref="ix_07-01-asciidoc2" data-type="indexterm" id="id731"/><a data-startref="ix_07-01-asciidoc1" data-type="indexterm" id="id732"/><a data-startref="ix_07-01-asciidoc0" data-type="indexterm" id="id733"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.2 Typing a promisify Function" data-type="sect1"><div class="sect1" id="ch07_promisify">&#13;
<h1>7.2 Typing a promisify Function</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id108">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="promisify functions and" data-type="indexterm" id="ix_07-02-asciidoc0"/><a data-primary="Promises" data-type="indexterm" id="ix_07-02-asciidoc1"/><a data-primary="promisify function" data-type="indexterm" id="ix_07-02-asciidoc2"/><a data-primary="variadic tuple types" data-secondary="typing a promisify function" data-type="indexterm" id="ix_07-02-asciidoc3"/>You want to convert callback-style functions to Promises and have them perfectly typed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id734">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Function arguments are tuple types. Make them generic using variadic tuple types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id109">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Before Promises were a thing in JavaScript it was very common to do asynchronous programming using callbacks. Functions would usually take a list of arguments, followed by a callback function that would be executed once the results were there, such as functions to load a file or do a very simplified HTTP request:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadFile</code><code class="p">(</code>&#13;
  <code class="nx">filename</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">encoding</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="nx">File</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// TODO</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">loadFile</code><code class="p">(</code><code class="s2">"./data.json"</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">,</code> <code class="p">(</code><code class="nx">result</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// do something with the file</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">request</code><code class="p">(</code><code class="nx">url</code><code class="o">:</code> <code class="nx">URL</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="nx">JSON</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// TODO</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">request</code><code class="p">(</code><code class="s2">"https://typescript-cookbook.com"</code><code class="p">,</code> <code class="p">(</code><code class="nx">result</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// TODO</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Both follow the same pattern: arguments first, a callback with the result last. This works but can be clumsy if you have lots of asynchronous calls that result in callbacks within callbacks, also known as the <a href="https://oreil.ly/Ye3Qr">“the pyramid of doom”</a>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">loadFile</code><code class="p">(</code><code class="s2">"./data.txt"</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">,</code> <code class="p">(</code><code class="nx">file</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// pseudo API</code>&#13;
  <code class="nx">file</code><code class="p">.</code><code class="nx">readText</code><code class="p">((</code><code class="nx">url</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">request</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// do something with data</code>&#13;
    <code class="p">})</code>&#13;
  <code class="p">})</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Promises take care of that. Not only do they find a way to chain asynchronous calls instead of nesting them, they also are the gateway for <code>async</code>/<code>await</code>, allowing us to write asynchronous code in a synchronous form:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">loadFilePromise</code><code class="p">(</code><code class="s2">"./data.txt"</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">file</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">file</code><code class="p">.</code><code class="nx">text</code><code class="p">())</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">url</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">request</code><code class="p">(</code><code class="nx">url</code><code class="p">))</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// do something with data</code>&#13;
  <code class="p">});</code>&#13;
&#13;
<code class="c1">// with async/await</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">file</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">loadFilePromise</code><code class="p">(</code><code class="s2">"./data.txt"</code><code class="p">.</code> <code class="s2">"utf-8"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">url</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">file</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>&#13;
<code class="kr">const</code> <code class="nx">data</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">request</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>&#13;
<code class="c1">// do something with data.</code></pre>&#13;
&#13;
<p>Much nicer! Thankfully, it is possible to convert every function that adheres to the callback pattern to a <code>Promise</code>. We want to create a <code>promisify</code> function to do that for us automatically:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">promisify</code><code class="p">(</code><code class="nx">fn</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kr">unknown</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// To be implemented</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">loadFilePromise</code> <code class="o">=</code> <code class="nx">promisify</code><code class="p">(</code><code class="nx">loadFile</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">requestPromise</code> <code class="o">=</code> <code class="nx">promisify</code><code class="p">(</code><code class="nx">request</code><code class="p">);</code></pre>&#13;
&#13;
<p>But how do we type this? Variadic tuple types to the rescue!</p>&#13;
&#13;
<p>Every function head can be described as a tuple type. For example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kd">function</code> <code class="nx">hello</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">msg</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p>is the same as:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kd">function</code> <code class="nx">hello</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p>And we can be very flexible in defining it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kd">function</code> <code class="nx">h</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="c1">// equal to</code>&#13;
<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">h</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">r</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="c1">// equal to</code>&#13;
<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">h</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">r</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="c1">// equal to</code>&#13;
<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">h</code><code class="p">(...</code><code class="nx">r</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-primary="rest elements" data-type="indexterm" id="id735"/>This is also known as a <em>rest element</em>, something we have in JavaScript that allows you to define functions with an almost limitless argument list, where the last element, the rest element, sucks all excess arguments in.</p>&#13;
&#13;
<p>For example, this generic tuple function takes an argument list of any type and &#13;
<span class="keep-together">creates</span> a tuple out of it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">tuple</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">args</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">numbers</code><code class="o">:</code> <code class="kt">number</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">getArrayOfNumbers</code><code class="p">();</code>&#13;
<code class="kr">const</code> <code class="nx">t1</code> <code class="o">=</code> <code class="nx">tuple</code><code class="p">(</code><code class="s2">"foo"</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code>  <code class="c1">// [string, number, boolean]</code>&#13;
<code class="kr">const</code> <code class="nx">t2</code> <code class="o">=</code> <code class="nx">tuple</code><code class="p">(</code><code class="s2">"bar"</code><code class="p">,</code> <code class="p">...</code><code class="nx">numbers</code><code class="p">);</code>  <code class="c1">// [string, ...number[]]</code></pre>&#13;
&#13;
<p>The thing is, rest elements always have to be last. In JavaScript, it’s not possible to define an almost endless argument list somewhere in between. With variadic tuple types, however, we can do this in TypeScript!</p>&#13;
&#13;
<p>Let’s look again at the <code>loadFile</code> and <code>request</code> functions again. If we described the parameters of both functions as tuples, they would look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadFile</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">,</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="nx">File</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">])</code> <code class="p">{</code>&#13;
  <code class="c1">// TODO</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">request2</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[</code><code class="nx">URL</code><code class="p">,</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="nx">JSON</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">])</code> <code class="p">{</code>&#13;
  <code class="c1">// TODO</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s look for similarities. Both end with a callback with a varying result type. We can align the types for both callbacks by substituting the variations with a generic one. Later, in usage, we substitute generics for actual types. So <code>JSON</code> and <code>File</code> become the generic type parameter <code>Res</code>.</p>&#13;
&#13;
<p>Now for the parameters <em>before</em> <code>Res</code>. They are arguably totally different, but even they have something in common: they are elements within a tuple. This calls for a variadic tuple. We know they will have a concrete length and concrete types, but right now we just take a placeholder for them. Let’s call them <code>Args</code>.</p>&#13;
&#13;
<p>So a function type describing both function signatures could look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Fn</code><code class="o">&lt;</code><code class="nx">Args</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[],</code> <code class="nx">Res</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[...</code><code class="nx">Args</code><code class="p">,</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="nx">Res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">]</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p>Take your new type for a spin:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">LoadFileFn</code> <code class="o">=</code> <code class="nx">Fn</code><code class="o">&lt;</code><code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">],</code> <code class="nx">File</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">RequestFn</code> <code class="o">=</code> <code class="nx">Fn</code><code class="o">&lt;</code><code class="p">[</code><code class="nx">URL</code><code class="p">],</code> <code class="nx">JSON</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is exactly what we need for the <code>promisify</code> function. We are able to extract all relevant parameters—the ones before the callback and the result type—and bring them into a new order.</p>&#13;
&#13;
<p>Let’s start by inlining the newly created function type directly into the function &#13;
<span class="keep-together">signature of <code>promisify</code>:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">promisify</code><code class="o">&lt;</code><code class="nx">Args</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[],</code> <code class="nx">Res</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[...</code><code class="nx">Args</code><code class="p">,</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="nx">Res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Res</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// soon</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before"><code>promisify</code> now reads:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>There are two generic type parameters: <code>Args</code>, which needs to be an array (or tuple), and <code>Res</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The parameter of <code>promisify</code> is a function where the first arguments are the elements of <code>Args</code> and the last argument is a function with a parameter of type <code>Res</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>promisify</code> returns a function that takes <code>Args</code> for parameters and returns a <code>Promise</code> of <code>Res</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you try out the new typings for <code>promisify</code>, you can see that we get exactly the type we want.</p>&#13;
&#13;
<p>But it gets even better. If you look at the function signature, it’s absolutely clear which arguments we expect, even if they are variadic and will be substituted with real types. We can use the same types for the implementation of <code>promisify</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">promisify</code><code class="o">&lt;</code><code class="nx">Args</code><code> </code><code class="kr">extends</code><code> </code><code class="kr">unknown</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">Res</code><code class="o">&gt;</code><code class="p">(</code><code>&#13;
  </code><code class="nx">fn</code><code class="o">:</code><code> </code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code class="o">:</code><code> </code><code class="p">[</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">Args</code><code class="p">,</code><code> </code><code class="p">(</code><code class="nx">result</code><code class="o">:</code><code> </code><code class="nx">Res</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code>&#13;
</code><code class="p">)</code><code class="o">:</code><code> </code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code class="o">:</code><code> </code><code class="nx">Args</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Res</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="kd">function</code><code> </code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code class="o">:</code><code> </code><code class="nx">Args</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_variadic_tuple_types_CO1-1" id="co_variadic_tuple_types_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nx">Promise</code><code class="p">(</code><code class="p">(</code><code class="nx">resolve</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_variadic_tuple_types_CO1-2" id="co_variadic_tuple_types_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
      </code><code class="kd">function</code><code> </code><code class="nx">callback</code><code class="p">(</code><code class="nx">res</code><code class="o">:</code><code> </code><code class="nx">Res</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_variadic_tuple_types_CO1-3" id="co_variadic_tuple_types_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
        </code><code class="nx">resolve</code><code class="p">(</code><code class="nx">res</code><code class="p">)</code><code class="p">;</code><code>&#13;
      </code><code class="p">}</code><code>&#13;
      </code><code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code><code> </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="p">[</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code class="p">,</code><code> </code><code class="nx">callback</code><code class="p">]</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_variadic_tuple_types_CO1-4" id="co_variadic_tuple_types_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="p">}</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>So what does it do?</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_variadic_tuple_types_CO1-1" id="callout_variadic_tuple_types_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We return a function that accepts all parameters except for the callback.</p></dd>&#13;
<dt><a class="co" href="#co_variadic_tuple_types_CO1-2" id="callout_variadic_tuple_types_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This function returns a newly created <code>Promise</code>.</p></dd>&#13;
<dt><a class="co" href="#co_variadic_tuple_types_CO1-3" id="callout_variadic_tuple_types_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Since we don’t have a callback yet, we need to construct it. What does it do? It calls the <code>resolve</code> function from the <code>Promise</code>, producing a result.</p></dd>&#13;
<dt><a class="co" href="#co_variadic_tuple_types_CO1-4" id="callout_variadic_tuple_types_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>What has been split needs to be brought back together! We add the callback to the arguments and call the original function.</p></dd>&#13;
</dl>&#13;
&#13;
<p>And that’s it. A working <code>promisify</code> function for functions that adhere to the callback pattern. Perfectly typed. And we even keep the parameter names.<a data-startref="ix_07-02-asciidoc3" data-type="indexterm" id="id736"/><a data-startref="ix_07-02-asciidoc2" data-type="indexterm" id="id737"/><a data-startref="ix_07-02-asciidoc1" data-type="indexterm" id="id738"/><a data-startref="ix_07-02-asciidoc0" data-type="indexterm" id="id739"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.3 Typing a curry Function" data-type="sect1"><div class="sect1" id="ch07_currying">&#13;
<h1>7.3 Typing a curry Function</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id223">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="combining with conditional types for typing a curry function" data-type="indexterm" id="ix_07-03-asciidoc0"/><a data-primary="curry function" data-secondary="typing" data-type="indexterm" id="ix_07-03-asciidoc1"/><a data-primary="variadic tuple types" data-secondary="typing a curry function" data-type="indexterm" id="ix_07-03-asciidoc2"/>You write a <code>curry</code> function. <a data-primary="curry function" data-secondary="currying defined" data-type="indexterm" id="id740"/><em>Currying</em> is a technique that converts a function that takes several arguments into a sequence of functions that each takes a single argument.</p>&#13;
&#13;
<p>You want to provide excellent types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id741">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Combine conditional types with variadic tuple types, always shaving off the first parameter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id110">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Currying is a very well-known technique in functional programming. Currying converts a function that takes several arguments into a sequence of functions that each takes a single argument.</p>&#13;
&#13;
<p>The underlying concept is called “partial application of function arguments.” We use it to maximize the reuse of functions. The “Hello, World!” of currying implements an <code>add</code> function that can partially apply the second argument later:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">curriedAdd</code> <code class="o">=</code> <code class="nx">curry</code><code class="p">(</code><code class="nx">add</code><code class="p">);</code> <code class="c1">// convert: (a: number) =&gt; (b: number) =&gt; number</code>&#13;
<code class="kr">const</code> <code class="nx">add5</code> <code class="o">=</code> <code class="nx">curriedAdd</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code> <code class="c1">// apply first argument. (b: number) =&gt; number</code>&#13;
<code class="kr">const</code> <code class="nx">result1</code> <code class="o">=</code> <code class="nx">add5</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code> <code class="c1">// second argument. Result: 7</code>&#13;
<code class="kr">const</code> <code class="nx">result2</code> <code class="o">=</code> <code class="nx">add5</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code> <code class="c1">// second argument. Result: 8</code></pre>&#13;
&#13;
<p>What feels arbitrary at first is useful when you work with long argument lists. The following generalized function either adds or removes classes to an <code>HTMLElement</code>.</p>&#13;
&#13;
<p>We can prepare everything except for the final event:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">applyClass</code><code class="p">(</code>&#13;
  <code class="k">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="c1">// for TypeScript only</code>&#13;
  <code class="nx">method</code><code class="o">:</code> <code class="s2">"remove"</code> <code class="o">|</code> <code class="s2">"add"</code><code class="p">,</code>&#13;
  <code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">event</code><code class="o">:</code> <code class="nx">Event</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">this</code> <code class="o">===</code> <code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">classList</code><code class="p">[</code><code class="nx">method</code><code class="p">](</code><code class="nx">className</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">applyClassCurried</code> <code class="o">=</code> <code class="nx">curry</code><code class="p">(</code><code class="nx">applyClass</code><code class="p">);</code> <code class="c1">// convert</code>&#13;
<code class="kr">const</code> <code class="nx">removeToggle</code> <code class="o">=</code> <code class="nx">applyClassCurried</code><code class="p">(</code><code class="s2">"remove"</code><code class="p">)(</code><code class="s2">"hidden"</code><code class="p">);</code>&#13;
&#13;
<code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">".toggle"</code><code class="p">)</code><code class="o">?</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="nx">removeToggle</code><code class="p">);</code></pre>&#13;
&#13;
<p>This way, we can reuse <code>removeToggle</code> for several events on several elements. We can also use <code>applyClass</code> for many other situations.</p>&#13;
&#13;
<p><a data-primary="Haskell" data-type="indexterm" id="id742"/>Currying is a fundamental concept of the programming language Haskell and gives a nod to the mathematician Haskell Brooks Curry, the namesake for both the programming language and the technique. In Haskell, every operation is curried, and programmers make good use of it.</p>&#13;
&#13;
<p>JavaScript borrows heavily from functional programming languages, and it is possible to implement partial application with its built-in functionality of binding:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Partial application</code>&#13;
<code class="kr">const</code> <code class="nx">partialAdd5And3</code> <code class="o">=</code> <code class="nx">add</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">3</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">partialAdd5And3</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code> <code class="c1">// third argument</code></pre>&#13;
&#13;
<p>Since functions are first-class citizens in JavaScript, we can create a <code>curry</code> function that takes a function as an argument and collects all arguments before executing it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">curry</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">curried</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// if you haven't collected enough arguments</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">!==</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="c1">// partially apply arguments and</code>&#13;
      <code class="c1">// return the collector function</code>&#13;
      <code class="k">return</code> <code class="nx">curried</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="c1">// otherwise call all functions</code>&#13;
    <code class="k">return</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
  <code class="k">return</code> <code class="nx">curried</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The trick is that every function stores the number of defined arguments in its <code>length</code> property. That’s how we can recursively collect all necessary arguments before applying them to the function passed.</p>&#13;
&#13;
<p>So what’s missing? Types! Let’s create a type that works for a currying pattern where every sequenced function can take exactly one argument. We do this by creating a conditional type that does the inverse of what the <code>curried</code> function inside the <code>curry</code> function does: removing arguments.</p>&#13;
&#13;
<p>So let’s create a <code>Curried&lt;F&gt;</code> type. The first thing is to check if the type is indeed &#13;
<span class="keep-together">a function:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">F</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">A</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">infer</code> <code class="nx">R</code>&#13;
  <code class="o">?</code> <code class="cm">/* to be done */</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code> <code class="c1">// not a function, this should not happen</code></pre>&#13;
&#13;
<p>We also infer the arguments as <code>A</code> and the return type as <code>R</code>. Next step, we shave off the first parameter as <code>F</code>, and store all remaining parameters in <code>L</code> (for <em>last</em>):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">F</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">A</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">infer</code> <code class="nx">R</code>&#13;
  <code class="o">?</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">F</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">L</code><code class="p">]</code>&#13;
    <code class="o">?</code> <code class="cm">/* to be done */</code>&#13;
    <code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">R</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Should there be no arguments, we return a function that takes no arguments. Last check: we check if the remaining parameters are empty. This means we reached the end of removing arguments from the argument list:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">F</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">A</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">infer</code> <code class="nx">R</code>&#13;
  <code class="o">?</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">F</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">L</code><code class="p">]</code>&#13;
    <code class="o">?</code> <code class="nx">L</code> <code class="kr">extends</code> <code class="p">[]</code>&#13;
      <code class="o">?</code> <code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="nx">F</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">R</code>&#13;
      <code class="o">:</code> <code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="nx">F</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">L</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">R</code><code class="o">&gt;</code>&#13;
    <code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">R</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Should some parameters remain, we call the <code>Curried</code> type again, but with the remaining parameters. This way, we shave off a parameter step by step, and if you take a good look, you can see that the process is almost identical to what we do in the &#13;
<span class="keep-together"><code>curried</code></span> function. Where we deconstruct parameters in <code>Curried&lt;F&gt;</code>, we collect them again in <code>curried(fn)</code>.</p>&#13;
&#13;
<p>With the type done, let’s add it to <code>curry</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">curry</code><code class="o">&lt;</code><code class="nx">F</code> <code class="kr">extends</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">fn</code><code class="o">:</code> <code class="nx">F</code><code class="p">)</code><code class="o">:</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">curried</code><code class="o">:</code> <code class="nb">Function</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">!==</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">curried</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
  <code class="k">return</code> <code class="nx">curried</code> <code class="kr">as</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We need a few assertions and some <code>any</code> because of the flexible nature of the type. But with <code>as</code> and <code>any</code> as keywords, we mark which portions are considered unsafe types.</p>&#13;
&#13;
<p>And that’s it! We can get curried away!<a data-startref="ix_07-03-asciidoc2" data-type="indexterm" id="id743"/><a data-startref="ix_07-03-asciidoc1" data-type="indexterm" id="id744"/><a data-startref="ix_07-03-asciidoc0" data-type="indexterm" id="id745"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.4 Typing a Flexible curry Function" data-type="sect1"><div class="sect1" id="ch07_flexible_currying">&#13;
<h1>7.4 Typing a Flexible curry Function</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id224">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="curry function" data-secondary="typing a flexible curry function" data-type="indexterm" id="ix_07-04-asciidoc0"/><a data-primary="function overloads" data-secondary="typing a flexible curry function" data-type="indexterm" id="ix_07-04-asciidoc1"/><a data-primary="variadic tuple types" data-secondary="typing a flexible curry function" data-type="indexterm" id="ix_07-04-asciidoc2"/>The <code>curry</code> function from <a data-type="xref" href="#ch07_currying">Recipe 7.3</a> allows for an arbitrary number of arguments to be passed, but your typings allow you to take only one argument at a time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id746">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Extend your typings to create function overloads for all possible tuple combinations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id111">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In <a data-type="xref" href="#ch07_currying">Recipe 7.3</a> we ended up with function types that allow us to apply function arguments one at a time:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">addThree</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">adder</code> <code class="o">=</code> <code class="nx">curried</code><code class="p">(</code><code class="nx">addThree</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">add7</code> <code class="o">=</code> <code class="nx">adder</code><code class="p">(</code><code class="mi">5</code><code class="p">)(</code><code class="mi">2</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">add7</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code></pre>&#13;
&#13;
<p>However, the <code>curry</code> function itself can take an arbitrary list of arguments:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">addThree</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">adder</code> <code class="o">=</code> <code class="nx">curried</code><code class="p">(</code><code class="nx">addThree</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">add7</code> <code class="o">=</code> <code class="nx">adder</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code> <code class="c1">// this is the difference</code>&#13;
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">add7</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code></pre>&#13;
&#13;
<p>This allows us to work on the same use cases but with a lot fewer function invocations. So let’s adapt our types to take advantage of the full <code>curry</code> experience.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This example illustrates really well how the type system works as just a thin layer on top of JavaScript. By adding assertions and <code>any</code> at the right positions, we effectively define how <code>curry</code> should work, whereas the function itself is much more flexible. Be aware that when you define complex types on top of complex functionality, you might cheat your way to the goal, and it’s in your hands how the types work in the end. Test accordingly.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Our goal is to create a type that can produce all possible function signatures for every partial application. For the <code>addThree</code> function, all possible types would look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Adder</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">c</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">Adder</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">Adder</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">c</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">Adder</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code></pre>&#13;
&#13;
<p>See also <a data-type="xref" href="#img-curry-illustration">Figure 7-1</a> for a visualization of all possible call graphs.</p>&#13;
&#13;
<figure><div class="figure" id="img-curry-illustration">&#13;
<img alt="tscb 0701" src="assets/tscb_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>A graph showing all possible function call combinations of <code>addThree</code> when curried; there are three branches to start, with a possible fourth branch</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first thing we do is to slightly adapt the way we call the <code>Curried</code> helper type. In the original type, we do the inference of function arguments and return types <em>in</em> the helper type. Now we need to carry along the return value over multiple type invocations, so we extract the return type and arguments directly in the <code>curry</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">curry</code><code class="o">&lt;</code><code class="nx">A</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">R</code> <code class="kr">extends</code> <code class="kr">any</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">A</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">R</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">R</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// see before, we're not changing the implementation</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Next, we redefine the <code>Curried</code> type. It now features two generic type parameters: <code>A</code> for arguments, <code>R</code> for the return type. As a first step, we check if the arguments contain tuple elements. We extract the first element <code>F</code> and all remaining elements <code>L</code>. If there are no elements left, we return the return type <code>R</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">A</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">R</code> <code class="kr">extends</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">F</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">L</code><code class="p">]</code>&#13;
  <code class="o">?</code> <code class="c1">// to be done</code>&#13;
  <code class="o">:</code> <code class="nx">R</code><code class="p">;</code></pre>&#13;
&#13;
<p>It’s not possible to extract multiple tuples via the rest operator. That’s why we still need to shave off the first element and collect the remaining elements in <code>L</code>. But that’s OK; we need at least <em>one</em> parameter to effectively do partial application.</p>&#13;
&#13;
<p>When we are in the <code>true</code> branch, we create the function definitions. In the previous example, we returned a function that returns a recursive call; now we need to provide all possible partial applications.</p>&#13;
&#13;
<p>Since function arguments are nothing but tuple types (see <a data-type="xref" href="#ch07_promisify">Recipe 7.2</a>), arguments of function overloads can be described as a union of tuple types. A type <code>Overloads</code> takes a tuple of function arguments and creates all partial applications:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Overloads</code><code class="o">&lt;</code><code class="nx">A</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[]</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">A</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">L</code><code class="p">]</code>&#13;
  <code class="o">?</code> <code class="p">[</code><code class="nx">A</code><code class="p">]</code> <code class="o">|</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="p">...</code><code class="nx">Overloads</code><code class="o">&lt;</code><code class="nx">L</code><code class="o">&gt;</code><code class="p">]</code> <code class="o">|</code> <code class="p">[]</code>&#13;
  <code class="o">:</code> <code class="p">[];</code></pre>&#13;
&#13;
<p>If we pass a tuple, we get a union starting from the empty tuple and then growing to one argument, then to two arguments, etc., and up to a tuple that includes all &#13;
<span class="keep-together">arguments:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// type Overloaded = [] | [string, number, string] | [string] | [string, number]</code>&#13;
<code class="kr">type</code> <code class="nx">Overloaded</code> <code class="o">=</code> <code class="nx">Overloads</code><code class="o">&lt;</code><code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Now that we can define all overloads, we take the remaining arguments of the original functions’ argument list and create all possible function calls that also include the first argument:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">A</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">R</code> <code class="kr">extends</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">F</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">L</code><code class="p">]</code>&#13;
  <code class="o">?</code> <code class="o">&lt;</code><code class="nx">K</code> <code class="kr">extends</code> <code class="nx">Overloads</code><code class="o">&lt;</code><code class="nx">L</code><code class="o">&gt;&gt;</code><code class="p">(</code>&#13;
      <code class="nx">arg</code><code class="o">:</code> <code class="nx">F</code><code class="p">,</code>&#13;
      <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">K</code>&#13;
    <code class="p">)</code> <code class="o">=&gt;</code> <code class="cm">/* to be done */</code>&#13;
  <code class="o">:</code> <code class="nx">R</code><code class="p">;</code></pre>&#13;
&#13;
<p>Applied to the <code>addThree</code> example from before, this part would create the first argument <code>F</code> as <code>number</code> and then combine it with <code>[]</code>, <code>[number]</code>, and <code>[number, number]</code>.</p>&#13;
&#13;
<p>Now for the return type. This is again a recursive call to <code>Curried</code>, just like in <a data-type="xref" href="#ch07_promisify">Recipe 7.2</a>. Remember, we chain functions in a sequence. We pass in the same return type—we need to get there eventually—but also need to pass all remaining arguments that we haven’t spread out in the function overloads. So if we call <code>addThree</code> only with &#13;
<span class="keep-together"><code>number</code></span>, the two remaining numbers need to be arguments of the next iteration of &#13;
<span class="keep-together"><code>Curried</code></span>. This is how we create a tree of possible invocations.</p>&#13;
&#13;
<p>To get to the possible combinations, we need to remove the arguments we already described in the function signature from the remaining arguments. A helper type <code>Remove&lt;T, U&gt;</code> goes through both tuples and shaves off one element each, until one of the two tuples runs out of elements:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">U</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[]</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">U</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">_</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">UL</code><code class="p">]</code>&#13;
  <code class="o">?</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">_</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">TL</code><code class="p">]</code>&#13;
    <code class="o">?</code> <code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">TL</code><code class="p">,</code> <code class="nx">UL</code><code class="o">&gt;</code>&#13;
    <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>Wiring that up to <code>Curried</code>, and we get the final result:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">A</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">R</code> <code class="kr">extends</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="p">[</code><code class="kr">infer</code> <code class="nx">F</code><code class="p">,</code> <code class="p">...</code><code class="kr">infer</code> <code class="nx">L</code><code class="p">]</code>&#13;
  <code class="o">?</code> <code class="o">&lt;</code><code class="nx">K</code> <code class="kr">extends</code> <code class="nx">Overloads</code><code class="o">&lt;</code><code class="nx">L</code><code class="o">&gt;&gt;</code><code class="p">(</code>&#13;
      <code class="nx">arg</code><code class="o">:</code> <code class="nx">F</code><code class="p">,</code>&#13;
      <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">K</code>&#13;
    <code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Curried</code><code class="o">&lt;</code><code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">L</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">R</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="nx">R</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>Curried&lt;A, R&gt;</code> now produces the same call graph as described in <a data-type="xref" href="#img-curry-illustration">Figure 7-1</a> but is flexible for all possible functions that we pass in <code>curry</code>. Proper type safety for maximum flexibility (shout-out to GitHub user Akira Matsuzaki who provided the &#13;
<span class="keep-together">missing</span> piece in their Type Challenges solution).<a data-startref="ix_07-04-asciidoc2" data-type="indexterm" id="id747"/><a data-startref="ix_07-04-asciidoc1" data-type="indexterm" id="id748"/><a data-startref="ix_07-04-asciidoc0" data-type="indexterm" id="id749"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.5 Typing the Simplest curry function" data-type="sect1"><div class="sect1" id="ch07_simple_curry">&#13;
<h1>7.5 Typing the Simplest curry function</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id225">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="curry function" data-secondary="typing the simplest curry function" data-type="indexterm" id="ix_07-05-asciidoc0"/><a data-primary="variadic tuple types" data-secondary="typing the simplest curry function" data-type="indexterm" id="ix_07-05-asciidoc1"/>The <code>curry</code> functions and their typings are impressive but come with a lot of caveats. Are there any simpler solutions?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id750">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a <code>curry</code> function with only a single sequential step. TypeScript can figure out the proper types on its own.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id112">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In the last piece of the <code>curry</code> trilogy, I want you to sit back and think a bit about what we saw in Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ch07_currying">7.3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ch07_flexible_currying">7.4</a>. We created very complex types that work almost like the actual implementation through TypeScript’s metaprogramming features. And while the results are impressive, there are some caveats we have to think about:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The way the types are implemented for both Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ch07_currying">7.3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ch07_flexible_currying">7.4</a> is a bit different, but the results vary a lot! Still, the <code>curry</code> function underneath stays the same. The only way this works is by using <code>any</code> in arguments and type assertions for the return type. What this means is that we effectively disable type-checking by forcing TypeScript to adhere to our view of the world. It’s great that TypeScript can do that, and at times it’s also necessary (such as the creation of new objects), but it can backfire, especially when both implementation and types get very complex. Tests for both types and implementation are a must. We talk about testing types in <a data-type="xref" href="ch12.html#ch12_testing_types">Recipe 12.4</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>You lose information. Especially when currying, keeping argument names is essential to know which arguments already have applied. The solutions in the earlier recipes couldn’t keep argument names but defaulted to a generic-sounding <code>a</code> or <code>args</code>. If your argument types are, for example, all strings, you can’t say which string you are currently writing.</p>&#13;
</li>&#13;
<li>&#13;
<p>While the result in <a data-type="xref" href="#ch07_flexible_currying">Recipe 7.4</a> gives you proper type-checking, autocomplete is limited because of the nature of the type. You know only that a second argument is needed the moment you type it. One of TypeScript’s main features is giving you the right tooling and information to make you more productive. The flexible &#13;
<span class="keep-together"><code>Curried</code></span> type reduces your productivity to guesswork again.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Again, while those types are impressive, there is no denying that they come with some huge trade-offs. This raises the question: should we even go for it? I think it really depends on what you try to achieve.</p>&#13;
&#13;
<p>In the case of currying and partial application, there are two camps. The first camp loves functional programming patterns and tries to leverage JavaScript’s functional capabilities to the max. They want to reuse partial applications as much as possible and need advanced currying functionalities. The other camp sees the benefit of functional programming patterns in certain situations—for example, waiting for the final parameter to give the same function to multiple events. They often are happy with applying as much as possible, but then provide the rest in a second step.</p>&#13;
&#13;
<p>We have dealt with only the first camp until now. If you’re in the second camp, you most likely only need a currying function that applies a few parameters partially, so you can pass in the rest in a second step: no sequence of parameters of one argument, and no flexible application of as many arguments as you like. An ideal interface would look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">applyClass</code><code class="p">(</code>&#13;
  <code class="k">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="c1">// for TypeScript only</code>&#13;
  <code class="nx">method</code><code class="o">:</code> <code class="s2">"remove"</code> <code class="o">|</code> <code class="s2">"add"</code><code class="p">,</code>&#13;
  <code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">event</code><code class="o">:</code> <code class="nx">Event</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">this</code> <code class="o">===</code> <code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">classList</code><code class="p">[</code><code class="nx">method</code><code class="p">](</code><code class="nx">className</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">removeToggle</code> <code class="o">=</code> <code class="nx">curry</code><code class="p">(</code><code class="nx">applyClass</code><code class="p">,</code> <code class="s2">"remove"</code><code class="p">,</code> <code class="s2">"hidden"</code><code class="p">);</code>&#13;
&#13;
<code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"button"</code><code class="p">)</code><code class="o">?</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="nx">removeToggle</code><code class="p">);</code></pre>&#13;
&#13;
<p class="pagebreak-before"><code>curry</code> is a function that takes another function <code>f</code> as an argument and then a sequence <code>t</code> of parameters of <code>f</code>. It returns a function that takes the remaining parameters <code>u</code> of <code>f</code>, which calls <code>f</code> with all possible parameters. The function could look like this in &#13;
<span class="keep-together">JavaScript:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">curry</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="p">...</code><code class="nx">t</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(...</code><code class="nx">u</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">(...</code><code class="nx">t</code><code class="p">,</code> <code class="p">...</code><code class="nx">u</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Thanks to the rest and spread operator, <code>curry</code> becomes a one-liner. Now let’s type this! We will have to use generics, as we deal with parameters that we don’t know yet. There’s the return type <code>R</code>, as well as both parts of the function’s arguments, <code>T</code> and <code>U</code>. The latter are variadic tuple types and need to be defined as such.</p>&#13;
&#13;
<p>With a generic type parameter <code>T</code> and <code>U</code> comprising the arguments of <code>f</code>, a type for <code>f</code> looks like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Fn</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">U</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[]</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
    <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[...</code><code class="nx">T</code><code class="p">,</code> <code class="p">...</code><code class="nx">U</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">;</code></pre>&#13;
&#13;
<p>Function arguments can be described as tuples, and here we say those function arguments should be split into two parts. Let’s inline this type to <code>curry</code> and use another generic type parameter for the return type <code>R</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">curry</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">U</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">R</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">f</code><code class="o">:</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[...</code><code class="nx">T</code><code class="p">,</code> <code class="p">...</code><code class="nx">U</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">R</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">t</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(...</code><code class="nx">u</code><code class="o">:</code> <code class="nx">U</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">(...</code><code class="nx">t</code><code class="p">,</code> <code class="p">...</code><code class="nx">u</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And that’s all the types we need: simple, straightforward, and the types look very similar to the actual implementation. With a few variadic tuple types, TypeScript gives us:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>100% type safety. TypeScript directly infers the generic types from your usage, and they are correct. No laboriously crafted types through conditional types and recursion.</p>&#13;
</li>&#13;
<li>&#13;
<p>We get autocomplete for all possible solutions. The moment you add a <code>,</code> to announce the next step of your arguments, TypeScript will adapt types and give you a hint about what to expect.</p>&#13;
</li>&#13;
<li>&#13;
<p>We don’t lose any information. Since we don’t construct new types, TypeScript keeps the labels from the original type, and we know which arguments to expect.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p class="pagebreak-before">Yes, <code>curry</code> is not as flexible as the original version, but for a lot of use cases, this might be the right choice. It’s all about the trade-offs we accept for our use case.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you work with tuples a lot, you can name the elements of your tuple types: <code>type Person = [name: string, age: number];</code>. Those labels are just annotations and are removed after &#13;
<span class="keep-together">transpilation.</span></p>&#13;
</div>&#13;
&#13;
<p>Ultimately, the <code>curry</code> function and its many different implementations stand for the many ways you can use TypeScript to solve a particular problem. You can go all out with the type system and use it for very complex and elaborate types, or you can reduce the scope a bit and let the compiler do the work for you. Your choice depends on your goals and what you try to achieve.<a data-startref="ix_07-05-asciidoc1" data-type="indexterm" id="id751"/><a data-startref="ix_07-05-asciidoc0" data-type="indexterm" id="id752"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.6 Creating an Enum from a Tuple" data-type="sect1"><div class="sect1" id="ch07_creating_an_enum_from_a_tuple">&#13;
<h1>7.6 Creating an Enum from a Tuple</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id113">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="creating an enum from a tuple" data-type="indexterm" id="ix_07-06-asciidoc0"/><a data-primary="enums" data-secondary="creating from a tuple" data-type="indexterm" id="ix_07-06-asciidoc1"/><a data-primary="tuples, creating enums from" data-type="indexterm" id="ix_07-06-asciidoc2"/><a data-primary="variadic tuple types" data-secondary="creating an enum from a tuple" data-type="indexterm" id="ix_07-06-asciidoc3"/>You like how enums make it easy to select valid values, but after reading <a data-type="xref" href="ch03.html#ch03_item_enums">Recipe 3.12</a> you don’t want to deal with all their caveats.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id753">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create your enums from a tuple. Use conditional types, variadic tuple types, and the <code>"length"</code> property to type the data structure.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id114">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#ch03_item_enums">Recipe 3.12</a> we discussed all possible caveats when using number and string enums. We ended up with a pattern that is much closer to the type system but gives you the same developer experience as regular enums:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Direction</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Up</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="nx">Down</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="nx">Left</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">Right</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Get to the const values of Direction</code>&#13;
<code class="kr">type</code> <code class="nx">Direction</code> <code class="o">=</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">Direction</code><code class="p">)[</code><code class="kr">keyof</code> <code class="k">typeof</code> <code class="nx">Direction</code><code class="p">];</code>&#13;
&#13;
<code class="c1">// (typeof Direction)[keyof typeof Direction] yields 0 | 1 | 2 | 3</code>&#13;
<code class="kd">function</code> <code class="nx">move</code><code class="p">(</code><code class="nx">direction</code><code class="o">:</code> <code class="nx">Direction</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">move</code><code class="p">(</code><code class="mi">30</code><code class="p">);</code> <code class="c1">// This breaks!</code>&#13;
&#13;
<code class="nx">move</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code> <code class="c1">//This works!</code>&#13;
&#13;
<code class="nx">move</code><code class="p">(</code><code class="nx">Direction</code><code class="p">.</code><code class="nx">Left</code><code class="p">);</code> <code class="c1">// This also works!</code></pre>&#13;
&#13;
<p>It’s a very straightforward pattern with no surprises, but it can result in a lot of work for you if you are dealing with lots of entries, especially if you want to have string enums:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Commands</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Shift</code><code class="o">:</code> <code class="s2">"shift"</code><code class="p">,</code>&#13;
  <code class="nx">Xargs</code><code class="o">:</code> <code class="s2">"xargs"</code><code class="p">,</code>&#13;
  <code class="nx">Tail</code><code class="o">:</code> <code class="s2">"tail"</code><code class="p">,</code>&#13;
  <code class="nx">Head</code><code class="o">:</code> <code class="s2">"head"</code><code class="p">,</code>&#13;
  <code class="nx">Uniq</code><code class="o">:</code> <code class="s2">"uniq"</code><code class="p">,</code>&#13;
  <code class="nx">Cut</code><code class="o">:</code> <code class="s2">"cut"</code><code class="p">,</code>&#13;
  <code class="nx">Awk</code><code class="o">:</code> <code class="s2">"awk"</code><code class="p">,</code>&#13;
  <code class="nx">Sed</code><code class="o">:</code> <code class="s2">"sed"</code><code class="p">,</code>&#13;
  <code class="nx">Grep</code><code class="o">:</code> <code class="s2">"grep"</code><code class="p">,</code>&#13;
  <code class="nx">Echo</code><code class="o">:</code> <code class="s2">"echo"</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code></pre>&#13;
&#13;
<p>There is duplication, which may result in typos, which may lead to undefined behavior. A helper function that creates an enum like this for you helps deal with redundancy and duplication. Let’s say you have a collection of items like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">commandItems</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="s2">"echo"</code><code class="p">,</code>&#13;
  <code class="s2">"grep"</code><code class="p">,</code>&#13;
  <code class="s2">"sed"</code><code class="p">,</code>&#13;
  <code class="s2">"awk"</code><code class="p">,</code>&#13;
  <code class="s2">"cut"</code><code class="p">,</code>&#13;
  <code class="s2">"uniq"</code><code class="p">,</code>&#13;
  <code class="s2">"head"</code><code class="p">,</code>&#13;
  <code class="s2">"tail"</code><code class="p">,</code>&#13;
  <code class="s2">"xargs"</code><code class="p">,</code>&#13;
  <code class="s2">"shift"</code><code class="p">,</code>&#13;
<code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code></pre>&#13;
&#13;
<p>A helper function <code>createEnum</code> iterates through every item, creating an object with capitalized keys that point either to a string value or to a number value, depending on your input parameters:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">capitalize</code><code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">x</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">0</code><code class="p">).</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="o">+</code> <code class="nx">x</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Typings to be done</code>&#13;
<code class="kd">function</code> <code class="nx">createEnum</code><code class="p">(</code><code class="nx">arr</code><code class="p">,</code> <code class="nx">numeric</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">i</code><code class="p">,</code> <code class="nx">el</code><code class="p">]</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="p">{</code>&#13;
    <code class="nx">obj</code><code class="p">[</code><code class="nx">capitalize</code><code class="p">(</code><code class="nx">el</code><code class="p">)]</code> <code class="o">=</code> <code class="nx">numeric</code> <code class="o">?</code> <code class="nx">i</code> <code class="o">:</code> <code class="nx">el</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">obj</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Command</code> <code class="o">=</code> <code class="nx">createEnum</code><code class="p">(</code><code class="nx">commandItems</code><code class="p">);</code> <code class="c1">// string enum</code>&#13;
<code class="kr">const</code> <code class="nx">CommandN</code> <code class="o">=</code> <code class="nx">createEnum</code><code class="p">(</code><code class="nx">commandItems</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code> <code class="c1">// number enum</code></pre>&#13;
&#13;
<p>Let’s create types for this! We need to take care of two things:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Create an object from a tuple. The keys are capitalized.</p>&#13;
</li>&#13;
<li>&#13;
<p>Set the values of each property key to either a string value or a number value. The number values should start at 0 and increase by one with each step.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To create object keys, we need a union type we can map out. To get all object keys, we need to convert our tuple to a union type. A helper type <code>TupleToUnion</code> takes a string tuple and converts it to a union type. Why only string tuples? Because we need object keys, and string keys are the easiest to use.</p>&#13;
&#13;
<p><code>TupleToUnion&lt;T&gt;</code> is a recursive type. Like we did in other lessons, we are shaving off single elements—this time at the end of the tuple—and then calling the type again with the remaining elements. We put each call in a union, effectively getting a union type of tuple elements:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">readonly</code> <code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kr">readonly</code> <code class="p">[</code>&#13;
  <code class="p">...</code><code class="kr">infer</code> <code class="nx">Rest</code> <code class="kr">extends</code> <code class="kt">string</code><code class="p">[],</code>&#13;
  <code class="kr">infer</code> <code class="nx">Key</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="p">]</code>&#13;
  <code class="o">?</code> <code class="nx">Key</code> <code class="o">|</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>With a map type and a string manipulation type, we can create the string enum version of <code>Enum&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Enum</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">readonly</code> <code class="kt">string</code><code class="p">[],</code> <code class="nx">N</code> <code class="kr">extends</code> <code class="kr">boolean</code> <code class="o">=</code> <code class="kc">false</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Readonly</code><code class="o">&lt;</code>&#13;
  <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">as</code> <code class="nx">Capitalize</code><code class="o">&lt;</code><code class="nx">K</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="nx">K</code>&#13;
  <code class="p">}</code>&#13;
<code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-primary="TupleToUnion&lt;T&gt;" data-type="indexterm" id="ix_07-06-asciidoc4"/>For the number enum version, we need to get a numerical representation of each value. If we think about it, we have already stored it somewhere in our original data. Let’s look at how <code>TupleToUnion</code> deals with a four-element tuple:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// The type we want to convert to a union type</code>&#13;
<code class="kr">type</code> <code class="nx">Direction</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"up"</code><code class="p">,</code> <code class="s2">"down"</code><code class="p">,</code> <code class="s2">"left"</code><code class="p">,</code> <code class="s2">"right"</code><code class="p">];</code>&#13;
&#13;
<code class="c1">// Calling the helper type</code>&#13;
<code class="kr">type</code> <code class="nx">DirectionUnion</code> <code class="o">=</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="nx">Direction</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Extracting the last, recursively calling TupleToUnion with the Rest</code>&#13;
<code class="kr">type</code> <code class="nx">DirectionUnion</code> <code class="o">=</code> <code class="s2">"right"</code> <code class="o">|</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="p">[</code><code class="s2">"up"</code><code class="p">,</code> <code class="s2">"down"</code><code class="p">,</code> <code class="s2">"left"</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Extracting the last, recursively calling TupleToUnion with the Rest</code>&#13;
<code class="kr">type</code> <code class="nx">DirectionUnion</code> <code class="o">=</code> <code class="s2">"right"</code> <code class="o">|</code> <code class="s2">"left"</code> <code class="o">|</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="p">[</code><code class="s2">"up"</code><code class="p">,</code> <code class="s2">"down"</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Extracting the last, recursively calling TupleToUnion with the Rest</code>&#13;
<code class="kr">type</code> <code class="nx">DirectionUnion</code> <code class="o">=</code> <code class="s2">"right"</code> <code class="o">|</code> <code class="s2">"left"</code> <code class="o">|</code> <code class="s2">"down"</code> <code class="o">|</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="p">[</code><code class="s2">"up"</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
&#13;
<code class="c1">// Extracting the last, recursively calling TupleToUnion with an empty tuple</code>&#13;
<code class="kr">type</code> <code class="nx">DirectionUnion</code> <code class="o">=</code> <code class="s2">"right"</code> <code class="o">|</code> <code class="s2">"left"</code> <code class="o">|</code> <code class="s2">"down"</code> <code class="o">|</code> <code class="s2">"up"</code> <code class="o">|</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// The conditional type goes into the else branch, adding never to the union</code>&#13;
<code class="kr">type</code> <code class="nx">DirectionUnion</code> <code class="o">=</code> <code class="s2">"right"</code> <code class="o">|</code> <code class="s2">"left"</code> <code class="o">|</code> <code class="s2">"down"</code> <code class="o">|</code> <code class="s2">"up"</code> <code class="o">|</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// never in a union is swallowed</code>&#13;
<code class="kr">type</code> <code class="nx">DirectionUnion</code> <code class="o">=</code> <code class="s2">"right"</code> <code class="o">|</code> <code class="s2">"left"</code> <code class="o">|</code> <code class="s2">"down"</code> <code class="o">|</code> <code class="s2">"up"</code><code class="p">;</code></pre>&#13;
&#13;
<p>If you look closely, you can see that the length of the tuple is decreasing with each call. First, it’s three elements, then two, then one, and ultimately there are no elements left. Tuples are defined by the length of the array and the type at each position in the array. TypeScript stores the length as a number for tuples, accessible via the <code>"length"</code> property:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">DirectionLength</code> <code class="o">=</code> <code class="nx">Direction</code><code class="p">[</code><code class="s2">"length"</code><code class="p">];</code> <code class="c1">// 4</code></pre>&#13;
&#13;
<p>So with each recursive call, we can get the length of the remaining elements and use this as a value for the enum. Instead of just returning the enum keys, we return an object with the key and its possible number value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">readonly</code> <code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kr">readonly</code> <code class="p">[</code>&#13;
  <code class="p">...</code><code class="kr">infer</code> <code class="nx">Rest</code> <code class="kr">extends</code> <code class="kt">string</code><code class="p">[],</code>&#13;
  <code class="kr">infer</code> <code class="nx">Key</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="p">]</code>&#13;
  <code class="o">?</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="nx">Key</code><code class="p">;</code> <code class="nx">val</code><code class="o">:</code> <code class="nx">Rest</code><code class="p">[</code><code class="s2">"length"</code><code class="p">]</code> <code class="p">}</code> <code class="o">|</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>We use this newly created object to decide whether we want to have number values or string values in our enum:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Enum</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">readonly</code> <code class="kt">string</code><code class="p">[],</code> <code class="nx">N</code> <code class="kr">extends</code> <code class="kr">boolean</code> <code class="o">=</code> <code class="kc">false</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Readonly</code><code class="o">&lt;</code>&#13;
  <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">TupleToUnion</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">as</code> <code class="nx">Capitalize</code><code class="o">&lt;</code><code class="nx">K</code><code class="p">[</code><code class="s2">"key"</code><code class="p">]</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="nx">N</code> <code class="kr">extends</code> <code class="kc">true</code>&#13;
      <code class="o">?</code> <code class="nx">K</code><code class="p">[</code><code class="s2">"val"</code><code class="p">]</code>&#13;
      <code class="o">:</code> <code class="nx">K</code><code class="p">[</code><code class="s2">"key"</code><code class="p">];</code>&#13;
  <code class="p">}</code>&#13;
<code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>And that’s it! We wire up our new <code>Enum&lt;T, N&gt;</code> type to the <code>createEnum</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Values</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">[</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">];</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">createEnum</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">readonly</code> <code class="kt">string</code><code class="p">[],</code> <code class="nx">B</code> <code class="kr">extends</code> <code class="kr">boolean</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">numeric</code><code class="o">?:</code> <code class="nx">B</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="kr">any</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">i</code><code class="p">,</code> <code class="nx">el</code><code class="p">]</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="p">{</code>&#13;
    <code class="nx">obj</code><code class="p">[</code><code class="nx">capitalize</code><code class="p">(</code><code class="nx">el</code><code class="p">)]</code> <code class="o">=</code> <code class="nx">numeric</code> <code class="o">?</code> <code class="nx">i</code> <code class="o">:</code> <code class="nx">el</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">obj</code> <code class="kr">as</code> <code class="nx">Enum</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">B</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Command</code> <code class="o">=</code> <code class="nx">createEnum</code><code class="p">(</code><code class="nx">commandItems</code><code class="p">,</code> <code class="kc">false</code><code class="p">);</code>&#13;
<code class="kr">type</code> <code class="nx">Command</code> <code class="o">=</code> <code class="nx">Values</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">Command</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Being able to access the length of a tuple within the type system is one of the hidden gems in TypeScript.<a data-startref="ix_07-06-asciidoc4" data-type="indexterm" id="id754"/> This allows for many things, as shown in this example, but also fun stuff like implementing calculators in the type system. As with all advanced features in TypeScript, use them wisely.<a data-startref="ix_07-06-asciidoc3" data-type="indexterm" id="id755"/><a data-startref="ix_07-06-asciidoc2" data-type="indexterm" id="id756"/><a data-startref="ix_07-06-asciidoc1" data-type="indexterm" id="id757"/><a data-startref="ix_07-06-asciidoc0" data-type="indexterm" id="id758"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="7.7 Splitting All Elements of a Function Signature" data-type="sect1"><div class="sect1" id="ch07_splitting_elements">&#13;
<h1>7.7 Splitting All Elements of a Function Signature</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id115">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="function signatures" data-secondary="splitting all elements of" data-type="indexterm" id="ix_07-07-asciidoc0"/><a data-primary="Parameters&lt;F&gt; helper type" data-type="indexterm" id="ix_07-07-asciidoc1"/><a data-primary="ReturnType&lt;F&gt; helper type" data-type="indexterm" id="ix_07-07-asciidoc2"/><a data-primary="variadic tuple types" data-secondary="splitting all elements of a function signature" data-type="indexterm" id="ix_07-07-asciidoc3"/>You know how to grab argument types and return types from functions within a function, but you want to use the same types outside as well.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id759">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the built-in <code>Parameters&lt;F&gt;</code> and <code>ReturnType&lt;F&gt;</code> helper types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id116">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In this chapter, we have dealt with helper functions and how they can grab information from functions that are arguments. For example, this <code>defer</code> function takes a function and all its arguments and returns another function that will execute it. With some generic types, we can capture everything we need:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">defer</code><code class="o">&lt;</code><code class="nx">Par</code> <code class="kr">extends</code> <code class="kr">unknown</code><code class="p">[],</code> <code class="nx">Ret</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(...</code><code class="nx">par</code><code class="o">:</code> <code class="nx">Par</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Ret</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Par</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">Ret</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">log</code> <code class="o">=</code> <code class="nx">defer</code><code class="p">(</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">,</code> <code class="s2">"Hello, world!"</code><code class="p">);</code>&#13;
<code class="nx">log</code><code class="p">();</code></pre>&#13;
&#13;
<p class="pagebreak-before">This works great if we pass functions as arguments because we can easily pick the details and reuse them. But certain scenarios need a function’s arguments and its return type outside of a generic function. Thankfully, we can leverage some built-in TypeScript helper types. With <code>Parameters&lt;F&gt;</code> we get a function’s arguments as a tuple; with <code>ReturnType&lt;F&gt;</code> we get the return type of a function. So the <code>defer</code> function from before could be written like:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Fn</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">defer</code><code class="o">&lt;</code><code class="nx">F</code> <code class="kr">extends</code> <code class="nx">Fn</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fn</code><code class="o">:</code> <code class="nx">F</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Parameters</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Both <code>Parameters&lt;F&gt;</code> and <code>ReturnType&lt;F&gt;</code> are conditional types that rely on function/tuple types and are very similar. In <code>Parameters&lt;F&gt;</code> we infer the arguments, and in <code>ReturnType&lt;F&gt;</code> we infer the return type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Parameters</code><code class="o">&lt;</code><code class="nx">F</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">F</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">P</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">P</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="nx">F</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">F</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">infer</code> <code class="nx">R</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">any</code><code class="p">;</code></pre>&#13;
&#13;
<p>We can use those helper types, for example, to prepare function arguments outside of functions. Take this <code>search</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Result</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">page</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">description</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">search</code><code class="p">(</code><code class="nx">query</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">tags</code><code class="o">:</code> <code class="kt">string</code><code class="p">[])</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Result</code><code class="p">[]</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="k">throw</code> <code class="s2">"to be done"</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With <code>Parameters&lt;typeof search&gt;</code> we get an idea of which parameters to expect. We define them outside of the function call and spread them as arguments when calling:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">searchParams</code><code class="o">:</code> <code class="nx">Parameters</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">search</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="s2">"Variadic tuple tpyes"</code><code class="p">,</code>&#13;
  <code class="p">[</code><code class="s2">"TypeScript"</code><code class="p">,</code> <code class="s2">"JavaScript"</code><code class="p">],</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="nx">search</code><code class="p">(...</code><code class="nx">searchParams</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">deferredSearch</code> <code class="o">=</code> <code class="nx">defer</code><code class="p">(</code><code class="nx">search</code><code class="p">,</code> <code class="p">...</code><code class="nx">searchParams</code><code class="p">);</code></pre>&#13;
&#13;
<p>Both helpers come in handy when you generate new types as well; see <a data-type="xref" href="ch04.html#ch04_this_type">Recipe 4.8</a> for an example.<a data-startref="ix_07-07-asciidoc3" data-type="indexterm" id="id760"/><a data-startref="ix_07-07-asciidoc2" data-type="indexterm" id="id761"/><a data-startref="ix_07-07-asciidoc1" data-type="indexterm" id="id762"/><a data-startref="ix_07-07-asciidoc0" data-type="indexterm" id="id763"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>