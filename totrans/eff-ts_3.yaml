- en: Chapter 3\. Type Inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For programming languages used in industry, “statically typed” and “explicitly
    typed” have traditionally been synonymous. C, C++, Java: they all made you write
    out your types. But academic languages never conflated these two things: languages
    like ML and Haskell have long had sophisticated type inference systems, and in
    the past decade this has begun to work its way into industry languages. C++ has
    added `auto`, and Java has added `var`.'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript makes extensive use of type inference. Used well, this can dramatically
    reduce the number of type annotations your code requires to get full type safety.
    One of the easiest ways to tell a TypeScript beginner from a more experienced
    user is by the number of type annotations. An experienced TypeScript developer
    will use relatively few annotations (but use them to great effect), while a beginner
    may drown their code in redundant type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows you some of the problems that can arise with type inference
    and how to fix them. After reading it, you should have a good understanding of
    how TypeScript infers types, when you still need to write type declarations, and
    when it’s a good idea to write type declarations even when a type can be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 19: Avoid Cluttering Your Code with Inferable Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that many new TypeScript developers do when they convert a codebase
    from JavaScript is fill it with type annotations. TypeScript is about *types*,
    after all! But in TypeScript many annotations are unnecessary. Declaring types
    for all your variables is counterproductive and is considered poor style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, just write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you mouse over `x` in your editor, you’ll see that its type has been inferred
    as `number` (as shown in [Figure 3-1](#efts-3in1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 03in01](assets/efts_03in01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. A text editor showing that the inferred type of x is number.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The explicit type annotation is redundant. Writing it just adds noise. If you’re
    unsure of the type, you can check it in your editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript will also infer the types of more complex objects. Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'you can just write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, the types are exactly the same. Writing the type in addition to the value
    just adds noise here. ([Item 21](#widening) has more to say on the types inferred
    for object literals.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s true for objects is also true for arrays. TypeScript has no trouble
    figuring out the return type of this function based on its inputs and operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript may infer something more precise than what you expected. This is
    generally a good thing. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`"y"` is a more precise type for the `axis` variable. [Item 21](#widening)
    gives an example of how this can fix a type error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowing types to be inferred can also facilitate refactoring. Say you have
    a `Product` type and a function to log it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point you learn that product IDs might have letters in them in addition
    to numbers. So you change the type of `id` in `Product`. Because you included
    explicit annotations on all the variables in `logProduct`, this produces an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Had you left off all the annotations in the `logProduct` function body, the
    code would have passed the type checker without modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better implementation of `logProduct` would use destructuring assignment
    ([Item 58](ch08.html#write-modern-js)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This version allows the types of all the local variables to be inferred. The
    corresponding version with explicit type annotations is repetitive and cluttered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicit type annotations are still required in some situations where TypeScript
    doesn’t have enough context to determine a type on its own. You have seen one
    of these before: function parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Some languages will infer types for parameters based on their eventual usage,
    but TypeScript does not. In TypeScript, a variable’s type is generally determined
    when it is first introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal TypeScript code includes type annotations for function/method signatures
    but not for the local variables created in their bodies. This keeps noise to a
    minimum and lets readers focus on the implementation logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some situations where you can leave the type annotations off of function
    parameters, too. When there’s a default value, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here the type of `base` is inferred as `number` because of the default value
    of `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter types can usually be inferred when the function is used as a callback
    for a library with type declarations. The declarations on `request` and `response`
    in this example using the express HTTP server library are not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Item 26](#context-inference) goes into more depth on how context is used in
    type inference.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few situations where you may still want to specify a type even where
    it can be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'One is when you define an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you specify a type on a definition like this, you enable excess property
    checking ([Item 11](ch02_split_001.html#excess-property-checking)). This can help
    catch errors, particularly for types with optional fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also increase the odds that an error will be reported in the right place.
    If you leave off the annotation, a mistake in the object’s definition will result
    in a type error where it’s used, rather than where it’s defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With an annotation, you get a more concise error in the place where the mistake
    was made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similar considerations apply to a function’s return type. You may still want
    to annotate this even when it can be inferred to ensure that implementation errors
    don’t leak out into uses of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have a function which retrieves a stock quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You decide to add a cache to avoid duplicating network requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a mistake in this implementation: you should really be returning `Promise.resolve(cache[ticker])`
    so that `getQuote` always returns a Promise. The mistake will most likely produce
    an error…but in the code that calls `getQuote`, rather than in `getQuote` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Had you annotated the intended return type (`Promise<number>`), the error would
    have been reported in the correct place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When you annotate the return type, it keeps implementation errors from manifesting
    as errors in user code. (See [Item 25](#use-async-await) for a discussion of async
    functions, which are an effective way to avoid this specific error with Promises.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing out the return type may also help you think more clearly about your
    function: you should know what its input and output types are *before you implement
    it*. While the implementation may shift around a bit, the function’s contract
    (its type signature) generally should not. This is similar in spirit to test-driven
    development (TDD), in which you write the tests that exercise a function before
    you implement it. Writing the full type signature first helps get you the function
    you want, rather than the one the implementation makes expedient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A final reason to annotate return values is if you want to use a named type.
    You might choose not to write a return type for this function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript infers the return type as `{ x: number; y: number; }`. This is compatible
    with `Vector2D`, but it may be surprising to users of your code when they see
    `Vector2D` as a type of the input and not of the output (as shown in [Figure 3-2](#efts-03in02)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 03in02](assets/efts_03in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. The parameters to the add function have named types, while the
    inferred return value does not.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you annotate the return type, the presentation is more straightforward. And
    if you’ve written documentation on the type ([Item 48](ch06.html#use-tsdoc)) then
    it will be associated with the returned value as well. As the complexity of the
    inferred return type increases, it becomes increasingly helpful to provide a name.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a linter, the eslint rule `no-inferrable-types` (note the variant
    spelling) can help ensure that all your type annotations are really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Avoid writing type annotations when TypeScript can infer the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally your code has type annotations in function/method signatures but not
    on local variables in their bodies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using explicit annotations for object literals and function return
    types even when they can be inferred. This will help prevent implementation errors
    from surfacing in user code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 20: Use Different Variables for Different Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript it’s no problem to reuse a variable to hold a differently typed
    value for a different purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, this results in two errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hovering over the first `id` in your editor gives a hint as to what’s going
    on (see [Figure 3-3](#efts-03in03)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 03in03](assets/efts_03in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. The inferred type of id is string.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Based on the value `"12-34-56"`, TypeScript has inferred `id`’s type as `string`.
    You can’t assign a `number` to a `string` and hence the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to a key insight about variables in TypeScript: *while a variable’s
    value can change, its type generally does not*. The one common way a type can
    change is to narrow ([Item 22](#narrowing)), but this involves a type getting
    smaller, not expanding to include new values. There are some important exceptions
    to this rule ([Item 41](ch05.html#evolving-any)), but they are the exceptions
    and not the rule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How can you use this idea to fix the example? In order for `id`’s type to not
    change, it must be broad enough to encompass both `string`s and `number`s. This
    is the very definition of the union type, `string|number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This fixes the errors. It’s interesting that TypeScript has been able to determine
    that `id` is really a `string` in the first call and really a `number` in the
    second. It has narrowed the union type based on the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: While a union type does work, it may create more issues down the road. Union
    types are harder to work with than simple types like `string` or `number` because
    you usually have to check what they are before you do anything with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The better solution is to introduce a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous version, the first and second `id` were not semantically related
    to one another. They were only related by the fact that you reused a variable.
    This was confusing for the type checker and would be confusing for a human reader,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version with two variables is better for a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It disentangles two unrelated concepts (ID and serial number).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to use more specific variable names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It improves type inference. No type annotations are needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It results in simpler types (`string` and `number`, rather than `string|number`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It lets you declare the variables `const` rather than `let`. This makes them
    easier for people and the type checker to reason about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid type-changing variables. If you can use different names for different
    concepts, it will make your code clearer both to human readers and to the type
    checker.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not to be confused with “shadowed” variables as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While these two `id`s share a name, they are actually two distinct variables
    with no relationship to one another. It’s fine for them to have different types.
    While TypeScript is not confused by this, your human readers might be. In general
    it’s better to use different names for different concepts. Many teams choose to
    disallow this sort of shadowing via linter rules.
  prefs: []
  type: TYPE_NORMAL
- en: This item focused on scalar values, but similar considerations apply to objects.
    For more on that, see [Item 23](#all-at-once).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While a variable’s value can change, its type generally does not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid confusion, both for human readers and for the type checker, avoid reusing
    variables for differently typed values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 21: Understand Type Widening'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As [Item 7](ch02_split_000.html#types-as-sets) explained, at runtime every variable
    has a single value. But at static analysis time, when TypeScript is checking your
    code, a variable has a set of *possible* values, namely, its type. When you initialize
    a variable with a constant but don’t provide a type, the type checker needs to
    decide on one. In other words, it needs to decide on a set of possible values
    from the single value that you specified. In TypeScript, this process is known
    as *widening*. Understanding it will help you make sense of errors and make more
    effective use of type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you’re writing a library to work with vectors. You write out a type
    for a 3D vector and a function to get the value of any of its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But when you try to use it, TypeScript flags an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code runs fine, so why the error?
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that `x`’s type is inferred as `string`, whereas the `getComponent`
    function expected a more specific type for its second argument. This is widening
    at work, and here it has led to an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is ambiguous in the sense that there are many possible types for
    any given value. In this statement, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'what should the type of `mixed` be? Here are a few possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(''x'' | 1)[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[''x'', 1]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[string, number]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly [string, number]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(string|number)[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly (string|number)[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[any, any]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without more context, TypeScript has no way to know which one is “right.” It
    has to guess at your intent. (In this case, it guesses `(string|number)[]`.) And
    smart as it is, TypeScript can’t read your mind. It won’t get this right 100%
    of the time. The result is inadvertent errors like the one we just looked at.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initial example, the type of `x` is inferred as `string` because TypeScript
    chooses to allow code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But it would also be valid JavaScript to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In inferring the type of `x` as `string`, TypeScript attempts to strike a balance
    between specificity and flexibility. The general rule is that a variable’s type
    shouldn’t change after it’s declared ([Item 20](#one-var-one-type)), so `string`
    makes more sense than `string|RegExp` or `string|string[]` or `any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript gives you a few ways to control the process of widening. One is
    `const`. If you declare a variable with `const` instead of `let`, it gets a narrower
    type. In fact, using `const` fixes the error in our original example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Because `x` cannot be reassigned, TypeScript is able to infer a narrower type
    without risk of inadvertently flagging errors on subsequent assignments. And because
    the string literal type `"x"` is assignable to `"x"|"y"|"z"`, the code passes
    the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: '`const` isn’t a panacea, however. For objects and arrays, there is still ambiguity.
    The `mixed` example here illustrates the issue for arrays: should TypeScript infer
    a tuple type? What type should it infer for the elements? Similar issues arise
    with objects. This code is fine in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `v` could be inferred anywhere along the spectrum of specificity.
    At the specific end is `{readonly x: 1}`. More general is `{x: number}`. More
    general still would be `{[key: string]: number}` or `object`. In the case of objects,
    TypeScript’s widening algorithm treats each element as though it were assigned
    with `let`. So the type of `v` comes out as `{x: number}`. This lets you reassign
    `v.x` to a different number, but not to a `string`. And it prevents you from adding
    other properties. (This is a good reason to build objects all at once, as explained
    in [Item 23](#all-at-once).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the last three statements are errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Again, TypeScript is trying to strike a balance between specificity and flexibility.
    It needs to infer a specific enough type to catch errors, but not so specific
    that it creates false positives. It does this by inferring a type of `number`
    for a property initialized to a value like `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know better, there are a few ways to override TypeScript’s default behavior.
    One is to supply an explicit type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Another is to provide additional context to the type checker (e.g., by passing
    the value as the parameter of a function). For much more on the role of context
    in type inference, see [Item 26](#context-inference).
  prefs: []
  type: TYPE_NORMAL
- en: 'A third way is with a `const` assertion. This is not to be confused with `let`
    and `const`, which introduce symbols in value space. This is a purely type-level
    construct. Look at the different inferred types for these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When you write `as const` after a value, TypeScript will infer the narrowest
    possible type for it. There is *no* widening. For true constants, this is typically
    what you want. You can also use `as const` with arrays to infer a tuple type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you’re getting incorrect errors that you think are due to widening, consider
    adding some explicit type annotations or `const` assertions. Inspecting types
    in your editor is the key to building an intuition for this (see [Item 6](ch02_split_000.html#editor)).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understand how TypeScript infers a type from a constant by widening it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Familiarize yourself with the ways you can affect this behavior: `const`, type
    annotations, context, and `as const`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 22: Understand Type Narrowing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The opposite of widening is narrowing. This is the process by which TypeScript
    goes from a broad type to a narrower one. Perhaps the most common example of this
    is null checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If `el` is `null`, then the code in the first branch won’t execute. So TypeScript
    is able to exclude `null` from the type union within this block, resulting in
    a narrower type which is much easier to work with. The type checker is generally
    quite good at narrowing types in conditionals like these, though it can occasionally
    be thwarted by aliasing ([Item 24](#avoid-aliasing)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also narrow a variable’s type for the rest of a block by throwing or
    returning from a branch. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many ways that you can narrow a type. Using `instanceof` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So does a property check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Some built-in functions such as `Array.isArray` are able to narrow types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript is generally quite good at tracking types through conditionals.
    Think twice before adding an assertion—it might be onto something that you’re
    not! For example, this is the wrong way to exclude `null` from a union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `typeof null` is `"object"` in JavaScript, you have not, in fact, excluded
    `null` with this check! Similar surprises can come from falsy primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Because the empty string and `0` are both falsy, `x` could still be a `string`
    or `number` in that branch. TypeScript is right!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common way to help the type checker narrow your types is by putting
    an explicit “tag” on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is known as a “tagged union” or “discriminated union,” and it is
    ubiquitous in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'If TypeScript isn’t able to figure out a type, you can even introduce a custom
    function to help it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is known as a “user-defined type guard.” The `el is HTMLInputElement` as
    a return type tells the type checker that it can narrow the type of the parameter
    if the function returns true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some functions are able to use type guards to perform type narrowing across
    arrays or objects. If you do some lookups in an array, for instance, you may wind
    up with an array of nullable types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you filter out the `undefined` values using `filter`, TypeScript isn’t able
    to follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you use a type guard, it can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As always, inspecting types in your editor is key to building an intuition for
    how narrowing works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how types in TypeScript narrow will help you build an intuition
    for how type inference works, make sense of errors, and generally have a more
    productive relationship with the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understand how TypeScript narrows types based on conditionals and other types
    of control flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tagged/discriminated unions and user-defined type guards to help the process
    of narrowing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 23: Create Objects All at Once'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As [Item 20](#one-var-one-type) explained, while a variable’s value may change,
    its type in TypeScript generally does not. This makes some JavaScript patterns
    easier to model in TypeScript than others. In particular, it means that you should
    prefer creating objects all at once, rather than piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one way to create an object representing a two-dimensional point in
    JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, this will produce errors on each assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is because the type of `pt` on the first line is inferred based on its
    value `{}`, and you may only assign to known properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'You get the opposite problem if you define a `Point` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to define the object all at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you must build the object piecemeal, you may use a type assertion (`as`)
    to silence the type checker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'But the better way is by building the object all at once and using a declaration
    (see [Item 9](ch02_split_000.html#prefer-declarations-to-assertions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to build a larger object from smaller ones, avoid doing it in multiple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can build the larger object all at once instead using the *object spread
    operator*, `...`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the object spread operator to build up objects field by field
    in a type-safe way. The key is to use a new variable on every update so that each
    gets a new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: While this is a roundabout way to build up such a simple object, it can be a
    useful technique for adding properties to an object and allowing TypeScript to
    infer a new type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conditionally add a property in a type-safe way, you can use object spread
    with `null` or `{}`, which add no properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you mouse over `president` in your editor, you’ll see that its type is inferred
    as a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This may come as a surprise if you wanted `middle` to be an optional field.
    You can’t read `middle` off this type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re conditionally adding multiple properties, the union does more accurately
    represent the set of possible values ([Item 32](ch04.html#union-of-interfaces)).
    But an optional field would be easier to work with. You can get one with a helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes you want to build an object or array by transforming another one.
    In this case the equivalent of “building objects all at once” is using built-in
    functional constructs or utility libraries like Lodash rather than loops. See
    [Item 27](#well-typed-libs) for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prefer to build objects all at once rather than piecemeal. Use object spread
    (`{...a, ...b}`) to add properties in a type-safe way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know how to conditionally add properties to an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 24: Be Consistent in Your Use of Aliases'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you introduce a new name for a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'you have created an *alias*. Changes to properties on the alias will be visible
    on the original value as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Aliases are the bane of compiler writers in all languages because they make
    control flow analysis difficult. If you’re deliberate in your use of aliases,
    TypeScript will be able to understand your code better and help you find more
    real errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a data structure that represents a polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The geometry of the polygon is specified by the `exterior` and `holes` properties.
    The `bbox` property is an optimization that may or may not be present. You can
    use it to speed up a point-in-polygon check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works (and type checks) but is a bit repetitive: `polygon.bbox` appears
    five times in three lines! Here’s an attempt to factor out an intermediate variable
    to reduce duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: (I’m assuming you’ve enabled `strictNullChecks`.)
  prefs: []
  type: TYPE_NORMAL
- en: This code still works, so why the error? By factoring out the `box` variable,
    you’ve created an alias for `polygon.bbox`, and this has thwarted the control
    flow analysis that quietly worked in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inspect the types of `box` and `polygon.bbox` to see what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The property check refines the type of `polygon.bbox` but not of `box` and
    hence the errors. This leads us to the golden rule of aliasing: *if you introduce
    an alias, use it* *consistently*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `box` in the property check fixes the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The type checker is happy now, but there’s an issue for human readers. We’re
    using two names for the same thing: `box` and `bbox`. This is a distinction without
    a difference ([Item 36](ch04.html#language-of-domain)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object destructuring syntax rewards consistent naming with a more compact syntax.
    You can even use it on arrays and nested structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A few other points:'
  prefs: []
  type: TYPE_NORMAL
- en: This code would have required more property checks if the `x` and `y` properties
    had been optional, rather than the whole `bbox` property. We benefited from following
    the advice of [Item 31](ch04.html#null-values-to-perimeter), which discusses the
    importance of pushing null values to the perimeter of your types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional property was appropriate for `bbox` but would not have been appropriate
    for `holes`. If `holes` was optional, then it would be possible for it to be either
    missing or an empty array (`[]`). This would be a distinction without a difference.
    An empty array is a fine way to indicate “no holes.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your interactions with the type checker, don’t forget that aliasing can
    introduce confusion at runtime, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript’s control flow analysis tends to be quite good for local variables.
    But for properties you should be on guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `fn(polygon)` could very well un-set `polygon.bbox`, so it would
    be safer for the type to revert to `BoundingBox | undefined`. But this would get
    frustrating: you’d have to repeat your property checks every time you called a
    function. So TypeScript makes the pragmatic choice to assume the function does
    not invalidate its type refinements. But it *could*. If you’d factored out a local
    `bbox` variable instead of using `polygon.bbox`, the type of `bbox` would remain
    accurate, but it might no longer be the same value as `polygon.box`.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aliasing can prevent TypeScript from narrowing types. If you create an alias
    for a variable, use it consistently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use destructuring syntax to encourage consistent naming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware of how function calls can invalidate type refinements on properties.
    Trust refinements on local variables more than on properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 25: Use async Functions Instead of Callbacks for Asynchronous Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classic JavaScript modeled asynchronous behavior using callbacks. This leads
    to the infamous “pyramid of doom”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the logs, the execution order is the opposite of the code
    order. This makes callback code hard to read. It gets even more confusing if you
    want to run the requests in parallel or bail when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES2015 introduced the concept of a Promise to break the pyramid of doom. A
    Promise represents something that will be available in the future (they’re also
    sometimes called “futures”). Here’s the same code using Promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now there’s less nesting, and the execution order more directly matches the
    code order. It’s also easier to consolidate error handling and use higher-order
    tools like `Promise.all`.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES2017 introduced the `async` and `await` keywords to make things even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `await` keyword pauses execution of the `fetchPages` function until each
    Promise resolves. Within an `async` function, `await`ing a Promise that throws
    an exception. This lets you use the usual try/catch machinery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: When you target ES5 or earlier, the TypeScript compiler will perform some elaborate
    transformations to make `async` and `await` work. In other words, whatever your
    runtime, with TypeScript you can use `async`/`await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few good reasons to prefer Promises or `async`/`await` to callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Promises are easier to compose than callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types are able to flow through Promises more easily than callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to fetch the pages in parallel, for example, you can compose Promises
    with `Promise.all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Using destructuring assignment with `await` is particularly nice in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is able to infer the types of each of the three `response` variables
    as `Response`. The equivalent code to do the requests in parallel with callbacks
    requires more machinery and a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Extending this to include error handling or to be as generic as `Promise.all`
    is challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type inference also works well with `Promise.race`, which resolves when the
    first of its input Promises resolves. You can use this to add timeouts to Promises
    in a general way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type of `fetchWithTimeout` is inferred as `Promise<Response>`, no
    type annotations required. It’s interesting to dig into why this works: the return
    type of `Promise.race` is the union of the types of its inputs, in this case `Promise<Response
    | never>`. But taking a union with `never` (the empty set) is a no-op, so this
    gets simplified to `Promise<Response>`. When you work with Promises, all of TypeScript’s
    type inference machinery works to get you the right types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some times when you need to use raw Promises, notably when you are
    wrapping a callback API like `setTimeout`. But if you have a choice, you should
    generally prefer `async`/`await` to raw Promises for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It typically produces more concise and straightforward code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enforces that `async` functions always return Promises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `async` function always returns a `Promise`, even if it doesn’t involve
    `await`ing anything. TypeScript can help you build an intuition for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create `async` arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw Promise equivalent is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'While it may seem odd to return a Promise for an immediately available value,
    this actually helps enforce an important rule: a function should either always
    be run synchronously or always be run asynchronously. It should never mix the
    two. For example, what if you want to add a cache to the `fetchURL` function?
    Here’s an attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'While this may seem like an optimization, the function is now extremely difficult
    for a client to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: What will the value of `requestStatus` be after calling `getUser`? It depends
    entirely on whether the profile is cached. If it’s not, `requestStatus` will be
    set to “success.” If it is, it’ll get set to “success” and then set back to “loading.”
    Oops!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `async` for both functions enforces consistent behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now it’s completely transparent that `requestStatus` will end in “success.”
    It’s easy to accidentally produce half-synchronous code with callbacks or raw
    Promises, but difficult with `async`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you return a Promise from an `async` function, it will not get
    wrapped in another Promise: the return type will be `Promise<T>` rather than `Promise<Promise<T>>`.
    Again, TypeScript will help you build an intuition for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prefer Promises to callbacks for better composability and type flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer `async` and `await` to raw Promises when possible. They produce more
    concise, straightforward code and eliminate whole classes of errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function returns a Promise, declare it `async`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 26: Understand How Context Is Used in Type Inference'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript doesn’t just infer types based on values. It also considers the context
    in which the value occurs. This usually works well but can sometimes lead to surprises.
    Understanding how context is used in type inference will help you identify and
    work around these surprises when they do occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript you can factor an expression out into a constant without changing
    the behavior of your code (so long as you don’t alter execution order). In other
    words, these two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, this refactor still works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose you take to heart the advice of [Item 33](ch04.html#avoid-strings)
    and replace the string type with a more precise union of string literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: What went wrong? With the inline form, TypeScript knows from the function declaration
    that the parameter is supposed to be of type `Language`. The string literal `'JavaScript'`
    is assignable to this type, so this is OK. But when you factor out a variable,
    TypeScript must infer its type at the time of assignment. In this case it infers
    `string`, which is not assignable to `Language`. Hence the error.
  prefs: []
  type: TYPE_NORMAL
- en: (Some languages are able to infer types for variables based on their eventual
    usage. But this can also be confusing. Anders Hejlsberg, the creator of TypeScript,
    refers to it as “spooky action at a distance.” By and large, TypeScript determines
    the type of a variable when it is first introduced. For a notable exception to
    this rule, see [Item 41](ch05.html#evolving-any).)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two good ways to solve this problem. One is to constrain the possible
    values of `language` with a type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This also has the benefit of flagging an error if there’s a typo in the language—for
    example `'Typescript'` (it should be a capital “S”).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other solution is to make the variable constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: By using `const`, we’ve told the type checker that this variable cannot change.
    So TypeScript can infer a more precise type for `language`, the string literal
    type `"JavaScript"`. This is assignable to `Language` so the code type checks.
    Of course, if you do need to reassign `language`, then you’ll need to use the
    type declaration. (For more on this, see [Item 21](#widening).)
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental issue here is that we’ve separated the value from the context
    in which it’s used. Sometimes this is OK, but often it is not. The rest of this
    item walks through a few cases where this loss of context can cause errors and
    shows you how to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to string literal types, problems can come up with tuple types.
    Suppose you’re working with a map visualization that lets you programmatically
    pan the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As before, you’ve separated a value from its context. In the first instance
    `[10, 20]` is assignable to the tuple type `[number, number]`. In the second,
    TypeScript infers the type of `loc` as `number[]` (i.e., an array of numbers of
    unknown length). This is not assignable to the tuple type, since many arrays have
    the wrong number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can you fix this error without resorting to `any`? You’ve already declared
    it `const`, so that won’t help. But you can still provide a type declaration to
    let TypeScript know precisely what you mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to provide a “const context.” This tells TypeScript that you
    intend the value to be deeply constant, rather than the shallow constant that
    `const` gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If you hover over `loc` in your editor, you’ll see that its type is now inferred
    as `readonly [10, 20]`, rather than `number[]`. Unfortunately this is *too* precise!
    The type signature of `panTo` makes no promises that it won’t modify the contents
    of its `where` parameter. Since the `loc` parameter has a `readonly` type, this
    won’t do. The best solution here is to add a `readonly` annotation to the `panTo`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If the type signature is outside your control, then you’ll need to use an annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '`const` contexts can neatly solve issues around losing context in inference,
    but they do have an unfortunate downside: if you make a mistake in the definition
    (say you add a third element to the tuple) then the error will be flagged at the
    call site, not at the definition. This may be confusing, especially if the error
    occurs in a deeply nested object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem of separating a value from its context also comes up when you factor
    out a constant from a larger object that contains some string literals or tuples.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ts` object, the type of `language` is inferred as `string`. As before,
    the solution is to add a type declaration (`const ts: GovernedLanguage = ...`)
    or use a const assertion (`as const`).'
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you pass a callback to another function, TypeScript uses context to infer
    the parameter types of the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The types of `a` and `b` are inferred as `number` because of the type declaration
    for `callWithRandom`. If you factor the callback out into a constant, you lose
    that context and get `noImplicitAny` errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is either to add type annotations to the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: or to apply a type declaration to the entire function expression if one is available.
    See [Item 12](ch02_split_001.html#type-entire-functions).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be aware of how context is used in type inference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If factoring out a variable introduces a type error, consider adding a type
    declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the variable is truly a constant, use a const assertion (`as const`). But
    be aware that this may result in errors surfacing at use, rather than definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 27: Use Functional Constructs and Libraries to Help Types Flow'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has never included the sort of standard library you find in Python,
    C, or Java. Over the years many libraries have tried to fill the gap. jQuery provided
    helpers not just for interacting with the DOM but also for iterating and mapping
    over objects and arrays. Underscore focused more on providing general utility
    functions, and Lodash built on this effort. Today libraries like Ramda continue
    to bring ideas from functional programming into the JavaScript world.
  prefs: []
  type: TYPE_NORMAL
- en: Some features from these libraries, such as `map`, `flatMap`, `filter`, and
    `reduce`, have made it into the JavaScript language itself. While these constructs
    (and the other ones provided by Lodash) are helpful in JavaScript and often preferable
    to a hand-rolled loop, this advantage tends to get even more lopsided when you
    add TypeScript to the mix. This is because their type declarations ensure that
    types flow through these constructs. With hand-rolled loops, you’re responsible
    for the types yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider parsing some CSV data. You could do it in plain JavaScript
    in a somewhat imperative style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'More functionally minded JavaScripters might prefer to build the row objects
    with `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This version saves three lines (almost 20 non-whitespace characters!) but may
    be more cryptic depending on your sensibilities. Lodash’s `zipObject` function,
    which forms an object by “zipping” up a keys and values array, can tighten it
    even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: I find this the clearest of all. But is it worth the cost of adding a dependency
    on a third-party library to your project? If you’re not using a bundler and the
    overhead of doing this is significant, then the answer may be “no.”
  prefs: []
  type: TYPE_NORMAL
- en: When you add TypeScript to the mix, it starts to tip the balance more strongly
    in favor of the Lodash solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both vanilla JS versions of the CSV parser produce the same error in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution in each case is to provide a type annotation for `{}`, either
    `{[column: string]: string}` or `Record<string, string>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lodash version, on the other hand, passes the type checker without modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '`Dictionary` is a Lodash type alias. `Dictionary<string>` is the same as `{[key:
    string]: string}` or `Record<string, string>`. The important thing here is that
    the type of `rows` is exactly correct, no type annotations needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These advantages get more pronounced as your data munging gets more elaborate.
    For example, suppose you have a list of the rosters for all the NBA teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a flat list using a loop, you might use `concat` with an array. This
    code runs fine but does not type check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix the error you need to add a type annotation to `allPlayers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'But a better solution is to use `Array.prototype.flat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The `flat` method flattens a multidimensional array. Its type signature is something
    like `T[][] => T[]`. This version is the most concise and requires no type annotations.
    As an added bonus you can use `const` instead of `let` to prevent future mutations
    to the `allPlayers` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to start with `allPlayers` and make a list of the highest-paid
    players on each team ordered by salary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a solution without Lodash. It requires a type annotation where you don’t
    use functional constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the equivalent with Lodash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to being half the length, this code is clearer and requires only
    a single non-null assertion (the type checker doesn’t know that the `players`
    array passed to `_.maxBy` is non-empty). It makes use of a “chain,” a concept
    in Lodash and Underscore that lets you write a sequence of operations in a more
    natural order. Instead of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'you write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The `_(v)` “wraps” the value, and the `.value()` “unwraps” it.
  prefs: []
  type: TYPE_NORMAL
- en: You can inspect each function call in the chain to see the type of the wrapped
    value. It’s always correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even some of the quirkier shorthands in Lodash can be modeled accurately in
    TypeScript. For instance, why would you want to use `_.map` instead of the built-in
    `Array.prototype.map`? One reason is that instead of passing in a callback you
    can pass in the name of a property. These calls all produce the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: It’s a testament to the sophistication of TypeScript’s type system that it can
    model a construct like this accurately, but it naturally falls out of the combination
    of string literal types and index types (see [Item 14](ch02_split_001.html#map-between-types)).
    If you’re used to C++ or Java, this sort of type inference can feel quite magical!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: It’s not a coincidence that types flow so well through built-in functional constructs
    and those in libraries like Lodash. By avoiding mutation and returning new values
    from every call, they are able to produce new types as well ([Item 20](#one-var-one-type)).
    And to a large extent, the development of TypeScript has been driven by an attempt
    to accurately model the behavior of JavaScript libraries in the wild. Take advantage
    of all this work and use them!
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use built-in functional constructs and those in utility libraries like Lodash
    instead of hand-rolled constructs to improve type flow, increase legibility, and
    reduce the need for explicit type annotations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
