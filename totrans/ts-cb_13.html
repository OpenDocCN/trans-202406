<html><head></head><body><section data-pdf-bookmark="Chapter 12. Type Development Strategies" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch12">&#13;
<h1><span class="label">Chapter 12. </span>Type Development Strategies</h1>&#13;
&#13;
&#13;
<p><a data-primary="type development strategies" data-secondary="overview" data-type="indexterm" id="id966"/>All recipes up until now have dealt with specific aspects of the TypeScript programming language and its type system. You have learned about effectively using basic types in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#ch02">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a>, making your code more reusable through generics in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, and crafting advanced types for very delicate situations using conditional types in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>,  string template literal types in <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>, and variadic tuple types in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>.</p>&#13;
&#13;
<p>We established a collection of helper types in <a data-type="xref" href="ch08.html#ch08">Chapter 8</a> and worked around standard library limitations in <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>. We learned how to work with JSX as a language extension in <a data-type="xref" href="ch10.html#ch10">Chapter 10</a> and how and when to use classes in <a data-type="xref" href="ch11.html#ch11">Chapter 11</a>. Every recipe discussed in detail the pros and cons of each approach, giving you better tools to decide correctly for every situation, creating better types, more robust programs, and a stable development flow.</p>&#13;
&#13;
<p>That’s a lot! One thing is still missing, though, the final piece that brings everything together: how do we approach new type challenges? Where do we start? What do we need to look out for?</p>&#13;
&#13;
<p>The answers to these questions make up the contents of this chapter. Here you will learn about the concept of <em>low maintenance types</em>. We will explore a process on how you can start with simple types first and gradually get more refined and stronger. You will learn about the secret features of the <a href="https://www.typescriptlang.org/play">TypeScript playground</a> and how to deal with libraries that make validation easier. You will find guides to help you make hard decisions and learn about workarounds to the most common yet tough-to-beat type errors that will definitely hit you in your TypeScript journey.</p>&#13;
&#13;
<p>If the rest of the book brought you from novice to apprentice, the next recipes will lead you to become an expert. Welcome to the last chapter.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.1 Writing Low Maintenance Types" data-type="sect1"><div class="sect1" id="ch12_low_maintenance_types">&#13;
<h1>12.1 Writing Low Maintenance Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id234">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="low maintenance types" data-secondary="working with" data-type="indexterm" id="ix_12-01-asciidoc0"/><a data-primary="type development strategies" data-secondary="low maintenance types" data-type="indexterm" id="ix_12-01-asciidoc1"/>Every time your model changes, you need to touch a dozen types throughout your codebase. That is tedious, and it’s also easy to miss something.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id967">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Derive types from others, infer from usage, and create low maintenance types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id968">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Throughout this book, we have spent a lot of time creating types from other types. The moment we can derive a type from something that already exists means we spend less time writing and adapting type information and more time fixing bugs and errors in JavaScript.</p>&#13;
&#13;
<p>TypeScript is a layer of metainformation on top of JavaScript. Our goal is still to write JavaScript but make it as robust and easy as possible: tooling helps you stay productive and doesn’t get in your way.</p>&#13;
&#13;
<p>That’s how I write TypeScript in general: I write regular JavaScript, and where TypeScript needs extra information, I happily add some extra annotations. One condition: I don’t want to be bothered maintaining types. I’d rather create types that can update themselves if their dependencies or surroundings change. I call this approach <em>creating low maintenance types</em>.</p>&#13;
&#13;
<p>Creating low maintenance types is a three-part process:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Model your data or infer from existing models.</p>&#13;
</li>&#13;
<li>&#13;
<p>Define derivates (mapped types, partials, etc.).</p>&#13;
</li>&#13;
<li>&#13;
<p>Define behavior with conditional types.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let’s take a look at this brief and incomplete <code>copy</code> function. I want to copy files from one directory to another. To make my life easier, I created a set of default options so I don’t have to repeat myself too much:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">defaultOptions</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">:</code> <code class="s2">"./src"</code><code class="p">,</code>&#13;
  <code class="nx">to</code><code class="o">:</code> <code class="s2">"./dest"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">options</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Let's merge default options and options</code>&#13;
  <code class="kr">const</code> <code class="nx">allOptions</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">defaultOptions</code><code class="p">,</code> <code class="p">...</code><code class="nx">options</code><code class="p">};</code>&#13;
&#13;
  <code class="c1">// todo: Implementation of the rest</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That’s a pattern you might see a lot in JavaScript. What you see immediately is that TypeScript misses <em>some</em> type information. Especially the <code>options</code> argument of the <code>copy</code> function is <code>any</code> at the moment. So let’s add a type for that!</p>&#13;
&#13;
<p>I could create types explicitly:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">to</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">defaultOptions</code><code class="o">:</code> <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">:</code> <code class="s2">"./src"</code><code class="p">,</code>&#13;
  <code class="nx">to</code><code class="o">:</code> <code class="s2">"./dest"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">PartialOptions</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">to</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">options</code><code class="o">:</code> <code class="nx">PartialOptions</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Let's merge default options and options</code>&#13;
  <code class="kr">const</code> <code class="nx">allOptions</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">defaultOptions</code><code class="p">,</code> <code class="p">...</code><code class="nx">options</code><code class="p">};</code>&#13;
&#13;
  <code class="c1">// todo: Implementation of the rest</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That’s a reasonable approach. You think about types, then you assign types, and then you get all the editor feedback and type-checking you are used to. But what if something changes? Let’s assume we add another field to <code>Options</code>; we would have to adapt our code three times:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">to</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">overwrite</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code> <code class="c1">// added</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">defaultOptions</code><code class="o">:</code> <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">:</code> <code class="s2">"./src"</code><code class="p">,</code>&#13;
  <code class="nx">to</code><code class="o">:</code> <code class="s2">"./dest"</code><code class="p">,</code>&#13;
  <code class="nx">overwrite</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code> <code class="c1">// added</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">PartialOptions</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">to</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">overwrite</code><code class="o">?:</code> <code class="kr">boolean</code><code class="p">;</code> <code class="c1">// added</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>But why? The information is already there! In <code>defaultOptions</code>, we tell TypeScript exactly what we’re looking for. Let’s optimize:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Drop the <code>PartialOptions</code> type and use the utility type <code>Partial&lt;T&gt;</code> to get the same effect. You might have guessed this one already.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use the <code>typeof</code> operator in TypeScript to create a new type on the fly:</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">defaultOptions</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">from</code><code class="o">:</code> <code class="s2">"./src"</code><code class="p">,</code>&#13;
  <code class="nx">to</code><code class="o">:</code> <code class="s2">"./dest"</code><code class="p">,</code>&#13;
  <code class="nx">overwrite</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">options</code><code class="o">:</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">defaultOptions</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Let's merge default options and options</code>&#13;
  <code class="kr">const</code> <code class="nx">allOptions</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">defaultOptions</code><code class="p">,</code> <code class="p">...</code><code class="nx">options</code><code class="p">};</code>&#13;
&#13;
  <code class="c1">// todo: Implementation of the rest</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There you go. Just annotate where we need to tell TypeScript what we’re looking for:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If we add new fields, we don’t have to maintain anything at all.</p>&#13;
</li>&#13;
<li>&#13;
<p>If we rename a field, we get <em>just</em> the information we care about: all uses of <code>copy</code> where we have to change the options we pass to the function.</p>&#13;
</li>&#13;
<li>&#13;
<p>We have one single source of truth: the actual <code>defaultOptions</code> object. This is the object that counts because it’s the only information we have at runtime.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>And our code becomes a little bit more concise. TypeScript becomes less intrusive and more aligned to how we write JavaScript.</p>&#13;
&#13;
<p>Another example is one that has accompanied us from the beginning: the toy shop that started in <a data-type="xref" href="ch03.html#ch03_item_modelling_data">Recipe 3.1</a>, and has continued in Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04_new_object_types">4.5</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.html#ch05_grouping_elements">5.3</a>. Revisit all three items and think about how we can change only the model to get all other types &#13;
<span class="keep-together">updated.</span></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.2 Refining Types Step by Step" data-type="sect1"><div class="sect1" id="ch12_refining_types">&#13;
<h1>12.2 Refining Types Step by Step</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id182">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="refining types" data-type="indexterm" id="ix_12-02-asciidoc0"/><a data-primary="type development strategies" data-secondary="refining types step by step" data-type="indexterm" id="ix_12-02-asciidoc1"/>Your API needs elaborate types, using advanced features like generics, conditional types, and string template literal types. You don’t know where to start.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id969">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Refine your types step by step. Start with basic primitive and object types, subset, add generics, and then go all-in advanced. The process described in this lesson will help you craft types. It’s also a good way to recap everything you’ve learned.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id970">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Take a look at the following example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api/users/:userID"</code><code class="p">,</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">method</code> <code class="o">===</code> <code class="s2">"POST"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">20</code><code class="p">).</code><code class="nx">send</code><code class="p">({</code>&#13;
      <code class="nx">message</code><code class="o">:</code> <code class="s2">"Got you, user "</code> <code class="o">+</code> <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">userId</code><code class="p">,</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We have an <a href="https://expressjs.com">Express-style server</a> that allows us to define a route (or path) and executes a callback if the URL is requested.</p>&#13;
&#13;
<p>The callback takes two arguments:</p>&#13;
<dl>&#13;
<dt>The request object</dt>&#13;
<dd>&#13;
<p>Here we get information on the <a href="https://oreil.ly/zcoUS">HTTP method used</a>—for example, <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>—and additional parameters that come in. In this example <code>userID</code> should be mapped to a parameter <code>userID</code> that, well, contains the user’s identifier!</p>&#13;
</dd>&#13;
<dt>The response or reply object</dt>&#13;
<dd>&#13;
<p>Here we want to prepare a proper response from the server to the client. We want to send correct status codes (method <code>status</code>) and send JSON output over the wire.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>What we see in this example is heavily simplified, but it gives a good idea of what we are up to. The previous example is also riddled with errors! Take a look:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api/users/:userID"</code><code class="p">,</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">method</code> <code class="o">===</code> <code class="s2">"POST"</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* Error 1 */</code>&#13;
    <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">20</code><code class="p">).</code><code class="nx">send</code><code class="p">({</code> <code class="cm">/* Error 2 */</code>&#13;
      <code class="nx">message</code><code class="o">:</code> <code class="s2">"Welcome, user "</code> <code class="o">+</code> <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">userId</code> <code class="cm">/* Error 3 */</code><code class="p">,</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p class="pagebreak-before">Three lines of implementation code and three errors? What happened?</p>&#13;
<ol>&#13;
<li>&#13;
<p>The first error is nuanced. While we tell our app that we want to listen to <code>GET</code> requests (hence <code>app.get</code>), we do something only if the request method is <code>POST</code>. At this particular point in our application, <code>req.method</code> can’t be <code>POST</code>. So we would never send any response, which might lead to unexpected timeouts.</p>&#13;
</li>&#13;
<li>&#13;
<p>It’s great that we explicitly send a status code! <code>20</code> isn’t a valid status code, though. Clients might not understand what’s happening here.</p>&#13;
</li>&#13;
<li>&#13;
<p>This is the response we want to send back. We access the parsed arguments but have a typo. It’s <code>userID</code>, not <code>userId</code>. All our users would be greeted with “Welcome, user undefined!” Something you definitely have seen in the wild!</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Solving issues like this is TypeScript’s main purpose. TypeScript wants to understand your JavaScript code better than you do. And where TypeScript can’t figure out what you mean, you can assist by providing extra type information. The problem is that it’s often hard to start adding types. You might have the most puzzling edge cases in your mind but don’t know how to get to them.</p>&#13;
&#13;
<p>I want to propose a process that may help you get started and also shows you where there’s a good place to stop. You can increase the strengths of your types step by step. It gets better with each refinement, and you can increase type safety over a longer period of time. Let’s start!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 1: Basic typing" data-type="sect3"><div class="sect3" id="id183">&#13;
<h3>Step 1: Basic typing</h3>&#13;
&#13;
<p><a data-primary="refining types" data-secondary="basic typing" data-type="indexterm" id="ix_12-02-asciidoc2"/>We start with some basic type information. We have an <code>app</code> object that points to a <code>get</code> function. The <code>get</code> function takes a <code>path</code>, which is a string, and a callback:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">get</code> <code class="cm">/* post, put, delete, ... to come! */</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">get</code><code class="p">(</code><code class="nx">path</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented --&gt; not important right now</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>CallbackFn</code> is a function type that returns <code>void</code> and takes two arguments:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>req</code>, which is of type <code>ServerRequest</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>reply</code>, which is of type <code>ServerReply</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CallbackFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">req</code><code class="o">:</code> <code class="nx">ServerRequest</code><code class="p">,</code> <code class="nx">reply</code><code class="o">:</code> <code class="nx">ServerReply</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>ServerRequest</code> is a pretty complex object in most frameworks. We do a simplified version for demonstration purposes. We pass in a <code>method</code> string, for <code>"GET"</code>, <code>"POST"</code>, <code>"PUT"</code>, <code>"DELETE"</code>, and so on. It also has a <code>params</code> record. Records are objects that &#13;
<span class="keep-together">associate</span> a set of keys with a set of properties. For now, we want to allow every <code>string</code> key to be mapped to a <code>string</code> property. We’ll refactor this one later:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ServerRequest</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">method</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>For <code>ServerReply</code>, we lay out some functions, knowing that a real <code>ServerReply</code> object has many more. A <code>send</code> function takes an optional argument <code>obj</code> with the data we want to send. We have the possibility to set a status code with the <code>status</code> function using a fluent interface:<sup><a data-type="noteref" href="ch12.html#id971" id="id971-marker">1</a></sup></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ServerReply</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">send</code><code class="o">:</code> <code class="p">(</code><code class="nx">obj</code><code class="o">?:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">status</code><code class="o">:</code> <code class="p">(</code><code class="nx">statusCode</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ServerReply</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>With some very basic compound types and a simple primitive type for paths, we already added a lot of type safety to our project. We can rule out a couple of errors:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api/users/:userID"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">method</code> <code class="o">===</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>&#13;
<code class="c1">//   ^ This condition will always return 'false' since the types</code>&#13;
<code class="c1">//     'string' and 'number' have no overlap.(2367)</code>&#13;
&#13;
    <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="s2">"200"</code><code class="p">).</code><code class="nx">send</code><code class="p">()</code>&#13;
<code class="c1">//             ^</code>&#13;
<code class="c1">// Argument of type 'string' is not assignable to</code>&#13;
<code class="c1">// parameter of type 'number'.(2345)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>That’s great, but there’s still a lot to do. We can still send wrong status codes (any number is possible) and have no clue about the possible HTTP methods (any string is possible). So let’s refine our types.<a data-startref="ix_12-02-asciidoc2" data-type="indexterm" id="id972"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 2: Subset primitive types" data-type="sect3"><div class="sect3" id="id184">&#13;
<h3>Step 2: Subset primitive types</h3>&#13;
&#13;
<p><a data-primary="primitive types" data-type="indexterm" id="ix_12-02-asciidoc3"/><a data-primary="refining types" data-secondary="subsetting primitive types" data-type="indexterm" id="ix_12-02-asciidoc4"/>You can see primitive types as a set of all possible values of that certain category. For example, <code>string</code> includes all possible strings that can be expressed in JavaScript, &#13;
<span class="keep-together"><code>number</code></span> includes all possible numbers with double float precision, and <code>boolean</code> includes all possible Boolean values, which are <code>true</code> and <code>false</code>.</p>&#13;
&#13;
<p>TypeScript allows you to refine those sets to smaller subsets. For example, we can create a type <code>Methods</code> that includes all possible strings we can receive for &#13;
<span class="keep-together">HTTP methods:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Methods</code> <code class="o">=</code> <code class="s2">"GET"</code> <code class="o">|</code> <code class="s2">"POST"</code> <code class="o">|</code> <code class="s2">"PUT"</code> <code class="o">|</code> <code class="s2">"DELETE"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ServerRequest</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">method</code><code class="o">:</code> <code class="nx">Methods</code><code class="p">;</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p><code>Methods</code> is a smaller set of the bigger <code>string</code> set. <code>Methods</code> is also a union type of literal types, the smallest unit of a given set. A literal string. A literal number. There is no ambiguity: it’s just <code>"GET"</code>. You put them in a union with other literal types, creating a subset of whatever bigger types you have. You can also do a subset with literal types of both <code>string</code> and <code>number</code>, or different compound object types. There are lots of possibilities to combine and put literal types into unions.</p>&#13;
&#13;
<p>This has an immediate effect on our server callback. Suddenly, we can differentiate between those four methods (or more if necessary) and can exhaust all possibilities in code. TypeScript will guide us.</p>&#13;
&#13;
<p>That’s one less category of errors. We now know exactly which possible HTTP methods are available. We can do the same for HTTP status codes, by defining a subset of valid numbers that <code>statusCode</code> can take:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">StatusCode</code> <code class="o">=</code>&#13;
  <code class="mi">100</code> <code class="o">|</code> <code class="mi">101</code> <code class="o">|</code> <code class="mi">102</code> <code class="o">|</code> <code class="mi">200</code> <code class="o">|</code> <code class="mi">201</code> <code class="o">|</code> <code class="mi">202</code> <code class="o">|</code> <code class="mi">203</code> <code class="o">|</code> <code class="mi">204</code> <code class="o">|</code> <code class="mi">205</code> <code class="o">|</code>&#13;
  <code class="mi">206</code> <code class="o">|</code> <code class="mi">207</code> <code class="o">|</code> <code class="mi">208</code> <code class="o">|</code> <code class="mi">226</code> <code class="o">|</code> <code class="mi">300</code> <code class="o">|</code> <code class="mi">301</code> <code class="o">|</code> <code class="mi">302</code> <code class="o">|</code> <code class="mi">303</code> <code class="o">|</code> <code class="mi">304</code> <code class="o">|</code>&#13;
  <code class="mi">305</code> <code class="o">|</code> <code class="mi">306</code> <code class="o">|</code> <code class="mi">307</code> <code class="o">|</code> <code class="mi">308</code> <code class="o">|</code> <code class="mi">400</code> <code class="o">|</code> <code class="mi">401</code> <code class="o">|</code> <code class="mi">402</code> <code class="o">|</code> <code class="mi">403</code> <code class="o">|</code> <code class="mi">404</code> <code class="o">|</code>&#13;
  <code class="mi">405</code> <code class="o">|</code> <code class="mi">406</code> <code class="o">|</code> <code class="mi">407</code> <code class="o">|</code> <code class="mi">408</code> <code class="o">|</code> <code class="mi">409</code> <code class="o">|</code> <code class="mi">410</code> <code class="o">|</code> <code class="mi">411</code> <code class="o">|</code> <code class="mi">412</code> <code class="o">|</code> <code class="mi">413</code> <code class="o">|</code>&#13;
  <code class="mi">414</code> <code class="o">|</code> <code class="mi">415</code> <code class="o">|</code> <code class="mi">416</code> <code class="o">|</code> <code class="mi">417</code> <code class="o">|</code> <code class="mi">418</code> <code class="o">|</code> <code class="mi">420</code> <code class="o">|</code> <code class="mi">422</code> <code class="o">|</code> <code class="mi">423</code> <code class="o">|</code> <code class="mi">424</code> <code class="o">|</code>&#13;
  <code class="mi">425</code> <code class="o">|</code> <code class="mi">426</code> <code class="o">|</code> <code class="mi">428</code> <code class="o">|</code> <code class="mi">429</code> <code class="o">|</code> <code class="mi">431</code> <code class="o">|</code> <code class="mi">444</code> <code class="o">|</code> <code class="mi">449</code> <code class="o">|</code> <code class="mi">450</code> <code class="o">|</code> <code class="mi">451</code> <code class="o">|</code>&#13;
  <code class="mi">499</code> <code class="o">|</code> <code class="mi">500</code> <code class="o">|</code> <code class="mi">501</code> <code class="o">|</code> <code class="mi">502</code> <code class="o">|</code> <code class="mi">503</code> <code class="o">|</code> <code class="mi">504</code> <code class="o">|</code> <code class="mi">505</code> <code class="o">|</code> <code class="mi">506</code> <code class="o">|</code> <code class="mi">507</code> <code class="o">|</code>&#13;
  <code class="mi">508</code> <code class="o">|</code> <code class="mi">509</code> <code class="o">|</code> <code class="mi">510</code> <code class="o">|</code> <code class="mi">511</code> <code class="o">|</code> <code class="mi">598</code> <code class="o">|</code> <code class="mi">599</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ServerReply</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">send</code><code class="o">:</code> <code class="p">(</code><code class="nx">obj</code><code class="o">?:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">status</code><code class="o">:</code> <code class="p">(</code><code class="nx">statusCode</code><code class="o">:</code> <code class="nx">StatusCode</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ServerReply</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Type <code>StatusCode</code> is again a union type. And with that, we exclude another category of errors. Suddenly, code like that fails:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api/user/:userID"</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
 <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">method</code> <code class="o">===</code> <code class="s2">"POS"</code><code class="p">)</code> <code class="p">{</code>&#13;
<code class="c1">//   ^ This condition will always return 'false' since</code>&#13;
<code class="c1">//     the types 'Methods' and '"POS"' have no overlap.(2367)</code>&#13;
    <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code>&#13;
<code class="c1">//             ^</code>&#13;
<code class="c1">//  Argument of type '20' is not assignable to parameter of</code>&#13;
<code class="c1">//  type 'StatusCode'.(2345)</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>And our software becomes a lot safer. But we can do more!<a data-startref="ix_12-02-asciidoc4" data-type="indexterm" id="id973"/><a data-startref="ix_12-02-asciidoc3" data-type="indexterm" id="id974"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 3: Adding generics" data-type="sect3"><div class="sect3" id="id185">&#13;
<h3>Step 3: Adding generics</h3>&#13;
&#13;
<p><a data-primary="generics" data-secondary="refining types with" data-type="indexterm" id="ix_12-02-asciidoc5"/><a data-primary="refining types" data-secondary="adding generics" data-type="indexterm" id="ix_12-02-asciidoc6"/>When we define a route with <code>app.get</code>, we implicitly know that the only HTTP method possible is <code>"GET"</code>. But with our type definitions, we still have to check for all possible parts of the union.</p>&#13;
&#13;
<p>The type for <code>CallbackFn</code> is correct, as we could define callback functions for all possible HTTP methods, but if we explicitly call <code>app.get</code>, it would be nice to save some extra steps, which are only necessary to comply with typings.</p>&#13;
&#13;
<p>TypeScript generics can help. We want to define <code>ServerRequest</code> in a way that we can specify a part of <code>Methods</code> instead of the entire set. For that, we use the generic syntax where we can define parameters as we would do with functions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ServerRequest</code><code class="o">&lt;</code><code class="nx">Met</code> <code class="kr">extends</code> <code class="nx">Methods</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">method</code><code class="o">:</code> <code class="nx">Met</code><code class="p">;</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Here is what happens:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>ServerRequest</code> becomes a generic type, as indicated by the angle brackets.</p>&#13;
</li>&#13;
<li>&#13;
<p>We define a generic parameter called <code>Met</code>, which is a subset of type <code>Methods</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>We use this generic parameter as a generic variable to define the method.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With that change, we can specify different <code>ServerRequest</code> variants without &#13;
<span class="keep-together">duplicating:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">OnlyGET</code> <code class="o">=</code> <code class="nx">ServerRequest</code><code class="o">&lt;</code><code class="s2">"GET"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">OnlyPOST</code> <code class="o">=</code> <code class="nx">ServerRequest</code><code class="o">&lt;</code><code class="s2">"POST"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">POSTorPUT</code> <code class="o">=</code> <code class="nx">ServerRquest</code><code class="o">&lt;</code><code class="s2">"POST"</code> <code class="o">|</code> <code class="s2">"PUT"</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Since we changed the interface of <code>ServerRequest</code>, we have to change all our other types that use <code>ServerRequest</code>, like <code>CallbackFn</code> and the <code>get</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="nx">Met</code> <code class="kr">extends</code> <code class="nx">Methods</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="nx">req</code><code class="o">:</code> <code class="nx">ServerRequest</code><code class="o">&lt;</code><code class="nx">Met</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">reply</code><code class="o">:</code> <code class="nx">ServerReply</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">get</code><code class="p">(</code><code class="nx">path</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="s2">"GET"</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With the <code>get</code> function, we pass an actual argument to our generic type. We know that this won’t be just a subset of <code>Methods</code>; we know exactly which subset we are &#13;
<span class="keep-together">dealing with.</span></p>&#13;
&#13;
<p>Now, when we use <code>app.get</code>, we only have one possible value for <code>req.method</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api/users/:userID"</code><code class="p">,</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">req</code><code class="p">.</code><code class="nx">method</code><code class="p">;</code> <code class="c1">// can only be GET</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>This ensures we don’t assume HTTP methods like <code>"POST"</code> or similar are available when we create an <code>app.get</code> callback. We know exactly what we are dealing with at this point, so let’s reflect that in our types.</p>&#13;
&#13;
<p>We already did a lot to make sure that <code>request.method</code> is reasonably typed and represents the actual state of affairs. One nice benefit of subsetting the <code>Methods</code> union type is that we can create a general-purpose callback function <em>outside</em> of <code>app.get</code> that is type safe:<a data-startref="ix_12-02-asciidoc6" data-type="indexterm" id="id975"/><a data-startref="ix_12-02-asciidoc5" data-type="indexterm" id="id976"/></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">handler</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="s2">"PUT"</code> <code class="o">|</code> <code class="s2">"POST"</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">res</code><code class="p">,</code> <code class="nx">req</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">res</code><code class="p">.</code><code class="nx">method</code> <code class="c1">// can be "POST" or "PUT"</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">handlerForAllMethods</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="nx">Methods</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">res</code><code class="p">,</code> <code class="nx">req</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">res</code><code class="p">.</code><code class="nx">method</code> <code class="c1">// can be all methods</code>&#13;
<code class="p">};</code>&#13;
&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api"</code><code class="p">,</code> <code class="nx">handler</code><code class="p">);</code>&#13;
<code class="c1">//              ^</code>&#13;
<code class="c1">// Argument of type 'CallbackFn&lt;"POST" | "PUT"&gt;' is not</code>&#13;
<code class="c1">// assignable to parameter of type 'CallbackFn&lt;"GET"&gt;'.</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api"</code><code class="p">,</code> <code class="nx">handlerForAllMethods</code><code class="p">);</code> <code class="c1">// This works</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 4: Advanced types to type-check" data-type="sect3"><div class="sect3" id="id977">&#13;
<h3>Step 4: Advanced types to type-check</h3>&#13;
&#13;
<p>What we haven’t touched yet is typing the <code>params</code> object. So far, we get a record that allows accessing every <code>string</code> key. It’s our task now to make that a little more specific!</p>&#13;
&#13;
<p>We do so by adding another generic variable, one for methods and one for the possible keys in our <code>Record</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ServerRequest</code><code class="o">&lt;</code><code class="nx">Met</code> <code class="kr">extends</code> <code class="nx">Methods</code><code class="p">,</code> <code class="nx">Par</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">=</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">method</code><code class="o">:</code> <code class="nx">Met</code><code class="p">;</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">Par</code><code class="p">,</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The generic type variable <code>Par</code> can be a subset of type <code>string</code>, and the default value is every string. With that, we can tell <code>ServerRequest</code> which keys we expect:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// request.method = "GET"</code>&#13;
<code class="c1">// request.params = {</code>&#13;
<code class="c1">//   userID: string</code>&#13;
<code class="c1">// }</code>&#13;
<code class="kr">type</code> <code class="nx">WithUserID</code> <code class="o">=</code> <code class="nx">ServerRequest</code><code class="o">&lt;</code><code class="s2">"GET"</code><code class="p">,</code> <code class="s2">"userID"</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Let’s add the new argument to our <code>get</code> function and the <code>CallbackFn</code> type, so we can set the requested parameters:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">Par</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">=</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">path</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="s2">"GET"</code><code class="p">,</code> <code class="nx">Par</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">get</code> <code class="cm">/* post, put, delete, ... to come! */</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="nx">Met</code> <code class="kr">extends</code> <code class="nx">Methods</code><code class="p">,</code> <code class="nx">Par</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="nx">req</code><code class="o">:</code> <code class="nx">ServerRequest</code><code class="o">&lt;</code><code class="nx">Met</code><code class="p">,</code> <code class="nx">Par</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">reply</code><code class="o">:</code> <code class="nx">ServerReply</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p>If we don’t set <code>Par</code> explicitly, the type works like we are accustomed to, since <code>Par</code> defaults to <code>string</code>. If we set it, though, we suddenly have a proper definition for the <code>req.params</code> object:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="o">&lt;</code><code class="s2">"userID"</code><code class="o">&gt;</code><code class="p">(</code><code class="s2">"/api/users/:userID"</code><code class="p">,</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">userID</code><code class="p">;</code> <code class="c1">// Works!!</code>&#13;
  <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">anythingElse</code><code class="p">;</code> <code class="c1">// doesn't work!!</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>That’s great! One little thing can be improved, though. We still can pass <em>every</em> string to the <code>path</code> argument of <code>app.get</code>. Wouldn’t it be better if we could reflect <code>Par</code> in there as well? We can! This is where <em>string template literal types</em> (see <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>) come into play.</p>&#13;
&#13;
<p>Let’s create a type called <code>IncludesRouteParams</code> to make sure that <code>Par</code> is properly included in the Express-style way of adding a colon in front of the parameter name:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">IncludesRouteParams</code><code class="o">&lt;</code><code class="nx">Par</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="nx">Par</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">|</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="nx">Par</code><code class="si">}</code><code class="sb">/</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code></pre>&#13;
&#13;
<p>The generic type <code>IncludesRouteParams</code> takes one argument, which is a subset of <code>string</code>. It creates a union type of two template literals:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The first template literal starts with <em>any</em> <code>string</code>, then includes a <code>/</code> character followed by a <code>:</code> character, followed by the parameter name. This ensures that we catch all cases where the parameter is at the end of the route string.</p>&#13;
</li>&#13;
<li>&#13;
<p>The second template literal starts with <em>any</em> <code>string</code>, followed by the same pattern of <code>/</code>, <code>:</code>, and the parameter name. Then we have another <code>/</code> character, followed by <em>any</em> string. This branch of the union type makes sure we catch all cases where the parameter is somewhere within a route.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This is how <code>IncludesRouteParams</code> with the parameter name <code>userID</code> behaves with different test cases:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">IncludesRouteParams</code><code class="o">&lt;</code><code class="s2">"userID"</code><code class="o">&gt;</code> <code class="o">=</code> <code class="s2">"/api/user/:userID"</code><code class="p">;</code> <code class="c1">// works</code>&#13;
<code class="kr">const</code> <code class="nx">b</code><code class="o">:</code> <code class="nx">IncludesRouteParams</code><code class="o">&lt;</code><code class="s2">"userID"</code><code class="o">&gt;</code> <code class="o">=</code> <code class="s2">"/api/user/:userID/orders"</code><code class="p">;</code> <code class="c1">// works</code>&#13;
<code class="kr">const</code> <code class="nx">c</code><code class="o">:</code> <code class="nx">IncludesRouteParams</code><code class="o">&lt;</code><code class="s2">"userID"</code><code class="o">&gt;</code> <code class="o">=</code> <code class="s2">"/api/user/:userId"</code><code class="p">;</code> <code class="c1">// breaks</code>&#13;
<code class="kr">const</code> <code class="nx">d</code><code class="o">:</code> <code class="nx">IncludesRouteParams</code><code class="o">&lt;</code><code class="s2">"userID"</code><code class="o">&gt;</code> <code class="o">=</code> <code class="s2">"/api/user"</code><code class="p">;</code> <code class="c1">// breaks</code>&#13;
<code class="kr">const</code> <code class="nx">e</code><code class="o">:</code> <code class="nx">IncludesRouteParams</code><code class="o">&lt;</code><code class="s2">"userID"</code><code class="o">&gt;</code> <code class="o">=</code> <code class="s2">"/api/user/:userIDAndmore"</code><code class="p">;</code> <code class="c1">// breaks</code></pre>&#13;
&#13;
<p>Let’s include our new utility type in the <code>get</code> function declaration:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">Par</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">=</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">path</code><code class="o">:</code> <code class="nx">IncludesRouteParams</code><code class="o">&lt;</code><code class="nx">Par</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="s2">"GET"</code><code class="p">,</code> <code class="nx">Par</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="o">&lt;</code><code class="s2">"userID"</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="s2">"/api/users/:userID"</code><code class="p">,</code>&#13;
  <code class="kd">function</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">userID</code><code class="p">;</code> <code class="c1">// Yes!</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Great! We get another safety mechanism to ensure that we don’t miss out on adding the parameters to the actual route. That’s powerful.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 5: Locking literal types" data-type="sect3"><div class="sect3" id="id235">&#13;
<h3>Step 5: Locking literal types</h3>&#13;
&#13;
<p><a data-primary="literal types" data-secondary="refining types by locking" data-type="indexterm" id="id978"/><a data-primary="refining types" data-secondary="locking literal types" data-type="indexterm" id="id979"/>But guess what: I’m still not happy with it. A few issues with that approach become apparent the moment your routes get a little more complex:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The first issue is that we need to explicitly state our parameters in the generic type parameter. We have to bind <code>Par</code> to <code>"userID"</code>, even though we would specify it anyway in the <code>path</code> argument of the function. This is not JavaScript-y!</p>&#13;
</li>&#13;
<li>&#13;
<p>This approach handles only one route parameter. The moment we add a union—for example, <code>"userID" | "orderId"</code>—the fail-safe check is satisfied with only <em>one</em> of those arguments being available. That’s how sets work. It can be one or the other.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There must be a better way. And there is. Otherwise, this recipe would end on a very bitter note.</p>&#13;
&#13;
<p>Let’s inverse the order! Instead of defining the route params in a generic type variable, we extract the variables from the <code>path</code> passed as the first argument of <code>app.get</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">Path</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">=</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">path</code><code class="o">:</code> <code class="nx">Path</code><code class="p">,</code>&#13;
  <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="o">&lt;</code><code class="s2">"GET"</code><code class="p">,</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="nx">Path</code><code class="o">&gt;&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We remove the <code>Par</code> generic type and add <code>Path</code>, which can be a subset of any <code>string</code>. When we set <code>path</code> to this generic type <code>Path</code>, the moment we pass a parameter to <code>get</code>, we catch its string literal type. We pass <code>Path</code> to a new generic type <code>ParseRouteParams</code> that we haven’t created yet.</p>&#13;
&#13;
<p>Let’s work on <code>ParseRouteParams</code>. Here, we switch the order of events again. Instead of passing the requested route params to the generic to make sure the path is all right, we pass the route path and extract the possible route params. For that, we need to create a conditional type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 6: Adding conditional types" data-type="sect3"><div class="sect3" id="id186">&#13;
<h3>Step 6: Adding conditional types</h3>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="refining types by adding" data-type="indexterm" id="ix_12-02-asciidoc7"/><a data-primary="literal types" data-secondary="adding conditional types" data-type="indexterm" id="ix_12-02-asciidoc8"/>Conditional types are syntactically similar to the ternary operator in JavaScript. You check for a condition, and if the condition is met, you return branch A; otherwise, you return branch B. For example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="nx">Route</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">Route</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">P</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">P</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Here, we check if <code>Route</code> is a subset of every path that ends with the parameter at the end Express-style (with a preceding <code>"/:"</code>). If so, we infer this string, which means we capture its contents into a new variable. If the condition is met, we return the newly extracted string; otherwise, we return <code>never</code>, as in: “there are no route parameters.”</p>&#13;
&#13;
<p>If we try it, we get something like:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Params</code> <code class="o">=</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="s2">"/api/user/:userID"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// Params is "userID"</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">NoParams</code> <code class="o">=</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="s2">"/api/user"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// NoParams is never: no params!</code></pre>&#13;
&#13;
<p>That’s already much better than we did earlier. Now, we want to catch all other possible parameters. For that, we have to add another condition:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="nx">Route</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Route</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">P</code><code class="si">}</code><code class="sb">/</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">R</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">P</code> <code class="o">|</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="sb">`/</code><code class="si">${</code><code class="nx">R</code><code class="si">}</code><code class="sb">`</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="nx">Route</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">P</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">P</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Our conditional type now works as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>In the first condition, we check if there is a route parameter somewhere in between the route. If so, we extract both the route parameter and everything else that comes after. We return the newly found route parameter <code>P</code> in a union where we call the same generic type recursively with the rest <code>R</code>. For example, if we pass the route <code>"/api/users/:userID/orders/:orderID"</code> to <code>ParseRouteParams</code>, we infer <code>"userID"</code> into <code>P</code> and <code>"orders/:orderID"</code> into <code>R</code>. We call the same type with <code>R</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>This is where the second condition comes in. Here we check if there is a type at the end. This is the case for <code>"orders/:orderID"</code>. We extract <code>"orderID"</code> and return this literal type.</p>&#13;
</li>&#13;
<li>&#13;
<p>If there are no more route parameters left, we return <code>never</code>:</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Params is "userID"</code>&#13;
<code class="kr">type</code> <code class="nx">Params</code> <code class="o">=</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="s2">"/api/user/:userID"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// MoreParams is "userID" | "orderID"</code>&#13;
<code class="kr">type</code> <code class="nx">MoreParams</code> <code class="o">=</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="s2">"/api/user/:userID/orders/:orderId"</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Let’s apply this new type and see what our final usage of <code>app.get</code> looks like:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api/users/:userID/orders/:orderID"</code><code class="p">,</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">userID</code><code class="p">;</code> <code class="c1">// Works</code>&#13;
  <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">orderID</code><code class="p">;</code> <code class="c1">// Also available</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>And that’s it! Let’s recap. The types we just created for one function <code>app.get</code> make sure that we exclude a ton of possible errors:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We can only pass proper numeric status codes to <code>res.status()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>req.method</code> is one of four possible strings, and when we use <code>app.get</code>, we know it can only be <code>"GET"</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>We can parse route params and make sure we don’t have any typos inside our callback parameters.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If we look at the example from the beginning of this recipe, we get the following error messages:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/api/users/:userID"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">method</code> <code class="o">===</code> <code class="s2">"POST"</code><code class="p">)</code> <code class="p">{</code>&#13;
<code class="c1">//   ^ This condition will always return 'false' since</code>&#13;
<code class="c1">//     the types 'Methods' and '"POST"' have no overlap.(2367)</code>&#13;
    <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">20</code><code class="p">).</code><code class="nx">send</code><code class="p">({</code>&#13;
<code class="c1">//             ^</code>&#13;
<code class="c1">//  Argument of type '20' is not assignable to parameter of</code>&#13;
<code class="c1">//  type 'StatusCode'.(2345)</code>&#13;
      <code class="nx">message</code><code class="o">:</code> <code class="s2">"Welcome, user "</code> <code class="o">+</code> <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">userId</code>&#13;
<code class="c1">//                                           ^</code>&#13;
<code class="c1">//    Property 'userId' does not exist on type</code>&#13;
<code class="c1">//    '{ userID: string; }'. Did you mean 'userID'?</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>And all that before we actually run our code! Express-style servers are a perfect example of the dynamic nature of JavaScript. Depending on the method you call and the string you pass for the first argument, a lot of behavior changes inside the callback. Take another example and all your types look entirely different.</p>&#13;
&#13;
<p>The great thing about this approach is that every step added more type safety:</p>&#13;
<ol>&#13;
<li>&#13;
<p>You can easily stop at basic types and get more out of it than having no types &#13;
<span class="keep-together">at all.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Subsetting helps you get rid of typos by reducing the number of valid values.</p>&#13;
</li>&#13;
<li>&#13;
<p>Generics help you tailor behavior to use case.</p>&#13;
</li>&#13;
<li>&#13;
<p>Advanced types like string template literal types give your app more meaning in a stringly-typed world.</p>&#13;
</li>&#13;
<li>&#13;
<p>Locking in generics allows you to work with literals in JavaScript and treat them as types.</p>&#13;
</li>&#13;
<li>&#13;
<p>Conditional types make your types as flexible as your JavaScript code.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The best thing? Once you added your types, people will just write plain JavaScript and still get all the type information. That’s a win for everybody<a data-startref="ix_12-02-asciidoc8" data-type="indexterm" id="id980"/><a data-startref="ix_12-02-asciidoc7" data-type="indexterm" id="id981"/>.<a data-startref="ix_12-02-asciidoc1" data-type="indexterm" id="id982"/><a data-startref="ix_12-02-asciidoc0" data-type="indexterm" id="id983"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.3 Checking Contracts with satisfies" data-type="sect1"><div class="sect1" id="ch12_satisfies">&#13;
<h1>12.3 Checking Contracts with satisfies</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id187">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="annotation-like type-checking" data-type="indexterm" id="ix_12-03-asciidoc0"/><a data-primary="contracts, checking with satisfies operator" data-type="indexterm" id="ix_12-03-asciidoc1"/><a data-primary="literal types" data-secondary="checking contracts with satisfies" data-type="indexterm" id="ix_12-03-asciidoc2"/><a data-primary="satisfies operator" data-type="indexterm" id="ix_12-03-asciidoc3"/><a data-primary="type development strategies" data-secondary="checking contracts with satisfies" data-type="indexterm" id="ix_12-03-asciidoc4"/>You want to work with literal types but need an annotation type-check to make sure you fulfill a contract.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id984">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>satisfies</code> operator to do annotation-like type-checking while retaining the literal types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id188">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Mapped types are great, as they allow for the flexibility in object structures JavaScript is known for. But they have some crucial implications for the type system. Take this example from a generic messaging library, which takes a “channel definition” where multiple channel tokens can be defined:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Messages</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="s2">"CHANNEL_OPEN"</code>&#13;
  <code class="o">|</code> <code class="s2">"CHANNEL_CLOSE"</code>&#13;
  <code class="o">|</code> <code class="s2">"CHANNEL_FAIL"</code>&#13;
  <code class="o">|</code> <code class="s2">"MESSAGE_CHANNEL_OPEN"</code>&#13;
  <code class="o">|</code> <code class="s2">"MESSAGE_CHANNEL_CLOSE"</code>&#13;
  <code class="o">|</code> <code class="s2">"MESSAGE_CHANNEL_FAIL"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ChannelDefinition</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="nx">Messages</code><code class="p">;</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="nx">Messages</code><code class="p">;</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="nx">Messages</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The keys from this channel definition object are what the user wants them to be. So this is a valid channel definition:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">impl</code><code class="o">:</code> <code class="nx">ChannelDefinition</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="s1">'CHANNEL_OPEN'</code><code class="p">,</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="s1">'CHANNEL_CLOSE'</code><code class="p">,</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="s1">'CHANNEL_FAIL'</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="s1">'MESSAGE_CHANNEL_OPEN'</code><code class="p">,</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="s1">'MESSAGE_CHANNEL_CLOSE'</code><code class="p">,</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="s1">'MESSAGE_CHANNEL_FAIL'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We have a problem, however: when we want to access the keys we defined so flexibly. Let’s say we have a function that opens a channel. We pass the whole channel definition object, as well as the channel we want to open:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">openChannel</code><code class="p">(</code>&#13;
  <code class="nx">def</code><code class="o">:</code> <code class="nx">ChannelDefinition</code><code class="p">,</code>&#13;
  <code class="nx">channel</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">ChannelDefinition</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So what are the keys of <code>ChannelDefinition</code>? Well, it’s every key: <code>[key: string]</code>. So the moment we assign a specific type, TypeScript treats <code>impl</code> as this specific type, ignoring the actual implementation. The contract is fulfilled. Moving on. This allows for wrong keys to be passed:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Passes, even though "massage" is not part of impl</code>&#13;
<code class="nx">openChannel</code><code class="p">(</code><code class="nx">impl</code><code class="p">,</code> <code class="s2">"massage"</code><code class="p">);</code></pre>&#13;
&#13;
<p>So we are more interested in the actual implementation, not the type we assign to our constant. This means we have to get rid of the <code>ChannelDefinition</code> type and make sure we care about the actual type of the object.</p>&#13;
&#13;
<p>First, the <code>openChannel</code> function should take any object that is a subtype of <code>Ch⁠ann⁠el​De⁠fi⁠ni⁠tion</code> but work with the concrete subtype:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">openChannel</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">ChannelDefinition</code>&#13;
<code class="o">&gt;</code><code class="p">(</code><code class="nx">def</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">channel</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>TypeScript now works on two levels:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It checks if <code>T</code> actually extends <code>ChannelDefinition</code>. If so, we work with type <code>T</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>All our function parameters are typed with the generic <code>T</code>. This also means we get the <em>real</em> keys of <code>T</code> through <code>keyof T</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To benefit from that, we have to get rid of the type definition for <code>impl</code>. The explicit type definition overrides all actual types. From the moment we explicitly specify the type, TypeScript treats it as <code>ChannelDefinition</code>, not the actual underlying subtype. We also have to set <em>const context</em>, so we can convert all strings to their unit type (and thus be compliant with <code>Messages</code>):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">impl</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="s2">"CHANNEL_OPEN"</code><code class="p">,</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="s2">"CHANNEL_CLOSE"</code><code class="p">,</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="s2">"CHANNEL_FAIL"</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_OPEN"</code><code class="p">,</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_CLOSE"</code><code class="p">,</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_FAIL"</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code></pre>&#13;
&#13;
<p>Without <em>const context</em>, the inferred type of <code>impl</code> is:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">/// typeof impl</code>&#13;
<code class="p">{</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With <em>const context</em>, the actual type of <code>impl</code> is now:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">/// typeof impl</code>&#13;
<code class="p">{</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="kr">readonly</code> <code class="nx">open</code><code class="o">:</code> <code class="s2">"CHANNEL_OPEN"</code><code class="p">;</code>&#13;
    <code class="kr">readonly</code> <code class="nx">close</code><code class="o">:</code> <code class="s2">"CHANNEL_CLOSE"</code><code class="p">;</code>&#13;
    <code class="kr">readonly</code> <code class="nx">fail</code><code class="o">:</code> <code class="s2">"CHANNEL_FAIL"</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="kr">readonly</code> <code class="nx">open</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_OPEN"</code><code class="p">;</code>&#13;
    <code class="kr">readonly</code> <code class="nx">close</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_CLOSE"</code><code class="p">;</code>&#13;
    <code class="kr">readonly</code> <code class="nx">fail</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_FAIL"</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><em>Const context</em> allows us to satisfy the contract made by <code>ChannelDefinition</code>. Now <code>openChannel</code> works correctly:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">openChannel</code><code class="p">(</code><code class="nx">impl</code><code class="p">,</code> <code class="s2">"message"</code><code class="p">);</code> <code class="c1">// satisfies contract</code>&#13;
<code class="nx">openChannel</code><code class="p">(</code><code class="nx">impl</code><code class="p">,</code> <code class="s2">"massage"</code><code class="p">);</code>&#13;
<code class="c1">//                 ^</code>&#13;
<code class="c1">// Argument of type '"massage"' is not assignable to parameter</code>&#13;
<code class="c1">// of type '"test" | "message"'.(2345)</code></pre>&#13;
&#13;
<p>This works but comes with a caveat. The only point where we can check if <code>impl</code> is actually a valid subtype of <code>ChannelDefinition</code> is when we are using it. Sometimes we want to annotate early to figure out potential breaks in our contract. We want to see if this specific implementation <em>satisfies</em> a contract.</p>&#13;
&#13;
<p>Thankfully, there is a keyword for that. We can define objects and do a type-check to see if this implementation satisfies a type, but TypeScript will treat it as a literal type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">impl</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="s2">"CHANNEL_OPEN"</code><code class="p">,</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="s2">"CHANNEL_CLOSE"</code><code class="p">,</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="s2">"CHANNEL_FAIL"</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">open</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_OPEN"</code><code class="p">,</code>&#13;
    <code class="nx">close</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_CLOSE"</code><code class="p">,</code>&#13;
    <code class="nx">fail</code><code class="o">:</code> <code class="s2">"MESSAGE_CHANNEL_FAIL"</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">}</code> <code class="nx">satisfies</code> <code class="nx">ChannelDefinition</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">openChannel</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">ChannelDefinition</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">def</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">channel</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">T</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// to be implemented</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With that, we can make sure that we fulfill contracts but have the same benefits as with <em>const context</em>. The only difference is that the fields are not set to <code>readonly</code>, but since TypeScript takes the literal type of everything, there is no way to set fields to anything else after a satisfaction type-check:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">impl</code><code class="p">.</code><code class="nx">test</code><code class="p">.</code><code class="nx">close</code> <code class="o">=</code> <code class="s2">"CHANEL_CLOSE_MASSAGE"</code><code class="p">;</code>&#13;
<code class="c1">//                 ^</code>&#13;
<code class="c1">// Type '"CHANEL_CLOSE_MASSAGE"' is not assignable</code>&#13;
<code class="c1">// to type '"CHANNEL_CLOSE"'.(2322)</code></pre>&#13;
&#13;
<p>With that, we get the best of both worlds: proper type-checks at annotation time as well as the power of narrowed types for specific situations.<a data-startref="ix_12-03-asciidoc4" data-type="indexterm" id="id985"/><a data-startref="ix_12-03-asciidoc3" data-type="indexterm" id="id986"/><a data-startref="ix_12-03-asciidoc2" data-type="indexterm" id="id987"/><a data-startref="ix_12-03-asciidoc1" data-type="indexterm" id="id988"/><a data-startref="ix_12-03-asciidoc0" data-type="indexterm" id="id989"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.4 Testing Complex Types" data-type="sect1"><div class="sect1" id="ch12_testing_types">&#13;
<h1>12.4 Testing Complex Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id189">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="complex types, testing" data-type="indexterm" id="ix_12-04-asciidoc0"/><a data-primary="helper types" data-secondary="testing complex types with" data-type="indexterm" id="ix_12-04-asciidoc1"/><a data-primary="tests" data-secondary="testing complex types" data-type="indexterm" id="ix_12-04-asciidoc2"/><a data-primary="type development strategies" data-secondary="testing complex types" data-type="indexterm" id="ix_12-04-asciidoc3"/>You have written very elaborate and complex types, and you want to make sure that they behave correctly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id990">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Some commonly known helper types work like a test framework. Test your types!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id190">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In dynamically typed programming languages people always circle around the discussion of if you need types when you can have a proper test suite. This is at least what one camp says; the other thinks, why should we test so much when we can have types? The answer is probably somewhere in the middle.</p>&#13;
&#13;
<p>It is true that types can solve a lot of test cases. Is the result a number? Is the result an object with certain properties of certain types? This is something we can easily check via types. Does my function produce correct results? Are the values what I expect them to be? This belongs to tests.</p>&#13;
&#13;
<p>Throughout this book, we learned a lot about very complex types. With conditional types, we opened up the metaprogramming capabilities of TypeScript, where we could craft new types based on certain features of previous types. Powerful, Turing complete, and very advanced. This leads to the question: how do we ensure that those complex types actually do what they should do? Maybe we should <em>test our types</em>?</p>&#13;
&#13;
<p>We actually can. There are a few helper types known within the community that can serve as some sort of testing framework. <a data-primary="Type Challenges" data-type="indexterm" id="id991"/>The following types come from the excellent <a href="https://tsch.js.org">Type Challenges repository</a>, which allows you to test your TypeScript type system skills to an extreme. They include very challenging tasks: some that have relevance to real-world use cases and others that are just for fun.</p>&#13;
&#13;
<p>Their testing library starts with a few types that expect a truthy or a falsy value. They are pretty straightforward. By using generics and literal types, we can check if this one Boolean is true or false:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">type</code> <code class="nx">Expect</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kc">true</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">ExpectTrue</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kc">true</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">ExpectFalse</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kc">false</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">IsTrue</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kc">true</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">IsFalse</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kc">false</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>They don’t do much on their own but are fantastic when being used with <code>Equal&lt;X, Y&gt;</code> and <code>NotEqual&lt;X, Y&gt;</code>, which return either <code>true</code> or <code>false</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">type</code> <code class="nx">Equal</code><code class="o">&lt;</code><code class="nx">X</code><code class="p">,</code> <code class="nx">Y</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">(</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">X</code> <code class="o">?</code> <code class="mi">1</code> <code class="o">:</code> <code class="mi">2</code><code class="p">)</code> <code class="kr">extends</code>&#13;
  <code class="p">(</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Y</code> <code class="o">?</code> <code class="mi">1</code> <code class="o">:</code> <code class="mi">2</code><code class="p">)</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">NotEqual</code><code class="o">&lt;</code><code class="nx">X</code><code class="p">,</code> <code class="nx">Y</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kc">true</code> <code class="kr">extends</code> <code class="nx">Equal</code><code class="o">&lt;</code><code class="nx">X</code><code class="p">,</code> <code class="nx">Y</code><code class="o">&gt;</code> <code class="o">?</code> <code class="kc">false</code> <code class="o">:</code> <code class="kc">true</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>Equal&lt;X, Y&gt;</code> is interesting as it creates generic functions and checks them against both types that should be compared with each other. Since there is no resolution on each conditional type, TypeScript compares both conditional types and can see if there is compatibility. It’s a step within TypeScript’s conditional type logic that is masterfully explained by <a href="https://oreil.ly/ywWd4">Alex Chashin on Stack Overflow</a>.</p>&#13;
&#13;
<p><a data-primary="any type" data-secondary="testing complex types" data-type="indexterm" id="id992"/>The next batch allows us to check if a type is <code>any</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">type</code> <code class="nx">IsAny</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="mi">0</code> <code class="kr">extends</code> <code class="mi">1</code> <code class="o">&amp;</code> <code class="nx">T</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">NotAny</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kc">true</code> <code class="kr">extends</code> <code class="nx">IsAny</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">?</code> <code class="kc">false</code> <code class="o">:</code> <code class="kc">true</code><code class="p">;</code></pre>&#13;
&#13;
<p>It’s a simple conditional type that checks <code>0</code> against <code>1 &amp; T</code>, which should always narrow down to <code>1</code> or <code>never</code>, which always yields the <code>false</code> branch of the conditional type. Except when we intersect with <code>any</code>. An intersection with <code>any</code> is always <code>any</code>, and <code>0</code> is a subset of <code>any</code>.</p>&#13;
&#13;
<p>The next batch is reinterpretations of <code>Remap</code> and <code>DeepRemap</code> we saw in <a data-type="xref" href="ch08.html#ch08_remapping">Recipe 8.3</a>, along with <code>Alike</code> as a way to compare types that are equal in structure but not &#13;
<span class="keep-together">construction:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">type</code> <code class="nx">Debug</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="p">};</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">MergeInsertions</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">object</code>&#13;
  <code class="o">?</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">MergeInsertions</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code> <code class="p">}</code>&#13;
  <code class="o">:</code> <code class="nx">T</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">Alike</code><code class="o">&lt;</code><code class="nx">X</code><code class="p">,</code> <code class="nx">Y</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Equal</code><code class="o">&lt;</code><code class="nx">MergeInsertions</code><code class="o">&lt;</code><code class="nx">X</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">MergeInsertions</code><code class="o">&lt;</code><code class="nx">Y</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>The <code>Equal</code> check before should theoretically be able to understand that <code>{ x : number, y: string }</code> is equal to <code>{ x: number } &amp; { y: string }</code>, but implementation details of the TypeScript type-checker don’t see them as equal. That’s where <code>Alike</code> comes into play.</p>&#13;
&#13;
<p>The last batch of the type challenges testing file does two things:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It does subset checks with a simple conditional type.</p>&#13;
</li>&#13;
<li>&#13;
<p>It checks if a tuple you have constructed can be seen as a valid argument for a function:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">type</code> <code class="nx">ExpectExtends</code><code class="o">&lt;</code><code class="nx">VALUE</code><code class="p">,</code> <code class="nx">EXPECTED</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">EXPECTED</code> <code class="kr">extends</code> <code class="nx">VALUE</code>&#13;
  <code class="o">?</code> <code class="kc">true</code>&#13;
  <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">ExpectValidArgs</code><code class="o">&lt;</code>&#13;
  <code class="nx">FUNC</code> <code class="kr">extends</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">,</code>&#13;
  <code class="nx">ARGS</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[]</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">ARGS</code> <code class="kr">extends</code> <code class="nx">Parameters</code><code class="o">&lt;</code><code class="nx">FUNC</code><code class="o">&gt;</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code></pre>&#13;
&#13;
<p>Having a small helper type library like this for type testing and debugging is really helpful when your types get more complex. Add them to your global type definition files (see <a data-type="xref" href="ch09.html#ch09_augmenting_globals">Recipe 9.7</a>) and use them.<a data-startref="ix_12-04-asciidoc3" data-type="indexterm" id="id993"/><a data-startref="ix_12-04-asciidoc2" data-type="indexterm" id="id994"/><a data-startref="ix_12-04-asciidoc1" data-type="indexterm" id="id995"/><a data-startref="ix_12-04-asciidoc0" data-type="indexterm" id="id996"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.5 Validating Data Types at Runtime with Zod" data-type="sect1"><div class="sect1" id="ch12_zod">&#13;
<h1>12.5 Validating Data Types at Runtime with Zod</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id191">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="runtime, validating data types at" data-type="indexterm" id="ix_12-05-asciidoc0"/><a data-primary="schemas, defining" data-type="indexterm" id="ix_12-05-asciidoc1"/><a data-primary="type development strategies" data-secondary="validating data types at runtime with Zod" data-type="indexterm" id="ix_12-05-asciidoc2"/><a data-primary="Zod library" data-type="indexterm" id="ix_12-05-asciidoc3"/>You rely on data from external sources and can’t trust them to be correct.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id997">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Define schemas using a library called <em>Zod</em> and use it to validate data from external sources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id192">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Congratulations! We’re almost at the end. If you have followed along from start to finish, you have been constantly reminded that TypeScript’s type system follows a couple of goals. First and foremost, it wants to give you excellent tooling so you can be &#13;
<span class="keep-together">productive</span> when developing applications. It also wants to cater to all JavaScript frameworks and make sure they are fun and easy to use. It sees itself as an add-on to JavaScript, as a syntax for static types. There are also some non-goals or trade-offs. It prefers productivity over correctness, it allows developers to bend the rules to their needs, and it has no claim of being provably sound.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#ch03_item_assertions">Recipe 3.9</a> we learned that we can influence TypeScript if we think that types should be something different through <em>type assertions</em>, and in <a data-type="xref" href="ch09.html#ch09_unsafe_operations">Recipe 9.2</a> we learned how we can make <em>unsafe operations</em> more robust and easier to spot. Since TypeScript’s type system is compile-time only, all our safeguards evaporate once we run JavaScript in our selected runtime.</p>&#13;
&#13;
<p>Usually, compile-time type-checks are good enough. As long as we are within the <em>inner world</em> where we write our own types, let TypeScript check that everything is OK, and our code is good to go. In JavaScript applications, however, we also deal with a lot of things beyond our control: user input, for example. APIs from third parties that we need to access and process. Inevitably, we reach a point in our development process where we need to leave the boundaries of our well-typed application and deal with data that we can’t trust.</p>&#13;
&#13;
<p>While developing, working with external sources or user input might work well enough, but to make sure that the data we use stays the same when running in production requires extra effort. You may want to validate that your data adheres to a certain scheme.</p>&#13;
&#13;
<p>Thankfully, there are libraries that deal with that kind of task. One library that has gained popularity in recent years is <a href="https://zod.dev">Zod</a>. Zod is TypeScript-first, which means it makes sure not only that the data you consume is valid and what you expect but also that you get TypeScript types you can use throughout your program. Zod sees itself as the guard between the outer world outside of your control and the inner world where everything is well-typed and also type-checked.</p>&#13;
&#13;
<p>Think of an API that gives you data for the <code>Person</code> type we’ve seen throughout the book. A <code>Person</code> has a name and age, a profession that is optional, and also a status: in our system, they can be either active, inactive, or only registered, waiting for confirmation.</p>&#13;
&#13;
<p>The API also packs a couple of <code>Person</code> objects in an array contained within a <code>Result</code> type. In short, it’s an example for a classic response type for HTTP calls:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">?:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">status</code><code class="o">:</code> <code class="s2">"active"</code> <code class="o">|</code> <code class="s2">"inactive"</code> <code class="o">|</code> <code class="s2">"registered"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Results</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">entries</code><code class="o">: </code><code class="kr">Person</code><code class="p">[]</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p class="pagebreak-before">You know how to type models like this. By now, you are fluent in recognizing and applying both syntax and patterns. We want to have the same type, but at runtime for data outside our control, we use Zod. And writing the same type in JavaScript (the value namespace) looks very familiar:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">z</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"zod"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="nx">object</code><code class="p">({</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="kt">string</code><code class="p">(),</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="kt">number</code><code class="p">().</code><code class="nx">min</code><code class="p">(</code><code class="mi">0</code><code class="p">).</code><code class="nx">max</code><code class="p">(</code><code class="mi">150</code><code class="p">),</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="kt">string</code><code class="p">().</code><code class="nx">optional</code><code class="p">(),</code>&#13;
  <code class="nx">status</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="nx">union</code><code class="p">([</code>&#13;
    <code class="nx">z</code><code class="p">.</code><code class="nx">literal</code><code class="p">(</code><code class="s2">"active"</code><code class="p">),</code>&#13;
    <code class="nx">z</code><code class="p">.</code><code class="nx">literal</code><code class="p">(</code><code class="s2">"inactive"</code><code class="p">),</code>&#13;
    <code class="nx">z</code><code class="p">.</code><code class="nx">literal</code><code class="p">(</code><code class="s2">"registered"</code><code class="p">),</code>&#13;
  <code class="p">]),</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Results</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="nx">object</code><code class="p">({</code>&#13;
  <code class="nx">entries</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="nx">array</code><code class="p">(</code><code class="nx">Person</code><code class="p">),</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>As you see, we are in JavaScript, and we add names to the <em>value</em> namespace, not the <em>type</em> namespace (see <a data-type="xref" href="ch02.html#ch02_item_namespaces">Recipe 2.9</a>), but the tools we get from Zod’s fluent interface are very familiar to us TypeScript developers. We define objects, strings, numbers, and arrays. We can also define union types and literals. All the building blocks for defining models are here, and we can also nest types, as we see by defining <code>Person</code> first and reusing it in <code>Results</code>.</p>&#13;
&#13;
<p>The fluent interface also allows us to make certain properties optional. All things that we know from TypeScript. Furthermore, we can set validation rules. We can say that age should be above or equal to 0 and below 100. Things that we can’t do reasonably within the type system.</p>&#13;
&#13;
<p>Those objects are not types that we can use like we would use TypeScript types. They are <em>schemas</em>, waiting for data they can parse and validate. Since Zod is TypeScript-first, we have helper types that allow us to cross the bridge from the value space to the type space. With <code>z.infer</code> (a type, not a function), we can extract the type we defined through Zod’s schema functions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonType</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="kr">infer</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">Person</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">ResultType</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="kr">infer</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">Results</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>So, how do we apply Zod’s validation techniques? Let’s talk about a function called <code>fetchData</code>, which calls an API that gets entries of type <code>ResultType</code>. We just don’t know if the values we receive actually adhere to the types we’ve defined. So, after fetching data as <code>json</code>, we use the <code>Results</code> schema to parse the data we’ve received. If this process is successful, we get data that is of type <code>ResultType</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ResultType</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="kr">infer</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">Results</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="kr">async</code> <code class="kd">function</code> <code class="nx">fetchData</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">ResultType</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">data</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/persons"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>&#13;
  <code class="k">return</code> <code class="nx">Results</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that we already had our first safeguard in how we defined the function interface. <code>Promise&lt;ResultType&gt;</code> is based on what we get from <code>z.infer</code>.</p>&#13;
&#13;
<p><code>Results.parse(data)</code> is of the inferred type but without a name. The structural type system makes sure that we return the right thing. There might be errors, and we can <code>catch</code> them using the respective <code>Promise.catch</code> methods or <code>try</code>-<code>catch</code> blocks.</p>&#13;
&#13;
<p>Usage with <code>try</code>-<code>catch</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">fetchData</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// do something with results</code>&#13;
  <code class="p">})</code>&#13;
  <code class="p">.</code><code class="k">catch</code><code class="p">((</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// a potential zod error!</code>&#13;
  <code class="p">});</code>&#13;
&#13;
<code class="c1">// or</code>&#13;
&#13;
<code class="k">try</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">res</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetchData</code><code class="p">();</code>&#13;
  <code class="c1">// do something with results</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// a potential zod error!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>While we can ensure that we continue only if we have correct data, we are not forced to do error checking. If we want to make sure that we look at the parsing result first before we continue with our program, <code>safeParse</code> is the way to go:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">async</code> <code class="kd">function</code> <code class="nx">fetchData</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">ResultType</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">data</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/persons"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>&#13;
  <code class="kr">const</code> <code class="nx">results</code> <code class="o">=</code> <code class="nx">Results</code><code class="p">.</code><code class="nx">safeParse</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">results</code><code class="p">.</code><code class="nx">success</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">results</code><code class="p">.</code><code class="nx">data</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="c1">// Depending on your application, you might want to have a</code>&#13;
    <code class="c1">// more sophisticated way of error handling than returning</code>&#13;
    <code class="c1">// an empty result.</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">entries</code><code class="o">:</code> <code class="p">[]</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This already makes Zod a valuable asset if you need to rely on external data. Furthermore, it allows you to adapt to API changes. Let’s say that your program can work only with active and inactive states of <code>Person</code>; it does not know how to handle &#13;
<span class="keep-together"><code>registered</code>.</span> It’s easy to apply a transform where, based on the data you get, you modify the <code>"registered"</code> state to be actually <code>"active"</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="nx">object</code><code class="p">({</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="kt">string</code><code class="p">(),</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="kt">number</code><code class="p">().</code><code class="nx">min</code><code class="p">(</code><code class="mi">0</code><code class="p">).</code><code class="nx">max</code><code class="p">(</code><code class="mi">150</code><code class="p">),</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="nx">z</code><code class="p">.</code><code class="kt">string</code><code class="p">().</code><code class="nx">optional</code><code class="p">(),</code>&#13;
  <code class="nx">status</code><code class="o">:</code> <code class="nx">z</code>&#13;
    <code class="p">.</code><code class="nx">union</code><code class="p">([</code>&#13;
      <code class="nx">z</code><code class="p">.</code><code class="nx">literal</code><code class="p">(</code><code class="s2">"active"</code><code class="p">),</code>&#13;
      <code class="nx">z</code><code class="p">.</code><code class="nx">literal</code><code class="p">(</code><code class="s2">"inactive"</code><code class="p">),</code>&#13;
      <code class="nx">z</code><code class="p">.</code><code class="nx">literal</code><code class="p">(</code><code class="s2">"registered"</code><code class="p">),</code>&#13;
    <code class="p">])</code>&#13;
    <code class="p">.</code><code class="nx">transform</code><code class="p">((</code><code class="nx">val</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">val</code> <code class="o">===</code> <code class="s2">"registered"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="s2">"active"</code><code class="p">;</code>&#13;
      <code class="p">}</code>&#13;
      <code class="k">return</code> <code class="nx">val</code><code class="p">;</code>&#13;
    <code class="p">}),</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>You then work with two different types: the <em>input</em> type represents what the API is giving you, and the <em>output</em> type is the data you have after parsing. Thankfully, we can get both types from the respective Zod helper types <code>z.input</code> and <code>z.output</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonTypeIn</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="nx">input</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">Person</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="cm">/*</code>&#13;
<code class="cm">type PersonTypeIn = {</code>&#13;
<code class="cm">  name: string;</code>&#13;
<code class="cm">  age: number;</code>&#13;
<code class="cm">  profession?: string | undefined;</code>&#13;
<code class="cm">  status: "active" | "inactive" | "registered";</code>&#13;
<code class="cm">};</code>&#13;
<code class="cm">*/</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">PersonTypeOut</code> <code class="o">=</code> <code class="nx">z</code><code class="p">.</code><code class="nx">output</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">Person</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="cm">/*</code>&#13;
<code class="cm">type PersonTypeOut = {</code>&#13;
<code class="cm">  name: string;</code>&#13;
<code class="cm">  age: number;</code>&#13;
<code class="cm">  profession?: string | undefined;</code>&#13;
<code class="cm">  status: "active" | "inactive";</code>&#13;
<code class="cm">};</code>&#13;
<code class="cm">*/</code></pre>&#13;
&#13;
<p>Zod’s typings are clever enough to understand that you removed one of the three literals from <code>status</code>. So there are no surprises and you actually deal with the data you’ve been expecting.</p>&#13;
&#13;
<p>Zod’s API is elegant, easy to use, and closely aligned with TypeScript’s features. For data at the boundaries that you can’t control, where you need to rely on third parties to provide the expected shape of data, Zod is a lifesaver without you having to do too much work. It comes at a cost, though: runtime validation takes time. The bigger the dataset, the longer it takes. Also, at 12KB it’s big. Be certain that you need this kind of validation for data at your boundaries.</p>&#13;
&#13;
<p>If the data you request comes from some other team within your company, maybe the person sitting next to you, no library, not even Zod, beats talking with each other and collaborating toward the same goals. Types are a way to guide collaboration, not a means to get rid of it.<a data-startref="ix_12-05-asciidoc3" data-type="indexterm" id="id998"/><a data-startref="ix_12-05-asciidoc2" data-type="indexterm" id="id999"/><a data-startref="ix_12-05-asciidoc1" data-type="indexterm" id="id1000"/><a data-startref="ix_12-05-asciidoc0" data-type="indexterm" id="id1001"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.6 Working Around Index Access Restrictions" data-type="sect1"><div class="sect1" id="ch12_unexpected_intersections">&#13;
<h1>12.6 Working Around Index Access Restrictions</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id193">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="generic types, working around index access restrictions with" data-type="indexterm" id="ix_12-06-asciidoc0"/><a data-primary="index access restrictions, working around" data-type="indexterm" id="ix_12-06-asciidoc1"/><a data-primary="type development strategies" data-secondary="working around index access restrictions" data-type="indexterm" id="ix_12-06-asciidoc2"/>When accessing an object’s property using index access, TypeScript complains that the type you want to assign is not assignable to <code>never</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1002">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>TypeScript looks for the lowest common denominator of possible values. Use a generic type to lock in specific keys so TypeScript doesn’t assume the rule needs to apply for all.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id194">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Sometimes when writing TypeScript, actions you’d usually do in JavaScript work a little differently and cause some weird and puzzling situations. Sometimes you just want to assign a value to an object property via index access and get an error like “Type <code>'string | number'</code> is not assignable to type <code>'never'</code>. Type <code>'string'</code> is not assignable to type <code>'never'</code>.(2322).”</p>&#13;
&#13;
<p>This isn’t out of the ordinary; it’s just where “unexpected intersection types” make you think a little bit more about the type system.</p>&#13;
&#13;
<p>Let’s look at this example. We create a function that lets us update from one object <code>anotherPerson</code> to object <code>person</code> via providing a key. Both <code>person</code> and <code>an⁠oth⁠er​Pe⁠rs⁠on</code> have the same type <code>Person</code>, but TypeScript throws errors:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">39</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">person</code><code class="p">;</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">anotherPerson</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Not Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">20</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">update</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">person</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">anotherPerson</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>&#13;
<code class="c1">//^ Type 'string | number' is not assignable to type 'never'.</code>&#13;
<code class="c1">//  Type 'string' is not assignable to type 'never'.(2322)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">update</code><code class="p">(</code><code class="s2">"age"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Property assignments via the index access operator are hard for TypeScript to track down. Even if you narrow all possible access keys via <code>keyof Person</code>, the possible values that can be assigned are <code>string</code> or <code>number</code> (for name and age, respectively). While this is fine if you have index access on the righthand side of a statement (reading), it gets a little interesting if you have index access on the lefthand side of a statement (writing).</p>&#13;
&#13;
<p>TypeScript can’t guarantee that the value you pass along is actually correct. Look at this function signature:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">updateAmbiguous</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">Person</code><code class="p">,</code> <code class="nx">value</code><code class="o">: </code><code class="kr">Person</code><code class="p">[</code><code class="kr">keyof</code> <code class="nx">Person</code><code class="p">])</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">updateAmbiguous</code><code class="p">(</code><code class="s2">"age"</code><code class="p">,</code> <code class="s2">"Stefan"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Nothing prevents me from adding a falsely typed value to every key. Except for TypeScript, which throws an error. But why does TypeScript tell us the type is <code>never</code>?</p>&#13;
&#13;
<p>To allow for <em>some</em> assignments TypeScript compromises. Instead of not allowing <em>any</em> assignments at all on the righthand side, TypeScript looks for the lowest common denominator of possible values, for example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Switch</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">address</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code>&#13;
  <code class="nx">on</code><code class="o">:</code> <code class="mi">0</code> <code class="o">|</code> <code class="mi">1</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">switcher</code><code class="o">:</code> <code class="nx">Switch</code><code class="p">;</code>&#13;
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">key</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">Switch</code><code class="p">;</code></pre>&#13;
&#13;
<p>Here, both keys are subsets of <code>number</code>. <code>address</code> is the entire set of numbers; <code>on</code> on the other side is either <code>0</code> or <code>1</code>. It’s absolutely possible to set <code>0</code> or <code>1</code> to both fields! And this is what you get with TypeScript as well:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">switcher</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="c1">// This works</code>&#13;
<code class="nx">switcher</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="c1">// ^ Type '2' is not assignable to type '0 | 1'.(2322)</code></pre>&#13;
&#13;
<p>TypeScript gets to the possible assignable values by doing an <em>intersection type</em> of all property types. In the case of the <code>Switch</code>, it’s <code>number &amp; (0 | 1)</code>, which boils down to <code>0 | 1</code>. In the case of all <code>Person</code> properties, it’s <code>string &amp; number</code>, which has no overlap; therefore it’s <code>never</code>. Hah! There’s the culprit!</p>&#13;
&#13;
<p>One way to get around this strictness (which is for your own good) is by using generics. Instead of allowing all <code>keyof Person</code> values to access, we <em>bind</em> a specific subset of <code>keyof Person</code> to a generic variable:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">update</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">Person</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="nx">K</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">person</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">anotherPerson</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code> <code class="c1">// works</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">update</code><code class="p">(</code><code class="s2">"age"</code><code class="p">);</code></pre>&#13;
&#13;
<p>When I <code>update("age")</code>, <code>K</code> is bound to the literal type of <code>"age"</code>. No ambiguity there!</p>&#13;
&#13;
<p>There is a theoretical loophole since we could instantiate <code>update</code> with a much broader generic value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">update</code><code class="o">&lt;</code><code class="s2">"age"</code> <code class="o">|</code> <code class="s2">"name"</code><code class="o">&gt;</code><code class="p">(</code><code class="s2">"age"</code><code class="p">);</code></pre>&#13;
&#13;
<p>This is something the TypeScript team allows,  for now. See also <a href="https://oreil.ly/0Fetp">this comment</a> by Anders Hejlsberg. Note that he asks to see use cases for such a scenario, which perfectly details how the TypeScript team works. The original assignment via index access on the righthand side has so much potential for error that they give you enough safeguards until you make it very intentional what you want to do. This is ruling out entire classes of errors without getting too much in the way.<a data-startref="ix_12-06-asciidoc2" data-type="indexterm" id="id1003"/><a data-startref="ix_12-06-asciidoc1" data-type="indexterm" id="id1004"/><a data-startref="ix_12-06-asciidoc0" data-type="indexterm" id="id1005"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.7 Deciding Whether to Use &#10;Function Overloads or Conditional Types" data-type="sect1"><div class="sect1" id="ch12_overloads_vs_conditionals">&#13;
<h1>12.7 Deciding Whether to Use &#13;
<span class="keep-together">Function Overloads or Conditional Types</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id236">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="function overloads versus" data-type="indexterm" id="ix_12-07-asciidoc0"/><a data-primary="function overloads" data-secondary="conditional types versus" data-type="indexterm" id="ix_12-07-asciidoc1"/><a data-primary="function signatures" data-secondary="deciding whether to use function overloads or conditional types with" data-type="indexterm" id="ix_12-07-asciidoc2"/><a data-primary="type development strategies" data-secondary="function overloads versus conditional types" data-type="indexterm" id="ix_12-07-asciidoc3"/>With conditional types, you have more possibilities to define function signatures than before. You wonder if you still need function overloads or if they’re obsolete.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1006">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Function overloads provide better readability and an easier way to define expectations from your type than conditionals. Use them when the situation requires.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id1007">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>With type system features like conditional types or variadic tuple types, one technique to describe a function’s interface has faded into the background: function &#13;
<span class="keep-together">overloads.</span> And for good reason. Both features have been implemented to deal with the shortcomings of regular function overloads.</p>&#13;
&#13;
<p>See this concatenation example directly from the TypeScript 4.0 release notes. This is an array <code>concat</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">concat</code><code class="p">(</code><code class="nx">arr1</code><code class="p">,</code> <code class="nx">arr2</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[...</code><code class="nx">arr1</code><code class="p">,</code> <code class="p">...</code><code class="nx">arr2</code><code class="p">];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To correctly type a function like this so it takes all possible edge cases into account, we would end up in a sea of overloads:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// 7 overloads for an empty second array</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">,</code> <code class="nx">F</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">,</code> <code class="nx">F</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">,</code> <code class="nx">D</code><code class="p">,</code> <code class="nx">E</code><code class="p">,</code> <code class="nx">F</code><code class="p">];</code>&#13;
<code class="c1">// 7 more for arr2 having one element</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">],</code> <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">])</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">F1</code><code class="p">,</code> <code class="nx">A2</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">arr1</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">F1</code><code class="p">],</code>&#13;
  <code class="nx">arr2</code><code class="o">:</code> <code class="p">[</code><code class="nx">A2</code><code class="p">]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="nx">A1</code><code class="p">,</code> <code class="nx">B1</code><code class="p">,</code> <code class="nx">C1</code><code class="p">,</code> <code class="nx">D1</code><code class="p">,</code> <code class="nx">E1</code><code class="p">,</code> <code class="nx">F1</code><code class="p">,</code> <code class="nx">A2</code><code class="p">];</code>&#13;
<code class="c1">// and so on, and so forth</code></pre>&#13;
&#13;
<p class="pagebreak-before">And this only takes into account arrays that have up to six elements. Variadic tuple types help greatly with these situations:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Arr</code> <code class="o">=</code> <code class="kr">readonly</code> <code class="kr">any</code><code class="p">[];</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">concat</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Arr</code><code class="p">,</code> <code class="nx">U</code> <code class="kr">extends</code> <code class="nx">Arr</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">arr1</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">arr2</code><code class="o">:</code> <code class="nx">U</code><code class="p">)</code><code class="o">:</code> <code class="p">[...</code><code class="nx">T</code><code class="p">,</code> <code class="p">...</code><code class="nx">U</code><code class="p">]</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[...</code><code class="nx">arr1</code><code class="p">,</code> <code class="p">...</code><code class="nx">arr2</code><code class="p">];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The new function signature requires a lot less effort to parse and is very clear on what types it expects to get as arguments and what it returns. The return value also maps to the return type. No extra assertions: TypeScript can make sure that you are returning the correct value.</p>&#13;
&#13;
<p>It’s a similar situation with conditional types. This example is very similar to <a data-type="xref" href="ch05.html#ch05_function_signatures">Recipe 5.1</a>. Think of software that retrieves orders based on customer, article, or order ID. You might want to create something like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">customer</code><code class="o">:</code> <code class="nx">Customer</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">product</code><code class="o">:</code> <code class="nx">Product</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">orderId</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code>&#13;
<code class="c1">// the implementation</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">param</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code> <code class="o">|</code> <code class="nx">Order</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But this is just half the truth. What if you end up with ambiguous types where you don’t know exactly if you get <em>only</em>&#13;
a <code>Customer</code> or only a <code>Product</code>? You need to take care of all possible combinations:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">customer</code><code class="o">:</code> <code class="nx">Customer</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">product</code><code class="o">:</code> <code class="nx">Product</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">orderId</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">param</code><code class="o">:</code> <code class="nx">Customer</code> <code class="o">|</code> <code class="nx">Product</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">param</code><code class="o">:</code> <code class="nx">Customer</code> <code class="o">|</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code> <code class="o">|</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">param</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">Product</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code> <code class="o">|</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
<code class="c1">// the implementation</code>&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="p">(</code><code class="nx">param</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="nx">Order</code> <code class="o">|</code> <code class="nx">Order</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Add more possibilities, and you end up with more combinations. Here, conditional types can reduce your function signature tremendously:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FetchParams</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">Customer</code> <code class="o">|</code> <code class="nx">Product</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">FetchReturn</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Customer</code>&#13;
  <code class="o">?</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
  <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Product</code>&#13;
  <code class="o">?</code> <code class="nx">Order</code><code class="p">[]</code>&#13;
  <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">number</code>&#13;
  <code class="o">?</code> <code class="nx">Order</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">fetchOrder</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">FetchParams</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">params</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">FetchReturn</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Since conditional types distribute a union, <code>FetchReturn</code> returns a union of return types.</p>&#13;
&#13;
<p>So there is good reason to use those techniques instead of drowning in too many function overloads. So, to return to the question: do we still need function overloads?</p>&#13;
&#13;
<p>Yes, we do.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Different function shapes" data-type="sect3"><div class="sect3" id="id195">&#13;
<h3>Different function shapes</h3>&#13;
&#13;
<p><a data-primary="function overloads" data-secondary="for different function shapes" data-type="indexterm" id="ix_12-07-asciidoc4"/>One scenario where function overloads remain handy is if you have different argument lists for your function variants. This means not only the arguments (parameters) themselves can have some variety (this is where conditionals and variadic tuples are fantastic) but also the number and position of arguments.</p>&#13;
&#13;
<p>Imagine a search function that has two different ways of being called:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Call it with the search query. It returns a <code>Promise</code> you can await.</p>&#13;
</li>&#13;
<li>&#13;
<p>Call it with the search query and a callback. In this scenario, the function does not return anything.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This <em>can</em> be done with conditional types but is very unwieldy:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// =&gt; (1)</code>&#13;
<code class="kr">type</code> <code class="nx">SearchArguments</code> <code class="o">=</code>&#13;
  <code class="c1">// Argument list one: a query and a callback</code>&#13;
  <code class="o">|</code> <code class="p">[</code><code class="nx">query</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">results</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">]</code>&#13;
  <code class="c1">// Argument list two:: just a query</code>&#13;
  <code class="o">|</code> <code class="p">[</code><code class="nx">query</code><code class="o">:</code> <code class="kt">string</code><code class="p">];</code>&#13;
&#13;
<code class="c1">// A conditional type picking either void or a Promise depending</code>&#13;
<code class="c1">// on the input =&gt; (2)</code>&#13;
<code class="kr">type</code> <code class="nx">ReturnSearch</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="p">[</code><code class="nx">query</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code>&#13;
  <code class="o">?</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nb">Array</code><code class="o">&lt;</code><code class="kr">unknown</code><code class="o">&gt;&gt;</code>&#13;
  <code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// the actual function =&gt; (3)</code>&#13;
<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">search</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">SearchArguments</code><code class="o">&gt;</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">ReturnSearch</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// z is void</code>&#13;
<code class="kr">const</code> <code class="nx">z</code> <code class="o">=</code> <code class="nx">search</code><code class="p">(</code><code class="s2">"omikron"</code><code class="p">,</code> <code class="p">(</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{});</code>&#13;
&#13;
<code class="c1">// y is Promise&lt;unknown&gt;</code>&#13;
<code class="kr">const</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">search</code><code class="p">(</code><code class="s2">"omikron"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Here’s what we did:</p>&#13;
<ol>&#13;
<li>&#13;
<p>We defined our argument list using tuple types. Since TypeScript 4.0, we can name tuple fields just like we would objects. We create a union because we have two different variants of our function signature.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>ReturnSearch</code> type selects the return type based on the argument list variant. If it’s just a string, return a <code>Promise</code>. Otherwise return <code>void</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>We add our types by constraining a generic variable to <code>SearchArguments</code> so that we can correctly select the return type.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>That is a lot! And it features a ton of complex features we love to see in TypeScript’s feature list: conditional types, generics, generic constraints, tuple types, union types! We get <em>some</em> nice autocomplete, but it’s nowhere near the clarity of a simple function overload:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">search</code><code class="p">(</code><code class="nx">query</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kr">unknown</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">search</code><code class="p">(</code><code class="nx">query</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="c1">// This is the implementation, it only concerns you</code>&#13;
<code class="kd">function</code> <code class="nx">search</code><code class="p">(</code>&#13;
  <code class="nx">query</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">callback</code><code class="o">?:</code> <code class="p">(</code><code class="nx">result</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="o">|</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kr">unknown</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// Implement</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We use a union type only for the implementation part. The rest is very explicit and clear. We know our arguments, and we know what to expect in return. No ceremony, just simple types. The best part of function overloads is that the <em>actual</em> implementation does not pollute the type space. You can go for a round of <code>any</code> and just not care.<a data-startref="ix_12-07-asciidoc4" data-type="indexterm" id="id1008"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exact arguments" data-type="sect3"><div class="sect3" id="id196">&#13;
<h3>Exact arguments</h3>&#13;
&#13;
<p><a data-primary="exact arguments, function overloads for" data-type="indexterm" id="ix_12-07-asciidoc5"/><a data-primary="function overloads" data-secondary="for exact arguments" data-type="indexterm" id="ix_12-07-asciidoc6"/>Another situation where function overloads can make things easier is when you need exact arguments and their mapping. Let’s look at a function that applies an event to an event handler. For example, we have a <code>MouseEvent</code> and want to call a <code>Mo⁠use⁠Eve⁠nt​Ha⁠nd⁠ler</code> with it. Same for keyboard events and so on. If we use conditionals and union types to map event and handler, we might end up with something like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// All the possible event handlers</code>&#13;
<code class="kr">type</code> <code class="nx">Handler</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="nx">MouseEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code>&#13;
  <code class="o">|</code> <code class="nx">KeyboardEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Map Handler to Event</code>&#13;
<code class="kr">type</code> <code class="nx">Ev</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">MouseEventHandler</code><code class="o">&lt;</code><code class="kr">infer</code> <code class="nx">R</code><code class="o">&gt;</code>&#13;
  <code class="o">?</code> <code class="nx">MouseEvent</code><code class="o">&lt;</code><code class="nx">R</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">KeyboardEventHandler</code><code class="o">&lt;</code><code class="kr">infer</code> <code class="nx">R</code><code class="o">&gt;</code>&#13;
  <code class="o">?</code> <code class="nx">KeyboardEvent</code><code class="o">&lt;</code><code class="nx">R</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Create a</code>&#13;
<code class="kd">function</code> <code class="nx">apply</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Handler</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">handler</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">ev</code><code class="o">:</code> <code class="nx">Ev</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="nx">handler</code><code class="p">(</code><code class="nx">ev</code> <code class="kr">as</code> <code class="kr">any</code><code class="p">);</code> <code class="c1">// We need the assertion here</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>At first glance, this looks fine. It might be a bit cumbersome, though, if you think about all the variants you need to keep track of.</p>&#13;
&#13;
<p>But there’s a bigger problem. The way TypeScript deals with all possible variants of the event is causing an <em>unexpected intersection</em>, as we see in <a data-type="xref" href="#ch12_unexpected_intersections">Recipe 12.6</a>. This means that, in the function body, TypeScript can’t tell what kind of handler you are passing. Therefore, it also can’t tell which kind of event we’re getting. So TypeScript says the event can be both: a mouse event and a keyboard event. You need to pass handlers that can deal with both, which is not how we intend our function to work.</p>&#13;
&#13;
<p>The actual error message is “TS 2345: Argument of type <code><em>Ke⁠ybo⁠ard⁠Eve⁠nt&lt;H⁠TML⁠Bu⁠tt⁠on​El⁠em⁠en⁠t&gt; | MouseEvent&lt;HTMLButtonElement, MouseEvent&gt;</em></code> is not assignable to parameter of type <code><em>Mo⁠us⁠eEv⁠ent⁠&lt;HT⁠MLB⁠utt⁠onE⁠lem⁠ent⁠, Mo⁠use⁠Eve⁠nt&gt; ⁠&amp; Key⁠boa⁠rd ​Eve⁠nt&lt;H⁠TML⁠But⁠ton⁠Ele⁠me⁠nt&gt;</em></code>.”</p>&#13;
&#13;
<p>This is why we need an <code>as any</code> type assertion to make it possible to actually call the handler with the event.</p>&#13;
&#13;
<p>The function signature works in a lot of scenarios:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kr">const</code> <code class="nx">mouseHandler</code><code class="o">:</code> <code class="nx">MouseEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">mouseEv</code><code class="o">:</code> <code class="nx">MouseEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">keyboardHandler</code><code class="o">:</code> <code class="nx">KeyboardEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">keyboardEv</code><code class="o">:</code> <code class="nx">KeyboardEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="nx">apply</code><code class="p">(</code><code class="nx">mouseHandler</code><code class="p">,</code> <code class="nx">mouseEv</code><code class="p">);</code> <code class="c1">// works</code>&#13;
<code class="nx">apply</code><code class="p">(</code><code class="nx">keyboardHandler</code><code class="p">,</code> <code class="nx">keyboardEv</code><code class="p">);</code> <code class="c1">// woirks</code>&#13;
<code class="nx">apply</code><code class="p">(</code><code class="nx">mouseHandler</code><code class="p">,</code> <code class="nx">keyboardEv</code><code class="p">);</code> <code class="c1">// breaks like it should!</code>&#13;
<code class="c1">//                  ^</code>&#13;
<code class="c1">// Argument of type 'KeyboardEvent&lt;HTMLButtonElement&gt;' is not assignable</code>&#13;
<code class="c1">// to parameter of type 'MouseEvent&lt;HTMLButtonElement, MouseEvent&gt;'</code></pre>&#13;
&#13;
<p>But once there’s ambiguity, things don’t work out as they should:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kr">const</code> <code class="nx">mouseOrKeyboardHandler</code><code class="o">:</code>&#13;
  <code class="nx">MouseEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code> <code class="o">|</code>&#13;
  <code class="nx">KeyboardEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">;;</code>&#13;
&#13;
<code class="c1">// This is accepted but can cause problems!</code>&#13;
<code class="nx">apply</code><code class="p">(</code><code class="nx">mouseOrKeyboardHandler</code><code class="p">,</code> <code class="nx">mouseEv</code><code class="p">);</code></pre>&#13;
&#13;
<p>When <code>mouseOrKeyboardHandler</code> is a keyboard handler, we can’t reasonably pass a mouse event. Wait: this is exactly what the TS2345 error from before tried to tell us! We just shifted the problem to another place and made it silent with an &#13;
<span class="keep-together"><code>as any</code> assertion.</span></p>&#13;
&#13;
<p>Explicit, exact function signatures make <em>everything</em> easier. The mapping becomes clearer, the type signatures are easier to understand, and there’s no need for conditionals or unions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Overload 1: MouseEventHandler and MouseEvent</code>&#13;
<code class="kd">function</code> <code class="nx">apply</code><code class="p">(</code>&#13;
  <code class="nx">handler</code><code class="o">:</code> <code class="nx">MouseEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">ev</code><code class="o">:</code> <code class="nx">MouseEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="c1">// Overload 2: KeyboardEventHandler and KeyboardEvent</code>&#13;
<code class="kd">function</code> <code class="nx">apply</code><code class="p">(</code>&#13;
  <code class="nx">handler</code><code class="o">:</code> <code class="nx">KeyboardEventHandler</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">ev</code><code class="o">:</code> <code class="nx">KeyboardEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="c1">// The implementation. Fall back to any. This is not a type!</code>&#13;
<code class="c1">// TypeScript won't check for this line nor</code>&#13;
<code class="c1">// will it show in the autocomplete.</code>&#13;
<code class="c1">// This is just for you to implement your stuff.</code>&#13;
<code class="kd">function</code> <code class="nx">apply</code><code class="p">(</code><code class="nx">handler</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">ev</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="nx">handler</code><code class="p">(</code><code class="nx">ev</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Function overloads help us with all possible scenarios. We make sure there are no ambiguous types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">apply</code><code class="p">(</code><code class="nx">mouseHandler</code><code class="p">,</code> <code class="nx">mouseEv</code><code class="p">);</code> <code class="c1">// works!</code>&#13;
<code class="nx">apply</code><code class="p">(</code><code class="nx">keyboardHandler</code><code class="p">,</code> <code class="nx">keyboardEv</code><code class="p">);</code> <code class="c1">// works!</code>&#13;
<code class="nx">apply</code><code class="p">(</code><code class="nx">mouseHandler</code><code class="p">,</code> <code class="nx">keyboardEv</code><code class="p">);</code> <code class="c1">// breaks like it should!</code>&#13;
<code class="c1">// ^ No overload matches this call.</code>&#13;
<code class="nx">apply</code><code class="p">(</code><code class="nx">mouseOrKeyboardHandler</code><code class="p">,</code> <code class="nx">mouseEv</code><code class="p">);</code> <code class="c1">// breaks like it should</code>&#13;
<code class="c1">// ^ No overload matches this call.</code></pre>&#13;
&#13;
<p>For the implementation, we can even use <code>any</code>. Since you can make sure that you won’t run into a situation that implies ambiguity, you can rely on the happy-go-lucky type and don’t need to bother.<a data-startref="ix_12-07-asciidoc6" data-type="indexterm" id="id1009"/><a data-startref="ix_12-07-asciidoc5" data-type="indexterm" id="id1010"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The catch-all function body" data-type="sect3"><div class="sect3" id="id197">&#13;
<h3>The catch-all function body</h3>&#13;
&#13;
<p>Last but not least, there’s the combination of conditional types <em>and</em> function overloads. Remember the example from <a data-type="xref" href="ch05.html#ch05_function_signatures">Recipe 5.1</a>: we saw that conditional types gave the function body a hard time to map values to the respective generic return types. Moving the conditional type to a function overload and using a very broad function signature for implementation helps both the users of the function as well as the &#13;
<span class="keep-together">implementers:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createLabel</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">|</code> <code class="nx">NumberLabel</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">input</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code>&#13;
  <code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">|</code> <code class="nx">NumberLabel</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="s2">"id"</code> <code class="k">in</code> <code class="nx">input</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">id</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">name</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Function overloads are still very useful and, for a lot of scenarios, the way to go. They’re easier to read, easier to write, and, in a lot of cases, more exact than what we get with other means.</p>&#13;
&#13;
<p>But it’s not either-or. You can happily mix and match conditionals and function overloads if your scenario needs it.<a data-startref="ix_12-07-asciidoc3" data-type="indexterm" id="id1011"/><a data-startref="ix_12-07-asciidoc2" data-type="indexterm" id="id1012"/><a data-startref="ix_12-07-asciidoc1" data-type="indexterm" id="id1013"/><a data-startref="ix_12-07-asciidoc0" data-type="indexterm" id="id1014"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.8 Naming Generics" data-type="sect1"><div class="sect1" id="ch12_naming_generics">&#13;
<h1>12.8 Naming Generics</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id237">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="generics" data-secondary="naming" data-type="indexterm" id="ix_12-08-asciidoc0"/><a data-primary="type development strategies" data-secondary="naming generics" data-type="indexterm" id="ix_12-08-asciidoc1"/><code>T</code> and <code>U</code> don’t tell you anything about generic type parameters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1015">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Follow a naming pattern.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id198">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript’s generics are arguably one of the most powerful features of the language. They open a door to TypeScript’s own metaprogramming language, which allows for a very flexible and dynamic generation of types. It comes close to being its own functional programming language.</p>&#13;
&#13;
<p>Especially with the arrival of <em>string literal types</em> and <em>recursive conditional types</em> in the most recent TypeScript versions, we can craft types that do astonishing things. This type from <a data-type="xref" href="#ch12_refining_types">Recipe 12.2</a> parses Express-style from route information and retrieves an object with all its parameters:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ParseRouteParameters</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">U</code><code class="si">}</code><code class="sb">/</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">R</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code>&#13;
    <code class="p">{</code> <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">U</code> <code class="o">|</code> <code class="kr">keyof</code> <code class="nx">ParseRouteParameters</code><code class="o">&lt;</code><code class="sb">`/</code><code class="si">${</code><code class="nx">R</code><code class="si">}</code><code class="sb">`</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">:</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">U</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code>&#13;
    <code class="p">{</code> <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">U</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">:</code> <code class="p">{}</code>&#13;
&#13;
&#13;
<code class="kr">type</code> <code class="nx">X</code> <code class="o">=</code> <code class="nx">ParseRouteParameters</code><code class="o">&lt;</code><code class="s2">"/api/:what/:is/notyou/:happening"</code><code class="o">&gt;</code>&#13;
<code class="c1">// type X = {</code>&#13;
<code class="c1">//   what: string,</code>&#13;
<code class="c1">//   is: string,</code>&#13;
<code class="c1">//   happening: string,</code>&#13;
<code class="c1">// }</code></pre>&#13;
&#13;
<p><a data-primary="generic type parameters" data-type="indexterm" id="id1016"/>When we define a <em>generic type</em>, we also define <em>generic type parameters</em>. They can be of a certain type (or more correctly, be a certain subtype):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Foo</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">...</code></pre>&#13;
&#13;
<p>They can have default values:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Foo</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">=</code> <code class="s2">"hello"</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">...</code></pre>&#13;
&#13;
<p>And when using default values, <em>order</em> is important. This is just one of many similarities to regular JavaScript functions! So since we are almost talking functions, why are we using single-letter names for generic type parameters?</p>&#13;
&#13;
<p>Most generic type parameters start with the letter <code>T</code>. Subsequent parameters go along the alphabet (<code>U</code>, <code>V</code>, <code>W</code>) or are abbreviations like <code>K</code> for <code>key</code>. This can lead to highly unreadable types, however. If I look at <code>Extract&lt;T, U&gt;</code>, it is hard to tell if we extract <code>T</code> from <code>U</code>, or the other way around.</p>&#13;
&#13;
<p>Being a bit more elaborate helps:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Extract</code><code class="o">&lt;</code><code class="nx">From</code><code class="p">,</code> <code class="nx">Union</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">...</code></pre>&#13;
&#13;
<p>Now we know that we want to extract <em>from</em> the first parameter everything that is assignable to <code>Union</code>. Furthermore, we understand that we want to have a union type.</p>&#13;
&#13;
<p>Types are documentation, and our type parameters can have speaking names, just like you would do with regular functions. Go for a naming scheme, like this one:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>All type parameters start with an uppercase letter, like you would name all other types!</p>&#13;
</li>&#13;
<li>&#13;
<p>Only use single letters if the usage is completely clear. For example, <code>ParseRouteParams</code> can have only one argument, the route.</p>&#13;
</li>&#13;
<li>&#13;
<p>Don’t abbreviate to <code>T</code> (that’s way too …​ generic!) but to something that clarifies what we are dealing with. For example, <code>ParseRouteParams&lt;R&gt;</code>, where <code>R</code> stands for <code>Route</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Rarely use single letters; stick to short words or abbreviations: <code>Elem</code> for <code>Element</code>, <code>Route</code> can stand as is.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use prefixes to differentiate from built-in types. For example, <code>Element</code> is taken, so use <code>GElement</code> (or stick with <code>Elem</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Use prefixes to make generic names clearer: <code>URLObj</code> is clearer than <code>Obj</code>, &#13;
<span class="keep-together">for instance.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Same patterns apply to inferred types within a generic type.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s look at <code>ParseRouteParams</code> again and be more explicit with our names:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ParseRouteParams</code><code class="o">&lt;</code><code class="nx">Route</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">Route</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Param</code><code class="si">}</code><code class="sb">/</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code>&#13;
    <code class="p">{</code> <code class="p">[</code><code class="nx">Entry</code> <code class="k">in</code> <code class="nx">Param</code> <code class="o">|</code> <code class="kr">keyof</code> <code class="nx">ParseRouteParameters</code><code class="o">&lt;</code><code class="sb">`/</code><code class="si">${</code><code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">:</code>&#13;
  <code class="nx">Route</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Param</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code>&#13;
    <code class="p">{</code> <code class="p">[</code><code class="nx">Entry</code> <code class="k">in</code> <code class="nx">Param</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">:</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>It becomes a lot clearer what each type is meant to be. We also see that we need to iterate over all <code>Entry</code>s in <code>Param</code>, even if <code>Param</code> is just a set of one type.</p>&#13;
&#13;
<p>Arguably, it’s a lot more readable than before!</p>&#13;
&#13;
<p>There is one caveat: it’s almost impossible to distinguish type parameters from actual types. There’s another scheme that has been heavily popularized by <a href="https://oreil.ly/Y1i-Q">Matt Pocock</a>: using a <code>T</code> prefix:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ParseRouteParameters</code><code class="o">&lt;</code><code class="nx">TRoute</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">Route</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">TParam</code><code class="si">}</code><code class="sb">/</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">TRest</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code>&#13;
    <code class="p">{</code> <code class="p">[</code><code class="nx">TEntry</code> <code class="k">in</code> <code class="nx">TParam</code> <code class="o">|</code> <code class="kr">keyof</code> <code class="nx">ParseRouteParameters</code><code class="o">&lt;</code><code class="sb">`/</code><code class="si">${</code><code class="nx">TRest</code><code class="si">}</code><code class="sb">`</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">:</code>&#13;
  <code class="nx">Route</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">/:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">TParam</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code>&#13;
    <code class="p">{</code> <code class="p">[</code><code class="nx">TEntry</code> <code class="k">in</code> <code class="nx">TParam</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">:</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>This comes close to a <a href="https://oreil.ly/c23gW">Hungarian Notation</a> for types.</p>&#13;
&#13;
<p>Whatever variation you use, making sure that generic types are readable to you and your colleagues, and that their parameters speak for themselves, is as important as in other programming languages.<a data-startref="ix_12-08-asciidoc1" data-type="indexterm" id="id1017"/><a data-startref="ix_12-08-asciidoc0" data-type="indexterm" id="id1018"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.9 Prototyping on the TypeScript Playground" data-type="sect1"><div class="sect1" id="ch12_playground">&#13;
<h1>12.9 Prototyping on the TypeScript Playground</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id199">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="prototyping, TypeScript playground for" data-type="indexterm" id="ix_12-09-asciidoc0"/><a data-primary="troubleshooting, prototyping on the TypeScript playground for" data-type="indexterm" id="ix_12-09-asciidoc1"/><a data-primary="type development strategies" data-secondary="prototyping on the TypeScript playground" data-type="indexterm" id="ix_12-09-asciidoc2"/><a data-primary="TypeScript playground" data-type="indexterm" id="ix_12-09-asciidoc3"/>Your project is so big, it’s hard for you to properly fix bugs in typings.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1019">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Move your types to the TypeScript playground and develop them in isolation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id200">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a href="https://www.typescriptlang.org/play">The TypeScript playground</a> as shown in <a data-type="xref" href="#img-playground">Figure 12-1</a> is a web application that has been with TypeScript since its first release, showcasing how TypeScript syntax is compiled to JavaScript. Its capabilities were originally limited and focused on “breaking the ice” for new developers, but in recent years it has become a powerhouse of online development, rich in features and indispensable for TypeScript development. The TypeScript team asks people to submit issues including a re-creation of the bug using the playground. They also test new and upcoming features by allowing the nightly version to be loaded into the application. In short: the TypeScript playground is essential for TypeScript development.</p>&#13;
&#13;
<figure><div class="figure" id="img-playground">&#13;
<img alt="tscb 1201" src="assets/tscb_1201.png"/>&#13;
<h6><span class="label">Figure 12-1. </span>The TypeScript playground showing one of the built-in examples</h6>&#13;
</div></figure>&#13;
&#13;
<p>For your regular development practices, the TypeScript playground is a great way to develop types in isolation, independent from your current project. As TypeScript configurations grow, they become confusing, and it becomes hard to understand which types contribute to your actual project. If you encounter weird or unexpected behavior in your types, try re-creating them in the playground, in isolation, without the rest of your project.</p>&#13;
&#13;
<p class="pagebreak-before">The playground doesn’t feature a full <em>tsconfig.json</em>, but you can define the important pieces of your configuration via a user interface, as seen in <a data-type="xref" href="#img-tsconfig-panel">Figure 12-2</a>. Alternatively, you can set compiler flags using annotations directly in the source code:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// @strictPropertyInitialization: false</code>&#13;
<code class="c1">// @target: esnext</code>&#13;
<code class="c1">// @module: nodenext</code>&#13;
<code class="c1">// @lib: es2015,dom</code></pre>&#13;
&#13;
<p>Not as comfortable but highly ergonomic as it allows you to share compiler flags much more easily.</p>&#13;
&#13;
<figure><div class="figure" id="img-tsconfig-panel">&#13;
<img alt="tscb 1202" src="assets/tscb_1202.png"/>&#13;
<h6><span class="label">Figure 12-2. </span>Instead of writing an actual tsconfig.json, you set compiler flags using the TSConfig panel</h6>&#13;
</div></figure>&#13;
&#13;
<p>You also can compile TypeScript, get extracted type information, run small pieces of code to see how they behave, and export everything to various destinations, including other popular online editors and IDEs.</p>&#13;
&#13;
<p class="pagebreak-before">You can select various versions to ensure that your bug isn’t dependent on version updates, and you can run various, well-documented examples to learn the basics of TypeScript while trying out actual source code.</p>&#13;
&#13;
<p>As noted in <a data-type="xref" href="#ch12_multiple_library_versions">Recipe 12.10</a>, developing JavaScript would be nothing without using dependencies. In the TypeScript playground, it’s possible to fetch type information for dependencies directly from NPM. If you import, for example, React within the TypeScript playground, the playground will try to acquire types:</p>&#13;
<ol>&#13;
<li>&#13;
<p>First, it will look at the respective package on NPM and check if there are types defined or <em>.d.ts</em> files somewhere in its contents.</p>&#13;
</li>&#13;
<li>&#13;
<p>If not, it will check on NPM if Definitely Typed type information exists and will download the respective <code>@types</code> package.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This is recursive, meaning that if some types require types from other packages, type acquisition will also go through the type dependencies. For some packages, you can even define which version to load:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">render</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"preact"</code><code class="p">;</code> <code class="c1">// types: legacy</code></pre>&#13;
&#13;
<p>Here, <code>types</code> is set to <code>legacy</code>, which loads the respective legacy version from NPM.</p>&#13;
&#13;
<p><a data-primary="Twoslash" data-type="indexterm" id="ix_12-09-asciidoc4"/>There’s more to the ecosystem. An important tool of the TypeScript playground is <em>Twoslash</em>. Twoslash is a markup format for TypeScript files that lets you highlight code, handle multiple files, and show the files the TypeScript compiler creates. It’s fantastic for blogs and websites—you basically have an inline TypeScript compiler for code examples—but it’s also fantastic if you need to create complex debugging &#13;
<span class="keep-together">scenarios.</span></p>&#13;
&#13;
<p>The compiler flag annotations are handled by Twoslash, but you can also get inline hints on current types by adding a marker in a comment directly under a variable name:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// @jsxFactory: h</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">render</code><code class="p">,</code> <code class="nx">h</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"preact"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Heading</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Hello</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">elem</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">Heading</code><code class="o">/&gt;</code>&#13;
<code class="c1">//    ^?</code>&#13;
<code class="c1">// This line above triggers inline hints</code></pre>&#13;
&#13;
<p>You can see the result in <a data-type="xref" href="#img-twoslash">Figure 12-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-twoslash">&#13;
<img alt="tscb 1203" src="assets/tscb_1203.png"/>&#13;
<h6><span class="label">Figure 12-3. </span>Twoslash in action: setting compiler flags via annotations</h6>&#13;
</div></figure>&#13;
&#13;
<p>Twoslash is also part of the <a href="https://oreil.ly/jVU3u">bug workbench</a>, which is a fork of the playground with an emphasis on creating and displaying complex reproductions of bugs. Here, you can also define multiple files to see how imports and exports work:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// @filename: a.ts</code>&#13;
&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">a</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./input.js"</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code></pre>&#13;
&#13;
<p>Multifile support is triggered by the first <code>@filename</code> annotation. Everything before this line becomes a file called <em>input.tsx</em>, basically your main entry point.</p>&#13;
&#13;
<p>Last but not least, the playground can work as your entire demo suite for workshops and trainings. Using Twoslash, you can create multiple files in a GitHub Gist repository and load the TypeScript files along with documentation as part of a Gist docset, as seen in <a data-type="xref" href="#img-docsets">Figure 12-4</a>.</p>&#13;
&#13;
<p>This is immensely powerful for immersive learning. From mere reproductions to full-fledged demo suites, the TypeScript playground is the one-stop source for TypeScript developers—whether you need to file bugs, try out something new, or work on types in isolation. It’s a great resource to start with, and from there you can easily migrate to “real” IDEs and tools<a data-startref="ix_12-09-asciidoc4" data-type="indexterm" id="id1020"/>.<a data-startref="ix_12-09-asciidoc3" data-type="indexterm" id="id1021"/><a data-startref="ix_12-09-asciidoc2" data-type="indexterm" id="id1022"/><a data-startref="ix_12-09-asciidoc1" data-type="indexterm" id="id1023"/><a data-startref="ix_12-09-asciidoc0" data-type="indexterm" id="id1024"/></p>&#13;
&#13;
<figure><div class="figure" id="img-docsets">&#13;
<img alt="tscb 1204" src="assets/tscb_1204.png"/>&#13;
<h6><span class="label">Figure 12-4. </span>A Gist docset in the playground</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.10 Providing Multiple Library Versions" data-type="sect1"><div class="sect1" id="ch12_multiple_library_versions">&#13;
<h1>12.10 Providing Multiple Library Versions</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id201">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="external libraries" data-type="indexterm" id="ix_12-10-asciidoc0"/><a data-primary="external types, providing multiple library versions for" data-type="indexterm" id="ix_12-10-asciidoc1"/><a data-primary="libraries" data-secondary="providing multiple library versions for external types" data-type="indexterm" id="ix_12-10-asciidoc2"/><a data-primary="type development strategies" data-secondary="providing multiple library versions" data-type="indexterm" id="ix_12-10-asciidoc3"/><a data-primary="type updates" data-type="indexterm" id="ix_12-10-asciidoc4"/>You write external types for a library and want to maintain type updates relative to library version updates.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1025">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use reference triple-slash directives, as well as modules, namespaces, and interfaces for declaration merging.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id202">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Programming would be tough without external libraries that take care of a lot of work for you. JavaScript’s ecosystem is arguably one of the richest when it comes to third-party dependencies, mainly through <a href="https://npmjs.org">NPM</a>. Also, most of them come with TypeScript support, either through built-in types or through types from Definitely Typed. According to the TypeScript team, almost <a href="https://oreil.ly/G2Ktl">80% of NPM is typed</a>. However, there is still the odd holdout: for example, libraries are not written in TypeScript, or legacy code from your own company that you still need to make compatible with today’s software.</p>&#13;
&#13;
<p>Think of a library called <em>“lib”</em>, which exposes a <code>Connector</code> class that you can use to target internal systems. This library exists in multiple versions, and features have been added constantly:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">Connector</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"lib"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// This exists in version 1</code>&#13;
<code class="kr">const</code> <code class="nx">connector</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Connector</code><code class="p">();</code>&#13;
<code class="kr">const</code> <code class="nx">connection</code> <code class="o">=</code> <code class="nx">connector</code><code class="p">.</code><code class="nx">connect</code><code class="p">(</code><code class="s2">"127.0.0.1:4000"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">connection</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This exists in version 2</code>&#13;
<code class="nx">connection</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code></pre>&#13;
&#13;
<p>It’s worth noting that this library can be used by multiple projects within your organization, with varying versions. Your task is to write types so your teams get proper autocomplete and type information.</p>&#13;
&#13;
<p>In TypeScript, you can provide multiple versions of a library’s types by creating an ambient module declaration for each version of the library. An ambient module declaration is a file with a <em>.d.ts</em> extension that provides TypeScript with the types for a library not written in TypeScript.</p>&#13;
&#13;
<p>By default, TypeScript is greedy: it includes type definitions and <em>globs</em> everything it can. If you want to limit TypeScript’s file access, make sure to use the <code>"exclude"</code> and <code>"include"</code> properties in <em>tsconfig.json</em>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"typeRoots"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">      </code><code class="s2">"@types"</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"rootDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./src"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"outDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"dist"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"include"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"./src"</code><code class="p">,</code><code class="w"> </code><code class="s2">"./@types"</code><code class="p">]</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>We create a folder <em>next to</em> the folders we included in <em>tsconfig.json</em>. Here, we create a file called <em>lib.v1.d.ts</em>, where we store the basic information on how objects are created:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"lib"</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kr">interface</code> <code class="nx">ConnectorConstructor</code> <code class="p">{</code>&#13;
    <code class="k">new</code> <code class="p">()</code><code class="o">:</code> <code class="nx">Connector</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="kd">var</code> <code class="nx">Connector</code><code class="o">:</code> <code class="nx">ConnectorConstructor</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Connector</code> <code class="p">{</code>&#13;
    <code class="nx">connect</code><code class="p">(</code><code class="nx">stream</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Connection</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Connection</code> <code class="p">{</code>&#13;
    <code class="nx">send</code><code class="p">(</code><code class="nx">msg</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Connection</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that we use modules to define the name of the module and that we also use interfaces for most of our types. Both modules and interfaces are open to declaration merging, which means we can add new types in different files and TypeScript merges them together. This is crucial if we want to define multiple versions.</p>&#13;
&#13;
<p>Also note that we use the constructor interface pattern (see <a data-type="xref" href="ch11.html#ch11_constructor_interfaace">Recipe 11.3</a>) for &#13;
<span class="keep-together"><code>Connector</code></span>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">interface</code> <code class="nx">ConnectorConstructor</code> <code class="p">{</code>&#13;
  <code class="k">new</code> <code class="p">()</code><code class="o">:</code> <code class="nx">Connector</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">var</code> <code class="nx">Connector</code><code class="o">:</code> <code class="nx">ConnectorConstructor</code><code class="p">;</code></pre>&#13;
&#13;
<p>In doing so, we can change the signature of the constructor and make sure that an instantiable class is being recognized by TypeScript.</p>&#13;
&#13;
<p>In another file called <em>lib.v2.d.ts</em>, next to <em>lib.v1.d.ts</em>, we redeclare <code>"lib"</code> and add more methods to <code>Connection</code>. Through declaration merging, the <code>close</code> method gets added to the <code>Connection</code> interface:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">/// &lt;reference path="lib.v1.d.ts" /&gt;</code>&#13;
&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"lib"</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Connection</code> <code class="p">{</code>&#13;
    <code class="nx">close</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using triple-slash directives, we refer from <em>lib.v2.d.ts</em> to <em>lib.v1.d.ts</em>, signaling that everything from version 1 is to be included in version 2.</p>&#13;
&#13;
<p>All those files exist in a folder called <em>@lib</em>. Using the configuration we declared earlier, TypeScript won’t pick them up. We can, however, write a new file <em>lib.d.ts</em> and put it in <em>@types</em>, and from there, refer to the version we want to include:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">/// &lt;reference path="../@lib/lib.v2.d.ts" /&gt;</code>&#13;
&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"lib"</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>A simple change from <em>“../@lib/lib.v2.d.ts”</em> to <em>“../@lib/lib.v1.d.ts”</em> will change the version we target, while we still maintain all library versions independently.</p>&#13;
&#13;
<p>If you are curious, try looking into the included library files from TypeScript. They are a treasure trove of external type definitions, and there is a lot to learn. If you use your editor to find references, for example, to <code>Object.keys</code>, you will see that this function exists in multiple locations, and based on your TypeScript configuration, the right file will be included. <a data-type="xref" href="#img-object-keys">Figure 12-5</a> shows how Visual Studio Code displays various file locations for <code>Object.keys</code>. TypeScript is so flexible that you can use the same techniques for your project, even extending TypeScript’s built-in types themselves (see <a data-type="xref" href="ch09.html#ch09_augmenting_globals">Recipe 9.7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="img-object-keys">&#13;
<img alt="tscb 1205" src="assets/tscb_1205.png"/>&#13;
<h6><span class="label">Figure 12-5. </span>Finding references to built-in types in Visual Studio Code shows you how TypeScript manages multiple versions of ECMAScript and the DOM</h6>&#13;
</div></figure>&#13;
&#13;
<p>In conclusion, providing multiple versions of a library’s types in TypeScript can be done by creating ambient module declarations for each version of the library and referencing the appropriate declaration in your TypeScript code. Hopefully, you will be able to use package managers in your project to manage different versions of libraries and their corresponding types, making it easier to handle dependencies and avoid conflicts.<a data-startref="ix_12-10-asciidoc4" data-type="indexterm" id="id1026"/><a data-startref="ix_12-10-asciidoc3" data-type="indexterm" id="id1027"/><a data-startref="ix_12-10-asciidoc2" data-type="indexterm" id="id1028"/><a data-startref="ix_12-10-asciidoc1" data-type="indexterm" id="id1029"/><a data-startref="ix_12-10-asciidoc0" data-type="indexterm" id="id1030"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="12.11 Knowing When to Stop" data-type="sect1"><div class="sect1" id="ch12_stop">&#13;
<h1>12.11 Knowing When to Stop</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id238">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="type development strategies" data-secondary="knowing when to stop" data-type="indexterm" id="ix_12-11-asciidoc0"/>Writing elaborate and complicated types is exhausting!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1031">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Don’t write elaborate and complicated types. TypeScript is gradual; use what makes you productive.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id203">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>I want to end this book with some general advice on how to stop at the right time. If you have read through the entire book and ended up here, you have read through more than one hundred recipes with a lot of advice about everyday TypeScript problems. Be it project setup, complicated situations where you need to find the right type, or workarounds when TypeScript runs into a situation where it’s too strict for its own good, we have covered it all.</p>&#13;
&#13;
<p>Solutions can get very complex, especially when we enter the area of conditional types and everything around them, like helper types, variadic tuple types, and string template literal types. TypeScript’s type system is undoubtedly powerful, especially if you understand that every decision, every feature, has its roots in the fact that JavaScript lies underneath it all. Creating a type system that gives you strong, static types for a programming language that is so inherently dynamic is an amazing achievement. I have nothing but the deepest admiration for the bright minds in Redmond who made all of this possible.</p>&#13;
&#13;
<p>However, undeniably, things can get very complicated at times. Types can be hard to read or create, and the fact that the type system is its own Turing-complete meta-programming system that needs testing libraries doesn’t help. And developers take pride in understanding every aspect of their craft and tools, often preferring a complex type solution over simpler types that don’t give the same type safety but are ultimately easier to read and understand.</p>&#13;
&#13;
<p><a data-primary="Type Challenges" data-type="indexterm" id="id1032"/>A project that goes into the nitty-gritty of the type system is called <a href="https://tsch.js.org">Type Challenges</a>. It’s a fantastic project of brainteasers that show what’s possible with the type system. I fiddle around with some of the more challenging riddles, getting great ideas for how to explain the type system better. And while puzzles are fantastic for training a developer’s mind, most of them lack a significant grasp of real-world, everyday situations.</p>&#13;
&#13;
<p>And those are the situations where we often overlook TypeScript’s wonderful capability that you don’t often see in mainstream programming languages: its gradual adoption of types. Tools like <code>any</code>, generic type parameters, and type assertions and the fact that you can write simple JavaScript with a couple of comments make the barrier to entry so much lower. The latest effort from the TypeScript team and TC39 is to lower the barrier even more by adding <a href="https://oreil.ly/yQnIO">type annotations to JavaScript</a>, a proposal currently in discussion. The goal of this proposal is not to make JavaScript type safe but to remove compile steps if we want to have simple, easy-to-understand type annotations. JavaScript engines can treat them as comments, and type-checkers can get real information on the program’s semantics.</p>&#13;
&#13;
<p>As developers, project leaders, engineers, and architects, we should use this feature. Simple types are always better types: easier to understand and much easier to consume.</p>&#13;
&#13;
<p>The <a href="https://typescriptlang.org">TypeScript website</a> changed its claim from “JavaScript that scales” to “JavaScript with syntax for types,” which should give you an idea of how to approach TypeScript in projects: write JavaScript, annotate where necessary, write simple but comprehensive types, and use TypeScript as a way to document, understand, and communicate your software.</p>&#13;
&#13;
<p>I think TypeScript follows the <a href="https://oreil.ly/smytJ">Pareto principle</a>: 80% of type safety comes from 20% of its features. This doesn’t mean the rest of it is bad or unnecessary. We just spent one hundred recipes to understand situations where we effectively need TypeScript’s more advanced features. It should just give you an idea of where to put effort. Don’t run into advanced TypeScript trickery on every occasion. Monitor if loser types are a problem. Estimate the effort to change types in your program, and make well-informed decisions. Also know that in a refinement process (see <a data-type="xref" href="#ch12_refining_types">Recipe 12.2</a>), the reason for multiple steps is to easily be able to stop.<a data-startref="ix_12-11-asciidoc0" data-type="indexterm" id="id1033"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id971"><sup><a href="ch12.html#id971-marker">1</a></sup> Fluent interfaces allow for chainable operations by returning the instance with every method call.</p></div></div></section></body></html>