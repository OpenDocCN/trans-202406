<html><head></head><body><section data-pdf-bookmark="Chapter 10. Pod and Container Security" data-type="chapter" epub:type="chapter"><div class="chapter" id="pod_and_container_security">&#13;
<h1><span class="label">Chapter 10. </span>Pod and Container Security</h1>&#13;
&#13;
&#13;
<p>When it comes to pod security via the Kubernetes API, you have two main options at your disposal: Pod Security Admission and RuntimeClass. In this chapter, we review the purpose and use of each API and provide best practices for their use.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pod Security Admission Controller" data-type="sect1"><div class="sect1" id="id86">&#13;
<h1>Pod Security Admission Controller</h1>&#13;
&#13;
<p>This cluster-wide resource creates a single place to define and manage&#13;
all the security-sensitive fields found in pod specifications. Prior to&#13;
the creation of the Pod Security Admission resource, cluster administrators and/or&#13;
users used PodSecurityPolicy, which was complex and could be challenging to&#13;
set up correctly. Before PodSecurityPolicy, users&#13;
would need to independently define&#13;
individual <code>SecurityContext</code>&#13;
settings for each pod or Deployment in their workloads or enable&#13;
bespoke admission controllers on the cluster to enforce some aspects of pod security.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <a data-primary="security" data-secondary="Pod Security Admission controller" data-type="indexterm" id="security-pod-sec-admin"/><a data-primary="Pod Security Admission controller" data-type="indexterm" id="pod-secure-admin"/><a data-primary="PodSecurityPolicy API" data-type="indexterm" id="id793"/>Pod Security Admission controller replaced the beta PodSecurityPolicy API starting with Kubernetes 1.22. PodSecurityPolicy was removed in Kubernetes 1.25. Pod Security Admission provides a simplified API for securing pods, but it does not provide complete feature parity with PodSecurityPolicy. For that you will need to install a more complete policy solution like the <a href="https://oreil.ly/0lVJP">Gatekeeper</a> project.</p>&#13;
</div>&#13;
&#13;
<p>Pod Security Admission was developed to address this complexity and make it&#13;
fairly straightforward for a cluster administrator to secure pods on their cluster.&#13;
While it is markedly less complicated than other solutions, Pod Security Admission&#13;
also has significant limitations in that it has coarse-grained permissions that&#13;
are applied at the namespace level. Though you can exempt specific users or&#13;
runtime classes from policy enforcement, you cannot enable different levels&#13;
of security for different pods or users within a namespace.</p>&#13;
&#13;
<p>Because of these limitations, many enterprises or administrators running multitenant&#13;
clusters will likely need to implement a policy solution like the <a href="https://oreil.ly/0lVJP">Gatekeeper</a> project. But especially for many smaller&#13;
single-tenant clusters, Pod Security Admission control may be appropriate.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enabling Pod Security Admission" data-type="sect2"><div class="sect2" id="id87">&#13;
<h2>Enabling Pod Security Admission</h2>&#13;
&#13;
<p>If your<a data-primary="security" data-secondary="Pod Security Admission controller" data-tertiary="enabling" data-type="indexterm" id="id794"/><a data-primary="Pod Security Admission controller" data-secondary="enabling" data-type="indexterm" id="id795"/><a data-primary="enabling Pod Security Admission controller" data-type="indexterm" id="id796"/> cluster is Kubernetes 1.22 or newer, Pod Security Admission is likely to be enabled. You can&#13;
check the version of your cluster using the <code>kubectl version</code> command. If you are running on an older&#13;
version of Kubernetes, we recommend updating since such older versions are no longer actively supported by&#13;
the Kubernetes project, which puts you at risk for unpatched security vulnerabilities.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Proceed with caution when enabling Pod Security Admission control on existing clusters because it’s&#13;
potentially workload blocking if adequate preparation isn’t done at the outset. Consider starting with the <code>warn</code> and <code>audit</code> enforcement modes to ensure that your policy works as expected.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pod Security levels" data-type="sect2"><div class="sect2" id="id216">&#13;
<h2>Pod Security levels</h2>&#13;
&#13;
<p>The<a data-primary="security" data-secondary="Pod Security Admission controller" data-tertiary="security levels" data-type="indexterm" id="security-pod-sec-admin-level"/><a data-primary="Pod Security Admission controller" data-secondary="security levels" data-type="indexterm" id="pod-secure-admin-level"/> Pod Security Admission controller simplifies security configuration by implementing three different policy levels for administrators to choose from. Each security level contains a collection of different&#13;
rules for restricting pod configurations. The details of the security levels can be found in the <a href="https://oreil.ly/3bKXr">Kubernetes documentation</a>.</p>&#13;
&#13;
<p>The three Pod Security Standard levels are:</p>&#13;
<dl>&#13;
<dt><code>privileged</code></dt>&#13;
<dd>&#13;
<p>Effectively no restrictions. It matches the default behavior of a Kubernetes cluster with no pod security enabled.</p>&#13;
</dd>&#13;
<dt><code>baseline</code></dt>&#13;
<dd>&#13;
<p>Protects against known privilege escalations and other security issues.</p>&#13;
</dd>&#13;
<dt><code>restricted</code></dt>&#13;
<dd>&#13;
<p>The current community best practice for pod security.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>When starting out with policy, it may be tempting to immediately start enforcing the <code>restricted</code> level&#13;
for all namespaces, but it is important to note that preexisting configurations in the cluster may&#13;
break, and community solutions or software provided by other third parties may not work correctly.</p>&#13;
&#13;
<p>In addition to the security levels, the Pod Security Admission controller provides three levels of activation&#13;
for the policy. The <code>enforce</code> level actively blocks pods from being created if they don’t match the security level. The <code>warn</code> level provides a warning to a user that their pod violates policy but doesn’t block it&#13;
from being created. The <code>audit</code> level logs policy violations but doesn’t provide user&#13;
feedback.</p>&#13;
&#13;
<p>Finally, each security level is versioned to match a particular Kubernetes version (e.g., <code>v1.25</code>). It’s&#13;
important to note that while the security level is associated with a Kubernetes version, it is available&#13;
in other Kubernetes versions: you can use the <code>v1.25</code> security level in a Kubernetes 1.26 cluster. The&#13;
versions follow the same three-version deprecation policy as any other Kubernetes component. There is&#13;
also a <code>latest</code> version that tracks whatever is the most up-to-date policy. However, as with&#13;
using <code>latest</code> in container images, this is discouraged because your security policy will change&#13;
when the cluster is upgraded, which means that you could break your cluster by adopting a new policy&#13;
unexpectedly. Instead, incremental upgrading of security policy after a cluster upgrade is a best&#13;
practice.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It’s important to note that the <code>warn</code> level provides warnings only in tools that support warnings, like <code>kubectl</code>. If you are using other tools for deployment, especially CI/CD automation, the warnings may not be surfaced to your users. In such situations, you may want to combine some sort of linter that examines the configurations before they are checked in along with pod security <a data-primary="security" data-secondary="Pod Security Admission controller" data-startref="security-pod-sec-admin-level" data-tertiary="security levels" data-type="indexterm" id="id797"/><a data-primary="Pod Security Admission controller" data-secondary="security levels" data-startref="pod-secure-admin-level" data-type="indexterm" id="id798"/>audit.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Activating Pod Security Using Namespace Labels" data-type="sect2"><div class="sect2" id="id88">&#13;
<h2>Activating Pod Security Using Namespace Labels</h2>&#13;
&#13;
<p>The<a data-primary="security" data-secondary="Pod Security Admission controller" data-tertiary="activating with namespace labels" data-type="indexterm" id="security-pod-sec-admin-activate"/><a data-primary="Pod Security Admission controller" data-secondary="activating with namespace labels" data-type="indexterm" id="pod-secure-admin-activate"/><a data-primary="namespaces" data-secondary="activating Pod Security" data-type="indexterm" id="namespace-activate"/><a data-primary="activating Pod Security" data-type="indexterm" id="activate-pod-security"/><a data-primary="labels" data-secondary="activating Pod Security" data-type="indexterm" id="label-activate"/> activation of Pod Security is done on a per-namespace basis by adding labels to the namespaces.&#13;
You can do this in your namespace YAML by adding labels as shown in the following example.&#13;
We will start with a configuration that simply audits existing usage at the baseline security level:</p>&#13;
&#13;
<pre data-type="programlisting">...&#13;
  metadata:&#13;
    labels:&#13;
      # Start with enforce and warn unrestricted so as not to&#13;
      # interfere with existing users&#13;
      pod-security.kubernetes.io/enforce: privileged&#13;
      pod-security.kubernetes.io/enforce-version: v1.25&#13;
      pod-security.kubernetes.io/warn: privileged&#13;
      pod-security.kubernetes.io/warn-version: v1.25&#13;
&#13;
      # Turn on baseline auditing&#13;
      pod-security.kubernetes.io/audit: baseline&#13;
      pod-security.kubernetes.io/audit-version: v1.25</pre>&#13;
&#13;
<p>Once this configuration is applied to all namespaces, you will start seeing audit information&#13;
in the cluster audit logs. This will give you a sense of your cluster’s level of compliance. If your cluster is very far out of compliance, you will likely&#13;
need to identify the owners of various workloads and work with them to bring their&#13;
workloads into compliance. Because the enforcement is per-namespace, you can work with teams&#13;
individually and move to enforcement as their workloads become compliant.</p>&#13;
&#13;
<p>Ultimately, your final security posture is a function of your teams and their workloads, so it&#13;
is difficult to identify a single best practice for pod security configuration. However,&#13;
for most users, setting <code>audit</code> and <code>warn</code> to <code>restricted</code> and <code>enforce</code> to <code>baseline</code> is a&#13;
pretty good place to start. It will give you visibility into potentially vulnerable&#13;
configurations while enabling enforcement to prevent the most egregious<a data-primary="security" data-secondary="Pod Security Admission controller" data-startref="security-pod-sec-admin" data-type="indexterm" id="id799"/><a data-primary="Pod Security Admission controller" data-startref="pod-secure-admin" data-type="indexterm" id="id800"/><a data-primary="security" data-secondary="Pod Security Admission controller" data-startref="security-pod-sec-admin-activate" data-tertiary="activating with namespace labels" data-type="indexterm" id="id801"/><a data-primary="Pod Security Admission controller" data-secondary="activating with namespace labels" data-startref="pod-secure-admin-activate" data-type="indexterm" id="id802"/><a data-primary="namespaces" data-secondary="activating Pod Security" data-startref="namespace-activate" data-type="indexterm" id="id803"/><a data-primary="activating Pod Security" data-startref="activate-pod-security" data-type="indexterm" id="id804"/><a data-primary="labels" data-secondary="activating Pod Security" data-startref="label-activate" data-type="indexterm" id="id805"/> violations.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Workload Isolation and RuntimeClass" data-type="sect1"><div class="sect1" id="id89">&#13;
<h1>Workload Isolation and RuntimeClass</h1>&#13;
&#13;
<p>Container runtimes <a data-primary="security" data-secondary="workload isolation/RuntimeClass" data-type="indexterm" id="security-workload"/><a data-primary="container runtime security" data-type="indexterm" id="container-runtime-security"/><a data-primary="workload isolation" data-type="indexterm" id="workload"/><a data-primary="RuntimeClass" data-type="indexterm" id="runtime-class"/>are still largely considered an insecure workload isolation&#13;
boundary. There is no clear path to whether the most common runtimes of&#13;
today will ever be recognized as secure. The momentum and interest among those in the industry toward&#13;
Kubernetes has led to the development of different&#13;
container runtimes that offer varying levels of isolation. Some&#13;
are based on familiar and trusted technology stacks, whereas others are&#13;
a completely new attempt to tackle the problem. Open source projects&#13;
like Kata containers, gVisor, and Firecracker tout the promise of&#13;
stronger workload isolation. These specific projects are either based on&#13;
nested virtualization (running a super lightweight virtual machine within a virtual machine) or&#13;
system call filtering and servicing. There has also been recent interest in&#13;
the sandbox provided by the WebAssembly virtual machine, which was originally&#13;
built for running in the browser but is seeing increased usage on the server&#13;
side. The <code>containerd</code> project, one of the most popular container runtimes,&#13;
now supports WebAssembly (WASM) based containers. Additionally RuntimeClass&#13;
may be needed to choose a container runtime based on specific hardware&#13;
capabilities like interacting with a GPU for artificial intelligence and&#13;
machine learning workloads.</p>&#13;
&#13;
<p>The introduction of these container runtimes that offer different workload&#13;
isolation allows users to choose different runtimes based on their isolation&#13;
guarantees in the same cluster. For example, you could have trusted and&#13;
untrusted workloads running in the same cluster in different container runtimes.</p>&#13;
&#13;
<p>RuntimeClass was introduced into Kubernetes as an API to allow container runtime&#13;
selection. It is used to represent one of the supported container&#13;
runtimes on the cluster when it has been configured by the cluster administrator.&#13;
As a Kubernetes user, you can define specific runtime classes for your&#13;
workloads by using the &#13;
<span class="keep-together">RuntimeClassName</span> in the pod specification.&#13;
How this is implemented under the hood is that the RuntimeClass designates&#13;
a <code>RuntimeHandler</code> that is passed to the Container Runtime Interface (CRI)&#13;
to implement. Node labeling or node taints can then be used in&#13;
conjunction with nodeSelectors or tolerations to ensure that the workload&#13;
lands on a node capable of supporting the desired RuntimeClass. <a data-type="xref" href="#runtimeclass_flow_diagram">Figure 10-1</a> demonstrates how a kubelet uses RuntimeClass when launching pods.</p>&#13;
&#13;
<figure><div class="figure" id="runtimeclass_flow_diagram">&#13;
<img alt="RunTimeClass flow diagram" src="assets/kbp2_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span><code>RuntimeClass</code> flow diagram</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using RuntimeClass" data-type="sect2"><div class="sect2" id="id362">&#13;
<h2>Using RuntimeClass</h2>&#13;
&#13;
<p>If a cluster administrator has set up different RuntimeClasses, you can use them by specifying&#13;
<code>runtimeClassName</code> in the pod specification; for example:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">runtimeClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">firecracker</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Runtime Implementations" data-type="sect2"><div class="sect2" id="id363">&#13;
<h2>Runtime Implementations</h2>&#13;
&#13;
<p>Following are some open source container runtime implementations that offer different levels of security&#13;
and isolation for your consideration. This list is intended as a guide and is by no means exhaustive:</p>&#13;
<dl>&#13;
<dt><a href="https://oreil.ly/1wxU1">CRI containerd</a></dt>&#13;
<dd>&#13;
<p>An API facade for container runtimes with an emphasis on simplicity, robustness, and portability.</p>&#13;
</dd>&#13;
<dt><a href="https://oreil.ly/OiXpP">cri-o</a></dt>&#13;
<dd>&#13;
<p>A purpose-built, lightweight Open Container Initiative (OCI)-based implementation of a container runtime for Kubernetes.</p>&#13;
</dd>&#13;
<dt><a href="https://oreil.ly/on3Ge">Firecracker</a></dt>&#13;
<dd>&#13;
<p>Built on top of the Kernel-based Virtual Machine (KVM),  this virtualization technology allows you to launch microVMs in nonvirtualized environments very quickly using the security and isolation of traditional VMs.</p>&#13;
</dd>&#13;
<dt><a href="https://oreil.ly/ZZt3n">gVisor</a></dt>&#13;
<dd>&#13;
<p>An OCI-compatible sandbox runtime that runs containers with a new user-space kernel, which provides a low overhead and secure, isolated container runtime.</p>&#13;
</dd>&#13;
<dt><a href="https://oreil.ly/giOxk">Kata Containers</a></dt>&#13;
<dd>&#13;
<p>A secure container runtime that provides VM-like security and isolation by running lightweight VMs that feel and operate like <span class="keep-together">containers.</span></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Workload Isolation and RuntimeClass Best Practices" data-type="sect2"><div class="sect2" id="id90">&#13;
<h2>Workload Isolation and RuntimeClass Best Practices</h2>&#13;
&#13;
<p>The following<a data-primary="best practices" data-secondary="workload isolation/RuntimeClass" data-type="indexterm" id="id806"/> best practices will help you to avoid common workload isolation and RuntimeClass pitfalls:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Implementing different workload isolation environments via RuntimeClass will complicate your operational environment. This means that workloads might not be portable across different container runtimes given the nature of the isolation they provide. Understanding the matrix of supported features across different runtimes can be complicated and&#13;
will lead to poor user experience. We recommend having separate clusters, each with a single runtime, to avoid confusion, if possible.</p>&#13;
</li>&#13;
<li>&#13;
<p>Workload isolation doesn’t mean secure multitenancy. Even though you might have&#13;
implemented a secure container runtime, this doesn’t mean that the Kubernetes cluster and APIs&#13;
have been secured in the same fashion. You must consider the total surface area of Kubernetes end to end.&#13;
Just because you have an isolated workload doesn’t mean that it cannot be modified by a bad actor via&#13;
the <span class="keep-together">Kubernetes API.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Tooling across different runtimes is inconsistent. You might have users who rely on&#13;
container runtime tooling for debugging and introspection. Having different runtimes means that you&#13;
might no longer be able to run <code>docker ps</code> to list running containers. This leads to confusion&#13;
and complications<a data-primary="security" data-secondary="workload isolation/RuntimeClass" data-startref="security-workload" data-type="indexterm" id="id807"/><a data-primary="container runtime security" data-startref="container-runtime-security" data-type="indexterm" id="id808"/><a data-primary="workload isolation" data-startref="workload" data-type="indexterm" id="id809"/><a data-primary="RuntimeClass" data-startref="runtime-class" data-type="indexterm" id="id810"/> when <span class="keep-together">troubleshooting.</span></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Pod and Container Security Considerations" data-type="sect1"><div class="sect1" id="id364">&#13;
<h1>Other Pod and Container Security Considerations</h1>&#13;
&#13;
<p>In addition to Pod Security Admission control and workload isolation, here are some other tools you&#13;
may consider when determining how to handle pod and container security.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission Controllers" data-type="sect2"><div class="sect2" id="id91">&#13;
<h2>Admission Controllers</h2>&#13;
&#13;
<p>The <a data-primary="security" data-secondary="admission controllers" data-type="indexterm" id="id811"/><a data-primary="admission controllers" data-type="indexterm" id="id812"/>previous discussion of pod security was powered by the Pod Security Admission controller, but there are many other admission&#13;
controllers that you can choose from in the cloud native ecosystem. If you find&#13;
the Pod Security Admission controller to be too restrictive, many other options provide&#13;
more sophisticated policy solutions.&#13;
For more information on admission control, refer to <a data-type="xref" href="ch17.html#admission_control_and_authorization">Chapter 17</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Intrusion and Anomaly Detection Tooling" data-type="sect2"><div class="sect2" id="id92">&#13;
<h2>Intrusion and Anomaly Detection Tooling</h2>&#13;
&#13;
<p>We’ve<a data-primary="security" data-secondary="intrusion and anomaly detection" data-type="indexterm" id="id813"/><a data-primary="intrusion and anomaly detection" data-type="indexterm" id="id814"/><a data-primary="Falco" data-type="indexterm" id="id815"/> covered security policies and container runtimes, but what happens&#13;
when you want to introspect and enforce policy within the container&#13;
runtime? There are open source tools that can do this and more. They&#13;
operate by either listening and filtering Linux system calls or by&#13;
utilizing a Berkeley Packet Filter (BPF). One such tool is <a href="https://oreil.ly/9KOeg">Falco</a>, a Cloud Native Computing Foundation (CNCF)&#13;
project that installs as a DaemonSet and allows you to configure&#13;
and enforce policy during execution. Falco is just one approach. We&#13;
encourage you to explore the tooling in this space to see what works for you.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id365">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we covered in depth both the Pod Security Admission control and&#13;
the RuntimeClass APIs with which you can configure a granular level of&#13;
security for your workloads. We have also taken a look at some open source&#13;
ecosystem tooling that you can use to monitor and enforce policy within&#13;
the container runtime. We have provided a thorough overview for you&#13;
to make an informed decision about providing the level of security best suited for your workload needs.</p>&#13;
</div></section>&#13;
</div></section></body></html>