["```\ngetUsers()\n  .then(\n    // This function is called when the user list has been loaded.\n    userList => {\n      console.log('User List:');\n      userList.forEach(user => {\n        console.log(user.name);\n      });\n    }\n  ).catch(error => {\n    console.error('Failed to load the user list:', error);\n  });\n```", "```\n/**\n * Loads an image. If there's an error loading the image, uses a fallback\n * image URL instead.\n *\n * @param url The image URL to load\n * @param fallbackUrl The fallback image to load if there's an error\n * @returns a Promise that resolves to an Image element to insert into the DOM\n */\nfunction loadImage(url, fallbackUrl) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n\n    // Attempt to load the image from the given URL\n    image.src = url;\n\n    // The image triggers the 'load' event when it is successfully loaded.\n    image.addEventListener('load', () => {\n      // The now-loaded image is used to resolve the Promise\n      resolve(image);\n    });\n\n    // If an image failed to load, it triggers the 'error' event.\n    image.addEventListener('error', error => {\n      // Reject the Promise in one of two scenarios:\n      // (1) There is no fallback URL.\n      // (2) The fallback URL is the one that failed.\n      if (!fallbackUrl || image.src === fallbackUrl) {\n        reject(error);\n      } else {\n        // If this is executed, it means the original image failed to load.\n        // Try to load the fallback.\n        image.src = fallbackUrl;\n      }\n    });\n  });\n}\n```", "```\nloadImage('https://example.com/profile.jpg', 'https://example.com/fallback.jpg')\n  .then(image => {\n    // container is an element in the DOM where the image will go\n    container.appendChild(image);\n  }).catch(error => {\n    console.error('Image load failed');\n  });\n```", "```\n/**\n * Loads the post titles for a given user ID.\n * @param userId is the ID of the user whose posts you want to load\n * @returns a Promise that resolves to an array of post titles\n */\nfunction getPostTitles(userId) {\n  return getUser(userId)\n    // Callback is called with the loaded user object\n    .then(user => {\n      console.log(`Getting posts for ${user.name}`);\n      // This Promise is also returned from .then\n      return getPosts(user);\n    })\n    // Calling then on the getPosts' Promise\n    .then(posts => {\n      // Returns another Promise that will resolve to an array of post titles\n      return posts.map(post => post.title);\n    })\n    // Called if either getUser or getPosts are rejected\n    .catch(error => {\n      console.error('Error loading data:', error);\n    });\n}\n```", "```\n// A function must be declared with the async keyword\n// in order to use await in its body.\nasync function listUsers() {\n  try {\n    // Equivalent to getUsers().then(...)\n    const userList = await getUsers();\n    console.log('User List:');\n    userList.forEach(user => {\n      console.log(user.name);\n    });\n  } catch (error) { // Equivalent to .catch(...)\n    console.error('Failed to load the user list:', error);\n  }\n}\n```", "```\n// Loading three users at once\nPromise.all([\n  getUser(1),\n  getUser(2),\n  getUser(3)\n]).then(users => {\n  // users is an array of user objectsâ€”the values returned from\n  // the parallel getUser calls\n}).catch(error => {\n  // If any of the above Promises are rejected\n  console.error('One of the users failed to load:', error);\n});\n```", "```\nPromise.allSettled([\n  getUser(1),\n  getUser(2),\n  getUser(3)\n]).then(results => {\n  results.forEach(result => {\n    if (result.status === 'fulfilled') {\n      console.log('- User:', result.value.name);\n    } else {\n      console.log('- Error:', result.reason);\n    }\n  });\n});\n// No catch necessary here because allSettled is always fulfilled.\n```", "```\nconst animationSeconds = 2; // Animate over 2 seconds\nconst fps = 60; // A nice, smooth animation\n\n// The time interval between each frame\nconst frameInterval = 1000 / fps;\n\n// The total number of frames for the animation\nconst frameCount = animationSeconds * fps;\n\n// The amount to adjust the opacity by in each frame\nconst opacityIncrement = 1 / frameCount;\n\n// The timestamp of the last frame\nlet lastTimestamp;\n\n// The starting opacity value\nlet opacity = 1;\n\nfunction fade(timestamp) {\n  // Set the last timestamp to now if there isn't an existing one.\n  if (!lastTimestamp) {\n    lastTimestamp = timestamp;\n  }\n\n  // Calculate how much time has elapsed since the last frame.\n  // If not enough time has passed yet, schedule another call of this\n  // function and return.\n  const elapsed = timestamp - lastTimestamp;\n  if (elapsed < frameInterval) {\n    requestAnimationFrame(animate);\n    return;\n  }\n\n  // Time for a new animation frame. Remember this timestamp.\n  lastTimestamp = timestamp;\n\n  // Adjust the opacity value and make sure it doesn't go below 0.\n  opacity = Math.max(0, opacity - opacityIncrement)\n  box.style.opacity = opacity;\n\n  // If the opacity hasn't reached the target value of 0, schedule another\n  // call to this function.\n  if (opacity > 0) {\n    requestAnimationFrame(animate);\n  }\n}\n\n// Schedule the first call to the animation function.\nrequestAnimationFrame(fade);\n```", "```\n/**\n * Sends a GET request to the specified URL. Returns a Promise that will resolve to\n * the JSON body parsed as an object, or will reject if there is an error or the\n * response is not valid JSON.\n *\n * @param url The URL to request\n * @returns a Promise that resolves to the response body\n */\nfunction loadJSON(url) {\n  // Create a new Promise object, performing the async work inside the\n  // constructor function.\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n\n    // If the request is successful, parse the JSON response and\n    // resolve the Promise with the resulting object.\n    request.addEventListener('load', event => {\n      // Wrap the JSON.parse call in a try/catch block just in case\n      // the response body is not valid JSON.\n      try {\n        resolve(JSON.parse(event.target.responseText));\n      } catch (error) {\n        // There was an error parsing the response body.\n        // Reject the Promise with this error.\n        reject(error);\n      }\n    });\n\n    // If the request fails, reject the Promise with the\n    // error that was emitted.\n    request.addEventListener('error', error => {\n      reject(error);\n    });\n\n    // Set the target URL and send the request.\n    request.open('GET', url);\n    request.send();\n  });\n}\n```", "```\n// Using .then\nloadJSON('/api/users/1').then(user => {\n  console.log('Got user:', user);\n})\n\n// Using await\nconst user = await loadJSON('/api/users/1');\nconsole.log('Got user:', user);\n```"]