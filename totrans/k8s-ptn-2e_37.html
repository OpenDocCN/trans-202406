<html><head></head><body><section data-pdf-bookmark="Chapter 30. Image Builder" data-type="chapter" epub:type="chapter"><div class="chapter" id="ImageBuilder">&#13;
<h1><span class="label">Chapter 30. </span>Image Builder</h1>&#13;
&#13;
&#13;
<p>Kubernetes<a data-primary="Image Builder" data-type="indexterm" id="imgbld30"/> is a general-purpose orchestration engine, suitable not only for running applications but also for building container images.&#13;
The <em>Image Builder</em> pattern explains why it makes sense to build the container images within the cluster and what techniques exist today for creating images within Kubernetes.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902080840448">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>All<a data-primary="problems" data-secondary="images, creating within Kubernetes" data-type="indexterm" id="idm45902080838768"/> the patterns in this book so far have been about operating applications on Kubernetes. You’ve learned how to develop and prepare applications to be good cloud native citizens. However, what about <em>building</em> the application itself? The classic approach is to build container images outside the cluster, push them to a registry, and refer to them in the Kubernetes Deployment descriptors. However, building within the cluster has several advantages.</p>&#13;
&#13;
<p>If your company policies allow, having only one cluster for everything is advantageous. Building and running applications in one place can considerably reduce maintenance costs. It also simplifies capacity planning and reduces platform resource overhead.</p>&#13;
&#13;
<p>Typically, continuous integration (CI) systems<a data-primary="CI (continuous integration) systems" data-type="indexterm" id="idm45902080836080"/><a data-primary="continuous integration (CI) systems" data-type="indexterm" id="idm45902080835360"/> like Jenkins are used to build images.&#13;
Building with a CI system is a scheduling problem for efficiently finding free computing resources for build jobs. At the heart of Kubernetes is a highly sophisticated<a data-primary="scheduler" data-secondary="benefits of" data-type="indexterm" id="idm45902080834544"/> scheduler that is a perfect fit for this kind of scheduling challenge.</p>&#13;
&#13;
<p>Once we move to<a data-primary="continuous delivery (CD)" data-type="indexterm" id="idm45902080832784"/><a data-primary="CD (continuous delivery)" data-type="indexterm" id="idm45902080832064"/> continuous delivery (CD), where we transition from <em>building</em> images to <em>running</em> containers, if the build happens within the same cluster, both phases share the same infrastructure and ease transition. For example, let’s assume that a new security vulnerability is discovered in a base image used for all applications. As soon as your team has fixed this issue, you have to rebuild all the application images that depend on this base image and update your running applications with the new image. When implementing this <em>Image Builder</em> pattern, the cluster knows both—the build of an image and its deployment—and can automatically do a redeployment if a base image changes. In <a data-type="xref" href="#image-builder-openshift">“OpenShift Build”</a>, we’ll see how OpenShift implements such automation.</p>&#13;
&#13;
<p>Having seen the benefits of building images on the platform, let’s look at what tech<span class="keep-together">niques</span> exist for creating images in a Kubernetes cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902080827744">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>As of 2023, a whole zoo of in-cluster container image-build techniques exists. While all target the same goal of building images, each tool adds a twist, making it unique and suitable for specific situations.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-image-builder-levels">Figure 30-1</a> contains the essential image-building techniques as of 2023 for building container images within a Kubernetes cluster.</p>&#13;
&#13;
<figure class="width-60"><div class="figure" id="img-image-builder-levels">&#13;
<img alt="kup2 3001" src="assets/kup2_3001.png"/>&#13;
<h6><span class="label">Figure 30-1. </span>Container image builds within Kubernetes</h6>&#13;
</div></figure>&#13;
&#13;
<p>This chapter contains a brief overview of most of these techniques. You can find more details about these tools by following the links in <a data-type="xref" href="#image-builder-more-information">“More Information”</a>.&#13;
Please note that while many of the tools described here are matured and used in production projects, there are no guarantees that some of those projects still exist when you read these lines.&#13;
Before using one, you should check whether the project is still alive and supported.</p>&#13;
&#13;
<p>Categorizing these tools is not straightforward as they are partly overlapping or dependent on one another.&#13;
Each of these tools has a unique focus, but for in-cluster builds, we can identify these high-level categories:</p>&#13;
<dl>&#13;
<dt>Container image builder</dt>&#13;
<dd>&#13;
<p>These tools create container images within the cluster. There is some overlap of these tools, and they vary, but all of them can run without privileged access. You can also run these tools outside the cluster as CLI programs. The sole purpose of&#13;
these builders is to create a container image, but they don’t care about application redeployments.</p>&#13;
</dd>&#13;
<dt>Build orchestration</dt>&#13;
<dd>&#13;
<p>These tools operate on a higher level of abstraction and eventually trigger the container image builder for creating images. They also support build-related tasks like updating the deployment descriptors after the image has been built. CI/CD systems, as described previously, are typical examples of orchestrators.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Image Builder" data-type="sect2"><div class="sect2" id="image-builder-builders">&#13;
<h2>Container Image Builder</h2>&#13;
&#13;
<p>One<a data-primary="container image builder" data-type="indexterm" id="idm45902080815504"/> of the essential prerequisites for building images from within a cluster is creating images without having privileged access to the node host.&#13;
Various tools exists that fulfill this prerequisite, and they can be roughly categorized according to how the container image is specified and built.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902080814208">&#13;
<h1>Rootless Builds</h1>&#13;
<p>When<a data-primary="rootless builds" data-type="indexterm" id="idm45902080812912"/> building within Kubernetes, the cluster has complete control over the build process. Because of this, the cluster needs higher security standards to protect against potential vulnerabilities. One way to improve security during builds is to run them without root privileges, a practice known as <em>rootless builds</em>. There are many ways to achieve rootless builds in Kubernetes that allow you to build without elevated privileges.</p>&#13;
&#13;
<p>Docker successfully brought container technologies to the masses thanks to its unmatched user experience. Docker is based on a client-server architecture with a<a data-primary="daemons" data-secondary="Dockerfile-based builders" data-type="indexterm" id="Ddocker30"/> daemon running in the background and taking instructions via a REST API from its client. This daemon needs root privileges mainly for network and volume management reasons. Unfortunately, this imposes a security risk, as untrusted processes can escape their container, and an intruder could get control of the whole host. This concern applies not only when running containers but also when building container images because building also happens within a container when the Docker daemon executes arbitrary commands.</p>&#13;
&#13;
<p>Most of the in-cluster build techniques described in this chapter allow container images to be built in a nonprivileged mode to reduce that attack surface, which is very useful for locked-down Kubernetes clusters.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dockerfile-Based builders" data-type="sect3"><div class="sect3" id="idm45902080808784">&#13;
<h3>Dockerfile-Based builders</h3>&#13;
&#13;
<p>The<a data-primary="Dockerfile-based builders" data-type="indexterm" id="idm45902080807488"/> following builders are based on the well-known Dockerfile format for defining the build instructions.&#13;
All of them are compatible on a Dockerfile level, and they either work completely without talking to a background daemon or talk via a REST API remotely with a build process that is running in a nonprivileged mode:</p>&#13;
<dl>&#13;
<dt>Buildah and Podman</dt>&#13;
<dd>&#13;
<p>Buildah<a data-primary="Buildah" data-type="indexterm" id="idm45902080804736"/><a data-primary="Podman" data-type="indexterm" id="idm45902080804000"/> and its sister Podman are potent tools for building OCI-compliant images without a Docker daemon. They create images locally within the container before pushing them to an image registry. Buildah and Podman overlap in functionality, with Buildah focusing on building container images (though Podman can also create container images by wrapping the Buildah API). The difference is shaped more clearly in this <a href="https://oreil.ly/kSgHk">README</a>.</p>&#13;
</dd>&#13;
<dt>Kaniko</dt>&#13;
<dd>&#13;
<p>Kaniko<a data-primary="Kaniko" data-type="indexterm" id="idm45902080800672"/> is one backbone of the Google Cloud Build service and is deliberately targeted for running as a build container in Kubernetes. Within the build container, Kaniko still runs with UID 0, but the Pod holding the container itself is nonprivileged. This requirement prevents the usage of Kaniko in clusters that disallow running as a root user in a container, like in OpenShift. We see Kaniko in action in <a data-type="xref" href="#image-builder-build-pod">“Build Pod”</a>.</p>&#13;
</dd>&#13;
<dt>BuildKit</dt>&#13;
<dd>&#13;
<p>Docker<a data-primary="BuildKit" data-type="indexterm" id="idm45902080797680"/> extracted its build engine into a separate project, BuildKit, which can be used independently of Docker. It inherits from Docker its client-server architecture with a BuildKit daemon running in the background, waiting for build jobs. Usually, this daemon runs directly in the container that triggers the build, but it can also run in a Kubernetes cluster to allow distributed rootless builds. BuildKit introduces a Low-Level Build (LLB) definition format supported by multiple frontends. LLB allows complex build graphs and can be used for arbitrary complex build definitions. BuildKit also supports features that go beyond the original Dockerfile specification. In addition to Dockerfiles, BuildKit can use other frontends to define the container image’s content via LLB.<a data-primary="" data-startref="Ddocker30" data-type="indexterm" id="idm45902080796816"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Multilanguage builders" data-type="sect3"><div class="sect3" id="idm45902080795488">&#13;
<h3>Multilanguage builders</h3>&#13;
&#13;
<p>Many developers care only  that their application gets packaged as container images and not so much about how this is done.&#13;
To cover this use case, multilanguage builders exist to support many programming platforms.&#13;
They detect an existing project, like a Spring Boot application or generic Python build, and select an opinionated image build flow accordingly.</p>&#13;
&#13;
<p><em>Buildpacks</em> have been around since 2012 and were initially introduced by Heroku to allow you to push developer’s code directly to their platform. Cloud Foundry picked up that idea and created a fork of buildpacks that eventually led to the infamous <code>cf push</code> idiom that many considered the gold standard of Platform as a Service (PaaS).&#13;
In 2018, the different forks of Buildpacks united under the umbrella of the CNCF and are now known as<a data-primary="Cloud Native Buildpacks (CNB)" data-type="indexterm" id="idm45902080792432"/><a data-primary="CNB (Cloud Native Buildpacks)" data-type="indexterm" id="idm45902080791712"/> <em>Cloud Native Buildpacks</em> (CNB).&#13;
Besides individual buildpacks for different programming languages, CNB introduce a lifecycle for transforming source code to executable container images.</p>&#13;
&#13;
<p>The lifecycle can roughly be divided into three main phases:<sup><a data-type="noteref" href="ch30.html#idm45902080790064" id="idm45902080790064-marker">1</a></sup></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>In the <em>detect</em> phase, CNB iterate over a list of configured buildpacks. Each buildpack can decide whether it fits for the given source code. For example, a Java-based buildpack will raise its hand when it detects a Maven <em>pom.xml</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>All buildpacks that survived the detect phase will be called in the <em>build</em> phase to provide their part for the final, possibly compiled artifact. For example, a buildpack for a Node.js application calls <code>npm install</code> to fetch all required dependencies.</p>&#13;
</li>&#13;
<li>&#13;
<p>The last step in the CNB lifecycle is an <em>export</em> to the final OCI image that gets pushed to a registry.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>CNB target two personas. The primary audience includes <em>Developers</em> who want to deploy their code onto Kubernetes or any other container-based platform. The other is <em>Buildpack Authors</em>, who create individual buildpacks and group them into so-called <em>builders</em>.&#13;
You can choose from a list of prefactored buildpacks and builders or create your own for you and your team.&#13;
Developers can then pick up those buildpacks by referencing them when running the CNB lifecycle on their source code.&#13;
Several tools are available for executing this lifecycle; you’ll find a complete list at the <a href="https://oreil.ly/B07Et">Cloud Native Buildpacks site</a>.</p>&#13;
&#13;
<p>For using CNB within a Kubernetes cluster, the following tasks are helpful:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>pack</code> is a CLI command to configure and execute the CNB lifecycle locally. It requires access to an OCI container runtime engine like Docker or Podman to run Builder images that hold the list of buildpacks to use.</p>&#13;
</li>&#13;
<li>&#13;
<p>CI steps like Tekton build tasks or GitHub actions that call the lifecycle directly from a configured Builder image.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>kpack</code> comes with an Operator that allows you to configure and run buildpacks within a Kubernetes cluster. All the core concepts of CNB, like Builder or Buildpacks, are reflected directly as CustomResourceDefinitions. <code>kpack</code> is not yet part of the CNB project itself, but as of 2023 is about to be absorbed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Many other platforms and projects have adopted CNB as their build platform of choice. For example, Knative Functions<a data-primary="Knative" data-secondary="functions" data-type="indexterm" id="idm45902080775024"/> use CNB under the hood to transform Function code to container images before they get deployed as<a data-primary="Knative" data-secondary="CNB platform" data-type="indexterm" id="idm45902080773808"/> Knative services.</p>&#13;
&#13;
<p><em>OpenShift’s Source-to-Image</em> (S2I) is another opinionated building method with builder images. S2I takes you directly from your application’s source code to executable container images. We will look closely at S2I in <a data-type="xref" href="#image-builder-openshift">“OpenShift Build”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Specialized builders" data-type="sect3"><div class="sect3" id="idm45902080770656">&#13;
<h3>Specialized builders</h3>&#13;
&#13;
<p>Finally, specialized builders with an opinionated way of creating images exist for specific situations. While their scope is narrow, their strong opinion allows for a highly optimized build flow that increases flexibility and decreases build times.&#13;
All these builders perform a rootless build.&#13;
They create the container image without running arbitrary commands as with a Dockerfile <code>RUN</code> directive. They create the image layers locally with the application artifacts and push them directly to a container image registry:</p>&#13;
<dl>&#13;
<dt>Jib</dt>&#13;
<dd>&#13;
<p>Jib<a data-primary="Jib" data-type="indexterm" id="idm45902080766288"/> is a pure Java library and build extension that integrates nicely with Java build tools like Maven or Gradle. It creates separate image layers directly for the Java build artifacts, its dependencies, and other static resources to optimize image rebuild times. Like the other builders, it speaks directly with a container image registry for the resulting images.</p>&#13;
</dd>&#13;
<dt>ko</dt>&#13;
<dd>&#13;
<p>For<a data-primary="ko" data-type="indexterm" id="idm45902080764144"/> creating images from Golang sources, ko is a great tool. It can directly create images from remote Git repositories and update Pod specifications to point to the image after it has been built and pushed to a registry.</p>&#13;
</dd>&#13;
<dt>Apko</dt>&#13;
<dd>&#13;
<p>Apko<a data-primary="Apko" data-type="indexterm" id="idm45902080762000"/> is a unique builder that uses Alpine’s Apk packages as building blocks instead of Dockerfile scripts. This strategy allows for the easy reuse of building blocks when creating multiple similar images.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This list is only a selection of the many specialized build techniques. All of them have a very narrow scope of what they can build.&#13;
The advantage of this opinionated approach is that they can optimize build time and image size because they know precisely about the domain in which they operate and can make strong assumptions.</p>&#13;
&#13;
<p>Now that we have seen some ways to build container images, let’s jump one abstraction level higher and see how we can embed the actual build in a broader context.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Build Orchestrators" data-type="sect2"><div class="sect2" id="idm45902080759760">&#13;
<h2>Build Orchestrators</h2>&#13;
&#13;
<p>Build orchestrators are CI and CD platforms like Tekton, Argo CD, or Flux.&#13;
Those platforms cover your application’s entire automated management lifecycle, including building, testing, releasing, deploying, security scanning, and much more.&#13;
There are excellent books that cover those platforms and bring it all together, so we won’t go into the details here.</p>&#13;
&#13;
<p>In addition to general-purpose CI and CD platforms, we can use more specialized orchestrators to create container images:</p>&#13;
<dl>&#13;
<dt>OpenShift builds</dt>&#13;
<dd>&#13;
<p>One<a data-primary="Red Hat OpenShift" data-secondary="build system" data-type="indexterm" id="idm45902080755968"/> of the oldest and most mature ways of building images in a Kubernetes cluster is the <em>OpenShift build</em> subsystem.&#13;
It allows you to build images in several ways.&#13;
We take a closer look at the OpenShift way of building images in <a data-type="xref" href="#image-builder-openshift">“OpenShift Build”</a>.</p>&#13;
</dd>&#13;
<dt>kbld</dt>&#13;
<dd>&#13;
<p>kbld<a data-primary="kbld" data-type="indexterm" id="idm45902080752096"/> is part of Carvel, a toolset for building, configuring, and deploying on Kubernetes. kbld is responsible for building containers with one of the builder technologies we described in <a data-type="xref" href="#image-builder-builders">“Container Image Builder”</a> and updating resource descriptors with a reference to the images that have been built. The technique for updating the YAML files is very similar to how ko works: kbld looks for <code>image</code> fields and sets their values to the coordinates of the freshly built image.</p>&#13;
</dd>&#13;
<dt>Kubernetes Job</dt>&#13;
<dd>&#13;
<p>You<a data-primary="Kubernetes Job" data-type="indexterm" id="idm45902080748352"/> can also use standard Kubernetes Jobs for triggering builds with any of the image builders from <a data-type="xref" href="#image-builder-builders">“Container Image Builder”</a>. Jobs are described in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.html#BatchJob">Chapter 7, “Batch Job”</a>. Such a Job wraps a build Pod specification for defining the runtime parts.&#13;
The build Pod picks up the source code from a remote source repository and uses one of the in-cluster builders to create the appropriate image. We’ll see such a Pod in action in <a data-type="xref" href="#image-builder-build-pod">“Build Pod”</a>.</p>&#13;
</dd>&#13;
</dl>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902080744224">&#13;
<h1>What Happened to Knative Build?</h1>&#13;
<p>In<a data-primary="Knative" data-secondary="build" data-type="indexterm" id="idm45902080742928"/> the first edition of this book, we described Knative Build as one possibility for creating container images from within the cluster.&#13;
As time has shown, Knative as an umbrella project was too small for the community, so Knative Build was split off from Knative and transformed into a new project, Tekton, with a much larger scope than only building container images. Tekton a is a full-featured CI solution that fully integrates into Kubernetes and uses CustomResourceDefinitions as described in<a data-primary="Operator" data-type="indexterm" id="idm45902080741792"/><a data-primary="Operator" data-secondary="Image Builder" data-type="indexterm" id="idm45902080741120"/> <a data-type="xref" href="ch28.html#Operator">Chapter 28</a> as the basis for the description of the CI pipelines.</p>&#13;
&#13;
<p>While Knative Build is history now, it was an excellent lesson about how open source communities evolve and can transform in unexpected ways.&#13;
Keep this in mind, as it might happen to other popular projects too.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Build Pod" data-type="sect2"><div class="sect2" id="image-builder-build-pod">&#13;
<h2>Build Pod</h2>&#13;
&#13;
<p>To carve out the essential ingredients of typical in-cluster builds, let’s start minimally and use a Kubernetes Pod for performing a complete build and deploy cycle.&#13;
These build steps are illustrated in <a data-type="xref" href="#img-build-pod">Figure 30-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-build-pod">&#13;
<img alt="kup2 3002" src="assets/kup2_3002.png"/>&#13;
<h6><span class="label">Figure 30-2. </span>In-cluster container image build with a build Pod</h6>&#13;
</div></figure>&#13;
&#13;
<p>The following tasks are representative of all build orchestrators and cover all aspects of creating container images:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Check out the source code from a given remote Git repository.</p>&#13;
</li>&#13;
<li>&#13;
<p>For a compiled language, perform a local build within the container.</p>&#13;
</li>&#13;
<li>&#13;
<p>Build the application with one of the techniques described in <a data-type="xref" href="#image-builder-builders">“Container Image Builder”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Push the image to a remote image registry.</p>&#13;
</li>&#13;
<li>&#13;
<p>Optionally, update a deployment with the new image reference, which will trigger a redeployment of the application following the strategies described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.html#DeclarativeDeployment">Chapter 3, “Declarative Deployment”</a>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The build Pod in our example uses<a data-primary="init containers" data-type="indexterm" id="idm45902080724544"/> init containers as described in&#13;
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch15.html#InitContainer">Chapter 15, “Init Container”</a>, to ensure that the build steps are running one after the other.&#13;
In a real-world scenario, you would use a CI system like Tekton to specify and execute these tasks sequentially.</p>&#13;
&#13;
<p>The complete build Pod definition is shown in <a data-type="xref" href="#ex-image-builder-build-pod">Example 30-1</a>.</p>&#13;
<div data-type="example" id="ex-image-builder-build-pod">&#13;
<h5><span class="label">Example 30-1. </span>Build Pod using Kaniko</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">build</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">initContainers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">git-sync</code><code class="w">          </code><a class="co" href="#callout_image_builder_CO1-1" id="co_image_builder_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8s.gcr.io/git-sync/git-sync</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w">&#13;
</code><code class="w">      </code><code class="s">"</code><code class="s">--one-time</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w">&#13;
</code><code class="w">      </code><code class="s">"</code><code class="s">--depth</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">1</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w">&#13;
</code><code class="w">      </code><code class="s">"</code><code class="s">--root</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">/workspace</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w">&#13;
</code><code class="w">      </code><code class="s">"</code><code class="s">--repo</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">https://github.com/k8spatterns/random-generator.git</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w">&#13;
</code><code class="w">      </code><code class="s">"</code><code class="s">--dest</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">main</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w">&#13;
</code><code class="w">      </code><code class="s">"</code><code class="s">--branch</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">main</code><code class="s">"</code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">           </code><a class="co" href="#callout_image_builder_CO1-2" id="co_image_builder_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/workspace</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">build</code><code class="w">             </code><a class="co" href="#callout_image_builder_CO1-3" id="co_image_builder_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kaniko-project/executor</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">--context=dir:///workspace/main/</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">--destination=index.docker.io/k8spatterns/random-generator-kaniko</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">--image-name-with-digest-file=/workspace/image-name</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">privileged</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w">     </code><a class="co" href="#callout_image_builder_CO1-4" id="co_image_builder_CO1-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kaniko-secret</code><code class="w">   </code><a class="co" href="#callout_image_builder_CO1-5" id="co_image_builder_CO1-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/kaniko/.docker</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source</code><code class="w">          </code><a class="co" href="#callout_image_builder_CO1-6" id="co_image_builder_CO1-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/workspace</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">image-update</code><code class="w">      </code><a class="co" href="#callout_image_builder_CO1-7" id="co_image_builder_CO1-7"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/image-updater</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">random</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">/opt/image-name</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/opt</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kaniko-secret</code><code class="w">     </code><a class="co" href="#callout_image_builder_CO1-8" id="co_image_builder_CO1-8"><img alt="8" src="assets/8.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">secret</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">registry-creds</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">items</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">.dockerconfigjson</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config.json</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source</code><code class="w">            </code><a class="co" href="#callout_image_builder_CO1-9" id="co_image_builder_CO1-9"><img alt="9" src="assets/9.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">build-pod</code><code class="w">  </code><a class="co" href="#callout_image_builder_CO1-10" id="co_image_builder_CO1-10"><img alt="10" src="assets/10.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Never</code><code class="w">      </code><a class="co" href="#callout_image_builder_CO1-11" id="co_image_builder_CO1-11"><img alt="11" src="assets/11.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_image_builder_CO1-1" id="callout_image_builder_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Init<a data-primary="restartPolicy" data-type="indexterm" id="idm45902080359152"/> container for fetching the source code from a remote Git repository.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-2" id="callout_image_builder_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Volume in which to store the source code.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-3" id="callout_image_builder_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Kaniko as build container, storing the created image as a reference in the shared workspace.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-4" id="callout_image_builder_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Build is running unprivileged.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-5" id="callout_image_builder_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Secret for pushing to Docker Hub registry mounted at a well-known path so that Kaniko can find it.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-6" id="callout_image_builder_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Mounting shared workspace for getting the source code.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-7" id="callout_image_builder_CO1-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Container for updating the deployment <code>random</code> with the image reference from the Kaniko build.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-8" id="callout_image_builder_CO1-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Secret volume with the Docker Hub credentials.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-9" id="callout_image_builder_CO1-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Definition of a shared volume as an empty directory on the node’s local &#13;
<span class="keep-together">filesystem.</span></p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-10" id="callout_image_builder_CO1-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>ServiceAccount that is allowed to patch a Deployment resource.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO1-11" id="callout_image_builder_CO1-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>Never restart this Pod.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This example is quite involved, so let’s break it down into three main parts.</p>&#13;
&#13;
<p>First, before being able to build a container image, the application code needs to be fetched.&#13;
In most cases, the source code is picked up from a remote Git repository, but other techniques are available.&#13;
For development purposes, it is convenient to get the source code from your local machine so that you don’t have to go over a remote source repository and mess up your commit history with triggering commits.&#13;
Because the build happens within a cluster, that source code must be uploaded somehow to your build container.&#13;
Another possibility is to distribute the source code packaged in a container image and distribute it via a container image registry.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#ex-image-builder-build-pod">Example 30-1</a>, we use an<a data-primary="Init Container" data-type="indexterm" id="idm45902080255696"/><a data-primary="Operator" data-secondary="Image Builder" data-type="indexterm" id="idm45902080255088"/><a data-primary="Operator" data-type="indexterm" id="idm45902080254240"/> init container to fetch the source code from our source Git repository and store it in a shared Pod volume <code>source</code> of type <code>emptyDir</code> so that it can later be picked up by the build process container.</p>&#13;
&#13;
<p>Second, after the application code is retrieved, the actual build happens.&#13;
In our example, we use <a href="https://oreil.ly/SQeYa">Kaniko</a>, which uses a regular Dockerfile and can run entirely unprivileged.&#13;
We again use an init container to ensure that the build starts only after the source code has been fully fetched.&#13;
The container image is created locally on disk, and we also configure Kaniko to push the resulting image to a remote Docker registry.</p>&#13;
&#13;
<p>The credentials for pushing to the registry are picked up from a Kubernetes Secret. We describe Secrets in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#ConfigurationResource">Chapter 20, “Configuration Resource”</a>.</p>&#13;
&#13;
<p>Luckily, for the particular case of authentication against a Docker registry, we have direct support from<a data-primary="kubectl" data-secondary="creating Secrets" data-type="indexterm" id="idm45902080249488"/> <code>kubectl</code> for creating such a secret that stores this configuration in a well-known format:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>secret<code class="w"> </code>docker-registry<code class="w"> </code>registry-creds<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>--docker-username<code class="o">=</code>k8spatterns<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>--docker-password<code class="o">=</code>*********<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>--docker-server<code class="o">=</code>https://index.docker.io/<code class="w"/></pre>&#13;
&#13;
<p>For <a data-type="xref" href="#ex-image-builder-build-pod">Example 30-1</a>, such a secret is mounted into the build container under a given path so that Kaniko can pick it up when pushing the created image.&#13;
In <a data-type="xref" data-xrefstyle="chap-num-title" href="ch25.html#SecureConfiguration">Chapter 25, “Secure Configuration”</a>, we explain how such a secret can be stored securely so that it can’t be forged.</p>&#13;
&#13;
<p>The final step is to update an existing Deployment with the newly created image.&#13;
This task is now performed in the actual application container of the Pod.<sup><a data-type="noteref" href="ch30.html#idm45902080225920" id="idm45902080225920-marker">2</a></sup>&#13;
The referenced image is from our example repository and contains just a <code>kubectl</code> binary that patches the specified Deployment with the new image name with the following call, shown in <a data-type="xref" href="#ex-image-builder-deploy">Example 30-2</a>.</p>&#13;
<div data-type="example" id="ex-image-builder-deploy">&#13;
<h5><span class="label">Example 30-2. </span>Update image field in Deployment</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">IMAGE</code><code class="o">=</code><code class="k">$(</code><code>cat</code><code class="w"> </code><code class="nv">$1</code><code class="k">)</code><code class="w">               </code><a class="co" href="#callout_image_builder_CO2-1" id="co_image_builder_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nv">PATCH</code><code class="o">=</code><code class="s">&lt;&lt;EOT                   </code><a class="co" href="#callout_image_builder_CO2-2" id="co_image_builder_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="s">&#13;
[{&#13;
  "op":    "replace",&#13;
  "path":  "/spec/template/spec/containers/0/image",&#13;
  "value": "$IMAGE"&#13;
}]&#13;
EOT</code><code class="w">&#13;
</code><code>kubectl</code><code class="w"> </code><code>patch</code><code class="w"> </code><code>deployment</code><code class="w"> </code><code class="nv">$2</code><code class="w"> </code><code class="se">\ </code><a class="co" href="#callout_image_builder_CO2-3" id="co_image_builder_CO2-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
   </code><code>--type</code><code class="o">=</code><code class="s2">"json"</code><code class="w"> </code><code class="se">\&#13;
</code><code class="w">   </code><code>--patch</code><code class="o">=</code><code class="nv">$PATCH</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_image_builder_CO2-1" id="callout_image_builder_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Pickup image name stored by the previous build step in the file <em>/opt/image-name</em>. This file is provided as the first argument to this script.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO2-2" id="callout_image_builder_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>JSON path to update the Pod spec with the new image reference.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO2-3" id="callout_image_builder_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Patch the deployment given as the second argument (<code>random</code> in our example) and trigger a new rollout.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The Pod’s assigned ServiceAccount <code>build-pod</code> is set up so it can write to this Deployment.&#13;
Assigning permissions to a ServiceAccount is described fully in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch26.html#AccessControl">Chapter 26, “Access Control”</a>.&#13;
When the image reference is updated in the Deployment, a rollout as described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.html#DeclarativeDeployment">Chapter 3, “Declarative Deployment”</a>, is performed.</p>&#13;
&#13;
<p>You can find the fully working setup in the book’s <a href="https://oreil.ly/jVF6h">example repository</a>.&#13;
The build Pod is the simplest way to orchestrate an in-cluster build and redeployment.&#13;
As mentioned, it is meant for illustrative purposes only.</p>&#13;
&#13;
<p>For real-world use cases, you should use a CI/CD solution like Tekton or a whole build orchestration platform like OpenShift Build, which we describe now.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="OpenShift Build" data-type="sect2"><div class="sect2" id="image-builder-openshift">&#13;
<h2>OpenShift Build</h2>&#13;
&#13;
<p>Red Hat OpenShift is an enterprise distribution of Kubernetes. Besides supporting everything Kubernetes supports, it adds a few enterprise-related features like an integrated container image registry, single sign-on support, and a new user interface, and it also adds a native image building capability to Kubernetes. <a href="https://www.okd.io">OKD</a> is the upstream open source community edition distribution that contains all the OpenShift features.</p>&#13;
&#13;
<p>OpenShift build was the first cluster-integrated way of directly building images managed by Kubernetes. It supports multiple strategies for building images:</p>&#13;
<dl>&#13;
<dt>Source-to-Image (S2I)</dt>&#13;
<dd>&#13;
<p>Takes<a data-primary="Source-to-Image (S2I)" data-type="indexterm" id="idm45902080117088"/><a data-primary="S2I (Source-to-Image)" data-type="indexterm" id="idm45902080116352"/> the source code of an application and creates the runnable artifact with the help of a language-specific S2I builder image and then pushes the images to the integrated registry.</p>&#13;
</dd>&#13;
<dt>Docker builds</dt>&#13;
<dd>&#13;
<p>Use a Dockerfile plus a context directory and creates an image as a Docker daemon would do.</p>&#13;
</dd>&#13;
<dt>Pipeline builds</dt>&#13;
<dd>&#13;
<p>Map build-to-build jobs of an internally managed Tekton by allowing the user to configure a Tekton pipeline.</p>&#13;
</dd>&#13;
<dt>Custom builds</dt>&#13;
<dd>&#13;
<p>Give you full control over how you create your image. Within a custom build, you have to create the image on your own within the build container and push it to a registry.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The input for doing the builds can come from different sources:</p>&#13;
<dl>&#13;
<dt>Git</dt>&#13;
<dd>&#13;
<p>Repository specified via a remote URL from where the source is fetched.</p>&#13;
</dd>&#13;
<dt>Dockerfile</dt>&#13;
<dd>&#13;
<p>A Dockerfile that is directly stored as part of the build configuration resource.</p>&#13;
</dd>&#13;
<dt>Image</dt>&#13;
<dd>&#13;
<p>Another container image from which files are extracted for the current build. This source type allows for <em>chained builds</em>, as shown in <a data-type="xref" href="#ex-image-builder-chained">Example 30-4</a>.</p>&#13;
</dd>&#13;
<dt>Secret</dt>&#13;
<dd>&#13;
<p>Resource for providing confidential information for the build.</p>&#13;
</dd>&#13;
<dt>Binary</dt>&#13;
<dd>&#13;
<p>Source to provide all input from the outside. This input has to be provided when starting the build.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The choice of which input sources we can use in which way depends on the build strategy. <em>Binary</em> and <em>Git</em> are mutually exclusive source types. All other sources can be combined or used on a standalone basis. We will see later in <a data-type="xref" href="#ex-image-builder-s2i">Example 30-3</a> how this works.</p>&#13;
&#13;
<p>All the build information is defined in a central resource object called BuildConfig.&#13;
We can create this resource either by directly applying it to the cluster or by using the CLI tool <code>oc</code>, which is the OpenShift equivalent of<a data-primary="kubectl" data-secondary="build-specific commands" data-type="indexterm" id="idm45902080098352"/> <code>kubectl</code>. <code>oc</code> supports build-specific commands for defining and triggering a build.</p>&#13;
&#13;
<p>Before we look at BuildConfig, we need to understand two additional concepts specific to OpenShift.</p>&#13;
&#13;
<p>An ImageStream is<a data-primary="Red Hat OpenShift" data-secondary="ImageStream" data-type="indexterm" id="idm45902080095360"/> an OpenShift resource that references one or more container images.&#13;
It is a bit similar to a Docker repository, which also contains multiple images with different tags. OpenShift maps an actual tagged image to an ImageStreamTag resource so that an ImageStream (repository) has a list of references to ImageStreamTags (tagged images). Why is this extra abstraction required? Because it allows OpenShift to emit events when an image is updated in the registry for an ImageStreamTag. Images are created during builds or when an image is pushed to the OpenShift internal registry. That way, the build or deployment controllers can listen to these events and trigger a new build or start a deployment.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To connect an ImageStream to a deployment, OpenShift uses the DeploymentConfig resource instead of the Kubernetes Deployment resource, which can only use container image references directly. However, you can still use vanilla Deployment resources in OpenShift with ImageStreams by adding some <a href="https://oreil.ly/Tu9GA">OpenShift-specific annotations</a>.</p>&#13;
</div>&#13;
&#13;
<p>The other concept is a <em>trigger</em>, which we can consider as a kind of listener to events.&#13;
One possible trigger is <code>imageChange</code>, which reacts to the event published because of an ImageStreamTag change. As a reaction, such a trigger can, for example, cause the rebuild of another image or redeployment of the Pods using this image. You can read more about triggers and the kinds of triggers available in addition to the <code>imageChange</code> trigger in the <a href="https://oreil.ly/J4qTQ">OpenShift documentation</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Source-to-Image" data-type="sect3"><div class="sect3" id="image-builder-s2i">&#13;
<h3>Source-to-Image</h3>&#13;
&#13;
<p>Let’s<a data-primary="Red Hat OpenShift" data-secondary="S2I" data-type="indexterm" id="idm45902080087312"/><a data-primary="S2I (Source-to-Image)" data-type="indexterm" id="idm45902080086304"/> have a quick look at what an S2I builder image looks like. We won’t go into too many details here, but an S2I builder image is a standard container image that contains a set of S2I scripts. It is very similar to Cloud Native Buildpacks but with a much simpler lifecycle that knows two mandatory commands:</p>&#13;
<dl>&#13;
<dt><code>assemble</code></dt>&#13;
<dd>&#13;
<p>The script that gets called when the build starts. Its task is to take the source given by one of the configured inputs, compile it if necessary, and copy the final artifacts to the proper locations.</p>&#13;
</dd>&#13;
<dt><code>run</code></dt>&#13;
<dd>&#13;
<p>Used as an entry point for this image. OpenShift calls this script when it deploys the image. This run script uses the generated artifacts to deliver the application services.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Optionally, you can also script to provide a usage message, saving the generated artifacts for so-called<a data-primary="incremental S2I builds" data-type="indexterm" id="idm45902080081568"/> <em>incremental builds</em> that are accessible by the <code>assemble</code> script in a subsequent build run, or add some sanity checks.</p>&#13;
&#13;
<p>Let’s have a closer look at an S2I build in <a data-type="xref" href="#img-image-builder-s2i">Figure 30-3</a>. An S2I build has two ingredients: a builder image and a source input. Both are brought together by the S2I build system when a build is started—either because a trigger event was received or because we started it manually. When the build image has finished by, for example, compiling the source code, the container is committed to an image and pushed to the configured ImageStreamTag. This image contains the compiled and prepared artifacts, and the image’s <code>run</code> script is set as the entry point.</p>&#13;
&#13;
<figure class="width-70"><div class="figure" id="img-image-builder-s2i">&#13;
<img alt="kup2 3003" src="assets/kup2_3003.png"/>&#13;
<h6><span class="label">Figure 30-3. </span>S2I build with Git source as input</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#ex-image-builder-s2i">Example 30-3</a> shows a simple Java S2I build with a Java S2I image.&#13;
This build takes a source, the builder image, and produces an output image that is pushed to an ImageStreamTag. It can be started manually via <code>oc start-build</code> or automatically when the builder image changes.</p>&#13;
<div data-type="example" id="ex-image-builder-s2i">&#13;
<h5><span class="label">Example 30-3. </span>S2I Build using a Java builder image</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">build.openshift.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">BuildConfig</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator-build</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">source</code><code class="p">:</code><code class="w">    </code><a class="co" href="#callout_image_builder_CO3-1" id="co_image_builder_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">git</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">uri</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/k8spatterns/random-generator</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">strategy</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_image_builder_CO3-2" id="co_image_builder_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">sourceStrategy</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">from</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DockerImage</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fabric8/s2i-java</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w">    </code><a class="co" href="#callout_image_builder_CO3-3" id="co_image_builder_CO3-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">to</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ImageStreamTag</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator-build:latest</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">triggers</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_image_builder_CO3-4" id="co_image_builder_CO3-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">GitHub</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">github</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">secretReference</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-secret</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_image_builder_CO3-1" id="callout_image_builder_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Reference to the source code to fetch; in this case, pick it up from GitHub.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO3-2" id="callout_image_builder_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>sourceStrategy</code> switches to S2I mode, and the builder image is picked up directly from Docker Hub.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO3-3" id="callout_image_builder_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The ImageStreamTag to update with the generated image. It’s the committed builder container after the <code>assemble</code> script has run.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO3-4" id="callout_image_builder_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Rebuild automatically when the source code in the repository changes.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>S2I is a robust mechanism for creating application images, and it is more secure than plain Docker builds because the build process is under full control of trusted builder images. However, this approach still has some drawbacks.</p>&#13;
&#13;
<p>For complex applications, S2I can be slow, especially when the build needs to load many dependencies. Without any optimization, S2I loads all dependencies afresh for every build. In the case of a Java application built with Maven, there is no caching as when doing local builds. To avoid downloading half of the internet again and again, it is recommended that you set up a cluster-internal Maven repository that serves as a cache. The builder image then has to be configured to access this common repository instead of downloading the artifacts from remote repositories.</p>&#13;
&#13;
<p>Another way to decrease the build time is to use <em>incremental builds</em> with S2I, which allows you to reuse artifacts created or downloaded in a previous S2I build. However, a lot of data is copied over from the previously generated image to the current build container, and the performance benefits are typically not much better than using a cluster-local proxy that holds the dependencies.</p>&#13;
&#13;
<p>Another drawback of S2I is that the generated image also contains the whole build environment.<sup><a data-type="noteref" href="ch30.html#idm45902079913104" id="idm45902079913104-marker">3</a></sup> This fact increases not only the size of the application image but also the surface for a potential attack, as builder tools can become vulnerable too.</p>&#13;
&#13;
<p>To get rid of unneeded builder tools like Maven, OpenShift offers<a data-primary="chained builds" data-type="indexterm" id="chnbld30"/> <em>chained builds</em>, which take the result of an S2I build and create a slim runtime image. We look at chained builds in <a data-type="xref" href="#image-builder-chained">“Chained builds”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Docker builds" data-type="sect3"><div class="sect3" id="image-builder-docker">&#13;
<h3>Docker builds</h3>&#13;
&#13;
<p>OpenShift<a data-primary="Docker builds" data-type="indexterm" id="idm45902079907712"/> also supports Docker builds directly within the cluster. Docker builds work by mounting the Docker daemon’s socket directly in the build container, which is then used for a <code>docker build</code>. The source for a Docker build is a Dockerfile and a directory holding the context. You can also use an <code>Image</code> source that refers an arbitrary image and from which files can be copied into the Docker build context directory. As mentioned in the next section, this technique, together with triggers, can be used for chained builds.</p>&#13;
&#13;
<p>Alternatively, you can use a standard multistage Dockerfile to separate the build and runtime parts. Our <a href="https://oreil.ly/mn4vg">example repository</a> contains a fully working multistage Docker build example that results in the same image as the chained build described in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chained builds" data-type="sect3"><div class="sect3" id="image-builder-chained">&#13;
<h3>Chained builds</h3>&#13;
&#13;
<p>The mechanics of a chained build are shown in <a data-type="xref" href="#img-image-builder-chained">Figure 30-4</a>. A chained build consists of an initial S2I build, which creates the runtime artifact such as a binary executable. This artifact is then picked up from the generated image by a second build, typically a Docker build.</p>&#13;
&#13;
<figure class="width-70"><div class="figure" id="img-image-builder-chained">&#13;
<img alt="kup2 3004" src="assets/kup2_3004.png"/>&#13;
<h6><span class="label">Figure 30-4. </span>Chained build with S2I for compiling and Docker build for application image</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#ex-image-builder-chained">Example 30-4</a> shows the setup of this second build config, which uses the JAR file generated in <a data-type="xref" href="#ex-image-builder-s2i">Example 30-3</a>. The image that is eventually pushed to the ImageStream <code>random-generator-runtime</code> can be used in a DeploymentConfig to run the &#13;
<span class="keep-together">application.</span></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The trigger used in <a data-type="xref" href="#ex-image-builder-chained">Example 30-4</a> monitors the result of the S2I build. This trigger causes a rebuild of this runtime image whenever we run an S2I build so that both ImageStreams are always in sync.</p>&#13;
</div>&#13;
<div data-type="example" id="ex-image-builder-chained">&#13;
<h5><span class="label">Example 30-4. </span>Docker build for creating the application image</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="w">  </code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">build.openshift.io/v1</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">BuildConfig</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">runtime</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">source</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">images</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">from</code><code class="p">:</code><code class="w">             </code><a class="co" href="#callout_image_builder_CO4-1" id="co_image_builder_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ImageStreamTag</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator-build:latest</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">paths</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">sourcePath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/deployments/.</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">destinationDir</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">.</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">dockerfile</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="p-Indicator">-</code><code class="w">      </code><a class="co" href="#callout_image_builder_CO4-2" id="co_image_builder_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="no">FROM openjdk:17</code><code class="w">&#13;
</code><code class="w">        </code><code class="no">COPY *.jar /</code><code class="w">&#13;
</code><code class="w">        </code><code class="no">CMD java -jar /*.jar</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">strategy</code><code class="p">:</code><code class="w">             </code><a class="co" href="#callout_image_builder_CO4-3" id="co_image_builder_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Docker</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">output</code><code class="p">:</code><code class="w">               </code><a class="co" href="#callout_image_builder_CO4-4" id="co_image_builder_CO4-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">to</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ImageStreamTag</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator:latest</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">triggers</code><code class="p">:</code><code class="w">             </code><a class="co" href="#callout_image_builder_CO4-5" id="co_image_builder_CO4-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">imageChange</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">automatic</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">from</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ImageStreamTag</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator-build:latest</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ImageChange</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_image_builder_CO4-1" id="callout_image_builder_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Image source references the ImageStream that contains the result of the S2I build run and selects a directory within the image that contains the compiled JAR archive.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO4-2" id="callout_image_builder_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Dockerfile source for the Docker build that copies the JAR archive from the ImageStream generated by the S2I build.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO4-3" id="callout_image_builder_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>strategy</code> selects a Docker build.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO4-4" id="callout_image_builder_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Rebuild automatically when the S2I result ImageStream changes—after a successful S2I run to compile the JAR archive.</p></dd>&#13;
<dt><a class="co" href="#co_image_builder_CO4-5" id="callout_image_builder_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Register listener for image updates, and do a redeploy when a new image has been added to the ImageStream.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>You can find the full example with installation instructions in our <a href="https://oreil.ly/mn4vg">example repository</a>.</p>&#13;
&#13;
<p>As mentioned, OpenShift build, along with its most prominent S2I mode, is one of the oldest and most mature ways to safely build container images within an OpenShift cluster.<a data-primary="" data-startref="chnbld30" data-type="indexterm" id="idm45902079669360"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902080827280">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>You have seen two ways to build container images within a cluster.&#13;
The plain build Pod illustrates the most crucial tasks that every build system needs to execute: fetching the source code, creating a runnable artifact from your source code, creating a container image containing the application’s artifacts, pushing this image to an image registry, and finally updating any deployments so that it picks up the newly created image from that registry.&#13;
This example is not meant for direct production use as it contains too many manual steps that existing build orchestrators cover more effectively.</p>&#13;
&#13;
<p>The OpenShift build system nicely demonstrates one of the main benefits of building and running an application in the same cluster. With OpenShift’s ImageStream triggers, you can connect multiple builds and redeploy your application if a build updates your application’s container image. Better integration between build and deployment is a step forward to the holy grail of CD. OpenShift builds with S2I are a proven and established technology, but S2I is usable only when using the OpenShift distribution of Kubernetes.</p>&#13;
&#13;
<p>The landscape of in-cluster build tools as of 2023 is rich and contains many exciting techniques that partly overlap. As a result, you can expect some consolidation, but new tooling will arise over time, so we’ll see more implementations of the <em>Image Builder</em> pattern emerge.<a data-primary="" data-startref="imgbld30" data-type="indexterm" id="idm45902079665952"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="image-builder-more-information">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/39C_l">Image Builder Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Image Builders:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/AY7ml">Buildah</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/SQeYa">Kaniko</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/N28Dn">What Is BuildKit?</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/sBth1">Building Multi-Architecture Images with Buildpacks</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/jy9KH">Jib</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/iILs7">Pack</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/LpGvB">Kpack</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/9hARS">Ko</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/5227Q">Apko: A Better Way to Build Containers?</a></p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Build Orchestrators:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/dIii_">OpenShift Builds</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Uako8">Kbld</a></p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/8-zKu">Multistage Build</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/3MPXZ">Chaining S2I Builds</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/jcFx7">Build Triggers Overview</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/0B2cc">Source-to-Image Specification</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/YbUen">Incremental S2I Builds</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/0ijOJ">Building Container Images in Kubernetes: It’s Been a Journey!</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/0Neln">Build Multi-Architecture Container Images Using Kubernetes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/8E76m">Best Practices for Running Buildah in a Container</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45902080790064"><sup><a href="ch30.html#idm45902080790064-marker">1</a></sup> CNB cover more phases. The entire lifecycle is explained on the <a href="https://oreil.ly/8l69J">Buildpacks site</a>.</p><p data-type="footnote" id="idm45902080225920"><sup><a href="ch30.html#idm45902080225920-marker">2</a></sup> We could have also chosen an init container again here and used a no-op application container, but since the application containers start only after all init containers have been finished, it doesn’t matter much where we put the container. In all cases, the three specified containers run after one another.</p><p data-type="footnote" id="idm45902079913104"><sup><a href="ch30.html#idm45902079913104-marker">3</a></sup> This is different from Cloud Native Buildpacks, which use a separate runtime image in its stack for carrying the final artifact.</p></div></div></section></body></html>