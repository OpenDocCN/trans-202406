- en: Appendix B. The top ten-ish topics that didn’t make it into the rest of the
    book...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0683-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We covered a lot of ground, and you’re almost finished with this book. We’ll
    miss you, but before we let you go, we wouldn’t feel right about sending you out
    into JavaLand without a little more preparation. We can’t possibly fit everything
    you’ll need to know into this relatively small appendix. Actually, we *did* originally
    include everything you need to know about Java (not already covered by the other
    chapters), by reducing the type point size to .00003\. It all fit, but nobody
    could read it. So, we threw most of it away, but kept the best bits for this Top
    Ten-ish appendix. Yep, there’s more than ten Really Useful Things that you still
    need to know.
  prefs: []
  type: TYPE_NORMAL
- en: This really *is* the end of the book. Except for the index (a must-read!).
  prefs: []
  type: TYPE_NORMAL
- en: '#11 JShell (Java REPL)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java 9+**'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you care?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A REPL (Read Eval Print Loop) lets you run snippets of code without needing
    a full application or framework. It’s a great way to try out new features, experiment
    with new ideas, and get immediate feedback. We’ve put this right at the start
    of this appendix in case you want to use JShell to try out some of the features
    we’ll be talking about in the following pages.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the REPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JShell is a command-line tool that comes part of the JDK. If JAVA_HOME/bin is
    on your system’s path, you can just type “jshell” from the command line (full
    details on getting started are in Oracle’s Introduction to JShell (*[https://oreil.ly/Ei3Df](https://oreil.ly/Ei3Df)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0684-01.png)'
  prefs: []
  type: TYPE_IMG
- en: JShell is available only in **JDK 9 and higher**, but the good news is that
    even if you’re running code and applications on an older version of Java, you
    can still use JShell from a more recent version, since it’s completely independent
    of your “JAVA_HOME” or IDE’s version of Java. Just run it directly from the *bin*
    directory of whichever version of Java you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Run Java code without a class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try out some Java from the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0684-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: No need for a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for a *public static main* method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for a semicolon on the end of the line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just start typing Java!
  prefs: []
  type: TYPE_NORMAL
- en: More than just lines of code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define variables and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0684-03.png)'
  prefs: []
  type: TYPE_IMG
- en: It supports *forward references*, so you can sketch out the shape of your code
    without having to define everything immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0684-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Code suggestions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you press Tab halfway through typing, you’ll get code suggestions. You can
    also use the up and down arrows to cycle through the lines you’ve typed so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0684-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are lots of helpful commands that are part of JShell and not part of Java.
    For example, type **`/vars`** to see all the variables you’ve declared. Type **`/exit`**
    to, er, exit. Use **`/help`** to see a list of commands and to get more information.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle has a very useful JShell User Guide (*[https://oreil.ly/Ei3Df](https://oreil.ly/Ei3Df)*),
    which also shows how to create and run scripts with JShell.
  prefs: []
  type: TYPE_NORMAL
- en: '#10 Packages'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages prevent class name conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although packages aren’t just for preventing name collisions, that’s a key feature.
    If part of the point of OO is to write reusable components, developers need to
    be able to piece together components from a variety of sources and build something
    new out of them. Your components have to be able to “play well with others,” including
    those you didn’t write or even know about.
  prefs: []
  type: TYPE_NORMAL
- en: Remember way back in [Chapter 6](ch06.xhtml#using_the_java_library_get_to_know_the_j),
    *Using the Java Library*, when we discussed how a package name is like the full
    name of a class, technically known as the *fully qualified name*. Class List is
    really **`java.util.List`**, a GUI List is really **`java.awt.List`**, and Socket
    is really **`java.net.Socket`**. Hey presto, an example of how package names can
    help prevent name conflicts—there’s a List that’s a data structure and a List
    that’s a GUI element, and we can use the package names to tell them apart.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that these classes have *java* as their “first name.” In other words,
    the first part of their fully qualified names is “java”; think of a hierarchy
    when you think of package structures, and organize your classes accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0685-02.png)![image](Images/f0685-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**What does this picture look like to you? Doesn’t it look a whole lot like
    a directory hierarchy?**'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing package name conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard package naming convention is to prepend every class with your reverse
    domain name. Remember, domain names are guaranteed to be unique. Two different
    guys can be named Bartholomew Simpson, but two different domains cannot be named
    *[doh.com](http://doh.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0685-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you look at the code samples at *[https://oreil.ly/hfJava_3e_examples](https://oreil.ly/hfJava_3e_examples)*,
    you’ll see we’ve put the classes into packages named after each chapter to clearly
    separate the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Packages can prevent name conflicts, but only if you choose a package name
    that’s guaranteed to be unique. The best way to do that is to preface your packages
    with your reverse domain name.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0685-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To put your class in a package:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Choose a package name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re using **`com.headfirstjava`** as our example. The class name is PackageExercise,
    so the fully qualified name of the class is now **`com.headfirstjava.PackageExercise`**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **Put a package statement in your class**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be the first statement in the source code file, above any import statements.
    There can be only one package statement per source code file, so **`all classes
    in a source file must be in the same package`**. That includes inner classes,
    of course.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) **Set up a matching directory structure**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not enough to ***say*** your class is in a package by merely putting a
    package statement in the code. Your class isn’t *truly* in a package until you
    put the class in a matching directory structure. So, if the fully qualified class
    name is com.headfirstjava.PackageExercise, you *must* put the PackageExercise
    source code in a directory named **`headfirstjava`**, which ***must*** be in a
    directory named **`com`**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0686-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A note on directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Real World, source files and class files are usually kept in separate
    directories—you don’t want to copy the source code to wherever it’s running (a
    customer’s computer or the cloud), only the class files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common structure for Java projects is based off Maven’s* convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**MyProject/src/main/java**` Application sources'
  prefs: []
  type: TYPE_NORMAL
- en: '`**MyProject/src/test/java**` Test sources'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class files are placed elsewhere. Real enterprise systems usually use a
    build tool like Maven or Gradle to compile and build the application (our sample
    code uses Gradle). Each build tool puts the classes into different folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Maven | Gradle |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Application classes | MyProject/target/classes | MyProject/out/production/classes
    |'
  prefs: []
  type: TYPE_TB
- en: '| Test classes | MyProject/target/test-classes | MyProject/out/test/classes
    |'
  prefs: []
  type: TYPE_TB
- en: '*Maven and Gradle are the most common build tools for Java projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running with packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don’t need to use a build tool to separate our classes and source files.
    By using the `**-d**` flag, *you* get to decide which **`directory`** the compiled
    code lands in, rather than accepting the default of class files landing in the
    same directory as the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with the `**-d**` flag not only lets you send your compiled class
    files into a directory other than the one where the source file is, but it also
    knows to put the class into the correct directory structure for the package the
    class is in. Not only that, compiling with -d tells the compiler to *build* the
    directories if they don’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**The `-d` flag tells the compiler, “Put the class into its package directory
    structure, using the class specified after the `-d` as the root directory. But...if
    the directories aren’t there, create them first and *then* put the class in the
    right place!”**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compiling with the `-d` (directory) flag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image](Images/f0687-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To compile all the .java files in the com.headfirstjava package, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0687-03.png)![image](Images/f0687-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Running your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image](Images/f0687-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '#9 Immutability in Strings and Wrappers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about immutability in [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con),
    and we’ll mention immutability in the last item of this appendix. This section
    is specifically about immutability in two important Java types: Strings and Wrappers.'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you care that Strings are immutable?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For security purposes and for the sake of conserving memory (whether you’re
    running on phones, IoT devices, or the cloud, memory matters), Strings in Java
    are immutable. What this means is that when you say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: what’s actually happening is that you’re creating ten String objects (with values
    “0,” “01,” “012,” through “0123456789”). In the end, *s* is referring to the String
    with the value “0123456789,” but at this point there are *ten different* Strings
    in existence!
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you use methods on String to “change” a String object, it doesn’t
    change that object at all; it creates a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0688-01.png)'
  prefs: []
  type: TYPE_IMG
- en: How does this save memory?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you make a new String, the JVM puts it into a special part of memory
    called the “String Pool” (sounds refreshing, doesn’t it?). If there is already
    a String in the pool with the same value, the JVM *doesn’t create a duplicate*;
    it refers your reference variable to the *existing* entry. So you won’t have 500
    objects of the word “customer” (for example), but 500 references to the single
    “customer” String object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0688-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Immutability makes reuse possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JVM can get away with this because Strings are **`immutable`**; one reference
    variable can’t change a String’s value out from under another reference variable
    referring to the same String.
  prefs: []
  type: TYPE_NORMAL
- en: What happens to unused Strings?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first example created a lot of intermediate Strings that weren’t used (“01,”
    “012,” etc). These were placed in the String Pool, which is on the heap and therefore
    eligible for Garbage Collection (see [Chapter 9](ch09.xhtml#life_and_death_of_an_object_constructors)).
    Strings that aren’t used will eventually be garbage-collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you have to do a lot of String manipulations (like concatenations,
    etc.), you can avoid the creation of unnecessary strings by using a *StringBuilder*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This way, the single *mutable* StringBuilder is updated every time to represent
    the intermediate states, instead of ten *immutable* String instances being created
    and the nine intermediate Strings being thrown away.
  prefs: []
  type: TYPE_NORMAL
- en: Why do you care that Wrappers are immutable?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics), we talked about
    the two main uses of the wrapper classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a primitive so it can act like an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the static utility methods (e.g., Integer.parseInt()).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s important to remember that when you create a wrapper object like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: that’s it for that wrapper object. Its value will *always* be 42\. ***There
    is no setter method for a wrapper object.*** You can, of course, refer *iWrap*
    to a *different* wrapper object, but then you’ll have *two* objects. Once you
    create a wrapper object, there’s no way to change the *value* of that object!
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Access levels and access modifiers (who sees what)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java has four access levels and three access modifiers. There are only three
    modifiers because the default (what you get when you don’t use any access modifier)
    is one of the four access levels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Access levels** (in order of how restrictive they are, from least to most
    restrictive)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0689-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Access modifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time you’ll use only public and private access levels.
  prefs: []
  type: TYPE_NORMAL
- en: '**public**'
  prefs: []
  type: TYPE_NORMAL
- en: Use public for classes, constants (static final variables), and methods that
    you’re exposing to other code (for example getters and setters) and most constructors.
  prefs: []
  type: TYPE_NORMAL
- en: '**private**'
  prefs: []
  type: TYPE_NORMAL
- en: Use private for virtually all instance variables, and for methods that you don’t
    want outside code to call (in other words, methods used by the public methods
    of your class).
  prefs: []
  type: TYPE_NORMAL
- en: Although you might not use the other two (protected and default) much, you still
    need to know what they do because you’ll see them in other code.
  prefs: []
  type: TYPE_NORMAL
- en: '**default and protected**'
  prefs: []
  type: TYPE_NORMAL
- en: '**default**'
  prefs: []
  type: TYPE_NORMAL
- en: Both protected and default access levels are tied to packages. Default access
    is simple—it means that only code *within the same package* can access code with
    default access. So a default class, for example (which means a class that isn’t
    explicitly declared as *public*) can be accessed by only classes within the same
    package as the default class.
  prefs: []
  type: TYPE_NORMAL
- en: But what does it really mean to *access* a class? Code that does not have access
    to a class is not allowed to even *think* about the class. And by think, we mean
    *use* the class in code. For example, if you don’t have access to a class, because
    of access restriction, you aren’t allowed to instantiate the class or even declare
    it as a type for a variable, argument, or return value. You simply can’t type
    it into your code at all! If you do, the compiler will complain.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the implications—a default class with public methods means the public
    methods aren’t really public at all. You can’t access a method if you can’t *see*
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: Why would anyone want to restrict access to code within the same package? Typically,
    packages are designed as a group of classes that work together as a related set.
    So it might make sense that classes within the same package need to access one
    another’s code, while as a package, only a small number of classes and methods
    are exposed to the outside world (i.e., code outside that package).
  prefs: []
  type: TYPE_NORMAL
- en: OK, that’s default. It’s simple—if something has default access (which, remember,
    means no explicit access modifier!), only code within the same package as the
    default *thing* (class, variable, method, inner class) can access that *thing*.
  prefs: []
  type: TYPE_NORMAL
- en: Then what’s *protected* for?
  prefs: []
  type: TYPE_NORMAL
- en: '**protected**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Protected access is almost identical to default access, with one exception:
    it allows subclasses to *inherit* the protected thing, *even if those subclasses
    are outside the package of the superclass they extend*. That’s it. That’s *all*
    protected buys you—the ability to let your subclasses be outside your superclass
    package, yet still *inherit* pieces of the class, including methods and constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: Many developers find very little reason to use protected, but it is used in
    some designs, and some day you might find it to be exactly what you need. One
    of the interesting things about protected is that—unlike the other access levels—protected
    access applies only to *inheritance*. If a subclass-outside-the-package has a
    *reference* to an instance of the superclass (the superclass that has, say, a
    protected method), the subclass can’t access the protected method using that superclass
    reference! The only way the subclass can access that method is by *inheriting*
    it. In other words, the subclass-outside-the-package doesn’t have *access* to
    the protected method; it just *has* the method, through inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Experienced developers writing libraries for other developers to use will find
    both default and protected access levels very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: These access levels can separate the internals of a library from the API that
    other developers will call from their code.
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Varargs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw varargs briefly in [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics),
    *Numbers Matter,* when we looked at the String.format() method. You also saw them
    in [Chapter 11](ch11.xhtml#data_structures_collections_and_generics), *Data Structures*,
    when we looked at *convenience factory methods for Collections*. Varargs let a
    method take as many arguments as they want, as long as they’re of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Why do you care?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chances are, you won’t write many (or any!) methods with a vararg parameter.
    But you will likely use them, passing in varargs, since the Java libraries do
    provide helpful methods, like the ones we just mentioned, that can take as many
    arguments as they like.
  prefs: []
  type: TYPE_NORMAL
- en: How can I tell if a method takes varargs?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at the API documentation for String.format():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The triple dot (...) says this is method takes an arbitrary number of Objects
    after the String argument, **`including zero`**. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0691-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Methods that take varargs generally don’t care how many arguments there are;
    it doesn’t matter much. Consider List.of(), for example. It doesn’t care how many
    items you want in the List; it will just use add all the arguments into the new
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a method that takes varargs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will generally be calling a method that takes varargs, not creating it,
    but let’s take a look anyway. If you wanted to define your own method that, for
    example, printed out everything passed into it, you could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter *elements* is nothing magic; it’s actually just an array of Objects.
    So you can iterate over it the same way as if you’d created the method signature
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s the calling code that looks different. Instead of having to create an array
    of objects to pass in, you get the convenience of passing in an arbitrary number
    of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method can have only one varargs parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The varargs parameter must be the last parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '#6 Annotations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do you care?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We very briefly mentioned annotations back in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la),
    *Lambdas and Streams: What, Not How*, when we said that interfaces that can be
    implemented as a lambda expression may be marked with a “@FunctionalInterface”
    annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an annotation to your code can add extra behavior, or an annotation can
    be a kind of compiler-friendly documentation; i.e., you’re simply tagging the
    code with some additional information that could optionally be used by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: You will definitely see annotations used in the Real World, and very likely
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Where will you see annotations?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will see annotations in code that uses libraries and frameworks like Java
    EE/Jakarta EE, Spring/Spring Boot, Hibernate and Jackson, all of which are very
    commonly used in the Java world for building large and small applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0692-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Where you will definitely see annotations is in test code. Back in [Chapter 5](ch05.xhtml#extra-strength_methods_writing_a_program),
    *Extra-Strength Methods*, we introduced the idea of testing your code, but what
    we haven’t shown is the frameworks that make it much easier. The most common one
    is JUnit. If you look at the code samples at *[https://oreil.ly/hfJava_3e_examples](https://oreil.ly/hfJava_3e_examples)*,
    you’ll see there are some example test classes in the “test” folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0692-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Annotations can be applied to classes and methods, to variables (local and instance)
    and parameters, and even some other places in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations can have elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some annotations include elements, which are like parameters with names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the annotation has only one element, you don’t need to give the name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you saw in the earlier examples, you don’t need to add parentheses to an
    annotation that doesn’t have elements.
  prefs: []
  type: TYPE_NORMAL
- en: You can add more than one annotation to the class, method, or variable that
    you’re annotating.
  prefs: []
  type: TYPE_NORMAL
- en: What do they do?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, it depends! Some can be used as a sort of compiler-safe documentation.
    If you add @FunctionalInterface to an interface with more than one abstract method,
    you’ll get a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Other annotations (like @NotNull) can be used by your IDE or by analysis tools
    to see if your code is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Many libraries provide annotations for you to use to tag parts of your code
    so the framework knows what to do with your code. For example, the @Test annotation
    tags methods that need to be run as individual tests by JUnit; @SpringBootApplication
    tags the class with the *main* method that’s the entry point of a Spring Boot
    application; @Entity tags a Java class as a data object that needs to be saved
    to a database by Hibernate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some annotations provide behavior on top of your code. For example, Lombok
    can use annotations to generate common code: add @Data to the top of your class,
    and Lombok will generate constructors, getters and (if needed) setters, and hashCode,
    toString, and equals methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Lambdas and Maps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java 8+**'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you care?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 8 famously added lambdas and streams to Java, but what is less well-known
    is that java.util.Map also got a few new methods that take lambda expressions
    as arguments. These methods make it much easier to do common operations on Maps,
    which will save you time and brainpower.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new value if there isn’t one for the key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine you want to track what a customer does on your website, and you do
    this using an Actions object. You might have a Map of String username to Actions.
    When a customer performs some action that you want to add to their Actions object,
    you want to either:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Actions object for this customer and add it to the Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the existing Actions object for this customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s very common to use an *if* statement and a *null* check to do this (pre-Java
    8):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0693-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It’s not a lot of code, but it is a pattern that is used again and again. If
    you’re using Java 8 or higher, you don’t need to do this at all. Use **computeIfAbsent**,
    and give it a lambda expression that says how to “compute” the value that should
    go into the Map if there isn’t an entry for the given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0693-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Update the value only if it already exists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There may be other scenarios when you want to update a value in the Map only
    if it exists. For example, you might have a Map of things that you are counting,
    like metrics, and you want to update only the metrics that you care about. You
    don’t want to add any arbitrary new metric to the Map. Before Java 8, you might
    use a combination of *contains*, *get*, and *put* to check if the map has a value
    for this metric and update it if so.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0694-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Java 8 added **computeIfPresent**, which takes the key you’re looking for and
    a lambda expression, which you can use to describe how to calculate the updated
    value for the Map. Using this, the code above can be simplified to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0694-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Other methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other, more advanced methods on Map that can be useful when you want
    to “add a new value OR do something with the existing value” (or even remove a
    value), like *merge* and *compute*. There’s also *replaceAll*, which you can give
    a lambda expression that calculates a new value for all the values in the map
    (we could use this, for example, to increment ALL the metrics in our previous
    example, if we needed to). And, like all the collections, it has a *forEach* that
    lets us iterate over all the key/value pairs in the Map.
  prefs: []
  type: TYPE_NORMAL
- en: The Java libraries continuously evolve, so even if you think you understand
    something you’ve used a lot, like List or Map, it’s always worth keeping an eye
    out for changes that may make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the Java API documentation (*[https://oreil.ly/ln5xn](https://oreil.ly/ln5xn)*)
    is a great place to start if you want to see what methods are available on a class,
    and what they do.
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Parallel Streams'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java 8+**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la),
    *Lambdas and Streams: What, Not How*, we took a long look at the Streams API.
    We did not look at one of the really interesting features of streams, which is
    that you can use them to take advantage of modern multicore, multi-CPU hardware
    and run your stream operations in parallel. Let’s look at that now.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used the Streams API to effectively “query” our data structures.
    Now, imagine those data structures can get big. We mean REALLY big. Like all the
    data from a database, or like a real-time stream of data from a social media API.
    We *could* plod over each of these items one by one, in **`serial`**, until we
    get the results we want. Or, we could split the work up into multiple operations
    and run them at the same time, in **`parallel`**, on different CPUs. After [Chapter 17](ch17.xhtml#make_a_connection_networking_and_threads)
    and [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con) you might
    be tempted to run off and write a multithreaded application to do that, but *you
    don’t have to*!
  prefs: []
  type: TYPE_NORMAL
- en: Going parallel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can simply tell the Streams API you want your stream pipeline to be run
    on multiple CPU cores. There are two ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Start a parallelStream**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0695-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add parallel() to the stream pipeline**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: They both do the same thing, and you can choose whichever approach you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: OK now what?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you just write a stream pipeline just like we did in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la),
    adding the operations you want and finishing off with a terminator. The Java libraries
    will take care of figuring out:'
  prefs: []
  type: TYPE_NORMAL
- en: How to split the data to run the stream pipeline on multiple CPU cores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many parallel operations to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to merge the results of the multiple operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading is taken care of
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the covers, parallel streams use the [Fork-Join framework](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)
    (which we did not cover in this book; see *[https://oreil.ly/XJ6eH](https://oreil.ly/XJ6eH)*),
    yet another type of thread pool (which we did talk about in [Chapter 17](ch17.xhtml#make_a_connection_networking_and_threads),
    *Make a Connection*). With parallel streams, you’ll find the number of threads
    is equal to the number of cores available wherever your application is running.
    There are ways to change this setup, but it’s recommended to stick with the defaults
    unless you *really* know what you’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use parallel everywhere!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you going running off and making all your stream calls parallel, **wait**!
    Remember we said back in [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con),
    *Dealing with Concurrency Issues*, that multithreaded programming was hard, because
    the solutions you choose depend a lot on your application, your data, and your
    environment? The same applies to using parallel streams. Going parallel and making
    use of multiple CPU cores is ***not*** free and does ***not*** automatically mean
    your application will run faster.
  prefs: []
  type: TYPE_NORMAL
- en: There is a cost to running a stream pipeline in parallel. The data needs to
    be split up, the operations need to be run on each bit of data on separate threads,
    and then at the end the results of each separate parallel operation need to be
    combined in some way to give a final result. All of that adds time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data going into your stream pipeline is a simple collection, like the
    examples we looked at in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la)
    (indeed, in *most* places streams are used today), using serial streams is almost
    definitely going to be faster. Yes, you read that correctly: for most ordinary
    use cases, you do ***not*** want to go parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel streams can improve performance when:'
  prefs: []
  type: TYPE_NORMAL
- en: The input collection is BIG (think hundreds of thousands of elements at least)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stream pipeline is performing complicated, long-running operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decomposition (splitting) of the data/operations and merging of the results
    are not too costly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should measure the performance with and without parallel before using it.
    If you want to learn more, Richard Warburton’s *Java 8 Lambdas* book has an excellent
    section on data parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Enumerations (also called enumerated types or enums)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve talked about constants that are defined in the API, for instance, `**JFrame.EXIT_ON_CLOSE**`.
    You can also create your own constants by marking a variable `**static final**`.
    But sometimes you’ll want to create a set of constant values to represent the
    ***only*** valid values for a variable. This set of valid values is commonly referred
    to as an enumeration. Full-fledged enumerations were introduce way back in Java
    5.
  prefs: []
  type: TYPE_NORMAL
- en: Who’s in the band?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say that you’re creating a website for your favorite band, and you want
    to make sure that all of the comments are directed to a particular band member.
  prefs: []
  type: TYPE_NORMAL
- en: 'The old way to fake an “enum”:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0696-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The good news about this technique is that it DOES make the code easier to read.
    The other good news is that you can’t ever change the value of the fake enums
    you’ve created; `KEVIN` will always be `1`. The bad news is that there’s no easy
    or good way to make sure that the value of `selectedBandMember` will always be
    `1, 2`, or `3`. If some hard-to-find piece of code sets `selectedBandMember` equal
    to `812`, it’s pretty likely your code will break.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This IS the OLD way to fake an enum, but you will still see code like this in
    Real Life (e.g., the older Java libraries like AWT).
  prefs: []
  type: TYPE_NORMAL
- en: However, if you have any control over the code, try to use enums instead of
    constants like this. See the next page...
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what the band members would look like with a “real” enum. While this
    is a very basic enumeration, most enumerations usually are this simple.
  prefs: []
  type: TYPE_NORMAL
- en: An official “enum”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image](Images/f0697-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your enum extends java.lang.Enum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create an enum, you’re creating a new class, and ***you’re implicitly
    extending*** `***java.lang.Enum***`. You can declare an enum as its own standalone
    class, in its own source file, or as a member of another class.
  prefs: []
  type: TYPE_NORMAL
- en: Using “if” and “switch” with enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the enum we just created, we can perform branches in our code using either
    the `if` or `switch` statement. Also notice that we can compare enum instances
    using either `==` or the `.equals()` method. Usually `==` is considered better
    style.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0697-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You can add a bunch of things to your enum like a constructor, methods, variables,
    and something called a constant-specific class body. They’re not common, but you
    might run into them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer:'
  prefs: []
  type: TYPE_NORMAL
- en: King Bob
  prefs: []
  type: TYPE_NORMAL
- en: Banana!
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Local Variable Type Inference (var)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java 10+**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Java 10 or higher, you can use **`var`** when you’re declaring
    your *local* variables (i.e., variables inside methods, **not** method parameters
    or instance variables).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0698-01.png)'
  prefs: []
  type: TYPE_IMG
- en: This is another example of *type inference*, where the compiler can use what
    it already knows about the types to save you from writing more. The compiler knows
    *name* is a String because it was declared as a String on the right hand side
    of the equals sign.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0698-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Type inference, NOT dynamic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you declare your variable using *var*, ***it still has a type***. It’s
    not a way of adding dynamic or optional types to Java (it’s **not** like Groovy’s
    *def*). It’s simply a way of avoiding writing that type twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do have to somehow tell the compiler what the type is when you declare
    the variable. You can’t assign it later. So, you ***can’t*** do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0698-03.png)'
  prefs: []
  type: TYPE_IMG
- en: because the compiler has no idea what type *name* is.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also means that you can’t change its type later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0698-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Someone has to read your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using *var* does make the code shorter, and an IDE can tell you exactly what
    type your variable is, so you might be tempted to use var everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: However, someone reading your code might not be using an IDE or have the same
    understanding of the code as you.
  prefs: []
  type: TYPE_NORMAL
- en: We did not use var in this book (even though it would have been easier to fit
    the code on the pages), because we wanted to be explicit to you, the reader, about
    what the code was doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: Better with useful variable names'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t have the type information visible in the code, descriptive variable
    and method names will be extra helpful to a reader.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0698-05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tip: Variable will be the concrete type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 11](ch11.xhtml#data_structures_collections_and_generics) we started
    “programming to interfaces”; i.e., we declared our variables as the interface
    type, not the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using var, you can’t do this. The type will be the type from the
    right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0698-06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tip: Don’t use var with the diamond operator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at the last example. We declared list first as a List<String> and used
    the diamond operator (<>) on the right-hand side. The compiler knows the type
    of the list element is a String from the lefthand side.
  prefs: []
  type: TYPE_NORMAL
- en: If you use var, like we did in the second example, the compiler no longer has
    this information. If you want the list to still be a list of Strings, you need
    to declare that on the righthand side; otherwise, it will contain Objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0698-07.png)'
  prefs: []
  type: TYPE_IMG
- en: Read all the style guidelines from the OpenJDK developers (*[https://oreil.ly/eVfSd](https://oreil.ly/eVfSd)*).
  prefs: []
  type: TYPE_NORMAL
- en: '#1 Records'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do you care?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A “simple” Java data object is often not simple at all. Even a data class (sometimes
    called a Java Bean, for historical reasons) with only a couple of fields requires
    quite a lot more code than you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: A Java data class, before Java 16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine a basic Customer class, with a name and an ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ve left out the details of the equals, hashCode, and toString methods, but
    you would probably want to implement those methods, especially if you’re going
    to use this object in any collections. We’ve also left off the “setters”; this
    is an immutable object with final fields, but in some cases you might want setters
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a lot of code! It’s a simple class with two fields, and the full code,
    including implementation, is 41 lines!
  prefs: []
  type: TYPE_NORMAL
- en: What if there was a special syntax for data classes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Guess what? If you’re using **Java 16** or higher, there is! Instead of creating
    a *class*, you create a *record*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0699-01.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s it. That’s all you need to do to replace the 42 lines of code of the
    “old” Customer data class.
  prefs: []
  type: TYPE_NORMAL
- en: A record like this one has instance variables, a constructor, accessor methods,
    and equals, hashCode, and toString methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re using a record that’s already been defined, it looks exactly the
    same as it would if the record class was a standard data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0699-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0699-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Goodbye “get”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you notice something? Records don’t use the classic “get” prefix for the
    methods that let you read the instance variables (hence we carefully called them
    “accessors” and not “getters”). They just use the name of the record component
    as the method name.
  prefs: []
  type: TYPE_NORMAL
- en: You can override constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The constructor, accessors, and equals, hashCode, and toString methods are all
    provided by default, but you can still override their behavior if you need something
    specific.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you probably won’t need to. But if you want, for example,
    to add validation when you create the record, you can do that by overriding the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, it’s even easier than that. The example above is a ***canonical constructor***,
    i.e., the normal kind of constructor we’ve been using everywhere. But records
    also have a ***compact constructor***. This compact constructor assumes all the
    normal stuff is taken care of (having the right number of parameters in the right
    order, and all assigned to the instance variables) and lets you define only the
    other stuff that matters, like validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0699-04.png)'
  prefs: []
  type: TYPE_IMG
- en: When you call the Customer’s constructor, you still need to pass it an ID and
    a name, and they will still be assigned to the instance variables (that’s all
    defined by the record header). All you need to do to add validation to the constructor
    is use the compact form and let the compiler take care of all of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0700-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You can override or add methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can override any of the methods and add your own (public, default, or private)
    methods. If you are migrating existing data classes to use records, you may want
    to keep your old equals, hashCode, and toString methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0700-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You can create a protected method; the compiler won’t stop you, but there’s
    no point—records are always *final* classes and can’t be subclassed.
  prefs: []
  type: TYPE_NORMAL
- en: Records are immutable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con), we talked
    about making data objects *immutable*. Immutable objects are safer to use in concurrent
    applications, because you know that it’s impossible for more than one thread to
    change the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also easier to reason about what’s happening in your application if you
    know the data classes can’t change, so even in applications that aren’t multithreaded,
    you may find immutable data objects being used. And in #9 in this appendix we
    saw how immutability in Strings can save memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Records are immutable. You can’t change the values in a record Object after
    you have created it; there are no “setters” and no way to change the instance
    variables. You can’t access them directly from outside the record, only read them
    via the accessor method.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to change one of the record’s instance variables from inside the
    record, the compiler will throw an exception. A record’s instance variables are
    *final*.
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about records in Oracle’s Record Classes documentation (*[https://oreil.ly/D7fh3](https://oreil.ly/D7fh3)*).
    There, you can also read about some of the other new language features available
    in Java 17 that we didn’t get a chance to cover, like Pattern Matching, Sealed
    Classes, Switch Expressions, and the very useful Text Blocks.
  prefs: []
  type: TYPE_NORMAL
