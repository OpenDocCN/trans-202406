- en: Chapter 8\. Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our journey through React thus far, we have uncovered an extensive range
    of features and principles that contribute to its power and versatility. The previous
    chapter delved into the fascinating world of asynchronous React, which empowers
    us with tools like `useTransition` and `useDeferredValue` to create highly responsive
    and user-friendly interfaces. We explored how these tools utilize the sophisticated
    scheduling and prioritization mechanisms of React, made possible by the Fiber
    reconciler, to achieve optimal performance. The understanding of these asynchronous
    patterns is critical as we venture into the realm of React frameworks in this
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: React by itself is incredibly powerful, but as applications grow in complexity,
    we often find ourselves repeating similar patterns or needing more streamlined
    solutions for common challenges. This is where frameworks come in. React frameworks
    are software libraries or toolkits built on top of React, providing additional
    abstractions to handle common tasks more efficiently and enforce best practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Why We Need a Framework
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While React provides the building blocks to create interactive user interfaces,
    it leaves many important architectural decisions up to the developers. React is
    unopinionated in this regard, giving developers the flexibility to structure their
    applications in the way they see fit. However, as applications scale, this freedom
    can turn into a burden. You might find yourself reinventing the wheel, dealing
    with common challenges such as routing, data fetching, and server-side rendering
    again and again.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This is where React frameworks come in. They provide a predefined structure
    and solutions to common problems, allowing developers to focus on what’s unique
    about their application, rather than getting bogged down with boilerplate code.
    This can significantly accelerate the development process and improve the quality
    of the codebase by adhering to best practices enforced by the framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully understand this, let’s try to write our own minimal framework. In
    order to do this, we need to identify a few key features that we get from frameworks
    that we do not get as easily from plain React. For the sake of brevity, we’ll
    identify three key features along these lines that we get from frameworks . It’s
    worth noting that frameworks do far more, but this subset will help us form the
    basis of a great discussion:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data fetching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a preexisting imaginary React application and incrementally add
    these features to understand what frameworks do for us. The React app we’re “framework-ifying”
    has the following structure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s what each file looks like:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are a few issues with this that affect all client-only rendered React
    applications:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: We ship an empty page to a user with only code to load, then parse and execute
    JavaScript.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A user downloads a blank page until JavaScript kicks in, and then they get our
    app. If the user is a search engine, they may see nothing. If the search engine
    crawler does not support JavaScript, the search engine will not index our website.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: We start fetching data too late.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app falls prey to a user-experience curse called *network waterfalls*:
    a phenomenon that occurs when network requests happen in succession and slow down
    applications. Our application has to make multiple requests to a server for basic
    functionality. For instance, it executes like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Download, parse, and execute JavaScript.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render and commit React components.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect` starts fetching data.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render and commit spinners, etc.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect` finishes fetching data.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Render and commit data. All of this can be avoided if we serve a page with
    data straight to the browser: if we send HTML markup as covered in [Chapter 7](ch07.html#ch07)
    on server-side React.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our router is purely client based.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If a browser requests [*https://our-app.com/detail?thingId=24*](https://our-app.com/detail?thingId=24),
    the server responds with a 404 page because there is no such file on the server.
    A common hack used to remedy this is to render an HTML file when a 404 is encountered
    that loads JavaScript and has the client-side router take over. This hack doesn’t
    work for search engines or environments where JavaScript support is limited.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks help resolve all these issues and more. Let’s explore how exactly
    they do this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Server Rendering
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with, frameworks usually give us server rendering out of the box. To
    add server rendering to this application, we need a server. We can write one ourselves
    using a package like Express.js. We would then deploy this server and we’re in
    business. Let’s explore the code that would power such a server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Before we do, please be aware that we’re using `renderToString` merely for simplicity
    and to illustrate the underlying mechanisms behind how frameworks implement these
    features. In a real production use case, it’s almost always better to rely on
    more powerful asynchronous APIs for server rendering like `renderToPipeableStream`,
    as covered in [Chapter 6](ch06.html#ch06).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, let’s do this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is all we need to add server rendering to our application. Notice
    how `index.js` on the client side has its own client router, and how we essentially
    just added another one for the server. Frameworks ship *isomorphic routers*, which
    are routers that work on both the client and the server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While this server is *OK*, it doesn’t scale well: for each route we add, we’ll
    have to manually add more `req.get` calls. Let’s make this a little more scalable.
    We can solve this in a number of ways, like with a configuration object that maps
    routes to components, or with filesystem-based routing. For the sake of education
    (and frankly, fun) let’s explore *filesystem-based routing*. This is where the
    reasoning for and mechanism behind the conventions and opinions of frameworks
    like Next.js become more clear. When we enforce a convention such that all pages
    must go in a *./pages* directory and all filenames in this directory become router
    paths, then our server can rely on the convention as an assumption and become
    more scalable.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate this with an example. First, we’ll augment our directory structure.
    The new directory structure looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can assume that everything in `pages` becomes a route. Let’s update
    our server to match this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, our server scales far better because of the new *./pages* directory convention
    we’ve adopted! Great! However, we’re now forced to have each page’s component
    be a default export since our approach is more general and there would otherwise
    be no way to predict what name to import. This is one of the trade-offs of working
    with frameworks. In this case, the trade-off seems to be worth it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Data Fetching
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Great! We’re 2 for 3\. We’ve got server rendering and filesystem-based routing,
    but we’re still suffering from network waterfalls. Let’s fix the data fetching
    story. To start with, we’ll update our components to receive initial data through
    props. For simplicity, we’ll deal with just the `List` component and leave the
    `Detail` component for you to do as homework:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Great. Now that we’ve added an initial prop, we need some way to fetch the
    data this page needs on the server, and then pass it to the component before rendering
    it. Let’s explore how we can do that. Ideally, what we want to do is this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This means we’ll need to export a fetcher function called `getData` from any
    page components that need data! Let’s adjust the list to do this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Done! Now we’re:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data as early as possible on the server for each route per file
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a full page as an HTML string
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending this to a client
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ve successfully added and understood the three features we’ve identified
    from various frameworks and implemented a basic version of them. By doing this,
    we’ve learned and now understand the underlying mechanism by which frameworks
    do what they do. Specifically, we learned how frameworks:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Give us server rendering
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have isomorphic routing, influenced by the filesystem
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch data through exported functions
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’ve used Next.js versions before 13, the reasoning for its various patterns
    should become abundantly clear at this point, specifically patterns around:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The *./pages* directory
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All page exports are default exports
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getServerSideProps` and `getStaticProps`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the mechanism behind frameworks at the code level and
    the reasons for some of their conventions, let’s zoom out and summarize the benefits
    of using a framework.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了框架在代码层面的机制以及一些约定背后的原因，让我们放大视野，总结使用框架的好处。
- en: Benefits of Using a Framework
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框架的好处
- en: 'The benefits of using a framework include:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架的好处包括：
- en: Structure and consistency
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象
- en: Frameworks enforce a certain structure and pattern to organize the codebase.
    This leads to consistency, making it easier for new developers to understand the
    flow of the application. It also enables us to focus on our products and features
    without worrying about the minutiae of how to structure our code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 框架强制执行一定的结构和模式来组织代码库。这导致一致性，使新开发人员更容易理解应用程序的流程。它还使我们能够专注于我们的产品和功能，而不必担心如何构建代码的细枝末节。
- en: Best practices
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Frameworks often come with baked-in best practices that developers are encouraged
    to follow. This can lead to better code quality and fewer bugs. For example, frameworks
    might encourage you to fetch data early—i.e., on the server—rather than waiting
    for the client to fetch it. This can lead to better performance and user experience.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 框架通常内置了最佳实践，鼓励开发人员遵循。这可以提高代码质量，减少错误。例如，框架可能鼓励您尽早获取数据—即，在服务器端—而不是等待客户端获取数据。这可以提高性能和用户体验。
- en: Abstractions
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化
- en: Frameworks provide higher-level abstractions to handle common tasks such as
    routing, data fetching, server rendering, and more. This can make your code cleaner,
    more readable, and easier to maintain, while leaning on the broader community
    to ensure the quality of these abstractions. An example of this is the `useRouter`
    hook provided by Next.js, which makes it easy to access the router in your components.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供更高级别的抽象来处理常见任务，如路由、数据获取、服务器渲染等。这可以使您的代码更清晰、更易读，更易于维护，同时依赖更广泛的社区来确保这些抽象的质量。Next.js提供的`useRouter`钩子就是一个例子，它使得在组件中访问路由变得容易。
- en: Performance optimizations
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 社区和生态系统
- en: Many frameworks come with out-of-the-box optimizations such as code splitting,
    server-side rendering, and static site generation. These can significantly improve
    the performance of your application. For example, Next.js automatically code-splits
    your application and preloads the code for the next page when the user hovers
    over a link, leading to faster page transitions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架都带有开箱即用的优化，如代码拆分、服务器端渲染和静态站点生成。这些可以显著提高应用程序的性能。例如，Next.js自动对应用程序进行代码拆分，并在用户悬停在链接上时预加载下一页的代码，从而实现更快的页面转换。
- en: Community and ecosystem
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的框架拥有庞大的社区和丰富的插件和库生态系统。这意味着如果遇到问题，你通常可以快速找到解决方案或获得帮助。
- en: Popular frameworks have a large community and a rich ecosystem of plug-ins and
    libraries. This means you can often find a solution or get help quickly if you
    run into a problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 流程和一致性
- en: Trade-Offs of Using a Framework
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框架的权衡
- en: 'While frameworks come with many advantages, they are not without their trade-offs.
    Understanding these can help you make an informed decision about whether to use
    a framework and which one to choose:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管框架有许多优点，但也不是没有权衡之处。了解这些可以帮助您就是否使用框架以及选择哪个框架做出明智的决定：
- en: Learning curve
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 学习曲线
- en: Every framework comes with its own set of concepts, APIs, and conventions that
    you need to learn. If you’re new to React, trying to learn a framework at the
    same time can be overwhelming but is still recommended. If you’re already familiar
    with React, you’ll need to invest time in learning the framework’s specific features
    and APIs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架都有自己的一套概念、API和约定，您需要学习。如果您是React的新手，同时尝试学习一个框架可能会让人不知所措，但仍然值得推荐。如果您已经熟悉React，您需要投入时间学习框架的特定功能和API。
- en: Flexibility versus convention
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性与约定
- en: While the enforced structure and conventions of a framework can be a boon, they
    can also be constraining. If your application has unique requirements that don’t
    fit into the framework’s model, you might find yourself fighting against the framework
    rather than being helped by it. There are some cases where you’re building for
    a specific user group with fast internet and a modern browser, and you don’t need
    server-side rendering or data fetching. In these cases, a framework might be overkill.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Dependency and commitment
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a framework is a commitment. You’re tying your application to the fate
    of the framework. If the framework stops being maintained or if it takes a direction
    that doesn’t align with your needs, you may face difficult decisions about whether
    to undertake a costly migration to a different framework or to maintain the existing
    framework code yourself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction overhead
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: While abstractions can simplify development by hiding complexity, they can also
    create “magic” that makes it difficult to understand what’s happening under the
    hood. This can make debugging and performance tuning challenging. Furthermore,
    every abstraction comes with some overhead, which might impact performance. An
    example of this is server actions in Next.js, where the `"use server"` directive
    somehow magically makes the action run on the server. This is a great abstraction,
    but it can be difficult to understand how it works.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand why we might want to use a React framework, and the benefits
    and trade-offs involved, we can delve into specific frameworks in the React ecosystem.
    In the upcoming sections of this chapter, we’ll explore some of the popular choices,
    such as Next.js and Remix. Each framework offers unique features and advantages,
    and understanding them will equip you with the knowledge to choose the right tool
    for your specific needs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Popular React Frameworks
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s explore some of the popular React frameworks and discuss their features,
    advantages, and trade-offs. We’ll start with a brief overview of each framework,
    followed by a detailed comparison of their features and performance. We’ll also
    discuss some of the factors to consider when choosing a framework for your project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Remix
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix is a powerful modern web framework that leverages React and the features
    of the web platform. Let’s get started with some practical examples to understand
    how it works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: A basic Remix application
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we’ll set up a basic Remix application. You can install Remix using
    `npm`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will create a new Remix project in your current directory. Let’s look around
    and see what’s inside. To start with, we’ve got an *app* directory with *entry.client.tsx*
    and *entry.server.tsx*. We’ve also got a *root.tsx* in this directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Off the bat, we can immediately see that Remix supports client and server entry
    points out of the box. Moreover, the *root.tsx* contains a shared layout component
    that is rendered on every page. This is a great example of how Remix provides
    a predefined structure to help you get started quickly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们可以立即看到 Remix 默认支持客户端和服务器端入口点。此外，*root.tsx* 包含一个共享布局组件，该组件在每个页面上都会渲染。这是
    Remix 提供的一个预定义结构的很好示例，帮助您快速入门。
- en: Server rendering
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: 'Remix provides server rendering out of the box through its *entry.server.tsx*.
    The file is generated for us, but let’s understand it a little bit. Here’s what
    it looks like:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 通过其 *entry.server.tsx* 默认支持服务器端渲染。文件由框架为我们生成，但让我们稍微理解一下它。它看起来是这样的：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The great thing about Remix is that this file is used internally, but is exposed
    here for us to customize. If we delete this file, Remix will defer to its internal
    default implementation of the same file. This is a nice escape hatch that allows
    us to customize the server rendering behavior if we need to, while not locking
    us into the framework’s “magic.”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的一个很棒的特性是，这个文件在内部使用，但在此处暴露出来供我们定制。如果我们删除这个文件，Remix 将会使用其内部默认的实现。这是一个很好的逃生口，允许我们根据需要定制服务器渲染行为，而不会被框架的“魔法”所束缚。
- en: This file is defining how HTTP responses should be generated and handled in
    our Remix application, particularly concerning how requests are managed differently
    for bots and regular browsers. Remix is a framework for building modern React
    applications, and this file is a part of the server-side logic of a Remix app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件定义了在我们的 Remix 应用程序中生成和处理 HTTP 响应的方式，特别是关于如何处理来自机器人和常规浏览器的请求的不同方式。Remix 是一个用于构建现代
    React 应用程序的框架，而这个文件是 Remix 应用程序的服务器端逻辑的一部分。
- en: Initially, the file imports necessary modules and types from various libraries,
    such as the `node:stream`, `@remix-run/node`, `@remix-run/react`, `isbot`, and
    `react-dom/server`. It defines a constant `ABORT_DELAY` with a value of 5,000
    milliseconds, which is used as a timeout period for rendering operations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，文件从各种库中导入必要的模块和类型，例如 `node:stream`，`@remix-run/node`，`@remix-run/react`，`isbot`
    和 `react-dom/server`。它定义了一个名为 `ABORT_DELAY` 的常量，其值为 5,000 毫秒，用作渲染操作的超时期限。
- en: The file exports a default function `handleRequest` that takes several arguments,
    including the HTTP request, response status code, response headers, and contexts
    for Remix and the application’s load process. Inside `handleRequest`, it checks
    the user-agent of the incoming request to determine if it’s coming from a bot
    using the `isbot` library. Depending on whether the request is from a bot or a
    browser, it delegates the handling to either `handleBotRequest` or `handleBrowserRequest`
    functions, respectively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 文件导出了一个名为 `handleRequest` 的默认函数，该函数接受多个参数，包括 HTTP 请求、响应状态码、响应头以及 Remix 和应用程序加载过程的上下文。在
    `handleRequest` 内部，它检查传入请求的用户代理，以确定请求是否来自使用 `isbot` 库的机器人。根据请求来自机器人还是浏览器，它将处理委托给
    `handleBotRequest` 或 `handleBrowserRequest` 函数。
- en: This helps with SEO and performance. For example, if a request comes from a
    bot, it’s important to ensure that the response contains the rendered HTML content
    of the page, which is what `handleBotRequest` does. On the other hand, if the
    request comes from a regular browser, it’s important to ensure that the response
    contains the rendered HTML content of the page along with the necessary JavaScript
    code to hydrate the page, which is what `handleBrowserRequest` does. It’s pretty
    cool that Remix handles this for us automatically.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于 SEO 和性能。例如，如果请求来自机器人，则确保响应包含页面的渲染 HTML 内容非常重要，这正是 `handleBotRequest` 的作用。另一方面，如果请求来自常规浏览器，则确保响应包含页面的渲染
    HTML 内容以及必要的 JavaScript 代码以水合页面非常重要，这正是 `handleBrowserRequest` 的作用。很酷的是，Remix
    自动为我们处理了这些。
- en: Both `handleBotRequest` and `handleBrowserRequest` functions are fairly similar
    in structure but have different handlers for when the rendering shell is ready
    or encounters an error. They return a promise that resolves to an HTTP response.
    They initiate a rendering operation to a pipeable stream with `renderToPipeableStream`,
    passing in a `RemixServer` component along with the necessary context and URL
    from the request. They define a timeout to abort the rendering operation if it
    takes longer than `ABORT_DELAY`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleBotRequest`和`handleBrowserRequest`函数在结构上非常相似，但在渲染外壳准备就绪或遇到错误时有不同的处理程序。它们返回一个解析为HTTP响应的承诺。他们通过`renderToPipeableStream`启动一个到可管道流的渲染操作，传入一个`RemixServer`组件以及来自请求的必要上下文和URL。他们定义了一个超时时间，如果渲染操作时间超过`ABORT_DELAY`，则中止渲染操作。'
- en: In the event handlers for the rendering operation, they create a `PassThrough`
    stream and a readable stream from it. They set the `Content-Type` header to `text/html`
    for the response. They resolve the promise with a new `Response` object that encapsulates
    the stream, response headers, and status code. In case of errors during rendering,
    they either reject the promise or log the error to the console, depending on the
    rendering stage where the error occurred.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染操作的事件处理程序中，他们创建了一个`PassThrough`流和从中读取的可读流。他们为响应设置了`Content-Type`头为`text/html`。他们使用封装了流、响应头和状态码的新`Response`对象来解析承诺。在渲染过程中出现错误时，他们要么拒绝承诺，要么将错误记录到控制台，这取决于错误发生的渲染阶段。
- en: This file essentially ensures that the HTTP responses are correctly generated
    and returned, with different rendering logic applied based on whether the request
    comes from a bot or a regular browser, which is crucial for SEO and performance
    considerations in modern web applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件主要确保正确生成并返回HTTP响应，根据请求来自机器人还是常规浏览器的不同渲染逻辑应用，这对于现代Web应用程序的SEO和性能考虑至关重要。
- en: If we have no customizations to make, we can simply delete this file, and Remix
    will handle the server rendering for us. Let’s keep it for now and explore how
    Remix handles routes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有自定义内容要添加，我们可以简单地删除这个文件，Remix会为我们处理服务器渲染。现在让我们保留它，并探索一下Remix如何处理路由。
- en: Routing
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由
- en: 'In Remix, each route is represented by a file in the *routes* directory. If
    we create *./routes/cheese.tsx*, whose default export is:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Remix中，每个路由都由*routes*目录中的一个文件表示。如果我们创建*./routes/cheese.tsx*，其默认导出为：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and then run the local development server with `npm run dev`, we’ll see a page
    with a funny heading. Once again, we see how Remix provides a predefined structure
    to help you get started quickly, and the value of default exports in this convention
    is similar to our own implementation of filesystem-based routing earlier. When
    combined with the shared layout component in *./app/root.tsx* and both the server
    and client entry points, this forms the basis of most websites. However, we’re
    still missing one crucial component for a modern web application: data fetching.
    Let’s look at how Remix handles this.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用`npm run dev`运行本地开发服务器，我们会看到一个有趣标题的页面。再次看到Remix提供了一个预定义的结构，帮助您快速入门，而这种约定中默认导出的价值类似于我们之前基于文件系统的路由实现。当与*./app/root.tsx*中的共享布局组件以及服务器和客户端入口点结合使用时，这构成了大多数网站的基础。然而，对于现代Web应用程序，我们仍然缺少一个至关重要的组件：数据获取。让我们看看Remix如何处理这个问题。
- en: Data fetching
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据获取
- en: The Remix data fetching story at the time of writing involves the use of functions
    called *loaders*. When you export an async function called `loader` that returns
    some value, this value becomes available to your page component through the `useLoaderData`
    hook. Let’s see how this works with an example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Remix的数据获取故事涉及使用称为*loaders*的函数。当您导出一个名为`loader`的异步函数，返回某个值时，这个值通过`useLoaderData`钩子可在页面组件中使用。让我们通过一个示例看看这是如何工作的。
- en: 'To go back to our cheese page, let’s say we want to fetch a list of cheeses
    from an API and display them on the page. We can do this by exporting a `loader`
    function from *./routes/cheese.tsx*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要回到我们的奶酪页面，假设我们想从 API 获取奶酪列表并在页面上显示它们。我们可以通过从*./routes/cheese.tsx*导出一个`loader`函数来实现这一点：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this, we see a recurrence in our own earlier implementation of data fetching.
    We can see how the Remix `loader` function is similar to our own `getData` function.
    We can also see how the `useLoaderData` hook is similar to our own `initialThings`
    prop. Ideally, at this time we’re able to glean the common patterns and underlying
    mechanisms behind how frameworks implement these features.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve covered:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data fetching
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But there’s one more Remix feature that we haven’t covered yet: forms and server
    actions, or mutations—that is, mutating data on the server, like creating, updating,
    or deleting data. Let’s explore this next.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remix was responsible for bringing the web back to its fundamentals, leaning
    heavily on native web platform conventions and behavior. This is best seen around
    data mutations and Remix’s usage of forms. Let’s explore this with an example,
    extending our previous cheese example: let’s make the cheese list mutable. To
    do so, let’s start by updating our *./routes/cheese.tsx* file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice we’ve added a new `form` element to the page. This form has an action
    of `/cheese` and a method of `post`. This is a standard HTML form that will submit
    a POST request to the `/cheese` route. Moreover, the `input` has a `name` attribute
    and no `useState` or `onChange` handler: Remix lets the browser manage the state
    and behavior of the form. This is a great example of how Remix leans on the web
    platform to provide a great developer experience, and doesn’t try to reinvent
    the wheel having React manage everything.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Given that the form’s action property is `/cheese` and we’re already in the
    *./routes/cheese.tsx* file, we can assume that the form will submit to the same
    route. When this route is accessed with a `POST` method, we know that the form
    has been submitted. When this route is accessed with the `GET` method by default,
    we know that the form has not been submitted and we instead show the initial UI.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update our *./routes/cheese.tsx* file to handle this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how we’ve added a new `action` function that takes a `params` and `request`
    argument. The `params` argument is an object that contains the parameters of the
    route. The `request` argument is an object that contains the request object. We
    can use this to get the form data from the request and then use it to make a request
    to our API to add a new cheese.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: We then return a redirect to the same route, but this time with a `GET` method.
    This will cause the page to be reloaded, and the `loader` function will be called
    again to fetch the updated list of cheeses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This is how Remix fully leans on the web platform to enable JavaScript to be
    used where it’s needed, and to let the browser handle the rest. If this page was
    visited without JavaScript, it would just work because it leans on the web platform.
    If the page does use JavaScript, Remix progressively enhances the experience by
    adding interactivity and a better user experience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve covered how Remix:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Provides server rendering
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles routing
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles data fetching
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles data mutations
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we should be seeing strong parallels between our own implementation
    of these features and Remix’s implementation. This is a great sign that we’re
    understanding the underlying mechanisms behind how frameworks implement these
    features.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s consider Next.js and how it does very similar things to isolate the
    commonalities behind the way these features are implemented.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Next.js
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next.js, a popular React framework by Vercel, is well-known for its rich features
    and simplicity in creating server-side rendered (SSR) and static websites. It
    follows the convention over configuration principle, reducing the amount of boilerplate
    and decision-making necessary to start a project. With the release of Next.js
    13, a significant addition has been the introduction of the Next.js App Router.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through a basic Next.js application to understand how it works.
    To start, let’s run the following command to create a new Next.js project:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will ask us some questions, but ultimately we’ll arrive at a basic Next.js
    project. Let’s look around and see what’s inside. To start with, we’ve got an
    *app* directory with *page.tsx*, *layout.tsx*, *error.tsx*, and *loading.tsx*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: One thing we immediately notice is that Next.js does not expose server configuration
    like Remix does, but instead hides away a large number of complexities with the
    intention of “getting out of the way” and letting developers focus on building
    their applications. This is a great example of how different frameworks have different
    philosophies and approaches to solving the same problems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore Next.js in the context of the three key features we identified
    earlier: server rendering, routing, and data fetching.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next.js not only provides server rendering but is also server-first. Every page
    and component in Next.js is a server component. We dive quite deep into server
    components in [Chapter 9](ch09.html#ch09), but for now, suffice it to say that
    server components are components rendered exclusively on the server. This level
    of understanding is fine for now, as the focus is on Next.js, not server components.
    For server components, [Chapter 9](ch09.html#ch09) should be sufficient.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean in the context of Next.js, though? In essence, we are to
    operate on the basis that all the code we write executes on the server exclusively
    unless otherwise specified by adding a `"use client"` directive to the top of
    a given route or component. Without this directive, all code is assumed to be
    server code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Next.js also is static-first: at build time, the server components
    are rendered to as much static content as possible and then deployed. This combination
    of server-first and static-first is what makes Next.js so powerful and prioritizes
    performance pretty significantly, with static content being arguably the fastest
    to reach users as there’s no runtime or server-side processing required; it’s
    just text (HTML). The next step from static is server rendered content, which
    can be highly optimized and cached, but still requires a server to render the
    content. The final step is client-rendered content through hydration for interactive
    portions of the page.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, Next.js lends itself well to have smaller JavaScript bundles
    shipped to users, with the bulk of the content being some mix of static and server
    rendered markup. The level of granularity with which not just pages but components
    can be rendered on the server is a powerful feature of Next.js, enabling some
    very powerful data fetching and rendering patterns. Before we get to those patterns,
    let’s explore how Next.js handles routing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we see in our new Next.js project is an *app* directory with *layout.tsx*
    and *page.tsx*. Next.js follows this pattern: the path your users see in their
    browser, the URL of your page, is the name of the directory where *app* is equivalent
    to the root (*/*), and every directory under it becomes a subpath.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, let’s create a directory *cheese* and add a *page.tsx*
    file to it. When a directory under *./app* has a *page.tsx* file, that directory
    becomes a route. Let’s add some content to *./app/cheese/page.tsx*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, if we run the development server and navigate to */cheese*, we’ll see a
    page with a funny heading. It’s worth noting here that Next.js also has a concept
    of shared layouts, similar to Remix, where you can define a layout component in
    *./app/layout.tsx* and it will be rendered on every page. Then, *./app/cheese/layout.tsx*
    will be rendered on every page under the */cheese* route. Layouts are typically
    portions of routes that are shared across multiple pages, such as a header or
    footer, or other fixed elements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Great, this is how Next.js handles routing. It’s sort of similar to Remix and
    our own implementation of filesystem-based routing, but with a slight difference
    that it’s not a single file that becomes a page but instead an entire directory,
    and that the actual page is expected to called *page.tsx* all the time. Besides
    this, it’s pretty similar.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk about data fetching.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Data fetching
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because every component is a server component, every component in Next.js is
    capable of being asynchronous and thus, `await`-ing data. Let’s try to fetch cheeses
    like we did in our previous Remix example, but this time in Next.js:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you’re reading that and are impressed—yes. This syntax is what React engineers
    have hoped for for years, and is quite natural to reason about. This is possible
    because `CheesePage` here is a server component: it is not included in the client
    bundle and is instead rendered on the server. This means that we can `await` data
    and render it directly to the page.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Since all components are server components, we can further increase the granularity
    and not fetch at the page level, but at the component level too if we want to.
    Consider breaking this page into smaller components where `CheeseList` is reusable
    and is used in this page, but may be used elsewhere too.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Our page would become this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and our `CheeseList` component would be this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The true power of this approach is that we can fetch data at the component level,
    and then render it to the page. We don’t export a function from the page level
    like `loader`, `getData`, `getServerSideProps`, `getStaticProps`, or anything
    like that. Instead, we just fetch data at the component level and render it to
    the page.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: What happens to this data? Next.js uses it to statically generate the first
    load of our page when we deploy, and server renders it on subsequent loads. Next.js
    also has a number of caching and deduplication mechanisms that ensure data integrity
    and performance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s round out the comparison by exploring how Next.js handles data
    mutations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next.js has a concept of *server actions*, which are functions that run on the
    server. These are functions that are called when a form is submitted, a user clicks
    a button, or a user navigates to a page. They are functions that run on the server,
    and are not included in the client bundle.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at adding a cheese to the list like we did in our Remix example.
    To do this, we’ll add a form to our page:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’re using a standard-ish HTML form here similar to Remix, except the `action`
    attribute is a function this time. This function is a server action, and it is
    called when the form is submitted. This function is not included in the client
    bundle and is instead run on the server. This is enforced by the `"use server"`
    directive at the top.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We could move this function wherever we want, including into the body of the
    server component, like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'or even into a separate module, like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, `addCheeseAction` would be in its own file and read like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There’s an inherent problem here though, because unlike Remix where all components
    are client components, server components do not support interactivity at all since
    they are not included in the client bundle and never loaded by the browser; thus,
    `onClick` handlers never actually make it to users. To solve this problem, Next.js
    has a concept of client components, which are included in the client bundle and
    are loaded by the browser. These components are not server components, and thus
    cannot be asynchronous or have server actions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore adding a cheese, but this time with a mix of server and client
    components. This will also help us react to the form submission by immediately
    providing feedback with a spinner or similar. To do this, we’ll create a new component,
    *./app/AddCheeseForm.tsx*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that it’s a client component, we can do interactive things—like respond
    to form state changes. Let’s update our `AddCheeseForm` to do that:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because our `AddCheeseForm` is a client component, we can use the `useFormStatus`
    to get the status of the form. This is a hook provided by React. This hook returns
    an object with a `pending` property that is `true` when the form is submitting,
    and `false` when the form is not submitting. We can use this to disable the form
    while it’s submitting, and to show a loading indicator.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use this form in our page, which is a server component, like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As a result, we’ve got a mix of server and client components. The `CheesePage`
    and `CheeseList` are server components, and the `AddCheeseForm` is a client component.
    Both components are reusable and can be used elsewhere in our application. There
    are some rules and considerations around client and server components, but we’ll
    explore those in [Chapter 9](ch09.html#ch09).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: For now, if we zoom out we can see that Next.js solves similar problems as Remix
    and our own implementation of filesystem-based routing, data fetching, and data
    mutations. It does so in a slightly different way, but the underlying mechanisms
    are somewhat similar.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, by exploring both of these frameworks, we’re able to understand why
    we would reach for frameworks, the problems they solve, and how they solve them
    for our benefit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Let’s wrap up by talking about how to choose a framework.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Framework
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deciding which React framework to use for your project can be a challenging
    decision, as each offers a distinct set of features, advantages, and trade-offs.
    In this section, we will attempt to provide some insight into what makes popular
    React frameworks a viable option for developers today, and discuss factors such
    as learning curve, flexibility, and performance, which can guide you in choosing
    the most suitable framework for your specific needs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that one framework is not inherently better or worse than
    another. Each framework has its own set of strengths and weaknesses, and the best
    framework for your project will depend on your specific requirements and preferences.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Your Project Needs
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into the details of each framework, it’s important to understand
    your project’s specific needs. Here are some critical questions to consider:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: What is the scope of your project? Is it a small personal project, a medium-sized
    application with several features, or a large-scale, complex application?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the main functionalities and features you want to include in your project?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you require server-side rendering (SSR), site generation (SSG), or a combination
    of both?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you building a content-heavy site like a blog or ecommerce site that might
    benefit from excellent SEO?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is real-time data or highly dynamic content a critical part of your application?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much flexibility do you require in terms of customization and control over
    the build process?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How important are the performance and speed of your application?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is your proficiency level with React and general web development concepts?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who are your target users? Enterprise folks sitting at desks with fast internet?
    Or the general public with a wide range of devices and internet speeds?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the answers to these questions will give you a clearer picture
    of what you need from a framework.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Next.js
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore some of these parameters in the context of Next.js:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Learning curve
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Next.js uses the bleeding edge of React under the hood, often making use of
    canary releases of React. This means that Next.js is often ahead of the curve
    and can be a bit more challenging to learn. However, the Next.js team does a great
    job of documenting the framework and providing clear guides for various features,
    which can help you get started quickly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Next.js is designed with flexibility in mind between static and server rendered
    content. It also supports entirely client-side applications, though this is not
    its primary use case. Next.js also provides a rich ecosystem of plug-ins and integrations,
    which can significantly speed up the development process.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Next.js aggressively prioritizes performance, with a focus on static generation
    and server-side rendering, as well as caching. Next.js ships with four distinct
    purpose-driven caches at the time of writing, each tailored to provide the best
    performance for a number of use cases. This performance, though, can come at a
    cost of friction around the boundaries between client/server and the decision-making
    around when to use which.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that some members of the team that builds React work
    at Vercel, where Next.js is developed, which suggests an extremely tight feedback
    loop of development between Next.js and React.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Remix
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compared to Next.js, Remix is a newer entry to the React framework scene, created
    around 10 years earlier. It’s built by the creators of React Router and emphasizes
    web fundamentals, making fewer assumptions and providing a lot of flexibility:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Learning curve
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Remix might have a slightly flatter learning curve because it relies more heavily
    on web fundamentals and uses React the way many have learned it before the heavier
    emphasis on server components.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Intuitiveness
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix often gets out of the way and allows the fundamentals of the web platform
    to shine through. This can be a bit of a double-edged sword: on one hand, it’s
    great because it’s intuitive and familiar, but on the other hand, it can be a
    bit frustrating because it’s not as “magical” as other frameworks.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s unique approach to routing and data loading makes it efficient and performant.
    Since data fetching is tied to routes, only the necessary data for a specific
    route is fetched, reducing the overall data requirement. Plus, its optimistic
    UI updates and progressive enhancement strategies improve the user experience.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Trade-Offs
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing a framework does not come without trade-offs, the meat of which revolve
    around the continuum of convenience versus control. All frameworks remove a lot
    of the brainwork and decision-making around our applications by conventionalizing
    things. For example, frameworks by default have answers for questions like:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: How do we do routing?
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do static assets go?
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should we server render?
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do we fetch data?
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that frameworks so heavily conventionalize these topics and more, this
    takes control away from us, the developers. In exchange, we get quite a bit of
    convenience to charge forward and work on the more central aspects of our applications,
    like the business logic itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Most, if not all, trade-offs around frameworks revolve around this continuum.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how to choose the right framework? It all comes down to your project needs
    and personal preference:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: If you need a somewhat flexible full stack framework, Next.js might be a better
    fit since it lets you choose between static, server-side, or entirely client-only
    application.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you prefer a serverful, progressively enhanced approach with a strong adherence
    to web fundamentals, Remix could be your best bet.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any case, it’s a good idea to try one out for a smaller project or a part
    of your application. This will give you a better understanding of how they work
    and which one feels most comfortable to work with.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Developer Experience
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both frameworks offer world-class developer experience, with a focus on productivity
    and ease of use. They both provide a rich set of features and tools to help developers
    build high-quality applications, as we’ve seen previously in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Build performance becomes increasingly critical as a project grows in complexity
    and size. Both Next.js and Remix have made optimizations to improve the build
    time.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Next.js uses static generation by default, which means pages are prerendered
    at build time. This can lead to faster page loads, but also longer build times,
    especially for sites with a large number of pages.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: To address this, Next.js introduced Incremental Static Regeneration (ISR), allowing
    developers to regenerate static pages after they have been built, without a full
    rebuild. This feature can significantly improve build times for large, dynamic
    sites.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Remix, on the other hand, has a unique take on build performance. It opts for
    a server-first architecture, which means that pages are rendered on demand by
    the server, and the HTML is sent down to the client.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Performance
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both Next.js and Remix are designed with performance in mind and offer several
    optimizations to deliver fast, responsive applications.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Next.js comes with several built-in performance optimizations. It supports automatic
    code splitting, which ensures that only the necessary code is loaded for each
    page. It also has a built-in Image component that optimizes image loading for
    better performance.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The hybrid SSG/SSR model in Next.js allows developers to choose the optimal
    data fetching strategy for each page, balancing performance and freshness. Pages
    that don’t require fresh data can be prerendered at build time, resulting in faster
    page loads. For pages that require fresh data, server-side rendering or ISR can
    be used.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Next.js also provides automatic static optimization for pages without blocking
    data requirements, ensuring they are served as static HTML files, leading to faster
    time to first byte (TTFB).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Next.js takes full advantage of React Server Components where possible,
    allowing it to send less JavaScript to the client, resulting in faster page loads
    and other overhead.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Remix takes a slightly different approach to performance. Instead of prerendering
    pages, it opts for server rendering, streaming down just the HTML that the client
    needs. This can result in faster TTFB, especially for dynamic content.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features of Remix is its robust caching strategy. It leverages
    the browser’s native fetch and cache APIs, allowing developers to specify caching
    strategies for different resources. This leads to faster page loads and a more
    resilient application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Both Next.js and Remix offer compelling benefits for large-scale, complex projects.
    They both excel in developer experience, build performance, and runtime performance.
    Next.js might be a better choice if you prefer a mature ecosystem with extensive
    resources and plug-ins, a hybrid SSG/SSR model, and innovative features like ISR.
    On the other hand, Remix could be more suitable if you prefer a server rendered
    approach with instant deploys, a strong emphasis on embracing web platform features
    like fetch and cache APIs, and advanced React concepts like Suspense and Server
    Components.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The most suitable framework for your specific project needs would ultimately
    depend on your team’s expertise, your project requirements, and your preference
    for certain architectural patterns. Regardless of the choice, both Next.js and
    Remix are solid foundations for building high-quality, performant React applications.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we’ve delved deep into the concept of React
    frameworks. This chapter allowed us to explore the underlying principles, the
    reasoning, and the practical implications of using frameworks.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The discussion began by recapping concurrent React and its implications for
    efficient rendering and user interactivity. We then moved on to explore the “why”
    and the “what” of React frameworks: why they are necessary, what benefits they
    offer, and what trade-offs they entail.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: We did this by implementing our own basic framework, which allowed us to understand
    the underlying mechanisms and concepts behind React frameworks. We then explored
    the concept of filesystem-based routing, which is a common feature in many React
    frameworks. We also looked at data fetching and how it can be implemented in a
    framework.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dived into a comparison between different frameworks, focusing primarily
    on Next.js and Remix. Each framework offers its unique set of features and advantages,
    and the choice often comes down to the specific needs of the project. We explored
    how these frameworks solve for server rendering, routing, data fetching, and data
    mutations, and how they compare to our own implementation of these features.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Through this, we gleaned an understanding of the mechanism through the commonalities
    between our own implementation and the frameworks. We also explored the trade-offs
    involved in using frameworks, and how they can be mitigated by understanding the
    underlying mechanisms.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed how to choose a framework, and explored some of the trade-offs
    involved in this decision. We also looked at the developer experience and runtime
    performance of frameworks and considered what might be the best for our projects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we wrap up this chapter, here are some questions to help you review the
    concepts we’ve covered:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: What are the primary reasons for using a React framework like Next.js or Remix,
    and what benefits do they offer?
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of the trade-offs or downsides that come with using a React framework?
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some common problems solved by frameworks?
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do these frameworks solve them?
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up Next
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we briefly mentioned React Server Components and began to
    scratch their surface in a crude manner. In the next chapter, we’ll intensify
    our focus on React Server Components and dive a little bit deeper: understanding
    their value proposition and how they work by writing a minimal server that renders
    and serves React Server Components.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we’ll examine why React Server Components require a new generation
    of build tooling, like bundlers, routers, and more. Ultimately, we will come away
    with an improved understanding of React Server Components and their underlying
    mechanism in what is sure to be an informative and educational deep dive.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
