- en: Chapter 16\. Miscellaneous Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of this chapter is to go beyond troubleshooting a query, or an overloaded
    system, or setting up different MySQL topologies. We want to show you the arsenal
    of tools available for you to make daily tasks easier or investigate complex issues.
    Let’s start with MySQL Shell.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL Shell is an advanced client and code editor for MySQL. It expands the
    functionality of the traditional MySQL client that most DBAs worked with in MySQL
    5.6 and 5.7\. MySQL Shell supports programming languages such as Python, JavaScript,
    and SQL. It also extends functionalities using an API command syntax. For example,
    it is possible to customize scripts to administer an InnoDB Cluster. From MySQL
    Shell, you can also start and configure MySQL sandbox instances.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MySQL Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For supported Linux distributions, the easiest way to install MySQL Shell is
    to use the MySQL *yum* or *apt* repository. Let’s see how to install it on Ubuntu
    and CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MySQL Shell on Ubuntu 20.04 Focal Fossa
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing MySQL Shell in Ubuntu is relatively easy since it is part of the
    regular repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to configure the MySQL repository. We can use these commands
    to [download](https://oreil.ly/K7eq8) the *apt* repository to our server and install
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, update our package information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then execute the `install` command to install MySQL Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start MySQL Shell using the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Installing MySQL Shell on CentOS 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install MySQL Shell in CentOS 8, we follow the same steps as described for
    Ubuntu—but first we need to make sure the default MySQL package present in CentOS
    8 is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to configure our *yum* repository. We need to get the correct
    OS version from the [download page](https://oreil.ly/YvW74):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the repository installed, we will install the MySQL Shell binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can validate that the installation worked by running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Deploying a Sandbox InnoDB Cluster with MySQL Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell automates the deployment of sandbox instances with AdminAPI, which
    provides the `dba.deploySandboxInstance(`*`port_number`*`)` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the sandbox instances are placed in a directory named *$HOME/mysql-sandboxes/port*.
    Let’s see how to change the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A prerequiste to deploy a sandbox instance is to install the MySQL binaries.
    If necessary, review [Chapter 1](ch01.xhtml#CH1_INSTALL) for details. You’ll need
    to enter a password for the `root` user in order to complete the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to deploy two more instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create the InnoDB Cluster while connected to the seed MySQL
    Server instance. The *seed* instance is the instance we are connected to via MySQL
    Shell and that we want to replicate to the other instances. In this example the
    sandbox instances are all blank instances, so we can choose any instance. In a
    production setup the seed instance would be the one that contains the existing
    dataset to be replicated to the other instances in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use this command to connect MySQL Shell to the seed instance, in this case
    the one at port 3310:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Subsequently, we will use the `createCluster()` method to create the InnoDB
    Cluster with the currently connected instance as the seed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the output, three instances are capable of keeping the database
    online with one server failure, which is why we deployed three sandbox instances.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add secondary instances to our `learning_mysql` InnoDB Cluster.
    Any transactions that were executed by the seed instance are reexecuted by each
    secondary instance as it is added.
  prefs: []
  type: TYPE_NORMAL
- en: The seed instance in this example was recently created, so it is nearly empty.
    Therefore, there is little data that needs to be replicated from the seed instance
    to the secondary instances. If it’s necessary to replicate data, MySQL will use
    the [clone plugin](https://oreil.ly/VUASS) (discussed in [“Creating a Replica
    Using the Clone Plugin”](ch13.xhtml#clone_plugin)) to configure the instances
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add one secondary to see the process in action. To add the second instance
    to the InnoDB Cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the third instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we have created a cluster with three instances: a primary and
    two secondaries. We can see the status by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Assuming MySQL Router is already installed (see [“MySQL Router”](ch15.xhtml#MYSQL_ROUTER)),
    the only required step is to bootstrap it with the location of the InnoDB Cluster
    metadata server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We observe the router being bootstrapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]**  **## MySQL Shell Utilities'
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve said, MySQL Shell is a powerful, advanced client and code editor for
    MySQL. Among its many functionalities are utilities to create a logical dump and
    do a logical restore for the entire database instance, including users. The advantage,
    compared to `mysqldump`, for example, is that the utility has parallelization
    capacity, greatly improving the dump and restore speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the utilities to execute the dump and restore process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`util.dumpInstance()`'
  prefs: []
  type: TYPE_NORMAL
- en: Dump an entire database instance, including users
  prefs: []
  type: TYPE_NORMAL
- en: '`util.dumpSchemas()`'
  prefs: []
  type: TYPE_NORMAL
- en: Dump a set of schemas
  prefs: []
  type: TYPE_NORMAL
- en: '`util.loadDump()`'
  prefs: []
  type: TYPE_NORMAL
- en: Load a dump into a target database
  prefs: []
  type: TYPE_NORMAL
- en: '`util.dumpTables()`'
  prefs: []
  type: TYPE_NORMAL
- en: Load specific tables and views
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: util.dumpInstance()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dumpInstance()` utility will dump all the databases that are present in
    the MySQL data directory (see [“The Contents of the MySQL Directory”](ch01.xhtml#MYSQL_DIRECTORY_CONTENT)).
    It will exclude the `information_schema`, `mysql_`, `ndbinfo`, `performance_schema`,
    and `sys` schemas while taking the dump.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a dry-run option that allows you to inspect the schemas and view
    the compatibility issues and then run the dump with the appropriate compatibility
    options applied to remove the issues. Let’s try this now—we’ll examine the possible
    errors and see the options for the dump utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the dump, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `ocimds` option set to `true`, the dump utility will check the data
    dictionary and index dictionary. Encryption options in `CREATE TABLE` statements
    are commented out in the DDL files, to ensure that all tables are located in the
    MySQL data directory and use the default schema encryption. `strip_restricted_grants`
    removes specific privileges that are restricted by MySQL Database Service that
    would cause an error during the user creation process. `dryRun` is self-explanatory:
    it will perform validation only, and no data will be actually dumped.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a MyISAM table in the `test` database. The dry-run option clearly
    throws the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this error, we are going to use the `force_innodb` option, which will
    convert all unsupported engines to InnoDB in the `CREATE TABLE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now the dry run does not throw any errors, and there are no exceptions. Let’s
    run the `dumpInstance()` command to take an instance backup. The target directory
    must be empty before the export takes place. If the directory does not yet exist
    in its parent directory, the utility creates it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to process the dump in parallel. For this, we will use the option
    `threads` and set a value of 10 threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we observe the last part of the output, we’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were using `mysqldump`, we would have a single file. As we can see here,
    there are multiple files in the backup directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at these:'
  prefs: []
  type: TYPE_NORMAL
- en: The *@.json* file contains server details and lists of users, database names,
    and their character sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *@.post.sql* and *@.sql* files contain MySQL Server version details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *test.json* file contains view, stored procedure, and function names along
    with a list of tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *@.users.sql* file (not shown) contains a list of database users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *test@sbtest10.json* file contains column names and character sets. There
    will be a similiarly named file for each dumped table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *test@sbtest1.sql* file contains a table structure. There will be one for
    each dumped table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *test@sbtest10@@0.tsv.zst* file is a binary file. It stores data. There
    will be a similarly named file for each dumped table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *test@sbtest10@@0.tsv.zst.idx* file is a binary file. It stores table index
    stats. There will be a similarly named file for each dumped table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *@.done.json* file contains the backup end time and data file sizes in KB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *test.sql* file contains a database statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: util.dumpSchemas()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This utility is similar to `dumpInstance()`, but it allows us to specify schemas
    to dump. It supports the same options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to specify multiple schemas, we can do that by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: util.dumpTables()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to extract more granular data, like specific tables, we can use
    the `dumpTables()` utility. Again, the big advantage compared to `mysqldump` is
    the potential to extract data from MySQL in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: util.loadDump(url[, options])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve seen all the utilities to extract data, but there is one remaining: the
    one to load data into MySQL.'
  prefs: []
  type: TYPE_NORMAL
- en: The `loadDump()` enables provides data streaming to remote storage, parallel
    loading of tables or table chunks, and progress state tracking. It also provides
    resume and reset capabilities and the option of concurrent loading while the dump
    is still taking place.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this utility uses the `LOAD DATA LOCAL INFILE` statement, so we need
    to enable the [`local_infile`](https://oreil.ly/vm445) parameter globally while
    importing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadDump()` utility checks whether the [`sql_require_primary_key` system
    variable](https://oreil.ly/2Si8y) is set to `ON`, and if it is, returns an error
    if there is a table in the dump files with no primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the output will be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to check the warnings reported at the end in case any show up.**  **#
    Flame Graphs
  prefs: []
  type: TYPE_NORMAL
- en: Quoting [Brendan Gregg](https://oreil.ly/STGxb), determining why CPUs are busy
    is a routine task for performance analysis, which often involves profiling *stack
    traces*. Profiling by sampling at a fixed rate is a coarse but effective way to
    see which code paths are *hot* (busy on the CPU). It usually works by creating
    a timed interrupt that collects the current program counter, function address,
    or entire stack trace, and translates these to something human-readable when printing
    a summary report. *Flame graphs* are a type of visualization for sampled stack
    traces that allow hot code paths to be identified quickly.
  prefs: []
  type: TYPE_NORMAL
- en: A *stack trace* (also called *stack backtrace* or *stack traceback*) is a report
    of the active stack frames at a certain point in time during the execution of
    a program. There are many tools available to collect stack traces. These tools
    are also known as *CPU profilers*. The CPU profiler we are going to use is [`perf`](https://oreil.ly/T7qZl).
  prefs: []
  type: TYPE_NORMAL
- en: '`perf` is a profiler tool for Linux 2.6+–based systems that abstracts away
    CPU hardware differences in Linux performance measurements and presents a simple
    command-line interface. `perf` is based on the `perf_events` interface exported
    by recent versions of the Linux kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: '`perf_events` is an event-oriented observability tool that can help solve advanced
    performance and troubleshooting tasks. Questions that can be answered include:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is the kernel on-CPU so much? What code paths are hot?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which code paths are causing CPU level 2 cache misses?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the CPUs stalled on memory I/O?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which code paths are allocating memory, and how much?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is triggering TCP retransmits?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is a certain kernel function being called, and how often?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are threads leaving the CPU?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that in this book, we are only scratching the surface of `perf`’s capabilities.
    We highly recommend checking out [Brendan Gregg’s website](https://oreil.ly/STGxb),
    which contains much more detailed information about `perf` and other CPU profilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce flame graphs, we need to start collecting the stack trace report
    with `perf` in the MySQL server. This operation needs to be done on the MySQL
    host. We will collect data for 60 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we check the */tmp* directory, we will see `perf` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The next step doesn’t need to be executed on the MySQL host; we can copy the
    files to another Linux host or even macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce the flame graphs we can use [Brendan’s GitHub repository](https://oreil.ly/llqVS).
    For this example, we will clone the Flame Graph repository in the directory where
    our `perf` report is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We’ve produced a file named *perf.report.out.svg*. This file can be opened in
    any browser to be visualized. [Figure 16-1](#FIG-MYSQL-FLAME) is an example of
    a flame graph.
  prefs: []
  type: TYPE_NORMAL
- en: Flame graphs show the sample population across the x-axis, and stack depth on
    the y-axis. Each function (stack frame) is drawn as a rectangle, with the width
    relative to the number of samples; so the bigger the bar, the more CPU time was
    spent on that function. The x-axis spans the stack trace collection but does not
    show the passage of time, so the left-to-right ordering has no special meaning.
    The ordering is done alphabetically based on the function names, from the root
    to the leaf of each stack.
  prefs: []
  type: TYPE_NORMAL
- en: The file that’s created is interactive, so we can explore where kernel CPU time
    is spent. In the previous example an `INSERT` operation is consuming 44% of the
    CPU time, as you can see in [Figure 16-2](#FIG-MYSQL-INSERT-FLAME).
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1601](Images/lm2e_1601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. An example of a flame graph
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![lm2e 1602](Images/lm2e_1602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-2\. 44% of CPU time is used for an `INSERT` operation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Building MySQL from Source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As [Chapter 1](ch01.xhtml#CH1_INSTALL) explained, MySQL has a distribution available
    for most common operating systems. Some companies have also compiled their own
    MySQL versions, such as Facebook, which worked on the RocksDB engine and integrated
    it into MySQL. RocksDB is an embeddable, persistent key/value store for fast storage
    that has several advantages compared with InnoDB with regard to space efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its advantages, RocksDB does not support replication or a SQL layer.
    This led the Facebook team to build MyRocks, an open source project that integrates
    RocksDB as a MySQL storage engine. With MyRocks, it is possible to use RocksDB
    as backend storage and still benefit from all the features of MySQL. Facebook’s
    project is open source and available on [GitHub](https://oreil.ly/ssWon).
  prefs: []
  type: TYPE_NORMAL
- en: Another motivation to compile MySQL is the ability to customize its build. For
    example, for a very specific problem, we can always try to debug MySQL to gather
    extra information. To do this, we need to configure MySQL with the `-DWITH_DEBUG=1`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Building MySQL for Ubuntu Focal Fossa and ARM Processors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because ARM processors are currently gaining traction (particularly thanks to
    Apple’s M1 chip), we will show you how to compile MySQL for Ubuntu Focal Fossa
    running on ARM.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create our directories. We will create one directory
    that will be for the source code, another one for the compiled binaries, and a
    third for the `boost` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to install the additional Linux packages required to compile
    MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: These packages are related to the [CMake flags](https://oreil.ly/GOnBJ) that
    we will run. If we remove or add certain flags, some packages are not necessary
    to install (for example, if we don’t want to compile with Valgrind, we don’t need
    this package).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will download the source code. For this, we will use [MySQL repository](https://oreil.ly/6Jb4c)
    on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To check which version we will compile, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will go to our *build* directory and run `CMake` with our chosen flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what each of these does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DBUILD_CONFIG` configures a source distribution with the same build options
    as for MySQL releases (we are going to override some of them).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DCMake_BUILD_TYPE` with `RelWithDebInfo` enables optimizations and generates
    debugging information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DWITH_DEBUG` enables the use of the `--debug="d,parser_debug"` option when
    MySQL is started. This causes the Bison parser used to process SQL statements
    to dump a parser trace to the server’s standard error output. Typically, this
    output is written to the error log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DFEATURE_SET` indicates we are going to install community features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DENABLE_DTRACE` includes support for DTrace probes. The DTrace probes in the
    MySQL server are designed to provide information about the execution of queries
    within MySQL and the different areas of the system being utilized during that
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DWITH_SSL` option adds support for encrypted connections, entropy for random
    number generation, and other encryption-related operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DWITH_ZLIB` enables compression library support for the `COMPRESS()` and `UNCOMPRESS()`
    functions, and compression of the client/server protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DCMake_INSTALL_PREFIX` sets the location of our installation base directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DINSTALL_LIBDIR` indicates where to install the library files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DINSTALL_SBINDIR` specifies where to install `mysqld`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DWITH_INNODB_MEMCACHED` generates memcached shared libraries (*libmemcached.so*
    and *innodb_engine.so*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DDOWNLOAD_BOOST` makes CMake download the `boost` library and place it in
    the location specified with `DWITH_BOOST`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DWITH_VALGRIND` enables Valgrind, exposing the Valgrind API to MySQL code.
    This is useful for analyzing memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DINSTALL_PLUGINDIR` defines where the compiler will place the plugin libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DMYSQL_DATADIR` defines the location of the MySQL data directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DWITH_BOOST` defines the directory where CMake will download the `boost` library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If by mistake you miss a step and the CMake process fails, to prevent old object
    files or configuration information from being used in the next attempt you’ll
    need to clean up the build directory and the previous configuration. That is,
    you’ll need to run the following commands in the build directory on Unix before
    rerunning CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run CMake, we are going to compile MySQL using the `make` command.
    To optimize the compiling process we will use the `-j` option, which specifies
    how many threads we are going to use to compile MySQL. Since in our instance we
    have 16 ARM cores, we are going to use 15 threads (leaving one for OS activities):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This process may take a while, and it is very verbose. After it’s finished,
    we can see the binaries in the *basedir* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are not going to find a *mysqld* binary in the */compile/build/bin/*
    directory, but instead we will see *mysqld-debug*. This is because of the `DWITH_DEBUG`
    option we set previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test our binary. For this we are going to manually create the directories
    and configure the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add these settings to */etc/my.cnf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to initialize the MySQL data dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, MySQL is ready to be started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A temporary password will be created, and we can extract it from the error
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can connect using the MySQL client of our preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing a MySQL Crash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We say that MySQL *crashes* when the `mysqld` process dies without the proper
    shutdown command. MySQL can crash for a variety of reasons, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware failure (memory, disk, processor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segmentation faults (invalid memory access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being killed by the `OOM` process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various other causes, such as [cosmic rays](https://oreil.ly/Lq09r).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The MySQL process can receive a number of signals from Linux. The following
    are among the most common:'
  prefs: []
  type: TYPE_NORMAL
- en: Signal 15 (`SIGTERM`)
  prefs: []
  type: TYPE_NORMAL
- en: 'Causes the server to shut down. This is like executing a `SHUTDOWN` statement
    without having to connect to the server (which for shutdown requires an account
    that has the `SHUTDOWN` privilege). For example, the following two commands result
    in a regular shutdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Signal 1 (`SIGHUP`)
  prefs: []
  type: TYPE_NORMAL
- en: 'Causes the server to reload the grant tables and to flush tables, logs, the
    thread cache, and the host cache. These actions are like various forms of the
    `FLUSH` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Signal 6 (`SIGABRT`)
  prefs: []
  type: TYPE_NORMAL
- en: 'Happens because something went wrong. It is commonly used by `libc` and other
    libraries to abort the program in case of critical errors. For example, `glibc`
    sends a `SIGABRT` if it detects a double free or other heap corruption. `SIGABRT`
    will write the crash details in the MySQL error log, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Signal 11 (`SIGSEGV`)
  prefs: []
  type: TYPE_NORMAL
- en: Indicates a segmentation fault, bus error, or access violation issue. This is
    generally an attempt to access memory that the CPU cannot physically address,
    or an access violation. When MySQL receives a `SIGSEGV`, a core dump will be created
    if the `core-file` parameter is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Signal 9 (`SIGKILL`)
  prefs: []
  type: TYPE_NORMAL
- en: 'Causes a process to terminate immediately (kills it). This is probably the
    most famous signal. In contrast to `SIGTERM` and `SIGINT`, this signal cannot
    be caught or ignored, and the receiving process cannot perform any cleanup upon
    receiving this signal. Besides the chance of corrupting MySQL data, `SIGKILL`
    will also force MySQL to perform a recovery process when restarted to bring it
    to an operational state. The following example shows how to send a `SIGKILL` manually
    to the MySQL process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Also, the Linux `OOM` process executes a `SIGKILL` to terminate with the MySQL
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to analyze a crash where MySQL got a signal 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sometimes stack may not contain fully resolved symbols or may only have addresses.
    That depends on whether the mysqld binary is stripped and whether the debug symbols
    are available. As a rule of thumb, we recommend installing debug symbols, as that
    has no disadvantage other than using up some disk space. Having debug symbols
    installed doesn’t make your MySQL server run in some slow debug mode. Official
    MySQL 8.0 builds are always symbolized, however, so you don’t need to worry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack trace is analyzed from top to bottom. We can see from the crash that
    this is a Percona Server v8.0.22\. Next, we see the thread being created at the
    OS level at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing up through the stack, the code path enters MySQL and starts executing
    a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And the code path that crashes is the `Item_splocal` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'With a bit of investigation in the [MySQL code](https://oreil.ly/OjTUs), we
    discover that `Item_splocal` is part of the stored procedure code. If we look
    at the end of the stack trace, we will see a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '*Triggers* can also use the stored procedure path when they contain variables.
    If we check whether this table has triggers, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'With all this information, we can create a test case and report the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To reproduce it, we run multiple commands simultaneously in the same table
    until the error happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This bug is relatively easy to reproduce, and we recommend you test it. You
    can find more details about this bug in Percona’s [Jira system](https://oreil.ly/cAWbG).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can see that Oracle fixed the bug at version 8.0.23 thanks to the
    [release notes](https://oreil.ly/izg4K):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared statements involving stored programs could cause heap-use-after-free
    memory problems (Bug #32131022, Bug #32045681, Bug #32051928).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sometimes bugs are not easy to reproduce and can be really frustrating to investigate.
    Even experienced engineers have problems with this, especially when investigating
    memory leaks. We hope we have sparked your curiosity to investigate crashes.**
  prefs: []
  type: TYPE_NORMAL
