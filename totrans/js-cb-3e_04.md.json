["```\nrandomNumber = Math.floor(Math.random() * (max - min + 1) ) + min;\n```", "```\nconst randomNumber = Math.floor(Math.random()*6) + 1;\n```", "```\nconst randomNumber = Math.floor(0.374324823*6) + 1;\n```", "```\nconst randomNumber = Math.floor(2.245948938) + 1;\n```", "```\nconst randomNumber = 2 + 1;\n```", "```\nconst randomBuffer = new Uint32Array(1);\nwindow.crypto.getRandomValues(randomBuffer);\nconst randomFraction = randomBuffer[0] / (0xffffffff + 1);\n```", "```\n// Use the random fraction to make a random integer from 1-6\nconst randomNumber = Math.floor(randomFraction*6) + 1;\nconsole.log(randomNumber);\n```", "```\nconst crypto = require('crypto').webcrypto;\n```", "```\nconst randomBuffer = new Uint32Array(1);\nwindow.crypto.getRandomValues(randomBuffer);\n```", "```\nconst randomFraction = randomBuffer[0] / (0xffffffff + 1);\n```", "```\nconst fractionalNumber = 19.48938;\nconst roundedNumber = Math.round(fractionalNumber);\n\n// Now roundedNumber is 19\n```", "```\nconst numberToRound = fractionalNumber * (10**numberOfDecimalPlaces);\nlet roundedNumber = Math.round(numberToRound);\nroundedNumber = roundedNumber / (10**numberOfDecimalPlaces);\n```", "```\nconst fractionalNumber = 19.48938;\nconst numberToRound = fractionalNumber * (10**2);\nlet roundedNumber = Math.round(numberToRound);\nroundedNumber = roundedNumber / (10**2);\n\n// Now roundedNumber is 19.49\n```", "```\nconst sum = 0.1 + 0.2;\nconsole.log(sum);      // displays 0.30000000000000004\n```", "```\nconst currentBalance = 5382.23;\nconst transactionAmount = 14.02;\n\nconst updatedBalance = currentBalance - transactionAmount;\n\n// Now updatedBalance = 5368.209999999999\n```", "```\nconst currentBalanceInCents = 538223;\nconst transactionAmountInCents = 1402;\n\nconst updatedBalanceInCents = currentBalanceInCents - transactionAmountInCents;\n\n// Now updatedBalanceInCents = 536821\n```", "```\nconst costInCents = 4899;\n\n// Calculate 11% tax, and round the result to the nearest cent\nconst costWithTax = Math.round(costInCents*1.11);\n```", "```\nconst stringData = '42';\nconst numberData = Number(stringData);\n```", "```\nif (stringData.trim() === '') {\n  // This is an all-whitespace or empty string\n}\n```", "```\nconst numberData = Number(stringData);\n\nif (Number.isNaN(numberData)) {\n  // It's safe to process this data as a number\n}\n```", "```\nconsole.log(Number('42'));               // 42\nconsole.log(parseFloat('42'));           // 42\n\nconsole.log(Number('12 goats'));         // NaN\nconsole.log(parseFloat('12 goats'));     // 12\n\nconsole.log(Number('goats 12'));         // NaN\nconsole.log(parseFloat('goats 12'));     // NaN\n\nconsole.log(Number('2001/01/01'));       // NaN\nconsole.log(parseFloat('2001/01/01'));   // 2001\n\nconsole.log(Number(' '));                // 0\nconsole.log(parseFloat(' '));            // NaN\n```", "```\nconst num = 255;\n\n// displays ff, which is hexadecimal equivalent for 255\nconsole.log(num.toString(16));\n```", "```\nconst octalNumber = 0o255;  // equivalent to 173 decimal\nconst hexaNumber = 0xad;    // equivalent to 173 decimal\n```", "```\nconst decNum = 55;\nconst octNum = decNum.toString(8);   // value of 67 octal\nconst hexNum = decNum.toString(16);  // value of 37 hexadecimal\nconst binNum = decNum.toString(2);   // value of 110111 binary\n```", "```\nconst radians = degrees * (Math.PI / 180);\n```", "```\nconst radians = 90 * (Math.PI / 180);\nconsole.log(radians);   // 1.5707963267948966\n```", "```\nconst degrees = radians * (180 / Math.PI);\n```", "```\n// angle of arc is 120 degrees, radius of circle is 2\nconst radians = degrees * (Math.PI / 180);\nconst arclength = radians * radius; // value is 4.18879020478...\n```", "```\n// Create a BigInt and set it to 10\nconst bigInteger = BigInt(10);\n```", "```\nconst bigInteger = 10n;\n```", "```\n// Ordinarily, large integers suffer from imprecision\nconst maxInt = Number.MAX_SAFE_INTEGER // Probably about 9007199254740991\nconsole.log(maxInt + 1);  // 9007199254740992 (reasonable)\nconsole.log(maxInt + 2);  // 9007199254740992 (not a typo, this seems wrong)\nconsole.log(maxInt + 3);  // 9007199254740994 (sure)\nconsole.log(maxInt + 4);  // 9007199254740996 (wait, what now?)\n\n// BigInts behave more reliably\nconst bigInt = BigInt(maxInt);\nconsole.log(bigInt + 1n);  // 9007199254740992 (as before)\nconsole.log(bigInt + 2n);  // 9007199254740993 (this is better)\nconsole.log(bigInt + 3n);  // 9007199254740994 (still good)\nconsole.log(bigInt + 4n);  // 9007199254740995 (excellent!)\n```", "```\nconst result = 10n / 6n;    // result is 1.\n```", "```\nlet bigInteger = 10n;\nlet integer = Number(bigInteger);  // Number is 10\n\ninteger = 20;\nbigInteger = BigInt(integer);      // bigInteger is 20n\n```", "```\nconst decimal = 10.8;\nconst bigInteger = BigInt(Math.round(decimal));    // bigInteger is 11n\n```", "```\nlet x = 10n;\nx = x * 2;    // throws a TypeError because x is a BigInt and 2 is a Number\nx += 1;       // also throws a TypeError\n\nx = x * 2n;   // x is now 20n, as expected\nx += 1n;      // x is 21\n```", "```\nBigInt.prototype.toJSON = function() { return this.toString() }\n```"]