<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Declaration Files"><div class="chapter" id="declaration_files">
<h1><span class="label">Chapter 11. </span>Declaration Files</h1>

<blockquote>
<p>Declaration files</p>

<p>Have purely type system code</p>

<p>No runtime constructs</p></blockquote>

<p>Even <a data-type="indexterm" data-primary="types" data-secondary="declaration files" data-see="declaration files" id="idm45584674515296"/>though writing code in TypeScript is great and that’s all you want to do, you’ll need to be able to work with raw JavaScript files in your TypeScript projects.
Many packages are written directly in JavaScript, not TypeScript.
Even packages that are written in TypeScript are distributed as JavaScript files.</p>

<p>Moreover, TypeScript projects need a way to be told the type shapes of environment-specific features such as global variables and APIs.
A project running in, say, Node.js might have access to built-in Node modules not available in browsers—and vice versa.</p>

<p>TypeScript allows declaring type shapes separately from their implementation.
Type declarations are typically written in files whose names end with the <em>.d.ts</em> extension, <a data-type="indexterm" data-primary="declaration files" data-secondary="purpose of" id="declare-file-purpose"/>known as <em>declaration files</em>.
Declaration files are generally either written within a project, built and distributed with a project’s compiled npm package, or shared as a standalone “typings” package.</p>






<section data-type="sect1" data-pdf-bookmark="Declaration Files"><div class="sect1" id="idm45584674510528">
<h1>Declaration Files</h1>

<p>A <em>.d.ts</em> declaration file generally works similarly to a <em>.ts</em> file, except with the notable constraint of not being allowed to include runtime code.
<em>.d.ts</em> files contain only descriptions of available runtime values, interfaces, modules, and general types.
They cannot contain any runtime code that could be compiled down to JavaScript.</p>

<p>Declaration files can be imported just like any other source TypeScript file.</p>

<p class="less_space pagebreak-before">This <em>types.d.ts</em> file exports a <code>Character</code> interface used by an <em>index.ts</em> file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// types.d.ts</code>
<code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Character</code> <code class="p">{</code>
    <code class="nx">catchphrase?</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">Character</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./types"</code><code class="p">;</code>

<code class="kr">export</code> <code class="kr">const</code> <code class="nx">character</code>: <code class="nx">Character</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">catchphrase</code><code class="o">:</code> <code class="s2">"Yee-haw!"</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Sandy Cheeks"</code><code class="p">,</code>
<code class="p">};</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Declaration files create what’s known as <a data-type="indexterm" data-primary="ambient contexts" id="idm45584674418016"/>an <em>ambient context</em>, meaning an area of code where you can only declare types, not <a data-type="indexterm" data-primary="declaration files" data-secondary="purpose of" data-startref="declare-file-purpose" id="idm45584674416832"/>values.</p>
</div>

<p>This chapter is largely dedicated to declaration files and the most common forms of type declarations used within them.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Declaring Runtime Values"><div class="sect1" id="idm45584674456544">
<h1>Declaring Runtime Values</h1>

<p>Although<a data-type="indexterm" data-primary="declaration files" data-secondary="for runtime values" data-tertiary="declare keyword" data-secondary-sortas="runtime values" id="declare-file-runtime-keyword"/><a data-type="indexterm" data-primary="runtime values, declaring" data-secondary="with declare keyword" data-secondary-sortas="declare keyword" id="runtime-value-declare-keyword"/><a data-type="indexterm" data-primary="declaring" data-secondary="runtime values" data-tertiary="with declare keyword" data-tertiary-sortas="declare keyword" id="declare-runtime-keyword"/><a data-type="indexterm" data-primary="declare keyword" id="declare-keyword"/> definition files may not create runtime values such as functions or variables, they are able to declare that those constructs exist with the <code>declare</code> keyword.
Doing so tells the type system that some external influence—such as a <code>&lt;script&gt;</code> tag in a web page—has created the value under that name with a particular type.</p>

<p>Declaring a variable with <code>declare</code> uses the same syntax as a normal variable declaration, except an initial value is not allowed.</p>

<p>This snippet successfully declares a <code>declared</code> variable but receives a type error for trying to give a value to an <code>initializer</code> variable:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// types.d.ts</code>
<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">declared</code>: <code class="nx">string</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">initializer</code>: <code class="nx">string</code> <code class="o">=</code> <code class="s2">"Wanda"</code><code class="p">;</code>
<code class="c1">//                                ~~~~~~~</code>
<code class="c1">// Error: Initializers are not allowed in ambient contexts.</code></pre>

<p>Functions and classes are also declared similarly to their normal forms, but without the bodies of functions or methods.</p>

<p>The following <code>canGrantWish</code> function and method are properly declared without a body, but the <code>grantWish</code> function and method are syntax errors for improperly attempting to set up a body:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// fairies.d.ts</code>
<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">canGrantWish</code><code class="p">(</code><code class="nx">wish</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">grantWish</code><code class="p">(</code><code class="nx">wish</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">true</code><code class="p">;</code> <code class="p">}</code>
<code class="c1">//                                       ~</code>
<code class="c1">// Error: An implementation cannot be declared in ambient contexts.</code>

<code class="kr">class</code> <code class="nx">Fairy</code> <code class="p">{</code>
    <code class="nx">canGrantWish</code><code class="p">(</code><code class="nx">wish</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code> <code class="c1">// Ok</code>

    <code class="nx">grantWish</code><code class="p">(</code><code class="nx">wish</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">//                  ~</code>
        <code class="c1">// Error: An implementation cannot be declared in ambient contexts.</code>
        <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>TypeScript’s implicit <code>any</code> rules work the same for functions and variables declared in<a data-type="indexterm" data-primary="ambient contexts" id="idm45584677617056"/><a data-type="indexterm" data-primary="explicit type annotations" id="idm45584674312176"/><a data-type="indexterm" data-primary="type annotations" data-secondary="explicit" id="idm45584674311536"/><a data-type="indexterm" data-primary="any type" data-secondary="ambient contexts" id="idm45584674310592"/> ambient contexts as they do in normal source code.
Because ambient contexts may not provide function bodies or initial variable values, explicit type annotations—including explicit return type annotations—are generally the only way to stop them from implicitly being type <code>any</code>.</p>
</div>

<p>Although type declarations using the <code>declare</code> keyword are most common in <em>.d.ts</em> definition files, the <code>declare</code> keyword can be used outside of declaration files as well.
A module or script file can use <code>declare</code> as well.
This can be useful when a globally available variable is only meant to be used in that file.</p>

<p>Here, a <code>myGlobalValue</code> variable is defined in an <em>index.ts</em> file, so it’s allowed to be used in that file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">myGlobalValue</code>: <code class="nx">string</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">myGlobalValue</code><code class="p">);</code> <code class="c1">// Ok</code></pre>

<p>Note that while type shapes such as interfaces are allowed with or without a <code>declare</code> in <em>.d.ts</em> definition files, runtime constructs such as functions or variables will trigger a type complaint without<a data-type="indexterm" data-primary="declaration files" data-secondary="for runtime values" data-tertiary="declare keyword" data-secondary-sortas="runtime values" data-startref="declare-file-runtime-keyword" id="idm45584674256816"/><a data-type="indexterm" data-primary="runtime values, declaring" data-secondary="with declare keyword" data-secondary-sortas="declare keyword" data-startref="runtime-value-declare-keyword" id="idm45584674243392"/><a data-type="indexterm" data-primary="declaring" data-secondary="runtime values" data-tertiary="with declare keyword" data-tertiary-sortas="declare keyword" data-startref="declare-runtime-keyword" id="idm45584674241968"/><a data-type="indexterm" data-primary="declare keyword" data-startref="declare-keyword" id="idm45584674240208"/> a <code>declare</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.d.ts</code>
<code class="kr">interface</code> <code class="nx">Writer</code> <code class="p">{}</code> <code class="c1">// Ok</code>
<code class="kr">declare</code> <code class="kr">interface</code> <code class="nx">Writer</code> <code class="p">{}</code> <code class="c1">// Ok</code>

<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">fullName</code>: <code class="nx">string</code><code class="p">;</code> <code class="c1">// Ok: type is the primitive string</code>
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">firstName</code><code class="o">:</code> <code class="s2">"Liz"</code><code class="p">;</code> <code class="c1">// Ok: type is the literal "value"</code>

<code class="kr">const</code> <code class="nx">lastName</code> <code class="o">=</code> <code class="s2">"Lemon"</code><code class="p">;</code>
<code class="c1">// Error: Top-level declarations in .d.ts files must</code>
<code class="c1">// start with either a 'declare' or 'export' modifier.</code></pre>








<section data-type="sect2" data-pdf-bookmark="Global Values"><div class="sect2" id="idm45584674192416">
<h2>Global Values</h2>

<p>Because <a data-type="indexterm" data-primary="declaration files" data-secondary="for runtime values" data-tertiary="global values" data-secondary-sortas="runtime values" id="declare-file-runtime-global"/><a data-type="indexterm" data-primary="runtime values, declaring" data-secondary="as global values" data-secondary-sortas="global values" id="runtime-value-global"/><a data-type="indexterm" data-primary="declaring" data-secondary="runtime values" data-tertiary="as global values" data-tertiary-sortas="global values" id="declare-runtime-global"/><a data-type="indexterm" data-primary="global values, declaring runtime values as" id="global-value-declare"/>TypeScript files that have no <code>import</code> or <code>export</code> statements are treated as <em>scripts</em> rather than <em>modules</em>, constructs—including types—declared in them are available globally.
Definition files without any imports or exports can take advantage of that behavior to declare types globally.
Global definition files are particularly useful for declaring global types or variables available across all files in an application.</p>

<p>Here, a <em>globals.d.ts</em> file declares that a <code>const version: string</code> exists globally.
A <em>version.ts</em> file is then able to refer to a global <code>version</code> variable despite not importing from <em>globals.d.ts</em>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// globals.d.ts</code>
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">version</code>: <code class="nx">string</code><code class="p">;</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// version.ts</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">logVersion() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Version: </code><code class="si">${</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="p">}</code></pre>

<p>Globally declared values are most often used in browser applications that use global variables.
Although most modern web frameworks generally use newer techniques such as ECMAScript modules, it can still be useful—especially in smaller projects—to be able to store variables globally.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you find that you can’t automatically access global types declared in a <em>.d.ts</em> file, double-check that the <em>.d.ts</em> file isn’t importing and exporting anything.
Even a single export will cause the whole file to no longer be available globally!</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Global Interface Merging"><div class="sect2" id="idm45584674132112">
<h2>Global Interface Merging</h2>

<p>Variables<a data-type="indexterm" data-primary="declaration files" data-secondary="for runtime values" data-tertiary="interface merging" data-secondary-sortas="runtime values" id="idm45584674130352"/><a data-type="indexterm" data-primary="runtime values, declaring" data-secondary="for interface merging" data-secondary-sortas="interface merging" id="idm45584674096496"/><a data-type="indexterm" data-primary="declaring" data-secondary="runtime values" data-tertiary="for interface merging" data-tertiary-sortas="interface merging" id="idm45584674095312"/><a data-type="indexterm" data-primary="interfaces" data-secondary="merging" id="idm45584674093824"/><a data-type="indexterm" data-primary="merging interfaces" id="idm45584674092880"/><a data-type="indexterm" data-primary="global interface merging" id="idm45584674092208"/> aren’t the only globals floating around in a TypeScript project’s type system.
Many type declarations exist globally for global APIs and values.
Because interfaces merge with other interfaces of the same name, declaring an interface in a global script context—such as a <em>.d.ts</em> declaration file without any <code>import</code> or <code>export</code> statements—augments that interface globally.</p>

<p class="less_space pagebreak-before">For example, a web application that relies on a global variable set by the server might want to declare that as existing on the global <code>Window</code> interface.
Interface merging would allow a file such as <em>types/window.d.ts</em> to declare a variable that exists on the global <code>window</code> variable of type <code>Window</code>:</p>

<pre data-type="programlisting" data-code-language="html"><code class="p">&lt;</code><code class="nt">script</code> <code class="na">type</code><code class="o">=</code><code class="s">"text/javascript"</code><code class="p">&gt;</code><code class="w"/>
<code class="nb">window</code><code class="p">.</code><code class="nx">myVersion</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"3.1.1"</code><code class="p">;</code><code class="w"/>
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// types/window.d.ts</code>
<code class="kr">interface</code> <code class="nx">Window</code> <code class="p">{</code>
    <code class="nx">myVersion</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">logWindowVersion() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Window version is: </code><code class="si">${</code><code class="nb">window</code><code class="p">.</code><code class="nx">myVersion</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="nb">window</code><code class="p">.</code><code class="nx">alert</code><code class="p">(</code><code class="s2">"Built-in window types still work! Hooray!"</code><code class="p">)</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Global Augmentations"><div class="sect2" id="idm45584673963776">
<h2>Global Augmentations</h2>

<p>It’s <a data-type="indexterm" data-primary="declaration files" data-secondary="for runtime values" data-tertiary="global augmentations" data-secondary-sortas="runtime values" id="idm45584673956256"/><a data-type="indexterm" data-primary="runtime values, declaring" data-secondary="for global augmentations" data-secondary-sortas="global augmentations" id="idm45584673954704"/><a data-type="indexterm" data-primary="declaring" data-secondary="runtime values" data-tertiary="for global augmentations" data-tertiary-sortas="global augmentations" id="idm45584673953552"/><a data-type="indexterm" data-primary="global augmentations" id="idm45584673952096"/><a data-type="indexterm" data-primary="variables" data-secondary="global augmentations" id="idm45584673928048"/>not always feasible to refrain from <code>import</code> or <code>export</code> statements in a <em>.d.ts</em> file that needs to also augment the global scope, such as when your global definitions are simplified greatly by importing a type defined elsewhere.
Sometimes types declared in a module file are meant to be consumed globally.</p>

<p>For those cases, TypeScript allows a syntax to <code>declare global</code> a block of code.
Doing so marks the contents of that block as being in a global context even though their surroundings are not:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// types.d.ts</code>
<code class="c1">// (module context)</code>

<code class="kr">declare</code> <code class="nx">global</code> <code class="p">{</code>
    <code class="c1">// (global context)</code>
<code class="p">}</code>

<code class="c1">// (module context)</code></pre>

<p>Here, a <code>types/data.d.ts</code> file exports a <code>Data</code> interface, which will later be imported by both <code>types/globals.d.ts</code> and the runtime <em>index.ts</em>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// types/data.d.ts</code>
<code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Data</code> <code class="p">{</code>
    <code class="nx">version</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Additionally, <code>types/globals.d.ts</code> declares a variable of type <code>Data</code> globally inside a <code>declare global</code> block as well as a variable available only in that file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// types/globals.d.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">Data</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./data"</code><code class="p">;</code>

<code class="kr">declare</code> <code class="nx">global</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">globallyDeclared</code>: <code class="nx">Data</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">locallyDeclared</code>: <code class="nx">Data</code><code class="p">;</code></pre>

<p><em>index.ts</em> then has access to the <code>globallyDeclared</code> variable without an import, and still needs to import <code>Data</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">Data</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./types/data"</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">logData</code><code class="p">(</code><code class="nx">data</code>: <code class="nx">Data</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Ok</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Data version is: </code><code class="si">${</code><code class="nx">data</code><code class="p">.</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">logData</code><code class="p">(</code><code class="nx">globallyDeclared</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">logData</code><code class="p">(</code><code class="nx">locallyDeclared</code><code class="p">);</code>
<code class="c1">//      ~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Cannot find name 'locallyDeclared'.</code></pre>

<p>Wrangling global and module declarations to play well together can be tricky.
Proper usage of TypeScript’s <code>declare</code> and <code>global</code> keywords can describe which type definitions are meant to be available globally in projects.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Built-In Declarations"><div class="sect1" id="idm45584674456048">
<h1>Built-In Declarations</h1>

<p>Now<a data-type="indexterm" data-primary="declaration files" data-secondary="built-in declarations" data-tertiary="purpose of" id="idm45584673785744"/><a data-type="indexterm" data-primary="built-in declarations" data-secondary="purpose of" id="idm45584673784464"/> that you’ve seen how declarations work, it’s time to unveil their hidden use in TypeScript: they’ve been powering its type checking the whole time!
Global objects such as <code>Array</code>, <code>Function</code>, <code>Map</code>, and <code>Set</code> are examples of constructs that the type system needs to know about but aren’t declared in your code.
They’re provided by whatever runtime(s) your code is meant to run in: Deno, Node, a web browser, etc.</p>








<section data-type="sect2" data-pdf-bookmark="Library Declarations"><div class="sect2" id="idm45584673781472">
<h2>Library Declarations</h2>

<p>Built-in <a data-type="indexterm" data-primary="declaration files" data-secondary="built-in declarations" data-tertiary="library files" id="declare-file-built-in-library"/><a data-type="indexterm" data-primary="built-in declarations" data-secondary="library files" id="built-in-declare-library"/><a data-type="indexterm" data-primary="library declaration files" id="library-declare"/>global objects such as <code>Array</code> and <code>Function</code> that exist in all JavaScript runtimes are declared in files with names like <em>lib.[target].d.ts</em>.
<em>target</em> is the minimum support version of JavaScript targeted by your project, such as ES5, ES2020, or ESNext.</p>

<p>The built-in library definition files, or “lib files,” are fairly large because they represent the entirety of JavaScript’s built-in APIs.
For example, members on the built-in <code>Array</code> type are represented by a global <code>Array</code> interface that starts like this:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// lib.es5.d.ts</code>

<code class="kr">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="cm">/**</code>
<code class="cm">     * Gets or sets the length of the array.</code>
<code class="cm">     * This is a number one higher than the highest index in the array.</code>
<code class="cm">     */</code>
    <code class="nx">length</code>: <code class="nx">number</code><code class="p">;</code>

    <code class="c1">// ...</code>
<code class="p">}</code></pre>

<p>Lib files are distributed as part of the TypeScript npm package.
You can find them inside the package at paths like <em>node_modules/typescript/lib/lib.es5.d.ts</em>.
For IDEs such as VS Code that use their own packaged TypeScript versions to type check code, you can find the lib file being used by right-clicking on a built-in method such as an array’s <code>forEach</code> in your code and selecting an option like Go to Definition (<a data-type="xref" href="#lib_go_to_definition">Figure 11-1</a>).</p>

<figure><div id="lib_go_to_definition" class="figure">
<img src="Images/lets_1101.png" alt="Left: going to definition on a forEach; right: the resultant opened lib.es5.d.ts file." width="600" height="312"/>
<h6><span class="label">Figure 11-1. </span>Left: going to definition on a <code>forEach</code>; right: the resultant opened lib.es5.d.ts file</h6>
</div></figure>










<section data-type="sect3" data-pdf-bookmark="Library targets"><div class="sect3" id="idm45584673697856">
<h3>Library targets</h3>

<p>TypeScript <a data-type="indexterm" data-primary="targets for library declaration files" id="target-library"/>by default will include the appropriate lib file based on the <code>target</code> setting provided to the <code>tsc</code> CLI and/or in your project’s <em>tsconfig.json</em> (by default, <code>"es5"</code>).
Successive lib files for newer versions of JavaScript build on each other using interface merging.</p>

<p>For example, static <code>Number</code> members such as <code>EPSILON</code> and <code>isFinite</code> added in ES2015 are listed in <em>lib.es2015.d.ts</em>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// lib.es2015.d.ts</code>

<code class="kr">interface</code> <code class="nx">NumberConstructor</code> <code class="p">{</code>
    <code class="cm">/**</code>
<code class="cm">     * The value of Number.EPSILON is the difference between 1 and the</code>
<code class="cm">     * smallest value greater than 1 that is representable as a Number</code>
<code class="cm">     * value, which is approximately:</code>
<code class="cm">     * 2.2204460492503130808472633361816 x 10‍−‍16.</code>
<code class="cm">     */</code>
    <code class="nx">readonly</code> <code class="nx">EPSILON</code>: <code class="nx">number</code><code class="p">;</code>

    <code class="cm">/**</code>
<code class="cm">     * Returns true if passed value is finite.</code>
<code class="cm">     * Unlike the global isFinite, Number.isFinite doesn't forcibly</code>
<code class="cm">     * convert the parameter to a number. Only finite values of the</code>
<code class="cm">     * type number result in true.</code>
<code class="cm">     * @param number A numeric value.</code>
<code class="cm">     */</code>
    <code class="nb">isFinite</code><code class="p">(</code><code class="kt">number</code><code class="o">:</code> <code class="nx">unknown</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>

    <code class="c1">// ...</code>
<code class="p">}</code></pre>

<p>TypeScript projects will include the lib files for all version targets of JavaScript up through their minimum target.
For example, a project with a target of <code>"es2016"</code> would include <em>lib.es5.d.ts</em>, <em>lib.es2015.d.ts</em>, and <em>lib.es2016.d.ts</em>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Language features available only in newer versions of JavaScript than your target will not be available in the type system.
For example, if your target is <code>"es5"</code>, language features from ES2015 or later such as <code>String.prototype.startsWith</code> will not be recognized.</p>
</div>

<p>Compiler options such as <code>target</code> are covered in more <a data-type="indexterm" data-primary="targets for library declaration files" data-startref="target-library" id="idm45584673642656"/><a data-type="indexterm" data-primary="declaration files" data-secondary="built-in declarations" data-tertiary="library files" data-startref="declare-file-built-in-library" id="idm45584673641680"/><a data-type="indexterm" data-primary="built-in declarations" data-secondary="library files" data-startref="built-in-declare-library" id="idm45584673640176"/><a data-type="indexterm" data-primary="library declaration files" data-startref="library-declare" id="idm45584673638944"/>detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="DOM Declarations"><div class="sect2" id="idm45584673665008">
<h2>DOM Declarations</h2>

<p>Outside<a data-type="indexterm" data-primary="declaration files" data-secondary="built-in declarations" data-tertiary="DOM types" id="declare-file-built-in-DOM"/><a data-type="indexterm" data-primary="built-in declarations" data-secondary="DOM types" id="built-in-declare-DOM"/><a data-type="indexterm" data-primary="DOM declarations" id="DOM-declare"/> of the JavaScript language itself, the most commonly referenced area of type declarations is for web browsers.
Web browser types, generally referred to as “DOM” types, cover APIs such as <code>localStorage</code> and type shapes such as <code>HTMLElement</code> available primarily in web browsers.
DOM types are stored in a <em>lib.dom.d.ts</em> file alongside the other <em>lib.*.d.ts</em> declaration files.</p>

<p>Global DOM types, like many built-in globals, are often described with global interfaces.
For example, the <code>Storage</code> interface used for <code>localStorage</code> and <code>sessionStorage</code> and starts roughly like this:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// lib.dom.d.ts</code>

<code class="kr">interface</code> <code class="nx">Storage</code> <code class="p">{</code>
    <code class="cm">/**</code>
<code class="cm">     * Returns the number of key/value pairs.</code>
<code class="cm">     */</code>
    <code class="nx">readonly</code> <code class="nx">length</code>: <code class="nx">number</code><code class="p">;</code>

    <code class="cm">/**</code>
<code class="cm">     * Removes all key/value pairs, if there are any.</code>
<code class="cm">     */</code>
    <code class="nx">clear</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>

    <code class="cm">/**</code>
<code class="cm">     * Returns the current value associated with the given key,</code>
<code class="cm">     * or null if the given key does not exist.</code>
<code class="cm">     */</code>
    <code class="nx">getItem</code><code class="p">(</code><code class="nx">key</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">null</code><code class="p">;</code>

    <code class="c1">// ...</code>
<code class="p">}</code></pre>

<p>TypeScript includes DOM types by default in projects that don’t override the <code>lib</code> compiler option.
That can sometimes be confusing for developers working on projects meant to be run in nonbrowser environments such as Node, as they shouldn’t be able to access the global APIs such as <code>document</code> and <code>localStorage</code> that the type system would then claim to exist.
Compiler options such as <code>lib</code> are covered in more detail <a data-type="indexterm" data-primary="declaration files" data-secondary="built-in declarations" data-tertiary="DOM types" data-startref="declare-file-built-in-DOM" id="idm45584673563440"/><a data-type="indexterm" data-primary="built-in declarations" data-secondary="DOM types" data-startref="built-in-declare-DOM" id="idm45584673561952"/><a data-type="indexterm" data-primary="DOM declarations" data-startref="DOM-declare" id="idm45584673560736"/>in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Module Declarations"><div class="sect1" id="idm45584673558304">
<h1>Module Declarations</h1>

<p>One <a data-type="indexterm" data-primary="declaration files" data-secondary="for modules" data-secondary-sortas="modules" id="declare-file-module"/><a data-type="indexterm" data-primary="modules" data-secondary="declaration files" id="module-declare"/>more important feature of declaration files is their ability to describe the shapes of modules.
The <code>declare</code> keyword can be used before a string name of a module to inform the type system of the contents of that module.</p>

<p>Here, the <code>"my-example-lib"</code> module is declared as being in existence in a 
<span class="keep-together"><code>modules.d.ts</code></span> declaration script file, then used in an <em>index.ts</em> file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// modules.d.ts</code>
<code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"my-example-lib"</code> <code class="p">{</code>
    <code class="kr">export</code> <code class="kr">const</code> <code class="nx">value</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">value</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"my-example-lib"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code> <code class="c1">// Ok</code></pre>

<p>You shouldn’t have to use <code>declare module</code> often, if ever, in your own code.
It’s mostly used with the following section’s wildcard module declarations and with package types covered later in this chapter.
Additionally, see <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> for information on <code>resolveJsonModule</code>, a compiler option that allows TypeScript to natively recognize imports from <em>.json</em> files.</p>








<section data-type="sect2" data-pdf-bookmark="Wildcard Module Declarations"><div class="sect2" id="idm45584673481664">
<h2>Wildcard Module Declarations</h2>

<p>A common use<a data-type="indexterm" data-primary="wildcard module declarations" id="wildcard-module"/> of module declarations is to tell web applications that a particular non-JavaScript/TypeScript file extension is available to <code>import</code> into code.
Module declarations may contain a single <code>*</code> wildcard to indicate that any module matching that pattern looks the same.</p>

<p>For example, many web projects such as those preconfigured in popular React starters such as create-react-app and create-next-app support CSS modules to import styles from CSS files as objects that can be used at runtime.
They would define modules with a pattern such as <code>"*.module.css"</code> that default exports an object of type <code>{ [i: string]: string }</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// styles.d.ts</code>
<code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"*.module.css"</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">styles</code><code class="o">:</code> <code class="p">{</code> <code class="p">[</code><code class="nx">i</code>: <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">};</code>
    <code class="kr">export</code> <code class="k">default</code> <code class="nx">styles</code><code class="p">;</code>
<code class="p">}</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// component.ts</code>
<code class="kr">import</code> <code class="nx">styles</code> <code class="nx">from</code> <code class="s2">"./styles.module.css"</code><code class="p">;</code>

<code class="nx">styles</code><code class="p">.</code><code class="nx">anyClassName</code><code class="p">;</code> <code class="c1">// Type: string</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Using wildcard modules to represent local files isn’t completely type safe.
TypeScript does not provide a mechanism to ensure the imported module path matches a local file.
Some projects use a build system such as Webpack and/or generate <em>.d.ts</em> files from local files to make sure imports <a data-type="indexterm" data-primary="declaration files" data-secondary="for modules" data-secondary-sortas="modules" data-startref="declare-file-module" id="idm45584673393296"/><a data-type="indexterm" data-primary="modules" data-secondary="declaration files" data-startref="module-declare" id="idm45584673391808"/>match up.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Package Types"><div class="sect1" id="idm45584673390208">
<h1>Package Types</h1>

<p>Now that you’ve seen how to declare typings within a project, it’s time to cover consuming types between packages.
Projects written in TypeScript still generally distribute packages containing compiled <em>.js</em> outputs.
They typically use <em>.d.ts</em> files to declare the backing TypeScript type system shapes behind those JavaScript files.</p>








<section data-type="sect2" data-pdf-bookmark="declaration"><div class="sect2" id="idm45584673387568">
<h2>declaration</h2>

<p>TypeScript <a data-type="indexterm" data-primary="declaration files" data-secondary="package types" data-tertiary="declaration compiler option" id="idm45584673386000"/><a data-type="indexterm" data-primary="package types" data-secondary="declaration compiler option" id="idm45584673332880"/><a data-type="indexterm" data-primary="declaration compiler option" id="idm45584673332032"/>provides a <code>declaration</code> option to create <em>.d.ts</em> outputs for input files alongside JavaScript outputs.</p>

<p class="less_space pagebreak-before">For example, given the following <em>index.ts</em> source file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">greet</code> <code class="o">=</code> <code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Hello, </code><code class="si">${</code><code class="nx">text</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">};</code></pre>

<p>Using <code>declaration</code>, a <code>module</code> of <code>"es2015"</code>, and a <code>target</code> of <code>"es2015"</code>, the following outputs would be generated:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.d.ts</code>
<code class="kr">export</code> <code class="kr">declare</code> <code class="kr">const</code> <code class="nx">greet</code><code class="o">:</code> <code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code></pre>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// index.js</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">greet</code> <code class="o">=</code> <code class="p">(</code><code class="nx">text</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Hello, </code><code class="si">${</code><code class="nx">text</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">};</code></pre>

<p>Auto-generated <em>.d.ts</em> files are the best way for a project to create type definitions to be used by consumers.
It’s generally recommended that most packages written in TypeScript that produce <em>.js</em> file outputs should also bundle <em>.d.ts</em> alongside those files.</p>

<p>Compiler options such as <code>declaration</code> are covered in more detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Dependency Package Types"><div class="sect2" id="idm45584673221920">
<h2>Dependency Package Types</h2>

<p>TypeScript is <a data-type="indexterm" data-primary="declaration files" data-secondary="package types" data-tertiary="dependency" id="idm45584673217584"/><a data-type="indexterm" data-primary="package types" data-secondary="dependency" id="idm45584673216416"/><a data-type="indexterm" data-primary="dependency package types" id="idm45584673215472"/>able to detect and utilize <em>.d.ts</em> files bundled inside a project’s 
<span class="keep-together"><code>node_modules</code></span> dependencies.
Those files will inform the type system about the type shapes exported by that package as if they were written inside the same project or declared with a <code>declare</code> module block.</p>

<p>A typical npm module that comes with its own <em>.d.ts</em> declaration files might have a file structure something like:</p>

<pre data-type="programlisting" data-code-language="text">lib/
    index.js
    index.d.ts
package.json</pre>

<p>As an example, the ever-popular test runner Jest is written in TypeScript and provides its own bundled <em>.d.ts</em> files in its <code>jest</code> package.
It has a dependency on the <code>@jest/globals</code> package that provides functions such as <code>describe</code> and <code>it</code>, which <code>jest</code> then makes available globally:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// package.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"devDependencies"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nt">"jest"</code><code class="p">:</code><code class="w"> </code><code class="s2">"^32.1.0"</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// using-globals.d.ts</code>
<code class="nx">describe</code><code class="p">(</code><code class="s2">"MyAPI"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">it</code><code class="p">(</code><code class="s2">"works"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">});</code>
<code class="p">});</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// using-imported.d.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">describe</code><code class="p">,</code> <code class="nx">it</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@jest/globals"</code><code class="p">;</code>

<code class="nx">describe</code><code class="p">(</code><code class="s2">"MyAPI"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">it</code><code class="p">(</code><code class="s2">"works"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">});</code>
<code class="p">});</code></pre>

<p>If we were to re-create a very limited subset of the Jest typings packages from scratch, they might look some something like these files.
The <code>@jest/globals</code> package exports the <code>describe</code> and <code>it</code> functions.
Then, the <code>jest</code> package imports those functions and augments the global scope with <code>describe</code> and <code>it</code> variables of their corresponding function’s type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// node_modules/@jest/globals/index.d.ts</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">describe</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">test</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">it</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">test</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// node_modules/jest/index.d.ts</code>
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">globals</code> <code class="nx">from</code> <code class="s2">"@jest/globals"</code><code class="p">;</code>

<code class="kr">declare</code> <code class="nx">global</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">describe</code>: <code class="nx">typeof</code> <code class="nx">globals</code><code class="p">.</code><code class="nx">describe</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">it</code>: <code class="nx">typeof</code> <code class="nx">globals</code><code class="p">.</code><code class="nx">it</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This structure allows projects that use Jest to refer to global versions of <code>describe</code> and <code>it</code>.
Projects can alternatively choose to import those functions from the <code>@jest/globals</code> package.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Exposing Package Types"><div class="sect2" id="idm45584673218752">
<h2>Exposing Package Types</h2>

<p>If your <a data-type="indexterm" data-primary="declaration files" data-secondary="package types" data-tertiary="exposing" id="idm45584672937568"/><a data-type="indexterm" data-primary="package types" data-secondary="exposing" id="idm45584672936288"/><a data-type="indexterm" data-primary="exposing package types" id="idm45584672935344"/>project is meant to be distributed on npm and provide types for consumers,  add a <code>"types"</code> field in the package’s <em>package.json</em> file to point to the root declaration file.
The <code>types</code> field works similarly to the <code>main</code> field—and often will look the same but with the <em>.d.ts</em> extension instead of <em>.js</em>.</p>

<p>For example, in this <code>fictional</code> package file, the <em>./lib/index.js</em> main runtime file is paralleled by the <em>./lib/index.d.ts</em> types file:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"author"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Pendant Publishing"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"main"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./lib/index.js"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"coffeetable"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./lib/index.d.ts"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"version"</code><code class="p">:</code><code class="w"> </code><code class="s2">"0.5.22"</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>TypeScript would then use the contents of the <em>./lib/index.d.ts</em> as what should be provided for consuming files that import from the <code>utilitarian</code> package.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If the <code>types</code> field does not exist in a package’s <em>package.json</em>, TypeScript will assume a default value of <em>./index.d.ts</em>.
This mirrors the default npm behavior of assuming an <em>./index.js</em> file as the <code>main</code> entry point for a package if not specified.</p>
</div>

<p>Most packages use TypeScript’s <code>declaration</code> compiler option to create <em>.d.ts</em> files alongside <em>.js</em> outputs from source files.
Compiler options are covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="DefinitelyTyped"><div class="sect1" id="idm45584672865792">
<h1>DefinitelyTyped</h1>

<p>Sadly, <a data-type="indexterm" data-primary="declaration files" data-secondary="package types" data-tertiary="DefinitelyTyped repository" id="declare-file-package-definite"/><a data-type="indexterm" data-primary="package types" data-secondary="DefinitelyTyped repository" id="package-type-definite"/><a data-type="indexterm" data-primary="DefinitelyTyped repository" id="definitelytyped"/><a data-type="indexterm" data-primary="types" data-secondary="DefinitelyTyped repository" id="type-definite"/>not all projects are written in TypeScript.
Some unfortunate developers are still writing their projects in plain old JavaScript without a type checker to aide them.
Horrifying.</p>

<p>Our TypeScript projects still need to be informed of the type shapes of the modules from those packages.
The TypeScript team and community created a giant repository called <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> to house community-authored definitions for packages.
DefinitelyTyped, or DT for short, is one of the most active repositories on GitHub.
It contains thousands of packages of <em>.d.ts</em> definitions, along with automation around reviewing change proposals and publishing updates.</p>

<p>DT packages are published on npm under the <code>@types</code> scope with the same name as the package they provide types for.
For example, as of 2022, <code>@types/react</code> provides type definitions for the <code>react</code> package.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>@types</code> are generally installed as either <code>dependencies</code> or <code>devDependencies</code>, though the distinction between those two has become blurred in recent years.
In general, if your project is meant to be distributed as an npm package, it should use <code>dependencies</code> so consumers of the package also bring in the type definitions used within.
If your project is a standalone application such as one built and run on a server, it should use <code>devDependencies</code> to convey that the types are just a development-time tool.</p>
</div>

<p>For example, for a utility package that relies on <code>lodash</code>—which as of 2022 has a separate <code>@types/lodash</code> package—the <em>package.json</em> would contain lines similar to:</p>

<pre data-type="programlisting" data-code-language="json" class="less_space pagebreak-before"><code class="c1">// package.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"dependencies"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nt">"@types/lodash"</code><code class="p">:</code><code class="w"> </code><code class="s2">"^4.14.182"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nt">"lodash"</code><code class="p">:</code><code class="w"> </code><code class="s2">"^4.17.21"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <em>package.json</em> for a standalone app built on React might contain lines similar to:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// package.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"dependencies"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nt">"react"</code><code class="p">:</code><code class="w"> </code><code class="s2">"^18.1.0"</code><code class="w"/>
<code class="w">    </code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="nt">"devDependencies"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nt">"@types/react"</code><code class="p">:</code><code class="w"> </code><code class="s2">"^18.0.9"</code><code class="w"/>
<code class="w">    </code><code class="p">},</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Note that semantic versioning (“semver”) numbers do not necessarily match between <code>@types/</code> packages and the packages they represent.
You may often find some that are off by a patch version as with React earlier, a minor version as with Lodash earlier, or even major versions.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>As these files are authored by the community, they may lag behind the parent project or have small inaccuracies.
If your project compiles successfully yet you get runtime errors when calling libraries, investigate if the signatures of the APIs you are accessing have changed.
This is less common, but still not unheard of, for mature projects with stable API surfaces.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Type Availability"><div class="sect2" id="idm45584672710256">
<h2>Type Availability</h2>

<p>Most popular JavaScript packages either ship with their own typings or have typings available via DefinitelyTyped.</p>

<p>If you’d like to get types for a package that doesn’t yet have types available, your three most common options would be:</p>

<ul>
<li>
<p>Send a pull request to DefinitelyTyped to create its <code>@types/</code> package.</p>
</li>
<li>
<p>Use the <code>declare module</code> syntax introduced earlier to write the types within your project.</p>
</li>
<li>
<p>Disable <code>noImplicitAny</code> as covered—and strongly warned against—in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>.</p>
</li>
</ul>

<p>I’d recommend contributing types to DefinitelyTyped if you have the time.
Doing so helps out other TypeScript developers who may also want to use that package.</p>
<div data-type="tip"><h6>Tip</h6>
<p>See <a href="https://aka.ms/types">aka.ms/types</a> to display whether a package has types bundled or via a <a data-type="indexterm" data-primary="declaration files" data-secondary="package types" data-tertiary="DefinitelyTyped repository" data-startref="declare-file-package-definite" id="idm45584672680960"/><a data-type="indexterm" data-primary="package types" data-secondary="DefinitelyTyped repository" data-startref="package-type-definite" id="idm45584672679504"/><a data-type="indexterm" data-primary="DefinitelyTyped repository" data-startref="definitelytyped" id="idm45584672678320"/><a data-type="indexterm" data-primary="types" data-secondary="DefinitelyTyped repository" data-startref="type-definite" id="idm45584672677408"/>separate <code>@types/</code> package.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584672865136">
<h1>Summary</h1>

<p>In this chapter, you used declaration files and value declarations to inform TypeScript about modules and values not declared in your source code:</p>

<ul>
<li>
<p>Creating declaration files with <em>.d.ts</em></p>
</li>
<li>
<p>Declaring types and values with the <code>declare</code> keyword</p>
</li>
<li>
<p>Changing global types using global values, global interface merges, and global augmentations</p>
</li>
<li>
<p>Configuring and using TypeScript’s built-in target, library, and DOM 
<span class="keep-together">declarations</span></p>
</li>
<li>
<p>Declaring types of modules, including wildcard modules</p>
</li>
<li>
<p>How TypeScript picks up types from packages</p>
</li>
<li>
<p>Using DefinitelyTyped to acquire types for packages that don’t include their own</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/declaration-files"><em class="hyperlink">https://learningtypescript.com/declaration-files</em></a>.</p>
</div>
<blockquote class="joke">
<p>What do TypeScript types say in the American South?</p>

<p>“Why, I do <code>declare</code>!”</p></blockquote>
</div></section>







</div></section></div></body></html>