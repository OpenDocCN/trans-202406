<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Querying"><div class="chapter" id="chapter_d1e3559"><h1><span class="label">Chapter 4. </span>Querying</h1><p>This<a data-type="indexterm" data-primary="queries" data-secondary="overview of" id="idm45882383106968"/> chapter looks at querying in detail. The main areas covered
  are as follows:</p><ul><li><p>You can query for ranges, set inclusion, inequalities, and more by
      using <span class="keep-together"><code>$</code>
      conditionals</span>.</p></li><li><p>Queries return a database cursor, which lazily returns batches of
      documents as you need them.</p></li><li><p>There are a lot of metaoperations you can perform on a cursor,
      including skipping a certain number of results, limiting the number of
      results returned, and sorting results.</p></li></ul><section data-type="sect1" data-pdf-bookmark="Introduction to find"><div class="sect1" id="sect1_d1e3612"><h1>Introduction to find</h1><p>The<a data-type="indexterm" data-primary="queries" data-secondary="find method" id="Qfind04"/><a data-type="indexterm" data-primary="find method" data-secondary="arguments to" id="idm45882383100104"/> <code class="function">find</code> method is used to
    perform queries in MongoDB. Querying returns a subset of documents in a
    collection, from no documents at all to the entire collection. Which
    documents get returned is determined by the first argument to <code class="function">find</code>, which is a document specifying the query
    criteria.</p><p>An empty query document (i.e., <code>{}</code>) matches everything in the collection. If
    <code class="function">find</code> isn’t given a query document, it
    defaults to <code>{}</code>. For example, the
    following:</p><pre id="I_programlisting4_d1e3721" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">()</code></pre><p>matches every document in the collection <em>c</em> (and
    returns these documents in batches).</p><p>When we start adding key/value pairs to the query document, we begin
    restricting our search. This works in a straightforward way for most
    types: numbers match numbers, booleans match booleans, and strings match
    strings. Querying for a simple type is as easy as specifying the value
    that you are looking for. For example, to find all documents where the
    value for <code>"age"</code> is <code>27</code>, we can add that key/value pair to the query
    document:</p><pre id="I_programlisting4_d1e3733" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"age"</code> <code class="o">:</code> <code class="mi">27</code><code class="p">})</code></pre><p>If we have a string we want to match, such as a <code>"username"</code> key with the value <code>"joe"</code>, we use that key/value pair
    instead:</p><pre id="I_programlisting4_d1e3743" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"username"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">})</code></pre><p>Multiple conditions<a data-type="indexterm" data-primary="find method" data-secondary="multiple conditions" id="idm45882383084600"/> can be strung together by adding more key/value pairs to
    the query document, which gets interpreted as
    “<em><code>condition1</code></em> AND
    <em><code>condition2</code></em> AND … AND <span class="keep-together"><em><code>conditionN</code></em></span>.” For
    instance, to get all users who are 27-year-olds with the username “joe,”
    we can query for the following:</p><pre id="I_programlisting4_d1e3750" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"username"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">,</code> <code class="s2">"age"</code> <code class="o">:</code> <code class="mi">27</code><code class="p">})</code></pre><section data-type="sect2" data-pdf-bookmark="Specifying Which Keys to Return"><div class="sect2" id="sect2_d1e3675"><h2>Specifying Which Keys to Return</h2><p>Sometimes<a data-type="indexterm" data-primary="keys" data-secondary="specifying query returns" id="idm45882382967240"/><a data-type="indexterm" data-primary="find method" data-secondary="specifying which keys to return" id="idm45882382966232"/> you do not need all of the key/value pairs in a document
      returned. If this is the case, you can pass a second argument to
      <code>find</code> (or <code>findOne</code>) specifying the keys you want. This
      reduces both the amount of data sent over the wire and the time and
      memory used to decode documents on the client side.</p><p>For example, if you have a user collection and you are interested
      only in the <span class="keep-together"><code>"username"</code> and</span> <code>"email"</code> keys, you could return just those keys
      with the following query:</p><pre id="I_programlisting4_d1e3789" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({},</code> <code class="p">{</code><code class="s2">"username"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"email"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">})</code>
<code class="p">{</code>
    <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f0dfd22aa494fd523620"</code><code class="p">),</code>
    <code class="s2">"username"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">,</code>
    <code class="s2">"email"</code> <code class="o">:</code> <code class="s2">"joe@example.com"</code>
<code class="p">}</code></pre><p>As you can see from the previous output, the <code>"_id"</code> key is returned by default, even if it
      isn’t specifically requested.</p><p>You can also use this second parameter to exclude specific
      key/value pairs from the results of a query. For instance, you may have
      documents with a variety of keys, and the only thing you know is that
      you never want to return the <code>"fatal_weakness"</code> key:</p><pre id="I_programlisting4_d1e3801" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({},</code> <code class="p">{</code><code class="s2">"fatal_weakness"</code> <code class="o">:</code> <code class="mi">0</code><code class="p">})</code></pre><p>This can also prevent <code>"_id"</code>
      from being returned:</p><pre id="I_programlisting4_d1e3808" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({},</code> <code class="p">{</code><code class="s2">"username"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="mi">0</code><code class="p">})</code>
<code class="p">{</code>
    <code class="s2">"username"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">,</code>
<code class="p">}</code></pre></div></section><section data-type="sect2" data-pdf-bookmark="Limitations"><div class="sect2" id="sect2_d1e3727"><h2>Limitations</h2><p>There<a data-type="indexterm" data-primary="queries" data-secondary="limitations" id="idm45882382792952"/><a data-type="indexterm" data-primary="find method" data-secondary="limitations of" id="idm45882382791912"/> are some restrictions on queries. The value of a query
      document must be a constant as far as the database is concerned. (It can
      be a normal variable in your own code.) That is, it cannot refer to the
      value of another key in the document. For example, if we were keeping
      inventory and we had both <code>"in_stock"</code>
      and <code>"num_sold"</code> keys, we couldn’t
      compare their values by querying the following:</p><pre id="I_programlisting4_d1e3826" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">stock</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"in_stock"</code> <code class="o">:</code> <code class="s2">"this.num_sold"</code><code class="p">})</code> <code class="c1">// doesn't work</code></pre><p>There are ways to do this (see <a data-type="xref" href="#sect1_d1e4429">“$where Queries”</a>),
      but you will usually get better performance by restructuring your
      document slightly, such that a “normal” query will suffice. In this
      example, we could instead use the keys <code>"initial_stock"</code> and <code>"in_stock"</code>. Then, every time someone buys an
      item, we decrement the value of the <code>"in_stock"</code> key by one. Finally, we can do a
      simple query to check which items are<a data-type="indexterm" data-startref="Qfind04" id="idm45882382781352"/> out of stock:</p><pre id="I_programlisting4_d1e3841" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">stock</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"in_stock"</code> <code class="o">:</code> <code class="mi">0</code><code class="p">})</code></pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="Query Criteria"><div class="sect1" id="sect1_d1e3761"><h1>Query Criteria</h1><p>Queries<a data-type="indexterm" data-primary="queries" data-secondary="criteria for" id="Qcriteria04"/> can go beyond the exact matching described in the previous
    section; they can match more complex criteria, such as ranges, OR-clauses,
    and negation.</p><section data-type="sect2" data-pdf-bookmark="Query Conditionals"><div class="sect2" id="sect2_d1e3766"><h2>Query Conditionals</h2><p><code>"$lt"</code>, <code>"$lte"</code>, <code>"$gt"</code>, and <code>"$gte"</code> are all<a data-type="indexterm" data-primary="conditionals, query" id="idm45882382709800"/><a data-type="indexterm" data-primary="queries" data-secondary="range queries" id="idm45882382708936"/><a data-type="indexterm" data-primary="$gte operator" data-primary-sortas="gte operator" id="idm45882382707832"/><a data-type="indexterm" data-primary="$gt operator" data-primary-sortas="gt operator" id="idm45882382706728"/><a data-type="indexterm" data-primary="$lte operator" data-primary-sortas="lte operator" id="idm45882382705624"/><a data-type="indexterm" data-primary="$lt operator" data-primary-sortas="lt operator" id="idm45882382704520"/><a data-type="indexterm" data-primary="comparison operators" id="idm45882382703416"/><a data-type="indexterm" data-primary="query conditionals" id="idm45882382702584"/> comparison operators, corresponding to &lt;, &lt;=, &gt;,
      and &gt;=, respectively. They can be combined to look for a range of
      values. For example, to look for users who are between the ages of 18
      and 30, we can do this:</p><pre id="I_programlisting4_d1e3895" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"age"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$gte"</code> <code class="o">:</code> <code class="mi">18</code><code class="p">,</code> <code class="s2">"$lte"</code> <code class="o">:</code> <code class="mi">30</code><code class="p">}})</code></pre><p>This would find all documents where the <code>"age"</code> field was greater than or equal to
      <code>18</code> AND less than or equal to <code>30</code>.</p><p>These types of range queries are often useful for dates. For
      example, to find people who registered before January 1, 2007, we can do
      this:</p><pre id="I_programlisting4_d1e3899" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">start</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s2">"01/01/2007"</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"registered"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$lt"</code> <code class="o">:</code> <code class="nx">start</code><code class="p">}})</code></pre><p>Depending on how you create and store dates, an exact match might
      be less useful, since dates are stored with millisecond precision. Often
      you want a whole day, week, or month, making a range query <span class="keep-together">necessary</span>.</p><p>To query for documents where a key’s value is not equal to a
      certain value, you must use another<a data-type="indexterm" data-primary="$ne operator" data-primary-sortas="ne operator" id="idm45882382645544"/> conditional operator, <code>"$ne"</code>, which stands for “not equal.” If you
      want to find all users who do not have the username “joe,” you can query
      for them using this:</p><pre id="I_programlisting4_d1e3914" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"username"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$ne"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">}})</code></pre><p><code>"$ne"</code> can be used with any
      type.</p></div></section><section data-type="sect2" data-pdf-bookmark="OR Queries"><div class="sect2" id="sect2_d1e3813"><h2>OR Queries</h2><p>There<a data-type="indexterm" data-primary="$or operator" data-primary-sortas="or operator" id="idm45882382609464"/><a data-type="indexterm" data-primary="$in operator" data-primary-sortas="in operator" id="idm45882382608392"/><a data-type="indexterm" data-primary="queries" data-secondary="OR queries" id="idm45882382607288"/> are two ways to do an OR query in MongoDB. <code>"$in"</code> can be used to query for a variety of
      values for a single key. <code>"$or"</code> is
      more general; it can be used to query for any of the given values across
      multiple keys.</p><p>If you have more than one possible value to match for a single
      key, use an array of criteria with <code>"$in"</code>. For instance, suppose we’re running a
      raffle and the winning ticket numbers are 725, 542, and 390. To find all
      three of these documents, we can construct the following query:</p><pre id="I_programlisting4_d1e3956" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">raffle</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"ticket_no"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$in"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">725</code><code class="p">,</code> <code class="mi">542</code><code class="p">,</code> <code class="mi">390</code><code class="p">]}})</code></pre><p><code>"$in"</code> is very flexible and
      allows you to specify criteria of different types as well as values. For
      example, if we are gradually migrating our schema to use usernames
      instead of user ID numbers, we can query for either by using
      this:</p><pre id="I_programlisting4_d1e3962" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"user_id"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$in"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">12345</code><code class="p">,</code> <code class="s2">"joe"</code><code class="p">]}})</code></pre><p>This matches documents with a <code>"user_id"</code> equal to <code>12345</code> and documents with a <code>"user_id"</code> equal to <code>"joe"</code>.</p><p>If <code>"$in"</code> is given an array with
      a single value, it behaves the same as directly matching the value. For
      instance, <code>{ticket_no : {$in : [725]}}</code>
      matches the same documents as <code>{ticket_no :
      725}</code>.</p><p>The<a data-type="indexterm" data-primary="$nin operator" data-primary-sortas="nin operator" id="idm45882382507608"/> opposite of <code>"$in"</code> is
      <code>"$nin"</code>, which returns documents that
      don’t match any of the criteria in the array. If we want to return all
      of the people who didn’t win anything in the raffle, we can query for
      them with this:</p><pre id="I_programlisting4_d1e3997" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">raffle</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"ticket_no"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$nin"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">725</code><code class="p">,</code> <code class="mi">542</code><code class="p">,</code> <code class="mi">390</code><code class="p">]}})</code></pre><p>This query returns everyone who did not have tickets with those
      numbers.</p><p><code>"$in"</code> gives you an OR query for
      a single key, but what if we need to find documents where <code>"ticket_no"</code> is <code>725</code> or <code>"winner"</code> is <code>true</code>? For this type of query, we’ll need to
      use the <code>"$or"</code> conditional. <code>"$or"</code> takes an array of possible criteria. In
      the raffle case, using <code>"$or"</code> would
      look like this:</p><pre id="I_programlisting4_d1e4025" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">raffle</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"$or"</code> <code class="o">:</code> <code class="p">[{</code><code class="s2">"ticket_no"</code> <code class="o">:</code> <code class="mi">725</code><code class="p">},</code> <code class="p">{</code><code class="s2">"winner"</code> <code class="o">:</code> <code class="kc">true</code><code class="p">}]})</code></pre><p><code>"$or"</code> can contain other
      conditionals. If, for example, we want to match any of the three
      <code>"ticket_no"</code> values or the <code>"winner"</code> key, we can use this:</p><pre id="I_programlisting4_d1e4037" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">raffle</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"$or"</code> <code class="o">:</code> <code class="p">[{</code><code class="s2">"ticket_no"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$in"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">725</code><code class="p">,</code> <code class="mi">542</code><code class="p">,</code> <code class="mi">390</code><code class="p">]}},</code>
<code class="p">...</code>                        <code class="p">{</code><code class="s2">"winner"</code> <code class="o">:</code> <code class="kc">true</code><code class="p">}]})</code></pre><p>With a normal AND-type query, you want to narrow down your results
      as far as possible in as few arguments as possible. OR-type queries are
      the opposite: they are most efficient if the first arguments match as
      many documents as possible.</p><p>While <code>"$or"</code> will always work,
      use <code>"$in"</code> whenever possible as the
      query optimizer handles it more efficiently.</p></div></section><section data-type="sect2" data-pdf-bookmark="$not"><div class="sect2" id="sect2_d1e3927"><h2>$not</h2><p><code>"$not"</code> is<a data-type="indexterm" data-primary="$not operator" data-primary-sortas="not operator" id="idm45882382338520"/> a metaconditional: it can be applied on top of any other
      criteria. As an example, let’s consider the<a data-type="indexterm" data-primary="$mod operator" data-primary-sortas="mod operator" id="idm45882382337128"/> modulus operator, <code>"$mod"</code>. <code>"$mod"</code> queries for keys whose values, when
      divided by the first value given, have a remainder of the second
      value:</p><pre id="I_programlisting4_d1e4069" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"id_num"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$mod"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">1</code><code class="p">]}})</code></pre><p>The previous query returns users with <code>"id_num"</code>s of <code>1</code>, <code>6</code>,
      <code>11</code>, <code>16</code>, and so on. If we want, instead, to return
      users with <code>"id_num"</code>s of <code>2</code>, <code>3</code>,
      <code>4</code>, <code>5</code>, <code>7</code>,
      <code>8</code>, <code>9</code>, <code>10</code>,
      <code>12</code>, etc., we can use <code>"$not"</code>:</p><pre id="I_programlisting4_d1e4082" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"id_num"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$not"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$mod"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">1</code><code class="p">]}}})</code></pre><p><code>"$not"</code> can be particularly
      useful in conjunction with regular expressions to find all documents
      that don’t match a given pattern (regular expression usage is
      described<a data-type="indexterm" data-startref="Qcriteria04" id="idm45882382238776"/> in the section <a data-type="xref" href="#sect2_d1e4085">“Regular Expressions”</a>).</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="Type-Specific Queries"><div class="sect1" id="sect1_d1e4013"><h1>Type-Specific Queries</h1><p>As covered in <a data-type="xref" href="ch02.xhtml#chapter-2">Chapter 2</a>, MongoDB has a wide
    variety of types that can be used in a document. Some of these types have
    special behavior when querying.</p><section data-type="sect2" data-pdf-bookmark="null"><div class="sect2" id="sect2_d1e4021"><h2>null</h2><p><code>null</code> behaves<a data-type="indexterm" data-primary="queries" data-secondary="type-specific" data-tertiary="null" id="idm45882382233032"/><a data-type="indexterm" data-primary="null type" data-secondary="querying on" id="idm45882382231624"/> a bit strangely. It does match itself, so if we have a
      collection with the following documents:</p><pre id="I_programlisting4_d1e4176" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">()</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f0dfd22aa494fd523621"</code><code class="p">),</code> <code class="s2">"y"</code> <code class="o">:</code> <code class="kc">null</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f0dfd22aa494fd523622"</code><code class="p">),</code> <code class="s2">"y"</code> <code class="o">:</code> <code class="mi">1</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f148d22aa494fd523623"</code><code class="p">),</code> <code class="s2">"y"</code> <code class="o">:</code> <code class="mi">2</code> <code class="p">}</code></pre><p>we can query for documents whose <code>"y"</code> key is <code>null</code> in the expected way:</p><pre id="I_programlisting4_d1e4186" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"y"</code> <code class="o">:</code> <code class="kc">null</code><code class="p">})</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f0dfd22aa494fd523621"</code><code class="p">),</code> <code class="s2">"y"</code> <code class="o">:</code> <code class="kc">null</code> <code class="p">}</code></pre><p>However, <code>null</code> also matches
      “does not exist.” Thus, querying for a key with the value <code>null</code> will return all documents lacking that
      key:</p><pre id="I_programlisting4_d1e4196" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"z"</code> <code class="o">:</code> <code class="kc">null</code><code class="p">})</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f0dfd22aa494fd523621"</code><code class="p">),</code> <code class="s2">"y"</code> <code class="o">:</code> <code class="kc">null</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f0dfd22aa494fd523622"</code><code class="p">),</code> <code class="s2">"y"</code> <code class="o">:</code> <code class="mi">1</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4ba0f148d22aa494fd523623"</code><code class="p">),</code> <code class="s2">"y"</code> <code class="o">:</code> <code class="mi">2</code> <code class="p">}</code></pre><p>If we only want to find keys whose value is <code>null</code>, we can check that the key is <code>null</code> and exists using the <code>"$exists"</code> conditional:</p><pre id="I_programlisting4_d1e4212" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"z"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$eq"</code> <code class="o">:</code> <code class="kc">null</code><code class="p">,</code> <code class="s2">"$exists"</code> <code class="o">:</code> <code class="kc">true</code><code class="p">}})</code></pre></div></section><section data-type="sect2" data-pdf-bookmark="Regular Expressions"><div class="sect2" id="sect2_d1e4085"><h2>Regular Expressions</h2><p><code>"$regex"</code> provides<a data-type="indexterm" data-primary="queries" data-secondary="type-specific" data-tertiary="regular expressions" id="idm45882382027672"/><a data-type="indexterm" data-primary="regular expressions" data-secondary="querying with" id="idm45882382026328"/> regular expression capabilities for pattern matching
      strings in queries. Regular expressions are useful for flexible string
      matching. For example, if we want to find all users with the name “Joe”
      or “joe,” we can use a regular expression to do case-insensitive
      matching:</p><pre id="I_programlisting4_d1e4247" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code> <code class="p">{</code><code class="s2">"name"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$regex"</code> <code class="o">:</code> <code class="sr">/joe/i</code> <code class="p">}</code> <code class="p">})</code></pre><p>Regular expression flags (e.g., <code>i</code>) are allowed but not required. If we want to
      match not only various capitalizations of “joe,” but also “joey,” we can
      continue to improve our regular expression:</p><pre id="I_programlisting4_d1e4254" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"name"</code> <code class="o">:</code> <code class="sr">/joey?/i</code><code class="p">})</code></pre><p>MongoDB uses the Perl Compatible Regular Expression (PCRE)
      library<a data-type="indexterm" data-primary="Perl Compatible Regular Expression (PCRE) library" id="idm45882382002040"/> to match regular expressions; any regular expression
      syntax allowed by PCRE is allowed in <span class="keep-together">MongoDB</span>. It is a good idea to check your
      syntax with the JavaScript shell before using it in a query to make sure
      it matches what you think it matches.</p><div data-type="note" epub:type="note"><h6>Note</h6><p>MongoDB<a data-type="indexterm" data-primary="regular expressions" data-secondary="prefix expressions" id="idm45882381931800"/> can leverage an index for queries on prefix regular
        expressions (e.g., <code>/^joey/</code>).
        Indexes <em>cannot</em> be used for case-insensitive
        searches (<code>/^joey/i</code>). A regular
        expression is a “prefix expression” when it starts with either a caret
        (<code>^</code>) or a left anchor (<code>\A</code>). If the regular expression uses a
        case-sensitive query, then if an index exists for the field, the
        matches can be conducted against values in the index. If it also is a
        prefix expression, then the search can be limited to the values within
        the range created by that prefix from the index.</p></div><p>Regular expressions can also match themselves. Very few people
      insert regular expressions into the database, but if you insert one, you
      can match it with itself:</p><pre id="I_programlisting4_d1e4274" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"bar"</code> <code class="o">:</code> <code class="sr">/baz/</code><code class="p">})</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"bar"</code> <code class="o">:</code> <code class="sr">/baz/</code><code class="p">})</code>
<code class="p">{</code>
    <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4b23c3ca7525f35f94b60a2d"</code><code class="p">),</code>
    <code class="s2">"bar"</code> <code class="o">:</code> <code class="sr">/baz/</code>
<code class="p">}</code></pre></div></section><section data-type="sect2" data-pdf-bookmark="Querying Arrays"><div class="sect2" id="sect2_d1e4125"><h2>Querying Arrays</h2><p>Querying<a data-type="indexterm" data-primary="arrays" data-secondary="querying" id="Aquery04"/><a data-type="indexterm" data-primary="queries" data-secondary="type-specific" data-tertiary="arrays" id="QTSarray04"/> for elements of an array is designed to behave the way
      querying for scalars does. For example, if the array is a list of
      fruits, like this:</p><pre id="I_programlisting4_d1e4293" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"peach"</code><code class="p">]})</code></pre><p>the following query will successfully match the document:</p><pre id="I_programlisting4_d1e4297" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="s2">"banana"</code><code class="p">})</code></pre><p>We can query for it in much the same way as we would if we had a
      document that looked like the (illegal) document <code>{"fruit" : "apple", "fruit" : "banana", "fruit" :
      "peach"}</code>.</p><section data-type="sect3" data-pdf-bookmark="“$all”"><div class="sect3" id="sect3_d1e4149"><h3>“$all”</h3><p>If<a data-type="indexterm" data-primary="$all operator" data-primary-sortas="all operator" id="idm45882381819240"/> you need to match arrays by more than one element, you
        can use <code>"$all"</code>. This allows you to
        match a list of elements. For example, suppose we create a collection
        with three elements:</p><pre id="I_programlisting4_d1e4322" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"_id"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"peach"</code><code class="p">]})</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"_id"</code> <code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"kumquat"</code><code class="p">,</code> <code class="s2">"orange"</code><code class="p">]})</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"_id"</code> <code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"cherry"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"apple"</code><code class="p">]})</code></pre><p>Then we can find all documents with both <code>"apple"</code> and <code>"banana"</code> elements by querying with <code>"$all"</code>:</p><pre id="I_programlisting4_d1e4335" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">fruit</code> <code class="o">:</code> <code class="p">{</code><code class="nx">$all</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">]}})</code>
<code class="p">{</code><code class="s2">"_id"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"peach"</code><code class="p">]}</code>
<code class="p">{</code><code class="s2">"_id"</code> <code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"cherry"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"apple"</code><code class="p">]}</code></pre><p>Order does not matter. Notice <code>"banana"</code> comes before <code>"apple"</code> in the second result. Using a
        one-element array with <code>"$all"</code> is
        equivalent to not using <code>"$all"</code>. For
        instance, <code>{fruit : {$all :
        ['apple']}</code> will match the same documents as <code>{fruit : 'apple'}</code>.</p><p>You can also query by exact match using the entire array.
        However, exact match will not match a document if any elements are
        missing or superfluous. For example, this will match the first of our
        three documents:</p><pre id="I_programlisting4_d1e4360" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"peach"</code><code class="p">]})</code></pre><p>But this will not:</p><pre id="I_programlisting4_d1e4364" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"banana"</code><code class="p">]})</code></pre><p>and neither will this:</p><pre id="I_programlisting4_d1e4369" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">[</code><code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"peach"</code><code class="p">]})</code></pre><p>If you want to query for a specific element of an array, you can
        specify an index using the syntax
        <em><code>key</code></em>.<em><code>index</code></em>:</p><pre id="I_programlisting4_d1e4379" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"fruit.2"</code> <code class="o">:</code> <code class="s2">"peach"</code><code class="p">})</code></pre><p>Arrays are always 0-indexed, so this would match the third array
        element against the string <code>"peach"</code>.</p></div></section><section data-type="sect3" data-pdf-bookmark="“$size”"><div class="sect3" id="sect3_d1e4224"><h3>“$size”</h3><p>A<a data-type="indexterm" data-primary="$size operator" data-primary-sortas="size operator" id="idm45882381451976"/> useful conditional for querying arrays is <code>"$size"</code>, which allows you to query for
        arrays of a given size. Here’s an example:</p><pre id="I_programlisting4_d1e4401" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$size"</code> <code class="o">:</code> <code class="mi">3</code><code class="p">}})</code></pre><p>One common query is to get a range of sizes. <code>"$size"</code> cannot be combined with another
        <code>$</code> conditional (in this example,
        <code>"$gt"</code>), but this query can be
        accomplished by adding a <code>"size"</code> key
        to the document. Then, every time you add an element to the array,
        increment the value of <code>"size"</code>. If
        the original update looked like this:</p><pre id="I_programlisting4_d1e4417" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">update</code><code class="p">(</code><code class="nx">criteria</code><code class="p">,</code> <code class="p">{</code><code class="s2">"$push"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="s2">"strawberry"</code><code class="p">}})</code></pre><p>it can simply be changed to this:</p><pre id="I_programlisting4_d1e4421" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">update</code><code class="p">(</code><code class="nx">criteria</code><code class="p">,</code>
<code class="p">...</code> <code class="p">{</code><code class="s2">"$push"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"fruit"</code> <code class="o">:</code> <code class="s2">"strawberry"</code><code class="p">},</code> <code class="s2">"$inc"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"size"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">}})</code></pre><p>Incrementing is extremely fast, so any performance penalty is
        negligible. Storing documents like this allows you to do queries such
        as this:</p><pre id="I_programlisting4_d1e4425" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">food</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"size"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$gt"</code> <code class="o">:</code> <code class="mi">3</code><code class="p">}})</code></pre><p>Unfortunately, this technique doesn’t work as well with the
        <code>"$addToSet"</code> operator.</p></div></section><section data-type="sect3" data-pdf-bookmark="“$slice”"><div class="sect3" id="sect3_d1e4277"><h3>“$slice”</h3><p>As<a data-type="indexterm" data-primary="$slice operator" data-primary-sortas="slice operator" id="idm45882381243960"/> mentioned earlier in this chapter, the optional second
        argument to <code class="function">find</code> specifies the
        keys to be returned. The special <code>"$slice"</code> operator can be used to return a
        subset of elements for an array key.</p><p>For example, suppose we had a blog post document and we wanted
        to return the first 10 comments:</p><pre id="I_programlisting4_d1e4455" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">posts</code><code class="p">.</code><code class="nx">findOne</code><code class="p">(</code><code class="nx">criteria</code><code class="p">,</code> <code class="p">{</code><code class="s2">"comments"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$slice"</code> <code class="o">:</code> <code class="mi">10</code><code class="p">}})</code></pre><p>Alternatively, if we wanted the last 10 comments, we could use
        <code>−10</code>:</p><pre id="I_programlisting4_d1e4459" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">posts</code><code class="p">.</code><code class="nx">findOne</code><code class="p">(</code><code class="nx">criteria</code><code class="p">,</code> <code class="p">{</code><code class="s2">"comments"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$slice"</code> <code class="o">:</code> <code class="o">-</code><code class="mi">10</code><code class="p">}})</code></pre><p><code>"$slice"</code> can also return
        pages in the middle of the results by taking an offset and the number
        of elements to return:</p><pre id="I_programlisting4_d1e4465" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">posts</code><code class="p">.</code><code class="nx">findOne</code><code class="p">(</code><code class="nx">criteria</code><code class="p">,</code> <code class="p">{</code><code class="s2">"comments"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$slice"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">23</code><code class="p">,</code> <code class="mi">10</code><code class="p">]}})</code></pre><p>This would skip the first 23 elements and return the 24th
        through 33rd. If there were fewer than 33 elements in the array, it
        would return as many as possible.</p><p>Unless otherwise specified, all keys in a document are returned
        when <code>"$slice"</code> is used. This is
        unlike the other key specifiers, which suppress unmentioned keys from
        being returned. For instance, if we had a blog post document that
        looked like this:</p><pre id="I_programlisting4_d1e4474" data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
    <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4b2d75476cc613d5ee930164"</code><code class="p">),</code>
    <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"A blog post"</code><code class="p">,</code>
    <code class="s2">"content"</code> <code class="o">:</code> <code class="s2">"..."</code><code class="p">,</code>
    <code class="s2">"comments"</code> <code class="o">:</code> <code class="p">[</code>
        <code class="p">{</code>
            <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">,</code>
            <code class="s2">"email"</code> <code class="o">:</code> <code class="s2">"joe@example.com"</code><code class="p">,</code>
            <code class="s2">"content"</code> <code class="o">:</code> <code class="s2">"nice post."</code>
        <code class="p">},</code>
        <code class="p">{</code>
            <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"bob"</code><code class="p">,</code>
            <code class="s2">"email"</code> <code class="o">:</code> <code class="s2">"bob@example.com"</code><code class="p">,</code>
            <code class="s2">"content"</code> <code class="o">:</code> <code class="s2">"good post."</code>
        <code class="p">}</code>
    <code class="p">]</code>
<code class="p">}</code></pre><p>and we did a <code>"$slice"</code> to get
        the last comment, we’d get this:</p><pre id="I_programlisting4_d1e4482" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">posts</code><code class="p">.</code><code class="nx">findOne</code><code class="p">(</code><code class="nx">criteria</code><code class="p">,</code> <code class="p">{</code><code class="s2">"comments"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$slice"</code> <code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">}})</code>
<code class="p">{</code>
    <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4b2d75476cc613d5ee930164"</code><code class="p">),</code>
    <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"A blog post"</code><code class="p">,</code>
    <code class="s2">"content"</code> <code class="o">:</code> <code class="s2">"..."</code><code class="p">,</code>
    <code class="s2">"comments"</code> <code class="o">:</code> <code class="p">[</code>
        <code class="p">{</code>
            <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"bob"</code><code class="p">,</code>
            <code class="s2">"email"</code> <code class="o">:</code> <code class="s2">"bob@example.com"</code><code class="p">,</code>
            <code class="s2">"content"</code> <code class="o">:</code> <code class="s2">"good post."</code>
        <code class="p">}</code>
    <code class="p">]</code>
<code class="p">}</code></pre><p>Both <code>"title"</code> and <code>"content"</code> are still returned, even though
        they weren’t explicitly included in the key specifier.</p></div></section><section data-type="sect3" data-pdf-bookmark="Returning a matching array element"><div class="sect3" id="idm45882381289336"><h3>Returning a matching array element</h3><p><code>"$slice"</code> is helpful<a data-type="indexterm" data-primary="$ (dollar sign)" data-secondary="querying arrays" id="idm45882380954504"/> when you know the index of the element, but sometimes
        you want whichever array element matched your criteria. You can return
        the matching element with the <code>$</code>
        operator. Given the previous blog example, you could get Bob’s comment
        back with:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">posts</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"comments.name"</code> <code class="o">:</code> <code class="s2">"bob"</code><code class="p">},</code> <code class="p">{</code><code class="s2">"comments.$"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">})</code>
<code class="p">{</code>
    <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"4b2d75476cc613d5ee930164"</code><code class="p">),</code>
    <code class="s2">"comments"</code> <code class="o">:</code> <code class="p">[</code>
        <code class="p">{</code>
            <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"bob"</code><code class="p">,</code>
            <code class="s2">"email"</code> <code class="o">:</code> <code class="s2">"bob@example.com"</code><code class="p">,</code>
            <code class="s2">"content"</code> <code class="o">:</code> <code class="s2">"good post."</code>
        <code class="p">}</code>
    <code class="p">]</code>
<code class="p">}</code></pre><p>Note that this only returns the first match for each document:
        if Bob had left multiple comments on this post, only the first one in
        the <code>"comments"</code> array would be
        returned.</p></div></section><section data-type="sect3" data-pdf-bookmark="Array and range query interactions"><div class="sect3" id="idm45882380865544"><h3>Array and range query interactions</h3><p>Scalars (nonarray elements) in documents must match each clause
        of a query’s criteria. For example, if you queried for <code>{"x" : {"$gt" : 10, "$lt" : 20}}</code>, <code>"x"</code> would have to be both greater than 10
        and less than 20. However, if a document’s <code>"x"</code> field is an array, the document matches
        if there is an element of <code>"x"</code> that
        matches each part of the criteria <em>but each query clause can
        match a different array element</em>.</p><p>The best way to understand this behavior is to see an example.
        Suppose we have the following documents:</p><pre data-type="programlisting" data-code-language="javascript"><code class="p">{</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">5</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">15</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">25</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"x"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">25</code><code class="p">]}</code></pre><p>If we wanted to find all documents where <code>"x"</code> is between 10 and 20, we might naively
        structure a query as <code>db.test.find({"x" :
        {"$gt" : 10, "$lt" : 20}})</code> and expect to get back one
        document: <code>{"x" : 15}</code>. However,
        running this, we get two:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">test</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$gt"</code> <code class="o">:</code> <code class="mi">10</code><code class="p">,</code> <code class="s2">"$lt"</code> <code class="o">:</code> <code class="mi">20</code><code class="p">}})</code>
<code class="p">{</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">15</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"x"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">25</code><code class="p">]}</code></pre><p>Neither 5 nor 25 is between 10 and 20, but the document is
        returned because 25 matches the first clause (it is greater than 10)
        and 5 matches the second clause (it is less than 20).</p><p>This<a data-type="indexterm" data-primary="queries" data-secondary="range queries" id="idm45882380754600"/> makes range queries against arrays essentially useless:
        a range will match any multielement array. There are a couple of ways
        to get the expected behavior.</p><p>First, you can use <code>"$elemMatch<a data-type="indexterm" data-primary="$elemMatch operator" data-primary-sortas="elemMatch operator" id="idm45882380752872"/>"</code> to force MongoDB to compare both clauses
        with a single array element. However, the catch is that <code>"$elemMatch"</code> won’t match nonarray
        elements:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">test</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$elemMatch"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$gt"</code> <code class="o">:</code> <code class="mi">10</code><code class="p">,</code> <code class="s2">"$lt"</code> <code class="o">:</code> <code class="mi">20</code><code class="p">}}})</code>
<code class="o">&gt;</code> <code class="c1">// no results</code></pre><p>The document <code>{"x" : 15}</code> no
        longer matches the query, because the <code>"x"</code> field is not an array. That said, you
        should have a good reason for mixing array and scalar values in a
        field. Many uses cases do not require mixing. For those, <code>"$elemMatch"</code> provides a good solution for
        range queries on array elements.</p><p>If you have an index over the field that you’re querying on (see
        <a data-type="xref" href="ch05.xhtml#chapter_d1e5128">Chapter 5</a>), you can use <code class="function">min</code> and <code class="function">max</code> to limit the index range traversed by
        the query to your <code>"$gt"</code> and
        <code>"$lt"</code> values:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">test</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$gt"</code> <code class="o">:</code> <code class="mi">10</code><code class="p">,</code> <code class="s2">"$lt"</code> <code class="o">:</code> <code class="mi">20</code><code class="p">}}).</code><code class="nx">min</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">10</code><code class="p">}).</code><code class="nx">max</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">20</code><code class="p">})</code>
<code class="p">{</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">15</code><code class="p">}</code></pre><p>Now this will only traverse the index from 10 to 20, missing the
        5 and 25 entries. You can only use <code class="function">min</code> and <code class="function">max</code> when you have an index on the field you
        are querying for, though, and you must pass all fields of the index to
        <code class="function">min</code> and <code class="function">max</code>.</p><p>Using <code class="function">min</code> and <code class="function">max</code> when querying for ranges over documents
        that may include arrays is generally a good idea. The index bounds for
        a <code>"$gt"</code>/<code>"$lt"</code> query over an array is inefficient. It
        basically accepts any value, so it will search every index entry, not
        just those in the<a data-type="indexterm" data-startref="Aquery04" id="idm45882380631832"/><a data-type="indexterm" data-startref="QTSarray04" id="idm45882380631000"/> range.</p></div></section></div></section><section data-type="sect2" data-pdf-bookmark="Querying on Embedded Documents"><div class="sect2" id="sect2_d1e4349"><h2>Querying on Embedded Documents</h2><p>There<a data-type="indexterm" data-primary="queries" data-secondary="type-specific" data-tertiary="embedded documents" id="idm45882380629096"/><a data-type="indexterm" data-primary="embedded documents" data-secondary="querying" id="idm45882380627688"/> are two ways of querying for an embedded document:
      querying for the whole document or querying for its individual key/value
      pairs.</p><p>Querying for an entire embedded document works identically to a
      normal query. For example, if we have a document that looks like
      this:</p><pre id="I_programlisting4_d1e4513" data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
    <code class="s2">"name"</code> <code class="o">:</code> <code class="p">{</code>
        <code class="s2">"first"</code> <code class="o">:</code> <code class="s2">"Joe"</code><code class="p">,</code>
        <code class="s2">"last"</code> <code class="o">:</code> <code class="s2">"Schmoe"</code>
    <code class="p">},</code>
    <code class="s2">"age"</code> <code class="o">:</code> <code class="mi">45</code>
<code class="p">}</code></pre><p>we can query for someone named Joe Schmoe with the
      following:</p><pre id="I_programlisting4_d1e4517" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"name"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"first"</code> <code class="o">:</code> <code class="s2">"Joe"</code><code class="p">,</code> <code class="s2">"last"</code> <code class="o">:</code> <code class="s2">"Schmoe"</code><code class="p">}})</code></pre><p>However, a query for a full subdocument must exactly match the
      subdocument. If Joe decides to add a middle name field, suddenly this
      query won’t work anymore; it doesn’t match the entire embedded document!
      This type of query is also order-sensitive: <code>{"last" : "Schmoe", "first" : "Joe"}</code> would not
      be a match.</p><p>If possible, it’s usually a good idea to query for just a specific
      key or keys of an embedded document. Then, if your schema changes, all
      of your queries won’t suddenly break because they’re no longer exact
      matches. You<a data-type="indexterm" data-primary="queries" data-secondary="dot notation and" id="idm45882380560296"/> can query for embedded keys using dot notation:</p><pre id="I_programlisting4_d1e4526" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"name.first"</code> <code class="o">:</code> <code class="s2">"Joe"</code><code class="p">,</code> <code class="s2">"name.last"</code> <code class="o">:</code> <code class="s2">"Schmoe"</code><code class="p">})</code></pre><p>Now, if Joe adds more keys, this query will still match his first
      and last names.</p><p>This dot notation is the main difference between query documents
      and other document types. Query documents can contain dots, which mean
      “reach into an embedded document.” Dot notation is also the reason that
      documents to be inserted cannot contain the <code>.</code> character. Oftentimes<a data-type="indexterm" data-primary="keys" data-secondary="limitations on" id="idm45882380520408"/> people run into this limitation when trying to save URLs
      as keys. One way to get around it is to always perform a global replace
      before inserting or after retrieving, substituting a character that
      isn’t legal in URLs for the dot <span class="keep-together">character</span>.</p><p>Embedded document matches can get a little tricky as the document
      structure gets more complicated. For example, suppose we are storing
      blog posts and we want to find comments by Joe that were scored at least
      a 5. We could model the post as <span class="keep-together">follows</span>:</p><pre id="I_programlisting4_d1e4546" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">find</code><code class="p">()</code>
<code class="p">{</code>
    <code class="s2">"content"</code> <code class="o">:</code> <code class="s2">"..."</code><code class="p">,</code>
    <code class="s2">"comments"</code> <code class="o">:</code> <code class="p">[</code>
        <code class="p">{</code>
            <code class="s2">"author"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">,</code>
            <code class="s2">"score"</code> <code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
            <code class="s2">"comment"</code> <code class="o">:</code> <code class="s2">"nice post"</code>
        <code class="p">},</code>
        <code class="p">{</code>
            <code class="s2">"author"</code> <code class="o">:</code> <code class="s2">"mary"</code><code class="p">,</code>
            <code class="s2">"score"</code> <code class="o">:</code> <code class="mi">6</code><code class="p">,</code>
            <code class="s2">"comment"</code> <code class="o">:</code> <code class="s2">"terrible post"</code>
        <code class="p">}</code>
    <code class="p">]</code>
<code class="p">}</code></pre><p>Now, we can’t query using <code>db.blog.find({"comments" : {"author" : "joe", "score" :
      {"$gte" : 5}}})</code>. Embedded document matches have to match the
      whole document, and this doesn’t match the <code>"comment"</code> key. It also wouldn’t work to do
      <code>db.blog.find({"comments.author" : "joe",
      "comments.score" : {"$gte" : 5}})</code>, <span class="keep-together">because</span> the author criterion could match a
      different comment than the score criterion. That is, it would return the
      document shown above: it would match <code>"author" :
      "joe"</code> in the first comment and <code>"score" : 6</code> in the second comment.</p><p>To<a data-type="indexterm" data-primary="$elemMatch operator" data-primary-sortas="elemMatch operator" id="idm45882380404136"/> correctly group criteria without needing to specify every
      key, use <code>"$elemMatch"</code>. This vaguely
      named conditional allows you to partially specify criteria to match a
      single embedded document in an array. The correct query looks like
      this:</p><pre id="I_programlisting4_d1e4577" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"comments"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$elemMatch"</code> <code class="o">:</code> 
<code class="p">...</code> <code class="p">{</code><code class="s2">"author"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">,</code> <code class="s2">"score"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$gte"</code> <code class="o">:</code> <code class="mi">5</code><code class="p">}}}})</code></pre><p><code>"$elemMatch"</code> allows you to
      “group” your criteria. As such, it’s only needed when you have more than
      one key you want to match on in an embedded document.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="$where Queries"><div class="sect1" id="sect1_d1e4429"><h1>$where Queries</h1><p>Key/value<a data-type="indexterm" data-primary="queries" data-secondary="$where queries" id="idm45882380388104"/><a data-type="indexterm" data-primary="$where clauses" data-primary-sortas="where clauses" id="idm45882380387064"/> pairs are a fairly expressive way to query, but there are
    some queries that they cannot represent. For queries that cannot be done
    any other way, there are <code>"$where"</code>
    clauses, which allow you to execute arbitrary JavaScript as part of your
    query. This allows you to do (almost) anything within a query. For
    security, use of <code>"$where"</code> clauses
    should be highly restricted or eliminated. End users should never be
    allowed to execute arbitrary <code>"$where"</code>
    clauses.</p><p>The most common case for using <code>"$where"</code> is to compare the values for two keys
    in a document. For instance, suppose we have documents that look like
    this:</p><pre id="I_programlisting4_d1e4606" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"apple"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"banana"</code> <code class="o">:</code> <code class="mi">6</code><code class="p">,</code> <code class="s2">"peach"</code> <code class="o">:</code> <code class="mi">3</code><code class="p">})</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"apple"</code> <code class="o">:</code> <code class="mi">8</code><code class="p">,</code> <code class="s2">"spinach"</code> <code class="o">:</code> <code class="mi">4</code><code class="p">,</code> <code class="s2">"watermelon"</code> <code class="o">:</code> <code class="mi">4</code><code class="p">})</code></pre><p>We’d like to return documents where any two of the fields are equal.
    For example, in the second document, <code>"spinach"</code> and <code>"watermelon"</code> have the same value, so we’d like
    that document returned. It’s unlikely MongoDB will ever have a <code>$</code> conditional for this, so we can use a <code>"$where"</code> clause to do it with JavaScript:</p><pre id="I_programlisting4_d1e4619" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"$where"</code> <code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="p">...</code> <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">current</code> <code class="k">in</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
<code class="p">...</code>     <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">other</code> <code class="k">in</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
<code class="p">...</code>         <code class="k">if</code> <code class="p">(</code><code class="nx">current</code> <code class="o">!=</code> <code class="nx">other</code> <code class="o">&amp;&amp;</code> <code class="k">this</code><code class="p">[</code><code class="nx">current</code><code class="p">]</code> <code class="o">==</code> <code class="k">this</code><code class="p">[</code><code class="nx">other</code><code class="p">])</code> <code class="p">{</code>
<code class="p">...</code>             <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
<code class="p">...</code>         <code class="p">}</code>
<code class="p">...</code>     <code class="p">}</code>
<code class="p">...</code> <code class="p">}</code>
<code class="p">...</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
<code class="p">...</code> <code class="p">}});</code></pre><p>If the function returns <code>true</code>, the
    document will be part of the result set; if it returns <code>false</code>, it won’t be.</p><p><code>"$where"</code> queries should not be
    used unless strictly necessary: they are much slower than regular queries.
    Each document has to be converted from BSON to a JavaScript object and
    then run through the <code>"$where"</code>
    expression. Indexes cannot be used to satisfy a <code>"$where"</code> either. Hence, you should use <code>"$where"</code> only when there is no other way of
    doing the query. You can cut down on the penalty by using other query
    filters in combination with <code>"$where"</code>.
    If possible, an index will be used to filter based on the non-<code>$where</code> clauses; the <code>"$where"</code> expression will be used only to
    fine-tune the results. MongoDB 3.6 added the <code>$expr</code>
    operator which allows the use of aggregation expressions with the MongoDB
    query language. It is faster than <code>$where</code> as it does not
    execute JavaScript and is recommended as a replacement to this operator
    where <span class="keep-together">possible</span>.</p><p>Another way of doing complex queries is to use one of the
    aggregation tools, which are covered in <a data-type="xref" href="ch07.xhtml#chapter_d1e6036">Chapter 7</a>.</p></div></section><section data-type="sect1" data-pdf-bookmark="Cursors"><div class="sect1" id="sect1_d1e4513"><h1>Cursors</h1><p>The<a data-type="indexterm" data-primary="queries" data-secondary="cursors for" data-tertiary="benefits of" id="idm45882380170648"/><a data-type="indexterm" data-primary="cursors" data-secondary="benefits of" id="idm45882380169240"/> database returns results from <code class="function">find</code> using a <em>cursor</em>. The
    client-side implementations of cursors generally allow you to control a
    great deal about the eventual output of a query. You can limit the number
    of results, skip over some number of results, sort results by any
    combination of keys in any direction, and perform a number of other
    powerful operations.</p><p>To<a data-type="indexterm" data-primary="queries" data-secondary="cursors for" data-tertiary="creating" id="idm45882380166280"/><a data-type="indexterm" data-primary="cursors" data-secondary="creating" id="idm45882380164872"/> create a cursor with the shell, put some documents into a
    collection, do a query on them, and assign the results to a local variable
    (variables defined with <code>"var"</code> are
    local). Here, we create a very simple collection and query it, storing the
    results in the <code class="varname">cursor</code> variable:</p><pre id="I_programlisting4_d1e4698" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="k">for</code><code class="p">(</code><code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code><code class="o">&lt;</code><code class="mi">100</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
<code class="p">...</code>     <code class="nx">db</code><code class="p">.</code><code class="nx">collection</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="nx">x</code> <code class="o">:</code> <code class="nx">i</code><code class="p">});</code>
<code class="p">...</code> <code class="p">}</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">cursor</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">collection</code><code class="p">.</code><code class="nx">find</code><code class="p">();</code></pre><p>The advantage of doing this is that you can look at one result at a
    time. If you store the results in a global variable or no variable at all,
    the MongoDB shell will automatically iterate through and display the first
    couple of documents. This is what we’ve been seeing up until this point,
    and it is often the behavior you want for seeing what’s in a collection
    but not doing actual programming with the shell.</p><p>To<a data-type="indexterm" data-primary="queries" data-secondary="cursors for" data-tertiary="iterating through results" id="idm45882380122104"/><a data-type="indexterm" data-primary="cursors" data-secondary="iterating through results" id="idm45882380120888"/> iterate through the results, you can use the <code class="function">next</code> method on the cursor. You can use
    <code class="function">hasNext</code> to check whether there is
    another result. A typical loop through result looks like the
    following:</p><pre id="I_programlisting4_d1e4722" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="k">while</code> <code class="p">(</code><code class="nx">cursor</code><code class="p">.</code><code class="nx">hasNext</code><code class="p">())</code> <code class="p">{</code>
<code class="p">...</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="nx">cursor</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
<code class="p">...</code>     <code class="c1">// do stuff</code>
<code class="p">...</code> <code class="p">}</code></pre><p><code>cursor.hasNext()</code> checks that the
    next result exists, and <code>cursor.next()</code>
    fetches it.</p><p>The <code>cursor</code> class also implements
    JavaScript’s iterator interface, so you can use it in a <code class="function">forEach</code> loop:</p><pre id="I_programlisting4_d1e4742" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">cursor</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">find</code><code class="p">();</code>
<code class="o">&gt;</code> <code class="nx">cursor</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
<code class="p">...</code>     <code class="nx">print</code><code class="p">(</code><code class="nx">x</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
<code class="p">...</code> <code class="p">});</code>
<code class="nx">adam</code>
<code class="nx">matt</code>
<code class="nx">zak</code></pre><p>When you call <code class="function">find</code>, the shell
    does not query the database immediately. It waits until you start
    requesting results to send the query, which allows you to chain additional
    options onto a query before it is performed. Almost every method on a
    <code>cursor</code> object returns the cursor
    itself, so that you can chain options in any order. For instance, all of
    the following are equivalent:</p><pre id="I_programlisting4_d1e4750" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">cursor</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">sort</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">}).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">skip</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">cursor</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">limit</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">sort</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">}).</code><code class="nx">skip</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">cursor</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">skip</code><code class="p">(</code><code class="mi">10</code><code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">sort</code><code class="p">({</code><code class="s2">"x"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">});</code></pre><p>At this point, the query has not been executed yet. All of these
    functions merely build the query. Now, suppose we call the
    following:</p><pre id="I_programlisting4_d1e4754" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">cursor</code><code class="p">.</code><code class="nx">hasNext</code><code class="p">()</code></pre><p>At<a data-type="indexterm" data-primary="queries" data-secondary="cursors for" data-tertiary="sending queries to servers" id="idm45882379843656"/><a data-type="indexterm" data-primary="cursors" data-secondary="sending queries to servers" id="idm45882379871048"/> this point, the query will be sent to the server. The shell
    fetches the first 100 results or first 4 MB of results (whichever is
    smaller) at once so that the next calls to <code class="function">next</code> or <code class="function">hasNext</code> will not have to make trips to the
    server. After the client has run through the first set of results, the
    shell will again contact the database and ask for more results with a
    <code>getMore</code> request. <code>getMore</code> requests basically contain an identifier
    for the cursor and ask the database if there are any more results,
    returning the next batch if there are. This process continues until the
    cursor is exhausted and all results have been returned.</p><section data-type="sect2" data-pdf-bookmark="Limits, Skips, and Sorts"><div class="sect2" id="sect2_d1e4594"><h2>Limits, Skips, and Sorts</h2><p>The<a data-type="indexterm" data-primary="queries" data-secondary="cursors for" data-tertiary="limits, skips, and sorts" id="idm45882379864056"/><a data-type="indexterm" data-primary="cursors" data-secondary="limits, skips, and sort options" id="idm45882379862632"/> most common query options are limiting the number of
      results returned, <a data-type="indexterm" data-primary="skips" data-secondary="skipping query results" id="idm45882379861384"/>skipping a number of results, and sorting. All these
      options must be added before a query is sent to the database.</p><p>To set a limit, chain the <code class="function">limit</code> function onto your call to <code>find</code>. For example, to only return three
      results, use this:</p><pre id="I_programlisting4_d1e4797" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">limit</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code></pre><p>If there are fewer than three documents matching your query in the
      collection, only the number of matching documents will be returned;
      <code class="function">limit</code> sets an upper limit, not a
      lower limit.</p><p><code class="function">skip</code> works similarly to
      <code class="function">limit</code>:</p><pre id="I_programlisting4_d1e4821" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">skip</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code></pre><p>This will skip the first three matching documents and return the
      rest of the matches. If there are fewer than three documents in your
      collection, it will not return any <span class="keep-together">documents</span>.</p><p><code class="function">sort</code> takes an object: a set
      of key/value pairs where the keys are key names and the values are the
      sort directions. The sort direction can be <code>1</code> (ascending) or <code>−1</code> (descending). If multiple keys are given,
      the results will be sorted in that order. For instance, to sort the
      results by <code>"username"</code> ascending and
      <code>"age"</code> descending, we do the
      following:</p><pre id="I_programlisting4_d1e4851" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">sort</code><code class="p">({</code><code class="nx">username</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">age</code> <code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">})</code></pre><p>These three methods can be combined. This is often handy for
      pagination. For example, suppose that you are running an online store
      and someone searches for <em>mp3</em>. If you want 50
      results per page sorted by price from high to low, you can do the
      <span class="keep-together">following</span>:</p><pre id="I_programlisting4_d1e4864" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">stock</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"desc"</code> <code class="o">:</code> <code class="s2">"mp3"</code><code class="p">}).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">50</code><code class="p">).</code><code class="nx">sort</code><code class="p">({</code><code class="s2">"price"</code> <code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">})</code></pre><p>If that person clicks Next Page to see more results, you can
      simply add a skip to the query, which will skip over the first 50
      matches (which the user already saw on page 1):</p><pre id="I_programlisting4_d1e4868" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">stock</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"desc"</code> <code class="o">:</code> <code class="s2">"mp3"</code><code class="p">}).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">50</code><code class="p">).</code><code class="nx">skip</code><code class="p">(</code><code class="mi">50</code><code class="p">).</code><code class="nx">sort</code><code class="p">({</code><code class="s2">"price"</code> <code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">})</code></pre><p>However, large skips are not very performant; there are
      suggestions for how to avoid them in the next section.</p><section data-type="sect3" data-pdf-bookmark="Comparison order"><div class="sect3" id="sect3_d1e4662"><h3>Comparison order</h3><p>MongoDB<a data-type="indexterm" data-primary="data types" data-secondary="comparison order" id="idm45882379651976"/><a data-type="indexterm" data-primary="comparison order" id="idm45882379617944"/> has a hierarchy as to how types compare. Sometimes you
        will have a single key with multiple types: for instance, integers and
        booleans, or strings and nulls. If you do a sort on a key with a mix
        of types, there is a predefined order that they will be sorted in.
        From least to greatest value, this ordering is as follows:</p><ol><li><p>Minimum value</p></li><li><p>Null</p></li><li><p>Numbers (integers, longs, doubles, decimals)</p></li><li><p>Strings</p></li><li><p>Object/document</p></li><li><p>Array</p></li><li><p>Binary data</p></li><li><p>Object ID</p></li><li><p>Boolean</p></li><li><p>Date</p></li><li><p>Timestamp</p></li><li><p>Regular expression</p></li><li><p>Maximum value</p></li></ol></div></section></div></section><section data-type="sect2" data-pdf-bookmark="Avoiding Large Skips"><div class="sect2" id="sect2_d1e4756"><h2>Avoiding Large Skips</h2><p>Using<a data-type="indexterm" data-primary="skips" data-secondary="avoiding large" id="idm45882379609944"/><a data-type="indexterm" data-primary="queries" data-secondary="cursors for" data-tertiary="avoiding large skips" id="idm45882379608808"/><a data-type="indexterm" data-primary="cursors" data-secondary="avoiding large skips" id="idm45882379607432"/> <code class="function">skip</code> for a small
      number of documents is fine. But for a large number of results,
      <code class="function">skip</code> can be slow, since it has to
      find and then discard all the skipped results. Most databases keep more
      metadata in the index to help with skips, but MongoDB does not yet
      support this, so large skips should be avoided. Often you can calculate
      the results of the next query based on the previous one.</p><section data-type="sect3" data-pdf-bookmark="Paginating results without skip"><div class="sect3" id="sect3_d1e4770"><h3>Paginating results without skip</h3><p>The<a data-type="indexterm" data-primary="skips" data-secondary="paginating results without" id="idm45882379603128"/> easiest way to do pagination is to return the first
        page of results using <code>limit</code> and
        then return each subsequent page as an offset from the
        beginning:</p><pre id="I_programlisting4_d1e4965" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="c1">// do not use: slow for large skips</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">page1</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">criteria</code><code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">page2</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">criteria</code><code class="p">).</code><code class="nx">skip</code><code class="p">(</code><code class="mi">100</code><code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">page3</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">criteria</code><code class="p">).</code><code class="nx">skip</code><code class="p">(</code><code class="mi">200</code><code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>
<code class="p">...</code></pre><p>However, depending on your query, you can usually find a way to
        paginate without skips. For example, suppose we want to display
        documents in descending order based on <code>"date"</code>. We can get the first page of results
        with the following:</p><pre id="I_programlisting4_d1e4975" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">page1</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">sort</code><code class="p">({</code><code class="s2">"date"</code> <code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">}).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code></pre><p>Then, assuming the date is unique, we can use the <code>"date"</code> value of the last document as the
        criterion for fetching the next page:</p><pre id="I_programlisting4_d1e4982" data-type="programlisting" data-code-language="javascript"><code class="kd">var</code> <code class="nx">latest</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>

<code class="c1">// display first page</code>
<code class="k">while</code> <code class="p">(</code><code class="nx">page1</code><code class="p">.</code><code class="nx">hasNext</code><code class="p">())</code> <code class="p">{</code>
   <code class="nx">latest</code> <code class="o">=</code> <code class="nx">page1</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
   <code class="nx">display</code><code class="p">(</code><code class="nx">latest</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// get next page</code>
<code class="kd">var</code> <code class="nx">page2</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"date"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$lt"</code> <code class="o">:</code> <code class="nx">latest</code><code class="p">.</code><code class="nx">date</code><code class="p">}});</code>
<code class="nx">page2</code><code class="p">.</code><code class="nx">sort</code><code class="p">({</code><code class="s2">"date"</code> <code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">}).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">100</code><code class="p">);</code></pre><p>Now the query does not need to include a skip.</p></div></section><section data-type="sect3" data-pdf-bookmark="Finding a random document"><div class="sect3" id="sect3_d1e4812"><h3>Finding a random document</h3><p>One<a data-type="indexterm" data-primary="collections" data-secondary="finding random documents in" id="idm45882379362312"/><a data-type="indexterm" data-primary="documents" data-secondary="finding random" id="idm45882379361336"/><a data-type="indexterm" data-primary="skips" data-secondary="finding random documents" id="idm45882379360232"/> fairly common problem is how to get a random document
        from a collection. The naive (and slow) solution is to count the
        number of documents and then do a <code class="function">find</code>, skipping a random number of documents
        between zero and the size of the collection:</p><pre id="I_programlisting4_d1e5004" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="c1">// do not use</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">total</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">count</code><code class="p">()</code>
<code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">random</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code><code class="o">*</code><code class="nx">total</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">find</code><code class="p">().</code><code class="nx">skip</code><code class="p">(</code><code class="nx">random</code><code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code></pre><p>It is actually highly inefficient to get a random element this
        way: you have to do a count (which can be expensive if you are using
        criteria), and skipping large numbers of elements can be
        time-consuming.</p><p>It takes a little forethought, but if you know you’ll be looking
        up a random element in a collection, there’s a much more efficient way
        to do so. The trick is to add an extra random key to each document
        when it is inserted. For instance, if we’re using the shell, we could
        use the <code>Math.random()</code> function
        <a data-type="indexterm" data-primary="Math.random() function" id="idm45882379290552"/>(which creates a<a data-type="indexterm" data-primary="random numbers, creating" id="idm45882379289800"/> random number between 0 and 1):</p><pre id="I_programlisting4_d1e5019" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"joe"</code><code class="p">,</code> <code class="s2">"random"</code> <code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()})</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"john"</code><code class="p">,</code> <code class="s2">"random"</code> <code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()})</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">insertOne</code><code class="p">({</code><code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"jim"</code><code class="p">,</code> <code class="s2">"random"</code> <code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()})</code></pre><p>Now, when we want to find a random document from the collection,
        we can calculate a random number and use that as a query criterion,
        instead of using <code class="function">skip</code>:</p><pre id="I_programlisting4_d1e5026" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">random</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code>
<code class="o">&gt;</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">findOne</code><code class="p">({</code><code class="s2">"random"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$gt"</code> <code class="o">:</code> <code class="nx">random</code><code class="p">}})</code></pre><p>There is a slight chance that <code class="varname">random</code> will be
        greater than any of the <code>"random"</code>
        values in the collection, and no results will be returned. We can
        guard against this by simply returning a document in the other
        direction:</p><pre id="I_programlisting4_d1e5036" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="k">if</code> <code class="p">(</code><code class="nx">result</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
<code class="p">...</code>     <code class="nx">result</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">findOne</code><code class="p">({</code><code class="s2">"random"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$lte"</code> <code class="o">:</code> <code class="nx">random</code><code class="p">}})</code>
<code class="p">...</code> <code class="p">}</code></pre><p>If there aren’t any documents in the collection, this technique
        will end up returning <code>null</code>, which
        makes sense.</p><p>This technique can be used with arbitrarily complex queries;
        just make sure to have an index that includes the random key. For
        example, if we want to find a random plumber in California, we can
        create an index on <code>"profession"</code>,
        <code>"state"</code>, and <span class="keep-together"><code>"random"</code>:</span></p><pre id="I_programlisting4_d1e5055" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">people</code><code class="p">.</code><code class="nx">ensureIndex</code><code class="p">({</code><code class="s2">"profession"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"state"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"random"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">})</code></pre><p>This allows us to quickly find a random result (see <a data-type="xref" href="ch05.xhtml#chapter_d1e5128">Chapter 5</a> for more information on indexing).</p></div></section></div></section><section data-type="sect2" data-pdf-bookmark="Immortal Cursors"><div class="sect2" id="idm45882379363240"><h2>Immortal Cursors</h2><p>There<a data-type="indexterm" data-primary="immortal cursors" id="idm45882379088152"/><a data-type="indexterm" data-primary="queries" data-secondary="cursors for" data-tertiary="immortal cursors" id="idm45882379047816"/><a data-type="indexterm" data-primary="cursors" data-secondary="immortal" id="idm45882379046440"/> are two sides to a cursor: the client-facing cursor and
      the database cursor that the client-side one represents. We have been
      talking about the client-side one up until now, but we are going to take
      a brief look at what’s happening on the server.</p><p>On the server side, a cursor takes up memory and resources. Once a
      cursor runs out of results or the client sends a message telling it to
      die, the database can free the resources it was using. Freeing these
      resources lets the database use them for other things, which is good, so
      we want to make sure that cursors can be freed quickly (within
      reason).</p><p>There are a couple of conditions that can cause the death (and
      subsequent cleanup) of a cursor. First, when a cursor finishes iterating
      through the matching results, it will clean itself up. Another way is
      that, when a cursor goes out of scope on the client side, the drivers
      send the database a special message to let it know that it can kill that
      cursor. Finally, even if the user hasn’t iterated through all the
      results and the cursor is still in scope, after 10 minutes of
      inactivity, a database cursor will automatically “die.” This way, if a
      client crashes or is buggy, MongoDB will not be left with thousands of
      open cursors.</p><p>This “death by timeout” is usually the desired behavior: very few
      applications expect their users to sit around for minutes at a time
      waiting for results. However, sometimes you might know that you need a
      cursor to last for a long time. In that case, many drivers have
      implemented a function called <code class="function">immortal</code>, or a similar mechanism, which tells
      the database not to time out the cursor. If you turn off a cursor’s
      timeout, you must iterate through all of its results or kill it to make
      sure it gets closed. Otherwise, it will sit around in the database
      hogging resources until the server is restarted.</p></div></section></div></section></div></section></div>



  </body></html>