- en: Chapter 4\. Applications and Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [SUNBURST](https://oreil.ly/19FGs) [supply-chain compromise](https://oreil.ly/coa9p)
    was a hostile intrusion of US Government and Fortune-500 networks via malware
    hidden in a legitimately signed, compromised server monitoring agent. The [Cozy
    Bear hacking group](https://oreil.ly/gADiF) used techniques described in this
    chapter to compromise many billion-dollar companies simultaneously. High value
    targets were prioritized by the attackers, so smaller organizations may have escaped
    the potentially devastating consequences of the breach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Organizations targeted by the attackers suffered losses of data and may have
    been used as a springboard for further attacks against their own customers. This
    is the essential risk of a “trusted” supply chain: anybody who consumes something
    you produce becomes a potential target when you are compromised. The established
    trust relationship is exploited, and so malicious software is inadvertently trusted.'
  prefs: []
  type: TYPE_NORMAL
- en: Often vulnerabilities for which an exploit exists don’t have a corresponding
    software patch or workaround. Palo Alto research determined this is the case for
    80% of new, public exploits. With this level of risk exposure for all running
    software, denying malicious actors access to your internal networks is the primary
    line of defense.
  prefs: []
  type: TYPE_NORMAL
- en: The SUNBURST attack infected SolarWinds build pipelines and altered source code
    immediately before it was built, then hid the evidence of tampering and ensured
    the binary was signed by the CI/CD system so consumers would trust it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These techniques were previously unseen on the [Mitre ATT&CK Framework](https://oreil.ly/BV0mN),
    and the attacks compromised networks plundered for military, government, and company
    secrets—all enabled by the initial supply chain attack. Preventing the ignoble,
    crafty Captain Hashjack and their pals from covertly entering the organization’s
    network via any dependencies (libraries, tooling or otherwise) is the job of *supply
    chain security*: protecting our sources.'
  prefs: []
  type: TYPE_NORMAL
- en: '![captain](Images/haku_0000.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter we dive into supply chain attacks by looking at some historical
    issues and how they were exploited, then see how containers can either usefully
    compartmentalize or dangerously exacerbate supply chain risks. In [“Defending
    Against SUNBURST”](#defending_against_sunburst), we’ll ask: could we have secured
    a cloud native system from SUNBURST?'
  prefs: []
  type: TYPE_NORMAL
- en: 'For career criminals like Captain Hashjack, the supply chain provides a fresh
    vector to assault BCTL’s systems: attack by proxy to gain trusted access to your
    systems. This means attacking container software supply chains to gain remote
    control of vulnerable workloads and servers, and daisy-chain exploits and backdoors
    throughout an organization.'
  prefs: []
  type: TYPE_NORMAL
- en: Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unless targeted and mitigated, supply chain attacks are relatively simple:
    they impact trusted parts of our system that we would not normally directly observe,
    like the CI/CD patterns of our suppliers.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a complex problem, as we will discuss in this chapter. As adversarial
    techniques evolve and cloud native systems adapt, you’ll see how the supply chain
    risks shift during development, testing, distribution, and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Threat Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most applications do not come hardened by default, and you need to spend time
    securing them. [OWASP Application Security Verification Standard](https://oreil.ly/5S6Qd)
    provides application security (AppSec) guidance that we will not explore any further,
    except to say: you don’t want to make an attacker’s life easy by running outdated
    or error-ridden software. Rigorous logic and security tests are essential for
    any and all software you run.'
  prefs: []
  type: TYPE_NORMAL
- en: That extends from your developers’ coding style and web application security
    standards, to the supply chain for everything inside the container itself. Engineering
    effort is required to make them secure and ensure they are secure when updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies in the SDLC are especially vulnerable to attack, and give opportunities
    to Captain Hashjack to run some malicious code (the “payload”):'
  prefs: []
  type: TYPE_NORMAL
- en: At installation (package manager hooks, which may be running as root)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During development and test (IDEs, builds, and executing tests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime (local, dev, staging, and production Kubernetes pods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a payload is executing, it may write further code to the filesystem or
    pull malware from the internet. It may search for data on a developer’s laptop,
    a CI server, or production. Any looted credentials form the next phase of the
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'And applications are not the only software at risk: with infrastructure, policy,
    and security defined as code, any scripted or automated point of the system that
    an attacker can infiltrate must be considered, and so is in scope for your threat
    model.'
  prefs: []
  type: TYPE_NORMAL
- en: The Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software supply chains ([Figure 4-1](#web-of-supply-chains)) consider the movement
    of your files: source code, applications, data. They may be plain text, encrypted,
    on a floppy disk, or in the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: Supply chains exist for anything that is built from other things—perhaps something
    that humans ingest (food, medicine), use (a CPU, cars), or interact with (an operating
    system, open source software). Any exchange of goods can be modeled as a supply
    chain, and some supply chains are huge and complex.
  prefs: []
  type: TYPE_NORMAL
- en: '![haku 0401](Images/haku_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. A web of supply chains; adapted from [*https://oreil.ly/r9ndi*](https://oreil.ly/r9ndi)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Each dependency you use is potentially a malicious implant primed to trigger,
    awaiting a spark of execution when it’s run in your systems to deploy its payload.
    Container supply chains are long and may include:'
  prefs: []
  type: TYPE_NORMAL
- en: The base image(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed operating system packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application code and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public Git repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arbitrary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other data that may be added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If malicious code is added to your supply chain at any step, it may be loaded
    into executable memory in a running container in your Kubernetes cluster. This
    is Captain Hashjack’s goal with malicious payloads: sneak bad code into your trusted
    software and use it to launch an attack from inside the perimeter of your organization,
    where you may not have defended your systems as well on the assumption that the
    “perimeter” will keep attackers out.'
  prefs: []
  type: TYPE_NORMAL
- en: Each link of a supply chain has a producer and a consumer. In [Table 4-1](#app-example-supply-chains),
    the CPU chip producer is the manufacturer, and the next consumer is the distributor.
    In practice, there may be multiple producers and consumers at each stage of the
    supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Varied example supply chains
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Farm food | CPU chip | An open source software package | Your organization’s
    servers |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *original producer* | Farmer (seeds, feed, harvester) | Manufacturer (raw
    materials, fab, firmware) | Open source package developer (ingenuity, code) |
    Open source software, original source code built in internal CI/CD |'
  prefs: []
  type: TYPE_TB
- en: '| *(links to)* | Distributor (selling to shops or other distributors) | Distributor
    (selling to shops or other distributors) | Repository maintainer (npm, PyPi, etc.)
    | Signed code artifacts pushed over the network to production-facing registry
    |'
  prefs: []
  type: TYPE_TB
- en: '| *(links to)* | Local food shop | Vendor or local computer shop | Developer
    | Artifacts at rest in registry ready for deployment |'
  prefs: []
  type: TYPE_TB
- en: '| *links to final consumer* | End user | End user | End user | Latest artifacts
    deployed to production systems |'
  prefs: []
  type: TYPE_TB
- en: Any stage in the supply chain that is not under your direct control is liable
    to be attacked ([Figure 4-2](#app-similarity-between-supply-chains)). A compromise
    of any “upstream” stage—for example, one that you consume—may impact you as a
    downstream consumer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an open source software project ([Figure 4-3](#app-open-source-supply-chain-attack))
    may have three contributors (or “trusted producers”) with permission to merge
    external code contributions into the codebase. If one of those contributors’ passwords
    is stolen, an attacker can add their own malicious code to the project. Then,
    when your developers pull that dependency into their codebase, they are running
    the attacker’s hostile code on your internal systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![Similarity between supply chains](Images/haku_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Similarity between supply chains
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Open source supply chain attack](Images/haku_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Open source supply chain attack
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But the compromise doesn’t have to be malicious. As with the [npm `event-stream`
    vulnerability](https://oreil.ly/UCKUv), sometimes it’s something as innocent as
    someone looking to pass on maintainership to an existing and credible maintainer,
    who then goes rogue and inserts their own payload.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this case the vulnerable `event-stream` package was downloaded 12 million
    times, and was depended upon by more than 1,600 other packages. The payload searched
    for “hot cryptocurrency wallets” to steal from developers’ machines. If this had
    stolen SSH and GPG keys instead and used them to propagate the attack further,
    the compromise could have been much wider.
  prefs: []
  type: TYPE_NORMAL
- en: A successful supply chain attack is often difficult to detect, as a consumer
    trusts every upstream producer. If a single producer is compromised, the attacker
    may target individual downstream consumers or pick only the highest-value targets.
  prefs: []
  type: TYPE_NORMAL
- en: Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our purposes, the supply chains we consume are for software and hardware.
    In a cloud environment, a datacenter’s physical and network security is managed
    by the provider, but it is your responsibility to secure your use of the system.
    This means we have high confidence that the hardware we are using is safe. Our
    usage of it—the software we install and its behavior—is where our supply chain
    risk starts.
  prefs: []
  type: TYPE_NORMAL
- en: Software is built from many other pieces of software. Unlike CPU manufacturing,
    where inert components are assembled into a structure, software is more like a
    symbiotic population of cooperating organisms. Each component may be autonomous
    and choosing to cooperate (CLI tools, servers, OS) or useless unless used in a
    certain way (`glibc`, linked libraries, most application dependencies). Any software
    can be autonomous or cooperative, and it is impossible to conclusively prove which
    it is at any moment in time. This means test code (unit tests, acceptance tests)
    may still contain malicious code, which would start to explore the Continuous
    Integration (CI) build environment or the developer’s machine it is executed on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This poses a conundrum: if malicious code can be hidden in any part of a system,
    how can we conclusively say that the entire system is secure?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As Liz Rice points out in [*Container Security*](https://oreil.ly/uzvnv) (O’Reilly):'
  prefs: []
  type: TYPE_NORMAL
- en: It’s very likely that a deployment of any non-trivial software will include
    some vulnerabilities, and there is a risk that systems will be attacked through
    them. To manage this risk, you need to be able to identify which vulnerabilities
    are present and assess their severity, prioritize them, and have processes in
    place to fix or mitigate these issues.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Software supply chain management is difficult. It requires you to accept some
    level of risk and make sure that reasonable measures are in place to detect dangerous
    software before it is executed inside your systems. This risk is balanced with
    diminishing rewards—builds get more expensive and more difficult to maintain with
    each control, and there are much higher expenses for each step.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Full confidence in your supply chain is almost impossible without the full spectrum
    of controls detailed in the CNCF Security Technical Advisory Group paper on software
    supply chain security (addressed later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: As ever, you assume that no control is entirely effective and run intrusion
    detection on the build machines as the last line of defense against targeted or
    widespread zero-day vulnerabilities that may have included SUNBURST, Shellshock,
    or DirtyCOW, (see [“Architecting Containerized Apps for Resilience”](#architecting-apps-resilience)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at how to secure a software supply chain, starting with minimum
    viable cloud native security: scanning for CVEs.'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for CVEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CVEs are published for known vulnerabilities, and it is critical that you do
    not give Captain Hashjack’s gruesome crew easy access to your systems by ignoring
    or failing to patch them. Open source software lists its dependencies in its build
    instructions (*pom.xml*, *package.json*, *go.mod*, *requirements.txt*, *Gemfile*,
    etc.), which gives us visibility of its composition. This means you should scan
    those dependencies for CVEs using tools like [trivy](https://oreil.ly/wLyXO).
    This is the lowest-hanging fruit in the defense of the supply chain and should
    be considered a part of the minimum viable container security processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'trivy can scan code at rest in various places:'
  prefs: []
  type: TYPE_NORMAL
- en: In a container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reports on known vulnerabilities. Scanning for CVEs is minimum viable security
    for shipping code to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command scans the local directory and finds the `gomod` and `npm` dependency
    files, reporting on their contents (output was edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications_and_supply_chain_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Run trivy against the filesystem (`fs`) in the current working directory (`.`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications_and_supply_chain_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning has found two high-severity vulnerabilities in *infra/build/go.sum*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_applications_and_supply_chain_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The *infra/api/code/package-lock.json* has no vulnerabilities detected.
  prefs: []
  type: TYPE_NORMAL
- en: So we can scan code in our supply chain to see if it’s got vulnerable dependencies.
    But what about the code itself?
  prefs: []
  type: TYPE_NORMAL
- en: Ingesting Open Source Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Securely ingesting code is hard: how can we prove that a container image was
    built from the same source we can see on GitHub? Or that a compiled application
    is the same open source code we’ve read, without rebuilding it from source?'
  prefs: []
  type: TYPE_NORMAL
- en: While this is hard with open source, closed source presents even greater challenges.
  prefs: []
  type: TYPE_NORMAL
- en: How do we establish and verify trust with our suppliers?
  prefs: []
  type: TYPE_NORMAL
- en: 'Much to the Captain’s dismay, this problem has been studied since 1983, when
    Ken Thompson introduced [“Reflections on Trusting Trust”](https://oreil.ly/NEMQR):'
  prefs: []
  type: TYPE_NORMAL
- en: To what extent should one trust a statement that a program is free of Trojan
    horses? Perhaps it is more important to trust the people who wrote the software.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The question of trust underpins many human interactions, and is the foundation
    of the original internet. Thompson continues:'
  prefs: []
  type: TYPE_NORMAL
- en: The moral is obvious. You can’t trust code that you did not totally create yourself.
    (Especially code from companies that employ people like me.) No amount of source-level
    verification or scrutiny will protect you from using untrusted code… As the level
    of program gets lower, these bugs will be harder and harder to detect. A well
    installed microcode bug will be almost impossible to detect.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These philosophical questions of security affect your organization’s supply
    chain, as well as your customers. The core problem remains unsolved and difficult
    to correct entirely.
  prefs: []
  type: TYPE_NORMAL
- en: While BCTL’s traditional relationship with software was defined previously as
    a consumer, when you started public open source on GitHub, you became a producer
    too. This distinction exists in most enterprise organizations today, as most have
    not adapted to their new producer responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Which Producers Do We Trust?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To secure a supply chain we must have trust in our producers. These are parties
    outside of your organization and they may include:'
  prefs: []
  type: TYPE_NORMAL
- en: Security providers such as the root Certificate Authorities to authenticate
    other servers on a network, and DNSSEC to return the right address for our transmission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptographic algorithms and implementations like GPG, RSA, and Diffie-Hellman
    to secure our data in transit and at rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware enablers like OS, CPU/firmware, and driver vendors to provide us low-level
    hardware interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application developers and package maintainers to prevent malicious code installation
    via their distributed packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source and community-run teams, organizations, and standards bodies, to
    grow our technologies and communities in the common interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendors, distributors, and sales agents to not install backdoors or malware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everybody—not to have exploitable bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may be wondering if it’s ever possible to secure this entirely, and the
    answer is no. Nothing is ever entirely secure, but everything can be hardened
    so that it’s less appealing to all except the most skilled of threat actors. It’s
    all about balancing layers of security controls that might include:'
  prefs: []
  type: TYPE_NORMAL
- en: Physical second factors (2FA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPG signing (e.g., Yubikeys)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebAuthn](https://webauthn.io), FIDO2 Project, and physical security tokens
    (e.g., RSA)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Human redundancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authors cannot merge their own PRs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a second person to sign-off critical processes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplication by running the same process twice in different environments and
    comparing results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[reprotest](https://oreil.ly/c5Gm0) and the [Reproducible Builds](https://oreil.ly/VsONj)
    initiative (see examples in [Debian](https://oreil.ly/rwWoH) and [Arch Linux](https://oreil.ly/mgVwV))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CNCF Security Technical Advisory Group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CNCF Security Technical Advisory Group (*tag-security*) published a definitive
    [software supply chain security paper](https://oreil.ly/rEEd7). For an in-depth
    and immersive view of the field, it is strongly recommended reading:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It evaluates many of the available tools and defines four key principles for
    supply chain security and steps for each, including:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Trust: Every step in a supply chain should be “trustworthy” due to a combination
    of cryptographic attestation and verification.'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Automation: Automation is critical to supply chain security and can significantly
    reduce the possibility of human error and configuration drift.'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clarity: The build environments used in a supply chain should be clearly defined,
    with limited scope.'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Mutual Authentication: All entities operating in the supply chain environment
    must be required to mutually authenticate using hardened authentication mechanisms
    with regular key rotation.'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Software Supply Chain Best Practices, tag-security
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It then covers the main parts of supply chain security:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code (what your developers write)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Materials (dependencies of the app and its environment)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build pipelines (to test and build your app)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Artifacts (your app plus test evidence and signatures)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployments (how your consumers access your app)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your supply chain is compromised at any one of these points, your consumers
    may be compromised too.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting Containerized Apps for Resilience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should adopt an adversarial mindset when architecting and building systems
    so security considerations are baked in. Part of that mindset includes learning
    about historical vulnerabilities in order to defend yourself against similar attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The granular security policy of a container is an opportunity to reconsider
    applications as “compromised-by-default,” and configure them so they’re better
    protected against zero-day or unpatched vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One such historical vulnerability was DirtyCOW: a race condition in the Linux
    kernel’s privileged memory mapping code that allowed unprivileged local users
    to escalate to root.'
  prefs: []
  type: TYPE_NORMAL
- en: The bug allowed an attacker to gain a root shell on the host, and was exploitable
    from inside a container that didn’t block `ptrace`. One of the authors live demoed
    [preventing a DirtyCOW container breakout](https://oreil.ly/zYCJp) with an AppArmor
    profile that blocked the `ptrace` system call. There’s an example Vagrantfile
    to reproduce the bug in [Scott Coulton’s repo](https://oreil.ly/Fvu4v).
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Trojans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tools like [dockerscan](https://oreil.ly/rlLnJ) can *trojanize* a container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'trojanize: inject a reverse shell into a docker image'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: dockerscan
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We go into more detail on attacking software and libraries in [“Captain Hashjack
    Attacks a Supply Chain”](#captain_hashjack_attacks_a_supply_chain).
  prefs: []
  type: TYPE_NORMAL
- en: 'To trojanize a `webserver` image is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications_and_supply_chain_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Export a valid `webserver` tarball from a container image.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications_and_supply_chain_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Trojanize the image tarball.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_applications_and_supply_chain_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the attacker’s shellcatcher IP and port.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_applications_and_supply_chain_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Write to an output tarball called `trojanized-webserver`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s this sort of attack that you should scan your container images to detect
    and prevent. As `dockerscan` uses an `LD_PRELOAD` attack that most container IDS
    and scanning should detect.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis of software involves running it in a malware lab environment
    where it is unable to communicate with the internet and is observed for signs
    of C2 (“command and control”), automated attacks, or unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Malware such as WannaCry (a cryptolocking worm) includes a disabling “killswitch”
    DNS record (sometimes secretly used by malware authors to remotely terminate attacks).
    In some cases, this is used to delay the deployment of the malware until a convenient
    time for the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Together an artifact and its runtime behavior should form a picture of the trustworthiness
    of a single package, however there are workarounds. Logic bombs (behavior only
    executed on certain conditions) make this difficult to detect unless the logic
    is known. For example, SUNBURST closely emulated the valid HTTP calls of the software
    it infected. Even tracing a compromised application with tools such as `sysdig`
    does not clearly surface this type of attack.
  prefs: []
  type: TYPE_NORMAL
- en: Captain Hashjack Attacks a Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![captain](Images/haku_0000.png)'
  prefs: []
  type: TYPE_IMG
- en: You know BCTL hasn’t put enough effort into supply chain security. Open source
    ingestion isn’t regulated, and developers ignore the results of CVE scanning in
    the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Dread Pirate Hashjack dusts off their keyboard and starts the attack. The goal
    is to add malicious code to a container image, an open source package, or an operating
    system application that your team will run in production.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Captain Hashjack is looking to attack the rest of your systems
    from a foothold in an initial pod attack. When the malicious code runs inside
    your pods it will connect back to a server that the Captain controls. That connection
    will relay attack commands to run inside that pod in your cluster so the pirates
    can have a look around, as shown in [Figure 4-4](#app-remote-access-supply-chain).
  prefs: []
  type: TYPE_NORMAL
- en: 'From this position of remote control, Captain Hashjack might:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate other infrastructure around the cluster like datastores and internally
    facing software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to escalate privilege and take over your nodes or cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mine cryptocurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the pods or nodes to a botnet, use them as servers, or “watering holes”
    to spread malware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other unintended misuse of your noncompromised systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Establishing remote access with a supply chain compromise](Images/haku_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Establishing remote access with a supply chain compromise
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The [Open Source Security Foundation (OpenSSF)](https://openssf.org)’s [SLSA
    Framework](https://slsa.dev) (“Supply-chain Levels for Software Artifacts,” or
    “Salsa”) works on the principle that “It can take years to achieve the ideal security
    state, and intermediate milestones are important.” It defines a graded approach
    to adopting supply chain security for your builds (see [Table 4-2](#table-openssf)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. OpenSSF SLSA levels
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | Description | Requirements |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | No guarantees | SLSA 0 represents the lack of any SLSA level. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Provenance checks to help evaluate risks and security | The build process
    must be fully scripted/automated and generate provenance. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Further checks against the origin of the software | Requires using version
    control and a hosted build service that generates authenticated provenance. This
    results in tamper resistance of the build service. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Extra resistance to specific classes of threats | The source and build
    platforms meet specific standards to guarantee the auditability of the source
    and the integrity of the provenance respectively. Advanced protection including
    security controls on host, non-falsifiable provenance, and prevention of cross-build
    contamination. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Highest levels of confidence and trust | Strict auditability and reliability
    checks. Requires two-person review of all changes and a hermetic, reproducible
    build process. |'
  prefs: []
  type: TYPE_TB
- en: Let’s move on to the aftermath.
  prefs: []
  type: TYPE_NORMAL
- en: Post-Compromise Persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before attackers do something that may be detected by the defender, they look
    to establish persistence, or a backdoor, so they can, for example, enter the system
    if they get detected or unceremoniously ejected, as their method of intrusion
    is patched.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When containers restart, filesystem changes are lost, so persistence is not
    possible just by writing to the container filesystem. Dropping a “back door” or
    other persistence mechanism in Kubernetes requires the attacker to use other parts
    of Kubernetes or the `kubelet` on the host, as anything they write inside the
    container is lost when it restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you were compromised, Captain Hashjack now has various options
    available. None are possible in a well-configured container without excessive
    RBAC privilege, although this doesn’t stop the attacker exlpoiting the same path
    again and looking to pivot to another part of your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible persistence in Kubernetes can be gained by:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a static privileged pod through the `kubelet`’s static manifests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a privileged container directly using the container runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an admission controller or CronJob with a backdoor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a shadow API server with custom authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a mutating webhook that injects a backdoor container to some new pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding worker or control plane nodes to a botnet or C2 network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing container lifecycle `postStart` and `preStop` hooks to add backdoors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing liveness probes to exec a backdoor in the target container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other mechanism that runs code under the attacker’s control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risks to Your Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once they have established persistence, attacks may become more bold and dangerous:'
  prefs: []
  type: TYPE_NORMAL
- en: Exfiltrating data, credentials, and cryptocurrency wallets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivoting further into the system via other pods, the control plane, worker nodes,
    or cloud account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptojacking compute resources (e.g., [mining Monero in Docker containers](https://oreil.ly/0E9iw))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escalating privilege in the same pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptolocking data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary supply chain attack on target’s published artifacts/software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move on to container images.
  prefs: []
  type: TYPE_NORMAL
- en: Container Image Build Supply Chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your developers have written code that needs to be built and run in production.
    CI/CD automation enables the building and deployment of artifacts, and is a traditionally
    appealing target due to less security rigor than the production systems it deploys
    to.
  prefs: []
  type: TYPE_NORMAL
- en: To address this insecurity, the Software Factory pattern is gaining adoption
    as a model for building the pipelines to build software.
  prefs: []
  type: TYPE_NORMAL
- en: Software Factories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Software Factory is a form of CI/CD that focuses on self-replication. It is
    a build system that can deploy copies of itself, or other parts of the system,
    as new CI/CD pipelines. This focus on replication ensures build systems are repeatable,
    easy to deploy, and easy to replace. They also assist iteration and development
    of the build infrastructure itself, which makes securing these types of systems
    much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Use of this pattern requires slick DevOps skills, continuous integration, and
    build automation practices, and is ideal for containers due to their compartmentalised
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The [DoD Software Factory pattern](https://oreil.ly/HqNz4) defines the Department
    of Defense’s best practice ideals for building secure, large-scale cloud or on-prem
    cloud native infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Container images built from, and used to build, the DoD Software Factory are
    publicly available at [IronBank GitLab](https://oreil.ly/3NvDj).
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic signing of build steps and artifacts can increase trust in the
    system, and can be revalidated with an admission controller such as [portieris](https://oreil.ly/mY9eu)
    for Notary and [Kritis](https://oreil.ly/R33SG) for Grafeas.
  prefs: []
  type: TYPE_NORMAL
- en: Tekton is a Kubernetes-based build system that runs build stages in containers.
    It runs Kubernetes Custom Resources that define build steps in pods, and [Tekton
    Chains](https://oreil.ly/ZHMmw) can use in-toto to sign the pod’s workspace files.
    [Jenkins X](https://jenkins-x.io) is built on top of it and extends its feature
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Dan Lorenc](https://oreil.ly/av7UQ) elegantly summarised [the supply chain
    signing landscape](https://oreil.ly/WUVHD).'
  prefs: []
  type: TYPE_NORMAL
- en: Blessed Image Factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some software factory pipelines are used to build and scan your base images,
    in the same way virtual machine images are built: on a cadence, and in response
    to releases of the underlying image. An image build is untrusted if any of the
    inputs to the build are not trusted. An adversary can attack a container build
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: Malicious commands in a `RUN` directive that can attack the host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host’s non-loopback network ports/services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumeration of other network entities (cloud provider, build infrastructure,
    network routes to production)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious `FROM` image that has access to build Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious image that has `ONBUILD` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker-in-docker and mounted container runtime sockets that can lead to host
    breakout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero-days in container runtime or kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network attack surface (host, ports exposed by other builds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To defend from malicious builds, you should begin with static analysis using
    [Hadolint](https://oreil.ly/M8GDi) and [conftest](https://oreil.ly/8mKFd) to enforce
    your policy. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Conftest wraps OPA and runs Rego language policies (see [“Open Policy Agent”](ch08.xhtml#open-policy-agent)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the Dockerfile conforms to policy, scan the container build workspace with
    tools like trivy. You can also build and then scan, although this is slightly
    riskier if an attack spawns a reverse shell into the build environment.
  prefs: []
  type: TYPE_NORMAL
- en: If the container’s scan is safe, you can perform a build.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adding a hardening stage to the Dockerfile helps to remove unnecessary files
    and binaries that an attacker may try to exploit, and is detailed in [DoD’s Container
    Hardening Guide](https://oreil.ly/7lVbG).
  prefs: []
  type: TYPE_NORMAL
- en: 'Protecting the build’s network is important, otherwise malicious code in a
    container build can pull further dependencies and malicious code from the internet.
    Security controls of varying difficulty include:'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing network egress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolating from the host’s kernel with a VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the build process as a nonroot user or in a user namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing `RUN` commands as a nonroot user in container filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share nothing nonessential with the build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an application is being packaged for deployment it must be built into a
    container image. Depending on your choice of programming language and application
    dependencies, your container will use one of the base images from [Table 4-3](Images/#app-table-base-images).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Types of base images
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of base image | How it’s built | Contents of image filesystem | Example
    container image |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Scratch | Add one (or more) static binary to an empty container root filesystem.
    | Nothing at all except `/my-binary` (it’s the only thing in `/` directory), and
    any added dependencies (often CA bundles, locale information, static files for
    the application). | [Static Golang or Rust binary examples](https://oreil.ly/7VW3k)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Distroless | Add one (or more) static binary to a container that has locale
    and CA information only (no Bash, Busybox, etc.). | Nothing except `my-app`, `/etc/locale`,
    TLS pubkeys, (plus any dependencies, as per scratch), etc. | [Static Golang or
    Rust binary examples](https://oreil.ly/RZc07) |'
  prefs: []
  type: TYPE_TB
- en: '| Hardened | Add nonstatic binary or dynamic application to a minimal container,
    then remove all nonessential files and harden filesystem. | Reduced Linux userspace:
    `glibc`, `/code/my-app.py`, `/code/deps`, `/bin/python`, Python libs, static files
    for the application. | Web servers, nonstatic or complex applications, [IronBank
    examples](https://oreil.ly/tYOPP) |'
  prefs: []
  type: TYPE_TB
- en: '| Vanilla | No security precautions, possibly dangerous. | Standard Linux userspace.
    Root user. Possibly anything and everything required to install, build, compile,
    or debug applications. This offers many opportunities for attack. | [NGINX](https://oreil.ly/0M1HH),
    [raesene/alpine-nettools](https://oreil.ly/nGOby), [nicolaka/netshoot](https://oreil.ly/60byc)
    |'
  prefs: []
  type: TYPE_TB
- en: Minimal containers minimize a container’s attack surface to a hostile process
    or RCE, reducing an adversary to very advanced tricks like [return-oriented programming](https://oreil.ly/Kr4Kn)
    that are beyond most attackers’ capabilities. Organized criminals like Dread Pirate
    Hashjack may be able to use these programming techniques, but exploiting vulnerabilities
    like these are valuable and perhaps more likely to be sold to an exploit broker
    than used in the field, potentially reducing their value if discovered.
  prefs: []
  type: TYPE_NORMAL
- en: Because statically compiled binaries ship their own system call library, they
    do not need `glibc` or another userspace kernel interface, and can exist with
    only themselves on the filesystem (see [Figure 4-5](#app-scratch-vs-glibc)).
  prefs: []
  type: TYPE_NORMAL
- en: '![app-scratch-vs-glibc](Images/haku_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. How scratch containers and `glibc` talk to the kernel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s step back a bit now: we need to take stock of our supply chain.'
  prefs: []
  type: TYPE_NORMAL
- en: The State of Your Container Supply Chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications in containers bundle all their userspace dependencies with them,
    and this allows us to inspect the composition of an application. The blast radius
    of a compromised container is less than a bare metal server (the container provides
    security configuration around the namespaces), but exacerbated by the highly parallelised
    nature of a Kubernetes workload deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Secure third-party code ingestion requires trust and verification of upstream
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes components (OS, containers, config) are a supply chain risk in themselves.
    Kubernetes distributions that pull unsigned artifacts from object storage (such
    as S3 and GCS) have no way of validating that the developers meant them to run
    those containers. Any containers with “escape-friendly configuration” (disabled
    security features, a lack of hardening, unmonitored and unsecured, etc.) are viable
    assets for attack.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true of supporting applications (logging/monitoring, observability,
    IDS)—anything that is installed as root, that is not hardened, or indeed not architected
    for resilience to compromise, is potentially subjected to swashbuckling attacks
    from hostile forces.
  prefs: []
  type: TYPE_NORMAL
- en: Third-Party Code Risk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the image build your application installs dependencies into the container,
    and the same dependencies are often installed onto developers’ machines. This
    requires the secure ingestion of third party and open source code.
  prefs: []
  type: TYPE_NORMAL
- en: You value your data security, so running any code from the internet without
    first verifying it could be unsafe. Adversaries like Captain Hashjack may have
    left a backdoor to enable remote access to any system that runs their malicious
    code. You should consider the risk of such an attack as sufficiently low before
    you allow the software inside your organization’s corporate network and production
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: One method to scan ingested code is shown in [Figure 4-6](#app-third-party-code-ingestion).
    Containers (and other code) that originate outside your organization are pulled
    from the internet onto a temporary virtual machine. All software signatures and
    checksums are verified, binaries and source code are scanned for CVEs and malware,
    and the artifact is packaged and signed for consumption in an internal registry.
  prefs: []
  type: TYPE_NORMAL
- en: '![Third-party code ingestion (detailed)](Images/haku_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Third-party code ingestion
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example a container pulled from a public registry is scanned for CVEs,
    e.g., tagged for the internal domain, then signed with Notary and pushed to an
    internal registry, where it can be consumed by Kubernetes build systems and your
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: When ingesting third-party code you should be cognizant of who has released
    it and/or signed the package, the dependencies it uses itself, how long it has
    been published for, and how it scores in your internal static analysis pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Aqua’s [Dynamic Threat Analysis for Containers](https://oreil.ly/u1Rc8) runs
    potentially hostile containers in a sandbox to observe their behavior for signs
    of malice.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning third-party code before it enters your network protects you from some
    supply chain compromises, but targeted attacks may be harder to defend against
    as they may not use known CVEs or malware. In these cases you may want to observe
    it running as part of your validation.
  prefs: []
  type: TYPE_NORMAL
- en: Software Bills of Materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a software bill of materials (SBOM) for a container image is easy with
    tools like [syft](https://oreil.ly/Z7j5T), which supports APK, DEB, RPM, Ruby
    Bundles, Python Wheel/Egg/requirements.txt, JavaScript NPM/Yarn, Java JAR/EAR/WAR,
    Jenkins plugi-ns JPI/HPI, and Go modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can generate output in the [CycloneDX](https://cyclonedx.org) XM format.
    Here it is running on a container with a single static binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications_and_supply_chain_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The vendor of the tool used to create the SBOM.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications_and_supply_chain_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The tool that’s created the SBOM.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_applications_and_supply_chain_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The tool version.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_applications_and_supply_chain_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The supply chain component being scanned and its type of container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_applications_and_supply_chain_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The container’s name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_applications_and_supply_chain_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The container’s version, a SHA256 content hash, or digest.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bill of materials is just a packing list for your software artifacts. Running
    against the `alpine:base` image, we see an SBOM with software licenses (output
    edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These verifiable artifacts can be signed by supply chain security tools like
    `cosign`, `in-toto`, and `notary`. When consumers demand that suppliers produce
    verifiable artifacts and bills of materials from their own audited, compliant,
    and secure software factories, the supply chain will become harder to compromise
    for the casual attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An attack on source code prior to building an artifact or generating an SBOM
    from it is still trusted, even if it is actually malicious, as with SUNBURST.
    This is why the build infrastructure must be secured.
  prefs: []
  type: TYPE_NORMAL
- en: Human Identity and GPG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signing Git commits with GNU Privacy Guard (GPG) signatures identifies the owner
    of they key as having trusted the commit at the time of signature. This is useful
    to increase trust, but requires public key infrastructure (PKI), which is notoriously
    difficult to secure entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Signing data is easy—the verification is hard.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dan Lorenc
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The problem with PKI is the risk of breach of the PKI infrastructure. Somebody
    is always responsible for ensuring the public key infrastructure (the servers
    that host individuals’ trusted public keys) is not compromised and is reporting
    correct data. If PKI is compromised, an entire organization may be exploited as
    attackers add keys they control to trusted users.
  prefs: []
  type: TYPE_NORMAL
- en: Signing Builds and Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to trust the output of your build infrastructure, you need to sign
    it so consumers can verify that it came from you. Signing metadata like SBOMs
    also allows consumers to detect vulnerabilities where the code is deployed in
    their systems. The following tools help by signing your artifacts, containers,
    or metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Notary v1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notary is the signing system built into Docker, and implements The Update Framework
    (TUF). It’s used for shipping software updates, but wasn’t enabled in Kubernetes
    as it requires all images to be signed, or it won’t run them. [portieris](https://oreil.ly/beFeG)
    implements Notary as an admission controller for Kubernetes instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[Notary v2](https://oreil.ly/ZfhGk) supports creating multiple signatures for
    OCI Artifacts and storing them in OCI image registries.'
  prefs: []
  type: TYPE_NORMAL
- en: sigstore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: sigstore is a public software signing and transparency service, which can sign
    containers with [cosign](https://oreil.ly/0mtGF) and store the signatures in an
    OCI repository, something missing from Notary v1\. As anything can be stored in
    a container (e.g., binaries, tarballs, scripts, or configuration files), `cosign`
    is a general artifact signing tool with OCI as its packaging format.
  prefs: []
  type: TYPE_NORMAL
- en: '`sigstore` provides free certificates and tooling to automate and verify signatures
    of source code.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[sigstore release announcement](https://oreil.ly/rQEeS)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Similar to Certificate Transparency, it has an append-only cryptographic ledger
    of events (called [rekor](https://oreil.ly/hkMGk)), and each event has signed
    metadata about a software release as shown in [Figure 4-7](#suppy-chain-sigstore).
    Finally, it supports “a free Root-CA for code signing certs, that is, issuing
    certificates based on an OIDC email address” in [fulcio](https://oreil.ly/lS8WB).
    Together, these tools dramatically improve the capabilities of the supply chain
    security landscape.
  prefs: []
  type: TYPE_NORMAL
- en: It is designed for open source software, and is under rapid development. There
    are integrations for TUF and in-toto, hardware-based tokens are supported, and
    it’s compatible with most OCI registries.
  prefs: []
  type: TYPE_NORMAL
- en: '`sigstore`’s cosign is used to [sign the Distroless base image family](https://oreil.ly/28hQ9).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing sigstore manifests in the sigstore manifests into the rekor transparency
    log](Images/haku_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Storing sigstore manifests in the rekor transparency log
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: in-toto and TUF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [in-toto toolchain](https://in-toto.io) checksums and signs software builds—the
    steps and output of CI/CD pipelines. This provides transparent metadata about
    software build processes. This increases the trust a consumer has that an artifact
    was built from a specific source code revision.
  prefs: []
  type: TYPE_NORMAL
- en: in-toto link metadata (describing transitions between build stages and signing
    metadata about them) can be stored by tools like rekor and Grafeas, to be validated
    by consumers at time of use.
  prefs: []
  type: TYPE_NORMAL
- en: The in-toto signature ensures that a trusted party (e.g., the build server)
    has built and signed these objects. However, there is no guarantee that the third
    party’s keys have not been compromised—the only solution for this is to run parallel,
    isolated build environments and cross-check the cryptographic signatures. This
    is done with reproducible builds (in Debian, Arch Linux, and PyPi) to offer resilience
    to build tool compromise.
  prefs: []
  type: TYPE_NORMAL
- en: This is only possible if the CI and builds themselves are deterministic (no
    side effects of the build) and reproducible (the same artifacts are created by
    the source code). Relying on temporal or stochastic behaviors (time and randomness)
    will yield unreproducible binaries, as they are affected by timestamps in logfiles,
    or random seeds that affect compilation.
  prefs: []
  type: TYPE_NORMAL
- en: When using in-toto, an organization increases trust in their pipelines and artifacts,
    as there are verifiable signatures for everything. However, without an objective
    threat model or security assessment of the original build infrastructure, this
    doesn’t protect supply chains with a single build server that may have been compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Producers using in-toto with consumers that verfiy signatures makes an attacker’s
    life harder. They must fully compromise the signing infrastructure (as with SolarWinds).
  prefs: []
  type: TYPE_NORMAL
- en: GCP Binary Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GCP Binary Authorization feature allows signing of images and admission
    control to prevent unsigned, out of date, or vulnerable images from reaching production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validating expected signatures at runtime provides enforcement of pipeline
    controls: is this image free from known vulnerabilities, or has a list of “accepted”
    vulnerabilities? Did it pass the automated acceptance tests in the pipeline? Did
    it come from the build pipeline at all?'
  prefs: []
  type: TYPE_NORMAL
- en: Grafeas is used to store metadata from image scanning reports, and Kritis is
    an admission controller that verifies signatures and the absence of CVEs against
    the images.
  prefs: []
  type: TYPE_NORMAL
- en: Grafeas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grafeas is a metadata store for pipeline metadata like vulnerability scans and
    test reports. Information about a container is recorded against its digest, which
    can be used to report on vulnerabilities of an organization’s images and ensure
    that build stages have successfully passed. Grafeas can also store in-toto link
    metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s also worth considering your operating system base image, and the location
    your Kubernetes control plane containers and packages are installed from.
  prefs: []
  type: TYPE_NORMAL
- en: Some distributions have historically modified and repackaged Kubernetes, and
    this introduces further supply chain risk of malicious code injection. Decide
    how you’ll handle this based upon your initial threat model, and architect systems
    and networks for compromise resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Operator Privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes Operators are designed to reduce human error by automating Kubernetes
    configuration, and reactive to events. They interact with Kubernetes and whatever
    other resources are under the operator’s control. Those resources may be in a
    single namespace, multiple namespaces, or outside of Kubernetes. This means they
    are often highly privileged to enable this complex automation, and so bring a
    level of risk.
  prefs: []
  type: TYPE_NORMAL
- en: An Operator-based supply chain attack might allow Captain Hashjack to discreetly
    deploy their malicious workloads by misusing RBAC, and a rogue resource could
    go completely undetected. While this attack is not yet widely seen, it has the
    potential to compromise a great number of clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must appraise and security-test third-party Operators before trusting them:
    write tests for their RBAC permissions so you are alerted if they change, and
    ensure an Operator’s `securityContext` configuration is suitable for the workload.'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking Higher Up the Supply Chain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To attack BCTL, Captain Hashjack may consider attacking the organizations that
    supply its software, such as operating systems, vendors, and open source packages.
    Your open source libraries may also have vulnerabilities, the most devastating
    of which has historically been an Apache Struts RCE, CVE-2017-5638.
  prefs: []
  type: TYPE_NORMAL
- en: Trusted open source libraries may have been “backdoored” (such as NPM’s [`event-stream`
    package](https://oreil.ly/7ZRj5)) or may be removed from the registry while in
    active use, such as [`left-pad`](https://oreil.ly/mMv29) (although registries
    now look to avoid this by preventing “unpublishing” packages).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: CVE-2017-5638 affected Apache Struts, a Java web framework.
  prefs: []
  type: TYPE_NORMAL
- en: The server didn’t parse `Content-Type` HTTP headers correctly, which [allowed
    any commands](https://oreil.ly/aZfEL) to be executed in the process namespace
    as the web server’s user.
  prefs: []
  type: TYPE_NORMAL
- en: Struts 2 has a history of critical security bugs,[3] many tied to its use of
    OGNL technology;[4] some vulnerabilities can lead to arbitrary code execution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Wikipedia](https://oreil.ly/t6Cfe)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code distributed by vendors can be compromised, as [Codecov was](https://oreil.ly/9SHDZ).
    An error in its container image creation process allowed an attacker to modify
    a Bash uploader script run by customers to start builds. This attack compromised
    build Secrets that may then have been used against other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The number of organizations using Codecov was significant. [Searching for Git
    repos with grep.app](https://oreil.ly/kDBdD) showed there were over 9,200 results
    in the top 500,000 public Git repos. [GitHub](https://oreil.ly/GLP8D) shows 397,518
    code results at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: Poorly written code that fails to handle untrusted user input or internal errors
    may have remotely exploitable vulnerabilities. Application security is responsible
    for preventing this easy access to your systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The industry-recognised moniker for this is “shift left,” which means you should
    run static and dynamic analysis of the code your developers write as they write
    it: add automated tooling to the IDE, provide a local security testing workflow,
    run configuration tests before deployment, and generally don’t leave security
    considerations to the last possible moment as has been traditional in software.'
  prefs: []
  type: TYPE_NORMAL
- en: Types of Supply Chain Attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TAG Security’s [Catalog of Supply Chain Compromises](https://oreil.ly/zwxo9)
    lists attacks affecting packages with millions of weekly downloads across various
    application dependency repositories and vendors, and hundreds of millions of total
    installations.
  prefs: []
  type: TYPE_NORMAL
- en: The combined downloads, including both benign and malicious versions, for the
    most popular malicious packages (`event-stream`—190 million, `eslint-scope`—442
    million, `bootstrap-sass`—30 million, and `rest-client`—114 million) sum to 776
    million.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[“Towards Measuring Supply Chain Attacks on Package Managers for Interpreted
    Languages”](https://oreil.ly/uHWBT)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the quoted paper, the authors identify four actors in the open source supply
    chain:'
  prefs: []
  type: TYPE_NORMAL
- en: Registry Maintainers (RMs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package Maintainers (PMs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers (Devs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-users (Users)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those with consumers have a responsibility to verify the code they pass to their
    customers, and a duty to provide verifiable metadata to build confidence in the
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a lot to defend from to ensure that Users receive a trusted artifact
    ([Table 4-4](#table-attack-public-infra)):'
  prefs: []
  type: TYPE_NORMAL
- en: Source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dev tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious maintainer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negligence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watering-hole attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Registry maintainers should guard publishing infrastructure from typosquatters:
    individuals that register a package that looks similar to a widely deployed package.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4\. Examples of attacking publishing infrastructure
  prefs: []
  type: TYPE_NORMAL
- en: '| Attack | Package name | Typosquatted name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Typosquatting | event-stream | eventstream |'
  prefs: []
  type: TYPE_TB
- en: '| Different account | user/package | usr/package, user_/package |'
  prefs: []
  type: TYPE_TB
- en: '| Combosquatting | package | package-2, package-ng |'
  prefs: []
  type: TYPE_TB
- en: '| Account takeover | user/package | user/package—no change as the user has
    been compromised by to the attacker |'
  prefs: []
  type: TYPE_TB
- en: '| Social engineering | user/package | user/package—no change as the user has
    willingly given repository access to the attacker |'
  prefs: []
  type: TYPE_TB
- en: As [Figure 4-8](#app-trust-supply-chain-paper) demonstrates, the supply chain
    of a package manager holds many risks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simplified relationships of stakeholders and threats in the package manager
    ecosystem](Images/haku_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8\. Simplified relationships of stakeholders and threats in the package
    manager ecosystem (source: [“Towards Measuring Supply Chain Attacks on Package
    Managers for Interpreted Languages”](https://oreil.ly/uHWBT))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Open Source Ingestion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This attention to detail may become exhausting when applied to every package
    and quickly becomes impractical at scale. This is where a web of trust between
    producers and consumers alleviates some of the burden of double-checking the proofs
    at every link in the chain. However, nothing can be fully trusted, and regular
    reverification of code is necessary to account for newly announced CVEs or zero-days.
  prefs: []
  type: TYPE_NORMAL
- en: In “Towards Measuring Supply Chain Attacks on Package Managers for Interpreted
    Languages”, the authors identify relevant issues as listed in [Table 4-5](#table-oss-ingestion).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-5\. Heuristic rules derived from existing supply chain attacks and other
    malware studies
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Metadata | The package name is similar to popular ones in the same registry.The
    package name is the same as popular packages in other registries, but the authors
    are different.The package depends on or shares authors with known malware.The
    package has older versions released around the time as known malware.The package
    contains Windows PE files or Linux ELF files. |'
  prefs: []
  type: TYPE_TB
- en: '| Static | The package has customized installation logic.The package adds network,
    process, or code generation APIs in recently released versions.The package has
    flows from filesystem sources to network sinks.The package has flows from network
    sources to code generation or process sinks. |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic | The package contacts unexpected IPs or domains, where expected
    ones are official registries and code hosting services.The package reads from
    sensitive file locations such as */etc/shadow, /home/<user>/.ssh, /home/<user>/.aws*.The
    package writes to sensitive file locations such as */usr/bin, /etc/sudoers, /home/<user>/.ssh/authorized_keys*.The
    package spawns unexpected processes, where expected ones are initialized to registry
    clients (e.g., pip). |'
  prefs: []
  type: TYPE_TB
- en: 'The paper summarises that:'
  prefs: []
  type: TYPE_NORMAL
- en: Typosquatting and account compromise are low-cost to an attacker, and are the
    most widely exploited attack vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stealing data and dropping backdoors are the most common malicious post-exploit
    behaviors, suggesting wide consumer targeting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20% of identified malwares have persisted in package managers for over 400 days
    and have more than 1K downloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New techniques include code obfuscation, multistage payloads, and logic bombs
    to evade detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, packages with lower numbers of installations are unlikely to act
    quickly on a reported compromise as [Figure 4-9](#app-attacks-persistence-supply-chain)
    demonstrates. It could be that the developers are not paid to support these open
    source packages. Creating incentives for these maintainers with well-written patches
    and timely assistance merging them, or financial support for handling reports
    from a bug bounty program, are effective ways to decrease vulnerabilities in popular
    but rarely maintained packages.
  prefs: []
  type: TYPE_NORMAL
- en: '![haku 0409](Images/haku_0409.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9\. Correlation between number of persistence days and number of downloads
    (R&R = Reported and Removed; R&I = Reported and Investigating) (source: [“Towards
    Measuring Supply Chain Attacks on Package Managers for Interpreted Languages”](https://oreil.ly/0aNss))'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Application Vulnerability Throughout the SDLC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Software Development Lifecycle (SDLC) is an application’s journey from a
    glint in a developer’s eye, to its secure build and deployment on production systems.
  prefs: []
  type: TYPE_NORMAL
- en: As applications progress from development to production they have a varying
    risk profile, as shown [Table 4-6](#app-dep-vuln-order).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-6\. Application vulnerabilities throughout the SDLC
  prefs: []
  type: TYPE_NORMAL
- en: '| System lifecycle stage | Higher risk | Lower risk |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Development to production deployment | Application code (changes frequently)
    | Application libraries, operating system packages |'
  prefs: []
  type: TYPE_TB
- en: '| Established production deployment to decommissioning | Slowly decaying application
    libraries and operating system packages | Application code (changes less frequently)
    |'
  prefs: []
  type: TYPE_TB
- en: 'The risk profile of an application running in production changes as its lifespan
    lengthens, as its software becomes progressively more out-of-date. This is known
    as “reverse uptime”—the correlation between risk of an application’s compromise
    and the time since its deployment (e.g., the date of the container’s build). An
    average of reverse uptime in an organization could also be considered “mean time
    to …”:'
  prefs: []
  type: TYPE_NORMAL
- en: Compromise (application has a remotely exploitable vulnerability)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure (application no longer works with the updated system or external APIs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update (change application code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch (to update dependencies versions explicitly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebuild (to pull new server dependencies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defending Against SUNBURST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So would the techniques in this chapter save you from a SUNBURST-like attack?
    Let’s look at how it worked.
  prefs: []
  type: TYPE_NORMAL
- en: The attackers gained access to the SolarWinds systems on 4th September 2019
    ([Figure 4-10](#sunspot-timeline)). This might have happened perhaps through a
    spear-phishing email attack that allowed further escalation into SolarWind’s systems
    or through some software misconfiguration they found in build infrastructure or
    internet-facing servers.
  prefs: []
  type: TYPE_NORMAL
- en: '![haku 0410](Images/haku_0410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. SUNSPOT timeline
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The threat actors stayed hidden for a week, then started testing the SUNSPOT
    injection code that would eventually compromise the SolarWinds product. This phase
    progressed quietly for two months.
  prefs: []
  type: TYPE_NORMAL
- en: Internal detection may have discovered the attackers here, however build infrastructure
    is rarely subjected to the same level of security scrutiny, intrusion detection,
    and monitoring as production systems. This is despite it delivering code to production
    or customers. This is something we can address using our more granular security
    controls around containers. Of course, a backdoor straight into a host system
    remains difficult to detect unless intrusion detection is running on the host,
    which may be noisy on shared build nodes that necessarily run many jobs for its
    consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Almost six months after the initial compromise of the build infrastructure,
    the SUNSPOT malware was deployed. A month later, the infamous SolarWinds Hotfix
    5 DLL containing the malicious implant was made available to customers, and once
    the threat actor confirmed that customers were infected, it removed its malware
    from the build VMs.
  prefs: []
  type: TYPE_NORMAL
- en: It was a further six months before the customer infections were identified.
  prefs: []
  type: TYPE_NORMAL
- en: This SUNSPOT malware changed source code immediately before it was compiled
    and immediately back to its original form afterwards, as shown in [Figure 4-11](#sunspot-malware).
    This required observing the filesystem and changing its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '![SUNSPOT Malware](Images/haku_0411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. SUNSPOT malware
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A build-stage signing tool that verifies its inputs and outputs (as in-toto
    does) then invokes a subprocess to perform a build step may be immune to this
    variant of the attack, although it may turn security into a race condition between
    the in-toto hash function and the malware that modifies the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that if an attacker has control of your build environment, they
    can potentially modify any files in it. Although this is bad, they cannot regenerate
    signatures made outside the build: this is why your cryptographically signed artifacts
    are safer than unsigned binary blobs or Git code. Tampering of signed or checksummed
    artifacts can be detected because attackers are unlikely to have the private keys
    to, for example, sign tampered data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SUNSPOT changed the files that were about to be compiled. In a container build,
    the same problem exists: the local filesystem must be trusted. Signing the inputs
    and validating outputs goes some way to mitigating this attack, but a motivated
    attacker with full control of a build system may be impossible to disambiguate
    from build activity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may not be possible to entirely protect a build system without a complete
    implementation of all supply chain security recommendations. Your organization’s
    ultimate risk appetite should be used to determine how much effort you wish to
    expend protecting this vital, vulnerable part of your system: for example, critical
    infrastructure projects may wish to fully audit the hardware and software they
    receive, root chains of trust in hardware modules wherever possible, and strictly
    regulate the employees permitted to interact with build systems. For most organizations,
    this will be deeply impractical.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Nixpkgs](https://oreil.ly/nojb6) (utilized in NixOS) [bootstraps deterministically](https://oreil.ly/Rd1WB)
    from a small collection of tools. This is perhaps the ultimate in reproducible
    builds, with some useful security side effects; it allows end-to-end trust and
    reproducibility for all images built from it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Trustix](https://oreil.ly/flKAf), another Nix project, compares build outputs
    against a Merkle tree log across multiple untrusted build servers to determine
    if a build has been compromised.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So these recommendations might not truly prevent supply chain compromise like
    SUNBURST, but they can protect some of the attack vectors and reduce your total
    risk exposure. To protect your build system:'
  prefs: []
  type: TYPE_NORMAL
- en: Give developers root access to integration and testing environments, *not* build
    and packaging systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use ephemeral build infrastructure and protect builds from cache poisoning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate and distribute SBOMs so consumers can validate the artifacts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run intrusion detection on build servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan open source libraries and operating system packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create reproducible builds on distributed infrastructure and compare the results
    to detect tampering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run hermetic, self-contained builds that only use what’s made available to them
    (instead of calling out to other systems or the internet), and avoid decision
    logic in build scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep builds simple and easy to reason about, and security review and scan the
    build scripts like any other software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Supply chain attacks are difficult to defend completely. Malicious software
    on public container registries is often detected rather than prevented, with the
    same for application libraries, and potential insecurity is part of the reality
    of using any third-party software.
  prefs: []
  type: TYPE_NORMAL
- en: The [SLSA Framework](https://slsa.dev) suggests the milestones to achieve in
    order to secure your supply chain, assuming your build infrastructure is already
    secure! The [Software Supply Chain Security paper](https://oreil.ly/8qXmY) details
    concrete patterns and practices for Source Code, Materials, Build Pipelines, Artifacts,
    and Deployments, to guide you on your supply chain security voyage.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning container images and Git repositories for published CVEs is a cloud
    native application’s minimal viable security. If you assume all workloads are
    potentially hostile, your container security context and configuration should
    be tuned to match the workload’s sensitivity. Container `seccomp` and LSM profiles
    should always be configured to defend against new, undefined behavior or system
    calls from a freshly compromised dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Sign your build artifacts with cosign, Notary, and in-toto during CI/CD, then
    validate their signatures whenever they are consumed. Distribute SBOMs so consumers
    can verify your dependency chain for new vulnerabilities. While these measures
    only contribute to wider supply chain security coverage, they frustrate attackers
    and decrease BCTL’s risk of falling prey to drive-by container pirates.
  prefs: []
  type: TYPE_NORMAL
