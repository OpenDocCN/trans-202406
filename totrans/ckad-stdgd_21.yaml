- en: Chapter 21\. Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Using a Pod’s IP Address for Network Communication”](ch05.xhtml#pod_network_communication),
    we learned that you can communicate with a Pod by its IP address. A restart of
    a Pod will automatically assign a new virtual cluster IP address. Therefore, other
    parts of your system cannot rely on the Pod’s IP address if they need to talk
    to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Building a microservices architecture, where each of the components runs in
    its own Pod with the need to communicate with each other through a stable network
    interface, requires a different primitive, the Service.
  prefs: []
  type: TYPE_NORMAL
- en: The Service implements an abstraction layer on top of Pods, assigning a fixed
    virtual IP fronting all the Pods with matching labels, and that virtual IP is
    called Cluster IP. This chapter will focus on the ins and outs of Services, and
    most importantly the exposure of Pods inside and outside of the cluster based
    on their declared type.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a Service in minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing Services of type `NodePort` and `LoadBalancer` in minikube requires
    special handling. Refer to the [documentation](https://minikube.sigs.k8s.io/docs/handbook/accessing/#getting-the-nodeport-using-the-service-command)
    for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a nutshell, Services provide discoverable names and load balancing to a set
    of Pods. The Service remains agnostic from IP addresses with the help of the Kubernetes
    DNS control-plane component, an aspect we’ll discuss in [“Discovering the Service
    by DNS lookup”](Images/#discovering_service_by_dns_lookup). Similar to a Deployment,
    the Service determines the Pods it works on with the help of label selection.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 21-1](#service_traffic_routing) illustrates the functionality. Pod
    1 receives traffic as its assigned label matches with the label selection defined
    in the Service. Pod 2 does not receive traffic as it defines a nonmatching label.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2101](Images/ckd2_2101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-1\. Service traffic routing based on label selection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that it is possible to create a Service without a label selector to support
    other scenarios. Refer to the relevant [Kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Services and Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services are a complementary concept to Deployments. Services route network
    traffic to a set of Pods, and Deployments manage a set of Pods, the replicas.
    While you can use both concepts in isolation, it is recommended to use Deployments
    and Services together. The primary reason is the ability to scale the number of
    replicas and at the same time being able to expose an endpoint to funnel network
    traffic to those Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Service Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Service defines a type. The type is responsible for exposing the Service
    inside and/or outside of the cluster. [Table 21-1](#service_types) lists the Service
    types relevant to the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Table 21-1\. Service types
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`ClusterIP`](#service_type_clusterip) | Exposes the Service on a cluster-internal
    IP. Reachable only from within the cluster. Kubernetes uses a round-robin algorithm
    to distribute traffic evenly among the targeted Pods. |'
  prefs: []
  type: TYPE_TB
- en: '| [`NodePort`](#service_type_nodeport) | Exposes the Service on each node’s
    IP address at a static port. Accessible from outside of the cluster. The Service
    type does not provide any load balancing across multiple nodes. |'
  prefs: []
  type: TYPE_TB
- en: '| [`Load` `Balancer`](#service_type_loadbalancer) | Exposes the Service externally
    using a cloud provider’s load balancer. |'
  prefs: []
  type: TYPE_TB
- en: Other Service types, e.g. `ExternalName` or the headless Service, can be defined;
    however, we’ll not address them in this book as they are not within the scope
    of the exam. For more information, refer to the [Kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/service/).
  prefs: []
  type: TYPE_NORMAL
- en: Service type inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Service types just mentioned, `ClusterIP`, `NodePort`, and `LoadBalancer`,
    make a Service accessible with different levels of exposure. It’s imperative to
    understand that those Service types also build on top of each other. [Figure 21-2](#service_type_layers)
    shows the relationship between different Service types.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2102](Images/ckd2_2102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-2\. Network accessibility characteristics for Service types
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For example, creating a Service of type `NodePort` means that the Service will
    bear the network accessibility characteristics of a `ClusterIP` Service type as
    well. In turn, a `NodePort` Service is accessible from within and from outside
    of the cluster. This chapter demonstrates each Service type by example. You will
    find references to the inherited exposure behavior in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: When to use which Service type?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building a microservices architecture, the question arises which Service
    type to choose to implement certain use cases. We briefly discuss this question
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The `ClusterIP` Service type is suitable for use cases that call for exposing
    a microservice to other Pods within the cluster. Say you have a frontend microservice
    that needs to connect to one or many backend microservices. To properly implement
    the scenario, you’d stand up a `ClusterIP` Service that routes traffic to the
    backend Pods. The frontend Pods would then talk to that Service.
  prefs: []
  type: TYPE_NORMAL
- en: The `NodePort` Service type is often mentioned as a way to expose an application
    to consumers external to the cluster. Consumers will have to know the node’s IP
    address and the statically assigned port to connect to the Service. That’s problematic
    for multiple reasons. First, the node port is usually allocated dynamically. Therefore,
    you won’t typically know it in advance. Second, providing the node’s IP address
    will funnel the network traffic only through a single node so you will not have
    load balancing at your disposal. Finally, by opening a publicly available node
    port, you are at risk of increasing the attack surface of your cluster. For all
    these reasons, a `NodePort` Service is primarily used for development or testing
    purposes, and less so in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: The `LoadBalancer` Service type makes the application available to outside consumers
    through an external IP address provided by an external load balancer. Network
    traffic will be distributed across multiple nodes in the cluster. This solution
    works great for production environments, but keep in mind that every provisioned
    load balancer will accrue costs and can lead to an expensive infrastructure bill.
    A more cost-effective solution is the use of an Ingress, discussed in [Chapter 22](ch22.xhtml#ingresses).
  prefs: []
  type: TYPE_NORMAL
- en: Port Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Service uses label selection to determine the set of Pods to forward traffic
    to. Successful routing of network traffic depends on the port mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 21-3](#service_port_mapping) shows a Service that accepts incoming
    traffic on port 80\. That’s the port defined by the attribute `spec.ports[].port`
    in the manifest. Any incoming traffic is then routed toward the target port, represented
    by `spec.ports[].targetPort`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2103](Images/ckd2_2103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-3\. Service port mapping
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The target port is the same port as defined by the container with `spec.containers[].ports[].containerPort`
    running inside the label-selected Pod. In this example, that’s port 8080\. The
    selected Pod(s) will receive traffic only if the Service’s target port and the
    container port match.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create Services in a variety of ways, some of which are more appropriate
    for the exam as they provide a fast turnaround. Let’s discuss the imperative approach
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Service needs to select a Pod by a matching label. The Pod created by the
    following `run` command is called `echoserver`, which exposes the application
    on the container port 8080\. Internally, it automatically assigns the label key-value
    pair `run=echoserver` to the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a Service object using the `create service` command. Make sure
    to provide the Service type as a mandatory argument. Here we are using the type
    `clusterip`. The command-line option `--tcp` specifies the port mapping. Port
    80 exposes the Service to incoming network traffic. Port 8080 targets the container
    port exposed by the Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'An even faster workflow of creating a Pod and Service together can be achieved
    with a `run` command and the `--expose` option. The following command creates
    both objects in one swoop while establishing the proper label selection. This
    command-line option is a good choice during the exam to save time if you are asked
    to create a Pod and a Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s actually more common to use a Deployment and Service that work together.
    The following set of commands creates a Deployment with five replicas and then
    uses the `expose deployment` command to instantiate the Service object. The port
    mapping can be provided with the options `--port` and `--target-port`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 21-1](#service_manifest) shows the representation of a Service in
    the form of a YAML manifest. The Service declares the key-value `app=echoserver`
    for label selection and defines the port mapping from 80 to 8080.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-1\. A Service defined by a YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_services_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Selects all Pods with the given label assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_services_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines incoming and outgoing ports of the Service. The outgoing port needs
    to match the container port of the selected Pods.
  prefs: []
  type: TYPE_NORMAL
- en: The Service YAML manifest shown does not assign an explicit type. A Service
    object that does not specify a value for the attribute `spec.type` will default
    to `ClusterIP` upon creation.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing all Services presents a table view that includes the Service type,
    the cluster IP address, an optional external IP address, and the incoming port(s).
    Here, you can see the output for the `echoserver` Pod we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes assigns a cluster IP address given that the Service type is `ClusterIP`.
    An external IP address is not available for this Service type. The Service is
    accessible on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Service Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may want to drill into the details of a Service for troubleshooting purposes.
    That might be the case if the incoming traffic to a Service isn’t routed properly
    to the set of Pods you expect to handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe service` command renders valuable information about the configuration
    of a Service. The configuration relevant to troubleshooting a Service is the value
    of the fields Selector, IP, Port, TargetPort, and Endpoints. A common source of
    misconfiguration is incorrect label selection and port assignment. Make sure that
    the selected labels are actually available in the Pods intended to route traffic
    to and that the target port of the Service matches the exposed container port
    of the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the output of the following `describe` command. It’s the details
    for a Service created for five Pods controlled by a Deployment. The Endpoints
    attribute lists a range of endpoints, one for each of the Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An endpoint is a resolvable network endpoint, which serves as the virtual IP
    address and container port of a Pod. If a Service does not render any endpoints
    then you are likely dealing with a misconfiguration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes represents endpoints by a dedicated primitive that you can query
    for. The Endpoint object is created at the same time you instantiate the Service
    object. The following command lists the endpoints for the Service named `echoserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the endpoints give away the full list of IP addresses and ports
    combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The ClusterIP Service Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ClusterIP` is the default Service type. It exposes the Service on a cluster-internal
    IP address. That means the Service can be accessed only from a Pod running inside
    of the cluster and not from outside of the cluster (e.g., if you were to make
    a call to the Service from your local machine). [Figure 21-4](#service_clusterip)
    illustrates the accessibility of a Service with type `ClusterIP`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2104](Images/ckd2_2104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-4\. Accessibility of a Service with the type `ClusterIP`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating and Inspecting the Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a Pod and a corresponding Service to demonstrate the runtime
    behavior of the `ClusterIP` Service type. The Pod named `echoserver` exposes the
    container port 8080 and specifies the label `app=echoserver`. The Service defines
    port 5005 for incoming traffic, which is forwarded to outgoing port 8080\. The
    label selection matches the Pod we set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the live object with the command `kubectl get service echoserver
    -o yaml` will the render the assigned cluster IP address. [Example 21-2](#service_clusterip2)
    shows a abbreviated version of the Service runtime representation.
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-2\. A ClusterIP Service object at runtime
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_services_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The Service type set to `ClusterIP`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_services_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The cluster IP address assigned to the Service at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cluster IP address that makes the Service available in this example is
    `10.96.254.0`. Listing the Service object is an alternative way to render the
    information we need to make a call to the Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we’ll try to make a call to the Service.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can access the Service using a combination of the cluster IP address and
    the incoming port: 10.96.254.0:5005\. Making a request from any other machine
    residing outside of the cluster will fail, as illustrated by the following `wget`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the Service from a Pod from within the cluster properly routes the
    request to the Pod matching the label selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Apart from using the cluster IP address and the port, you can also discover
    a Service by DNS name and environment variables available to containers.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the Service by DNS lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes registers every Service by its name with the help of its DNS service
    named CoreDNS. Internally, CoreDNS will store the Service name as a hostname and
    maps it to the cluster IP address. Accessing a Service by its DNS name instead
    of an IP address is much more convenient and expressive when building microservice
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the correct service discovery by running a Pod in the same namespace
    that makes a call to the Service by using its hostname and incoming port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not uncommon to make a call from a Pod to a Service that lives in a different
    namespace. Referencing just the hostname of the Service does not work across namespaces.
    You need to append the namespace as well. The following makes a call from a Pod
    in the `other` namespace to the Service in the `default` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The full hostname for a Service is `echoserver.default.svc.cluster.local`. The
    string `svc` describes the type of resource we are communicating with. CoreDNS
    uses the default value `cluster.local` as a domain name (which is configurable
    if you want to change it). You do not have to spell out the full hostname when
    communicating with a Service.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the Service by environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find it easier to use the Service connection information directly from
    the application running in a Pod. The kubelet makes the cluster IP address and
    port for every active Service available as environment variables. The naming convention
    for Service-related environments variable are `<SERVICE_NAME>_SERVICE_HOST` and
    `<SERVICE_NAME>_SERVICE_PORT`.
  prefs: []
  type: TYPE_NORMAL
- en: Availability of Service environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you create the Service before instantiating the Pod. Otherwise, those
    environment variables won’t be populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check on the actual key-value pairs by listing the environment variables
    of the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The name of the Service, `echoserver`, does not include any special characters.
    That’s why the conversion to the environment variable key is easy; the Service
    name was simply upper-cased to conform to environment variable naming conventions.
    Any special characters (such as dashes) in the Service name will be replaced by
    underscore characters. You need to make sure that the Service has been created
    before starting a Pod if you want those environment variables populated.
  prefs: []
  type: TYPE_NORMAL
- en: The NodePort Service Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declaring a Service with type `NodePort` exposes access through the node’s IP
    address and can be resolved from outside of the Kubernetes cluster. The node’s
    IP address can be reached in combination with a port number in the range of 30000
    and 32767 (also called the node port), assigned automatically upon the creation
    of the Service. [Figure 21-5](#service_nodeport) illustrates the routing of traffic
    to Pods via a `NodePort`-type Service.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2105](Images/ckd2_2105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-5\. Accessibility of a Service with the type `NodePort`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The node port is opened on every node in the cluster, and its value is global
    and unique at the cluster-scope level. To avoid port conflicts, it’s best to not
    define the exact node port and to let Kubernetes find an available port.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Inspecting the Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next two commands create a Pod and a Service of type `NodePort`. The only
    difference here is that `nodeport` is provided instead of `clusterip` as a command-line
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The runtime representation of the Service object is shown in [Example 21-3](#service_nodeport2).
    It’s important to point out that the node port will be assigned automatically.
    Keep in mind `NodePort` (capital *N*) is the Service type, whereas `nodePort`
    (lowercase *n*) is the key for the value.
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-3\. A NodePort Service object at runtime
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_services_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The Service type set to `NodePort`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_services_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The statically-assigned node port that makes the Service accessible from outside
    of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Service is created, you can list it. You will find that the port representation
    contains the statically assigned port that makes the Service accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this output, the node port is 30158 (identifiable by the separating colon).
    The incoming port 5005 is still available for the purpose of resolving the Service
    from within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From within the cluster, you can still access the Service using the cluster
    IP address and port number. This Service displays exactly the same behavior as
    if it were of type `ClusterIP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From outside of the cluster, you need to use the IP address of any worker node
    in the cluster and the statically assigned port. One way to determine the worker
    node’s IP address is by rendering the node details. Another option is to use the
    `status.hostIP` attribute value of a Pod, which is the IP address of the worker
    node the Pod runs on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The node IP address here is `192.168.64.15`. It can be used to call the Service
    from outside of the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The LoadBalancer Service Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last Service type to discuss in this book is the `LoadBalancer`. This Service
    type provisions an external load balancer, primarily available to Kubernetes cloud
    providers, which exposes a single IP address to distribute incoming requests to
    the cluster nodes. The implementation of the load balancing strategy (e.g., round
    robin) is up to the cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancers for on-premises Kubernetes clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes does not offer a native load balancer solution for on-premises clusters.
    Cloud providers are in charge of providing an appropriate implementation. The
    [MetalLB project](https://metallb.universe.tf/) aims to fill the gap.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 21-6](#service_loadbalancer) shows an architectural overview of the
    `LoadBalancer` Service type.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2106](Images/ckd2_2106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-6\. Accessibility of a Service with the type `LoadBalancer`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see from the illustration, the load balancer routes traffic between
    different nodes, as long as the targeted Pods fulfill the requested label selection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Inspecting the Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a Service as a load balancer, set the type to `LoadBalancer` in the
    manifest or by using the `create service loadbalancer` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The runtime characteristics of a LoadBalancer Service type look similar to the
    ones provided by the NodePort Service type. The main difference is that the external
    IP address column has a value, as shown in [Example 21-4](#service_loadbalancer2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-4\. A LoadBalancer Service object at runtime
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_services_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The Service type set to `LoadBalancer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_services_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The external IP address assigned to the Service at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing the Service renders the external IP address, which is `10.109.76.157`,
    as demonstrated by this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Given that the external load balancer needs to be provisioned by the cloud provider,
    it may take a little time until the external IP address becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To call the Service from outside of the cluster, use the external IP address
    and its incoming port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As discussed, a `LoadBalancer` Service is also accessible in the same way as
    you would access a `ClusterIP` or `NodePort` Service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes assigns a unique IP address for every Pod in the cluster. Pods can
    communicate with each other using that IP address; however, you cannot rely on
    the IP address to be stable over time. That’s why Kubernetes provides the Service
    resource type.
  prefs: []
  type: TYPE_NORMAL
- en: A Service forwards network traffic to a set of Pods based on label selection
    and port mappings. Every Service needs to assign a type that determines how the
    Service becomes accessible from within or outside of the cluster. The Service
    types relevant to the exam are `ClusterIP`, `NodePort`, and `LoadBalancer`. CoreDNS,
    the DNS server for Kubernetes, allows Pods to access the Service by hostname from
    the same and other namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the purpose of a Service
  prefs: []
  type: TYPE_NORMAL
- en: Pod-to-Pod communication via their IP addresses doesn’t guarantee a stable network
    interface over time. A restart of the Pod will lease a new virtual IP address.
    The purpose of a Service is to provide that stable network interface so that you
    can operate complex microservice architecture that runs in a Kubernetes cluster.
    In most cases, Pods call a Service by hostname. The hostname is provided by the
    DNS server named CoreDNS running as a Pod in the `kube-system` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Practice how to access a Service for each type
  prefs: []
  type: TYPE_NORMAL
- en: The exam expects you to understand the differences between the Service types
    `ClusterIP`, `NodePort`, and `LoadBalancer`. Depending on the assigned type, a
    Service becomes accessible from inside the cluster or from outside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Work through Service troubleshooting scenarios
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to get the configuration of a Service wrong. Any misconfiguration
    won’t allow network traffic to reach the set of Pod it was intended for. Common
    misconfigurations include incorrect label selection and port assignments. The
    `kubectl get endpoints` command will give you an idea which Pods a Service can
    route traffic to.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_017.xhtml#appendix_a_services).
  prefs: []
  type: TYPE_NORMAL
- en: Create a Service named `myapp` of type `ClusterIP` that exposes port 80 and
    maps to the target port 80.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Deployment named `myapp` that creates 1 replica running the image `nginx:1.23.4-alpine`.
    Expose the container port 80\. Scale the Deployment to 2 replicas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a temporary Pod using the image `busybox:1.36.1` and execute a `wget`
    command against the IP of the service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the service type to `NodePort` so that the Pods can be reached from outside
    of the cluster. Execute a `wget` command against the service from outside of the
    cluster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Kate is a developer in charge of implementing a web-based application stack.
    She is not familiar with Kubernetes, and asked if you could help out. The relevant
    objects have been created; however, connection to the application cannot be established
    from within the cluster. Help Kate with fixing the configuration of her YAML manifests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch21/troubleshooting* of the checked-out GitHub
    repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    Create the objects from the YAML manifest *setup.yaml*. Inspect the objects in
    the namespace `y72`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a temporary Pod using the image `busybox:1.36.1` in the namespace `y72`.
    The container command should make a `wget` call to the Service `web-app`. The
    `wget` call will not be able to establish a successful connection to the Service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identify the root cause for the connection issue and fix it. Verify the correct
    behavior by repeating the previous step. The `wget` call should return a successful
    response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
