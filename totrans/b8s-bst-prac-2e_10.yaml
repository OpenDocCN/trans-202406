- en: Chapter 10\. Pod and Container Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to pod security via the Kubernetes API, you have two main options
    at your disposal: Pod Security Admission and RuntimeClass. In this chapter, we
    review the purpose and use of each API and provide best practices for their use.'
  prefs: []
  type: TYPE_NORMAL
- en: Pod Security Admission Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This cluster-wide resource creates a single place to define and manage all the
    security-sensitive fields found in pod specifications. Prior to the creation of
    the Pod Security Admission resource, cluster administrators and/or users used
    PodSecurityPolicy, which was complex and could be challenging to set up correctly.
    Before PodSecurityPolicy, users would need to independently define individual
    `SecurityContext` settings for each pod or Deployment in their workloads or enable
    bespoke admission controllers on the cluster to enforce some aspects of pod security.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Pod Security Admission controller replaced the beta PodSecurityPolicy API
    starting with Kubernetes 1.22\. PodSecurityPolicy was removed in Kubernetes 1.25\.
    Pod Security Admission provides a simplified API for securing pods, but it does
    not provide complete feature parity with PodSecurityPolicy. For that you will
    need to install a more complete policy solution like the [Gatekeeper](https://oreil.ly/0lVJP)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Pod Security Admission was developed to address this complexity and make it
    fairly straightforward for a cluster administrator to secure pods on their cluster.
    While it is markedly less complicated than other solutions, Pod Security Admission
    also has significant limitations in that it has coarse-grained permissions that
    are applied at the namespace level. Though you can exempt specific users or runtime
    classes from policy enforcement, you cannot enable different levels of security
    for different pods or users within a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these limitations, many enterprises or administrators running multitenant
    clusters will likely need to implement a policy solution like the [Gatekeeper](https://oreil.ly/0lVJP)
    project. But especially for many smaller single-tenant clusters, Pod Security
    Admission control may be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Pod Security Admission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your cluster is Kubernetes 1.22 or newer, Pod Security Admission is likely
    to be enabled. You can check the version of your cluster using the `kubectl version`
    command. If you are running on an older version of Kubernetes, we recommend updating
    since such older versions are no longer actively supported by the Kubernetes project,
    which puts you at risk for unpatched security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Proceed with caution when enabling Pod Security Admission control on existing
    clusters because it’s potentially workload blocking if adequate preparation isn’t
    done at the outset. Consider starting with the `warn` and `audit` enforcement
    modes to ensure that your policy works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Pod Security levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pod Security Admission controller simplifies security configuration by implementing
    three different policy levels for administrators to choose from. Each security
    level contains a collection of different rules for restricting pod configurations.
    The details of the security levels can be found in the [Kubernetes documentation](https://oreil.ly/3bKXr).
  prefs: []
  type: TYPE_NORMAL
- en: 'The three Pod Security Standard levels are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`privileged`'
  prefs: []
  type: TYPE_NORMAL
- en: Effectively no restrictions. It matches the default behavior of a Kubernetes
    cluster with no pod security enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '`baseline`'
  prefs: []
  type: TYPE_NORMAL
- en: Protects against known privilege escalations and other security issues.
  prefs: []
  type: TYPE_NORMAL
- en: '`restricted`'
  prefs: []
  type: TYPE_NORMAL
- en: The current community best practice for pod security.
  prefs: []
  type: TYPE_NORMAL
- en: When starting out with policy, it may be tempting to immediately start enforcing
    the `restricted` level for all namespaces, but it is important to note that preexisting
    configurations in the cluster may break, and community solutions or software provided
    by other third parties may not work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the security levels, the Pod Security Admission controller provides
    three levels of activation for the policy. The `enforce` level actively blocks
    pods from being created if they don’t match the security level. The `warn` level
    provides a warning to a user that their pod violates policy but doesn’t block
    it from being created. The `audit` level logs policy violations but doesn’t provide
    user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, each security level is versioned to match a particular Kubernetes
    version (e.g., `v1.25`). It’s important to note that while the security level
    is associated with a Kubernetes version, it is available in other Kubernetes versions:
    you can use the `v1.25` security level in a Kubernetes 1.26 cluster. The versions
    follow the same three-version deprecation policy as any other Kubernetes component.
    There is also a `latest` version that tracks whatever is the most up-to-date policy.
    However, as with using `latest` in container images, this is discouraged because
    your security policy will change when the cluster is upgraded, which means that
    you could break your cluster by adopting a new policy unexpectedly. Instead, incremental
    upgrading of security policy after a cluster upgrade is a best practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s important to note that the `warn` level provides warnings only in tools
    that support warnings, like `kubectl`. If you are using other tools for deployment,
    especially CI/CD automation, the warnings may not be surfaced to your users. In
    such situations, you may want to combine some sort of linter that examines the
    configurations before they are checked in along with pod security audit.
  prefs: []
  type: TYPE_NORMAL
- en: Activating Pod Security Using Namespace Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The activation of Pod Security is done on a per-namespace basis by adding labels
    to the namespaces. You can do this in your namespace YAML by adding labels as
    shown in the following example. We will start with a configuration that simply
    audits existing usage at the baseline security level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once this configuration is applied to all namespaces, you will start seeing
    audit information in the cluster audit logs. This will give you a sense of your
    cluster’s level of compliance. If your cluster is very far out of compliance,
    you will likely need to identify the owners of various workloads and work with
    them to bring their workloads into compliance. Because the enforcement is per-namespace,
    you can work with teams individually and move to enforcement as their workloads
    become compliant.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, your final security posture is a function of your teams and their
    workloads, so it is difficult to identify a single best practice for pod security
    configuration. However, for most users, setting `audit` and `warn` to `restricted`
    and `enforce` to `baseline` is a pretty good place to start. It will give you
    visibility into potentially vulnerable configurations while enabling enforcement
    to prevent the most egregious violations.
  prefs: []
  type: TYPE_NORMAL
- en: Workload Isolation and RuntimeClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container runtimes are still largely considered an insecure workload isolation
    boundary. There is no clear path to whether the most common runtimes of today
    will ever be recognized as secure. The momentum and interest among those in the
    industry toward Kubernetes has led to the development of different container runtimes
    that offer varying levels of isolation. Some are based on familiar and trusted
    technology stacks, whereas others are a completely new attempt to tackle the problem.
    Open source projects like Kata containers, gVisor, and Firecracker tout the promise
    of stronger workload isolation. These specific projects are either based on nested
    virtualization (running a super lightweight virtual machine within a virtual machine)
    or system call filtering and servicing. There has also been recent interest in
    the sandbox provided by the WebAssembly virtual machine, which was originally
    built for running in the browser but is seeing increased usage on the server side.
    The `containerd` project, one of the most popular container runtimes, now supports
    WebAssembly (WASM) based containers. Additionally RuntimeClass may be needed to
    choose a container runtime based on specific hardware capabilities like interacting
    with a GPU for artificial intelligence and machine learning workloads.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of these container runtimes that offer different workload isolation
    allows users to choose different runtimes based on their isolation guarantees
    in the same cluster. For example, you could have trusted and untrusted workloads
    running in the same cluster in different container runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: RuntimeClass was introduced into Kubernetes as an API to allow container runtime
    selection. It is used to represent one of the supported container runtimes on
    the cluster when it has been configured by the cluster administrator. As a Kubernetes
    user, you can define specific runtime classes for your workloads by using the
    RuntimeClassName in the pod specification. How this is implemented under the hood
    is that the RuntimeClass designates a `RuntimeHandler` that is passed to the Container
    Runtime Interface (CRI) to implement. Node labeling or node taints can then be
    used in conjunction with nodeSelectors or tolerations to ensure that the workload
    lands on a node capable of supporting the desired RuntimeClass. [Figure 10-1](#runtimeclass_flow_diagram)
    demonstrates how a kubelet uses RuntimeClass when launching pods.
  prefs: []
  type: TYPE_NORMAL
- en: '![RunTimeClass flow diagram](assets/kbp2_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. `RuntimeClass` flow diagram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using RuntimeClass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a cluster administrator has set up different RuntimeClasses, you can use
    them by specifying `runtimeClassName` in the pod specification; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Runtime Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are some open source container runtime implementations that offer
    different levels of security and isolation for your consideration. This list is
    intended as a guide and is by no means exhaustive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CRI containerd](https://oreil.ly/1wxU1)'
  prefs: []
  type: TYPE_NORMAL
- en: An API facade for container runtimes with an emphasis on simplicity, robustness,
    and portability.
  prefs: []
  type: TYPE_NORMAL
- en: '[cri-o](https://oreil.ly/OiXpP)'
  prefs: []
  type: TYPE_NORMAL
- en: A purpose-built, lightweight Open Container Initiative (OCI)-based implementation
    of a container runtime for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Firecracker](https://oreil.ly/on3Ge)'
  prefs: []
  type: TYPE_NORMAL
- en: Built on top of the Kernel-based Virtual Machine (KVM), this virtualization
    technology allows you to launch microVMs in nonvirtualized environments very quickly
    using the security and isolation of traditional VMs.
  prefs: []
  type: TYPE_NORMAL
- en: '[gVisor](https://oreil.ly/ZZt3n)'
  prefs: []
  type: TYPE_NORMAL
- en: An OCI-compatible sandbox runtime that runs containers with a new user-space
    kernel, which provides a low overhead and secure, isolated container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '[Kata Containers](https://oreil.ly/giOxk)'
  prefs: []
  type: TYPE_NORMAL
- en: A secure container runtime that provides VM-like security and isolation by running
    lightweight VMs that feel and operate like containers.
  prefs: []
  type: TYPE_NORMAL
- en: Workload Isolation and RuntimeClass Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following best practices will help you to avoid common workload isolation
    and RuntimeClass pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing different workload isolation environments via RuntimeClass will
    complicate your operational environment. This means that workloads might not be
    portable across different container runtimes given the nature of the isolation
    they provide. Understanding the matrix of supported features across different
    runtimes can be complicated and will lead to poor user experience. We recommend
    having separate clusters, each with a single runtime, to avoid confusion, if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workload isolation doesn’t mean secure multitenancy. Even though you might have
    implemented a secure container runtime, this doesn’t mean that the Kubernetes
    cluster and APIs have been secured in the same fashion. You must consider the
    total surface area of Kubernetes end to end. Just because you have an isolated
    workload doesn’t mean that it cannot be modified by a bad actor via the Kubernetes
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tooling across different runtimes is inconsistent. You might have users who
    rely on container runtime tooling for debugging and introspection. Having different
    runtimes means that you might no longer be able to run `docker ps` to list running
    containers. This leads to confusion and complications when troubleshooting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Pod and Container Security Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Pod Security Admission control and workload isolation, here are
    some other tools you may consider when determining how to handle pod and container
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Admission Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous discussion of pod security was powered by the Pod Security Admission
    controller, but there are many other admission controllers that you can choose
    from in the cloud native ecosystem. If you find the Pod Security Admission controller
    to be too restrictive, many other options provide more sophisticated policy solutions.
    For more information on admission control, refer to [Chapter 17](ch17.html#admission_control_and_authorization).
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion and Anomaly Detection Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered security policies and container runtimes, but what happens when
    you want to introspect and enforce policy within the container runtime? There
    are open source tools that can do this and more. They operate by either listening
    and filtering Linux system calls or by utilizing a Berkeley Packet Filter (BPF).
    One such tool is [Falco](https://oreil.ly/9KOeg), a Cloud Native Computing Foundation
    (CNCF) project that installs as a DaemonSet and allows you to configure and enforce
    policy during execution. Falco is just one approach. We encourage you to explore
    the tooling in this space to see what works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered in depth both the Pod Security Admission control
    and the RuntimeClass APIs with which you can configure a granular level of security
    for your workloads. We have also taken a look at some open source ecosystem tooling
    that you can use to monitor and enforce policy within the container runtime. We
    have provided a thorough overview for you to make an informed decision about providing
    the level of security best suited for your workload needs.
  prefs: []
  type: TYPE_NORMAL
