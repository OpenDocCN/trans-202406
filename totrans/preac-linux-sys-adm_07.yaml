- en: Chapter 7\. Managing Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learn how to add storage to your systems. You’ll see how
    to add a new disk drive to the system and make it available. You will also explore
    the logical volume manager and how to manipulate logical volumes, as well as learn
    about disk formatting, partitioning, and mounting.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, I cover some general concepts related to disks, filesystems,
    volumes, partitions, directories, and filesystem mounting.
  prefs: []
  type: TYPE_NORMAL
- en: Administering Linux Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The price of disk space has decreased so much in recent years that space is
    no longer a high-value commodity. You can buy multiterabyte disks for a few dollars
    per gigabyte. So system administrators rarely have to threaten to implement quotas
    or other arbitrary limits on disk space. Workstations and laptops often have as
    much space as servers, so space is no longer at a premium, and managing it is
    far less of a problem than it was just a few years ago. For example, many sysadmins
    now bypass old backup methods such as tape for faster and cheaper disk-to-disk
    backups.
  prefs: []
  type: TYPE_NORMAL
- en: But even though disk space is cheap and available, sysadmins still need to monitor
    users’ disk usage. You don’t want individuals filling up shared disk spaces or
    home directories with their music, videos, or other large files, because they
    waste corporate-owned space and prolong backup times. This section discusses disk-related
    terminology and how Linux system administrators interpret those terms. The specifics
    of how to work with each of these items are covered later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Disks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Disks (disk drives) are the devices that we refer to as hard drives or hard
    disk drives (HDDs), but *disks* can also refer to solid-state drives (SSDs) and
    USB thumb drives. System administrators make entire disks available to Linux systems
    using internal connections, USB connectivity, or an over-the-network technology
    such as Ethernet or fiber optic cabling. Before accessing a disk on Linux systems,
    a system administrator must mount the disk on a directory. For example, to mount
    a new disk identified by the system as */dev/sdd*, the sysadmin creates a new
    directory, such as */software*, and mounts the entire disk on that directory or
    *mount point*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The disk device */dev/sdd1* is now mounted on the directory */software* and
    is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The entire disk device is */dev/sdd* but initializing the disk requires at least
    one partition, so if disk */dev/sdd* has only a single partition, its name will
    be */dev/sdd1*. Details of this process appear later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once the administrator prepares the disk by partitioning and establishing a
    filesystem on it, users may access space made available to them.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *filesystem* is an organizational construct that allows for file storage and
    retrieval for an operating system. A filesystem is a data structure the operating
    system uses to keep track of files on a disk or partition. It is how the files
    are organized on the disk. A filesystem is a partition or entire disk that stores
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Contemporary Linux systems give administrators a broad choice of filesystems,
    although many sysadmins stick with ZFS, XFS, or ext4 when creating new partitions.
    There are many other filesystems available for specific needs and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting and Mount Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only the root user, or a user with `sudo` privileges, may mount a filesystem.
    Mounting a filesystem on a directory is roughly analogous to assigning a drive
    letter to a disk in Windows. Linux uses directories rather than drive letters,
    and those directories are referred to as mount points. In the example in [“Disks”](#disks),
    a new disk, */dev/sdd,* was mounted on the directory */software*. */software*
    is the mount point.
  prefs: []
  type: TYPE_NORMAL
- en: Linux systems provide a generic mount point, */mnt*, onto which you may temporarily
    mount disks. You shouldn’t use the */mnt* directory for a permanent mount point
    because another system administrator might mount another filesystem over it, hiding
    the original contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mount points need not be directories off of the root directory. They can be
    subdirectories. For example, you could mount the */dev/sdd* disk onto */opt/software*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A mount point (directory) must exist before mounting a disk or filesystem onto
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing special about a mount point directory. It’s the same as any
    other directory on the filesystem. Create a new directory, set its permissions,
    and mount the filesystem or disk onto it.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t mount filesystems or disks onto existing system directories such as */tmp*,
    */var*, */usr*, */etc*, etc. Doing so will cause erratic system behavior and possibly
    catastrophic failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cause disks to mount automatically at boot time, you must create an entry
    in the */etc/fstab* file that includes the new disk or filesystem and the mount
    point. For example, to automatically mount the */dev/sdd1* partition onto the
    */opt/software* directory, the */etc/fstab* entry looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t create this entry, the */dev/sdd1* won’t mount automatically upon
    reboot. This isn’t a problem if that’s your intent or if you only have a few systems,
    but if you manage dozens or hundreds of systems, you need to set up */etc/fstab*
    for each filesystem or disk you wish to mount automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Physical and Logical Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When sysadmins speak of physical and logical volumes, they refer to logical
    volume management (LVM). [Figure 7-1](#the_logical_volume_manager) shows a visual
    reference of the Logical Volume Manager. A physical volume is a partition or disk
    managed by a logical volume. The physical volume looks exactly like a disk partition.
    For example, the partition */dev/sdd1* is also the physical volume */dev/sdd1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/plsa_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. The Logical Volume Manager
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A volume group contains physical volumes. A logical volume is equivalent to
    a partition on a disk, but you create logical volume partitions from volume groups.
    Logical volumes contain filesystems that are named, and those names can be descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of thinking about logical volumes is that volume groups are analogous
    to disks, and logical volumes are analogous to disk partitions.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of abstracting physical volumes into logical ones are that you
    have the flexibility of spanning multiple disks to create large volume groups
    and can dynamically resize (shrink and grow) logical volumes without taking the
    system offline to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sysadmins should keep a close eye on disk space usage. Log files can grow to
    fill filesystems if something goes wrong on a system, such as a buffer overflow.
    Users often fill filesystems and shared spaces with nonwork files. Developers
    also often download gigabytes of code and other files without discussing their
    needs with the sysadmins or anyone else. You can quickly check disk space using
    the *disk free* (`df`) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `df` command lets you know at a glance how much available space there is
    on your mounted filesystems. The `-h` switch means human-readable, which means
    `M` for megabytes, `G` for gigabytes, etc. Monitoring systems or your own scripts
    can alert you to filesystems that fill beyond a given threshold. For example,
    setting a 90% threshold would trigger an alert that a particular filesystem is
    at or over 90% capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disk usage (`du`) command is very handy for checking individual directories
    and provides a breakdown of what’s consuming space. For example, the following
    command checks the space consumed by the */var/log* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see at a glance which directories consume the most disk space. This
    is important if you’re auditing your system’s disk space before removing unneeded
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Swap Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swap space is a special type of Linux disk partition that extends a system’s
    memory beyond the limits of physical random access memory (RAM). Your system’s
    kernel uses swap space to write inactive programs from memory to disk, freeing
    up memory for active programs. If a user or process activates those swapped programs,
    the system writes them from disk back into memory.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding swap space is not a remedy for solving memory problems. If your system
    has memory constraints, one accepted solution is to add more physical RAM rather
    than increasing swap space or adding another swap partition. A system’s overuse
    of swap space creates a condition known as *thrashing*. Thrashing occurs when
    too many programs are running, the swap partition is too small, or the system
    has insufficient physical RAM to support its processes.
  prefs: []
  type: TYPE_NORMAL
- en: I discuss how to create and manage swap space later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: RAM-Based Temporary Space (ramfs and tmpfs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Ramfs* and *tmpfs* are filesystems whose files exist in memory and are not
    written to disk. The *tmpfs* system is the newer and preferred RAM-based temporary
    filesystem, and *tmpfs* is the default for all contemporary Linux distributions.
    One reason for the transition away from *ramfs* to *tmpfs* is that *ramfs* allowed
    itself to fill to capacity. *Tmpfs* has limit checking to prevent reaching its
    maximum capacity. *Tmpfs* adds the feature of writing files to available swap
    space to save resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listings show the *tmpfs* mount information for both CentOS and
    Ubuntu systems, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of *tmpfs* is to write temporary files and caches to memory rather
    than to disk because of the speed differences between RAM and disk. RAM is many
    times faster than the fastest SSD. The downside of *tmpfs* is that if you reboot
    or unmount *tmpfs*, the data you have stored there is lost. Programs, processes,
    and users may all write to this temporary space. Similar to disk-based filesystems,
    a warning of “no space left on device” occurs when files, from whatever sources,
    have filled the allotted space.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a New Disk to a System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I show you the steps required to add a new disk to a system
    and prepare the disk for use. First, I describe how to add a disk to a physical
    system. Then I demonstrate the same procedure but using a virtual disk. You’ll
    also learn how to create a filesystem on the disk and mount it as a single usable
    directory. I also demonstrate how to set up a logical volume on a disk.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must have root privileges to perform these system-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Disk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can simply attach a hard drive without powering it down for physical systems
    with hot-swappable disk interfaces. If your system doesn’t have hot-swappable
    interfaces, shut it down before adding a new disk. Once you’ve physically added
    the disk, power on the system (if required) and log in to set it up.
  prefs: []
  type: TYPE_NORMAL
- en: For those who use virtual machines (VMs), shut down your VM, add a new disk,
    and restart it. From then on, the process is the same for physical and virtual
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I can’t demonstrate adding a new virtual disk because there are too many virtual
    platforms available from which to choose. It generally involves selecting storage,
    attaching a virtual disk to a virtual controller, adjusting the size of the disk,
    and saving the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Prepping the Disk for Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must first determine the new disk’s device name. The system assigns the
    device name automatically. Use the `fdisk` command to display all attached disks
    and partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding listing, the system identified the new disk device as */dev/sdb*.
    Now that you’ve identified the disk’s device name, you can begin initializing
    it using the `fdisk` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can ignore the message `Failed to add partition 1 to system: Device or
    resource busy`. You can see that the partition */dev/sdb1* does exist on the system.
    You have initialized the disk and created partition */dev/sdb1*. Now you must
    create the filesystem. The following command formats the */dev/sdb1* partition
    using XFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command lists all block devices and filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lsblk` command also displays the devices’ universally unique identifiers
    (UUIDs), which you need for the last step of the disk preparation process: mounting
    the filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also display the UUID by issuing the `blkid` command with the device
    name as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a directory on which you want to mount the new partition. I use
    */opt/software* as the mount point in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Mount the */dev/sdb1* partition onto the */opt/software* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to see if the preceding `mount` command worked correctly by using the
    `mount` command without any switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The partition */dev/sdb1* successfully mounted on */opt/software*. Now you
    need to make this mount “permanent,” which means it will survive a system reboot.
    Edit the */etc/fstab* file and enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file. The */dev/sdb1* partition will mount automatically once you
    reboot the system. Debian-derived systems handle this */etc/fstab* syntax a bit
    differently. On the Ubuntu system, this */etc/fstab* entry looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To allow users to access the drive, alter the permissions of */opt/software*
    or create subdirectories with appropriate permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Logical Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logical volumes give you much flexibility in allocating disk space. The capability
    of resizing live partitions is a huge feature because adding or removing disk
    space from a partition doesn’t require any system downtime. You should still schedule
    a maintenance window when resizing a logical volume because there is still potential
    for something to go wrong during the process. If you make a mistake, you could
    lose data or possibly have to rebuild the entire logical volume. Disasters are
    somewhat unlikely, but they can happen.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing isn’t the only notable feature of logical volumes. A logical volume
    can span disks, meaning you can create a very large logical volume from multiple
    disks. A few years ago, administrators were reluctant to create volumes that span
    multiple disks because spinning, mechanical hard drives are prone to failure.
    But using SSDs deprecates the “don’t span” rule. SSDs fail too, but their lifespans
    and reliability make it much more reasonable to span when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: This section demonstrates how to set up a logical volume from a raw disk. (You
    can convert a currently used disk to a logical volume, but you will lose all the
    data in the process.)
  prefs: []
  type: TYPE_NORMAL
- en: Identifying available disks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To check your system for available (unused) disks or disks that you want to
    convert to logical volumes, use the `lsblk` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'From the listing, in the line containing the disk, `sdb` shows that it is online
    and available for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you must create the physical volume (PV), which is the basic block device
    onto which you’ll build logical volumes. Use the `pvcreate` command and the device
    name to initialize the disk as a physical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'List all physical volumes and confirm that */dev/sdb* is among them using the
    `pvs` (PV Show) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `pvdisplay` command to see details about your physical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If your disk or filesystem is already mounted when you attempt to use `pvcreate`,
    you’ll receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You’ll need to unmount */dev/sdb* (`umount /dev/sdb`) before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to create a volume group (VG) from the physical volume */dev/sdb*
    using the `vgcreate` command. Give the VG a name, as I’ve done here with *vgsw*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As depicted in [Figure 7-1](#the_logical_volume_manager), you create volume
    groups from physical volumes. In this demonstration, I only used one physical
    volume. Now that you have a volume group, you must create logical volumes. Creating
    the logical volume is the third step in this process.
  prefs: []
  type: TYPE_NORMAL
- en: For this demonstration, I begin by deciding how much space to allocate to the
    logical volume. I decide to use 1 GB of the 1.5 GB disk. It’s now time to create
    the logical volume using the `lvcreate` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of the `lvcreate` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You must provide the size parameter in gigabytes or megabytes, by adding a
    trailing `G` or `M`, respectively. The `lvname` is the name you want to use for
    this logical volume (`software-lv`) and you must supply the volume group name
    (`vgsw`) from which you want to create the logical volume (`software-lv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding message, you see that the disk or partition had previously
    held an `xfs signature`, which means it’s not a new disk or partition but a recycled
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s no problem with using a previously used disk but realize that all the
    information on it will be overwritten and unrecoverable in this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `lvs` and `lvdisplay` commands to list details about your logical volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You must use the full path to the logical volume device (`/dev/vgsw/software-lv`)
    when you filter by the logical volume name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth step in this process is to create a filesystem on your logical volume.
    You perform this task by using the same command that you would use for any partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mount point for your filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Mount the filesystem onto the mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Check available space on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to add the filesystem and its mount point to */etc/fstab*
    to mount the logical volume automatically at boot time. My entry looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t use the UUID for defining logical volumes in */etc/fstab*. Instead, use
    the device name (`/dev/vgsw/software-lv`).
  prefs: []
  type: TYPE_NORMAL
- en: The logical volume will mount automatically on reboot. The next section describes
    how to increase the size of, or extend, a logical volume.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a logical volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the logical volume that I configured in this scenario, I used 1 GB of the
    1.5 GB total disk size for */dev/vgsw/software-lv*. To extend this volume, you
    can use one of the following general commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, I’ll use the `-l` (extents) option rather than a specific
    size to consume the rest of the free space on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lvextend` command extends the logical volume to its maximum capacity but
    a `df` shows the same amount of available space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You have extended the logical volume but not the filesystem. Now resize the
    filesystem using the `xfs_growfs` command with no size parameter. By not specifying
    a size parameter with `-D size`, `xfs_growfs` will extend the filesystem to its
    maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You cannot shrink an XFS volume.
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully extended the filesystem, and your logical volume is ready
    to use. The actual available size is 1.44 GB (shown as `1.4G` in the preceding
    example) because of filesystem overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Decommissioning and Disk Disposal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decommissioning includes the wiping or destruction of disks before disposal.
    The decommissioning process differs from company to company but generally follows
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Scream” test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk wiping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palletizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disposal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timeline for each of these steps varies. The following sections provide
    details for each step.
  prefs: []
  type: TYPE_NORMAL
- en: Notification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stakeholders, system administrators, network administrators, storage administrators,
    and management all receive multiple decommissioning notifications for a list of
    systems. Large companies generally send the list out weekly for a period of three
    to four weeks (the actual time varies from company to company and is a matter
    of policy). These notifications give stakeholders and others a chance to take
    possession of a system or to prevent its decommissioning via email and then a
    discussion during a governance meeting. If no one speaks up on behalf of any listed
    system, the process proceeds to the “scream” test phase.
  prefs: []
  type: TYPE_NORMAL
- en: Scream Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The so-called “scream” test is a period of two or more weeks where a system
    administrator or data center staff member unplugs a given system from the network
    but doesn’t power down listed systems. The plan is that during this time if someone
    screams about a system being down, it would be plugged back into the network,
    and its operations would continue as before. The next governance meeting would
    remove the system from the decommissioning list.
  prefs: []
  type: TYPE_NORMAL
- en: Power Down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next milestone in the decommissioning process is the power-down phase, which
    lasts two or more weeks. System administrators power down all listed systems.
    This period is a second chance for interested parties to claim a system or to
    notify the governance committee that the system needs to remain in operation.
  prefs: []
  type: TYPE_NORMAL
- en: Disk Wiping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After several weeks of notifications and waiting, the governance committee finalizes
    the list and submits it to system administrators for disk wiping. The system administrator
    powers on each system and uses a disk-wiping utility to overwrite every local
    disk. Leveraged or shared storage such as storage area network (SAN), network-attached
    storage (NAS), or nonlocal disk storage is not included in this process. This
    process ensures no data is left on a system’s local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I have relied on [Darik’s Boot and Nuke (DBAN) utility](https://oreil.ly/PnMgA)
    for years to wipe disks for decommissioning and disposal. It is a free, open source
    utility for hard disk drives (HDDs). This product is *not* for solid-state drives
    (SSDs).
  prefs: []
  type: TYPE_NORMAL
- en: Unracking and Palletizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a system’s disks have been wiped, the list goes to data center personnel
    for unracking. Technicians remove the systems from data center racks and place
    them onto shipping pallets. Once a pallet is full, the technician labels it, and
    it goes into a disposal queue.
  prefs: []
  type: TYPE_NORMAL
- en: Disposal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The disposal process may consist of bidding, where companies bulk purchase palletized
    systems for sale or redeployment. Sometimes the systems go to a recycling facility
    where technicians remove disks, CPUs, memory, and other salvageable components
    for individual or bulk resale. System disposal can also mean that those whole
    systems are disposed of by crushing or shredding and sold as recyclable material.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered multiple aspects of disk management, including general
    disk-related information, adding a new disk to a system, logical volume management,
    and decommissioning and disposal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, I cover two important tasks for system administrators:
    health and housekeeping.'
  prefs: []
  type: TYPE_NORMAL
