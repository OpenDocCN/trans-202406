<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Assembling Your Own Workspace in Terra"><div class="chapter" id="assembling_your_own_workspace_in_terra">
<h1><span class="label">Chapter 13. </span>Assembling Your Own Workspace in Terra</h1>

<p>In Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.xhtml#running_many_workflows_conveniently_in">11</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch12.xhtml#interactive_analysis_in_jupyter_noteboo">12</a>, you learned how  to use workflows and interactive notebooks in Terra using prebaked workspaces. <a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-startref="ix_Terrwksp" data-type="indexterm" id="idm45625612095832"/>Now, it’s time for you to learn to bake your own so you can build your own analyses within the Terra framework.<a contenteditable="false" data-primary="workspaces (Terra)" data-seealso="Terra platform" data-type="indexterm" id="idm45625612093896"/> This is an area provides a lot of options and multiple valid approaches, so rather than attempting to provide a one-size-fits-all path, we’re going to walk through three scenarios.</p>

<p>In the first scenario, we re-create the <a href="https://oreil.ly/n7oOr">book tutorial workspace</a> from its base components to demonstrate the key mechanisms involved in assembling a workspace from the ground up. In the second and third scenarios, we show you how to take advantage of existing workspaces to minimize the amount of work you have to do when starting a new project. In one case, we explain how to add data to an existing workspace that is already set up for a particular analysis, such as the official GATK Best Practices workspaces. In the other, we demonstrate how to build an analysis around data exported from the Terra Data Library. However, before we dive into those three scenarios, let’s explore the data management strategy that we’re applying in all three cases.</p>

<section data-type="sect1" data-pdf-bookmark="Managing Data Inside and Outside of Workspaces"><div class="sect1" id="managing_data_inside_and_outside_of_wor">
<h1>Managing Data Inside and Outside of Workspaces</h1>

<p>One of the most important <a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-tertiary="managing data inside and outside of workspaces" data-type="indexterm" id="ix_TerrwkspIO"/>aspects of moving <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="managing data inside and outside of" data-type="indexterm" id="ix_wkspmgda"/>your work <a contenteditable="false" data-primary="data management inside/outside of Terra workspaces" data-type="indexterm" id="ix_damgt"/>to the cloud is designing a data management strategy that will be sustainable for the long term, especially if you expect to work with large datasets that will serve as input for multiple projects. It’s a complex enough topic that a full discussion would be beyond the scope of this book, and entire books cover that subject alone. However, it’s worth taking some time to talk through a few key considerations that apply specifically in the context of Terra and shape how we decide where data should reside.</p>

<section data-type="sect2" data-pdf-bookmark="The Workspace Bucket as Data Repository"><div class="sect2" id="the_workspace_bucket_as_data_repository">
<h2>The Workspace Bucket as Data Repository</h2>

<p>As you learned in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>, each Terra workspace<a contenteditable="false" data-primary="storage buckets" data-secondary="workspace bucket as data repository" data-type="indexterm" id="idm45625612079688"/> is created<a contenteditable="false" data-primary="data management inside/outside of Terra workspaces" data-secondary="workspace bucket as data repository" data-type="indexterm" id="idm45625612078136"/> with a<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="managing data inside and outside of" data-tertiary="workspace bucket as data repository" data-type="indexterm" id="idm45625612076552"/> dedicated GCS bucket. <a contenteditable="false" data-primary="Google Cloud Storage (GCS)" data-secondary="dedicated bucket in each Terra workspace" data-type="indexterm" id="idm45625612074712"/>You can store any data that you want in the workspace bucket, and all notebooks as well as logs and outputs from workflows that you run in that workspace will be stored there.  However, there’s no obligation to store your <em>input</em> data in the workspace bucket. You can compute on data that resides anywhere in GCS as long as you can provide the relevant pointers to the files, assuming that you are able to grant access to that data to your Terra account (more on that in a minute).</p>

<p>This is important to note for a couple of reasons. First, if you’re going to use the same data as input for multiple projects, you don’t want to have to maintain copies of the data in each workspace because you’ll get charged storage costs for each bucket. Instead, you can put the data in one location and point to that location from wherever you need to use it. Second, be aware that the workspace bucket lives and dies with your workspace: if you delete the workspace, the bucket and its contents will also be deleted. Related to this, when you clone a workspace, the only bucket content that the clone inherits from its parent is the notebooks directory. The clone will inherit a copy of the parent’s data tables, retaining links to the data in the parent’s bucket, but not the files themselves. <a contenteditable="false" data-primary="shallow copy of workspace contents" data-type="indexterm" id="idm45625612071112"/>This is called making a <em>shallow copy</em> of the workspace contents. If you then delete the parent workspace, the links in the clone’s data tables will break, and you will no longer be able to run analyses on the affected data.</p>

<p>As a result, we generally recommend storing datasets in dedicated <em>master</em> workspaces that are kept separate from analysis workspaces, with more narrow permissions restricting the number of people authorized to modify or delete them. Alternatively, you could also store the data in buckets that you manage outside of Terra, as we did for the example data provided with this book. The advantage of storing the data outside of Terra is that you (or whoever owns the billing account for the bucket) have full administrative control over it. That gives you the freedom to do things like setting granular per-file permissions or making contents fully public, which are not currently possible in Terra workspace buckets for security reasons. It also doesn’t hurt that you can choose meaningful names for the buckets you create yourself, whereas Terra assigns long, abstract names that are not very human-friendly. However, if you decide to follow that route, you’ll need to enable Terra to access any private data that you manage yourself outside of Terra, as explained in the next section.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Accessing Private Data That You Manage Outside of Terra"><div class="sect2" id="accessing_private_data_that_you_manage">
<h2>Accessing Private Data That You Manage Outside of Terra</h2>

<p>So far, we’ve worked<a contenteditable="false" data-primary="data management inside/outside of Terra workspaces" data-secondary="accessing private data managed outside of Terra" data-type="indexterm" id="idm45625612065096"/> with data that’s either<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="managing data inside and outside of" data-tertiary="accessing private data outside of Terra" data-type="indexterm" id="idm45625612063464"/> in public buckets or in the workspace’s own bucket, which is managed by Terra. However, you will eventually want to access data that resides in a private bucket that is not managed by Terra.<a contenteditable="false" data-primary="storage buckets" data-secondary="accessing data in private bucket outside of Terra" data-type="indexterm" id="idm45625612061464"/> At that point, you will encounter<a contenteditable="false" data-primary="authentication" data-secondary="accessing data outside Terra in private GCS bucket" data-type="indexterm" id="idm45625612059928"/> an unexpected complication: even if you own that private bucket, you will need to go through an additional authentication step that involves the GCP <span class="keep-together">console</span> and <a contenteditable="false" data-primary="proxy group account" data-type="indexterm" id="idm45625612057544"/> a <em>proxy group account</em>. Here’s what you need to know and do to get past this hurdle.</p>

<p>Whenever you issue <a contenteditable="false" data-primary="Google Cloud Platform (GCP)" data-secondary="issuing instruction to do something in GCP through Terra service" data-type="indexterm" id="idm45625612055464"/>an instruction to do something in GCP through a Terra service, the Terra system doesn’t actually use your individual account in its request to GCP. Instead, it uses a service account that Terra creates for you. <a contenteditable="false" data-primary="service accounts created by Terra" data-type="indexterm" id="idm45625612053544"/>In fact, you can have multiple service accounts created for you by Terra because you get one for each billing project to which you have access. All of your service accounts are collected into a <em>proxy group</em>, which Terra uses to manage your credentials to various resources. This has benefits for both security and convenience under the hood.</p>

<p>Most of the time, you don’t need to know about this because any resources that you create or manage within Terra (like a workspace and its bucket, or a notebook) are automatically shared with your proxy group account. In addition, whenever someone shares something with you in Terra, the same thing happens: your proxy group account is automatically included in the fun, so you can seamlessly work with those resources from within Terra. However, when you start connecting to resources that are not managed by Terra, the Google system that controls access permissions doesn’t automatically know that your proxy group account is allowed to act as your proxy. <a contenteditable="false" data-primary="proxy group account" data-secondary="identifying in Google permissions system" data-type="indexterm" id="idm45625612050440"/>So, you need to identify your proxy group account in the Google permissions system, and specify what it should be allowed to do.</p>

<p>Fortunately, this is not too difficult if you know what to do, and we’re about to walk you through the process for the most common case: accessing a GCS bucket that is not controlled by Terra.<a contenteditable="false" data-primary="Google Cloud Storage (GCS)" data-secondary="accessing GCS bucket not controlled by Terra" data-type="indexterm" id="idm45625612048136"/><a contenteditable="false" data-primary="storage buckets" data-secondary="accessing data outside Terra in private GCS bucket" data-type="indexterm" id="idm45625612046712"/> For other resources, the process would be essentially the same.</p>

<p>First, you need to find out your proxy group account identifier. There are several ways to do that. The simplest is to look it up in your <a href="https://app.terra.bio/#profile">Terra user profile</a>, where it is displayed as shown in <a data-type="xref" href="#the_proxy_group_identifier_displayed_in">Figure 13-1</a>.</p>

<figure class="width-60 no-frame"><div id="the_proxy_group_identifier_displayed_in" class="figure"><img alt="The proxy group identifier displayed in the user profile." src="Images/gitc_1301.png" width="1238" height="278"/>
<h6><span class="label">Figure 13-1. </span>The proxy group identifier displayed in the user profile.</h6>
</div></figure>

<p>With that in hand, you can head over to the GCS console and look up your <em>external bucket</em>; that is, the bucket you originally created for the exercises in <a data-type="xref" href="ch04.xhtml#first_steps_in_the_cloud">Chapter 4</a>. Go to the Bucket details page and find the Permissions panel, which lists all accounts authorized to access the bucket in some capacity, as shown in <a data-type="xref" href="#the_bucket_permissions_panel_showing_ac">Figure 13-2</a>.</p>

<figure class="no-frame"><div id="the_bucket_permissions_panel_showing_ac" class="figure"><img alt="The bucket permissions panel showing accounts with access to the bucket." src="Images/gitc_1302.png" width="1439" height="645"/>
<h6><span class="label">Figure 13-2. </span>The bucket permissions panel showing accounts with access to the bucket.</h6>
</div></figure>

<p>Click the “Add members” button to open the relevant page and add your pet service account identifier in the “New members” field. In the “Select a role” drop-down menu, scroll if needed to select the Storage service in the left column and then further select the Storage Object Admin role in the right column, as shown in <a data-type="xref" href="#granting_access_to_a_bucket_to_a_new_me">Figure 13-3</a>. Click Save to confirm.</p>

<figure class="width-75 no-frame"><div id="granting_access_to_a_bucket_to_a_new_me" class="figure"><img alt="Granting access to a bucket to a new member." src="Images/gitc_1303.png" width="1440" height="1322"/>
<h6><span class="label">Figure 13-3. </span>Granting access to a bucket to a new member.</h6>
</div></figure>

<p>After you’ve done this, you will be able to access external GCP resources such as buckets not managed by Terra from within your notebooks and workflows. For any buckets that you don’t administer yourself, you’ll need to ask an administrator to do this procedure on your behalf.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Accessing Data in the Terra Data Library"><div class="sect2" id="accessing_data_in_the_terra_data_librar">
<h2>Accessing Data in the Terra Data Library</h2>

<p>As you might <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="managing data inside and outside of" data-tertiary="accessing data in Terra Data Library" data-type="indexterm" id="idm45625612028328"/>recall from the context-setting <a contenteditable="false" data-primary="data management inside/outside of Terra workspaces" data-secondary="accessing data in Terra Data Library" data-type="indexterm" id="idm45625612026520"/>discussion in <a data-type="xref" href="ch01.xhtml#introduction">Chapter 1</a>, in which we originally introduced <a contenteditable="false" data-primary="Terra Data Library" data-secondary="accessing data in" data-type="indexterm" id="idm45625612023880"/>the platform, Terra includes a <a href="https://oreil.ly/VD6cJ">Data Library</a> that provides connections to<a contenteditable="false" data-primary="datasets" data-secondary="hosted in GCP" data-type="indexterm" id="idm45625612021592"/> datasets hosted in GCP by various organizations. Some of those datasets are simply provided in Terra workspaces, like the 1000 Genomes High Coverage dataset that you’ll use in the second and third scenarios in this chapter.<a contenteditable="false" data-primary="1000 Genomes High Coverage dataset" data-primary-sortas="One Thousand" data-type="indexterm" id="idm45625612019848"/> You’ll have the opportunity to try out a few ways to take advantage of that type of data repository.</p>

<p>Other datasets are hosted in independent repositories that you access through dedicated<a contenteditable="false" data-primary="datasets" data-secondary="hosted in independent repositories, accessing from Terra" data-type="indexterm" id="idm45625612017688"/> interfaces called <em>data explorers</em>, which enable you to select <a contenteditable="false" data-primary="data explorers" data-type="indexterm" id="idm45625612015656"/>subsets of the data based on metadata properties and then export them to a regular workspace. We won’t cover those in detail but encourage you to explore the library and try retrieving data from the <a href="https://oreil.ly/lBDFN">ENCODE</a> or <a href="https://oreil.ly/qCWuS">NeMo</a> repositories, for example. Both of these are fully public and have very different interfaces, so they make for interesting navigation practice.<a contenteditable="false" data-primary="NeMo repository" data-type="indexterm" id="idm45625612012632"/><a contenteditable="false" data-primary="ENCODE repository" data-type="indexterm" id="idm45625612011528"/></p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625612010424">
<h5>Exploring ENCODE and NeMo</h5>

<p>For ENCODE, try selecting a few metadata properties to narrow the data selection. Then, look for the Export button to become active in the upper-right corner of the data explorer window. For NeMo, on the top menu bar, click the Data button, select a few properties in the menu on the left, and then go to the shopping cart icon in the upper right (interesting design choice, indeed). In the cart, click the Download options menu and select “Export to Terra.” In both cases, you’ll have the choice to create a new workspace or send the data to an existing workspace.</p>
</div></aside>

<p>Most of the datasets in the Terra Data Library are restricted to authorized researchers because they <a contenteditable="false" data-primary="datasets" data-secondary="in Terra Data Library" data-type="indexterm" id="idm45625612007784"/>contain protected health information, and the access modalities depend on the project host organization. <a contenteditable="false" data-primary="TCGA dataset" data-type="indexterm" id="idm45625612006152"/>Some, like <a href="https://oreil.ly/Dsnm4">TCGA</a>, are mediated<a contenteditable="false" data-primary="dbGAP credentials" data-type="indexterm" id="idm45625612004200"/> through dbGAP credentials, which you can link in your Terra user profile to gain automatic access if you are already authorized. Others are managed outside of Terra and require interaction with the project maintainers. If you are interested in learning more about any of the datasets in the library, click through to their project page, where you will typically find a description of access requirements.</p>

<p>Given the current heterogeneity of the data repositories included in the library, it is not yet trivial to use these resources effectively, especially if you intend to <span class="keep-together">cross-analyze</span> multiple datasets—which is unfortunate because that is one of the key attractions of moving to the cloud. This is an area of ongoing development, with many organizations actively collaborating to improve the level of interoperability and usability of these resources. We are already seeing early adopters successfully harness these resources in their research, and we are optimistic that upcoming improvements will make it easier for a wider range of investigators to do so as well.</p>

<p>For now, however, let’s dial back our ambition by a couple of notches and focus on getting the basics in place. <a contenteditable="false" data-primary="data management inside/outside of Terra workspaces" data-startref="ix_damgt" data-type="indexterm" id="idm45625612000184"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="managing data inside and outside of" data-startref="ix_wkspmgda" data-type="indexterm" id="idm45625611998776"/>Back to work!<a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-startref="ix_TerrwkspIO" data-tertiary="managing data inside and outside of workspaces" data-type="indexterm" id="idm45625611997032"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Re-Creating the Tutorial Workspace from Base Components"><div class="sect1" id="re_creating_the_tutorial_workspace_from">
<h1>Re-Creating the Tutorial Workspace from Base Components</h1>

<p>Our most immediate goal in this chapter<a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-tertiary="re-creating tutorial workspace from base components" data-type="indexterm" id="ix_Terrwksprecr"/> is to equip<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-type="indexterm" id="ix_wksprecr"/> you with the knowledge and skills to assemble a complete yet basic workspace on your own. We’ve chosen to do this by having you re-create the tutorial workspace from Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.xhtml#running_many_workflows_conveniently_in">11</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch12.xhtml#interactive_analysis_in_jupyter_noteboo">12</a> given that you’ve been using it extensively in previous chapters and it contains all the basic elements of a complete workspace in a fairly simple form. As we guide you through the process, we’re going to focus on the most commonly used mechanisms for pulling in the various components (data, code, etc.), and to avoid overwhelming you, we’re intentionally not going to discuss every option that is available on the <span class="keep-together">platform</span>.</p>

<p>Are you ready to get started? Because we’ll have you check the model workspace multiple times during the course of this section, we recommend that you open two separate browser windows (or tabs): one for the model workspace and another for the workspace that you are about to create.</p>

<section data-type="sect2" data-pdf-bookmark="Creating a New Workspace"><div class="sect2" id="creating_a_new_workspace">
<h2>Creating a New Workspace</h2>

<p>In your second<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="creating new workspace" data-type="indexterm" id="ix_wksprecrnew"/> browser tab or window, navigate to the page that lists workspaces to which you have access, either by selecting <a href="https://oreil.ly/3fL7H">Your Workspaces</a> in the collapsible navigation menu or View Workspaces from the Terra landing page. You should see <a contenteditable="false" data-primary="Create a New Workspace dialog box" data-type="indexterm" id="ix_CrNWks"/> plus sign next to the Workspaces header in the top left of the page. Click that now to create a new blank workspace.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>By default, this page lists only private workspaces that either you have created yourself or that were shared with you under the “My workspaces” tab, excluding workspaces that are publicly accessible to everyone. You can view public workspaces by selecting one of the other workspace category tabs.</p>
</div>

<p>In the workspace creation dialog that pops up, give your new workspace a name and select a billing project, just as you’ve done when cloning workspaces in previous chapters. Because this is a brand-new workspace, the Name and Description fields will initially be blank. The name of your workspace must be unique within your billing project, but aside from that, you have a lot of freedom in naming, including using spaces in the name, as you can see in the example in <a data-type="xref" href="#the_quotation_markcreate_a_new_workspac">Figure 13-4</a>.</p>

<figure class="width-50 no-frame"><div id="the_quotation_markcreate_a_new_workspac" class="figure"><img alt="The “Create a New Workspace” dialog box." src="Images/gitc_1304.png" width="772" height="846"/>
<h6><span class="label">Figure 13-4. </span>The Create a New Workspace dialog box.</h6>
</div></figure>

<p>The Description field is what will show up in the Dashboard of your new workspace. It’s good practice to enter something informative for future reference, even if it’s optional. You’ll have the opportunity to edit it later, though, so don’t sweat the details.</p>

<p>The Authorization domain field allows you to restrict access to the workspace and all its content to a specific group of users, which you must define separately. This is a useful feature for securing private information, but we’re not going to demonstrate its use here, so leave this field blank. See the <a href="https://oreil.ly/ikgz9">article in the Terra user guide</a> if you’re interested in learning more about this feature.</p>

<p>Click the Create button; you’re then directed to the Dashboard page of your brand-new workspace. Feel free to click through the various tabs to inspect the contents, but as you’ll quickly notice, there’s not much to see there, with the exception of the description you provided (if you provided one) and a link to the dedicated GCS bucket that Terra created for your workspace. You might also notice the small widget showing the estimated cost per month of the workspace, which corresponds to the cost of storing the bucket contents. That cost estimate does not include the charges resulting from the analyses you might perform in the workspace. Right now, the cost estimate is zero because there’s nothing in there. Yay?<a contenteditable="false" data-primary="Create a New Workspace dialog box" data-startref="ix_CrNWks" data-type="indexterm" id="idm45625611968664"/></p>

<p>Not that we want you to spend money, but this empty workspace is begging for some content, so let’s figure out how to load it up. Because this is supposed to be a <span class="keep-together">re-creation</span> of the tutorial from <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>, we’re going to follow the same order of operations. Our first stop, therefore, will be the Workflows panel to set up the <code>HaplotypeCaller</code> workflow.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-startref="ix_wksprecrnew" data-tertiary="creating new workspace" data-type="indexterm" id="idm45625611964408"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Adding the Workflow to the Methods Repository and Importing It into the Workspace"><div class="sect2" id="adding_the_workflow_to_the_methods_repo">
<h2>Adding the Workflow to the Methods Repository and Importing It into the Workspace</h2>

<p>As you <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="adding workflow to Methods Repository and importing it into workspace" data-type="indexterm" id="ix_wksprecrwkfl"/>might recall, the<a contenteditable="false" data-primary="workflows" data-secondary="importing WDL workflow into Terra via Broad Methods Repository" data-type="indexterm" id="ix_wkflimp"/> workflow that you used in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a> was the same <code>HaplotypeCaller</code> workflow that you worked with in previous chapters. For the purposes of the tutorial, we had already deposited the workflow in Terra’s internal Methods Repository, so technically you could just go look it up and import it into your workspace. However, we want to empower you to bring in your own private workflows, so we’re going to have you deposit your own copy of the <code>HaplotypeCaller</code> WDL and import that into your workspace.</p>

<p>In your blank workspace, navigate<a contenteditable="false" data-primary="Workflows panel in Terra, Find a workflow" data-type="indexterm" id="idm45625611953816"/> to the Workflows panel and click the large box labeled “Find a workflow.” This opens a dialog that lists a selection of example workflows as well as two workflow repositories that contain additional workflows: Dockstore and the Broad <a contenteditable="false" data-primary="Methods Repository (Broad)" data-type="indexterm" id="idm45625611952104"/>Methods Repository.<a contenteditable="false" data-primary="Broad Methods Repository" data-type="indexterm" id="idm45625611950808"/> Click the latter to access the Methods Repository.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625611949400">
<h5>Expectations for Working with the Broad Methods Repository</h5>

<p>As of this writing, the Broad Methods Repository has not yet been fully integrated into Terra and is technically considered a separate service. If that is still the case<a contenteditable="false" data-primary="FireCloud (precursor to Terra)" data-type="indexterm" id="idm45625611947832"/> when you follow these instructions, you’ll see a blue navigation theme and references to something called FireCloud, which was the precursor to Terra and lives on as a <a href="https://firecloud.terra.bio">project powered by Terra and funded by the National Cancer Institute</a>. If you see a green theme, you live far enough in the future for the integration to be complete. We hope the planet still has ice caps and the following instructions are still valid enough to guide you successfully through the next few steps. We tried to predict what might change and minimize our dependence on screenshots, but if you find yourself stuck, check out the changelog in the book repository for updated instructions.</p>
</div></aside>

<p>You may need to sign into your Google account again and accept a set of terms and conditions.<a contenteditable="false" data-primary="Create New Method page in Broad Methods Repository" data-type="indexterm" id="idm45625611944440"/> Find the Create New Method button (which might be renamed to Create New Workflow) to open the workflow creation page. Provide the information as shown in <a data-type="xref" href="#the_create_new_method_page_in_the_broad">Figure 13-5</a>, substituting your own namespace, which can be your username or another identifier that is likely to be unique to you. <a contenteditable="false" data-primary="Workflow Description Language (WDL)" data-secondary="getting HaplotypeCaller workflow file and transferring to Terra workspace" data-type="indexterm" id="idm45625611941800"/>You can get the original WDL file rom the book <a href="https://oreil.ly/GGMoF">GitHub repository</a>; either open the text file and copy the contents into the WDL text box, or use the “Load from file” link to upload it to the repository. By default, the optional Documentation field will be populated using the block of comment text at the top of the WDL file. The Synopsis box allows you to add a one-line summary of what the workflow does, whereas the Snapshot Comment box is intended to summarize what has changed if you upload new versions of the same workflow. You can leave the latter blank.</p>

<figure class="no-frame"><div id="the_create_new_method_page_in_the_broad" class="figure"><img alt="The Create New Method page in the Broad Methods Repository." src="Images/gitc_1305.png" width="1440" height="1281"/>
<h6><span class="label">Figure 13-5. </span>The Create New Method page in the Broad Methods Repository.</h6>
</div></figure>

<p>When you click the Upload button, the system validates the syntax of your WDL (using <code>Womtool</code> under the hood). Assuming that everything is fine, it will create a new workflow entry in the repository under the namespace you provided and present you with a summary page, as shown in <a data-type="xref" href="#summary_page_for_the_newly_created_work">Figure 13-6</a>.</p>

<figure><div id="summary_page_for_the_newly_created_work" class="figure"><img alt="Summary page for the newly created workflow." src="Images/gitc_1306.png" width="1439" height="551"/>
<h6><span class="label">Figure 13-6. </span>Summary page for the newly created workflow.</h6>
</div></figure>

<p>Take a moment to click the Permissions button, which opens a dialog that allows you to share your workflow with specific people, or make it fully public. Feel free to do either of those things as you prefer; just keep in mind that if and when you do share your workspace with others, they will be able to view and run your workflow only if you have done this. That being said, you will be able to come back to this page at a later date to do so if needed. We just bring this up now because we frequently see people run into errors after their collaborator forgot to share a workflow along with their workspace.</p>

<p>Incidentally, the workflow summary page is also what you would see if you had found another workflow in the Methods Repository, either by searching for it or following a link shared by a collaborator. As a result, the following instructions will apply regardless of whether you were the one who created the workflow in the first place.<a contenteditable="false" data-primary="workflows" data-secondary="importing WDL workflow into Terra via Broad Methods Repository" data-startref="ix_wkflimp" data-type="indexterm" id="idm45625611930936"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-startref="ix_wksprecrwkfl" data-tertiary="adding workflow to Methods Repository and importing it into workspace" data-type="indexterm" id="idm45625611929240"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Creating a Configuration Quickly with a JSON File"><div class="sect2" id="creating_a_configuration_quickly_with_a">
<h2>Creating a Configuration Quickly with a JSON File</h2>

<p>After you’re done <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="creating configuration quickly with JSON file" data-type="indexterm" id="ix_wksprecrcfg"/>sharing the <a contenteditable="false" data-primary="JSON" data-secondary="creating workflow configuration quickly with JSON file" data-type="indexterm" id="ix_JSONcfg"/>workflow (or not sharing; we’re not judging), click the <a contenteditable="false" data-primary="workflows" data-secondary="configuring workflow imported into Terra workspace" data-type="indexterm" id="ix_wkflimpcfg"/>Export to Workspace button. If a dialog box opens prompting you to select a method configuration, click the Use Blank Configuration button. In the next dialog box prompting you to select a destination workspace, select your blank workspace in the drop-down menu and click Export to Workspace. Finally, one last dialog box might appear, asking if you want to “go to the edit page now.” Click Yes—and we swear this is the last dialog box. You should now arrive back at the Workflows page in Terra, with your brand-new workflow configuration page in front of you.</p>

<p>Configuring the workflow is going to be fairly straightforward. First, because we’re following the flow of <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>, make sure to select the “Run workflow with inputs defined by file paths” option (located under the workflow documentation summary), which allows you to set up the workflow configuration with file paths rather than using the data tables. Then, turn your attention to the Inputs page, which should be lit up with little orange exclamation marks indicating that some inputs are missing. In fact, all of them are missing because you used a blank configuration and the workflow itself does not specify any default values.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The orange exclamation marks will also show up if you have an input that is badly formatted or of the wrong variable type, like a number instead of a file. Try hovering over one of them to see the error message; all such symbols in Terra generally display me information when you hover over them and can sometimes hold the answer to your problems.</p>
</div>

<p>So you need to plug in the appropriate file paths and parameter values on the Inputs page. You could look up each input value individually in the original workspace and type them manually, but there’s a less tedious way to do it. Can you guess what it is? That’s right, make Jason do all the work. Er, we mean the JSON <em>inputs</em> file, of course. (Yes, that’s a lame joke, but if it helps you remember that you can upload a JSON file of inputs, it will have been worth the shame we’re feeling right now.)</p>

<p>Because we previously ran this same workflow directly through Cromwell in <a data-type="xref" href="ch10.xhtml#running_single_workflows_at_scale_with">Chapter 10</a>, we have <a href="https://oreil.ly/I5Yzl">a JSON file</a> that specifies all the necessary inputs here in the book bucket. You just need to retrieve a local copy of the file and then use the “Drag or click to upload json” option on the Inputs page (right side next to the Search Inputs box) to add the input definitions it contains into your configuration. This should populate all of the fields on the page. Click the Save button and confirm that there are no longer any orange exclamation marks.</p>

<p>At this point, your workflow should be fully configured and ready to run. Feel free to test it by clicking the “Run analysis” button and following the rest of the procedure for monitoring execution as you did previously in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>.</p>

<p>With that, you have successfully imported a WDL workflow into Terra by way of the Broad Methods Repository, and configured it to run on a single sample using the direct file paths configuration option. That’s great because it means that you’re now able to take any WDL workflow you find out in the world and test it in Terra, assuming that you have the correct test data and an example JSON file available.</p>

<p>However, what happens when you’ve successfully tested your workflow and you want to launch it on multiple samples at once? As you learned in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>, that’s where the <a contenteditable="false" data-primary="data tables (Terra)" data-secondary="adding data table to workspace" data-type="indexterm" id="ix_datbl"/>data table comes in. You just reproduced the first exercise in that chapter, which demonstrated that you can run a workflow using paths to the files entered directly in the inputs configuration form. However, to launch the workflow on multiple samples, you need to set up a data table that lists the samples and the corresponding file paths on the workspace’s Data page. Then, you can configure the workflow to run on rows in the data table as you did in the second exercise in that chapter. In the next<a contenteditable="false" data-primary="workflows" data-secondary="configuring workflow imported into Terra workspace" data-startref="ix_wkflimpcfg" data-type="indexterm" id="idm45625611904712"/> section, we show you how to set up<a contenteditable="false" data-primary="JSON" data-secondary="creating workflow configuration quickly with JSON file" data-startref="ix_JSONcfg" data-type="indexterm" id="idm45625611902904"/> your data table.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-startref="ix_wksprecrcfg" data-tertiary="creating configuration quickly with JSON file" data-type="indexterm" id="idm45625611901096"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Adding the Data Table"><div class="sect2" id="adding_the_data_table">
<h2>Adding the Data Table</h2>

<p>Remember that our tutorial workspace <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="adding data table" data-type="indexterm" id="ix_wksprecrDT"/>used an example dataset that resides in a public bucket in GCS, which we manage outside of Terra. The <em>sample</em> table on the Data page listed each sample, identified by a name that is unique within that table, along with the file paths to the corresponding BAM file and its associated index file, each in a column of its own.</p>

<p>So the question is, how do you re-create the <em>sample</em> data table in our blank workspace? What does Terra expect from you? In a nutshell, you need to create a <em>load file</em> in a plain-text format <a contenteditable="false" data-primary="tab-separated values (TSV) format" data-type="indexterm" id="idm45625611892904"/>with tab-separated values. A <a href="https://oreil.ly/lONJL">Terra documentation article</a> goes into more detail, but basically, it’s a spreadsheet that you save in TSV format. It’s reasonably straightforward except for a small twist that often trips people up on their first attempt: the file needs to have a header containing column names, and the first column must be the unique identifier for each row. Here’s a pro tip: rather than trying to create a load file from scratch, you can download an existing one from any workspace that has data tables and use that as a starting point. Here we’re going to be extra lazy and download the table TSV file from the original tutorial workspace, look at it and discuss a few key points, and then upload it as is to our blank workspace.</p>

<p>In the browser tab or window where you opened the original tutorial workspace, navigate to the Data page and click the blue Download All Rows button. This should trigger the download in your browser, and because it’s a very small text file, the transfer should complete immediately. Find the downloaded file and open it in your preferred spreadsheet editor; we’re using Google Sheets.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also use a plain-text editor for viewing the file contents, but we recommend using a spreadsheet editor whenever you modify TSV load tables because it reduces the risk of messing up the tab-delimited format.</p>
</div>

<p>As you can see in <a data-type="xref" href="#a_sample_data_table_from_the_tutorial_w">Figure 13-7</a>, this file contains the raw content from the sample data table in the original workspace, so instead of seeing just <em>father.bam</em> with a hyperlink, for example, we have the full path to where the BAM file resides in the storage bucket. In addition, this table has a header row that contains the names of the columns as displayed in the workspace, with one exception: the name of the first column is preceded by <em>entity</em>: in the file, which is not the case in the workspace. That little detail marks the most important takeaway of this whole section: the column that contains the unique identifier for each row must be the first listed in the load file, and its name must end with the <em>_id</em> suffix. When you upload the load file into Terra, the system will derive the name of the data table itself from the name of that column, by chopping off both the <em>entity</em>: prefix and <em>_id</em> suffix. If you don’t include a column named following that pattern, Terra will reject your table. To be clear, the name that you give to the load file has no effect on the name of the table because it will be created in Terra.</p>

<figure class="no-frame"><div id="a_sample_data_table_from_the_tutorial_w" class="figure"><img alt="A sample data table from the tutorial workspace, viewed in Google Sheets." src="Images/gitc_1307.png" width="1344" height="260"/>
<h6><span class="label">Figure 13-7. </span>A sample data table from the tutorial workspace, viewed in Google Sheets.</h6>
</div></figure>

<p>Let’s try this out in practice. In your blank workspace, navigate to the Data page and click the “+” icon adjacent to TABLES on the DATA menu to bring up the TSV load file import dialog box, as shown in <a data-type="xref" href="#tsv_load_file_import_aright_parenthesis">Figure 13-8</a>. You can drag and drop the file or click the link to open a file browser; use either method as you prefer to upload the TSV file that we were just looking at.</p>

<figure><div id="tsv_load_file_import_aright_parenthesis" class="figure"><img alt="TSV load file import A) button, and B) dialog." src="Images/gitc_1308.png" width="1440" height="538"/>
<h6><span class="label">Figure 13-8. </span>TSV load file import A) button, and B) dialog.</h6>
</div></figure>

<p>If the upload completes successfully, you should now see the sample table listed in the data menu. Click its name to view its content, and compare it to the original: if you didn’t make any changes, it should be identical.</p>

<p>Feel free to experiment with this sample load file to test the behavior of the TSV import function. For example, try modifying the name of the first column and see what happens. You can also try adding more columns with different kinds of content, like plain text, numbers, file paths, and lists of elements (use array formatting, with square brackets and commas to separate elements). And try modifying rows and <span class="keep-together">creating</span> more rows, either by adding rows to the same file or by making a new file with different rows. Just remember that if you’re editing the load file in a spreadsheet editor, as we recommend, you’ll need to make sure to save the file in TSV format.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Many spreadsheet editors (including Microsoft Excel) call this format <em>Tab-delimited Text</em> and will save the file with a <em>.txt</em> extension instead of <em>.tsv</em>, which is absolutely fine; Terra will not care about the extension as long as the contents are formatted correctly.</p>
</div>

<p>If your data page ends up getting a bit messy as a result of this experimentation, don’t worry: you can delete rows or even entire tables; just select the relevant checkboxes (use the checkbox in the header to select an entire table) and click the trashcan icon that appears in the lower right of the window. The one limitation is that it’s not currently possible to delete columns from tables, so if you want to get rid of unwanted columns, you’ll need to delete the entire table and redo the upload procedure. For that reason, it can be a good idea to store versioned copies of what you consider the “good” states of your tables when you’re working on an actual project, especially if you’re planning to add data over time. There isn’t yet any built-in functionality to do that in Terra, so it’s a manual process of downloading the TSV and storing it somewhere (for example, in the workspace bucket), and in another location outside the workspace if you want <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-startref="ix_wksprecrDT" data-tertiary="adding data table" data-type="indexterm" id="idm45625611870632"/>to be extra cautious.<a contenteditable="false" data-primary="data tables (Terra)" data-secondary="adding data table to workspace" data-startref="ix_datbl" data-type="indexterm" id="idm45625611868488"/></p>

<p>After you’re done having fun with the data tables, move on to the resource data in the Workspace Data table.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Filling in the Workspace Resource Data Table"><div class="sect2" id="filling_in_the_workspace_resource_data">
<h2>Filling in the Workspace Resource Data Table</h2>

<p>As you might recall, the<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="filling in workspace resource data table" data-type="indexterm" id="idm45625611864680"/> purpose of this table is to hold <a contenteditable="false" data-primary="data tables (Terra)" data-secondary="filling in workspace resource data table" data-type="indexterm" id="idm45625611862728"/>variables that we might want to use in multiple workflow configurations, like the genome reference sequence file, for example, or the GATK Docker container. This allows you to configure it only once, and just point to the variable in any configuration that needs it. Not only do you not need to ever look up the file path again, but if you decide to update the version or location of the file, you need to do it in only one place. That being said, you might not always want updates to be propagated to every use of a given resource file or parameter setting. When you go to set up your own analysis, be sure to think carefully about how you want to manage common resources and “default” parameters.</p>

<p>In practice, this data table has a very simple structure because it’s all just key:value pairs, and it comes with an easy form-like interface for adding and modifying elements. You can simply use that interface to copy over the contents of the table from the original workspace, if you don’t mind the manual process. Alternatively, you can download the contents of the original in TSV format by clicking the Download All Rows link, and upload that without modification in your workspace using the Upload TSV link. You can even drag the file from your local filesystem into the table area if you prefer. Feel free to experiment and choose the method that suits you best. With that, you’re done setting up the data, so it’s time to get back to the workflow.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Creating a Workflow Configuration That Uses the Data Tables"><div class="sect2" id="creating_a_workflow_configuration_that">
<h2>Creating a Workflow Configuration That Uses the Data Tables</h2>

<p>In your not-so-blank-anymore workspace, navigate back to the Workflows page and look at the configuration listed there, but don’t open it. <a contenteditable="false" data-primary="workflows" data-secondary="imported into Terra workspace, creating configuration that uses data tables" data-type="indexterm" id="ix_wkflimpcfgDT"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="creating workflow configuration that uses data tables" data-type="indexterm" id="ix_wksprecrwkfcfg"/>Click the circle with three vertically stacked dots, which you might by now recognize as the symbol that Terra uses to provide action options for a particular asset, be it a workspace, workflow, or notebook. On the action menu that opens, select “Duplicate workflow” and then give the copy a name that will indicate that it is going to use the data table, as we did in the tutorial workspace.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It’s currently not possible to simply rename a workflow configuration in place. If you want to give the “file paths” version of your workflow configuration a name that is equally explicit as we did in the tutorial workspace, you’ll need to create another duplicate with the name you want and then delete the original.</p>
</div>

<p>Open the copy of the configuration that you want to modify to use the data table, and this time, switch the configuration option to “Process multiple workflows.” On the drop-down menu, select the <em>sample</em> table and choose whether to select a subset of the data or go with the default behavior, which is to run the workflow on all items in the table. Now comes the more tedious part of this exercise, which is to connect the input assignments on the Inputs page to specific columns in the data table or variables in the workspace resource data table. Unfortunately, this time you don’t have a prefilled JSON available as a shortcut, but on the bright side, the Inputs page has an assistive autocomplete feature that speeds up the process considerably. For each variable that needs to be connected (excluding a couple of runtime parameters that we simply leave hardcoded, which you can look up in the original workspace), start typing either <code><strong>workspace</strong></code> or <code><strong>this</strong></code> in the relevant text box. This brings up a contextual menu listing all options from the relevant table: <code>this</code> points to whatever table you selected on the configuration’s drop-down menu, and <code>workspace</code> always points to the workspace resource data, which lists the reference genome sequence, Docker images, and so on.</p>

<p>Another way to use the assistive autocomplete feature on the Inputs page is to start typing part of the input variable name in the corresponding input text box. If the relevant data table column or workspace resource variable was set up with the same name as the input variable, as is the case in our tutorial workspace, this will typically pull up a much shorter list of matching values. For example, typing <code><strong>ref</strong></code> in one of the input fields would bring up only the workspace reference sequence, its index file, and it dictionary file. This approach can be blissfully faster when you’re dealing with a large number of variables, but it is not guaranteed to work for every configuration because it relies on the names matching well enough, which will not always be the case. Some people just want to watch the world burn.</p>

<p>Go ahead and fill out the Inputs page, referring to the original workspace if you become stuck at any point. When you’re done, make sure to click the Save button and confirm that there are no more exclamation marks left, as occurred previously.</p>

<p>What do you think, is this workflow ready to launch or what? What. Meaning, you do have one more configuration task left, which was not applicable in the “file paths” round. Pop over to the Outputs page, which requires you to indicate what you want to do with the workflow outputs. To be clear, this won’t change where the files are written; that is determined for you by the built-in Cromwell server, as you learned in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>. What this does is determine under what <em>column name</em> the outputs will be added to the data table. You can click the “Use defaults” link to simply use the output variable names, or you can specify something different—either a column that already exists, or a new name that the system will use to create a new column. In our workspace, we chose to use the defaults.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625611841800">
<h5>Considerations for Naming Outputs</h5>

<p>Terra will happily overwrite any existing element in the table; the underlying data from any previous runs will still exist in its original location, but the link in the table will be updated to point to the latest result. To compare results from different configurations, you’ll probably want to give your outputs names that indicate which is which. Similarly, watch out for variable names that are overly generic; for example, if you have multiple workflows that produce qualitatively different outputs which are nevertheless all called <code>output_vcf</code>, you’re going to have a bad time.</p>
</div></aside>

<p>Alright, now you’re done. Go ahead and launch the workflow to try it out and then sit back and delight in the knowledge that you’ve just leveled up in a big way. Figuring out how to use the data table effectively is generally considered one of the most challenging aspects of using Terra, and here you are. You’re not an expert yet—that will come when you master the art of using multiple linked data tables, like participants and sample sets—but you’re most of the way there. We cover that in the next scenario, in which you’ll import data from the Terra Data Library into a GATK Best Practices workspace.</p>

<p>Before we get to that, however, we still need to tackle the Jupyter Notebook portion of the tutorial workspace, which we used in <a data-type="xref" href="ch12.xhtml#interactive_analysis_in_jupyter_noteboo">Chapter 12</a>. But don’t worry, it’s going to be mercifully brief—if you take the easy road, that is.<a contenteditable="false" data-primary="workflows" data-secondary="imported into Terra workspace, creating configuration that uses data tables" data-startref="ix_wkflimpcfgDT" data-type="indexterm" id="idm45625611836520"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-startref="ix_wksprecrwkfcfg" data-tertiary="creating workflow configuration that uses data tables" data-type="indexterm" id="idm45625611834936"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Adding the Notebook and Checking the Runtime Environment"><div class="sect2" id="adding_the_notebook_and_checking_the_ru">
<h2>Adding the Notebook and Checking the Runtime Environment</h2>

<p>In your increasingly well-equipped <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="adding Jupyter notebook and checking runtime environment" data-type="indexterm" id="ix_wksprecrJN"/>workspace, navigate<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="adding notebook to workspace and checking runtime environment" data-type="indexterm" id="ix_JNadd"/> to the Notebooks page, and take a guess at what should be your next step. Technically, you have a choice here. You could create a blank new notebook and re-create the original by typing in all the cells. To do that, click the box labeled Create New Notebook, and then, in the dialog that opens, give it a name and select Python 3 as the language. Then, you can work through <a data-type="xref" href="ch12.xhtml#interactive_analysis_in_jupyter_noteboo">Chapter 12</a> a second time, typing the commands yourself instead of just running the cells in the prebaked version as you did last time. Alternatively, you can take the easy road and simply upload a copy of the original notebook, which like everything else is available in the GitHub repository. Specifically, the cleared copy and the previously run copy of the notebook are <a href="https://oreil.ly/jbM8T">here</a>. Retrieve a local copy of the file and use the “Drag or Click to Add an ipynb File” option on the Notebooks page to upload it to your workspace.</p>

<p>Whichever <a contenteditable="false" data-primary="notebook runtime" data-secondary="checking for newly added notebook in workspace" data-type="indexterm" id="idm45625611824088"/>road you choose to take, you don’t need to customize the runtime environment again if you created your workspace under the same billing project as the one you used to work through <a data-type="xref" href="ch12.xhtml#interactive_analysis_in_jupyter_noteboo">Chapter 12</a>, because your runtime is the same across all workspaces within a billing project. Convenient, isn’t it? Perhaps, but it’s also a bit of a cop-out; if you were truly building this workspace from scratch, you would need to go back and follow the instructions in <a data-type="xref" href="ch12.xhtml#interactive_analysis_in_jupyter_noteboo">Chapter 12</a> again to customize the runtime environment. So, enjoy the opportunity to be lazy, but keep in mind that in a different context, you might still need to care about the runtime environment.</p>

<p>When you’re done playing with the notebook(s) in your workspace, take a step back and check that you have successfully re-created all functional aspects of the tutorial workspace. Does it all work? Well done, you! You now know all the basic mechanisms involved in assembling your own workspace from individual components.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-startref="ix_wksprecrJN" data-tertiary="adding Jupyter notebook and checking runtime environment" data-type="indexterm" id="idm45625611819096"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="adding notebook to workspace and checking runtime environment" data-startref="ix_JNadd" data-type="indexterm" id="idm45625611816856"/></p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625611815032">
<h5>Importing Notebooks from Outside of Terra</h5>

<p>Speaking of different context, we’d be remiss if we didn’t address the thus-far-unspoken question: what does it take to adapt an existing notebook from a source outside of Terra? Here we’re taking advantage of importing a notebook that is already set up to use the workspace bucket and all that jazz; but what if we were just grabbing a notebook out of someone’s Binder of Python tutorials? It’s a great question, and one that you’re very likely to face in practice at some point. Again, there is no single one-size-fits-all answer, but you can use the exercises in <a data-type="xref" href="ch12.xhtml#interactive_analysis_in_jupyter_noteboo">Chapter 12</a> to guide you.</p>

<p>Review the key steps that you had to go through in the beginning that involved cloud- or Terra-specific components, like accessing data in GCS using <code>gsutil</code> and setting up an environment variable to easily access the workspace bucket. The steps that have to do with accessing data and saving results are typically the parts of a new-to-you notebook that you need to tweak to work smoothly in the Terra context. For the rest, the work of tweaking the runtime environment to make sure you have the right versions of software packages and libraries is very similar to what you would need to do on a local system, except in Terra you need to decide between making those tweaks from within the notebook, using a startup script, or using a custom container image (which we do not cover in detail in this book).</p>
</div></aside>

</div></section>

<section data-type="sect2" data-pdf-bookmark="Documenting Your Workspace and Sharing It"><div class="sect2" id="documenting_your_workspace_and_sharing">
<h2>Documenting Your Workspace and Sharing It</h2>

<p>The one thing <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-tertiary="documenting workspace and sharing it" data-type="indexterm" id="idm45625611808344"/>you haven’t done yet to match (or outdo) the original tutorial workspace is to fill out the workspace description in the Dashboard, beyond whatever short placeholder you put in there when you created the workspace. If you have a little bit of steam left in you, we encourage you to do that now while your memory is fresh. All it takes is clicking the editing symbol that looks like a pencil on the Dashboard page, which opens up a Markdown editor that includes a graphical toolbar and a split-screen preview mode.</p>

<p>We don’t usually like to say anything is self-explanatory, because that kind of qualifier just makes you feel even worse if you end up struggling with the thing in question, but this one is as close as it gets to deserving that label. Take it for a spin, click all the buttons, and see what happens. Messing around with the workspace description is one of the only things you can do on the cloud that is absolutely free, and in a private clone, it’s completely harmless, so enjoy it. This is also a great opportunity to write up some notes about what you learned in the process of working through the Terra chapters, perhaps even some warnings to your future self about things you struggled with and need to watch out for.</p>

<p>Finally, consider sharing your workspace with a friend or colleague. To do so, click the same circle-with-dots symbol you used to clone the tutorial workspace in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>. This opens a small dialog box in which you can add their email address and set the privileges you want to give them. Click Add User and then be sure to click Save in the lower-right corner. If your intended recipient doesn’t yet have a Terra account, they will receive an email inviting them to join, along with a link to your workspace. They don’t need to have their own billing project if they just want to look at<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="re-creating tutorial workspace from base components" data-startref="ix_wksprecr" data-type="indexterm" id="idm45625611802744"/> the workspace contents.<a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-startref="ix_Terrwksprecr" data-tertiary="re-creating tutorial workspace from base components" data-type="indexterm" id="idm45625611800920"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Starting from a GATK Best Practices Workspace"><div class="sect1" id="starting_from_a_gatk_best_practices_wor">
<h1>Starting from a GATK Best Practices Workspace</h1>

<p>As you just experienced, setting up a new workspace from its base components takes a nontrivial amount of effort.<a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-type="indexterm" id="ix_GBPwksp"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-type="indexterm" id="ix_wkspcrGBP"/><a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-tertiary="starting from a GATK Best Practices workspace" data-type="indexterm" id="ix_TerrwkspGBP"/> Not that it’s necessarily <em>difficult</em>—you probably perform far more complex operations on a daily basis as part of your work—but there are a lot of little steps to follow, so until you’ve done it a bunch of times, you’ll probably need to refer to these instructions or to your own notes throughout the process.</p>

<p>The good news is that there are various opportunities to take shortcuts. For example, if you simply want to run the official GATK Best Practices workflows as provided in the featured workspaces by the GATK support team, you can skip an entire part of this process outright by starting from the relevant workspace. Those workspaces already contain example data and resource data as well as the workflows themselves, fully configured and ready to run. All you really need to do is clone the workspace of interest and add the data that you want to run the workflow(s) on to the data tables.</p>

<p>In this section, we run through that scenario so you can get a sense of what that entails in practice, the potential complications, and your options for customizing the analysis. The lessons from this scenario will generally apply beyond the GATK workspaces, to any case for which you have access to a workspace that is already populated with the basic components of an analysis. We think of this as the “just add water” scenario, which is an attractive model for tool developers to enable researchers to use their tools appropriately and with minimal effort. It’s also a promising model for boosting the computational reproducibility of published papers given that such a workspace constitutes the ultimate methods supplement. We discuss the mechanics and implications of this in more detail in <a data-type="xref" href="ch14.xhtml#making_a_fully_reproducible_paper">Chapter 14</a>. For now, let’s get to work on that GATK Best Practices workspace.</p>

<section data-type="sect2" data-pdf-bookmark="Cloning a GATK Best Practices Workspace"><div class="sect2" id="cloning_a_gatk_best_practices_workspace">
<h2>Cloning a GATK Best Practices Workspace</h2>

<p>We’re going to use the <a href="https://oreil.ly/2I8RE">Germline-SNPs-Indels-GATK4-hg38 workspace</a>, which showcases the GATK Best Practices for short variant discovery implemented as three separate workflows.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-tertiary="cloning Best Practices workspace" data-type="indexterm" id="idm45625611784872"/><a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="cloning GATK Best Practices workspace" data-type="indexterm" id="idm45625611783096"/> The first workflow, named <code>1_Processing_for_Variant_Discovery</code>, takes in raw sequencing data and outputs an analysis BAM file for a single sample. The second, <code>2_HaplotypeCaller_GVCF</code>, takes that BAM file and runs variant calling to produce a single-sample GVCF file. Finally, the third, <code>3_Joint_Discovery</code>, takes multiple GVCF files and applies joint calling to produce a multisample callset for the cohort of interest.</p>

<p>Navigate to that workspace now and clone it as you have done previously with other workspaces. When you’re in your clone, have a quick look around to become acquainted with its contents. You’ll find a detailed description in the Dashboard, three data tables and a set of predefined resources on the Data page, and the three fully configured workflows mentioned earlier on the Workflows page.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Examining GATK Workspace Data Tables to Understand How the Data Is Structured"><div class="sect2" id="examining_gatk_workspace_data_tables_to">
<h2>Examining GATK Workspace Data Tables to Understand How the Data Is Structured</h2>

<p>Let’s take a closer look at<a contenteditable="false" data-primary="data tables (Terra)" data-secondary="examining in GATK Best Practices workspace to understand data structure" data-type="indexterm" id="ix_datblGBP"/> the three data <a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="examining data tables in GATK workspace" data-type="indexterm" id="ix_GBPwkspDT"/>tables on the Data page.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-tertiary="examining data tables in GATK workspace" data-type="indexterm" id="ix_wkspcrGBPdt"/> One table is named <em>participant</em>. It contains a header line showing the name of the single column, <em>participant_id</em>, and a single row, populated by our beloved NA12878, or <em>mother</em> as we call her in this book:</p>

<table class="border" id="table_of_participants">
	<thead>
		<tr>
			<th>participant_id</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>NA12878</td>
		</tr>
	</tbody>
</table>

<p>This identifies her as a study <em>participant</em>; in other words, the actual person from whom biological samples were originally collected to produce the data that we will ultimately analyze.</p>

<p>The <code>participant_id</code> attribute is the unique identifier for the participant and is used to index the table. If you were to add attributes to the table (for example, some phenotype information like the participant’s height, weight, and health status), they would be added as columns to the right of the identifier.</p>

<p>The second table is called <em>sample</em> and contains multiple columns as well as two sample rows below the header. This table is more complicated than the previous one largely because in addition to the minimum inputs required to run the workflow, it contains outputs of previous runs of the workflow. Here is a minimal version of the table without those outputs:</p>

<table class="border" id="table_of_samples_omitting_workflow_outp">
	<thead>
		<tr>
			<th>sample_id</th>
			<th>flowcell_unmapped_bams_list</th>
			<th>participant _id</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>NA12878</td>
			<td>NA12878.ubams.list</td>
			<td>NA12878</td>
		</tr>
		<tr>
			<td>NA12878_small</td>
			<td>NA12878_24RG_small.txt</td>
			<td>NA12878</td>
		</tr>
	</tbody>
</table>

<p>In this table, you see that the leftmost column is <em>sample_id</em>, the unique identifier of each sample, which is used as index value for that table. Jumping briefly to the other end of the table, the rightmost column is <em>participant_id</em>. Can you guess what’s happening here? That’s right, this is how we indicate which sample belongs to which participant. The <em>sample</em> table is linking back to the <em>participant</em> table. This might seem boring, but it’s actually quite important, because by establishing this relationship, we make it possible for the system to follow those references. Using a similar relationship between two tables, we’ll be able to do things like configure a workflow to run on a set of samples to analyze them jointly instead of launching the workflow individually on each sample. If you find that confusing, don’t worry about it now; we discuss it in more detail further down. For now, just remember that these tables are connected to each other.</p>

<p>The middle column, <em>flowcell_unmapped_bams_list</em>, points to sequencing data that has been generated from a biological sample. Specifically, this data is provided in the form of a list of unmapped BAM files that contain sequencing data from individual read groups. As you might recall from <a data-type="xref" href="ch02.xhtml#genomics_in_a_nutshell_a_primer_for_new">Chapter 2</a>, the read groups are subsets of sequence data generated from the same sample in different lanes of the flowcell. The data processing portion of the workflow expects these subsets of data to be provided in separate BAM files so that it can process them separately for the first few steps and then merge the subsets in a single file containing all the data for that sample.</p>

<p>For a given sample, the list of unmapped BAMs will be the primary input to the <em>Processing_for_Variant_Discovery</em> workflow. You can verify this by taking a look at the workflow configuration, where the input variable <code>flowcell_unmapped_bams</code> is set to <code>this.flowcell_unmapped_bams_list</code>. Recall from our <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a> forays into launching workflows on data tables that syntax reads out as “for each row in the table, give the value in the <em>flowcell_unmapped_bams_list</em> column to this variable.” The main output of that workflow will be added under the <em>analysis_ready_bam</em> column, which you can see in the full table in the workspace. That column in turn will serve as the input for the <em>HaplotypeCaller_GVCF</em> workflow, which will then output its contents into the <em>gvcf</em> column.</p>

<p>The two sample rows correspond to two versions of the original whole genome dataset derived from participant <em>NA12878</em>. In the first row, the NA12878 sample is the full-scale dataset, whereas the <em>NA12878_small</em> sample in the second row is a downsampled version, meaning that it contains only a subset of the original data. The purpose of the downsampled version is to run tests more quickly and cheaply.</p>

<p>Finally, the third table is called <em>sample_set</em>, which might or might not sound familiar, depending on how much you paid attention in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>. Do you remember what happened when you ran a workflow on rows in the data table? The system automatically created a row in a new <em>sample_set</em> table, listing the samples on which you had launched the workflow. In this workspace, you can see a sample set called <em>one_sample,</em> with a link labeled <em>1 entity</em> under the <em>samples</em> column, as shown here simplified:</p>

<table class="border" id="table_of_sample_sets_omitting_output_fi">
	<thead>
		<tr>
			<th>sample_set_id</th>
			<th>samples</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>one_sample</td>
			<td>1 entity</td>
		</tr>
	</tbody>
</table>

<p>If you click that, a window opens and displays a list referencing the NA12878 sample. This is another example of a connection between tables, and we’re going to take advantage of this one specifically in a very short while.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The system doesn’t actually show how this sample set was created, but from what we know about the workflows, we can deduce that running either the first or the second workflow in this workspace on the NA12878 sample would replicate the creation of the sample set. Mind you, it’s also possible to create sample sets manually; we show how that works in a little bit.</p>
</div>

<p>What’s interesting here is that the <em>one_sample</em> row in this sample set has output files associated with it, which was not the case when we ran workflows in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>. Can you guess what that might mean? We’ll give you a hint: the <em>output_vcf</em> column contains a VCF of variant calls. Got it? Yes, this is the result of running the <em>Joint_Discovery</em> workflow on the sample set: it took as input the list of samples referenced in the <em>samples</em> column of the sample set, and attached its VCF output to the sample set. This is a somewhat artificial example given that the sample set contains only one sample, so we’ll run this again on a more realistic sample set later in this section in order to give you a more meaningful experience of this logic.</p>

<p>Now that we’ve dissected the data tables in this way, we can summarize the structure of the dataset and the relationships between its component entities. The result, illustrated in <a data-type="xref" href="#visual_representation_of_the_data_model">Figure 13-9</a>, is what we call the <em>data model</em>: Participant NA12878 has two associated Samples, NA12878 and NA12878_small, and one Sample Set references the NA12878 Sample.</p>

<figure><div id="visual_representation_of_the_data_model" class="figure"><img alt="Visual representation of the data model—the structure of the example dataset." src="Images/gitc_1309.png" width="871" height="210"/>
<h6><span class="label">Figure 13-9. </span>The data model—the structure of the example dataset.</h6>
</div></figure>

<p>Note that having a sample identifier that is identical to a participant identifier normally happens only when there is just one sample per participant. In a realistic research context in which a participant has multiple samples associated with it, you would expect to have different identifiers. You would also expect the two sample datasets to have originated from different biological samples or to have been generated using different assays, whereas we know that in this case they originated from the same one. Again, this is due to the somewhat artificial nature of the example data. In the next step of this scenario, we’re going to look at some data that follows more realistic expectations.<a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="examining data tables in GATK workspace" data-startref="ix_GBPwkspDT" data-type="indexterm" id="idm45625611722568"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-startref="ix_wkspcrGBPdt" data-tertiary="examining data tables in GATK workspace" data-type="indexterm" id="idm45625611720856"/><a contenteditable="false" data-primary="data tables (Terra)" data-secondary="examining in GATK Best Practices workspace to understand data structure" data-startref="ix_GBPwksp" data-type="indexterm" id="idm45625611718824"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Getting to Know the 1000 Genomes High Coverage Dataset"><div class="sect2" id="getting_to_know_the_1000_genomes_high_c">
<h2>Getting to Know the 1000 Genomes High Coverage Dataset</h2>

<p>As we discussed<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-tertiary="learning about 1000 Genomes High Coverage dataset" data-type="indexterm" id="ix_wkspcrGBP1KGen"/> earlier, the<a contenteditable="false" data-primary="1000 Genomes High Coverage dataset" data-primary-sortas="One Thousand" data-secondary="getting to know" data-type="indexterm" id="ix_OneThou"/> Data Library <a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="learning about 1000 Genomes High Coverage dataset" data-type="indexterm" id="ix_GBPwksp1KGen"/>provides access to a collection of datasets hosted by various organizations in several kinds of data repositories.<a contenteditable="false" data-primary="Terra Data Library" data-secondary="1000 Genomes High Coverage dataset" data-type="indexterm" id="idm45625611709064"/> Accordingly, the protocol for retrieving data varies depending on the repository. In this exercise, we retrieve data from a repository that hosts a whole-genome dataset of the 2,504 samples from Phase 3 of the 1000 Genomes Project, which were recently resequenced by the New York Genome Center as part of the <a href="https://oreil.ly/Z2vfO">AnVIL project</a>. This particular repository simply consists of a <a href="https://oreil.ly/195yq">public workspace</a> containing only data tables, which serves as a simple but effective form of data repository at this scale.</p>

<p>Go to the 1000 Genomes data workspace now, either by clicking the direct link above or by browsing the Data Library. If you choose the latter route, be aware that there is another 1000 Genomes Project data repository, as shown in <a data-type="xref" href="#the_terra_data_library_contains_two_dif">Figure 13-10</a>, but it’s quite different: that one contains the Low Coverage sequence data for the full 3,500 study participants, whereas we want the new High Coverage sequence data from the 2,504 participants who were included in Phase 3 of the project.</p>

<figure class="no-frame"><div id="the_terra_data_library_contains_two_dif" class="figure"><img alt="The Terra Data Library contains two different repositories of data from the 1000 Genomes Project." src="Images/gitc_1310.png" width="1440" height="837"/>
<h6><span class="label">Figure 13-10. </span>The Terra Data Library contains two repositories of data from the 1000 Genomes Project.</h6>
</div></figure>

<p>When you’re in the workspace, head over to the Data page to check out the data tables. <a contenteditable="false" data-primary="Terra Data Library" data-secondary="different repositories of data from 1000 Genomes Project" data-type="indexterm" id="idm45625611700872"/>You’ll see the same three tables as we described in the GATK workspace: <em>sample</em>, <em>participant</em>, and <em>sample_set</em>. As expected, the <em>participant</em> table lists the 2,504 participants in the dataset. Similarly, the <em>sample</em> table lists the paths to the location of the corresponding sequence data files, which are provided in CRAM format as well as a GVCF file produced by running a <code>HaplotypeCaller</code> pipeline on the sequence data. In addition, both contain a lot of metadata fields that were not present in the GATK workspace, including information about the data generation stage (type of <span class="keep-together">instrumentation</span>, library preparation protocol, etc.) and the population of origin of the study participant. The presence of all this metadata is a big indicator that this is a more realistic dataset, compared to the toy example data in the GATK workspace. Meanwhile, the <em>sample_set</em> table contains a list of all 2,504 samples associated with the sample set name <em>1000G-high-coverage-2019-all</em>.</p>

<p>We can summarize the data model for this dataset as follows: each Participant has a single associated Sample, and there is one Sample Set that references all the Samples, as shown in <a data-type="xref" href="#visual_representation_of_the_data_mode">Figure 13-11</a>.</p>

<figure><div id="visual_representation_of_the_data_mode" class="figure"><img alt="Visual representation of the data model for the 1000 Genomes High Coverage dataset." src="Images/gitc_1311.png" width="668" height="465"/>
<h6><span class="label">Figure 13-11. </span>The data model for the 1000 Genomes High Coverage dataset.</h6>
</div></figure>

<p>At this point, we <a contenteditable="false" data-primary="data models" data-secondary="for 1000 Genomes High Coverage dataset, visual representation of" data-type="indexterm" id="idm45625611690552"/>have a confession to make: all this time we’ve spent looking at the data tables of the two workspaces wasn’t mere data tourism. It all had a very specific purpose, to answer the unspoken question that you might or might not have seen coming: will their data models be compatible?</p>

<p>And the good news is yes, they seem to be compatible, meaning that you can combine their data tables without causing a conflict, and you should be able to run a <em>federated data analysis</em> across samples from both datasets. <a contenteditable="false" data-primary="federated data analysis" data-type="indexterm" id="idm45625611687656"/>Admittedly the degree of federation here is not really meaningful because only one person’s genomic information is in the GATK workspace, but the underlying principle will apply equally to other datasets that you might want to bring together into a single workspace.</p>

<p>Now that we’re satisfied that we should be able to use the data in our workspace, let’s figure out how to actually perform the transfer of information.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-startref="ix_wkspcrGBP1KGen" data-tertiary="learning about 1000 Genomes High Coverage dataset" data-type="indexterm" id="idm45625611685544"/><a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="learning about 1000 Genomes High Coverage dataset" data-startref="ix_GBPwksp1KGen" data-type="indexterm" id="idm45625611683816"/><a contenteditable="false" data-primary="1000 Genomes High Coverage dataset" data-primary-sortas="One Thousand" data-secondary="getting to know" data-startref="ix_OneThou" data-type="indexterm" id="idm45625611681752"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Copying Data Tables from the 1000 Genomes Workspace"><div class="sect2" id="copying_data_tables_from_the_1000_genom">
<h2>Copying Data Tables from the 1000 Genomes Workspace</h2>

<p>There are two main ways to do this: a point-and-click approach, and a load file–based approach. <a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="copying data tables from 1000 Genomes workspace" data-type="indexterm" id="idm45625611677944"/><a contenteditable="false" data-primary="data tables (Terra)" data-secondary="copying data tables from 1000 Genomes workspace" data-type="indexterm" id="idm45625611676424"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-tertiary="copying data tables from 1000 Genomes workspace" data-type="indexterm" id="idm45625611675016"/><a contenteditable="false" data-primary="1000 Genomes High Coverage dataset" data-primary-sortas="One Thousand" data-secondary="copying data tables from workspace" data-type="indexterm" id="idm45625611673304"/>Let’s begin with the point-and-click approach because it abstracts away some of the complexity involved in using load files.</p>

<p>On the Data page of the 1000 Genomes High Coverage workspace, click the <em>sample</em> table and choose a few samples by selecting their <span class="keep-together">corresponding</span> checkboxes on the left. Locate and click the three-dots symbol above the table to open the action menu (as you did in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a> to configure data inputs for the workflow) and select “Export to Workspace” as shown in <a data-type="xref" href="#the_copy_data_to_workspace_dialog_boxdo">Figure 13-12</a>.</p>

<figure class="no-frame"><div id="the_copy_data_to_workspace_dialog_boxdo" class="figure"><img alt="The Copy Data to Workspace dialog box." src="Images/gitc_1312.png" width="1440" height="452"/>
<h6><span class="label">Figure 13-12. </span>The Copy Data to Workspace dialog box.</h6>
</div></figure>

<p>This should open a dialog box with the list of samples and a workspace selection menu. Select your clone of the GATK workspace and then click Copy. Keep in mind that despite what the buttons seem to imply, we’re not going to copy over any files; we just want to copy over the metadata in the data tables, which include the paths to the locations of the files in GCS. So, rest assured you’re not suddenly going to be on the hook for a big data storage bill.</p>

<p>You should see a confirmation message that asks you whether you want to stay where you are (in the 1000 Genomes workspace) or go to where you copied the data (the GATK workspace). Select the latter option so we can go look at what the transfer produced. If everything worked as expected, you should see the samples you selected listed in the <em>sample</em> table. However, you will not see the corresponding participants listed in the <em>participant</em> table, because the system does not automatically copy over the data from other tables to which the selected data refers. The only exceptions to this are sets, like the sample sets we’ve been working with. If you select a set and copy that over, the system will also copy over the contents of the set. If you also want to copy over the participants, you need to do it as a separate step, either by selecting the rows of interest using the checkboxes or by defining a participant set using a load file.</p>

<p>If you play around with the “copy data to workspace” functionality a little bit, you will quickly realize that this approach is fairly limiting for dealing with large datasets. Why? Because when you try to select all rows in a table, even using the checkbox in the upper-left corner of the table, the system really selects only the items that are displayed on the page. Because the maximum allowed for that is one hundred items, the set approach is your only option for copying over more than one hundred samples at a time using the point-and-click approach.</p>

<p>So now let’s try the load file–based approach, which has some advantages if you are working with large datasets or need to tweak something before copying over the data.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Using TSV Load Files to Import Data from the 1000 Genomes Workspace"><div class="sect2" id="using_tsv_load_files_to_import_data_fro">
<h2>Using TSV Load Files to Import Data from the 1000 Genomes Workspace</h2>

<p>Technically, you’ve<a contenteditable="false" data-primary="1000 Genomes High Coverage dataset" data-primary-sortas="One Thousand" data-secondary="using TSV load files to import data from 1000 Genomes workspace" data-type="indexterm" id="ix_OneThouimp"/> already<a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="using TSV load files to import data from 1000 Genomes workspace" data-type="indexterm" id="ix_GBPwkspTSV"/> done this—that’s <a contenteditable="false" data-primary="tab-separated values (TSV) format" data-secondary="using TSV load files to import data from 1000 Genomes workspace" data-type="indexterm" id="ix_TSVs"/>how we had <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-tertiary="using TSV load files to import data from 1000 Genomes workspace" data-type="indexterm" id="ix_wkspcrGBPTSV"/>you copy over the data table from the original book tutorial workspace to re-create your own earlier in this chapter. You selected the table, clicked the Download All Rows button, retrieved the downloaded file, and then uploaded it to the new workspace. Boom. All our samples are belong to you.</p>

<p>However, this time there’s a twist: several data tables are involved, and some of them have references to the others. As a result, there’s going to be an order of precedence: you must start with the table that doesn’t have any references to the others because Terra can’t handle references to things that it hasn’t seen defined yet. For example, you can’t upload a sample set before having uploaded the samples to which the sample set refers. This is an annoying limitation, and you could imagine having the system simply create a stand-in for any reference to something that it doesn’t recognize. Yet we need to work with the system in its current state, so the bottom line is this: order matters; deal with it.</p>

<p>In practice, for this exercise, you need to download the TSVs for the three data tables from the 1000 Genomes workspace, as previously described (in any order), and then upload them in the correct order to your GATK workspace clone. What is the correct order, you ask? Here’s a hint: look at the visual representation of the data model in <a data-type="xref" href="#visual_representation_of_the_data_mode">Figure 13-11</a> and use the direction of the arrows to inform your decision. What do you think? That’s right, you first upload the participants, then the samples, and then the sample set. Go ahead and do that now.</p>

<p>Oh wait, did you encounter something you didn’t expect while doing that? Indeed: there are <em>two</em> load files for the sample set: one that defines the table itself and names the sample sets that it contains, identified as <em>entity:sample_set_id</em>, and one that lists the members that each sample set contains, identified as <em>membership:sample_set_id</em>. Have a look at their contents to get a sense of how they relate to each other. And relate they do; because the membership TSV refers to the name of the sample set defined in the entity TSV, you’ll need to upload the entity list first, then the membership list.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Dealing with load files and the precedence rules is one of the more awkward, and frankly tedious, parts of setting up data in Terra. We expect that future developments will address this by providing some kind of wizard-style functionality to smooth out the sharp edges.</p>
</div>

<p>On the bright side, after you’re done with that, you should see all 2,504 samples from the 1000 Genomes dataset listed in your GATK workspace as well as their <span class="keep-together">corresponding</span> participants. However, there’s a problem. Can you see it? Take a good look at the columns in the sample table. Most of the columns were different between the two original tables, of course, because the GATK workspace version mainly had output files from the workflows that are showcased in the workspace, and the 1000 Genomes workspace version mainly had metadata about the provenance of the data. However, they were supposed to have one thing in common: GVCF files. Can you find them? Yes, they do all have GVCF files—but they’re in different columns.</p>

<p>In the original GATK workspace, the name of the column containing the GVCF files was <em>gvcf</em> in all lowercase, whereas in the 1000 Genomes workspace it was <em>gVCF</em> in mixed case. Incidentally, the columns containing their respective index files are also named with subtle differences, <em>gvcf_index</em> versus <em>gVCF_TBI</em>, where TBI refers to the extension of the index format generated by a utility called Tabix.</p>

<p>Well, shucks. We were going to surprise you by saying, “Look, now you can run a joint calling analysis of your NA12878 sample combined with all of the 1000 Genomes Phase 3 data. Isn’t that cool?” But it’s not going to work if the GVCF files are in different columns (sad face Emoji).</p>

<p>Chin up; this is fixable. You still have the TSV files that you used to upload the 1000 Genomes data tables, right? Just open the <em>sample</em> TSV file and rename the two columns to match the corresponding names in the GATK workspace. No need to change anything else, just those two column names. Then, upload the TSV and see what happens: now the GVCF files from the 1000 Genomes samples and their index files also show up in the right columns. Crisis averted! The old columns with the mismatching names are still there, but you can ignore them. Literally, in fact; you can hide them (and any others you don’t care about) to reduce the visual clutter. Simply click the gear icon in the upper-right corner of the table to open the table display menu. You can clear the checkboxes for the column names to hide them and even reorder them to suit your preferences.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It’s admittedly a little annoying that you can’t simply edit column names in place or delete unwanted columns. The import dialog box feels a bit limited, as well—we would love to be able to preview the data and get a summary count of rows and columns, for example, before confirming the import operation. We’re looking forward to seeing these aspects of the interface improve as Terra matures.</p>
</div>

<p>Fortunately, we were able to get past this trivial little naming mismatch by editing just two column names. However, minor as it might seem, this stumbling block is symptomatic of a much larger problem: there is not enough standardization around how datasets are structured and how their attributes are named. Almost any attempt to federate datasets from different sources can quickly turn into an exercise in frustration as you find yourself battling conflicting schemas and naming conventions. There is no universal solution (yet), but when you encounter this kind of issue, it can be helpful to start by reducing the problem to the smallest set of components that need to be reconciled. For example, try to define the core data model of each dataset; that is, determine the key pieces of data and how they relate to one another. From there, you can gauge what it would take to make the datasets compatible to the extent that you need them to be.</p>

<p>In our case, we now have what we need: all our samples are defined in the sample table and have a GVCF file listed in the <em>gvcf</em> column as well as a corresponding index file in the <em>gvcf_index</em> column. Anything else is irrelevant to what we want to do next, which<a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="using TSV load files to import data from 1000 Genomes workspace" data-startref="ix_GBPwkspTSV" data-type="indexterm" id="idm45625611631848"/> is to apply<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-startref="ix_wkspcrGBPTSV" data-tertiary="using TSV load files to import data from 1000 Genomes workspace" data-type="indexterm" id="idm45625611629896"/> joint calling<a contenteditable="false" data-primary="tab-separated values (TSV) format" data-secondary="using TSV load files to import data from 1000 Genomes workspace" data-startref="ix_TSVs" data-type="indexterm" id="idm45625611627672"/> to all the samples<a contenteditable="false" data-primary="1000 Genomes High Coverage dataset" data-primary-sortas="One Thousand" data-secondary="using TSV load files to import data from 1000 Genomes workspace" data-startref="ix_OneThouimp" data-type="indexterm" id="idm45625611625800"/> in the workspace.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Running a Joint-Calling Analysis on the Federated Dataset"><div class="sect2" id="running_a_joint_calling_analysis_on_the">
<h2>Running a Joint-Calling Analysis on the Federated Dataset</h2>

<p>To cap off this <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-tertiary="running joint-calling analysis on federated dataset" data-type="indexterm" id="ix_wkspcrGBPJCA"/>scenario, we’re going<a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="running joint-calling analysis on federated dataset" data-type="indexterm" id="ix_GBPwkspJCA"/> to run<a contenteditable="false" data-primary="joint-calling analysis, running on federated dataset" data-type="indexterm" id="ix_JCA"/> the <em>3_Joint_Discovery</em> workflow that is preconfigured in this workspace, which applies the GATK Best Practices for joint-calling germline short variants on a cohort of samples as described in <a data-type="xref" href="ch06.xhtml#best_practices_for_germline_short_varia">Chapter 6</a>. We’re going to run it on a subset of the samples for testing purposes, but we’ll provide pointers for scaling up the analysis in case you want to try running it on all the samples. In any case, the workflow will produce a multisample VCF containing variant calls for the set of samples that we choose to include.</p>

<p>As we admitted earlier, calling this a <em>federated dataset</em> is a bit of an exaggeration given that we’re really adding just one sample to the 1000 Genomes Phase 3 data. However, the principles we’re discussing would apply equally if you were now to add more samples to this workspace. For example, you might want to use the 1000 Genomes data to pad your analysis of a small cohort in order to maximize the benefits you can get from doing joint calling, as is recommended in the GATK documentation.</p>

<p>The workflow is already configured, so let’s have a look at what it expects. Go to the Workflow page and click the <em>3_Joint_Discovery</em> workflow to view the configuration details. First, we’re going to look at which table the workflow is configured to run on. The data selection drop-down menu shows Sample Set, which means that we’ll need to provide a sample set from the <em>sample_set</em> table. That table currently holds two sample sets; one that lists the NA12878 sample alone, and the other that lists the full 1000 Genomes Phase 3 cohort that we imported into the workspace. We need a sample set that lists some samples from the 1000 Genomes cohort and the NA12878 sample from the GATK workspace, so let’s create one now.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We’re going to use 25 samples because that is how much data the predefined configuration of the workflow can accommodate; we’ll provide guidance for scaling up once we’ve completed the test at this scale.</p>
</div>

<p>To quickly create a test sample set, set the data table selector to <em>sample_set</em> under Step 1, and click Select Data under Step 2. In the dialog box that opens up, select the “Create a new set from selected samples” option. You can select the checkboxes of individual samples or select the checkbox at the top of the column to select all 25 samples that are displayed by default. When you’ve selected the samples, you can use the box labeled “Selected samples will be saved as a new set named” to specify a name for the sample set or leave the default autogenerated name as is. Press OK to confirm and return to the workflow configuration page. Note that, at this point, you haven’t actually created the new sample set; you’ve just set up the system to create it when you press the Launch button.</p>

<p>But don’t press the button yet! We want to show you another way to create a sample set, not just because we have a mean streak (we do), but also to equip you to deal with more-complex situations.</p>

<p>The interface for creating sets can be too limiting when you’re working with a lot more samples than can be displayed on a single screen, so we’re also going to show you how to use the manual TSV approach to do this. This is going to be a two-step process, similar to what you did earlier: create a new sample set using an <em>entity</em> load file and then provide a list of its members using a <em>membership</em> load file. The first one is really minimal because it’s just the one column header, <em>entity:sample_set_id</em>, and the name of the new sample set in the next row, as shown here:</p>

<table class="border" id="a_simple_table_for_a_sample_set">
	<thead>
		<tr>
			<th>entity:sample_set_id</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>federated-dataset</td>
		</tr>
	</tbody>
</table>

<p>You can save this as a TSV file and upload it to your workspace as previously, or you can take advantage of the alternative option illustrated in <a data-type="xref" href="#direct_text_import_of_tsv_formatted_dat">Figure 13-13</a>, which involves copying and pasting the two rows into a text field. Annoyingly, it’s not possible to type text directly into this text box or edit what you paste in, but it does cut out a few clicks from the import process.</p>

<figure class="width-75 no-frame"><div id="direct_text_import_of_tsv_formatted_dat" class="figure"><img alt="Direct text import of TSV-formatted data table content." src="Images/gitc_1313.png" width="1441" height="1179"/>
<h6><span class="label">Figure 13-13. </span>Direct text import of TSV-formatted data table content.</h6>
</div></figure>

<p>Uploading that content creates a new row in the <em>sample_set</em> table, but the new sample set has no samples associated with it yet. To remedy that, we need to make a <em>membership</em> TSV file containing the list of samples that we want to run on. We like to start from existing data tables because it reduces the chance that we’ll get something wrong, especially those finicky header lines. To do so, download the TSV files corresponding to the sample set table and open the <em>sample_set_membership.tsv</em> file in your spreadsheet editor. As shown in <a data-type="xref" href="#start_and_end_rows_of_the_membership_lo">Figure 13-14</a>, you should see the full list of 1000 Genomes samples in the second column, with the name of the original 1000 Genomes sample set displayed in the first column of each row. If you scroll all the way to the end of the file, you’ll also see the NA12878 sample from the GATK workspace, which is assigned to the <em>one_sample</em> set.</p>

<figure class="width-75 no-frame"><div id="start_and_end_rows_of_the_membership_lo" class="figure"><img alt="Start and end rows of the membership load file sample_set_membership.tsv." src="Images/gitc_1314.png" width="1216" height="588"/>
<h6><span class="label">Figure 13-14. </span>Start and end rows of the membership load file sample_set_membership.tsv.</h6>
</div></figure>

<p>We’re going to take a subset of this and transform it into a membership list that associates the samples we choose with our newly created sample set, <em>federated-dataset</em>. Start by deleting all but 24 of the samples that belong to the 1000 Genomes cohort from the list, so that you’re left with 25 samples in total in the list. It doesn’t matter which samples you keep. Then, use the Find and Replace or Rename function of your editor (typically found on the Edit menu) to change the sample set name in the first column to <em>federated-dataset</em> for all rows, as demonstrated in <a data-type="xref" href="#updated_membership_load_file_sample_set">Figure 13-15</a>. Make sure to also replace the sample set name for the NA12878 sample. Then, save and upload the file as you’ve done previously.</p>

<figure class="width-75 no-frame"><div id="updated_membership_load_file_sample_set" class="figure"><img alt="Updated membership load file sample_set_membership.tsv assigning 25 samples to the federated-dataset sample set." src="Images/gitc_1315.png" width="1256" height="602"/>
<h6><span class="label">Figure 13-15. </span>Updated membership load file sample_set_membership.tsv assigning 25 samples to the federated-dataset sample set.</h6>
</div></figure>

<p>After you’ve uploaded this membership list, the <em>sample_set</em> table should now list the 25 samples as belonging to the <em>federated-dataset</em> sample set, as shown in <a data-type="xref" href="#the_sample_set_table_showing_the_three">Figure 13-16</a>.</p>

<figure class="width-75 no-frame"><div id="the_sample_set_table_showing_the_three" class="figure"><img alt="The sample_set table showing the three sample sets." src="Images/gitc_1316.png" width="1440" height="516"/>
<h6><span class="label">Figure 13-16. </span>The sample_set table showing the three sample sets.</h6>
</div></figure>

<p>By the way, this shows you that you can add or modify rows by uploading TSV content for just the parts of the table you want to update or augment. You don’t need to reproduce the full table every time. We feel this makes up a bit for not being able to just create the sample sets in the graphical interface.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In case you’re wondering why we’re including only the full-scale <em>NA12878</em> sample from the GATK workspace and not the downsampled <em>NA12878_small</em> sample, it’s because they come from the same original person so it would be redundant to use both. Because the downsampled one has less data, it’s less likely to produce meaningful results, hence that’s the one we eliminate.</p>
</div>

<p>Now that we have a sample set that lists all of the samples that we want to use in our analysis, we can proceed with the next step. Select the checkbox on the left of the <em>federated-dataset</em> row in the <em>sample_set</em> table and then click the “Open with” button, select Workflow, and finally, select <em>3_Joint_Discovery</em> to initiate the workflow submission. As we’ve shown you previously, you can choose to kick off the process from a selection of data on the Data page like this, or you can do it from the Workflows page, as you prefer. The advantage of doing it as we just described is that now your workflow is already set to run on the right sample set; otherwise, you would need to use the Select Data menu to do it when you get to the configuration page.</p>

<p>At this point, all that remains for us to do is check the remainder of the configuration, starting with the Inputs. There are a lot of input fields so we’re not going to look at all of them; instead, let’s focus on the main file inputs. Based on what you learned about joint calling in <a data-type="xref" href="ch06.xhtml#best_practices_for_germline_short_varia">Chapter 6</a>, you should have an idea of what kind of input variable you’re looking for: one that refers to a list of GVCFs. Sure enough, if you scroll down a bit, you’ll find the workflow variable named <em>input_gvcfs</em>, as shown in <a data-type="xref" href="#input_configuration_details_for_the_inp">Figure 13-17</a>. The <em>Type</em> of the variable is <em>Array[File]</em>, which means the workflow expects us to provide a list of files as input, so that checks out. You also see a corresponding variable set up for the list of index files.</p>

<figure class="no-frame"><div id="input_configuration_details_for_the_inp" class="figure"><img alt="Input configuration details for the input_gvcfs and input_gvcfs_indices variables." src="Images/gitc_1317.png" width="1440" height="186"/>
<h6><span class="label">Figure 13-17. </span>Input configuration details for the input_gvcfs and input_gvcfs_indices variables.</h6>
</div></figure>

<p>Now if you look at the value provided in the rightmost column of the input configuration panel, you see <em>this.samples.gvcf</em>. That should seem both familiar and new at the same time. Familiar because it appears to be a variation of the <em>this.something</em> syntax that we’ve seen and used previously, which allows us to say, “For each row of the table that the workflow runs on, give the content of the <em>something</em> column to this input variable.” We used this previously when launching the <code>HaplotypeCaller</code> workflow on multiple samples for parallel execution; this syntax allowed us to easily wire up the <em>input_bam</em> variable to take the input BAM file for each workflow invocation, without having to specify any files explicitly.</p>

<p>Yet it’s also a bit new because it includes an extra element, forming a <em>this.other.something</em> syntax. Can you guess what’s going on there? This is really cool; it’s the payoff from establishing the connections between tables that we mentioned earlier in the chapter. This syntax is basically saying, “For each sample set, look up the list in its <em>samples</em> column, and then go to the <em>sample</em> table and round up all the GVCF files from the corresponding rows.” You can use this <em>.other.</em> element to refer to any list of rows from another table, query them for a particular field, and return a list of the corresponding elements. And that is how we generate the list of input GVCF files based on the list of samples linked in the sample set. As a bonus, the order in which the list is made is consistent, so we can assign <em>this.samples.gvcf</em> and <em>this.samples.gvcf_index</em> to two different variables, and rest assured that the lists of GVCF files and their index files will be in the same sample order.</p>

<p>This is one of the key benefits of having a well-designed data model in place; you can take advantage of the relationships between data entities at different levels. You can even daisy-chain them several levels deep; there is theoretically no limit to how many <em>.other.</em> lookups you could do. For more examples of what you can do along these lines, check out the data model used in the somatic Best Practices workspaces, where each participant has a tumor sample and a normal sample. In that data model, one additional table lists the Tumor-Normal pairs and another lists sets of pairs.</p>

<p>Feel free to scroll through the rest of the Inputs configuration page. Then, when you feel like you have a good grasp of how the inputs are wired up, head over to the Outputs for one last check before you launch the workflow. The outputs are all set up along a <em>this.output_*</em> pattern, and you should see a line that says, “References to outputs will be written to Tables / sample_set,” which tells you that the final VCF and related output files will be attached to the sample set. This makes sense because by definition the results of a joint calling analysis pertain to all of the samples that are included.</p>

<p>Finally, go ahead and launch the workflow. You can monitor the execution and explore results the same way as in previous exercises. On 25 samples, our test run of the workflow cost $10 and took about 10 hours (with a couple of preemptions) to run to completion. The longest-running step by far was <code>ImportGVCFs</code>, which ran for about three hours per parallelized segment of the genome and spent half that time in the file localization stage. That’s a classic indication that this step would strongly benefit from being optimized to stream data. The other long-running task that is parallelized, <code>GenotypeGVCFs</code>, took about one hour per parallelized segment. Finally, the variant recalibration step, which is not parallelized, took about two hours.</p>

<p>We recommend running this again with a few cohort sizes and comparing the timing diagram for the various runs in order to understand how the time and cost of this workflow scale, depending on the number of samples. You’ll need to create new sample sets by following the same instructions as earlier, but keeping however many samples you’re interested in. Be sure to give each sample set a different name and do the entity TSV step to add it to the table; otherwise, it will just update the sample set you originally created. If you choose to run the workflow on a larger number of samples than the 25 we’ve tested so far, you’ll need to make a few configuration changes according to the instructions in the workspace dashboard, under the <em>3_Joint_Discovery</em> workflow input requirements. In a nutshell, you’ll need to allocate more disk space to account for the larger number of sample GVCFs that will need to be localized, using the disk override input variables.</p>

<p>The truth of the matter is that this version of the joint discovery workflow suffers from key scaling inefficiencies, including that it does not use streaming, as we pointed out a moment ago, and does not automatically handle resource allocation scaling. We used it for this exercise because it’s conveniently available and fully supported by the GATK support team. Frankly, it’s a great way to observe the consequences of inefficiencies that might seem small individually but would cause substantial difficulties at the scale of thousands of samples. However, we do not recommend attempting to run it on the full cohort—in fact, we wouldn’t advise going above a few hundred samples until you’ve at least run some preliminary scale testing to gauge how the workflow time and cost increase with the number of samples.</p>

<p>If you need something that scales better out of the box, an <a href="https://oreil.ly/WI0NE">alternative version of this workflow</a> is supposed to scale better, but as of this writing, it has not gone through the GATK support team’s publishing process, so it is not officially supported. In addition, its input requirements do not allow you to run it directly on the data tables in your workspace because it expects a sample map file that lists sample names and GVCF files as shown in <a href="https://oreil.ly/mpFnK">this example</a> (but with multiple lines, one for each sample). To get past this obstacle, you could make such a file based on the <em>sample</em> table in your workspace and add it as a property of the sample set, or if you’re feeling adventurous, you could even write a short WDL task that would run before the main workflow. We leave this as the proverbial exercise for the reader.</p>

<p>This scenario started out with the goal of illustrating a few shortcuts that you can take when assembling a workspace to run GATK Best Practices, but in the process, you also picked up some bonus nuggets of knowledge: what to watch out for when combining data from different origins, how to set up an analysis on the resulting federated dataset, and how a well-crafted data model empowers you to pull together data across different levels. To cap it all off, you ran a complex analysis across a cohort of multiple whole-genome samples without breaking a sweat. Nicely done.</p>

<p>For our last scenario of the chapter, we’re going to flip the order of operations and see how that affects our workspace-building process.<a contenteditable="false" data-primary="joint-calling analysis, running on federated dataset" data-startref="ix_JCA" data-type="indexterm" id="idm45625611548504"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-startref="ix_wkspcrGBPJCA" data-tertiary="running joint-calling analysis on federated dataset" data-type="indexterm" id="idm45625611547032"/><a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-secondary="running joint-calling analysis on federated dataset" data-startref="ix_GBPwkspJCA" data-type="indexterm" id="idm45625611545016"/><a contenteditable="false" data-primary="GATK Best Practices workspace, creating new workspace from" data-startref="ix_GBPwksp" data-type="indexterm" id="idm45625611543288"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="creating, starting from GATK Best Practices workspace" data-startref="ix_wkspcrGBP" data-type="indexterm" id="idm45625611541864"/><a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-startref="ix_TerrwkspGBP" data-tertiary="starting from a GATK Best Practices workspace" data-type="indexterm" id="idm45625611540184"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Building a Workspace Around a Dataset"><div class="sect1" id="building_a_workspace_around_a_dataset">
<h1>Building a Workspace Around a Dataset</h1>

<p>So far, we’ve been <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="building workspace around a dataset" data-type="indexterm" id="ix_wkspbldDS"/>taking a very <a contenteditable="false" data-primary="datasets" data-secondary="building a Terra workspace around a dataset" data-type="indexterm" id="ix_DSetwksp"/>tool-first <a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-tertiary="building workspace around a dataset" data-type="indexterm" id="ix_Terrwkspdaset"/>approach in our scenarios, mainly because our primary focus is on teaching you how to work with a certain range of tools within the cloud computing framework offered by GCP and Terra. Accordingly, our guiding pattern has been to set up tools and then bring in data. However, we recognize that in practice, many of you will follow a data-first approach: bring in data and then figure out how to apply various tools.</p>

<p>In this last scenario, we’re going to walk through an example of what that would look like applied to the same 1000 Genomes dataset that we used in the previous scenario. This time, instead of cloning the GATK workspace and pulling in the 1000 Genomes data from the library, we’re going to clone the 1000 Genomes workspace and pull in a GATK workflow from the public tool repository Dockstore.</p>

<section data-type="sect2" data-pdf-bookmark="Cloning the 1000 Genomes Data Workspace"><div class="sect2" id="cloning_the_1000_genomes_data_workspace">
<h2>Cloning the 1000 Genomes Data Workspace</h2>

<p>Navigate <a contenteditable="false" data-primary="1000 Genomes High Coverage dataset" data-primary-sortas="One Thousand" data-secondary="cloning the workspace" data-type="indexterm" id="idm45625611528376"/>back to the 1000 Genomes High Coverage dataset workspace in the Data Library<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="building workspace around a dataset" data-tertiary="cloning 1000 Genomes High Coverage dataset workspace" data-type="indexterm" id="idm45625611526408"/> and clone it as you’ve done previously, specifying a name and a billing project. As we discussed at the beginning of this chapter, <em>cloning</em> a workspace makes a shallow copy of its contents, which means that the data files in the bucket will not be copied to the clone. The clone’s data tables will simply point to the original file locations; you can assure yourself that this is true by looking up the file locations in the clone and in the original. This is equivalent to the result of the copy operation we performed in the previous scenario, first by using the data copy option in the interface, and then by repurposing the original workspace’s TSV load files.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In your clone, feel free to replace some or all of the description in the Dashboard with a link to the original to make space for your own notes.</p>
</div>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Importing a Workflow from Dockstore"><div class="sect2" id="importing_a_workflow_from_dockstore">
<h2>Importing a Workflow from Dockstore</h2>

<p>Now the question<a contenteditable="false" data-primary="Dockstore, importing workflow into Terra from" data-type="indexterm" id="ix_Dkstwkfl"/> becomes how<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="building workspace around a dataset" data-tertiary="importing workflow from Dockstore" data-type="indexterm" id="ix_wkspbldDSimp"/> do we get some <a contenteditable="false" data-primary="workflows" data-secondary="importing workflow from Dockstore into Terra" data-type="indexterm" id="ix_wkflDckst"/>workflows in to analyze this data? As usual in Terra, you have a few options, depending on what you’re trying to achieve. First, you could simply use the internal Methods Repository as you did previously—either put in your own workflow or browse the public section to see if you can find a workflow you like. However, the internal Methods Repository is used only by people who do their work in Terra, so it’s probably missing a lot of interesting workflows that are developed by others in the wider biomedical community.</p>

<p>Another option is to simply copy over a workflow from another workspace; for example, you could grab the <em>3_Joint_Discovery</em> workflow from the GATK Best Practices workspace (either the original or the clone you used in the previous scenario) by using the “Copy to another workspace” option in the workspace actions menu (circle icon with stacked dots). However, that again limits you to workflows that have already been brought into Terra. In practice, you will likely find some interesting workflows outside of Terra, so we’re going to show you how to import workflows from Dockstore, an increasingly popular registry targeted at the biomedical community that supports workflows written in WDL, CWL, and Nextflow.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625611512088">
<h5>Introducing the Dockstore Repository</h5>

<p><em>Dockstore</em> is a public workflow registry developed and operated by the University of California, Santa Cruz, and Ontario Institute for Cancer Research (OICR) intended as a place for workflow authors to publish their workflows for use by the wider community. This is similar to the way code is released on GitHub or a Docker image is published on DockerHub; in fact, Dockstore uses both under the hood. In a nutshell, publishing a workflow in Dockstore consists mainly of linking a GitHub repository where the workflow code resides and providing metadata about the workflow and its inputs. Similarly, registering a container image for a tool involves linking a repository in DockerHub or Quay.io. To learn more about how to publish your own tool containers and workflows in Dockstore, see the <a href="https://docs.dockstore.org">extensive online documentation</a>.</p>
</div></aside>

<p>In your clone of the 1000 Genomes workspace, navigate to the Workflows page and click the Find a Workflow button, as you’ve done previously. This time, instead of choosing the internal Methods Repository, select the Dockstore option. This takes you to the Dockstore website, where you’ll be able to browse a collection of WDL workflows. On the lefthand menu, you should see a search box that says “Enter search term.” Type <code><strong>joint discovery</strong></code> and view the list of results in the righthand panel (there is no button to press), which will include several GATK workflows, as shown in <a data-type="xref" href="Images/#search_results_for_quotjoint_discoveryq">Figure 13-18</a>.</p>

<figure class="no-frame"><div id="search_results_for_quotjoint_discoveryq" class="figure"><img alt="Search results for &quot;joint discovery&quot; in Dockstore." src="Images/gitc_1318.png" width="1439" height="733"/>
<h6><span class="label">Figure 13-18. </span>Search results for “joint discovery” in Dockstore.</h6>
</div></figure>

<p>Some of the workflows listed in the results are different versions of the same workflow, registered separately for historical reasons. Unfortunately, the information summarized in the list of search results does not provide a way to easily differentiate between them, so you might sometimes need to click through to the detailed descriptions to understand how they differ.</p>

<p>Find the workflow called <a href="https://oreil.ly/Kfndw"><em>gatk-workflows/gatk4-germline-snps-indels/joint-discovery-gatk4</em></a> and click through to its detailed information page. This workflow’s name and description should feel at least a little bit familiar because this is actually the source of the <em>3_Joint_Discovery</em> workflow that you used in the previous scenario. The code itself is in GitHub, in one of the repositories under the gatk-workflows organization used by the GATK support team to publish official GATK workflows. If you click the Versions tab on the workflow details page, you can see a list of code development branches and releases from the GitHub repository. There should be one version tagged as <em>default</em> by the person who registered the workflow, which amounts to them saying, “Unless you know otherwise, this is the version you should use.”</p>

<p>It can sometimes be interesting to look at this to see whether the workflow you’re interested in is under active development; for example, in this case, as of this writing, we see that the default was set to version 1.1.1 in May 2019, yet recent work was done in a development branch as recently as January 2020. Perhaps those changes will have been released by the time you read this, and a new default version will have been set.</p>

<p>You can explore the various other tabs for yourself, but we’d like to point out a couple more that we find especially useful in addition to those we’ve already reviewed. The first is the Files tab, which references the WDL source file under Descriptor Files, and a JSON file of inputs under Test Parameter Files. This is boring now, but it will come in handy later. The other tab we really like is the DAG tab, which stands for <em>directed acyclic graph</em> and refers to the workflow graph. This offers you an interactive visualization of the workflow akin to what you generated with <code>Womtool</code> in <a data-type="xref" href="ch09.xhtml#deciphering_real_genomics_workflows">Chapter 9</a>, though the display is slightly different, as you can see in <a data-type="xref" href="Images/#visualization_of_the_joint_discovery_wo">Figure 13-19</a>. By default, this just shows tasks in the workflow, which is a pretty neat way to get a high-level view of how the workflow is wired up without looking at the WDL code. There is also an option to switch to a different visualization tool made by a company called EPAM, which provides a much more granular view that includes inputs and outputs. This is very cool for a deep dive, but the amount of detail can be a bit overwhelming.</p>

<figure><div id="visualization_of_the_joint_discovery_wo" class="figure"><img alt="Visualization of the Joint Discovery workflow provided in the DAG tab in Dockstore." src="Images/gitc_1319.png" width="1440" height="1100"/>
<h6><span class="label">Figure 13-19. </span>The Joint Discovery workflow provided in the DAG tab in Dockstore.</h6>
</div></figure>

<p>When you’re done exploring the workflow details in the Dockstore interface, look for the box in the right menu labeled “Launch with,” which offers you several options for running the workflow, including Terra. Click the Terra button to return to Terra with the workflow in your pocket. In the import screen that asks you which workspace you want to put it in, select your clone of the 1000 Genomes workspace. You will land on the configuration page of the newly imported workflow in your workspace.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="building workspace around a dataset" data-startref="ix_wkspbldDSimp" data-tertiary="importing workflow from Dockstore" data-type="indexterm" id="idm45625611492200"/><a contenteditable="false" data-primary="workflows" data-secondary="importing workflow from Dockstore into Terra" data-startref="ix_wkflDckst" data-type="indexterm" id="idm45625611490248"/><a contenteditable="false" data-primary="Dockstore, importing workflow into Terra from" data-startref="ix_Dkstwkfl" data-type="indexterm" id="idm45625611488504"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Configuring the Workflow to Use the Data Tables"><div class="sect2" id="configuring_the_workflow_to_use_the_dat">
<h2>Configuring the Workflow to Use the Data Tables</h2>

<p>The Inputs page <a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="building workspace around a dataset" data-tertiary="configuring workflow to use data tables" data-type="indexterm" id="idm45625611485384"/>will be completely <a contenteditable="false" data-primary="workflows" data-secondary="importing workflow from Dockstore into Terra" data-tertiary="configuring workflow to use data tables" data-type="indexterm" id="idm45625611483544"/>bare, so the first <a contenteditable="false" data-primary="data tables (Terra)" data-secondary="configuring workflow imported from Dockstore to use" data-type="indexterm" id="idm45625611481624"/>thing we recommend doing is uploading the example JSON file of inputs that was listed on the Files tab in Dockstore. Yes, this is why we mentioned that boring tab. Unfortunately, currently there is no way to have Terra import that file along with the workflow itself (obvious feature request right there, folks), so you’ll need to download a copy and then upload it to your workflow configuration using the Upload a JSON option. When the upload is complete, save the configuration and check that there are no remaining error indicators (orange exclamation marks) on the Inputs page. Make sure you select the option to run the workflow directly on file paths and then try running the imported workflow to make sure that everything works out of the box.</p>

<p>Assuming the test run completes successfully, you’re going to need to reconfigure the inputs to point to the data tables instead of direct file paths. This can be the most difficult part of the process, because you must figure out which inputs need to be plugged into the data tables, which ones make sense to move to the workspace resources table, and which one to just leave in the configuration. A good rule of thumb for figuring out the first set is to look at the workflow documentation for a description of its input requirements. There won’t always be one in the workflows you find out in the field, but when there is one, it’s usually highly illuminating with regard to what you should consider to be the main inputs of the workflow. In the case of this particular workflow, you should know what to wire up because we just spent a good chunk of this chapter poking at it, so go do that now. If you get stumped, remember that you can look at the original GATK workspace for a model of what you’re aiming for.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Regarding what’s appropriate to move to the workspace resources table, it’s really just a matter of judgment and preference because there is no real technical difference as far as Terra is concerned. You could simply decide to leave everything in the workflow until you import another workflow and realize they utilize the same resources, and plan to move the relevant resources over to the workspace data table at that time.</p>
</div>

<p>When you have the configuration set up, you’ll need to define a sample set by following the same instructions as we gave you in the previous scenario. In fact, at this point, all the remaining work is almost exactly the same as the last two sections of the previous scenario, so we don’t feel the need to walk you through every step again; we’re confident that you can do it on your own. Good luck!</p>

<p>Finally, if you’re feeling a bit short-changed because we made you import the same workflow as in the previous section, here’s a suggestion for a stretch assignment to flex your new muscles on a new-to-you workflow. Sometimes, you might want to redo the GVCF calling step if enough has changed in the algorithms or the supporting resources (e.g., if there is a new reference genome build), but the sequencing data files provided with the 1000 Genomes High Coverage dataset are all in CRAM format, which the GATK team does not yet recommend using for direct data access when using streaming. As a result, you need to find either a CRAM-to-BAM conversion workflow to run as a preprocessing step, or a GATK <code>Haplotype-Caller</code> workflow that starts with a built-in CRAM-to-BAM conversion task. That should ring a bell if you paid attention in <a data-type="xref" href="ch09.xhtml#deciphering_real_genomics_workflows">Chapter 9</a>.</p>

<p>So go ahead and try finding the appropriate workflow or combination of workflows to achieve that with the 1000 Genomes data, using the various approaches and resources we’ve given you over the past few <span class="keep-together">chapters</span>. If you get really stuck, let us know by posting an issue in the <a href="https://oreil.ly/genomics-repo">GitHub repository</a>, and we’ll help you work through it. If a lot of people report difficulties with the stretch assignments, we’ll consider posting step-by-step solutions in the blog.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="building workspace around a dataset" data-startref="ix_wkspbldDS" data-type="indexterm" id="idm45625611470472"/><a contenteditable="false" data-primary="datasets" data-secondary="building a Terra workspace around a dataset" data-startref="ix_DSetwksp" data-type="indexterm" id="idm45625611468808"/><a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-startref="ix_Terrwkspdaset" data-tertiary="building workspace around a dataset" data-type="indexterm" id="idm45625611467064"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Wrap-Up and Next Steps"><div class="sect1" id="wrap_up_and_next_steps-id00010">
<h1>Wrap-Up and Next Steps</h1>

<p>In this chapter, you learned how to assemble your own workspace in Terra from data and code components originating from various sources, both internal and external to Terra. We put a lot of emphasis on thinking about how datasets are structured in order to empower you to take advantage of the power of linked data tables in Terra and to combine data from different sources in general. You practiced importing data from the Data Library and running a federated analysis that included data from the 1000 Genomes Project, setting the stage for large-scale analyses. You also learned to import workflows from Dockstore, a tool and workflow repository that can connect to several other platforms besides Terra. At this point, you have all the necessary foundations to be able to assemble and execute your own scalable analysis from publicly or privately available tools and datasets on the cloud. In <a data-type="xref" href="ch14.xhtml#making_a_fully_reproducible_paper">Chapter 14</a>, the final chapter, we walk through an example of a workspace that reproduces an end-to-end analysis from a published paper to illustrate current capabilities, obstacles, and perspectives for achieving optimal computational reproducibility in biomedical research.<a contenteditable="false" data-primary="Terra platform" data-secondary="assembling your own workspace" data-startref="ix_Terrwksp" data-type="indexterm" id="idm45625611461192"/></p>
</div></section>
</div></section></div>



  </body></html>