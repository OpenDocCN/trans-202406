["```\nCallbacks.requestData(data -> Log.d(\"MyApp\", \"result received: \" + data));\n\n```", "```\nCallbacks.requestData { data-> Log.d(\"MyApp\", \"result received: $data\") }\n\n```", "```\nprivate void handleResult(Object data) {\n  Log.d(\"MyApp\", \"result received: \" + data);\n}\n...\nCallbacks.requestData(this::handleResult);\n\n```", "```\nprivate fun handleResult(data: Any?) {\n  Log.d(\"MyApp\", \"result received: $data\")\n}\n...\nCallbacks.requestData(::handleResult)\n\n```", "```\nCallbacks.requestData(new Callback(Object data) {\n  Log.d(\"MyApp\", \"result received: \" + data);\n});\n\n```", "```\nvar someClosure = { print(\"I'm a closure!\") }\nsomeClosure() // Executes our closure, which prints out a message to the console\n```", "```\nclass NetworkService {\n\tvar completion: ((Bool, Error?) -> ())?\n\n\tfunc fetchData(for url: URL) {\n\t\t...\n\t}\n\tfunc onSuccess() {\n\t\tcompletion?(true, nil)\n\t}\n\tfunc onError(error: Error) {\n\t\tcompletion?(false, error)\n\t}\n}\n\nlet api = NetworkService()\napi.completion = { success, error in\n\tif success {\n\t\tprint(\"Success!\")\n\t} else {\n\t\tprint(\"Uh-oh!\")\n\t}\n}\napi.fetchData()\n```", "```\nclass Incrementor {\n    var count = 0\n\n    func increment() {\n        count += 1\n        print(count)\n    }\n}\n\nlet incrementor = Incrementor()\nlet closure = {\n    incrementor.increment() // 1\n    incrementor.increment() // 2\n}\nclosure() // Prints \"1\\n2\"\n```", "```\nclass Incrementor {\n    var count = 0\n\n    func increment(with closure: () -> ()) {\n        count += 1\n        closure()\n    }\n}\n\nlet incrementor = Incrementor()\nlet printCount = {\n    print(incrementor.count)\n}\n\nincrementor.increment(with: printCount) // 1\nincrementor.increment(with: printCount) // 2\n```", "```\nclass Incrementor {\n    var count = 0\n    var printingMethod: (() -> ())?\n\n    func increment(with closure: () -> ()) {\n        if printingMethod == nil {\n            printingMethod = closure\n        }\n        count += 1\n        printingMethod?()\n    }\n}\n\nlet incrementor = Incrementor()\nlet printCount = {\n    print(incrementor.count)\n}\n\nincrementor.increment(with: printCount)\nincrementor.increment(with: printCount)\n```", "```\nfunc increment(with closure: @escaping () -> ()) {\n\tif printingMethod == nil {\n\t\tprintingMethod = closure\n\t}\n\tcount += 1\n\tprintingMethod?()\n}\n```", "```\nclass Incrementor {\n    var count = 0\n    var printingMethod: (() -> ())?\n\n    func increment(with closure: @escaping () -> ()) {\n        if printingMethod == nil {\n            printingMethod = closure\n        }\n        count += 1\n        printingMethod?()\n    }\n}\n\nlet incrementor = Incrementor()\nlet printCount = {\n    print(incrementor.count)\n}\n\nincrementor.increment(with: printCount)\nincrementor.increment(with: printCount)\n```", "```\nlet printCount = { [weak incrementor] in\n    guard let incrementor = incrementor else { return }\n    print(incrementor.count)\n}\n```", "```\nprotocol NetworkServiceDelegate: class {\n\tfunc fetchDidComplete(success: Bool, with error: Error?)\n}\n\nclass NetworkService {\n\tweak var delegate: NetworkServiceDelegate?\n\n\tfunc fetchData(for url: URL) {\n\t\t...\n\t}\n\tfunc onSuccess() {\n\t\tdelegate?.fetchDidComplete(success: true, with: nil)\n\t}\n\tfunc onError(error: Error) {\n\t\tdelegate?.fetchDidComplete(success: false, with: error)\n\t}\n}\n\nclass APIClient {\n\tinit() {\n\t\tlet api = NetworkService()\n\t\tapi.delegate = self\n\t\tapi.fetchData()\n\t}\n}\nextension APIClient: NetworkServiceDelegate {\n\tfunc fetchDidComplete(success: Bool, with error: Error?) {\n\t\tif success {\n\t\t\tprint(\"Success!\")\n\t\t} else {\n\t\t\tprint(\"Uh-oh!\")\n\t\t}\n\t}\n}\n```", "```\nNotificationCenter.default.post(name: Notification.Name(\"didFinish\"), object: nil)\n```", "```\nclass SomeObject {\n\tpublic static let didFinishNotification = Notification.Name(\"didFinish\")\n}\n\nNotificationCenter.default.post(name: SomeObject. didFinishNotification, object: nil)\n```", "```\nNotificationCenter.default\n    .post(name: SomeObject. didFinishNotification, object: nil, userInfo:\n    [\"downloadCount\": 3])\n```", "```\nlet anObject = SomeObject()\nlet count = 3\n\nNotificationCenter.default\n    .post(name: SomeObject. didFinishNotification, object: nil, userInfo:\n    [\"someObject\": anObject, \"downloadCount\": count])\n```", "```\nclass SomeObject {\n\t...\n}\n\n// Use an extension to encapsulate your notification code\nextension SomeObject {\n\tpublic static let didFinishNotification =\n      Notification.Name(\"SomeObjectDidFinishNotification\")\n\tpublic static let didFinishNotificationObjectKey = \"someObjectKey\"\n\tpublic static let didFinishNotificationDownloadCountKey = \"downloadCount\"\n}\n\nNotificationCenter.default\n    .post(name: SomeObject. didFinishNotification, object: nil,\n    userInfo: [SomeObject. didFinishNotificationObjectKey: anObject,\n    SomeObject. didFinishNotificationDownloadCountKey: count])\n```", "```\nclass SomeObject {\n\tfunc listenForNotifications() {\n\t\t// Subscribe to the notification\n\t\tNotificationCenter.default\n        .addObserver(self, selector: #selector(didFinishDownload(_:)),\n        name: SomeObject.didFinishNotification, object: nil)\n\t}\n\n\t@objc func didFinishDownload(_ notification: Notification) {\n\t\t// Get the notification payload\n\t\tlet downloadCount =\n       notification.userInfo?[SomeObject.didFinishNotificationDownloadCountKey]\n\t\tprint(downloadCount)\n\t}\n}\n```", "```\nclass SomeObject {\n\tprivate var observer: AnyObject?\n\n\tfunc listenForNotifications() {\n\t\t// Subscribe to the notification\n\t\tself.observer = NotificationCenter.default\n      .addObserver(forName: SomeObject.didFinishNotification, object: nil,\n      queue: nil) { notification in\n  let downloadCount =\n    notification.userInfo?[SomeObject.didFinishNotificationDownloadCountKey]\n    print(downloadCount)\n\t\t}\n\t}\n}\n```", "```\n// Selector style\nNotificationCenter.default.removeObserver(self)\n\n// Closure style\nNotificationCenter.default.removeObserver(observer)\nself.observer = nil\n```", "```\nNotificationCenter.default\n    .removeObserver(self, name: SomeObject.didFinishNotification, object: nil)\n```", "```\nlet objectToObserve = SomeObject()\n\n// You will only receive notifications that objectToObserve posts\nNotificationCenter.default\n    .addObserver(self, selector: #selector(didFinishDownload(_:)),\n    name: SomeObject.didFinishNotification, object: objectToObserve)\n\nThere a few different types of combinations available, for example:\n\n// Receive all notifications from specificed object\nNotificationCenter.default\n    .addObserver(self, selector: #selector(didFinishDownload(_:)),\n    name: nil, object: objectToObserve)\n\n// Receive all didFinishNotification notifications from all objects\nNotificationCenter.default\n    .addObserver(self, selector: #selector(didFinishDownload(_:)),\n    name: SomeObject.didFinishNotification, object: nil)\n\n// Receive all notifications from all objects (don't do this)\nNotificationCenter.default\n    .addObserver(self, selector: #selector(didFinishDownload(_:)),\n    name: nil, object: nil)\n```", "```\nclass SomeObject {\n\t...\n\n\t@objc func listenForNotifications(_ notification: Notification) {\n\t\tDispatchQueue.main.async {\n\t\t\tupdateUI()\n\t\t}\n\t}\n}\n```"]