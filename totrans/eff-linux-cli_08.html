<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Parents, Children, and Environments"><div class="chapter" id="ch_parent_child">
<h1><span class="label">Chapter 6. </span>Parents, Children, and Environments</h1>


<p><a data-type="indexterm" data-primary="shell" id="shell6"/>
The purpose of the shell—to run commands—is so fundamental to
Linux that you might think the shell is built into Linux in some
special way. It is not. A shell is just an ordinary program like <code>ls</code>
or <code>cat</code>. It is programmed to repeat the following steps over and over
and over and over…</p>
<ol>
<li>
<p>Print a prompt.</p>
</li>
<li>
<p>Read a command from stdin.</p>
</li>
<li>
<p>Evaluate and run the command.</p>
</li>

</ol>

<p>Linux does a great job of hiding the fact that a shell is an ordinary
program. When you log in, Linux automatically runs an instance of the
shell for you, known as your <em>login shell<a data-type="indexterm" data-primary="login shell" id="idm46586640330416"/></em>.<a data-type="indexterm" data-primary="shell" data-secondary="login" id="idm46586640329552"/> It launches so seamlessly
that it appears to <em>be</em> Linux, when really it’s just a program
launched on your behalf to interact with Linux.</p>
<div data-type="note" epub:type="note"><h1>Where Is Your Login Shell?</h1>
<p>If you log in at a nongraphical terminal, say, using an<a data-type="indexterm" data-primary="SSH" data-secondary="login shell" id="idm46586640326544"/> SSH client
program, the login shell is the initial shell you interact with. It
prints the first prompt and awaits your command.</p>

<p>Alternatively, if you’re at the computer’s console with a graphical
display, your login shell runs behind the scenes. It launches a
desktop environment<a data-type="indexterm" data-primary="desktop environment" data-secondary="launching" id="idm46586640324688"/> such as GNOME<a data-type="indexterm" data-primary="GNOME" id="idm46586640323584"/>, Unity<a data-type="indexterm" data-primary="Unity" id="idm46586640322752"/>, Cinnamon<a data-type="indexterm" data-primary="Cinnamon" id="idm46586640321920"/>, or
KDE Plasma<a data-type="indexterm" data-primary="KDE Plasma" id="idm46586640321088"/>. Then you can open terminal windows to run additional interactive shells.</p>
</div>

<p>The more you understand about the shell, the more effectively you can
work with Linux and the fewer superstitions you’ll develop about its
inner workings. This chapter explores the following mysteries of
shells more deeply than <a data-type="xref" href="ch02.xhtml#ch_shell">Chapter 2</a> did:</p>

<ul>
<li>
<p>Where shell programs are located</p>
</li>
<li>
<p>How different shell instances may be related to each other</p>
</li>
<li>
<p>Why different shell instances may have the same variables, values, aliases,
and other context</p>
</li>
<li>
<p>How to change a shell’s default behavior by editing configuration files</p>
</li>
</ul>

<p>By the end, I hope you’ll find that these mysteries aren’t so
mysterious after all.</p>






<section data-type="sect1" data-pdf-bookmark="Shells Are Executable Files"><div class="sect1" id="section_shell_executable">
<h1>Shells Are Executable Files</h1>

<p><a data-type="indexterm" data-primary="shell" data-secondary="ordinary program" id="idm46586640311952"/>
The default shell on most Linux systems is <code>bash</code>,<sup><a data-type="noteref" id="idm46586640310240-marker" href="ch06.xhtml#idm46586640310240">1</a></sup><a data-type="indexterm" data-primary="bash" data-secondary="default shell" data-tertiary="most Linux systems" id="idm46586640308816"/> and it’s an ordinary
program—an executable file—located in the system directory
<em>/bin</em> alongside <code>cat</code>, <code>ls</code>, <code>grep</code>, and other familiar commands:</p>

<pre data-type="programlisting">$ <strong>cd /bin</strong>
$ <strong>ls -l bash cat ls grep</strong>
-rwxr-xr-x 1 root root 1113504 Jun  6  2019 bash
-rwxr-xr-x 1 root root   35064 Jan 18  2018 cat
-rwxr-xr-x 1 root root  219456 Sep 18  2019 grep
-rwxr-xr-x 1 root root  133792 Jan 18  2018 ls</pre>

<p><code>bash</code> is also not the only shell on your system, most likely. Valid
shells are usually listed, one per line, in the file <em>/etc/shells</em>:<a data-type="indexterm" data-primary="/etc/shells file" id="idm46586640302592"/><a data-type="indexterm" data-primary="/etc/shells file" data-primary-sortas="etc shells" id="idm46586640301856"/></p>

<pre data-type="programlisting">$ <strong>cat /etc/shells</strong>
/bin/sh
/bin/bash
/bin/csh
/bin/zsh</pre>

<p>To see which shell you’re running, <code>echo</code> the shell variable <code>SHELL</code>:<a data-type="indexterm" data-primary="shell" data-secondary="SHELL variable" id="idm46586640298480"/><a data-type="indexterm" data-primary="variables" data-secondary="SHELL" id="idm46586640297472"/></p>

<pre data-type="programlisting">$ <strong>echo $SHELL</strong>
/bin/bash</pre>

<p>In theory, a Linux system can treat <em>any program</em> as a valid login
shell, if a user account is configured to invoke it on login and it’s
listed in <em>/etc/shells</em> (if required on your system). With superuser
privileges, you can even write and install your own shell, like the
script in <a data-type="xref" href="#ex_halshell">Example 6-1</a>.<a data-type="indexterm" data-primary="halshell script" id="idm46586640292832"/><a data-type="indexterm" data-primary="shell" data-secondary="halshell example" id="idm46586640292128"/> It reads any command and responds,
“I’m sorry, I’m afraid I can’t do that.”  This custom shell is
intentionally silly, but it demonstrates that other programs can be
just as legitimate a shell as <em>/bin/bash</em>.</p>
<div id="ex_halshell" data-type="example">
<h5><span class="label">Example 6-1. </span>halshell: A shell that refuses to run your commands</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="c1"># Print a prompt</code>
<code class="nb">echo</code> -n <code class="s1">'$ '</code>
<code class="c1"># Read the user's input in a loop. Exit when the user presses Ctrl-D.</code>
<code class="k">while</code> <code class="nb">read</code> line<code class="p">;</code> <code class="k">do</code>
 <code class="c1"># Ignore the input $line and print a message</code>
 <code class="nb">echo</code> <code class="s2">"I'm sorry, I'm afraid I can't do that"</code>
 <code class="c1"># Print the next prompt</code>
 <code class="nb">echo</code> -n <code class="s1">'$ '</code>
<code class="k">done</code></pre></div>

<p>Since <code>bash</code> is just a program, you can run it manually like any other
command:<a data-type="indexterm" data-primary="bash" data-secondary="running manually" id="idm46586640271728"/></p>

<pre data-type="programlisting">$ <strong>bash</strong></pre>

<p>If you do so, you’ll just see another prompt, as if your command had
no effect:</p>

<pre data-type="programlisting">$</pre>

<p>But really, you have run a new instance of <code>bash</code>. This new
instance prints a prompt and awaits your command. To make the new
instance more visible, change its prompt (say, to <code>%%</code>) by setting the
shell variable <code>PS1</code>,<a data-type="indexterm" data-primary="PS1 variable" id="idm46586640263216"/><a data-type="indexterm" data-primary="variables" data-secondary="PS1" id="idm46586640262480"/><a data-type="indexterm" data-primary="prompt" data-secondary="changing" id="idm46586640261536"/> and run some commands:</p>

<pre data-type="programlisting">$ <strong>PS1="%% "</strong>
%% <strong>ls</strong>                                 <em>The prompt has changed</em>
animals.txt
%% <strong>echo "This is a new shell"</strong>
This is a new shell</pre>

<p>Now run <code>exit</code><a data-type="indexterm" data-primary="exit command" id="idm46586640257408"/><a data-type="indexterm" data-primary="builtins" data-secondary="exit" id="idm46586640256704"/> to terminate the new instance of <code>bash</code>. You’ll
return to the original shell, which has a dollar-sign prompt:</p>

<pre data-type="programlisting">%% <strong>exit</strong>
$</pre>

<p>I must emphasize that the change from <code>%%</code> back to <code>$</code> was not a
prompt change. It was a whole shell change. The new instance of <code>bash</code>
has ended, so the original shell prompts you for the next command.</p>

<p>Running <code>bash</code> by hand is not just for entertainment value. You’ll use
manually invoked shells to your advantage in <a data-type="xref" href="ch07.xhtml#ch_running_commands">Chapter 7</a>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Parent and Child Processes"><div class="sect1" id="section_parent_child_processes">
<h1>Parent and Child Processes</h1>

<p>When one instance of the shell invokes another, as I just
demonstrated, the original shell is called the <em>parent</em><a data-type="indexterm" data-primary="parent process" id="idm46586640221648"/><a data-type="indexterm" data-primary="process" data-secondary="parent versus child" id="idm46586640221152"/> and the new
instance is called the <em>child</em>.<a data-type="indexterm" data-primary="child process" id="idm46586640219792"/> The same is true for any Linux program
that invokes any other Linux program. The invoking program is the
parent, and the invoked program is its child. A running Linux program
is known as a <em>process<a data-type="indexterm" data-primary="process" id="idm46586640218800"/></em>, so you’ll also see the terms <em>parent process</em>
and <em>child process</em>. A process can invoke any number of children, but
each child has only one parent.</p>

<p>Every process has its own environment.<a data-type="indexterm" data-primary="environment" data-secondary="process" id="idm46586640217040"/> An environment, which you
might recall from <a data-type="xref" href="ch02.xhtml#section_environments1">“Environments and Initialization Files, the Short Version”</a>, includes a current
directory, search path, shell prompt, and other important information
held in shell variables.  When a child is created, its environment is
largely a copy of its parent’s environment. (I’ll explain more in
<a data-type="xref" href="#section_environment_variables">“Environment Variables”</a>.)</p>

<p><em>Every time you run a simple command, you create a child
process</em>.<a data-type="indexterm" data-primary="child process" data-secondary="creation" id="idm46586640213408"/> This is such an important point for understanding Linux that
I’ll say it again: even when you run a simple command like <code>ls</code>, that
command secretly runs inside a new child process with its own
(copied) environment. That means any changes you make to a child,<a data-type="indexterm" data-primary="environment" data-secondary="changes to" id="idm46586640211600"/> like
changing the prompt variable <code>PS1</code><a data-type="indexterm" data-primary="PS1 variable" id="idm46586640210240"/><a data-type="indexterm" data-primary="variables" data-secondary="PS1" id="idm46586640209536"/> in a child shell, affect only the
child and are lost when the child exits. Likewise, any changes to the
parent won’t affect its children that are already running. Changes to
the parent <em>can</em> affect its <em>future</em> children, however, because each
child’s environment is copied from its parent’s environment on
startup.</p>

<p>Why does it matter that commands run in child processes? For one
thing, it means that any program you run can <code>cd</code> all over the
filesystem, but when it exits, your current shell (the parent) has not
changed its current directory. Here’s a quick experiment to
prove it. Create a shell script called <code>cdtest</code> in your home directory
containing a <code>cd</code> command:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="nb">cd</code> /etc
<code class="nb">echo</code> <code class="s2">"Here is my current directory:"</code>
<code class="nb">pwd</code></pre>

<p>Make it executable:</p>

<pre data-type="programlisting">$ <strong>chmod +x cdtest</strong></pre>

<p>Print your current directory name and then run the script:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/home/smith
$ <strong>./cdtest</strong>
Here is my current directory:
/etc</pre>

<p>Now check your current directory:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/home/smith</pre>

<p>Your current directory hasn’t changed, even though the <code>cdtest</code> script
traveled to the <em>/etc</em> directory. That’s because <code>cdtest</code> ran inside a
child process with its own environment. Changes to the child’s
environment cannot affect the parent’s environment, so the parent’s
current directory did not change. The same thing happens when you run
an executable program like <code>cat</code> or <code>grep</code>—it runs in a child process
that exits after the program terminates, taking any environment changes
with it.</p>
<div data-type="note" epub:type="note"><h1>Why cd Must Be a Shell Builtin</h1>
<p>If Linux programs cannot change your shell’s current directory, then
how<a data-type="indexterm" data-primary="cd command" data-secondary="why a shell builtin" id="idm46586640182944"/><a data-type="indexterm" data-primary="builtins" data-secondary="cd" id="idm46586640181968"/> does the command <code>cd</code> manage to change it? Well, <code>cd</code> isn’t a
program. It’s a built-in feature of the shell (a.k.a. a shell
builtin). If <code>cd</code> were a program external to the shell, directory
changes would be impossible—they would run in a child process and be
unable to affect the parent.</p>
</div>

<p>Pipelines<a data-type="indexterm" data-primary="pipes" data-secondary="pipelines" data-tertiary="child processes" id="idm46586640178992"/><a data-type="indexterm" data-primary="child process" data-secondary="pipelines launching" id="idm46586640177712"/> launch multiple child processes: one for each command in the
pipeline.  This command from the section <a data-type="xref" href="ch01.xhtml#section_uniq">“Command #6: uniq”</a> launches six

<span class="keep-together">children:</span></p>

<pre data-type="programlisting">$ <strong>cut -f1 grades | sort | uniq -c | sort -nr | head -n1 | cut -c9</strong></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Environment Variables"><div class="sect1" id="section_environment_variables">
<h1>Environment Variables</h1>

<p><a data-type="indexterm" data-primary="environment variables" id="idm46586640172304"/><a data-type="indexterm" data-primary="variables" data-secondary="environment" data-see="environment variables" id="idm46586640171440"/><a data-type="indexterm" data-primary="environment variables" data-secondary="local variables versus" id="idm46586640170224"/><a data-type="indexterm" data-primary="local variables" data-secondary="environment variables versus" id="idm46586640154688"/>
Every instance of the shell has a collection of variables, as you learned in
<a data-type="xref" href="ch02.xhtml#section_variables">“Evaluating Variables”</a>. <a data-type="indexterm" data-primary="variables" data-secondary="local" data-see="local variables" id="idm46586640152976"/>Some variables are local to a single shell. They
are called <em>local variables<a data-type="indexterm" data-primary="local variables" id="idm46586640151504"/></em>. Other variables are automatically
copied<a data-type="indexterm" data-primary="variables" data-secondary="copied from parent to child" id="idm46586640150768"/>
from a given shell to each child it invokes. These variables are called
<em>environment variables</em>,<a data-type="indexterm" data-primary="environment variables" data-secondary="definition" id="idm46586640149408"/> and they
collectively form the shell’s environment.<a data-type="indexterm" data-primary="environment" data-secondary="shell" id="idm46586640148400"/> Some examples
of environment variables and their uses are:</p>
<dl>
<dt><code>HOME</code></dt>
<dd>
<p>  The path to your home directory.<a data-type="indexterm" data-primary="home directory" data-secondary="HOME variable" id="idm46586640145376"/><a data-type="indexterm" data-primary="variables" data-secondary="HOME" id="idm46586640144400"/><a data-type="indexterm" data-primary="directory" data-secondary="home directory" data-tertiary="HOME variable" id="idm46586640143456"/> Its value is set automatically by
your login shell when you log in. Text editors like <code>vim</code> and <code>emacs</code>
read the variable <code>HOME</code> so they can locate and read their
configuration files<a data-type="indexterm" data-primary="configuration files" data-secondary="text editors" id="idm46586640140832"/> (<em>$HOME/.vim</em> and <em>$HOME/.emacs</em>, respectively).</p>
</dd>
<dt><code>PWD</code></dt>
<dd>
<p>  Your shell’s current directory.<a data-type="indexterm" data-primary="PWD variable" id="idm46586640137296"/><a data-type="indexterm" data-primary="variables" data-secondary="PWD" id="idm46586640136592"/><a data-type="indexterm" data-primary="directory" data-secondary="current" data-tertiary="PWD variable" id="idm46586640135648"/><a data-type="indexterm" data-primary="current directory" data-secondary="PWD variable" id="idm46586640134432"/> Its value is set and maintained
automatically by the shell each time you <code>cd</code> to another directory.
The command <code>pwd</code> reads the variable <code>PWD</code> to print the name of your
shell’s current directory.</p>
</dd>
<dt><code>EDITOR</code></dt>
<dd>
<p> The name of (or path to) your<a data-type="indexterm" data-primary="EDITOR variable" id="idm46586640130768"/><a data-type="indexterm" data-primary="variables" data-secondary="EDITOR" id="idm46586640130064"/> preferred text editor. Its value is
generally set by you in a shell configuration file. Other programs
read this variable to launch an appropriate editor on your behalf.</p>
</dd>
</dl>

<p>View a shell’s environment variables with the <code>printenv</code><a data-type="indexterm" data-primary="printenv command" data-secondary="listing environment variables" id="idm46586640127808"/><a data-type="indexterm" data-primary="environment variables" data-secondary="listing" id="idm46586640126864"/>
command. The output is one variable per line, unsorted, and can be
quite long, so pipe it though <code>sort</code> and <code>less</code> for friendlier
viewing:<sup><a data-type="noteref" id="idm46586640124848-marker" href="ch06.xhtml#idm46586640124848">2</a></sup><a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586640124128"/></p>

<pre data-type="programlisting">$ <strong>printenv | sort -i | less</strong>
⋮
DISPLAY=:0
EDITOR=emacs
HOME=/home/smith
LANG=en_US.UTF-8
PWD=/home/smith/Music
SHELL=/bin/bash
TERM=xterm-256color
USER=smith
⋮</pre>

<p>Local variables do not appear in the output of <code>printenv</code>. Display
their values by preceding the variable name with a dollar sign and
printing the result with <code>echo</code>:</p>

<pre data-type="programlisting">$ <strong>title="Efficient Linux"</strong>
$ <strong>echo $title</strong>
Efficient Linux
$ <strong>printenv title</strong>                               <em>(produces no output)</em></pre>








<section data-type="sect2" data-pdf-bookmark="Creating Environment Variables"><div class="sect2" id="idm46586640118288">
<h2>Creating Environment Variables</h2>

<p><a data-type="indexterm" data-primary="environment variables" data-secondary="creating" id="idm46586640116944"/><a data-type="indexterm" data-primary="variables" data-secondary="exporting" id="idm46586640115968"/><a data-type="indexterm" data-primary="local variables" data-secondary="environment variables made from" id="idm46586640115024"/>
To turn a local variable into an environment variable, use the
<code>export</code><a data-type="indexterm" data-primary="export command" id="idm46586640113728"/><a data-type="indexterm" data-primary="builtins" data-secondary="export" id="idm46586640113024"/> command:</p>

<pre data-type="programlisting">$ <strong>MY_VARIABLE=10</strong>                  <em>A local variable</em>
$ <strong>export MY_VARIABLE</strong>              <em>Export it to become an environment variable</em>
$ <strong>export ANOTHER_VARIABLE=20</strong>      <em>Or, set and export in a single command</em></pre>

<p><code>export</code> specifies that the variable and its value will be copied from
the current shell to any future children. Local variables
are not copied to future children:</p>

<pre data-type="programlisting">$ <strong>export E="I am an environment variable"</strong>     <em>Set an environment variable</em>
$ <strong>L="I am just a local variable"</strong>              <em>Set a local variable</em>
$ <strong>echo $E</strong>
I am an environment variable
$ <strong>echo $L</strong>
I am just a local variable
$ <strong>bash</strong>                                        <em>Run a child shell</em>
$ <strong>echo $E</strong>                                     <em>Environment variable was copied</em>
I am an environment variable
$ <strong>echo $L</strong>                                     <em>Local variable was not copied</em>
                                              <em>Empty string is printed</em>
$ <strong>exit</strong>                                        <em>Exit the child shell</em></pre>

<p>Remember, a child’s variables are <em>copies</em>.<a data-type="indexterm" data-primary="child process" data-secondary="copied variables" id="idm46586640099568"/><a data-type="indexterm" data-primary="variables" data-secondary="copied from parent to child" id="idm46586640098560"/>
Any changes to the copy do not affect the parent shell:</p>

<pre data-type="programlisting">$ <strong>export E="I am the original value"</strong>          <em>Set an environment variable</em>
$ <strong>bash</strong>                                        <em>Run a child shell</em>
$ <strong>echo $E</strong>
I am the original value                       <em>Parent's value was copied</em>
$ <strong>E="I was modified in a child"</strong>               <em>Change the child's copy</em>
$ <strong>echo $E</strong>
I was modified in a child
$ <strong>exit</strong>                                        <em>Exit the child shell</em>
$ <strong>echo $E</strong>
I am the original value                       <em>Parent's value is unchanged</em></pre>

<p>Launch a new shell anytime and change anything in its environment, and
all the changes disappear when you exit the shell. This means you
can experiment with shell features safely—just run a shell manually,
creating a child, and terminate it when 
<span class="keep-together">finished.</span></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Superstition Alert: “Global” Variables"><div class="sect2" id="idm46586640089296">
<h2>Superstition Alert: “Global” Variables</h2>

<p><a data-type="indexterm" data-primary="environment variables" data-secondary="not global" id="idm46586640087888"/><a data-type="indexterm" data-primary="global-like behavior of environment variables" id="idm46586640086912"/>
Sometimes Linux hides its inner workings too well. A great example is
the behavior of environment variables. Somehow, like magic, variables
like <code>HOME</code> and <code>PATH</code> each have a consistent value in all your shell
instances.  They seem to be “global variables” in some sense. (I’ve
even seen this claim in other Linux books, not published by
O’Reilly.) But an environment variable is <em>not global</em>. Each shell
instance has its own copy. Modifying an environment variable in one
shell cannot change the value in any other running
shells. Modifications affect only that shell’s future children (not
yet invoked).</p>

<p>If that’s the case, how does a variable like <code>HOME</code> or <code>PATH</code> seem to
keep its value in all your shell instances? There are two avenues to
make this happen, which are illustrated in <a data-type="xref" href="#fig_exporting">Figure 6-1</a>. In
short:</p>
<dl>
<dt>Children copy from their parents.</dt>
<dd>
<p>  For variables like <code>HOME</code>, the values are usually set and exported
by your login shell. All future shells (until you log out) are
children of the login shell, so they receive a copy of the variable
and its value. These sorts of system-defined environment variables are so
rarely modified in the real world that they seem global, but they are
just ordinary variables that play by the ordinary rules. (You may even
change their values in a running shell, but you might disrupt the expected
behavior of that shell and other programs.)</p>
</dd>
<dt>Different instances read the same configuration files.</dt>
<dd>
<p>  Local variables, which are not copied to children, can have their
values set in a Linux configuration file<a data-type="indexterm" data-primary="configuration files" data-secondary="bash" id="idm46586640078720"/><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" id="idm46586640077744"/> such
as <em>$HOME/.bashrc</em> (see more details in <a data-type="xref" href="#section_bash_configs">“Configuring Your Environment”</a>).
Each instance of the shell, on invocation, reads and executes the
appropriate configuration files. As a result, these local variables
appear to be copied from shell to shell. The same is true for other
nonexported shell features such as aliases.</p>
</dd>
</dl>

<p>This behavior leads some users to believe that the <code>export</code> command
creates a global variable. It does not. The command <code>export WHATEVER</code>
simply declares<a data-type="indexterm" data-primary="export command" data-secondary="purpose" id="idm46586640073504"/> that the variable
<code>WHATEVER</code> will be copied from the current shell to any future
children.</p>

<figure><div id="fig_exporting" class="figure">
<img src="Images/elcl_0601.png" alt="Shells may share variables and values by export or by reading the same configuration files" width="600" height="498"/>
<h6><span class="label">Figure 6-1. </span>Shells may share variables and values by export or by reading the same configuration files</h6>
</div></figure>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Child Shells Versus Subshells"><div class="sect1" id="section_subshells">
<h1>Child Shells Versus Subshells</h1>

<p><a data-type="indexterm" data-primary="child shell" id="idm46586640067984"/><a data-type="indexterm" data-primary="shell" data-secondary="child shell" id="idm46586640067280"/>
A child is a partial copy of its parent. It includes copies of its
parent’s environment variables, for example, but not its parent’s
local (unexported) variables or aliases:<a data-type="indexterm" data-primary="bash" data-secondary="initialization files" data-tertiary="skip loading (--norc option)" id="idm46586640066016"/></p>
<pre data-type="programlisting">$ <strong>alias</strong>                        <em>List aliases</em>
alias gd='pushd'
alias l='ls -CF'
alias pd='popd'
$ <strong>bash --norc</strong>                  <em>Run a child shell and ignore bashrc files</em>
$ <strong>alias</strong>                        <em>List aliases - none are known</em>
$ <strong>echo $HOME</strong>                   <em>Environment variables are known</em>
/home/smith
$ <strong>exit</strong>                         <em>Exit the child shell</em></pre>

<p>If you’ve ever wondered why your aliases aren’t available in shell scripts,<a data-type="indexterm" data-primary="aliases" data-secondary="availability in scripts" id="idm46586640059168"/>
now you know. Shell scripts run in a child, which does not receive
copies of the parent’s aliases.</p>

<p>A <em>subshell<a data-type="indexterm" data-primary="subshell" id="idm46586640057248"/></em>, in contrast,<a data-type="indexterm" data-primary="shell" data-secondary="subshell" data-see="subshell" id="idm46586640056384"/> is a complete copy of its
parent.<sup><a data-type="noteref" id="idm46586640055040-marker" href="ch06.xhtml#idm46586640055040">3</a></sup> It includes
all the parent’s variables, aliases, functions, and more. To launch a
command in a subshell, enclose the command in parentheses:</p>

<pre data-type="programlisting">$ <strong>(ls -l)</strong>                                      <em>Launches ls -l in a subshell</em>
-rw-r--r-- 1 smith smith 325 Oct 13 22:19 animals.txt
$ <strong>(alias)</strong>                                      <em>View aliases in a subshell</em>
alias gd=<em>pushd</em>
alias l=<em>ls -CF</em>
alias pd=<em>popd</em>
⋮
$ <strong>(l)</strong>                                          <em>Run an alias from the parent</em>
animals.txt</pre>

<p>To check if a shell instance is a subshell, print the variable
<code>BASH_SUBSHELL</code>.<a data-type="indexterm" data-primary="BASH_SUBSHELL variable" id="idm46586640046944"/><a data-type="indexterm" data-primary="variables" data-secondary="BASH_SUBSHELL" id="idm46586640046208"/><a data-type="indexterm" data-primary="subshell" data-secondary="detection" id="idm46586640045264"/> The value is nonzero in subshells, zero otherwise:</p>

<pre data-type="programlisting">$ <strong>echo $BASH_SUBSHELL</strong>         <em>Check the current shell</em>
0                             <em>Not a subshell</em>
$ <strong>bash</strong>                        <em>Run a child shell</em>
$ <strong>echo $BASH_SUBSHELL</strong>         <em>Check the child shell</em>
0                             <em>Not a subshell</em>
$ <strong>exit</strong>                        <em>Exit the child shell</em>
$ <strong>(echo $BASH_SUBSHELL)</strong>       <em>Run an explicit subshell</em>
1                             <em>Yes, it's a subshell</em></pre>

<p>I’ll cover some practical uses of subshells in
<a data-type="xref" href="ch07.xhtml#section_explicit_subshells">“Technique #10: Explicit Subshells”</a>. For now, just be aware that you can
create them and they copy the parent’s aliases.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Configuring Your Environment"><div class="sect1" id="section_bash_configs">
<h1>Configuring Your Environment</h1>

<p><a data-type="indexterm" data-primary="environment" data-secondary="configuring" data-see="configuration files" id="idm46586640034672"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" id="bashconfig2"/><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" id="bashconfig"/>
When <code>bash</code> runs, it configures itself by reading a sequence of files,
called <em>configuration files</em>, and executing their contents. These files
define variables, aliases, functions, and other shell features, and
they can include any Linux command. (They are like shell
scripts that configure the shell.) Some configuration files are
defined by the 
<span class="keep-together">system</span> administrator and apply to all
users system-wide. They are found in the directory <em>/etc</em>. Other configuration
files are owned
and changed by individual users. They are located in the user’s home
directory. <a data-type="xref" href="#table_config">Table 6-1</a> lists the standard <code>bash</code> configuration files.
They come in several types:</p>
<dl class="pagebreak-before">
<dt>Startup files</dt>
<dd>
<p> Configuration files that execute automatically<a data-type="indexterm" data-primary="startup files" id="idm46586640024880"/><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" data-tertiary="startup files" id="idm46586640024176"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" data-tertiary="startup files" id="idm46586640022960"/> when you log in—that
is, they apply only to your login shell. An example command in this
file might set and export an environment variable. Defining an alias
in this file would be less helpful, however, because aliases are not
copied to children.</p>
</dd>
<dt>Initialization (“init”) files</dt>
<dd>
<p> Configuration files that execute<a data-type="indexterm" data-primary="initialization files" id="idm46586640019872"/><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" data-tertiary="initialization files" id="idm46586640019168"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" data-tertiary="initialization files" id="idm46586640017952"/> for every shell instance that is not a
login shell—for example, when you run an interactive
shell<a data-type="indexterm" data-primary="interactive shell" id="idm46586640016496"/><a data-type="indexterm" data-primary="shell" data-secondary="interactive" id="idm46586640015824"/> by hand or a (noninteractive)
shell script.<a data-type="indexterm" data-primary="noninteractive shell" id="idm46586640014688"/><a data-type="indexterm" data-primary="shell" data-secondary="noninteractive" id="idm46586640014016"/>
An example initialization file command might set a variable or define
an alias.</p>
</dd>
<dt>Cleanup files</dt>
<dd>
<p> Configuration files that execute<a data-type="indexterm" data-primary="cleanup files" id="idm46586640011728"/><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" data-tertiary="cleanup files" id="idm46586640011024"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" data-tertiary="cleanup files" id="idm46586640009808"/> immediately before your login shell
exits. An example command in this file might be <code>clear</code><a data-type="indexterm" data-primary="clear command" id="idm46586640008016"/> to blank your
screen on logout.</p>
</dd>
</dl>
<table id="table_config">
<caption><span class="label">Table 6-1. </span>Standard configuration files sourced by <code>bash</code><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" data-tertiary="table of" id="idm46586640005696"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" data-tertiary="table of" id="idm46586640004448"/></caption>
<thead>
<tr>
<th>File type</th>
<th>Run by</th>
<th>System-wide location</th>
<th>Personal file locations (in order invoked)</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Startup files</p></td>
<td><p>Login shells, on invocation</p></td>
<td><p><em>/etc/profile</em></p></td>
<td><p><em>$HOME/.bash_profile</em>, <em>$HOME/.bash_login</em>, and <em>$HOME/.profile</em> <a data-type="indexterm" data-primary="/etc/profile file" id="idm46586639995808"/><a data-type="indexterm" data-primary="/etc/profile file" data-primary-sortas="etc profile" id="idm46586639995072"/><a data-type="indexterm" data-primary=".bash_profile file" data-primary-sortas="bash_profile" id="idm46586639994128"/><a data-type="indexterm" data-primary=".bash_login file" data-primary-sortas="bash_login" id="idm46586639993184"/><a data-type="indexterm" data-primary=".profile file" data-primary-sortas="profile" id="idm46586639992240"/></p></td>
</tr>
<tr>
<td rowspan="2"><p>Init files</p></td>
<td><p>Interactive shells (nonlogin), on invocation</p></td>
<td><p><em>/etc/bash.bashrc</em></p></td>
<td><p><em>$HOME/.bashrc</em> <a data-type="indexterm" data-primary="/etc/bash.bashrc file" id="idm46586639988016"/><a data-type="indexterm" data-primary="/etc/bash.bashrc file" data-primary-sortas="etc bash.bashrc" id="idm46586639987280"/><a data-type="indexterm" data-primary=".bashrc file" data-primary-sortas="bashrc" id="idm46586639986336"/></p></td>
</tr>
<tr>
<td><p>Shell scripts, on invocation</p></td>
<td><p>Set the variable <code>BASH_ENV</code> to the absolute path to an initialization file (example: <code>BASH_ENV=/usr/local/etc/bashrc</code>) <a data-type="indexterm" data-primary="BASH_ENV variable" id="idm46586639982944"/><a data-type="indexterm" data-primary="variables" data-secondary="BASH_ENV" id="idm46586639982240"/></p></td>
<td><p>Set the variable <code>BASH_ENV</code> to the absolute path to an initialization file (example: <code>BASH_ENV=/usr/local/etc/bashrc</code>)</p></td>
</tr>
<tr>
<td><p>Cleanup files</p></td>
<td><p>Login shells, on exit</p></td>
<td><p><em>/etc/bash.bash_logout</em></p></td>
<td><p><em>$HOME/.bash_logout</em> <a data-type="indexterm" data-primary="/etc/bash.bash_logout file" id="idm46586639976704"/><a data-type="indexterm" data-primary="/etc/bash.bash_logout file" data-primary-sortas="etc bash.bash_logout" id="idm46586639975904"/><a data-type="indexterm" data-primary=".bash_logout file" data-primary-sortas="bash_logout" id="idm46586639974944"/></p></td>
</tr>
</tbody>
</table>

<p>Notice that you have three choices for personal startup files in your
home directory (<em>.bash_profile</em>, <em>.bash_login</em>, and
<em>.profile</em>). Most users can just pick one and stick with it. Your
Linux distro probably supplies one of them already, prefilled with
(ideally) useful commands. Things are a bit different if you happen
to run other shells such as Bourne shell (<em>/bin/sh</em>) and Korn shell
(<em>/bin/ksh</em>). These shells also read <em>.profile</em> and can fail if handed
<code>bash</code>-specific commands to execute. Place <code>bash</code>-specific commands in
<em>.bash_profile</em> or <em>.bash_login</em> instead (again, just pick one).</p>

<p>Users sometimes find the separation of personal startup files and the
personal initialization file confusing. Why would you want your login shell to
behave differently from other shells, say, that you open in multiple
windows? The answer is, in many cases, you don’t need them to behave
differently. Your personal startup file might do little more than
source your personal initialization file, <em>$HOME/.bashrc</em>, so all interactive
shells (login or nonlogin) would have largely the same configuration.</p>

<p>In other cases, you might prefer to split responsibilities between
your startup and initialization files. For example, your personal startup file
might set and export your environment variables to be copied to
future children, whereas <em>$HOME/.bashrc</em> might define all your
aliases (which are not copied to children).</p>

<p>Another consideration is whether you log into a graphical, windowing
desktop environment<a data-type="indexterm" data-primary="desktop environment" data-secondary="login shell behavior" id="idm46586639965856"/><a data-type="indexterm" data-primary="login shell" data-secondary="desktop environment and" id="idm46586639964880"/> (GNOME, Unity,
KDE Plasma, etc.) where your login
shell may be hidden. In this case, you might not care how the login
shell behaves because you interact only with its children, so you
might put most or all of your configuration into <em>$HOME/.bashrc</em>.<sup><a data-type="noteref" id="idm46586639963168-marker" href="ch06.xhtml#idm46586639963168">4</a></sup>
On the other hand, if you primarily log in from a nongraphical terminal
program such as an SSH client, then you directly interact with your
login shell, so its configuration matters a lot.</p>

<p>In each of these cases, it’s generally worthwhile to have your
personal startup file source your personal initialization file:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Place in $HOME/.bash_profile or other personal startup file</code>
<code class="k">if</code> <code class="o">[</code> -f <code class="s2">"</code><code class="nv">$HOME</code><code class="s2">/.bashrc"</code> <code class="o">]</code>
<code class="k">then</code>
  <code class="nb">source</code> <code class="s2">"</code><code class="nv">$HOME</code><code class="s2">/.bashrc"</code>
<code class="k">fi</code></pre>

<p>Whatever you do, try not to place identical configuration commands in
two different configuration files. That’s a recipe for confusion, and
it’s hard to maintain, because any change you make to one file you
must remember to duplicate in the other (and you’ll forget, trust
me). Instead, source one file from the other as I’ve shown.</p>








<section data-type="sect2" data-pdf-bookmark="Rereading a Configuration File"><div class="sect2" id="idm46586639942688">
<h2>Rereading a Configuration File</h2>

<p><a data-type="indexterm" data-primary="source command" data-secondary="sourcing a file" id="idm46586639941680"/><a data-type="indexterm" data-primary="rereading a configuration file" id="idm46586639940704"/><a data-type="indexterm" data-primary="loading a configuration file" id="idm46586639940064"/><a data-type="indexterm" data-primary="running commands" data-secondary="in shell configuration file" id="idm46586639939424"/><a data-type="indexterm" data-primary="executing a configuration file" id="idm46586639912080"/><a data-type="indexterm" data-primary="configuration files" data-secondary="rereading" id="idm46586639911472"/>
When you change any startup or initialization file, you can force a
running shell to reread it by sourcing the file, as explained in
<a data-type="xref" href="ch02.xhtml#section_environments1">“Environments and Initialization Files, the Short Version”</a>:</p>

<pre data-type="programlisting">$ <strong>source ~/.bash_profile</strong>             <em>Uses the builtin "source" command</em>
$ <strong>. ~/.bash_profile</strong>                  <em>Uses a dot</em></pre>
<div data-type="note" epub:type="note"><h1>Why the source Command Exists</h1>
<p>Why do you source a configuration file<a data-type="indexterm" data-primary="source command" data-secondary="why it exists" id="idm46586639906336"/> instead of making it executable
with <code>chmod</code> and running it like a shell script? Because a script runs
in a child process. Any commands in the script would not affect your
intended (parent) shell. They would affect only the child, which
exits, leaving you with nothing changed.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Traveling with Your Environment"><div class="sect2" id="section_traveling">
<h2>Traveling with Your Environment</h2>

<p><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" data-tertiary="copying between machines" id="idm46586639902672"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" data-tertiary="copying between machines" id="idm46586639901184"/>
If you use many Linux machines in multiple locations, at some point
you might want to install your carefully crafted configuration files
on more than one machine. Don’t copy individual files from machine to
machine—that approach leads to confusion eventually. Instead, store
and maintain the files in a free account on <a href="https://github.com">GitHub</a><a data-type="indexterm" data-primary="Git" data-secondary="GitHub" id="idm46586639899296"/>
or a similar software-development service with version control.<a data-type="indexterm" data-primary="version control" data-secondary="configuration file version control" id="idm46586639898192"/><a data-type="indexterm" data-primary="configuration files" data-secondary="version control of" id="idm46586639897232"/> Then
you can download, install, and update your configuration files
conveniently and consistently on any Linux machine. If you make a
mistake editing a configuration file, you can roll back to a previous
version by issuing a command or two. Version control is beyond the
scope of this book; see <a data-type="xref" href="ch11.xhtml#section_git">“Apply Version Control to Day-to-Day Files”</a> to learn more about it.</p>

<p>If you aren’t comfortable with version control systems like Git<a data-type="indexterm" data-primary="Git" id="idm46586639895104"/> or
Subversion<a data-type="indexterm" data-primary="Subversion" id="idm46586639894272"/>, store the configuration
files on a simple file service like Dropbox, Google Drive, or
OneDrive. Updates to your configuration files will be less convenient,
but at least the files will be easily available for copying to other
Linux systems.<a data-type="indexterm" data-startref="bashconfig" id="idm46586639893184"/><a data-type="indexterm" data-startref="bashconfig2" id="idm46586639892512"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586639891456">
<h1>Summary</h1>

<p>I have met many Linux users who are puzzled by (or unaware of) parent
and child processes, environments, and the purposes of the many shell
configuration files. After reading this chapter, I hope you have a
clearer picture of all these things. They come into play in
<a data-type="xref" href="ch07.xhtml#ch_running_commands">Chapter 7</a> as powerful tools for running commands in
flexible ways.<a data-type="indexterm" data-startref="shell6" id="idm46586639889328"/></p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586640310240"><sup><a href="ch06.xhtml#idm46586640310240-marker">1</a></sup> If you use a different shell, see also <a data-type="xref" href="app02.xhtml#appendix_shells">Appendix B</a>.</p><p data-type="footnote" id="idm46586640124848"><sup><a href="ch06.xhtml#idm46586640124848-marker">2</a></sup> I have trimmed the output selectively to display common environment variables. Your output is likely much longer and full of obscure variable names.</p><p data-type="footnote" id="idm46586640055040"><sup><a href="ch06.xhtml#idm46586640055040-marker">3</a></sup> It’s complete except for traps<a data-type="indexterm" data-primary="traps" id="idm46586640054464"/>, which “are reset to the values that the shell inherited from its parent at invocation” (<code>man bash</code>). I don’t discuss traps further in this book.</p><p data-type="footnote" id="idm46586639963168"><sup><a href="ch06.xhtml#idm46586639963168-marker">4</a></sup> To make matters slightly more confusing, some desktop environments have their own shell configuration files. For example, GNOME has <em>$HOME/.gnomerc</em>,<a data-type="indexterm" data-primary=".gnomerc file" data-primary-sortas="gnomerc file" id="idm46586639961840"/><a data-type="indexterm" data-primary="GNOME" data-secondary="configuration file" id="idm46586639960832"/><a data-type="indexterm" data-primary="configuration files" data-secondary="desktop environments" id="idm46586639959888"/> and the underlying X window system has <em>$HOME/.xinitrc</em>.<a data-type="indexterm" data-primary=".xinitrc file" data-primary-sortas="xinitrc file" id="idm46586639958368"/><a data-type="indexterm" data-primary="X (windowing software)" data-secondary="configuration file" id="idm46586639957360"/></p></div></div></section></div></body></html>