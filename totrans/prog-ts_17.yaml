- en: Appendix D. Recipes for Writing Declaration Files for Third-Party JavaScript
    Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix covers a few key building blocks and patterns that come up over
    and over again when typing third-party modules. For a deeper discussion of typing
    third-party code, head over to [“JavaScript That Doesn’t Have Type Declarations
    on DefinitelyTyped”](ch11.html#writing-3rd-party-typings).
  prefs: []
  type: TYPE_NORMAL
- en: Since module declaration files have to live in *.d.ts* files and so can’t contain
    values, when you declare module types you need to use the `declare` keyword to
    affirm that values of the given type really are exported by your module. [Table D-1](#type-only-table)
    provides a short summary of regular declarations and their type declaration equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Table D-1\. TypeScript and its type-only equivalents
  prefs: []
  type: TYPE_NORMAL
- en: '| *.ts* | *.d.ts* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `var a = 1` | `declare var a: number` |'
  prefs: []
  type: TYPE_TB
- en: '| `let a = 1` | `declare let a: number` |'
  prefs: []
  type: TYPE_TB
- en: '| `const a = 1` | `declare const a: 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `function a(b) { return b.toFixed() }` | `declare function a(b: number):
    string` |'
  prefs: []
  type: TYPE_TB
- en: '| `class A { b() { return 3 } }` | `declare class A { b(): number }` |'
  prefs: []
  type: TYPE_TB
- en: '| `namespace A {}` | `declare namespace A {}` |'
  prefs: []
  type: TYPE_TB
- en: '| `type A = number` | `type A = number` |'
  prefs: []
  type: TYPE_TB
- en: '| `interface A { b?: string }` | `interface A { b?: string }` |'
  prefs: []
  type: TYPE_TB
- en: Types of Exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether your module uses global, ES2015, or CommonJS exports will affect how
    you write your declaration files.
  prefs: []
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your module only assigns values to the global namespace and doesn’t actually
    export anything, you can just create a script-mode file (see [“Module Mode Versus
    Script Mode”](ch10.html#module-mode)) and prefix your variable, function, and
    class declarations with `declare` (every other kind of declaration—`enum`, `type`,
    and so on—remains unchanged):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each of these declarations will be globally available to every file in your
    project without requiring an explicit import. Here, you could use `someGlobal`
    in any file in your project without importing it first, but at runtime, `someGlobal`
    would need to be assigned to the global namespace (`window` in browsers or `global`
    in NodeJS).
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to avoid `import`s and `export`s in your declaration file in order
    to keep your file in script mode.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 Exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your module uses ES2015 exports—that is, the `export` keyword—simply replace
    `declare` (which affirms that a global variable is defined) with `export` (which
    affirms that an ES2015 binding is exported):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: CommonJS Exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CommonJS was the de facto module standard before ES2015, and is still the standard
    for NodeJS at the time of writing. It also uses the `export` keyword, but the
    syntax is a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we assigned our exports to `export`, rather than using `export` as
    a modifier (like we do for ES2015 exports).
  prefs: []
  type: TYPE_NORMAL
- en: A type declaration for a third-party CommonJS module can contain exactly one
    export. To export multiple things, we take advantage of declaration merging (see
    [Appendix C](app03.html#types-and-values)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to type multiple exports and no default export, we export a single
    `namespace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What about a CommonJS module that has both a default export and named exports?
    We take advantage of declaration merging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: UMD Exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typing a UMD module is nearly identical to typing an ES2015 module. The only
    difference is that if you want to make your module globally available to script-mode
    files (see [“Module Mode Versus Script Mode”](ch10.html#module-mode)), you use
    the special `export as namespace` syntax. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that last line—if you have a script-mode file in your project, you can
    now use that module directly (without importing it first) on the global `MyModule`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Extending a Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending a module’s type declaration is less common than typing a module, but
    it might come up if you write a JQuery plugin or a Lodash mixin. Try to avoid
    doing it when possible; instead, consider using a separate module. That is, instead
    of a Lodash mixin use a regular function, and instead of a JQuery plugin—wait,
    why are you still using JQuery?
  prefs: []
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to extend another module’s global namespace or interface, just create
    a script-mode file (see [“Module Mode Versus Script Mode”](ch10.html#module-mode)),
    and augment it. Note that this only works for interfaces and namespaces because
    TypeScript will take care of merging them for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s add an awesome new `marquee` method to JQuery. We’ll start
    by installing `jquery` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll then create a new file—say *jquery-extensions.d.ts*—in our project, and
    add `marquee` to JQuery’s global `JQuery` interface (I found that JQuery defines
    its methods on the `JQuery` interface by sleuthing through its type declarations):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in any file where we use JQuery, we can use `marquee` (of course, we’ll
    want to add a runtime implementation for `marquee` too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is the same technique we used to extend built-in globals in [“Safely
    Extending the Prototype”](ch06.html#extending-the-prototype).
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extending module exports is a bit trickier, and has more pitfalls: you need
    to type your extension correctly, load your modules in the correct order at runtime,
    and make sure to update your extension’s types when the structure of the type
    declarations for the module you’re extending changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s type a new export for React. We’ll start by installing
    React and its type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll take advantage of module merging (see [“Declaration Merging”](ch10.html#namespace-merging))
    and simply declare a module with the same name as our React module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike in our example for extending globals, it doesn’t matter whether
    our extension file is in module mode or script mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about extending a specific export from a module? Inspired by [ReasonReact](https://reasonml.github.io/reason-react),
    let’s say we want to add a built-in reducer for our React components (a reducer
    is a way to declare an explicit set of state transitions for a React component).
    At the time of writing, React’s type declarations declare the `React.Component`
    type as an interface and a class that get merged together into a single UMD export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s extend `Component` with our `reducer` method. We can do this by entering
    the following in a *react-extensions.d.ts* file in the project root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We import `'react'`, switching our extension file into script mode, which we
    need to be in to consume a React module. Note that there are other ways we could
    have switched to script mode, like importing something else, exporting something,
    or exporting an empty object (`export {}`)—we didn’t have to import `'react'`
    specifically.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the `'react'` module, indicating to TypeScript that we want to declare
    types for that specific `import` path. Because we already installed `@types/react`
    (which defines an export for the same exact `'react'` path), TypeScript will merge
    this module declaration with the one provided by `@types/react`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We augment the `Component` interface provided by React by declaring our own
    `Component` interface. Following the rules of interface merging ([“Declaration
    Merging”](ch05.html#interface-merging)), we have to use the same exact signature
    in our declaration as the one in `@types/react`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we declare our `reducer` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After declaring these types (and assuming we’ve implemented the runtime behavior
    to support this update somewhere), we can now declare React components with built-in
    `reducers` in a typesafe way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As noted at the start of this section, it’s good practice to avoid this pattern
    when possible (even though it’s cool) because it can make your modules brittle
    and dependent on load order. Instead, try to use composition so that your module
    extensions consume the module they’re extending, and export a wrapper rather than
    modifying that module.
  prefs: []
  type: TYPE_NORMAL
