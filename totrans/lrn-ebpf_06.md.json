["```\nprocessed 61 insns (limit 1000000) max_states_per_insn 0 total_states 4\npeak_states 4 mark_read 3\n```", "```\n0: (bf) r6 = r1\n; data.counter = c;                                              ![1](assets/1.png)\n1: (18) r1 = 0xffff800008178000\n3: (61) r2 = *(u32 *)(r1 +0)\n R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=ctx(id=0,off=0,imm=0) \n R10=fp0                                                         ![2](assets/2.png)\n; c++; \n4: (bf) r3 = r2\n5: (07) r3 += 1\n6: (63) *(u32 *)(r1 +0) = r3\n R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R2_w=inv(id=1,umax_value=4294967295,\n var_off=(0x0; 0xffffffff)) R3_w=inv(id=0,umin_value=1,umax_value=4294967296,\n var_off=(0x0; 0x1ffffffff)) R6_w=ctx(id=0,off=0,imm=0) R10=fp0  ![3](assets/3.png)\n```", "```\nR2_w=inv(id=1,umax_value=4294967295,var_off=(0x0; 0xffffffff))\nR3_w=inv(id=0,umin_value=1,umax_value=4294967296,var_off=(0x0; 0x1ffffffff))\n```", "```\n$ bpftool prog dump xlated name kprobe_exec visual > out.dot\n$ dot -Tpng out.dot > out.png\n```", "```\n...\n16: (85) call bpf_get_current_pid_tgid#14\nunknown func bpf_get_current_pid_tgid#14\n```", "```\nconst struct `bpf_func_proto` `bpf_map_lookup_elem_proto` = {\n    .`func`      = `bpf_map_lookup_elem`,\n    .`gpl_only` = `false`,\n    .`pkt_access`     = `true`,\n    .`ret_type` = `RET_PTR_TO_MAP_VALUE_OR_NULL`,\n    .`arg1_type` = `ARG_CONST_MAP_PTR`,\n    .`arg2_type` = `ARG_PTR_TO_MAP_KEY`,\n};\n```", "```\np = bpf_map_lookup_elem(&data, &uid);\n```", "```\n27: (85) call bpf_map_lookup_elem#1\nR1 type=fp expected=map_ptr\n```", "```\n...\n37: (85) call bpf_probe_read_kernel#113\ncannot call GPL-restricted function from non-GPL compatible program\n```", "```\nSEC(\"xdp\")\nint xdp_load_balancer(struct xdp_md *ctx)\n{\n   void *data = (void *)(long)ctx->data;\n   void *data_end = (void *)(long)ctx->data_end;\n...\n```", "```\nSEC(\"xdp\")\nint xdp_hello(struct xdp_md *ctx) {\n  void *data = (void *)(long)ctx->data;\n  void *data_end = (void *)(long)ctx->data_end;\n  bpf_printk(\"%x\", data_end);\n  return XDP_PASS;\n}\n```", "```\ndata_end++;\n```", "```\n; data_end++;\n1: (07) r3 += 1\nR3 pointer arithmetic on pkt_end prohibited\n```", "```\nif (c < sizeof(message)) {\n   char a = message[c];\n   bpf_printk(\"%c\", a);\n}\n```", "```\nif (c <= sizeof(message)) {\n   char a = message[c];\n   bpf_printk(\"%c\", a);\n}\n```", "```\ninvalid access to map value, value_size=16 off=16 size=1\nR2 max value is outside of the allowed memory range\n```", "```\n; if (c <= sizeof(message)) {\n30: (25) if r1 > 0xc goto pc+10                                ![3](assets/3.png)\n R0_w=map_value_or_null(id=2,off=0,ks=4,vs=12,imm=0) R1_w=inv(id=0,\n umax_value=12,var_off=(0x0; 0xf)) R6=ctx(id=0,off=0,imm=0) ...\n; char a = message[c];\n31: (18) r2 = 0xffff800008e00004                               ![2](assets/2.png)\n33: (0f) r2 += r1                                               \nlast_idx 33 first_idx 19\nregs=2 stack=0 before 31: (18) r2 = 0xffff800008e00004\nregs=2 stack=0 before 30: (25) if r1 > 0xc goto pc+10\nregs=2 stack=0 before 29: (61) r1 = *(u32 *)(r8 +0)\n34: (71) r3 = *(u8 *)(r2 +0)                                   ![1](assets/1.png)\n R0_w=map_value_or_null(id=2,off=0,ks=4,vs=12,imm=0) R1_w=invP(id=0,\n umax_value=12,var_off=(0x0; 0xf)) R2_w=map_value(id=0,off=4,ks=4,vs=16,\n umax_value=12,var_off=(0x0; 0xf),s32_max_value=15,u32_max_value=15)\n R6=ctx(id=0,off=0,imm=0) ...\n```", "```\np = bpf_map_lookup_elem(&my_config, &uid);\n```", "```\nchar a = p->message[0];\nbpf_printk(\"%c\", a);\n```", "```\n; p = bpf_map_lookup_elem(&my_config, &uid); \n25: (18) r1 = 0xffff263ec2fe5000\n27: (85) call bpf_map_lookup_elem#1\n28: (bf) r7 = r0                                ![1](assets/1.png)\n; char a = p->message[0];\n29: (71) r3 = *(u8 *)(r7 +0)                    ![2](assets/2.png)\nR7 invalid mem access 'map_value_or_null'\n```", "```\nif (p != 0) {\n   char a = p->message[0];\n   bpf_printk(\"%d\", cc);\n}\n```", "```\nlong bpf_probe_read_kernel(void **`dst`*, u32 *`size`*, const void **`unsafe_ptr`*)\n```", "```\nfor (int i=0; i < 10; i++) {\n   bpf_printk(\"Looping %d\", i);\n}\n```", "```\nR0 !read_ok\n```", "```\nSEC(\"xdp\")\nint xdp_hello(struct xdp_md *ctx) {\n void *data = (void *)(long)ctx->data;\n void *data_end = (void *)(long)ctx->data_end;\n\n // bpf_printk(\"%x\", data_end);\n // return XDP_PASS;\n}\n```", "```\n    if (c < sizeof(data.message)) {\n       char a = data.message[c];\n       bpf_printk(\"%c\", a);\n    }\n    ```", "```\n    for (int i=0; i < 10; i++) {\n       bpf_printk(\"Looping %d\", i);\n    }\n    ```", "```\n    42: (18) r1 = 0xffff800008e10009\n    44: (b7) r2 = 11\n    45: (b7) r3 = 8\n    46: (85) call bpf_trace_printk#6\n     R0=inv(id=0) R1_w=map_value(id=0,off=9,ks=4,vs=26,imm=0) R2_w=inv11\n     R3_w=inv8 R6=pkt_end(id=0,off=0,imm=0) R7=pkt(id=0,off=0,r=0,imm=0) \n     R10=fp0\n    last_idx 46 first_idx 42\n    regs=4 stack=0 before 45: (b7) r3 = 8\n    regs=4 stack=0 before 44: (b7) r2 = 11\n    ```", "```\n    for (int i=0; i < c; i++) {\n       bpf_printk(\"Looping %d\", i);\n    }\n    ```", "```\n    unsigned short common_type;\n    unsigned char common_flags;\n    unsigned char common_preempt_count;\n    int common_pid;\n    ```"]