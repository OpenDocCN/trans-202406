<html><head></head><body><section data-pdf-bookmark="Chapter 6. React State Management" data-type="chapter" epub:type="chapter"><div class="chapter" id="react-state-management">&#13;
<h1><span class="label">Chapter 6. </span>React State Management</h1>&#13;
&#13;
&#13;
<p>Data<a data-primary="state management" data-secondary="importance of" data-type="indexterm" id="idm45901639957992"/> is what makes our React components come to life. The user interface&#13;
for recipes that we built in the last chapter is useless without the&#13;
array of recipes. It’s the recipes and the ingredients along with clear&#13;
instructions that makes such an app worthwhile. Our user&#13;
interfaces are tools that creators will use to generate content. In&#13;
order to build the best tools possible for our content creators, we’ll&#13;
need to know how to effectively manipulate and change data.</p>&#13;
&#13;
<p>In the last chapter, we constructed<a data-primary="component trees" data-secondary="definition of term" data-type="indexterm" id="idm45901639955992"/> a <em>component tree</em>: a hierarchy of&#13;
components that data was able to flow through as properties. Properties&#13;
are half of the picture. State is the other half. The <em>state</em> of a React&#13;
application is driven by data that has the ability to change.&#13;
Introducing state to the recipe application could make it possible for&#13;
chefs to create new recipes, modify existing recipes, and remove old ones.</p>&#13;
&#13;
<p>State and properties have a relationship with each other. When we work&#13;
with React applications, we gracefully compose components that are tied&#13;
together based on this relationship. When the state of a component&#13;
tree changes, so do the properties. The new data flows through the tree,&#13;
causing specific leaves and branches to render to reflect the new&#13;
content.</p>&#13;
&#13;
<p>In this chapter, we’re going to bring applications to life by&#13;
introducing state. We’ll learn to create stateful components and how state can be sent down a component tree and user&#13;
interactions back up the component tree. We’ll learn techniques for&#13;
collecting form data from users. And we’ll take a look at the&#13;
various ways in which we can separate concerns within our applications by&#13;
introducing stateful context <span class="keep-together">providers</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Building a Star Rating Component" data-type="sect1"><div class="sect1" id="building-a-star-rating-component">&#13;
<h1>Building a Star Rating Component</h1>&#13;
&#13;
<p>We<a data-primary="state management" data-secondary="building star rating components" data-type="indexterm" id="idm45901639924584"/> would all be eating terrible food and watching terrible movies&#13;
without the five-star rating system. If we plan on letting users drive&#13;
the content on our website, we’ll need a way to know if that content&#13;
is any good or not. That makes the <code>StarRating</code> component one of the&#13;
most important React components you’ll ever build (see <a data-type="xref" href="#star_rating_component">Figure 6-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="star_rating_component">&#13;
<img alt="lrc2 0601" src="assets/lrc2_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>StarRating component</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>StarRating</code> component will allow users to rate content based on a&#13;
specific number of stars. Content that’s no good gets one star.&#13;
Highly recommended content gets five stars. Users can set the rating for&#13;
specific content by clicking on a specific star. First, we’ll need a&#13;
star, and we can get one from <code>react-icons</code>:</p>&#13;
&#13;
<pre data-type="programlisting">npm i react-icons</pre>&#13;
&#13;
<p><code>react-icons</code> is<a data-primary="react-icons library" data-type="indexterm" id="idm45901639917768"/> an npm library that contains hundreds of SVG icons that&#13;
are distributed as React components. By installing it, we just installed&#13;
several popular icon libraries that contain hundreds of common SVG&#13;
icons. You can browse all the icons in the <a href="https://react-icons.netlify.com">library</a>. We’re going to use the star icon&#13;
from the Font Awesome collection:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">FaStar</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react-icons/fa"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[</code>&#13;
    <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="s2">"red"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
    <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="s2">"red"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
    <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="s2">"red"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
    <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="s2">"grey"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
    <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="s2">"grey"</code> <code class="o">/&gt;</code>&#13;
  <code class="p">];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, we’ve created a <code>StarRating</code> component that renders five SVG&#13;
stars that we’ve imported from <code>react-icons</code>. The first three stars&#13;
are filled in with red, and the last two are grey. We render the stars&#13;
first because seeing them gives us a roadmap for what we’ll have to&#13;
build. A selected star should be filled in with red, and a star that’s&#13;
not selected should be greyed out. Let’s create a component that&#13;
automatically files the stars based upon the selected property:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Star</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">selected</code> <code class="o">=</code> <code class="kc">false</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="p">{</code><code class="nx">selected</code> <code class="o">?</code> <code class="s2">"red"</code> <code class="o">:</code> <code class="s2">"grey"</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>The <code>Star</code> component renders an individual star and uses the <code>selected</code>&#13;
property to fill it with the appropriate color. If the selected property&#13;
is not passed to this component, we’ll assume that the star should not&#13;
be selected and by default will be filled in with grey.</p>&#13;
&#13;
<p>The 5-star rating system is pretty popular, but a 10-star rating&#13;
system is far more detailed. We should allow developers to select the&#13;
total number of stars they wish to use when they add this component&#13;
to their app. This can be accomplished by adding a <code>totalStars</code> property&#13;
to the <code>StarRating</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">createArray</code> <code class="o">=</code> <code class="nx">length</code> <code class="o">=&gt;</code> <code class="p">[...</code><code class="nb">Array</code><code class="p">(</code><code class="nx">length</code><code class="p">)];</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">({</code> <code class="nx">totalStars</code> <code class="o">=</code> <code class="mi">5</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">createArray</code><code class="p">(</code><code class="nx">totalStars</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">n</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">&lt;</code><code class="nx">Star</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, we added the <code>createArray</code> function from <a data-type="xref" href="ch02.html#javascript-for-react">Chapter 2</a>. All we have to&#13;
do is supply the length of the array that we want to create and we get a&#13;
new array at that length. We use this function with the <code>totalStars</code>&#13;
property to create an array of a specific length. Once we have an array,&#13;
we can map over it and render <code>Star</code> components. By default,&#13;
<code>totalStars</code> is equal to <code>5</code>, which means this component will render <code>5</code>&#13;
grey stars, as shown in <a data-type="xref" href="#five_stars">Figure 6-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="five_stars">&#13;
<img alt="lrc2 0602" src="assets/lrc2_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>Five stars are displayed</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The useState Hook" data-type="sect1"><div class="sect1" id="the-usestate-hook">&#13;
<h1>The useState Hook</h1>&#13;
&#13;
<p>It’s<a data-primary="state management" data-secondary="useState hook" data-type="indexterm" id="SMusestate06"/><a data-primary="useState hook" data-type="indexterm" id="usestate06"/><a data-primary="hooks" data-secondary="useState hook" data-type="indexterm" id="Husestate06"/> time to make the <code>StarRating</code> component clickable, which will allow&#13;
our users to change the <code>rating</code>. Since the <code>rating</code> is a value that&#13;
will change, we’ll store and change that value using React state. We&#13;
incorporate state into a function component using a React feature called&#13;
<em>Hooks</em>. <em>Hooks</em> contain<a data-primary="hooks" data-secondary="purpose of" data-type="indexterm" id="idm45901639706424"/> reusable code logic that is separate from the&#13;
component tree. They allow us to <em>hook</em> up functionality to our&#13;
components. React ships with several built-in hooks we can use out&#13;
of the box. In this case, we want to add state to our React component, so&#13;
the first hook we’ll work with is React’s <span class="keep-together"><code>useState</code></span> hook. This&#13;
hook is already available in the <code>react</code> package; we simply need to&#13;
import it:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">FaStar</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react-icons/fa"</code><code class="p">;</code></pre>&#13;
&#13;
<p>The stars the user has selected represents the rating. We’ll&#13;
create a state variable called <code>selectedStars</code>, which will hold the&#13;
user’s rating. We’ll create this variable by adding the <code>useState</code>&#13;
hook directly to the <code>StarRating</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">({</code> <code class="nx">totalStars</code> <code class="o">=</code> <code class="mi">5</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">selectedStars</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="p">{</code><code class="nx">createArray</code><code class="p">(</code><code class="nx">totalStars</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">n</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nx">Star</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code> <code class="nx">selected</code><code class="o">=</code><code class="p">{</code><code class="nx">selectedStars</code> <code class="o">&gt;</code> <code class="nx">i</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
      <code class="p">))}</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">selectedStars</code><code class="p">}</code> <code class="k">of</code> <code class="p">{</code><code class="nx">totalStars</code><code class="p">}</code> <code class="nx">stars</code>&#13;
      <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We just <em>hooked</em> this component up with state. The <code>useState</code> hook is a&#13;
function that we can invoke to return an array. The first value of that&#13;
array is the state variable we want to use. In this case, that&#13;
variable is <code>selectedStars</code>, or the number of stars the <code>StarRating</code>&#13;
will color red. <code>useState</code> returns an array. We can take advantage of&#13;
array destructuring, which allows us to name our state variable whatever&#13;
we like. The value we send to the <code>useState</code> function is the&#13;
default value for the state variable. In this case, <code>selectedStars</code> will&#13;
initially be set to <code>3</code>, as shown in <a data-type="xref" href="#selected_stars">Figure 6-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="selected_stars">&#13;
<img alt="lrc2 0603" src="assets/lrc2_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>Three of five stars are selected</h6>&#13;
</div></figure>&#13;
&#13;
<p>In order to collect a different rating from the user, we’ll need to&#13;
allow them to click on any of our stars. This means we’ll need to&#13;
make the stars clickable by adding an <code>onClick</code> handler to the <code>FaStar</code>&#13;
component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Star</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">selected</code> <code class="o">=</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">onSelect</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="p">{</code><code class="nx">selected</code> <code class="o">?</code> <code class="s2">"red"</code> <code class="o">:</code> <code class="s2">"grey"</code><code class="p">}</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">onSelect</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Here, we modified the star to contain an <code>onSelect</code> property. Check it&#13;
out: this property is a function. When a user clicks on the <code>FaStar</code>&#13;
component, we’ll invoke this function, which can notify its parent that&#13;
a star has been clicked. The default value for this function is&#13;
<code>f =&gt; f</code>. This is simply a fake function that does nothing; it just&#13;
returns whatever argument was sent to it. However, if we do not set a&#13;
default function and the <code>onSelect</code> property is not defined, an error&#13;
will occur when we click the <code>FaStar</code> component because the value for&#13;
<code>onSelect</code> must be a function. Even though <code>f =&gt; f</code> does nothing, it is&#13;
a function, which means it can be invoked without causing errors. If an&#13;
<code>onSelect</code> property is not defined, no problem. React will simply invoke&#13;
the fake function and nothing will happen.</p>&#13;
&#13;
<p>Now that our <code>Star</code> component is clickable, we’ll use it to change the&#13;
state of the <code>StarRating</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">({</code> <code class="nx">totalStars</code> <code class="o">=</code> <code class="mi">5</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">selectedStars</code><code class="p">,</code> <code class="nx">setSelectedStars</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="p">{</code><code class="nx">createArray</code><code class="p">(</code><code class="nx">totalStars</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">n</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nx">Star</code>&#13;
          <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code>&#13;
          <code class="nx">selected</code><code class="o">=</code><code class="p">{</code><code class="nx">selectedStars</code> <code class="o">&gt;</code> <code class="nx">i</code><code class="p">}</code>&#13;
          <code class="nx">onSelect</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setSelectedStars</code><code class="p">(</code><code class="nx">i</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)}</code>&#13;
        <code class="o">/&gt;</code>&#13;
      <code class="p">))}</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">selectedStars</code><code class="p">}</code> <code class="k">of</code> <code class="p">{</code><code class="nx">totalStars</code><code class="p">}</code> <code class="nx">stars</code>&#13;
      <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In order to change the state of the <code>StarRating</code> component, we’ll need a&#13;
function that can modify the value of <code>selectedStars</code>. The second item&#13;
in the array that’s returned by the <code>useState</code> hook is a function that&#13;
can be used to change the state value. Again, by destructuring this&#13;
array, we can name that function whatever we like. In this case, we’re&#13;
calling it <code>setSelectedStars</code>, because that’s what it does: it sets the&#13;
value of <code>selectedStars</code>.</p>&#13;
&#13;
<p>The most important thing to remember about Hooks is that they can cause&#13;
the component they’re hooked into to rerender. Every time we&#13;
invoke the <code>setSelectedStars</code> function to change the value of&#13;
<code>selectedStars</code>, the <code>StarRating</code> function component will be reinvoked&#13;
by the hook, and it will render again, this time with a new value for&#13;
<code>selectedStars</code>. This is why Hooks are such a killer feature. When data&#13;
within the hook changes, they have the power to rerender the component&#13;
 they’re hooked into with new data.</p>&#13;
&#13;
<p>The <code>StarRating</code> component will be rerendered every time a user clicks&#13;
a <code>Star</code>. When the user clicks the <code>Star</code>, the <code>onSelect</code> property of&#13;
that star is invoked. When the <code>onSelect</code> property is invoked, we’ll&#13;
invoke the <code>setSelectedStars</code> function and send it the number of the&#13;
star that was just selected. We can use the <code>i</code> variable from the <code>map</code>&#13;
function to help us calculate that number. When the <code>map</code> function&#13;
renders the first <code>Star</code>, the value for <code>i</code> is <code>0</code>. This means that we&#13;
need to add <code>1</code> to this value to get the correct number of stars. When&#13;
<code>setSelectedStars</code> is invoked, the <code>StarRating</code> component is invoked&#13;
with a the value for <code>selectedStars</code>, as shown in <a data-type="xref" href="#hooks_react_tools">Figure 6-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="hooks_react_tools">&#13;
<img alt="lrc2 0604" src="assets/lrc2_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>Hooks in React developer tools</h6>&#13;
</div></figure>&#13;
&#13;
<p>The React developer tools will show you which Hooks are incorporated&#13;
with specific components. When we render the <code>StarRating</code> component in&#13;
the browser, we can view debugging information about that component by&#13;
selecting it in the developer tools. In the column on the right, we can&#13;
see that the <code>StarRating</code> component incorporates a state Hook that has a&#13;
value of <code>2</code>. As we interact with the app, we can watch the state value&#13;
change and the component tree rerender with the corresponding number of&#13;
stars selected.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45901639327160">&#13;
<h5>React State the “Old Way”</h5>&#13;
<p>In<a data-primary="state management" data-secondary="prior to release of hooks" data-type="indexterm" id="idm45901639325624"/><a data-primary="class components" data-type="indexterm" id="idm45901639324600"/> previous versions of React, before v16.8.0, the only way to add state&#13;
to a component was to use a class component. This required not only a&#13;
lot of syntax, but it also made it more difficult to reuse functionality&#13;
across components. Hooks were designed to solve problems presented with&#13;
class components by providing a solution to incorporate functionality&#13;
into function components.</p>&#13;
&#13;
<p>The following code is a class component. This was the original&#13;
<code>StarRating</code> component that was printed in the first edition of this book:</p>&#13;
&#13;
<pre data-type="programlisting">import React, { Component } from "react";&#13;
&#13;
export default class StarRating extends Component {&#13;
  constructor(props) {&#13;
    super(props);&#13;
    this.state = {&#13;
      starsSelected: 0&#13;
    };&#13;
    this.change = this.change.bind(this);&#13;
  }&#13;
&#13;
  change(starsSelected) {&#13;
    this.setState({ starsSelected });&#13;
  }&#13;
&#13;
  render() {&#13;
    const { totalStars } = this.props;&#13;
    const { starsSelected } = this.state;&#13;
    return (&#13;
      &lt;div&gt;&#13;
        {[...Array(totalStars)].map((n, i) =&gt; (&#13;
          &lt;Star&#13;
            key={i}&#13;
            selected={i &lt; starsSelected}&#13;
            onClick={() =&gt; this.change(i + 1)}&#13;
          /&gt;&#13;
        ))}&#13;
        &lt;p&gt;&#13;
          {starsSelected} of {totalStars} stars&#13;
        &lt;/p&gt;&#13;
      &lt;/div&gt;&#13;
    );&#13;
  }&#13;
}</pre>&#13;
&#13;
<p>This class component does the same thing as our function component with&#13;
noticeably more code. Additionally, it introduces more confusion&#13;
thorough the use of the <code>this</code> keyword and function binding.</p>&#13;
&#13;
<p>As of today, this code still works. We’re no longer covering class&#13;
components in this book because they’re no longer needed. Function&#13;
components and Hooks are the future of React, and we’re not looking&#13;
back. There could come a day where class components are officially&#13;
deprecated, and this code will no longer be supported.<a data-primary="" data-startref="SMusestate06" data-type="indexterm" id="idm45901639319320"/><a data-primary="" data-startref="Husestate06" data-type="indexterm" id="idm45901639318344"/><a data-primary="" data-startref="usestate06" data-type="indexterm" id="idm45901639317400"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring for Advanced Reusability" data-type="sect1"><div class="sect1" id="idm45901639714072">&#13;
<h1>Refactoring for Advanced Reusability</h1>&#13;
&#13;
<p>Right now, the Star component is ready for production. You can use it&#13;
across several applications when you need to obtain a rating from a user.&#13;
However, if we were to ship this component to npm so that anyone in the world&#13;
could use it to obtain ratings from users, we may want to consider&#13;
handling a couple more use cases.</p>&#13;
&#13;
<p>First, let’s consider the <code>style</code> property. This property allows you to&#13;
add CSS styles to elements. It is highly possible that a future developer,&#13;
even yourself, could come across the need to modify the style of your entire container.&#13;
They may attempt to do something like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">StarRating</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">backgroundColor</code><code class="o">:</code> <code class="s2">"lightblue"</code> <code class="p">}}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>All React elements have style properties. A lot of components also have style properties.&#13;
So attempting to modify the style for the entire component seems sensible.</p>&#13;
&#13;
<p>All we need to do is collect those styles and pass them down to the <code>StarRating</code> container.&#13;
Currently, the <code>StarRating</code> does not have a single container because we are using a React fragment. To make this work, we’ll have to upgrade from a fragment to a <code>div</code> element and pass the styles to&#13;
that <code>div</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">({</code> <code class="nx">style</code> <code class="o">=</code> <code class="p">{},</code> <code class="nx">totalStars</code> <code class="o">=</code> <code class="mi">5</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">selectedStars</code><code class="p">,</code> <code class="nx">setSelectedStars</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">padding</code><code class="o">:</code> <code class="s2">"5px"</code><code class="p">,</code> <code class="p">...</code><code class="nx">style</code> <code class="p">}}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">createArray</code><code class="p">(</code><code class="nx">totalStars</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">n</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nx">Star</code>&#13;
          <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code>&#13;
          <code class="nx">selected</code><code class="o">=</code><code class="p">{</code><code class="nx">selectedStars</code> <code class="o">&gt;</code> <code class="nx">i</code><code class="p">}</code>&#13;
          <code class="nx">onSelect</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setSelectedStars</code><code class="p">(</code><code class="nx">i</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)}</code>&#13;
        <code class="o">/&gt;</code>&#13;
      <code class="p">))}</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">selectedStars</code><code class="p">}</code> <code class="k">of</code> <code class="p">{</code><code class="nx">totalStars</code><code class="p">}</code> <code class="nx">stars</code>&#13;
      <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the code above, we replaced the fragment with a <code>div</code> element and then applied&#13;
styles to that <code>div</code> element. By default we assign that <code>div</code> a padding of <code>5px</code>,&#13;
and then we use the spread operator to apply the rest of the properties from the <code>style</code>&#13;
object to the <code>div</code> style.</p>&#13;
&#13;
<p>Additionally, we may find developers who attempt to implement other common properties&#13;
properties to the entire star rating:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">StarRating</code>&#13;
      <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">backgroundColor</code><code class="o">:</code> <code class="s2">"lightblue"</code> <code class="p">}}</code>&#13;
      <code class="nx">onDoubleClick</code><code class="o">=</code><code class="p">{</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">alert</code><code class="p">(</code><code class="s2">"double click"</code><code class="p">)}</code>&#13;
    <code class="o">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this sample, the user is trying to add a double-click method to the&#13;
entire <code>StarRating</code> component. If we feel it is necessary, we can also pass&#13;
this method along with any other properties down to our containing <code>div</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">({</code> <code class="nx">style</code> <code class="o">=</code> <code class="p">{},</code> <code class="nx">totalStars</code> <code class="o">=</code> <code class="mi">5</code><code class="p">,</code> <code class="p">...</code><code class="nx">props</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">selectedStars</code><code class="p">,</code> <code class="nx">setSelectedStars</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">padding</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code> <code class="p">...</code><code class="nx">style</code> <code class="p">}}</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="p">...</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The first step is to collect any and all properties that the user may be attempting&#13;
to add to the <code>StarRating</code>. We gather these properties using the spread operator: <code>...props</code>. Next,&#13;
we’ll pass all of these remaining properties down to the <code>div</code> element: <code>{...props}</code>.<a data-primary="spreading props" data-type="indexterm" id="idm45901638989688"/></p>&#13;
&#13;
<p>By doing this, we make two assumptions. First, we are assuming that users will add&#13;
only those properties that are supported by the div element. Second, we are assuming that&#13;
our user can’t add malicious properties to the component.</p>&#13;
&#13;
<p>This is not a blanket rule to apply to all of your components. In fact, it’s only&#13;
a good idea to add this level of support in certain situations. The real point is that&#13;
it’s important to think about how the consumers of your component may try to use&#13;
it in the future.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="State in Component Trees" data-type="sect1"><div class="sect1" id="state-in-component-trees">&#13;
<h1>State in Component Trees</h1>&#13;
&#13;
<p>It’s<a data-primary="state management" data-secondary="component trees" data-type="indexterm" id="SMcomponent06"/><a data-primary="component trees" data-secondary="managing state from one location" data-type="indexterm" id="idm45901638984344"/> not a great idea to use state in every single component. Having&#13;
state data distributed throughout too many of your components will make&#13;
it harder to track down bugs and make changes within your application.&#13;
This occurs because it’s hard to keep track of where the state values&#13;
live within your component tree. It’s easier to understand your&#13;
application’s state, or state for a specific feature, if you&#13;
 manage it from one location. There are several approaches to this&#13;
methodology, and the first one we’ll analyze is storing state at the&#13;
root of the component tree and passing it down to child components via&#13;
props.</p>&#13;
&#13;
<p>Let’s build a small application that can be used to save a list of&#13;
colors. We’ll call the app the “Color Organizer”, and it will allow&#13;
users to associate a list of colors with a custom title and rating. To&#13;
get started, a sample dataset may look like the following:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nt">"id"</code><code class="p">:</code> <code class="s2">"0175d1f0-a8c6-41bf-8d02-df5734d829a4"</code><code class="p">,</code>&#13;
    <code class="nt">"title"</code><code class="p">:</code> <code class="s2">"ocean at dusk"</code><code class="p">,</code>&#13;
    <code class="nt">"color"</code><code class="p">:</code> <code class="s2">"#00c4e2"</code><code class="p">,</code>&#13;
    <code class="nt">"rating"</code><code class="p">:</code> <code class="mi">5</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nt">"id"</code><code class="p">:</code> <code class="s2">"83c7ba2f-7392-4d7d-9e23-35adbe186046"</code><code class="p">,</code>&#13;
    <code class="nt">"title"</code><code class="p">:</code> <code class="s2">"lawn"</code><code class="p">,</code>&#13;
    <code class="nt">"color"</code><code class="p">:</code> <code class="s2">"#26ac56"</code><code class="p">,</code>&#13;
    <code class="nt">"rating"</code><code class="p">:</code> <code class="mi">3</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nt">"id"</code><code class="p">:</code> <code class="s2">"a11e3995-b0bd-4d58-8c48-5e49ae7f7f23"</code><code class="p">,</code>&#13;
    <code class="nt">"title"</code><code class="p">:</code> <code class="s2">"bright red"</code><code class="p">,</code>&#13;
    <code class="nt">"color"</code><code class="p">:</code> <code class="s2">"#ff0000"</code><code class="p">,</code>&#13;
    <code class="nt">"rating"</code><code class="p">:</code> <code class="mi">0</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>The <em>color-data.json</em> file contains an array of three colors. Each color&#13;
has an <code>id</code>, <code>title</code>, <code>color</code>, and <code>rating</code>. First, we’ll create a UI&#13;
consisting of React components that will be used to display this data in&#13;
a browser. Then we’ll allow the users to add new colors as well as&#13;
rate and remove colors from the list.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sending State Down a Component Tree" data-type="sect2"><div class="sect2" id="sending-state-down-a-component-tree">&#13;
<h2>Sending State Down a Component Tree</h2>&#13;
&#13;
<p>In<a data-primary="component trees" data-secondary="sending state down" data-type="indexterm" id="idm45901638877992"/> this iteration, we’ll store state in the root of the Color&#13;
Organizer, the <code>App</code> component, and pass the colors down to child&#13;
components to handle the rendering. The <code>App</code> component will be the only&#13;
component within our application that holds state. We’ll add the list&#13;
of colors to the <code>App</code> with the <code>useState</code> hook:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">colorData</code> <code class="nx">from</code> <code class="s2">"./color-data.json"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ColorList</code> <code class="nx">from</code> <code class="s2">"./ColorList.js"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">colors</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">colorData</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">ColorList</code> <code class="nx">colors</code><code class="o">=</code><code class="p">{</code><code class="nx">colors</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>App</code> component sits at the root of our tree. Adding <code>useState</code> to&#13;
this component hooks it up with state management for colors. In this&#13;
example, the <code>colorData</code> is the array of sample colors from above. The&#13;
<code>App</code> component uses the <code>colorData</code> as the initial state for <code>colors</code>.&#13;
From there, the <code>colors</code> are passed down to a component called the&#13;
<code>ColorList</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">Color</code> <code class="nx">from</code> <code class="s2">"./Color"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">ColorList</code><code class="p">({</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[]</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">colors</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="k">return</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">No</code> <code class="nx">Colors</code> <code class="nx">Listed</code><code class="p">.</code><code class="o">&lt;</code><code class="err">/div&gt;;</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">colors</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">color</code> <code class="o">=&gt;</code> <code class="o">&lt;</code><code class="nx">Color</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">color</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code> <code class="p">{...</code><code class="nx">color</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">)</code>&#13;
      <code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>ColorList</code> receives the colors from the <code>App</code> component as props.&#13;
If the list is empty, this component will display a message to our&#13;
users. When we have a color array, we can map over it and pass the&#13;
details about each color farther down the tree to the <code>Color</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Color</code><code class="p">({</code> <code class="nx">title</code><code class="p">,</code> <code class="nx">color</code><code class="p">,</code> <code class="nx">rating</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">section</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">title</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">height</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="nx">backgroundColor</code><code class="o">:</code> <code class="nx">color</code> <code class="p">}}</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">StarRating</code> <code class="nx">selectedStars</code><code class="o">=</code><code class="p">{</code><code class="nx">rating</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/section&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>Color</code> component expects three properties: <code>title</code>, <code>color</code>, and&#13;
<code>rating</code>. These values are found in each <code>color</code> object and were passed to&#13;
this component using the spread operator <code>&lt;Color {...color} /&gt;</code>. This&#13;
takes each field from the <code>color</code> object and passes it to the <code>Color</code>&#13;
component as a property with the same name as the object key. The&#13;
<code>Color</code> component displays these values. The <code>title</code> is rendered inside&#13;
of an <code>h1</code> element. The <code>color</code> value is displayed as the&#13;
<code>backgroundColor</code> for a <code>div</code> element. The <code>rating</code> is passed farther&#13;
down the tree to the <code>StarRating</code> component, which will display the&#13;
rating visually as selected stars:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">({</code> <code class="nx">totalStars</code> <code class="o">=</code> <code class="mi">5</code><code class="p">,</code> <code class="nx">selectedStars</code> <code class="o">=</code> <code class="mi">0</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="p">{</code><code class="nx">createArray</code><code class="p">(</code><code class="nx">totalStars</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">n</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nx">Star</code>&#13;
          <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code>&#13;
          <code class="nx">selected</code><code class="o">=</code><code class="p">{</code><code class="nx">selectedStars</code> <code class="o">&gt;</code> <code class="nx">i</code><code class="p">}</code>&#13;
        <code class="o">/&gt;</code>&#13;
      <code class="p">))}</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">selectedStars</code><code class="p">}</code> <code class="k">of</code> <code class="p">{</code><code class="nx">totalStars</code><code class="p">}</code> <code class="nx">stars</code>&#13;
      <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This <code>StarRating</code> component has been modified. We’ve turned it into a&#13;
pure component. A pure component is a function component that does&#13;
not contain state and will render the same user interface given the same&#13;
props. We made this component a pure component because the state for&#13;
color ratings are stored in the <code>colors</code> array at the root of the&#13;
component tree. Remember that the goal of this iteration is to store state in&#13;
a single location and not have it distributed through many different&#13;
components within the tree.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It is possible for the <code>StarRating</code> component to hold its own state and&#13;
receive state from a parent component via props. This is typically&#13;
necessary when distributing components for wider use by the community.&#13;
We demonstrate this technique in the next chapter when we cover the&#13;
<code>useEffect</code> hook.</p>&#13;
</div>&#13;
&#13;
<p>At this point, we’ve finished passing state down the component tree&#13;
from the <code>App</code> component all the way to each <code>Star</code> component that’s&#13;
filled red to visually represent the <code>rating</code> for each color. If we&#13;
render the app based on the <em>color-data.json</em> file that was listed previously, we&#13;
should see our colors in the browser, as shown in <a data-type="xref" href="#color_organizer">Figure 6-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="color_organizer">&#13;
<img alt="lrc2 0605" src="assets/lrc2_0605.png"/>&#13;
<h6><span class="label">Figure 6-5. </span>Color Organizer rendered in the browser</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sending Interactions Back up a Component Tree" data-type="sect2"><div class="sect2" id="sending-interactions-back-up-a-component-tree">&#13;
<h2>Sending Interactions Back up a Component Tree</h2>&#13;
&#13;
<p>So<a data-primary="component trees" data-secondary="sending interactions back up" data-type="indexterm" id="CTup06"/> far, we’ve rendered a representation of the <code>colors</code> array as UI by&#13;
composing React components and passing data down the tree from parent&#13;
component to child component via props. What happens if we want to&#13;
remove a color from the list or change the rating of a color in our&#13;
list? The <code>colors</code> are stored in state at the root of our tree. We’ll&#13;
need to collect interactions from child components and send them back up&#13;
the tree to the root component where we can change the state.</p>&#13;
&#13;
<p>For instance, let’s say we wanted to add a Remove button next to each&#13;
color’s title that would allow users to remove colors from state. We&#13;
would add that button to the <code>Color</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">FaTrash</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react-icons/fa"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Color</code><code class="p">({</code> <code class="nx">id</code><code class="p">,</code> <code class="nx">title</code><code class="p">,</code> <code class="nx">color</code><code class="p">,</code> <code class="nx">rating</code><code class="p">,</code> <code class="nx">onRemove</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">section</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">title</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">onRemove</code><code class="p">(</code><code class="nx">id</code><code class="p">)}</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">FaTrash</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">height</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="nx">backgroundColor</code><code class="o">:</code> <code class="nx">color</code> <code class="p">}}</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">StarRating</code> <code class="nx">selectedStars</code><code class="o">=</code><code class="p">{</code><code class="nx">rating</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/section&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, we’ve modified the color by adding a button that will allow users&#13;
to remove colors. First, we imported a trash can icon from&#13;
<code>react-icons</code>. Next, we wrapped the <code>FaTrash</code> icon in a button. Adding an&#13;
<code>onClick</code> handler to this button allows us to invoke the <code>onRemove</code>&#13;
function property, which has been added to our list of properties along&#13;
with the <code>id</code>. When a user clicks the Remove button, we’ll invoke&#13;
<code>removeColor</code> and pass it the <code>id</code> of the color that we want to remove.&#13;
That is why the <code>id</code> value has also been gathered from the <code>Color</code>&#13;
component’s properties.</p>&#13;
&#13;
<p>This solution is great because we keep the <code>Color</code> component pure. It&#13;
doesn’t have state and can easily be reused in a different part of the&#13;
app or another application altogether. The <code>Color</code> component is not&#13;
concerned with what happens when a user clicks the Remove button. All it&#13;
cares about is notifying the parent that this event has occurred and&#13;
passing the information about which color the user wishes to remove. It’s now the parent’s responsibility to handle this event:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">ColorList</code><code class="p">({</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[],</code> <code class="nx">onRemoveColor</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">colors</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="k">return</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">No</code> <code class="nx">Colors</code> <code class="nx">Listed</code><code class="p">.</code> <code class="p">(</code><code class="nx">Add</code> <code class="nx">a</code> <code class="nx">Color</code><code class="p">)</code><code class="o">&lt;</code><code class="err">/div&gt;;</code>&#13;
&#13;
<code class="k">return</code> <code class="p">(</code>&#13;
    <code class="nx">colors</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">color</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
          <code class="o">&lt;</code><code class="nx">Color</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">color</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code> <code class="p">{...</code><code class="nx">color</code><code class="p">}</code> <code class="nx">onRemove</code><code class="o">=</code><code class="p">{</code><code class="nx">onRemoveColor</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
        <code class="p">)</code>&#13;
      <code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>Color</code> component’s parent is the <code>ColorList</code>. This component also&#13;
doesn’t have access to state. Instead of removing the color, it simply&#13;
passes the event up to its parent. It accomplishes this by adding an&#13;
<code>onRemoveColor</code> function property. If a <code>Color</code> component invokes the&#13;
<code>onRemove</code> property, the <code>ColorList</code> will in turn invoke its&#13;
<code>onRemoveColor</code> property and send the responsibility for removing the&#13;
color up to its parent. The color’s <code>id</code> is still being passed to the&#13;
<code>onRemoveColor</code> function.</p>&#13;
&#13;
<p>The parent of the <code>ColorList</code> is the <code>App</code>. This component is the&#13;
component that has been hooked up with state. This is where we can&#13;
capture the color <code>id</code> and remove the color in state:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">colors</code><code class="p">,</code> <code class="nx">setColors</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">colorData</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">ColorList</code>&#13;
      <code class="nx">colors</code><code class="o">=</code><code class="p">{</code><code class="nx">colors</code><code class="p">}</code>&#13;
      <code class="nx">onRemoveColor</code><code class="o">=</code><code class="p">{</code><code class="nx">id</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="kr">const</code> <code class="nx">newColors</code> <code class="o">=</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">color</code> <code class="o">=&gt;</code> <code class="nx">color</code><code class="p">.</code><code class="nx">id</code> <code class="o">!==</code> <code class="nx">id</code><code class="p">);</code>&#13;
        <code class="nx">setColors</code><code class="p">(</code><code class="nx">newColors</code><code class="p">);</code>&#13;
      <code class="p">}}</code>&#13;
    <code class="o">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First, we add a variable for <code>setColors</code>. Remember that the second&#13;
argument in the array returned by <code>useState</code> is a function we can&#13;
use to modify the state. When the <code>ColorList</code> raises an <code>onRemoveColor</code>&#13;
event, we capture the <code>id</code> of the color to remove from the arguments and&#13;
use it to filter the list of colors to exclude the color the user&#13;
wants to remove. Next, we change the state. We use the <code>setColors</code>&#13;
function to change change the array of colors to the newly filtered&#13;
array.</p>&#13;
&#13;
<p>Changing the state of the <code>colors</code> array causes the <code>App</code> component to&#13;
be rerendered with the new list of colors. Those new colors are passed&#13;
to the <code>ColorList</code> component, which is also rerendered. It will render&#13;
<code>Color</code> components for the remaining colors and our UI will reflect the&#13;
changes we’ve made by rendering one less color.</p>&#13;
&#13;
<p>If we want to rate the <code>colors</code> that are stored in the <code>App</code> components&#13;
state, we’ll have to repeat the process with an <code>onRate</code> event. First,&#13;
we’ll collect the new rating from the individual star that was&#13;
clicked and pass that value to the parent of the <code>StarRating</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">StarRating</code><code class="p">({</code>&#13;
  <code class="nx">totalStars</code> <code class="o">=</code> <code class="mi">5</code><code class="p">,</code>&#13;
  <code class="nx">selectedStars</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="nx">onRate</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code>&#13;
<code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="p">{</code><code class="nx">createArray</code><code class="p">(</code><code class="nx">totalStars</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">n</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nx">Star</code>&#13;
          <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code>&#13;
          <code class="nx">selected</code><code class="o">=</code><code class="p">{</code><code class="nx">selectedStars</code> <code class="o">&gt;</code> <code class="nx">i</code><code class="p">}</code>&#13;
          <code class="nx">onSelect</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">onRate</code><code class="p">(</code><code class="nx">i</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)}</code>&#13;
        <code class="o">/&gt;</code>&#13;
      <code class="p">))}</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then, we’ll grab the rating from the <code>onRate</code> handler we&#13;
added to the <code>StarRating</code> component. We’ll then pass the new rating along&#13;
with the <code>id</code> of the color to be rated up to the <code>Color</code> component’s&#13;
parent via another <code>onRate</code> function property:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Color</code><code class="p">({</code>&#13;
  <code class="nx">id</code><code class="p">,</code>&#13;
  <code class="nx">title</code><code class="p">,</code>&#13;
  <code class="nx">color</code><code class="p">,</code>&#13;
  <code class="nx">rating</code><code class="p">,</code>&#13;
  <code class="nx">onRemove</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">,</code>&#13;
  <code class="nx">onRate</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code>&#13;
<code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">section</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">title</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">onRemove</code><code class="p">(</code><code class="nx">id</code><code class="p">)}</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">FaTrash</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">height</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="nx">backgroundColor</code><code class="o">:</code> <code class="nx">color</code> <code class="p">}}</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">StarRating</code>&#13;
        <code class="nx">selectedStars</code><code class="o">=</code><code class="p">{</code><code class="nx">rating</code><code class="p">}</code>&#13;
        <code class="nx">onRate</code><code class="o">=</code><code class="p">{</code><code class="nx">rating</code> <code class="o">=&gt;</code> <code class="nx">onRate</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">rating</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/section&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the <code>ColorList</code> component, we’ll have to capture the <code>onRate</code> event&#13;
from individual color components and pass them up to its parent via the&#13;
<code>onRateColor</code> function <span class="keep-together">property</span>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">ColorList</code><code class="p">({</code>&#13;
  <code class="nx">colors</code> <code class="o">=</code> <code class="p">[],</code>&#13;
  <code class="nx">onRemoveColor</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">,</code>&#13;
  <code class="nx">onRateColor</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code>&#13;
<code class="p">})</code> <code class="p">{</code>&#13;
<code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">colors</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="k">return</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">No</code> <code class="nx">Colors</code> <code class="nx">Listed</code><code class="p">.</code> <code class="p">(</code><code class="nx">Add</code> <code class="nx">a</code> <code class="nx">Color</code><code class="p">)</code><code class="o">&lt;</code><code class="err">/div&gt;;</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"color-list"</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">colors</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">color</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
          <code class="o">&lt;</code><code class="nx">Color</code>&#13;
            <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">color</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code>&#13;
            <code class="p">{...</code><code class="nx">color</code><code class="p">}</code>&#13;
            <code class="nx">onRemove</code><code class="o">=</code><code class="p">{</code><code class="nx">onRemoveColor</code><code class="p">}</code>&#13;
            <code class="nx">onRate</code><code class="o">=</code><code class="p">{</code><code class="nx">onRateColor</code><code class="p">}</code>&#13;
          <code class="o">/&gt;</code>&#13;
        <code class="p">)</code>&#13;
      <code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, after passing the event up through all of these components, we’ll&#13;
arrive at the <code>App</code>, where state is stored and the new rating can be&#13;
saved:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">colors</code><code class="p">,</code> <code class="nx">setColors</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">colorData</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">ColorList</code>&#13;
      <code class="nx">colors</code><code class="o">=</code><code class="p">{</code><code class="nx">colors</code><code class="p">}</code>&#13;
      <code class="nx">onRateColor</code><code class="o">=</code><code class="p">{(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">rating</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="kr">const</code> <code class="nx">newColors</code> <code class="o">=</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">color</code> <code class="o">=&gt;</code>&#13;
          <code class="nx">color</code><code class="p">.</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">id</code> <code class="o">?</code> <code class="p">{</code> <code class="p">...</code><code class="nx">color</code><code class="p">,</code> <code class="nx">rating</code> <code class="p">}</code> <code class="o">:</code> <code class="nx">color</code>&#13;
        <code class="p">);</code>&#13;
        <code class="nx">setColors</code><code class="p">(</code><code class="nx">newColors</code><code class="p">);</code>&#13;
      <code class="p">}}</code>&#13;
      <code class="nx">onRemoveColor</code><code class="o">=</code><code class="p">{</code><code class="nx">id</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="kr">const</code> <code class="nx">newColors</code> <code class="o">=</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">color</code> <code class="o">=&gt;</code> <code class="nx">color</code><code class="p">.</code><code class="nx">id</code> <code class="o">!==</code> <code class="nx">id</code><code class="p">);</code>&#13;
        <code class="nx">setColors</code><code class="p">(</code><code class="nx">newColors</code><code class="p">);</code>&#13;
      <code class="p">}}</code>&#13;
    <code class="o">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>App</code> component will change color ratings when the <code>ColorList</code>&#13;
invokes the <span class="keep-together"><code>onRateColor</code></span> property with the <code>id</code> of the color to rate and&#13;
the new rating. We’ll use those values to construct an array of new&#13;
colors by mapping over the existing colors and changing the rating for&#13;
the color that matches the <code>id</code> property. Once we send the <code>newColors</code>&#13;
to the <code>setColors</code> function, the state value for <code>colors</code> will change and&#13;
the <code>App</code> component will be invoked with a new value for the <code>colors</code>&#13;
array.<a data-primary="" data-startref="CTup06" data-type="indexterm" id="idm45901637595144"/><a data-primary="" data-startref="SMcomponent06" data-type="indexterm" id="idm45901637594136"/></p>&#13;
&#13;
<p>Once the state of our <code>colors</code> array changes, the UI tree is rendered with the new data. The new rating is reflected back to the user via red stars. Just as we passed data down a component tree via props, interactions can be passed back up the tree along with data via function properties.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building Forms" data-type="sect1"><div class="sect1" id="building-forms">&#13;
<h1>Building Forms</h1>&#13;
&#13;
<p>For<a data-primary="state management" data-secondary="building forms" data-type="indexterm" id="SMforms06"/><a data-primary="forms" data-secondary="rendering with JSX" data-type="indexterm" id="idm45901637589768"/><a data-primary="JSX language extension" data-secondary="rendering forms with" data-type="indexterm" id="idm45901637588824"/> a lot of us, being a web developer means collecting&#13;
large amounts of information from users with forms. If this sounds like&#13;
your job, then you’ll be building a lot of form components with React.&#13;
All of the HTML form elements that are available to the DOM are also&#13;
available as React elements, which means that you may already know how&#13;
to render a form with JSX:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="nt">&lt;form&gt;</code>&#13;
  <code class="nt">&lt;input</code> <code class="na">type=</code><code class="s">"text"</code> <code class="na">placeholder=</code><code class="s">"color title..."</code> <code class="na">required</code> <code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;input</code> <code class="na">type=</code><code class="s">"color"</code> <code class="na">required</code> <code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;button&gt;</code>ADD<code class="nt">&lt;/button&gt;</code>&#13;
<code class="nt">&lt;/form&gt;</code></pre>&#13;
&#13;
<p>This<a data-primary="forms" data-secondary="form and child elements" data-type="indexterm" id="idm45901637568632"/> <code>form</code> element has three child elements: two <code>input</code> elements and&#13;
a <code>button</code>. The first <code>input</code> element is a text input that will be used&#13;
to collect the <code>title</code> value for new colors. The second <code>input</code> element&#13;
is an HTML color input that will allow users to pick a <code>color</code> from a&#13;
color wheel. We’ll be using basic HTML form validation, so we’ve marked&#13;
both inputs as <code>required</code>. The ADD button will be used to add a new&#13;
color.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Refs" data-type="sect2"><div class="sect2" id="using-refs">&#13;
<h2>Using Refs</h2>&#13;
&#13;
<p>When<a data-primary="forms" data-secondary="building with refs" data-type="indexterm" id="idm45901637562120"/><a data-primary="refs, building forms with" data-type="indexterm" id="idm45901637561112"/> it’s time to build a form component in React, there are several&#13;
patterns available to you. One of these patterns involves accessing the&#13;
DOM node directly using a React feature called refs. In React, a ref&#13;
is an object that stores values for the lifetime of a component.&#13;
There are several use cases that involve using refs. In this section,&#13;
we’ll look at how we can access a DOM node directly with a ref.</p>&#13;
&#13;
<p>React<a data-primary="useRef hook" data-secondary="building components" data-type="indexterm" id="idm45901637559528"/><a data-primary="hooks" data-secondary="useRef hook" data-type="indexterm" id="idm45901637558520"/> provides us with a <code>useRef</code> hook that we can use to create a <em>ref</em>.&#13;
We’ll use this hook when building the <code>AddColorForm</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useRef</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">AddColorForm</code><code class="p">({</code> <code class="nx">onNewColor</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">txtTitle</code> <code class="o">=</code> <code class="nx">useRef</code><code class="p">();</code>&#13;
  <code class="kr">const</code> <code class="nx">hexColor</code> <code class="o">=</code> <code class="nx">useRef</code><code class="p">();</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">submit</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="p">...</code> <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(...)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First, when creating this component, we’ll also create two refs using&#13;
the <code>useRef</code> hook. The <code>txtTitle</code> ref will be used to reference the text&#13;
input we’ve added to the form to collect the color title. The&#13;
<code>hexColor</code> ref will be used to access hexadecimal color values from the&#13;
HTML color input. We can set the values for these refs directly in JSX&#13;
using the <code>ref</code> property:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting">  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">form</code> <code class="nx">onSubmit</code><code class="o">=</code><code class="p">{</code><code class="nx">submit</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">txtTitle</code><code class="p">}</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"text"</code> <code class="nx">placeholder</code><code class="o">=</code><code class="s2">"color title..."</code> <code class="nx">required</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">hexColor</code><code class="p">}</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"color"</code> <code class="nx">required</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code><code class="o">&gt;</code><code class="nx">ADD</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/form&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, we set the value for the <code>txtTitle</code> and <code>hexColor</code> refs by adding&#13;
the <code>ref</code> attribute to these input elements in JSX. This creates a&#13;
<code>current</code> field on our ref object that references the DOM element&#13;
directly. This provides us access to the DOM element, which means we can&#13;
capture its value. When the user submits this form by clicking the&#13;
ADD button, we’ll invoke the <code>submit</code> function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">submit</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">e</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code>&#13;
  <code class="kr">const</code> <code class="nx">title</code> <code class="o">=</code> <code class="nx">txtTitle</code><code class="p">.</code><code class="nx">current</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>&#13;
  <code class="kr">const</code> <code class="nx">color</code> <code class="o">=</code> <code class="nx">hexColor</code><code class="p">.</code><code class="nx">current</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>&#13;
  <code class="nx">onNewColor</code><code class="p">(</code><code class="nx">title</code><code class="p">,</code> <code class="nx">color</code><code class="p">);</code>&#13;
  <code class="nx">txtTitle</code><code class="p">.</code><code class="nx">current</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>&#13;
  <code class="nx">hexColor</code><code class="p">.</code><code class="nx">current</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>When we submit HTML forms, by default, they send a POST request to the&#13;
current URL with the values of the form elements stored in the body. We&#13;
don’t want to do that. This is why the first line of code in the <code>submit</code>&#13;
function is <code>e.preventDefault()</code>, which prevents the browser from trying&#13;
to submit the form with a POST request.</p>&#13;
&#13;
<p>Next, we capture the current values for each of our form elements using&#13;
their refs. These values are then passed up to this component’s parent&#13;
via the <code>onNewColor</code> function property. Both the title and the&#13;
hexadecimal value for the new color are passed as function arguments.&#13;
Finally, we reset the <code>value</code> attribute for both inputs to clear the&#13;
data and prepare the form to collect another color.</p>&#13;
&#13;
<p>Did you notice the subtle paradigm shift that has occurred by using refs? We’re mutating the <code>value</code> attribute of DOM nodes directly by setting them&#13;
equal to <code>""</code> empty strings. This is imperative code. The <code>AddColorForm</code>&#13;
is now what we call an <em>uncontrolled component</em> because it uses the DOM&#13;
to save the form values. Sometimes using uncontrolled component can&#13;
get you out of problems. For instance, you may want to share access to a&#13;
form and its values with code outside of React. However, a controlled&#13;
component is a better approach.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Controlled Components" data-type="sect2"><div class="sect2" id="controlled-components">&#13;
<h2>Controlled Components</h2>&#13;
&#13;
<p>In<a data-primary="forms" data-secondary="controlled components" data-type="indexterm" id="idm45901637275352"/><a data-primary="components" data-secondary="controlled components" data-type="indexterm" id="idm45901637274344"/><a data-primary="controlled components" data-type="indexterm" id="idm45901637273400"/> a <em>controlled component</em>, the from values are managed by React and not&#13;
the DOM. They do not require us to use refs. They do not require us to&#13;
write imperative code. Adding features like robust form validation is&#13;
much easier when working with a controlled component. Let’s modify&#13;
the <code>AddColorForm</code> by giving it control over the form’s state:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">AddColorForm</code><code class="p">({</code> <code class="nx">onNewColor</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">title</code><code class="p">,</code> <code class="nx">setTitle</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">color</code><code class="p">,</code> <code class="nx">setColor</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">"#000000"</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">submit</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="p">...</code> <code class="p">};</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code> <code class="p">...</code> <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First, instead of using refs, we’re going to save the values for the&#13;
<code>title</code> and <code>color</code> using React state. We’ll&#13;
create variables for <code>title</code> and <code>color</code>. Additionally, we’ll&#13;
define the functions that can be used to change state: <code>setTitle</code> and&#13;
<code>setColor</code>.</p>&#13;
&#13;
<p>Now that the component controls the values for <code>title</code> and <code>color</code>, we&#13;
can display them inside of the form input elements by setting the&#13;
<code>value</code> attribute. Once we set the <code>value</code> attribute of an input&#13;
element, we’ll no longer be able to change with the form. The only way&#13;
to change the value at this point would be to change the state variable&#13;
every time the user types a new character in the input element. That’s&#13;
exactly what we’ll do:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">form</code> <code class="nx">onSubmit</code><code class="o">=</code><code class="p">{</code><code class="nx">submit</code><code class="p">}</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">input</code>&#13;
    <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">title</code><code class="p">}</code>&#13;
    <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">event</code> <code class="o">=&gt;</code> <code class="nx">setTitle</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
    <code class="nx">type</code><code class="o">=</code><code class="s2">"text"</code>&#13;
    <code class="nx">placeholder</code><code class="o">=</code><code class="s2">"color title..."</code>&#13;
    <code class="nx">required</code>&#13;
  <code class="o">/&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">input</code>&#13;
    <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">color</code><code class="p">}</code>&#13;
    <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">event</code> <code class="o">=&gt;</code> <code class="nx">setColor</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
    <code class="nx">type</code><code class="o">=</code><code class="s2">"color"</code>&#13;
    <code class="nx">required</code>&#13;
  <code class="o">/&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">button</code><code class="o">&gt;</code><code class="nx">ADD</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
<code class="o">&lt;</code><code class="err">/form&gt;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This controlled component now sets the value of both <code>input</code> elements&#13;
using the <code>title</code> and <code>color</code> from state. Whenever these elements raise&#13;
an <code>onChange</code> event, we can access the new value using the <code>event</code>&#13;
argument. The <code>event.target</code> is a reference to the DOM element, so we can&#13;
obtain the current value of that element with <code>event.target.value</code>. When&#13;
the <code>title</code> changes, we’ll invoke <code>setTitle</code> to change the title value&#13;
in state. Changing that value will cause this component to rerender, and&#13;
we can now display the new value for <code>title</code> inside the <code>input</code> element.&#13;
Changing the color works exactly the same way.</p>&#13;
&#13;
<p>When it’s time to submit the form, we can simply pass the state values&#13;
for <code>title</code> and <code>color</code> to the <code>onNewColor</code> function property as&#13;
arguments when we invoke it. The <code>setTitle</code> and <code>setColor</code> functions can&#13;
be used to reset the values after the new color has been passed to the&#13;
parent component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">submit</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">e</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code>&#13;
  <code class="nx">onNewColor</code><code class="p">(</code><code class="nx">title</code><code class="p">,</code> <code class="nx">color</code><code class="p">);</code>&#13;
  <code class="nx">setTitle</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="nx">setColor</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>It’s called a controlled component because React controls the state&#13;
of the form. It’s worth pointing out that controlled form components are&#13;
rerendered, a lot. Think about it: every new character typed in the&#13;
<code>title</code> field causes the <code>AddColorForm</code> to rerender. Using the color&#13;
wheel in the color picker causes this component to rerender way more&#13;
than the <code>title</code> field because the color value repeatedly changes as the user drags the mouse around the color wheel. This is OK—React is designed to&#13;
handle this type of workload. Hopefully, knowing that controlled&#13;
components are rerendered frequently will prevent you from adding some&#13;
long and expensive process to this component. At the very least, this&#13;
knowledge will come in handy when you’re trying to optimize your React&#13;
components.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Custom Hooks" data-type="sect2"><div class="sect2" id="creating-custom-hooks">&#13;
<h2>Creating Custom Hooks</h2>&#13;
&#13;
<p>When<a data-primary="forms" data-secondary="custom hooks" data-type="indexterm" id="idm45901637027224"/><a data-primary="hooks" data-secondary="custom hooks" data-type="indexterm" id="idm45901637026216"/> you have a large form with a lot of <code>input</code> elements, you may be&#13;
tempted to copy and paste these two lines of code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">title</code><code class="p">}</code>&#13;
<code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">event</code> <code class="o">=&gt;</code> <code class="nx">setTitle</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code></pre>&#13;
&#13;
<p>It might seem like you’re working faster by simply copying and pasting these&#13;
properties into every form element while tweaking the variable names&#13;
along the way. However, whenever you copy and paste code, you should hear&#13;
a tiny little alarm sound in your head. Copying and pasting code&#13;
suggests that there’s something redundant enough to abstract away in a&#13;
function.</p>&#13;
&#13;
<p>We can package the details necessary to create controlled form&#13;
components into a custom hook. We<a data-primary="hooks" data-secondary="useInput hook" data-type="indexterm" id="idm45901637014840"/><a data-primary="useInput hook" data-type="indexterm" id="idm45901637013992"/> could create our own <code>useInput</code> hook&#13;
where we can abstract away the redundancy involved with creating&#13;
controlled form inputs:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">useInput</code> <code class="o">=</code> <code class="nx">initialValue</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">value</code><code class="p">,</code> <code class="nx">setValue</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">initialValue</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">[</code>&#13;
    <code class="p">{</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">onChange</code><code class="o">:</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">setValue</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code> <code class="p">},</code>&#13;
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">setValue</code><code class="p">(</code><code class="nx">initialValue</code><code class="p">)</code>&#13;
  <code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This is a custom hook. It doesn’t take a lot of code. Inside of this&#13;
hook, we’re still using the<a data-primary="state management" data-secondary="useState hook" data-type="indexterm" id="idm45901636934872"/><a data-primary="hooks" data-secondary="useState hook" data-type="indexterm" id="idm45901636856088"/><a data-primary="useState hook" data-type="indexterm" id="idm45901636855176"/> <code>useState</code> hook to create a state <code>value</code>.&#13;
Next, we return an array. The first value of the array is the object that&#13;
contains the same properties we were tempted to copy and paste: the&#13;
<code>value</code> from state along with an <code>onChange</code> function property that&#13;
changes that value in state. The second value in the array is a function&#13;
that can be reused to reset the <code>value</code> back to its initial value. We&#13;
can use our hook inside of the <code>AddColorForm</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useInput</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./hooks"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">AddColorForm</code><code class="p">({</code> <code class="nx">onNewColor</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">titleProps</code><code class="p">,</code> <code class="nx">resetTitle</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useInput</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">colorProps</code><code class="p">,</code> <code class="nx">resetColor</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useInput</code><code class="p">(</code><code class="s2">"#000000"</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">submit</code> <code class="o">=</code> <code class="nx">event</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="p">...</code> <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code> <code class="p">...</code> <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>useState</code> hook is encapsulated within our <code>useInput</code> hook. We can&#13;
obtain the properties for both the title and the color by destructuring&#13;
them from the first value of the returned array. The second value of&#13;
this array contains a function we can use to reset the <code>value</code>&#13;
property back to its initial value, an empty string. The <code>titleProps</code>&#13;
and <code>colorProps</code> are ready to be spread into their corresponding input&#13;
elements:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="k">return</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">form</code> <code class="nx">onSubmit</code><code class="o">=</code><code class="p">{</code><code class="nx">submit</code><code class="p">}</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">input</code>&#13;
      <code class="p">{...</code><code class="nx">titleProps</code><code class="p">}</code>&#13;
      <code class="nx">type</code><code class="o">=</code><code class="s2">"text"</code>&#13;
      <code class="nx">placeholder</code><code class="o">=</code><code class="s2">"color title..."</code>&#13;
      <code class="nx">required</code>&#13;
    <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">input</code> <code class="p">{...</code><code class="nx">colorProps</code><code class="p">}</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"color"</code> <code class="nx">required</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">button</code><code class="o">&gt;</code><code class="nx">ADD</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
  <code class="o">&lt;</code><code class="err">/form&gt;</code>&#13;
<code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Spreading these properties from our custom hook is much more fun than&#13;
pasting them. Now both the title and the color inputs are receiving&#13;
properties for their value and <code>onChange</code> events. We’ve used our hook to&#13;
create controlled form inputs without worrying about the underlying&#13;
implementation details. The only other change we need to make is&#13;
when this form is submitted:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">submit</code> <code class="o">=</code> <code class="nx">event</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">event</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code>&#13;
  <code class="nx">onNewColor</code><code class="p">(</code><code class="nx">titleProps</code><code class="p">.</code><code class="nx">value</code><code class="p">,</code> <code class="nx">colorProps</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>&#13;
  <code class="nx">resetTitle</code><code class="p">();</code>&#13;
  <code class="nx">resetColor</code><code class="p">();</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Within the <code>submit</code> function, we need to be sure to grab the <code>value</code> for&#13;
both the title and the color from their properties. Finally, we can use&#13;
the custom reset functions that were returned from the <code>useInput</code> hook.</p>&#13;
&#13;
<p>Hooks are designed to be used inside of React components. We can compose&#13;
hooks within other hooks because eventually the customized hook will be&#13;
used inside of a component. Changing the state within this hook still&#13;
causes the <code>AddColorForm</code> to <span class="keep-together">rerender</span> with new values for <code>titleProps</code>&#13;
or <code>colorProps</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding Colors to State" data-type="sect2"><div class="sect2" id="adding-colors-to-state">&#13;
<h2>Adding Colors to State</h2>&#13;
&#13;
<p>Both<a data-primary="forms" data-secondary="adding colors to state" data-type="indexterm" id="idm45901636591496"/><a data-primary="colors" data-secondary="adding to state" data-type="indexterm" id="idm45901636648568"/> the controlled form component and the uncontrolled from component&#13;
pass the values for <code>title</code> and <code>color</code> to the parent component via the&#13;
<code>onNewColor</code> function. The parent doesn’t care whether we used a&#13;
controlled component or an uncontrolled component; it only wants the values&#13;
for the new color.</p>&#13;
&#13;
<p>Let’s add the <code>AddColorForm</code>, whichever one you choose, to the the <code>App</code>&#13;
component. When the <code>onNewColor</code> property is invoked, we’ll save the&#13;
new color in state:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">colorData</code> <code class="nx">from</code> <code class="s2">"./color-data.json"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ColorList</code> <code class="nx">from</code> <code class="s2">"./ColorList.js"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">AddColorForm</code> <code class="nx">from</code> <code class="s2">"./AddColorForm"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">v4</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"uuid"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">colors</code><code class="p">,</code> <code class="nx">setColors</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">colorData</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">AddColorForm</code>&#13;
        <code class="nx">onNewColor</code><code class="o">=</code><code class="p">{(</code><code class="nx">title</code><code class="p">,</code> <code class="nx">color</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
          <code class="kr">const</code> <code class="nx">newColors</code> <code class="o">=</code> <code class="p">[</code>&#13;
            <code class="p">...</code><code class="nx">colors</code><code class="p">,</code>&#13;
            <code class="p">{</code>&#13;
              <code class="nx">id</code><code class="o">:</code> <code class="nx">v4</code><code class="p">(),</code>&#13;
              <code class="nx">rating</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
              <code class="nx">title</code><code class="p">,</code>&#13;
              <code class="nx">color</code>&#13;
            <code class="p">}</code>&#13;
          <code class="p">];</code>&#13;
          <code class="nx">setColors</code><code class="p">(</code><code class="nx">newColors</code><code class="p">);</code>&#13;
        <code class="p">}}</code>&#13;
      <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ColorList</code> <code class="p">...</code><code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When a new color is added, the <code>onNewColor</code> property is invoked. The&#13;
<code>title</code> and hexadecimal value for the new <code>color</code> are passed to this&#13;
function as arguments. We use these arguments to create a new array of&#13;
colors. First, we spread the current <code>colors</code> from state into the new&#13;
array. Then we add an entirely new color object using the <code>title</code> and&#13;
<code>color</code> values. Additionally, we set the <code>rating</code> of the new color to&#13;
<code>0</code> because it has not yet been rated. We also use the <code>v4</code> function&#13;
found in the <code>uuid</code> package to generate a new unique <code>id</code> for the color.&#13;
Once we have an array of colors that contains our new color, we save it&#13;
to state by invoking <code>setColors</code>. This causes the <code>App</code> component to&#13;
rerender with a new array of <code>colors</code>. That new array will be used to&#13;
update the UI. We’ll see the new color at bottom of the list.</p>&#13;
&#13;
<p>With this change, we’ve completed the first iteration of the Color&#13;
Organizer. Users can now add new colors to the list, remove colors from&#13;
the list, and rate any existing color on that list.<a data-primary="" data-startref="SMforms06" data-type="indexterm" id="idm45901636455560"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="React Context" data-type="sect1"><div class="sect1" id="react-context">&#13;
<h1>React Context</h1>&#13;
&#13;
<p>Storing<a data-primary="context" data-secondary="purpose of" data-type="indexterm" id="idm45901636452600"/><a data-primary="state management" data-secondary="React context" data-type="indexterm" id="SMcontext06"/> state in one location at the root of our tree was an important&#13;
pattern that helped us all be more successful with early versions of&#13;
React. Learning to pass state both down and up a component tree via&#13;
properties is a necessary right of passage for any React developer—it’s&#13;
something we should all know how to do. However, as React evolved&#13;
and our component trees got larger, following this principle slowly&#13;
became more unrealistic. It’s hard for many developers to maintain&#13;
state in a single location at the root of a component tree for a complex&#13;
application. Passing state down and up the tree through dozens of&#13;
components is tedious and bug ridden.</p>&#13;
&#13;
<p>The UI elements that most of us work on are complex. The root of the&#13;
tree is often very far from the leaves. This puts data the&#13;
application depends on many layers away from the components that use the&#13;
data. Every component must receive props that they only pass to their&#13;
children. This will bloat our code and make our UI harder to&#13;
scale.</p>&#13;
&#13;
<p>Passing state data through every component as props until it reaches the&#13;
component that needs to use it is like taking the train from San&#13;
Francisco to DC. On the train, you’ll pass through every state, but you&#13;
won’t get off until you reach your destination (see <a data-type="xref" href="#fig0606">Figure 6-6</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig0606">&#13;
<img alt="lrc2 0607" src="assets/lrc2_0607.png"/>&#13;
<h6><span class="label">Figure 6-6. </span>Train from San Francisco to DC</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s obviously more efficient to fly from San Francisco to DC. This&#13;
way, you don’t have to pass through every state—you simply fly over&#13;
them (<a data-type="xref" href="#fig0607">Figure 6-7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig0607">&#13;
<img alt="lrc2 0608" src="assets/lrc2_0608.png"/>&#13;
<h6><span class="label">Figure 6-7. </span>Flight from San Francisco to DC</h6>&#13;
</div></figure>&#13;
&#13;
<p>In React, <em>context</em> is like jet-setting for your data. You<a data-primary="context" data-secondary="context providers and consumers" data-type="indexterm" id="idm45901636441000"/> can place&#13;
data in React context by creating a <em>context provider</em>. A context&#13;
provider is a React component you can wrap around your entire&#13;
component tree or specific sections of your component tree. The context&#13;
provider is the departing airport where your data boards the plane. It’s&#13;
also the airline hub. All flights depart from that airport to different&#13;
destinations. Each destination is a <em>context consumer</em>. The context&#13;
consumer is the React component that retrieves the data from context.&#13;
This is the destination airport where your data lands, deplanes, and&#13;
goes to work.</p>&#13;
&#13;
<p>Using context still allows to us store state data in a single location, but&#13;
it doesn’t require us to pass that data through a bunch of components&#13;
that don’t need it.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Placing Colors in Context" data-type="sect2"><div class="sect2" id="placing-colors-in-context">&#13;
<h2>Placing Colors in Context</h2>&#13;
&#13;
<p>In<a data-primary="colors" data-secondary="placing in context" data-type="indexterm" id="idm45901636435560"/><a data-primary="context" data-secondary="createContext function" data-type="indexterm" id="idm45901636434552"/><a data-primary="createContext function" data-type="indexterm" id="idm45901636433608"/> order to use context in React, we must first place some data in a&#13;
context provider and add that provider to our component tree. React&#13;
comes with a function called <span class="keep-together"><code>createContext</code></span> that we can use to create a&#13;
new context object. This object contains two components: a context&#13;
<code>Provider</code> and a <code>Consumer</code>.</p>&#13;
&#13;
<p>Let’s place the default colors found in the <em>color-data.json</em> file into&#13;
context. We’ll add context to the <em>index.js</em> file, the entry point of&#13;
our application:</p>&#13;
&#13;
<pre data-type="programlisting">import React, { createContext } from "react";&#13;
import colors from "./color-data";&#13;
import { render } from "react-dom";&#13;
import App from "./App";&#13;
&#13;
export const ColorContext = createContext();&#13;
&#13;
render(&#13;
  &lt;ColorContext.Provider value={{ colors }}&gt;&#13;
    &lt;App /&gt;&#13;
  &lt;/ColorContext.Provider&gt;,&#13;
  document.getElementById("root")&#13;
);</pre>&#13;
&#13;
<p>Using <code>createContext</code>, we created a new instance of React context that we&#13;
named <code>ColorContext</code>. The color context contains two components:&#13;
<code>ColorContext.Provider</code> and <code>ColorContext.Consumer</code>. We need to use&#13;
the provider to place the colors in state. We add data to context by&#13;
setting the <code>value</code> property of the <code>Provider</code>. In this scenario, we&#13;
added an object containing the <code>colors</code> to context. Since we wrapped the&#13;
entire <code>App</code> component with the provider, the array of <code>colors</code> will made&#13;
available to any context consumers found in our entire component tree.&#13;
It’s important to notice that we’ve also exported the <code>ColorContext</code>&#13;
from this location. This is necessary because we will need to access the&#13;
<code>ColorContext.Consumer</code> when we want to obtain the <code>colors</code> from&#13;
context.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A context <code>Provider</code> doesn’t always have to wrap an entire application.&#13;
It’s not only OK to wrap specific sections components with a context&#13;
<code>Provider</code>, it can make your application more efficient. The <code>Provider</code>&#13;
will only provide context values to its children.</p>&#13;
&#13;
<p>It’s OK to use multiple context providers. In fact, you may be using&#13;
context providers in your React app already without even knowing&#13;
it. Many npm packages designed to work with React use context behind the&#13;
scenes.</p>&#13;
</div>&#13;
&#13;
<p>Now that we’re providing the <code>colors</code> value in context, the <code>App</code>&#13;
component no longer needs to hold state and pass it down to its&#13;
children as props. We’ve made the <code>App</code> component a “flyover”&#13;
component. The <code>Provider</code> is the <code>App</code> component’s parent, and it’s providing the&#13;
<code>colors</code> in context. The <code>ColorList</code> is the <code>App</code> component’s child, and it&#13;
can obtain the <code>colors</code> directly on its own. So the app doesn’t need to&#13;
touch the colors at all, which is great because the <code>App</code> component&#13;
itself has nothing to do with colors. That responsibility has been&#13;
delegated farther down the tree.</p>&#13;
&#13;
<p>We can remove a lot of lines of code from the <code>App</code> component. It only needs to&#13;
render the <code>AddColorForm</code> and the <code>ColorList</code>. It no longer has to worry&#13;
about the data:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ColorList</code> <code class="nx">from</code> <code class="s2">"./ColorList.js"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">AddColorForm</code> <code class="nx">from</code> <code class="s2">"./AddColorForm"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">AddColorForm</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ColorList</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Retrieving Colors with useContext" data-type="sect2"><div class="sect2" id="retrieving-colors-with-usecontext">&#13;
<h2>Retrieving Colors with useContext</h2>&#13;
&#13;
<p>The<a data-primary="colors" data-secondary="retrieving with useContext" data-type="indexterm" id="idm45901636384584"/><a data-primary="context" data-secondary="useContext hook" data-type="indexterm" id="idm45901636383640"/><a data-primary="useContext hook" data-type="indexterm" id="idm45901636382696"/><a data-primary="hooks" data-secondary="useContext hook" data-type="indexterm" id="idm45901636382024"/> addition of Hooks makes working with context a joy. The <code>useContext</code>&#13;
hook is used to obtain values from context, and it obtains those values&#13;
we need from the context <code>Consumer</code>. The <code>ColorList</code> component no longer&#13;
needs to obtain the array of <code>colors</code> from its properties. It can access&#13;
them directly via the <code>useContext</code> hook:</p>&#13;
&#13;
<pre data-type="programlisting">import React, { useContext } from "react";&#13;
import { ColorContext } from "./";&#13;
import Color from "./Color";&#13;
&#13;
export default function ColorList() {&#13;
  const { colors } = useContext(ColorContext);&#13;
  if (!colors.length) return &lt;div&gt;No Colors Listed. (Add a Color)&lt;/div&gt;;&#13;
  return (&#13;
    &lt;div className="color-list"&gt;&#13;
      {&#13;
        colors.map(color =&gt; &lt;Color key={color.id} {...color} /&gt;)&#13;
      }&#13;
    &lt;/div&gt;&#13;
  );&#13;
}</pre>&#13;
&#13;
<p>Here, we’ve modified the <code>ColorList</code> component and removed the <code>colors=[]</code>&#13;
property because the <code>colors</code> are being retrieved from context. The&#13;
<code>useContext</code> hook requires the context instance to obtain values from&#13;
it. The <code>ColorContext</code> instance is being imported from the <em>index.js</em>&#13;
file where we create the context and add the provider to our component&#13;
tree. The <code>ColorList</code> can now construct a user interface based on the&#13;
data that has been provided in context.</p>&#13;
<div data-type="note" epub:type="note"><h1>Using Context Consumer</h1>&#13;
<p>The <code>Consumer</code> is accessed within the <code>useContext</code> hook, which means&#13;
that we no longer have to work directly with the consumer component.&#13;
Before Hooks, we would have to obtain the colors from context using a&#13;
pattern called<a data-primary="render props pattern" data-type="indexterm" id="idm45901636342472"/> <em>render props</em> within the context consumer. Render props&#13;
are passed as arguments to a child function. The following example is&#13;
how you would use the consumer to obtain the colors from context:</p>&#13;
&#13;
<pre data-type="programlisting">export default function ColorList() {&#13;
  return (&#13;
    &lt;ColorContext.Consumer&gt;&#13;
      {context =&gt; {&#13;
      if (!context.colors.length)&#13;
      return &lt;div&gt;No Colors Listed. (Add a Color)&lt;/div&gt;;&#13;
        return (&#13;
          &lt;div className="color-list"&gt;&#13;
            {&#13;
              context.colors.map(color =&gt;&#13;
  &lt;Color key={color.id} {...color} /&gt;)&#13;
            }&#13;
          &lt;/div&gt;&#13;
        )&#13;
      }}&#13;
    &lt;/ColorContext.Consumer&gt;&#13;
  )&#13;
}</pre>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Stateful Context Providers" data-type="sect2"><div class="sect2" id="stateful-context-providers">&#13;
<h2>Stateful Context Providers</h2>&#13;
&#13;
<p>The<a data-primary="context" data-secondary="stateful context providers" data-type="indexterm" id="idm45901636337384"/> context provider can place an object into context, but it can’t&#13;
mutate the values in context on its own. It needs some help from a&#13;
parent component. The trick is to create a stateful component that&#13;
renders a context provider. When the state of the stateful component&#13;
changes, it will rerender the context provider with new context data.&#13;
Any of the context providers’ children will also be rerendered with the&#13;
new context data.</p>&#13;
&#13;
<p>The stateful component that renders the context provider is our <em>custom&#13;
provider</em>. That is: that’s the component that will be used when it’s time to&#13;
wrap our <code>App</code> with the provider. In a brand-new file, let’s create a&#13;
<code>ColorProvider</code>:</p>&#13;
&#13;
<pre data-type="programlisting">import React, { createContext, useState } from "react";&#13;
import colorData from "./color-data.json";&#13;
&#13;
const ColorContext = createContext();&#13;
&#13;
export default function ColorProvider ({ children }) {&#13;
  const [colors, setColors] = useState(colorData);&#13;
  return (&#13;
    &lt;ColorContext.Provider value={{ colors, setColors }}&gt;&#13;
      {children}&#13;
    &lt;/ColorContext.Provider&gt;&#13;
  );&#13;
};</pre>&#13;
&#13;
<p>The <code>ColorProvider</code> is a component that renders the&#13;
<code>ColorContext.Provider</code>. Within this component, we’ve created a state&#13;
variable for <code>colors</code> using the <code>useState</code> hook. The initial data for&#13;
<code>colors</code> is still being populated from <em>color-data.json</em>. Next, the&#13;
<code>ColorProvider</code> adds the <code>colors</code> from state to context using the&#13;
<code>value</code> property of the <code>ColorContext.Provider</code>. Any children rendered&#13;
within the <code>ColorProvider</code> will be wrapped by the&#13;
<code>ColorContext.Provider</code> and will have access to the <code>colors</code> array from&#13;
context.</p>&#13;
&#13;
<p>You may have noticed that the <code>setColors</code> function is also being added&#13;
to context. This gives context consumers the ability to change the value&#13;
for colors. Whenever <code>setColors</code> is invoked, the <code>colors</code> array will&#13;
change. This will cause the <code>ColorProvider</code> to rerender, and our UI&#13;
will update itself to display the new <code>colors</code> array.</p>&#13;
&#13;
<p>Adding <code>setColors</code> to context may not be the best idea. It invites&#13;
other developers and you to make mistakes later on down the road&#13;
when using it. There are only three options when it comes to changing&#13;
the value of the <code>colors</code> array: users can add colors, remove colors, or&#13;
rate colors. It’s a better idea to add functions for each of these&#13;
operations to context. This way, you don’t expose the <code>setColors</code>&#13;
function to consumers; you only expose functions for the changes&#13;
they’re allowed to make:</p>&#13;
&#13;
<pre data-type="programlisting">export default function ColorProvider ({ children }) {&#13;
  const [colors, setColors] = useState(colorData);&#13;
&#13;
  const addColor = (title, color) =&gt;&#13;
    setColors([&#13;
      ...colors,&#13;
      {&#13;
        id: v4(),&#13;
        rating: 0,&#13;
        title,&#13;
        color&#13;
      }&#13;
    ]);&#13;
&#13;
  const rateColor = (id, rating) =&gt;&#13;
    setColors(&#13;
      colors.map(color =&gt; (color.id === id ? { ...color, rating } : color))&#13;
    );&#13;
&#13;
  const removeColor = id =&gt; setColors(colors.filter(color =&gt; color.id !== id));&#13;
&#13;
  return (&#13;
    &lt;ColorContext.Provider value={{ colors, addColor, removeColor, rateColor }}&gt;&#13;
      {children}&#13;
    &lt;/ColorContext.Provider&gt;&#13;
  );&#13;
};</pre>&#13;
&#13;
<p>That looks better. We added functions to context for all of the&#13;
operations that can be made on the colors array. Now, any component&#13;
within our tree can consume these operations and make changes to colors&#13;
using simple functions that we can document.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom Hooks with Context" data-type="sect2"><div class="sect2" id="custom-hooks-with-context">&#13;
<h2>Custom Hooks with Context</h2>&#13;
&#13;
<p>There’s<a data-primary="hooks" data-secondary="custom with context" data-type="indexterm" id="idm45901636317768"/><a data-primary="context" data-secondary="custom hooks with" data-type="indexterm" id="idm45901636278376"/> one more killer change we can make. The introduction of&#13;
Hooks has made it so that we don’t have to expose context to consumer&#13;
components at all. Let’s face it: context can be confusing for team&#13;
members who aren’t reading this book. We can make everything much easier&#13;
for them by wrapping context in a custom hook. Instead of exposing the&#13;
<code>ColorContext</code> instance, we can create a hook called <code>useColors</code> that&#13;
returns the colors from context:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">createContext</code><code class="p">,</code> <code class="nx">useState</code><code class="p">,</code> <code class="nx">useContext</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">colorData</code> <code class="nx">from</code> <code class="s2">"./color-data.json"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">v4</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"uuid"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">ColorContext</code> <code class="o">=</code> <code class="nx">createContext</code><code class="p">();</code>&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">useColors</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">useContext</code><code class="p">(</code><code class="nx">ColorContext</code><code class="p">);</code></pre>&#13;
&#13;
<p>This one simple change has a huge impact on architecture. We’ve&#13;
wrapped all of the functionality necessary to render and work with&#13;
stateful colors in a single JavaScript module. Context is contained to&#13;
this module yet exposed through a hook. This works because we return&#13;
context using the <code>useContext</code> hook, which has access to the&#13;
<code>ColorContext</code> locally in this file. It’s now appropriate to rename&#13;
this module <code>color-hooks.js</code> and distribute this functionality for wider&#13;
use by the community.</p>&#13;
&#13;
<p>Consuming colors using the <code>ColorProvider</code> and the <code>useColors</code> hook is a&#13;
joyous event. This is why we program. Let’s take this hook out for a&#13;
spin in the current Color Organizer app. First, we need to wrap our&#13;
<code>App</code> component with the custom <code>ColorProvider</code>. We can do this in the&#13;
<em>index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ColorProvider</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./color-hooks.js"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">render</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react-dom"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">App</code> <code class="nx">from</code> <code class="s2">"./App"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">ColorProvider</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">App</code> <code class="o">/&gt;</code>&#13;
  <code class="o">&lt;</code><code class="err">/ColorProvider&gt;,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Now, any component that’s a child of the <code>App</code> can obtain the <code>colors</code>&#13;
from the <span class="keep-together"><code>useColors</code></span> hook. The <code>ColorList</code> component needs to access&#13;
the <code>colors</code> array to render the colors on the screen:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">Color</code> <code class="nx">from</code> <code class="s2">"./Color"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useColors</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./color-hooks"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">ColorList</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">colors</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useColors</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="p">(</code> <code class="p">...</code> <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ve removed any references to context from this component.&#13;
Everything it needs is now being provided from our hook. The <code>Color</code>&#13;
component could use our hook to obtain the functions for rating and&#13;
removing colors directly:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">StarRating</code> <code class="nx">from</code> <code class="s2">"./StarRating"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useColors</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./color-hooks"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Color</code><code class="p">({</code> <code class="nx">id</code><code class="p">,</code> <code class="nx">title</code><code class="p">,</code> <code class="nx">color</code><code class="p">,</code> <code class="nx">rating</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">rateColor</code><code class="p">,</code> <code class="nx">removeColor</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useColors</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">section</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">title</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">removeColor</code><code class="p">(</code><code class="nx">id</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">X</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">height</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="nx">backgroundColor</code><code class="o">:</code> <code class="nx">color</code> <code class="p">}}</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">StarRating</code>&#13;
        <code class="nx">selectedStars</code><code class="o">=</code><code class="p">{</code><code class="nx">rating</code><code class="p">}</code>&#13;
        <code class="nx">onRate</code><code class="o">=</code><code class="p">{</code><code class="nx">rating</code> <code class="o">=&gt;</code> <code class="nx">rateColor</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">rating</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/section&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, the <code>Color</code> component no longer needs to pass events to the parent&#13;
via function props. It has access to the <code>rateColor</code> and <code>removeColor</code>&#13;
functions in context. They’re easily obtained through the <code>useColors</code>&#13;
hook. This is a lot of fun, but we’re not finished yet. The&#13;
<code>AddColorForm</code> can also benefit from the <code>useColors</code> hook:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useInput</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./hooks"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useColors</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./color-hooks"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">AddColorForm</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">titleProps</code><code class="p">,</code> <code class="nx">resetTitle</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useInput</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">colorProps</code><code class="p">,</code> <code class="nx">resetColor</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useInput</code><code class="p">(</code><code class="s2">"#000000"</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">addColor</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useColors</code><code class="p">();</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">submit</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">e</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code>&#13;
    <code class="nx">addColor</code><code class="p">(</code><code class="nx">titleProps</code><code class="p">.</code><code class="nx">value</code><code class="p">,</code> <code class="nx">colorProps</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>&#13;
    <code class="nx">resetTitle</code><code class="p">();</code>&#13;
    <code class="nx">resetColor</code><code class="p">();</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code> <code class="p">...</code> <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>AddColorForm</code> component can add colors directly with the <code>addColor</code>&#13;
function. When colors are added, rated, or removed, the state of the&#13;
<code>colors</code> value in context will change. When this change happens, the&#13;
children of the <code>ColorProvider</code> are <span class="keep-together">rerendered</span> with new context data.&#13;
All of this is happening through a simple hook.<a data-primary="" data-startref="SMcontext06" data-type="indexterm" id="idm45901635804392"/></p>&#13;
&#13;
<p>Hooks<a data-primary="hooks" data-secondary="benefits of" data-type="indexterm" id="idm45901635803160"/> provide software developers with the stimulation they need to&#13;
stay motivated and enjoy frontend programming. This is primarily&#13;
because they’re an awesome tool for separating concerns. Now, React&#13;
components only need to concern themselves with rendering other React&#13;
components and keeping the user interface up to date. React Hooks can&#13;
concern themselves with the logic required to make the app work.&#13;
Both the UI and Hooks can be developed separately, tested separately, and even&#13;
deployed separately. This is all very good news for React.</p>&#13;
&#13;
<p>We’ve only scratched the surface of what can be accomplished with&#13;
Hooks. In the next chapter, we’ll dive a little deeper.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>