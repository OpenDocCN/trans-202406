# 第二章：开发工作流程

Kubernetes 的设计初衷是可靠地运行软件。它通过面向应用的 API、自愈特性以及诸如部署（Deployments）之类的有用工具简化了应用程序的部署和管理，实现了零停机滚动升级。虽然所有这些工具都很有用，但它们并没有多少帮助来简化为 Kubernetes 开发应用程序的过程。这就是开发工作流程发挥作用的地方。尽管许多集群设计用于运行生产应用程序，因此很少被开发人员工作流程访问，但关键是要支持开发工作流程以面向 Kubernetes，通常这意味着需要一个或部分用于开发的集群。建立这样一个集群来便捷地开发 Kubernetes 应用程序对确保 Kubernetes 成功非常关键。如果你的集群中没有代码正在构建，那么集群本身并不能完成多少工作。

# 目标

在我们描述如何构建开发集群的最佳实践之前，值得说明我们对这些集群的目标。显然，最终目标是使开发人员能够在 Kubernetes 上快速轻松地构建应用程序，但在实践中，这究竟意味着什么，又如何在开发集群的实际特性中体现出来呢？

要回答这个问题，让我们首先识别开发人员与集群交互的各个阶段。

第一阶段是*入职*。这是新开发人员加入团队的时候。这一阶段包括为用户提供集群登录权限，并让他们了解他们的第一个部署。这一阶段的目标是在最短的时间内让开发人员尝试水。你应该为这个过程设定一个关键绩效指标（KPI）目标。一个合理的目标是，用户可以在半小时内从零到当前应用程序的 HEAD 运行。每当有新成员加入团队时，都要测试你们对这个目标的执行情况。

第二阶段是*开发*。这是开发人员的日常活动。这一阶段的目标是确保快速迭代和调试。开发人员需要能够快速重复地将代码推送到集群，并且需要能够轻松地测试和调试代码，以确保其正常运行。这一阶段的关键绩效指标较难测量，但可以通过测量将拉取请求（PR）或更改在集群中运行的时间，或者通过用户感知生产力的调查来估算。你还可以通过团队的整体生产力来衡量这一指标。

第三阶段是*测试*。这个阶段与开发交织在一起，用于在提交和合并之前验证代码的有效性。这个阶段的目标有两个。首先，开发者应该能够在提交 PR 之前在他们的环境中运行所有的测试。其次，所有的测试应该在代码合并到仓库之前自动运行。除了这些目标之外，你还应该为测试运行时间设置一个关键绩效指标（KPI）。随着项目变得越来越复杂，测试需要的时间自然会变长。在这种情况下，识别一组更小的烟雾测试，供开发者在提交 PR 前进行初步验证，可能会很有价值。你还应该在*测试的不稳定性*周围设定非常严格的 KPI。不稳定的测试偶尔会失败。在任何相对活跃的项目中，每千次运行超过一个失败的不稳定性率都会导致开发者之间的摩擦。你需要确保你的集群环境不会产生不稳定的测试。有时不稳定的测试是由于代码问题引起的，但也可能是由于开发环境中的干扰（例如资源耗尽和嘈杂的邻居）引起的。你应该通过测量测试的不稳定性并迅速采取措施来修复，确保你的开发环境没有这些问题。

# 构建开发集群

当人们开始考虑在 Kubernetes 上进行开发时，首先要做出的选择之一是是构建一个单一的大型开发集群，还是每个开发者一个集群。请注意，这个选择只在动态创建集群容易的环境中才有意义，比如公共云。在物理环境中，可能只有一个大型集群是唯一的选择。

如果你有选择的余地，你应该考虑每个选项的利弊。如果你选择每个用户一个开发集群，这种方法的重大缺点是成本更高、效率更低，而且你将需要管理大量不同的开发集群。额外的成本来自于每个集群可能严重闲置的事实。此外，由于开发者创建了不同的集群，跟踪和回收不再使用的资源变得更加困难。集群每用户的方法的优势在于简单性：每个开发者可以自主管理他们自己的集群，并且由于隔离性，不同开发者之间更难互相干扰。

另一方面，单个开发集群的效率显著提高；你可能能够以三分之一的价格（甚至更少）维持相同数量的开发人员在共享集群上工作。此外，你可以更轻松地安装共享集群服务，例如监控和日志记录，这显著提高了开发人员友好型集群的生产效率。共享开发集群的不利之处在于用户管理的过程以及开发人员之间的潜在干扰。因为目前添加新用户和命名空间到 Kubernetes 集群的流程并不是特别流畅，你需要启动一个新的开发者入职流程。尽管 Kubernetes 资源管理和基于角色的访问控制（RBAC）可以减少两位开发者发生冲突的可能性，但仍然存在用户可能因为消耗过多资源而使开发集群“砖化”，导致其他应用程序和开发者无法调度的情况。此外，你仍需确保开发者不会泄漏和忘记他们创建的资源。然而，这比每位开发者各自创建自己的集群的方法要容易一些。

尽管两种方法都可行，但一般我们建议为所有开发者使用单个大集群。尽管开发者之间的干扰存在挑战，但可以通过管理来解决，而最终的成本效益和轻松为集群添加组织范围的功能，大大超过了干扰的风险。但你需要投资于开发者入职流程、资源管理和垃圾收集的流程。我们建议首先尝试单个大集群作为首选。随着组织的增长（或者如果已经很大），你可能会考虑为每个团队或小组（10 至 20 人）设置一个集群，而不是为数百名用户设置一个巨大的集群。这样可以更容易地进行计费和管理。转向多个集群可能会使保持一致性变得更加复杂，但类似于舰队管理的工具可以更轻松地管理多个集群组。

# 为多个开发者设置共享集群

在设置大集群时，主要目标是确保多个用户可以同时使用集群而不会相互干扰。区分不同开发者的明显方法是使用 Kubernetes 命名空间。命名空间可以作为服务部署的作用域，以便一个用户的前端服务不会干扰另一个用户的前端服务。命名空间还是 RBAC 的作用域，确保一个开发者不会意外删除另一个开发者的工作。因此，在共享集群中使用命名空间作为开发者的工作空间是有意义的。关于用户入职流程、创建和保护命名空间的具体流程将在以下章节中详细描述。

## 用户入职流程

在将用户分配到命名空间之前，您必须将该用户加入到 Kubernetes 集群本身。为了实现这一点，有两种选择。您可以使用基于证书的认证来为用户创建一个新的证书，并提供给他们一个*kubeconfig*文件，以便他们登录；或者您可以配置您的集群以使用外部身份系统（例如，Microsoft Entra ID 或 AWS 身份和访问管理 [IAM]）来访问集群。

通常来说，使用外部身份系统是一种最佳实践，因为它不需要您维护两个不同的身份来源。此外，大多数外部系统使用短暂的令牌而不是长期的证书，因此意外泄露令牌会产生有时间限制的安全影响。如果可能的话，您应该限制开发人员通过外部身份提供者证明他们的身份。

不幸的是，在某些情况下这是不可能的，您需要使用证书。幸运的是，您可以使用 Kubernetes 证书 API 来创建和管理这些证书。以下是向现有集群添加新用户的流程。

首先，您需要生成一个证书签名请求来生成一个新的证书。以下是一个简单的 Go 程序来执行此操作：

```
package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"encoding/pem"
	"os"
)

func main() {
	name := os.Args[1]
	user := os.Args[2]

	key, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		panic(err)
	}
	keyDer := x509.MarshalPKCS1PrivateKey(key)
	keyBlock := pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: keyDer,
	}
	keyFile, err := os.Create(name + "-key.pem")
	if err != nil {
		panic(err)
	}
	pem.Encode(keyFile, &keyBlock)
	keyFile.Close()

	commonName := user
	// You may want to update these too
	emailAddress := "someone@myco.com"

	org := "My Co, Inc."
	orgUnit := "Widget Farmers"
	city := "Seattle"
	state := "WA"
	country := "US"

	subject := pkix.Name{
		CommonName:         commonName,
		Country:            []string{country},
		Locality:           []string{city},
		Organization:       []string{org},
		OrganizationalUnit: []string{orgUnit},
		Province:           []string{state},
	}

	asn1, err := asn1.Marshal(subject.ToRDNSequence())
	if err != nil {
		panic(err)
	}
	csr := x509.CertificateRequest{
		RawSubject:         asn1,
		EmailAddresses:     []string{emailAddress},
		SignatureAlgorithm: x509.SHA256WithRSA,
	}

	bytes, err := x509.CreateCertificateRequest(rand.Reader, &csr, key)
	if err != nil {
		panic(err)
	}
	csrFile, err := os.Create(name + ".csr")
	if err != nil {
		panic(err)
	}

	pem.Encode(csrFile, &pem.Block{Type: "CERTIFICATE REQUEST", Bytes:
      bytes})
	csrFile.Close()
}
```

您可以按以下步骤运行此操作：

```
go run csr-gen.go client <user-name>;
```

这会创建名为*client-key.pem*和*client.csr*的文件。然后，您可以运行以下脚本来创建和下载一个新的证书：

```
#!/bin/bash

csr_name="my-client-csr"
name="${1:-my-user}"

csr="${2}"

cat <<EOF | kubectl create -f -
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
 name: ${csr_name}
spec:
 groups:
 - system:authenticated
 request: $(cat ${csr} | base64 | tr -d '\n')
 usages:
 - key encipherment
 - client auth
EOF

echo
echo "Approving signing request."
kubectl certificate approve ${csr_name}

echo
echo "Downloading certificate."
kubectl get csr ${csr_name} -o jsonpath='{.status.certificate}' \
	| base64 --decode > $(basename ${csr} .csr).crt

echo
echo "Cleaning up"
kubectl delete csr ${csr_name}

echo
echo "Add the following to the 'users' list in your kubeconfig file:"
echo "- name: ${name}"
echo "  user:"
echo "    client-certificate: ${PWD}/$(basename ${csr} .csr).crt"
echo "    client-key: ${PWD}/$(basename ${csr} .csr)-key.pem"
echo
echo "Next you may want to add a role-binding for this user."
```

此脚本将打印出最终信息，您可以将其添加到*kubeconfig*文件中以启用该用户。当然，该用户没有访问权限，因此您需要为用户应用 Kubernetes RBAC 来授予他们访问命名空间的权限。

## 创建和保护命名空间

创建命名空间的第一步实际上只是创建它。您可以使用**`kubectl create namespace my-namespace`**来完成这个操作。

但事实上，当您创建命名空间时，您希望将一堆元数据附加到该命名空间，例如部署到命名空间的组件的团队联系信息。一般来说，这是以注释的形式存在的；您可以使用某些模板生成 YAML 文件，例如[Jinja](https://oreil.ly/vvtTF)或其他工具，或者您可以创建然后注释命名空间。执行此操作的简单脚本如下所示：

```
ns='my-namespace'
team='some team'
kubectl create namespace ${ns}
kubectl annotate namespace ${ns} team=${team}
```

当命名空间被创建时，您希望通过确保您可以将对命名空间的访问权限授予特定用户来保护它。为了做到这一点，您可以在该命名空间的上下文中将角色绑定到用户。您可以通过在命名空间本身内创建一个`RoleBinding`对象来完成这个操作。`RoleBinding`可能看起来像这样：

```
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: example
  namespace: my-namespace
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: edit
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: myuser
```

要创建它，只需运行 `kubectl create -f role-binding.yaml`。请注意，只要更新绑定中的命名空间指向正确的命名空间，就可以重复使用此绑定。如果确保用户没有其他角色绑定，可以确保此命名空间是用户可以访问的集群的唯一部分。一个合理的做法是还给整个集群授予读取权限；这样开发者就可以看到其他人正在做的事情，以防干扰他们的工作。但是，在授予此类读取访问权限时要小心，因为它将包括对集群中秘密资源的访问。通常在开发集群中这是可以接受的，因为每个人都在同一个组织中，并且秘密资源仅用于开发；然而，如果这是一个问题，那么可以创建一个更精细的角色，消除读取秘密的能力。

如果你想限制特定命名空间消耗的资源，以控制成本或确保资源在开发者间公平分配，可以使用 ResourceQuota 资源为命名空间设置资源总量限制。例如，以下配额限制命名空间内的 pods 的请求和限制为 10 个核心和 100 GB 内存：

```
apiVersion: v1
kind: ResourceQuota
metadata:
  name: limit-compute
  namespace: my-namespace
spec:
  hard:
    # These look a little odd because they're not nested
	# but they refer to the requests and limit fields in
	# a Pod
    requests.cpu: "10"
    requests.memory: 100Gi
    limits.cpu: 10
    limits.memory: 100Gi
```

## 管理命名空间

现在你已经了解了如何为新用户注册并创建用作工作空间的命名空间，接下来的问题是如何分配开发者到命名空间。和许多事情一样，并没有单一完美的答案；而是有两种方法。第一种是在注册流程中为每个用户提供其自己的命名空间。这很有用，因为一旦用户注册成功，他们就有了一个专门的工作空间，在这里可以开发和管理他们的应用程序。然而，将开发者的命名空间设置得太持久会鼓励开发者在完成后将东西留在命名空间中，清理和计费各个资源也会变得更加复杂。另一种方法是临时创建和分配有限生存期（TTL）的命名空间。这确保开发者将集群中的资源视为短暂的，并且可以轻松地围绕命名空间的整体删除构建自动化流程，当 TTL 到期时删除整个命名空间。

在有界 TTL 模型中，当开发者想要开始一个新项目时，他们会使用一个工具为项目分配一个新的命名空间。当他们创建命名空间时，它有一些与命名空间相关联的元数据，用于管理和记账。显然，这些元数据包括命名空间的 TTL，但也包括分配给它的开发者、应该分配给命名空间的资源（如 CPU 和内存）、团队及命名空间的用途。这些元数据确保你可以追踪资源使用情况，并在适当的时候删除命名空间。

开发按需分配命名空间的工具可能看起来是一个挑战，但是开发简单的工具相对来说是比较容易的。例如，你可以通过一个简单的脚本来实现分配新命名空间，并提示输入相关的元数据以附加到命名空间。

如果你想更深入地与 Kubernetes 集成，你可以使用自定义资源定义（CRDs）来使用户能够动态地使用 `kubectl` 工具创建和分配新的命名空间。如果你有时间和意愿，这绝对是一个好的实践，因为它使命名空间管理成为声明式的，还能够启用 Kubernetes RBAC。

当你有工具来启用命名空间的分配时，你还需要添加工具来在其 TTL 到期时收回命名空间。你可以通过一个简单的脚本来实现这一点，该脚本检查命名空间并删除那些 TTL 已过期的命名空间。

你可以将这个脚本构建成一个容器，并使用 `ScheduledJob` 每小时运行一次。这些组合工具可以确保开发者可以根据需要轻松分配独立资源来进行项目开发，但是这些资源也会在适当的时间间隔内被收回，以确保你不会浪费资源，并且旧资源不会妨碍新的开发。

## 集群级服务

除了使用工具来分配和管理命名空间之外，还有一些有用的集群级服务，在你的开发集群中启用它们是一个好主意。首先是将日志聚合到一个中央日志服务（LaaS）系统。对于开发者来说，理解他们应用的运行情况最简单的方式之一是将一些内容写入标准输出。虽然你可以通过 `kubectl logs` 访问这些日志，但该日志长度有限且不易搜索。如果你将这些日志自动发送到 LaaS 系统，如云服务或 Elasticsearch 集群，开发者可以轻松搜索相关信息，并在他们的服务中跨多个容器聚合日志信息。

# 启用开发者工作流

现在我们已成功设置了共享集群，并可以将新应用程序开发者加入到集群本身，我们需要确实让他们开始开发他们的应用程序。请记住，我们正在衡量的 KPI 之一是从加入到集群到在集群中运行初始应用程序的时间。很明显，通过刚刚描述的加入脚本，我们可以快速为用户在集群中进行身份验证并分配命名空间，但如何开始应用程序呢？不幸的是，尽管有一些技术可以帮助这个过程，但通常需要更多的约定而不是自动化来使初始应用程序运行起来。在以下各节中，我们描述了一种实现这一目标的方法；这绝不是唯一的方法或唯一的解决方案。您可以选择按原样应用此方法，或者受到这些想法的启发以制定您自己的解决方案。

## 初始设置

部署应用程序的主要挑战之一是安装所有依赖项。在许多情况下，特别是在现代微服务架构中，要想在其中一个微服务上开始开发，通常需要部署多个依赖项，无论是数据库还是其他微服务。虽然应用程序本身的部署相对简单，但识别和部署所有依赖项以构建完整应用程序的任务常常是试错和不完整或过时说明的结合，这是一个令人沮丧的过程。

要解决这个问题，通常有必要引入一种约定来描述和安装依赖项。这可以被视为类似于`npm install`的等效物，后者安装所有所需的 JavaScript 依赖项。最终，可能会有类似于`npm`的工具，为基于 Kubernetes 的应用程序提供此服务，但在那之前，依赖于团队内部的约定是最佳实践。

一种约定的选项是在所有项目仓库的根目录中创建一个*setup.sh*脚本。此脚本的责任是在特定命名空间内创建所有依赖项，以确保正确创建所有应用程序的依赖项。例如，设置脚本可能如下所示：

```
kubectl create my-service/database-stateful-set-yaml
kubectl create my-service/middle-tier.yaml
kubectl create my-service/configs.yaml
```

您可以通过将以下内容添加到您的*package.json*来将此脚本集成到 npm 中：

```
{
    ...
    "scripts": {
        "setup": "./setup.sh",
        ...
    }
}
```

使用这个设置，新开发者只需运行`npm run setup`，就可以安装集群依赖项。显然，这种特定的集成是针对 Node.js/npm 的。在其他编程语言中，最好使用特定于语言的工具集成。例如，在 Java 中，可能会与*Maven 的 pom.xml*文件集成。

对于更通用的工作流程，GitHub 和 Visual Studio Code 最近都已经标准化了“devcontainers”，这些容器由存储在仓库的 `.devcontainer/` 文件夹中的 Dockerfile 描述。构建时，它们会为该仓库的开发提供一个完整的环境。

## 启用活跃开发

在设置了开发者工作空间及所需依赖项后，下一步是让开发者能够快速迭代他们的应用程序。这其中的第一个前提是能够构建并推送一个容器镜像。假设您已经设置了这一点；如果没有，您可以在其他在线资源和书籍中了解如何操作。

在构建并推送容器镜像之后，任务是将其部署到集群中。与传统的部署不同，在开发者迭代的情况下，维护可用性实际上并不是一个问题。因此，部署新代码的最简单方式是简单地删除与前一次部署相关联的 Deployment 对象，然后创建一个指向新构建镜像的新 Deployment。也可以直接更新现有的 Deployment，但这会触发 Deployment 资源中的部署逻辑。虽然可以配置 Deployment 快速部署代码，但这样做会引入开发环境和生产环境之间的差异，可能会带来危险或不稳定性。例如，假设您意外地将部署的开发配置推送到生产环境中，则会突然在生产环境中部署新版本，而没有适当的测试和部署阶段之间的延迟。由于存在这种风险，并且有替代方案，最佳实践是删除并重新创建 Deployment。

就像安装依赖项一样，为执行此部署编写脚本也是一个好习惯。例如，*deploy.sh* 脚本可能如下所示：

```
kubectl delete -f ./my-service/deployment.yaml
perl -pi -e 's/${old_version}/${new_version}/' ./my-service/deployment.yaml
kubectl create -f ./my-service/deployment.yaml
```

与之前一样，您可以将其集成到现有的编程语言工具中，以便（例如）开发者只需运行 `npm run deploy` 就可以将他们的新代码部署到集群中。

在构建此自动化过程时，通常有必要将其集成到持续集成和交付（CI/CD）工具中，例如 GitHub Actions、Azure DevOps 或 Jenkins。与 CI/CD 工具的集成可以更轻松地实现进一步的自动化，例如在合并开发者的 PR 后自动部署。

## 启用测试和调试

用户成功部署其应用的开发版本后，需要对其进行测试，并在有问题时调试应用程序。在 Kubernetes 中进行开发时，这也可能是一个障碍，因为并不总是清楚如何与集群交互。`kubectl`命令行是一个多功能工具箱，可以通过其中的工具（例如`kubectl logs`、`kubectl exec`和`kubectl port-forward`）来实现这一点，但学习如何使用所有不同的选项并熟悉工具可能需要相当多的经验。此外，由于该工具在终端中运行，通常需要组合多个窗口同时检查应用程序的源代码和运行的应用程序本身。

为了简化测试和调试体验，Kubernetes 工具正在越来越多地集成到开发环境中，例如 Visual Studio（VS）Code 用于 Kubernetes 的开源扩展。该扩展可以免费从 VS Code 市场轻松安装。安装后，它会自动发现您在*kubeconfig*文件中已有的任何集群，并提供一个树形视图导航窗格，让您可以一目了然地查看集群内容。

除了能够一目了然地查看集群状态之外，集成还允许开发者以直观、可发现的方式使用通过`kubectl`可用的工具。从树形视图中，如果右键单击 Kubernetes pod，您可以立即使用端口转发将网络连接从 pod 直接引导到本地计算机。同样，您还可以访问 pod 的日志，甚至在运行中的容器内获取终端。

这些命令与典型的用户界面期望（例如，右键显示上下文菜单）的集成，以及这些体验与应用程序代码本身的集成，使具有最少 Kubernetes 经验的开发者能够迅速在开发集群中提高生产力。

当然，这个 VS Code 扩展并不是 Kubernetes 和开发环境之间唯一的集成方式；根据您的编程环境和风格（如`vi`、`emacs`等），还有其他几种可以安装的集成方式。

# 建立开发环境最佳实践

在 Kubernetes 上设置开发工作流程对于生产力至关重要，对于积极、快乐的开发团队也是至关重要。遵循这些最佳实践将有助于确保开发者能够快速上手：

+   考虑开发者体验的三个阶段：入职、开发和测试。确保您构建的开发环境支持这三个阶段。

+   在构建开发集群时，您可以选择一个大型集群或每个开发者一个集群。每种方式都有其利弊，但通常来说，一个单一的大型集群是一个更好的选择。

+   当您向集群添加用户时，请使用他们自己的身份和对他们自己命名空间的访问权限。使用资源限制来限制他们可以使用集群的量。

+   当管理命名空间时，请考虑如何收割旧的、未使用的资源。开发者常常不注意删除未使用的东西。可以利用自动化来清理这些资源。

+   考虑设置所有用户都可以使用的集群级服务，如日志和监控。有时候，像数据库这样的集群级依赖项也可以通过类似 Helm 图表的模板来为所有用户设置。

# 概要

我们已经到了一个阶段，在这个阶段中，在云环境中创建 Kubernetes 集群已经是一个相对简单的练习，但是使开发者能够有效地使用这样的集群却明显不那么明显和简单。在考虑如何使开发者成功地在 Kubernetes 上构建应用程序时，重要的是考虑关于入门、迭代、测试和调试应用程序的关键目标。同样，值得投资于一些专门用于用户入门、命名空间供应以及基本日志聚合等集群服务的基本工具。将开发集群和代码库视为标准化和应用最佳实践的机会，将确保您拥有快乐和高效的开发者成功地构建代码并部署到生产 Kubernetes 集群中。
