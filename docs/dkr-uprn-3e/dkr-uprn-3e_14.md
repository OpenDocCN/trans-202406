# 第十三章 容器平台设计

在将任何技术投入生产时，通过设计一个能够抵御不可避免出现的意外问题的弹性平台，您通常可以最大化技术的应用价值。Docker 可以是一个强大的工具，但需要对整个平台的细节进行关注。作为一个正在经历快速增长的技术，它很可能在构成您的容器平台的各个组件之间产生令人沮丧的错误。

如果您不仅仅是将 Docker 部署到现有环境中，而是花时间构建一个以 Docker 作为核心组件之一的精心设计的容器平台，您可以享受基于容器的工作流程的诸多好处，同时保护自己免受在这种高速项目中可能存在的某些尖锐边缘的影响。

像所有其他技术一样，Docker 并不能神奇地解决所有问题。要实现其真正的潜力，组织必须对何时以及如何使用它做出非常慎重的决策。对于小项目来说，可以简单地使用 Docker；然而，如果您计划支持一个能够按需扩展的大型项目，那么设计应用程序和平台非常关键。这确保您可以最大化对技术投资的回报。花时间有意识地设计您的平台，还将使您能够随着时间的推移轻松修改生产工作流程。一个精心设计的容器平台和部署流程将尽可能地简单明了，同时仍支持满足所有技术和合规要求的必要功能。经过深思熟虑的设计将有助于确保您的软件运行在一个能够轻松升级的动态基础上，以适应技术和公司流程的发展。

在这一章中，我们将探讨两个开放文档，[“十二要素应用”](https://12factor.net) 和 [“反应式宣言”](https://www.reactivemanifesto.org)（作为 [“反应式原则”](https://www.reactiveprinciples.org) 的附属文档），并讨论它们与 Docker 及构建健壮容器平台的关系。这两个文档包含了许多思想，应该帮助您设计和实施容器平台，并确保更多的弹性和可支持性。

# 十二要素应用

在 Docker 发布之前的 2011 年 11 月，Heroku 的联合创始人亚当·威金斯及其同事发布了一篇名为 [“十二要素应用”](https://12factor.net) 的文章。该文档从 [Heroku](https://www.heroku.com) 工程师的经验中提炼出了一系列 12 个实践，用于设计能够在现代基于容器的 SaaS 环境中蓬勃发展的应用程序。

虽然不是必需的，但是以这 12 个步骤为基础构建的应用程序是 Docker 工作流的理想候选者。在本章中，我们将探讨以下每个步骤，并解释为什么这些做法可以在多方面帮助改进您的开发周期：

+   代码库

+   依赖关系

+   配置

+   后备服务

+   构建、发布、运行

+   进程

+   端口绑定

+   并发性

+   可处置

+   开发/生产一致性

+   日志

+   管理流程

## 代码库

*一个代码库由版本控制跟踪。*

在任何给定时间可能会有多个应用程序实例在运行，但它们都应该来自同一个代码仓库。给定应用程序的每个 Docker 镜像都应该由一个单一的源代码仓库构建，该仓库包含构建 Linux 容器所需的所有代码。这确保了代码可以轻松重建，并且所有第三方要求在仓库中都有明确定义，并且在构建过程中将自动拉取。

这意味着构建应用程序不应该需要从多个源代码库中拼凑代码。这并不意味着你不能依赖来自另一个仓库的构件。但是这意味着应该有一个清晰的机制来确定在构建应用程序时哪些代码片段已经被包含进去了。如果构建应用程序需要拉取多个源代码库并将这些片段拼凑在一起，那么 Docker 简化依赖管理的能力就显得不太有用。如果你必须知道一个魔法咒语才能让构建正确工作，那么它也不太可重复。

一个很好的测试可能是给你公司的新开发者一台干净的笔记本电脑和一段说明文字，然后看看他们是否能在一个小时内成功构建你的应用程序。如果不能，那么这个流程可能需要进一步优化和简化。

## 依赖关系

*明确声明和隔离依赖项*。

永远不要依赖于某种依赖项将通过其他途径（如操作系统安装）提供。你的应用程序需要的任何依赖项应该在代码库中被明确定义，并且由构建过程拉取。这将有助于确保你的应用程序在部署时能够运行，而不依赖于其他人或过程安装的库。这在容器内尤为重要，因为容器的进程与主机操作系统的其余部分隔离，并且通常无法访问主机的内核和容器镜像的文件系统之外的任何内容。

*Dockerfile* 和类似 Node 的 *package.json* 或 Ruby 的 *Gemfile* 这样的语言相关配置文件应定义应用程序所需的每一个非外部依赖项。这确保了你的镜像能在部署到任何系统时正确运行。不再出现你尝试在生产环境中部署和运行应用程序，却发现重要的库缺失或安装的版本错误的情况。这种模式具有极大的可靠性和可重复性优势，并对系统安全性有非常积极的影响。如果为了修复安全问题，你更新了容器化应用程序所使用的 OpenSSL 或 *libyaml* 库，那么可以确保无论在哪里部署该特定应用程序，它始终会使用该版本运行。

还需要注意的是，许多 Docker 基础镜像比它们实际需要的要大。记住，你的应用程序进程将在共享内核上运行，你镜像中唯一需要的文件是进程运行所需的那些文件。基础镜像如此易于获取固然是好事，但有时可能掩盖了隐藏的依赖关系。尽管人们经常从 Alpine、Ubuntu 或 Fedora 的最小安装开始，这些镜像仍包含大量操作系统文件和你的进程几乎肯定不需要的应用程序，或者你的应用程序可能在使用一些你没有意识到的文件，例如在 Alpine 中使用 *musl* 系统库与其他许多基础镜像中使用的 *glibc* 系统库来编译你的应用程序。即使在容器化你的应用程序时，你也需要充分了解你的依赖关系。此外，还要考虑在你的镜像中是否包含了哪些支持工具，因为在使调试变得更加简单的同时，也可能增加你的应用程序和环境的安全攻击面。

理清镜像内所需文件的一个好方法是比较“小型”基础镜像与使用像 Go 或 C 这样的语言编写的静态链接程序镜像。这些应用程序可以设计为直接在 Linux 内核上运行，而不需要任何额外的库或文件。

为了更好地阐明这一点，回顾一下 “Keeping Images Small” 中的练习可能会有所帮助，我们在那里探讨了一个这样的超轻量级容器 `spkane/scratch-helloworld`，然后稍微深入地研究了底层文件系统，并将其与流行的 `alpine` 基础镜像进行了比较。

除了注意如何管理镜像中的文件系统层，保持镜像仅包含最基本的必需品也是保持一切简洁并且快速执行`docker image pull`命令的另一种好方法。使用解释性语言编写的应用程序将需要更多文件，因为通常需要安装大型运行时和依赖图，但是您应尽量保持最小化的基础层以便为您的用例进行推理。Docker 帮助您打包它们，但仍然需要您负责推理它们。

## 配置

*将配置存储在环境变量中，而不是检入代码库的文件中。*

这使得在不同环境（如测试和生产）中部署相同的代码库变得非常简单，而无需在代码中维护复杂的配置或为每个环境重新构建容器。通过将像数据库名称和密码等特定于环境的信息保持在源代码库之外，可以使代码库更加干净。更重要的是，这意味着您不会将部署环境的假设编码到存储库中，因此可以非常轻松地将应用程序部署到任何可能有用的地方。您还希望能够测试将要发布到生产环境的相同镜像。如果您必须为每个环境构建已经烘焙好了所有配置的镜像，那么这是做不到的。

如第四章所讨论的，您可以通过启动使用`-e`命令行参数的`docker container run`命令来实现这一点。使用`-e APP_ENV=` `*production*`告诉 Docker 在新启动的容器内将环境变量`APP_ENV`设置为值`production`。

举个实际例子，假设我们拉取了安装了[Rocket.Chat](https://www.rocket.chat)适配器的聊天机器人 Hubot 的镜像。我们会发出以下类似的命令来让它运行：

```
$ docker container run \
  --rm --name hubot -d \
  -e ENVIRONMENT="development" \
  -e ROCKETCHAT_URL='rocketchat:3000' \
  -e ROCKETCHAT_ROOM='general' \
  -e RESPOND_TO_DM=true \
  -e ROCKETCHAT_USER=bot \
  -e ROCKETCHAT_PASSWORD=bot \
  -e ROCKETCHAT_AUTH=password \
  -e BOT_NAME=bot \
  -e EXTERNAL_SCRIPTS=hubot-pugme,hubot-help \
  docker.io/rocketchat/hubot-rocketchat:latest
```

在这里，我们在创建容器时传递了一整套环境变量。当进程在容器中启动时，它将访问这些环境变量，以便在运行时正确配置自身。这些配置项现在是一个可以在运行时注入的外部依赖项。

###### 注意

将这些数据提供给容器的其他方式还有很多，包括使用像`etcd`和`consul`这样的键值存储。环境变量只是一个作为大多数项目非常好的起点的通用选项。它们是容器配置的简单途径，因为它们得到了平台和所有常用编程语言的广泛支持。它们还有助于应用程序的可观察性，因为可以轻松地使用`docker container inspect`来检查配置。

对于像 `hubot` 这样的 Node.js 应用程序，您可以编写以下代码，根据这些环境变量做出决策：

```
switch(process.env.ENVIRONMENT){
        case 'development':
            console.log('[INFO] Running in development');

        case 'staging':
            console.log('[INFO] Running in staging');

        case 'production':
            console.log('[INFO] Running in production');

        default:
            console.log('[WARN] Environment value is unknown');
    }
```

###### 注意

用于将配置数据传递到容器中的确切方法将因您为项目选择的具体工具而异，但几乎所有工具都会轻松确保每次部署包含该环境的正确设置。

将特定配置信息从源代码中分离出来，可以轻松地在多个环境中部署完全相同的容器，无需修改，也无需将敏感信息提交到源代码库中。关键是，在部署到生产环境之前，通过允许在所有环境中使用相同的镜像来彻底测试容器映像。

```
$ docker container stop hubot
```

###### 提示

如果需要管理需要提供给您的容器的秘密的过程，您可能需要查看 `docker secret` 命令的[文档](https://docs.docker.com/engine/swarm/secrets)，该命令适用于 Docker Swarm 模式，以及 HashiCorp 的 [Vault](https://www.vaultproject.io)。

## 后备服务

*将后备服务视为附加资源。*

本地数据库不比第三方服务更可靠，应以此为对待。应用程序应优雅地处理所附资源的丢失。通过在应用程序中实施优雅降级，并永不假设包括文件系统空间在内的任何资源可用，您可以确保即使外部资源不可用时，应用程序仍将尽可能执行其许多功能。

Docker 并不直接提供这种功能，尽管编写健壮的服务始终是个好主意，但在使用容器时更为重要。在使用容器时，通常通过水平扩展和滚动部署实现高可用性，而不是依赖于传统虚拟机上长时间运行进程的实时迁移。这意味着服务的特定实例经常会随时间的推移而来来去去，而你的服务应能优雅地处理这一点。

另外，由于 Linux 容器具有有限的文件系统资源，您不能简单地依赖于某些本地存储的可用性。您需要计划进入应用程序的依赖项，并显式地处理它。

## 构建、发布、运行

*严格分离构建和运行阶段。*

构建代码，使用正确的配置发布，然后部署它。这确保您控制整个过程，并可以执行任何单个步骤，而不会触发整个工作流程。通过确保每个步骤都在独立的进程中自包含，您可以缩短反馈循环，并更快地对部署流程中的任何问题做出反应。

在设计 Docker 工作流程时，你希望清晰地分隔部署过程中的每个步骤。可以有一个单独的按钮来构建容器，测试它，然后部署它，这是完全可以接受的，前提是你信任你的测试过程，但你不希望被迫重新构建容器，只是为了将其部署到另一个环境。

Docker 在这一领域很好地支持了 12 因素理想，因为镜像注册表提供了在构建镜像和将其推送到生产环境之间进行清晰交接的点。如果你的构建过程生成镜像并将其推送到注册表，那么部署就可以简单地将镜像拉到服务器上并运行它。

## 进程

*将应用程序作为一个或多个无状态进程执行。*

所有共享数据必须通过有状态的后备存储访问，以便可以轻松地重新部署应用程序实例而不会丢失任何重要的会话数据。你不希望在短暂的容器或其进程的内存中保留任何关键状态。容器化应用程序应始终被视为短暂的。真正动态的容器环境需要在瞬间销毁和重新创建容器的能力。这种灵活性有助于支持现代敏捷工作流所需的快速部署周期和故障恢复。

尽可能地，最好编写不需要保持状态时间超过处理和响应单个请求所需时间的应用程序。这样做可以确保停止应用程序池中的任何容器的影响非常小。当必须保持状态时，最佳方法是使用像 Redis、PostgreSQL、Memcache 甚至 Amazon S3 这样的远程数据存储，具体取决于你的弹性需求。

## 端口绑定

*通过端口绑定导出服务。*

你的应用程序需要通过特定的端口可寻址。应用程序应直接绑定到端口以公开服务，而不应依赖外部守护程序（如`inetd`）来处理这些事务。确保当你连接到该端口时，你正在与你的应用程序通信。大多数现代网络平台都能直接绑定到端口并为其自己的请求提供服务。

要从你的容器中暴露一个端口，如在第四章中讨论的，你可以使用`docker container run`命令，该命令使用`--publish`命令行参数。例如，使用`--publish mode=ingress,published=80,target=8080`将告诉 Docker 代理主机端口 80 上容器的端口 8080。

我们在“保持镜像小”中讨论的静态链接的 Go Hello World 容器是一个很好的例子，因为容器中除了用于提供内容的应用程序外，没有包含任何其他 Web 服务器。我们不需要包含任何额外的 Web 服务器，这将需要进一步的配置，引入额外的复杂性，并增加系统中潜在故障点的数量。

## 并发性

*通过进程模型进行横向扩展。*

设计您的应用程序以支持并发和横向扩展。增加现有实例的资源可能会很困难且难以逆转。根据规模波动添加和删除实例要容易得多，这有助于保持基础设施的灵活性。在新服务器上启动另一个容器的成本非常低廉，相比于为底层虚拟或物理系统添加资源所需的工作和费用，设计横向扩展使平台能够更快地响应资源需求的变化。

举个例子，在第十章中，你看到了如何通过运行以下命令轻松地使用 Docker Swarm 模式来扩展服务：

```
$ docker service scale myservice=8
```

这就是像 Docker Swarm 模式、Mesos 和 Kubernetes 这样的工具真正开始发挥作用的地方。一旦您实施了具有动态调度程序的 Docker 集群，就可以很容易地将三个容器实例添加到集群中以应对负载增加，然后在负载开始减少时轻松地从集群中移除两个应用程序实例。

## 可处置性

*通过快速启动和优雅关闭来最大化鲁棒性。*

服务应设计为短暂的。在讨论容器的外部状态时，我们已经稍微提到了这一点。对动态水平扩展、滚动部署和意外问题的良好响应要求应用程序能够快速且轻松地启动或关闭。服务应能够从操作系统接收`SIGTERM`信号并且能够自信地处理硬件故障。最重要的是，我们不应该关心应用程序中的任何容器是否正在运行。只要能够提供服务，开发者就无需担心系统中任何单个组件的健康状态。如果单个节点表现不佳，关闭它或重新部署它应该是一个简单的决定，不需要长时间的规划会议和对其余集群健康状态的担忧。

如第七章所述，Docker 在停止或杀死容器时向其发送标准的 Unix 信号；因此，任何容器化应用程序都可以检测这些信号并采取适当的步骤以优雅地关闭。

## 开发/生产环境的一致性

*尽可能使开发、测试和生产环境尽可能相似。*

所有环境中构建、测试和部署服务应使用相同的流程和工件。同一组人员应在所有环境中进行工作，并且环境的物理特性应尽可能相似。可重复性非常重要。几乎在生产中发现的任何问题都指向流程失败。生产环境与暂存环境分歧的每个领域都是引入风险的领域。这些不一致会使您对可能发生在生产环境中的某些问题变瞎，直到为时已晚才能主动处理它们。

在许多方面，这些建议基本上重复了早期的一些建议。然而，这里的具体观点是，任何环境分歧都会引入风险，尽管这些差异在许多组织中很常见，但在容器化环境中却不太必要。Docker 服务器通常可以创建为在所有环境中都相同，环境配置更改通常只应影响服务连接到的端点，而不会明确更改应用程序的行为。

## 日志

*将日志视为事件流。*

服务不应关注路由或存储日志。相反，事件应被流式传输，无缓冲，到`STDOUT`和`STDERR`以供托管进程处理。在开发中，`STDOUT`和`STDERR`可以轻松查看，而在暂存和生产中，流可以路由到任何地方，包括中央日志服务。不同环境对日志处理有不同的例外情况。这种逻辑不应硬编码到应用程序中。将所有内容流式传输到`STDOUT`和`STDERR`使得顶级进程管理器能够通过最适合环境的方法处理日志，从而使应用程序开发人员能够专注于核心功能。

在第六章中，我们讨论了`docker container logs`命令，该命令收集容器的`STDOUT`和`STDERR`的输出并记录为日志。如果将日志写入容器文件系统中的随机文件，您将无法轻松访问它们。还可以配置 Docker 将日志发送到本地或远程日志系统，使用类似`rsyslog`、`journald`或`fluentd`的工具。

如果您在服务器上使用进程管理器或初始化系统，如`systemd`或`upstart`，通常很容易将所有进程输出定向到`STDOUT`和`STDERR`，然后让您的进程监视器捕获它们并将它们发送到远程日志主机。

## 管理流程

*将管理任务作为一次性流程运行。*

一次性管理任务应通过与应用程序使用相同的代码库和配置来运行。这有助于避免同步问题和代码/架构漂移问题。管理工具往往存在于一次性脚本中，或者完全存在于不同的代码库中。在应用程序的代码库内构建管理工具并利用相同的库和函数执行所需的工作，这样做可以显著提高这些工具的可靠性，确保它们利用与应用程序核心功能相同的代码路径。

这意味着你不应该依赖类似于`cron`的随机脚本来执行管理和维护功能。相反，应将所有这些脚本和功能包含在你的应用程序代码库中。假设这些不需要在你的应用程序的每个实例上运行，你可以启动一个特殊的短暂容器，或者在需要运行维护作业时使用`docker container exec`与现有容器一起。这个命令可以触发所需的作业，在某处报告其状态，然后退出。

## 十二要素总结

虽然“十二要素应用”并非专门为 Docker 而写的宣言，但几乎所有这些建议都可以应用于在 Docker 平台上编写和部署应用程序。部分原因是因为该文章深刻影响了 Docker 的设计，部分原因是因为宣言本身明确了现代软件架构师推广的许多最佳实践。

# 响应式宣言

与“十二要素应用”并驾齐驱的是另一份相关文档，由 Typesafe 联合创始人兼 CTO Jonas Bonér 在 2013 年 7 月发布，题为[“响应式宣言”](https://www.reactivemanifesto.org)。Jonas 最初与一小组贡献者共同工作，以明确阐述一份关于如何预测性地应对各种交互形式（包括事件、用户、负载和[故障](https://www.lightbend.com/blog/why-do-we-need-a-reactive-manifesto)）的宣言，讨论了应用程序弹性的期望如何在过去几年里演变，以及应该如何设计应用程序以可预测地对各种交互做出反应。

“响应式宣言”指出，“响应式系统”具备响应性、弹性、伸缩性和消息驱动性。

## 响应性

*如果可能，系统应及时响应*。

总体而言，这意味着应用程序应该非常快速地响应请求。用户根本不想等待，而且很少有充分的理由让他们等待。如果你有一个容器化的服务来渲染大型 PDF 文件，设计它可以立即响应“作业已提交”的消息，这样用户可以继续他们的工作，然后提供一个消息或横幅，告知他们作业何时完成以及从哪里下载生成的 PDF。

## 弹性

*系统在面对故障时保持响应*。

当你的应用由于任何原因失败时，如果变得无响应，情况将会变得更糟。最好是优雅地处理失败，并动态降低应用的功能，甚至向用户显示简单而清晰的问题消息，同时内部报告问题。

## 弹性

*系统在不同工作负载下保持响应性。*

使用 Docker，你通过动态部署和下架容器来实现这一点，以便在需求和负载波动时，你的应用始终能够快速处理服务器请求，而不需要部署大量未充分利用的资源。

## 消息驱动

*响应式系统依赖于异步消息传递来建立组件之间的边界，确保松耦合、隔离和位置透明性。*

虽然 Docker 并未直接处理这一点，但这里的想法是，有时应用程序可能会变得繁忙或不可用。如果你在服务之间利用异步消息传递，可以帮助确保你的服务不会丢失请求，并且请求将尽快被处理。

# 总结

在“响应式宣言”中的四个设计特性都要求应用开发者设计优雅的降级，并在其应用中明确划分责任。通过将所有依赖视为设计良好的、连接的资源，动态容器环境允许你轻松地在应用堆栈中保持 *N*+2 的状态，可靠地扩展环境中的个别服务，并快速替换不健康的节点。

一个服务的可靠性取决于其最不可靠的依赖，因此将这些理念融入到平台的每个组件中至关重要。

“响应式宣言”中的核心思想与“十二要素应用”及 Docker 工作流非常契合。这些文档成功地总结了关于如何在行业中满足新期望的许多重要讨论。Docker 工作流为在任何组织中以完全可接近的方式实施这些思想提供了实用的方法。
