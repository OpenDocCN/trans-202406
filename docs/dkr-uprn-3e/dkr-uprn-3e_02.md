# 第一章：介绍

Docker 是由当时被称为 dotCloud 公司的创始人兼 CEO Solomon Hykes 在 2013 年 3 月 15 日在加利福尼亚州圣克拉拉的[Python 开发者大会](https://us.pycon.org)上进行的一个五分钟的[闪电演讲](https://youtu.be/wW9CAH9nSLs)中首次向世界公开介绍的，没有任何预先公告和少量的热烈欢迎。在这一公告之时，除了 dotCloud 外，仅有大约 40 人有机会体验 Docker。

在此公告发布几周后，出乎意料地引起了大量媒体关注。源代码很快作为一个公共的、完全开源的项目，在[GitHub](https://github.com/moby/moby)上发布。在接下来的几个月里，越来越多的行业人士开始听说 Docker，以及它如何革新软件构建、交付和运行的方式。而在一年内，几乎没有人在行业内不知道 Docker，但许多人仍然不确定它究竟是什么，以及为什么人们对它如此兴奋。

Docker 是一个工具，承诺轻松封装创建任何应用程序的可分发工件的过程，在任何环境中进行规模部署，并优化敏捷软件组织的工作流程和响应能力。

# Docker 的承诺

最初，许多对 Docker 不熟悉的人将其视为某种虚拟化平台，但实际上，它是第一个广泛可接触的基于一种称为*容器化*的新技术构建的工具。Docker 和 Linux 容器对包括 Vagrant、KVM、OpenStack、Mesos、Capistrano、Ansible、Chef、Puppet 等工具和技术在内的多个行业领域产生了重大影响。关于这些产品列表的情况，说明了很多事情，也许你已经发现了。看过这份列表后，大多数工程师会认识到，这些工具涵盖了很多不同的用例，但所有这些工作流程都已经被 Docker 彻底改变。这主要是因为 Docker 显著改变了每个人对持续集成和持续交付（CI/CD）工作流程应该如何运作的期望。与每个步骤都涉及由专家管理的耗时过程不同，大多数人希望 DevOps 流水线能够完全自动化，并在一个步骤到下一个步骤之间流畅无阻地进行。该列表中的技术通常也因其提高生产力的能力而广受好评，这正是使 Docker 如此受欢迎的原因。Docker 位于过去十年中一些最具推动力的技术的核心，并且可以显著改进流水线的几乎每一个步骤。

如果你要逐个功能比较 Docker 和任何单一领域的冠军（例如配置管理），Docker 很可能看起来像是一个中等竞争者。它在某些领域比其他领域更强大，但 Docker 带来的是一个跨越广泛工作流挑战的功能集。通过结合应用程序测试和部署工具（如 Vagrant 和 Capistrano）的易用性与管理虚拟化系统的便捷性，并提供易于实现的工作流自动化和编排界面，Docker 提供了一个非常有益的功能集。

许多新技术如风而来，对最新的热潮保持一些怀疑总是很健康的。当 Docker 还是一项新技术时，很容易将其视为仅解决开发人员或运维团队的一些特定问题的又一技术。如果你把 Docker 看作是一种伪虚拟化或仅仅是部署技术，它可能并不那么引人注目。但 Docker 远比表面上看起来的要复杂得多。

即使在较小的组织中，使不同团队之间的沟通和流程正确运作通常也很困难且经常代价高昂。然而，我们生活在一个要求团队之间传递详细信息才能成功的世界。发现并实施一种减少沟通复杂性同时有助于生产更强大软件的工具是一大收获。这也正是为何 Docker 值得深入研究的原因。它并非万能药，而在组织内实施 Docker 需要进行一些关键思考，但 Docker 和 Linux 容器提供了解决一些实际组织问题的良好方法，并帮助企业更快速地发布更好的软件。提供一个精心设计的 Linux 容器工作流程可以使技术团队更加愉快，并为组织的底线节省实际开支。

那么，公司最痛苦的地方在哪里呢？以今天的标准来看，以期望的速度发布软件确实很难做到，并且随着公司从一两名开发人员增长到多个开发团队，围绕发布新版本的沟通负担变得更加沉重和难以管理。开发人员必须了解他们将要发布软件的环境的复杂性，而生产运营团队则需要越来越深入地了解他们发布的软件的内部。这些通常都是很好的技能，因为它们有助于更好地理解整体环境，从而鼓励设计更加健壮的软件，但是这些技能在组织增长加速时很难有效扩展。

每个公司环境的细节通常需要大量沟通，这些沟通并不直接为涉及的团队带来价值。例如，要求开发者向运维团队请求特定库的 1.2.1 版本会拖慢他们的速度，并且对公司没有直接的业务价值。如果开发者可以简单地升级他们使用的库版本，编写他们的代码，使用新版本进行测试并进行发布，交付时间将会显著缩短，并且部署变更的风险将会减少。如果运维工程师可以在不需要与多个应用开发团队协调的情况下升级主机系统上的软件，他们可以更快地进行操作。Docker 有助于在软件中构建一层隔离，从而减少人类沟通的负担。

除了帮助解决沟通问题外，Docker 还在软件架构上持有一种鲜明的观点，鼓励构建更加健壮的应用程序。它的架构理念集中在原子或一次性容器上。在部署过程中，旧应用程序的整个运行环境会随之被丢弃。应用程序环境中的任何内容都不会比应用程序本身生存得更久，这是一个简单而有重大影响的理念。这意味着应用程序不太可能意外依赖于先前发布留下的遗物。这意味着短暂的调试更改不太可能会在未来的发布中继续存在，因为它们是从本地文件系统中获取的。这也意味着应用程序在服务器之间的可移植性很高，因为所有状态都必须直接包含在部署工件中并且是不可变的，或者发送到像数据库、缓存或文件服务器这样的外部依赖中。

所有这些都导致了不仅更具可扩展性而且更可靠的应用程序。应用程序容器的实例可以随时生成和销毁，几乎不会影响前端站点的运行时间。这些都是已经在非 Docker 应用程序中成功的架构选择，但是 Docker 强制执行的设计选择意味着容器化应用程序*必须*遵循这些最佳实践。而这是一件非常好的事情。

## Docker 工作流的好处

要完整地归类 Docker 带来的所有优势是很困难的。当实施良好时，它在多方面为组织、团队、开发者和运维工程师带来益处。它使得架构决策更加简单，因为从托管系统的视角看，所有应用程序在外观上本质上都是相同的。它使得编写和在应用程序之间共享工具更加容易。在这个世界上没有什么是没有好处的，但 Docker 显然更倾向于带来益处。以下是使用 Docker 和 Linux 容器时获得的一些更多好处：

将软件打包成一种利用开发者已有技能的方式

许多公司不得不为发布和构建工程师创建职位，以便管理创建其支持的平台的软件包所需的所有知识和工具。像`rpm`，`mock`，`dpkg`和`pbuilder`这样的 Linux 工具可能很难使用，并且每个工具必须独立学习。Docker 将所有您的要求捆绑到一个打包格式中，称为[Open Container Initiative (OCI)](https://opencontainers.org)标准。

将应用软件和所需的操作系统文件系统捆绑在一个单一的标准化镜像格式中。

以前，通常需要打包不仅是您的应用程序，还包括许多依赖项，如库和守护进程。然而，您永远无法确保 100%的执行环境是相同的。对于本地编译的代码，这意味着您的构建系统需要与生产环境具有完全相同的共享库版本。所有这些使得打包难以掌握，并且对许多公司来说很难可靠地完成。通常情况下，运行[Scientific Linux](https://scientificlinux.org)的人会尝试部署在[Red Hat Enterprise Linux](https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux)上测试过的社区包，希望该包与他们所需的接近。使用 Docker，您可以部署您的应用程序以及运行它所需的每个文件。Docker 的分层镜像使这个过程高效化，确保您的应用程序在预期的环境中运行。

使用打包的工件来测试并将完全相同的工件交付给所有环境中的所有系统。

当开发人员向版本控制系统提交更改时，可以构建新的 Docker 镜像，该镜像可以通过整个测试过程并在不需要在任何步骤中重新编译或重新打包的情况下部署到生产环境，除非特别需要。

把软件应用从硬件中抽象出来，而不牺牲资源。

传统的企业虚拟化解决方案如 VMware 通常用于在物理硬件和运行在其上的软件应用程序之间创建一个抽象层，但会以资源为代价。管理虚拟机和每个虚拟机运行的内核的超级监视器会使用硬件系统资源的一部分，这些资源因此不再可用于托管的应用程序。相反，容器只是另一个进程，通常直接与底层 Linux 内核通信，因此可以利用更多资源，直到达到系统或基于配额的限制。

当 Docker 首次发布时，Linux 容器已经存在了很多年，Docker 构建在其上的许多其他技术并不全是新的。然而，Docker 强大的架构和工作流选择的独特组合，使其整体远比其各部分之和更为强大。Docker 独自使得自 2008 年公开以来一直存在的 Linux 容器变得易于接近和对所有计算机工程师有用。Docker 相对容易地将容器融入实际公司的现有工作流程和流程中。而前面讨论过的问题被如此多的人感受到，以至于对 Docker 项目的兴趣加速发展得比任何人都能合理预期的更快。

从 2013 年开始，Docker 经历了快速迭代，现在拥有庞大的功能集，并在全球广泛部署在大量生产基础设施中。它已经成为任何现代分布式系统的基础层之一，并激发了许多其他人扩展这一方法。许多公司现在利用 Docker 和 Linux 容器作为解决其应用交付过程中面临的严重复杂性问题的解决方案。

# Docker 并非什么

Docker 可以用来解决广泛的挑战，传统工具类别通常被用来解决这些挑战；然而，Docker 的广泛功能经常意味着它在特定功能上缺乏深度。例如，一些组织在迁移到 Docker 后可能会完全移除其配置管理工具，但 Docker 的真正强大之处在于，虽然它可以替代某些更传统的工具的某些方面，但通常也与它们兼容甚至在组合使用时进行增强。在下面的列表中，我们探讨了一些 Docker 不能直接替代但通常可以与之配合使用以取得良好效果的工具类别：

企业虚拟化平台（VMware、KVM 等）

在传统意义上，容器不是虚拟机。虚拟机包含完整的操作系统，运行在由底层主机操作系统管理的 hypervisor 之上。Hypervisor 创建虚拟硬件层，使得可以在单个物理计算机系统上运行多个不同操作系统。这使得在单个主机上运行许多具有根本不同操作系统的虚拟机变得非常容易。而容器中，主机和容器共享同一个内核。这意味着容器利用更少的系统资源，但必须基于相同的底层操作系统（例如 Linux）。

云平台（OpenStack、CloudStack 等）

与企业虚拟化类似，容器工作流程在表面上与更传统的云平台有许多相似之处。两者传统上被利用以允许应用程序根据需求变化进行水平扩展。然而，Docker 并非云平台。它仅处理在预先存在的 Docker 主机上部署、运行和管理容器。它不允许您创建新的主机系统（实例）、对象存储、块存储以及通常使用云平台管理的其他资源。话虽如此，随着您开始扩展 Docker 工具，您应该开始体验到传统上与云关联的更多好处。

配置管理（Puppet，Chef 等）

尽管 Docker 可以显著改善组织管理应用程序及其依赖关系的能力，但它并不直接替代更传统的配置管理。*Dockerfiles*用于定义在构建时容器应该如何看起来，但它们不管理容器的持续状态，也不能用于管理 Docker 主机系统。然而，Docker 可以显著减少复杂的配置管理代码需求。随着越来越多的服务器简单地成为 Docker 主机，公司使用的配置管理代码库可以变得更小，Docker 可以用于将更复杂的应用程序要求打包到标准化的 OCI 镜像中。

部署框架（Capistrano，Fabric 等）

Docker 通过创建容器镜像来简化部署的多个方面，这些镜像封装了应用程序的所有依赖关系，可以在所有环境中部署，而无需更改。然而，Docker 本身无法用于自动化复杂的部署过程。通常还需要其他工具来将更大的工作流程连接在一起。话虽如此，由于 Docker 和其他 Linux 容器工具集（如 Kubernetes（k8s））提供了一个定义良好的部署接口，部署容器所需的方法在所有主机上都是一致的，一个单一的部署工作流程应该足以应对大多数，如果不是所有基于 Docker 的应用程序。

开发环境（Vagrant 等）

Vagrant 是开发者常用的虚拟机管理工具，通常用于模拟与将要部署应用程序的生产环境紧密相似的服务器堆栈。除此之外，Vagrant 还简化了在 macOS 和基于 Windows 的工作站上运行 Linux 软件的过程。由类似 Vagrant 管理的虚拟机协助的开发者试图避免常见的“在我的机器上可以运行”的情况，即开发者的软件能正常运行，但在其他地方可能运行不正常。然而，与之前的例子一样，当你开始充分利用 Docker 时，就不再需要在开发中模仿各种生产系统，因为大多数生产系统将只是 Linux 容器服务器，可以轻松地在本地复制。

工作负载管理工具（Mesos、Kubernetes、Swarm 等）。

必须使用一个编排层（包括内置的 Swarm 模式）来协调整个 Linux 容器主机池中的工作，跟踪所有主机及其资源的当前状态，并维护正在运行的容器清单。这些系统旨在自动化保持生产集群健康所需的常规任务，同时提供帮助人们更轻松地与容器化工作负载的高度动态性互动的工具。

每个部分指出了 Docker 和 Linux 容器颠覆和改进的重要功能。Linux 容器提供了在受控和隔离环境中运行软件的方式，而 Docker 引入的易于使用的命令行界面（CLI）工具和容器镜像标准使得使用容器变得更加简单，并确保了在整个服务器集群上构建软件的可重复方式。

# 重要术语

下面是我们将在整本书中继续使用的几个术语及其含义，你应该熟悉这些术语：

Docker 客户端

这是用于控制大部分 Docker 工作流并与远程 Docker 服务器通信的`docker`命令。

Docker 服务器

这是用于启动 Docker 服务器进程并通过客户端构建和启动容器的`dockerd`命令。

Docker 或 OCI 镜像

Docker 和 OCI 镜像由一个或多个文件系统层和一些重要的元数据组成，这些元数据代表运行容器化应用程序所需的所有文件。单个镜像可以复制到多个主机上。一个镜像通常具有仓库地址、名称和标签。标签通常用于标识镜像的特定版本（例如 *docker.io/superorbital/wordchain:v1.0.1*）。Docker 镜像是与 Docker 工具集兼容的任何镜像，而 OCI 镜像特指符合 Open Container Initiative 标准且保证与任何 OCI 兼容工具一起工作的镜像。

Linux 容器

这是从 Docker 或 OCI 镜像实例化的容器。一个特定的容器只能存在一次；然而，你可以轻松地从同一个镜像创建多个容器。术语*Docker 容器*是一个误称，因为 Docker 只是利用操作系统的容器功能。

原子或不可变主机

原子或不可变主机是一个小巧精细的操作系统镜像，比如[Fedora CoreOS](https://getfedora.org/en/coreos)，支持容器托管和原子操作系统升级。

# 总结

当你没有强烈的参考框架时，完全理解 Docker 可能是具有挑战性的。在下一章中，我们将概述 Docker 的大致情况：它是什么，预期如何使用，以及在考虑所有这些因素时实施时带来的优势。
