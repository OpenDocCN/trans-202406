# 目录（真实的内容）

+   如何使用本书：*Intro*

    **你的大脑与 Android 同行。** 在你努力学习某事时，你的大脑却在帮你确保学到的知识不会留下痕迹。你的大脑在想，“最好留出空间给更重要的事情，比如避免哪些野生动物以及裸体滑雪是否一个坏主意。” 那么，如何让你的大脑相信你的生活取决于知道如何开发 Android 应用程序呢？

    1.  “这本书是为谁准备的？”

    1.  “我们知道你在想什么”

    1.  “我们知道你的*大脑*在想什么”

    1.  “元认知：思考思维”

    1.  “这就是我们做的”

    1.  “阅读我”

    1.  “真正了不起的技术审阅团队”

    1.  “致谢”

+   第一章

    **Android 是全球最流行的移动操作系统。** 全球有数十亿的 Android 用户，都在等待下载你的下一个伟大想法。在本章中，您将了解如何通过**构建一个基本的 Android 应用程序**并进行更新，开始将您的想法变成现实。您将学习如何在物理和虚拟设备上运行它。在此过程中，您将遇到所有 Android 应用程序的两个核心组件：**活动**和**布局**。

    1.  “欢迎来到 Androidville”

    1.  “活动和布局构成您的应用程序的核心”

    1.  “我们将要做什么”

    1.  “Android Studio：您的开发环境”

    1.  “安装 Android Studio”

    1.  “让我们构建一个基本的应用程序”

    1.  “如何构建应用程序”

    1.  “Android 版本近距离观察 ![Images”](img/ch01.xhtml#android_versions_up_close)

    1.  “您已创建您的第一个 Android 项目”

    1.  “解剖你的新项目”

    1.  “介绍项目中的关键文件”

    1.  “使用 Android Studio 编辑器编辑代码”

    1.  “到目前为止的故事”

    1.  “如何在物理设备上运行应用程序”

    1.  “如何在虚拟设备上运行应用程序”

    1.  “创建 Android 虚拟设备（AVD）”

    1.  “编译、打包、部署、运行”

    1.  “刚才发生了什么？”

    1.  “完善应用程序”

    1.  “布局中有什么？”

    1.  “activity_main.xml 包含两个元素”

    1.  “更新布局中显示的文本”

    1.  “代码做了什么？”

    1.  “你的 Android 工具箱”

+   第二章

    **大多数应用需要以某种方式响应用户**。在本章中，你将看到如何使你的应用程序**更具交互性**。你将了解如何向你的活动代码添加***OnClickListener***，使得你的应用可以**监听用户的操作**并做出适当的响应。你还将更深入地了解**如何设计布局**，并学习每个添加到布局中的 UI 组件是如何来自**一个共同的 View 祖先**。在此过程中，你将发现**为什么字符串资源对于灵活、设计良好的应用程序如此重要**。

    1.  “让我们构建一个啤酒顾问应用程序”

    1.  “创建项目”

    1.  “仔细查看设计编辑器”

    1.  “使用设计编辑器添加按钮”

    1.  “仔细查看布局代码”

    1.  “更新布局 XML”

    1.  “XML 更改在设计编辑器中反映”

    1.  “布局中有警告…”

    1.  “将文本放入字符串资源文件”

    1.  “提取字符串资源”

    1.  “添加并使用新的字符串资源”

    1.  “深入了解字符串资源 ![图片”](img/ch02.xhtml#string_resources_up_close)

    1.  “向 Spinner 添加值”

    1.  “向 strings.xml 添加 string-array”

    1.  “我们需要使应用程序具有交互性”

    1.  “MainActivity 代码的样子”

    1.  “按钮可以监听点击事件…”

    1.  “获取按钮的引用…”

    1.  “将 Lambda 传递给 setOnClickListener 方法”

    1.  “How to edit a text view’s text”

    1.  “The updated code for MainActivity.kt”

    1.  “What happens when you run the code”

    1.  “Add the getBeers() method”

    1.  “Your Android Toolbox”

+   Chapter 3

    **我们只是初步接触了布局的使用**。到目前为止，您已经看到如何在简单的线性布局中排列视图，但布局还可以做更多事情。在本章中，我们将**深入一些**，向您展示布局的真正工作方式。您将学习**如何调整线性布局**。您将了解如何使用**帧布局**和**滚动视图**。并且在本章结束时，您将会发现，即使它们看起来可能有些不同，所有布局以及您添加到它们的视图**有更多共同之处**。

    1.  “It all starts with a layout”

    1.  “Android has different types of layout”

    1.  “How to define a linear layout”

    1.  “Orientation can be vertical or horizontal”

    1.  “Anatomy of AndroidManifest.xml ![Images”](img/ch03.xhtml#anatomy_of_androidmanifestdotxml)

    1.  “Use padding to add space to the layout’s edges”

    1.  “The layout code so far”

    1.  “An edit text lets you enter text”

    1.  “Add views to the layout XML”

    1.  “Make a view streeeeetch by adding weight”

    1.  “How to add weight to one view”

    1.  “How to add weight to multiple views”

    1.  “Values you can use with the android:gravity attribute”

    1.  “The story so far”

    1.  “More values you can use with the android:layout-gravity attribute”

    1.  “Use margins to add space between views”

    1.  “Your activity code tells Android which layout it uses”

    1.  “Layout inflation: an example”

    1.  “A frame layout stacks its views”

    1.  “Add an image to your project”

    1.  “Drawable Resources Up Close ![Images”](img/ch03.xhtml#drawable_resources_up_close)

    1.  “框架布局按照布局 XML 中出现的顺序堆叠视图”

    1.  “所有布局都是 ViewGroup 的一种类型…”

    1.  “滚动视图插入垂直滚动条”

    1.  “您的 Android 工具箱”

+   第四章

    **没有蓝图就不要盲目建房子。** 一些布局使用**蓝图**确保它们**完全按照您的意愿展示**。在本章中，我们将向您介绍 Android 的**约束布局**：一种**设计更复杂 UI 的灵活方式**。您将了解如何使用**约束**和**偏差**来定位和调整视图的大小，**无论屏幕大小和方向如何**。您将了解如何使用**指南线**和**障碍物**来固定视图的位置。最后，您将学习如何使用**链条**和**流**来打包或展开视图。

    1.  “嵌套布局再探讨”

    1.  “介绍约束布局”

    1.  “约束布局是 Android Jetpack 的一部分”

    1.  “使用 Gradle 包含 Jetpack 库”

    1.  “让我们在 activity_main.xml 中添加一个约束布局”

    1.  “在蓝图中添加一个按钮”

    1.  “使用约束来定位视图”

    1.  “还要添加一个垂直约束”

    1.  “使用对立约束来居中视图”

    1.  “使用约束小部件删除约束”

    1.  “蓝图的更改会在 XML 中反映出来”

    1.  “视图可以具有偏差”

    1.  “您可以更改视图的大小”

    1.  “大多数布局需要多个视图”

    1.  “您可以将视图连接到其他视图”

    1.  “使用指南线对齐视图”

    1.  “指南线有固定的位置”

    1.  “创建一个可移动的障碍物”

    1.  “添加一个水平障碍物”

    1.  “将按钮约束在障碍物下方”

    1.  “使用链条来控制线性视图组”

    1.  “创建水平链条”

    1.  “有不同风格的链条”

    1.  “一个流程就像是一个多行链”

    1.  “如何添加一个流程”

    1.  “您可以控制流程的外观”

    1.  “您的 Android 工具箱”

+   第五章

    **活动是每个 Android 应用程序的基础**。到目前为止，您已经了解如何创建活动，并与用户进行交互。但是，如果您不了解**活动生命周期**，它的某些行为可能会**让您感到意外**。在本章中，您将学习活动**创建**和**销毁**时发生了什么，以及如何导致**意外后果**。您将了解在活动变得**可见**或**隐藏**时如何控制其行为。甚至还会发现在需要时如何**保存和恢复活动的状态**。

    1.  “活动到底是如何工作的？”

    1.  “创建一个新项目”

    1.  “activity_main.xml 的完整代码”

    1.  “活动代码控制秒表”

    1.  “MainActivity.kt 的完整代码”

    1.  “当您运行应用程序时会发生什么？”

    1.  “旋转屏幕会改变设备配置”

    1.  “活动的状态”

    1.  “活动生命周期：从创建到销毁”

    1.  “您的活动继承了生命周期方法”

    1.  “在 Bundle 中保存当前状态”

    1.  “使用 onSaveInstanceState()保存状态”

    1.  “更新后的 MainActivity.kt 代码”

    1.  “当您运行应用程序时会发生什么？”

    1.  “一个活动的生命周期远不止创建和销毁”

    1.  “可见生命周期”

    1.  “我们需要实现另外两个生命周期方法”

    1.  “当应用程序变得可见时重新启动秒表”

    1.  “当您运行应用程序时会发生什么？”

    1.  “如果一个活动只是部分可见会怎么样？”

    1.  “前台生命周期”

    1.  “如果活动暂停，暂停秒表”

    1.  “完整的 MainActivity.kt 代码”

    1.  “运行应用时会发生什么”

    1.  “活动生命周期方法简明指南”

    1.  “你的 Android 工具箱”

+   第六章

    -   大多数应用需要多个屏幕。到目前为止，我们只看了如何创建单屏应用，这对于简单应用来说很好。但如果你有更复杂的需求呢？在本章中，你将学习如何使用片段和导航组件构建多屏应用。你将了解片段如何像子活动一样拥有自己的方法。你将了解如何设计有效的导航图。最后，你将认识导航宿主和导航控制器，学习它们如何帮助你从一个地方导航到另一个地方。

    1.  “大多数应用需要多个屏幕”

    1.  “每个屏幕都是一个片段”

    1.  “使用 Navigation 组件在屏幕之间导航”

    1.  “创建新项目”

    1.  “将 WelcomeFragment 添加到项目中”

    1.  “片段代码示例”

    1.  “片段的 onCreateView() 方法”

    1.  “片段布局代码看起来像活动布局代码”

    1.  “在 FragmentContainerView 中显示片段”

    1.  “更新 activity_main.xml 代码”

    1.  “代码的作用”

    1.  “创建 MessageFragment”

    1.  “使用 Navigation 组件在片段之间导航”

    1.  “使用 Gradle 添加 Navigation 组件到项目中”

    1.  “创建导航图”

    1.  “向导航图添加片段”

    1.  “使用操作连接片段”

    1.  “导航图是 XML 资源”

    1.  “使用 FragmentContainerView 向布局添加导航宿主”

    1.  “将 NavHostFragment 添加到 activity_main.xml”

    1.  “将 OnClickListener 添加到按钮”

    1.  “获取导航控制器”

    1.  “WelcomeFragment.kt 的完整代码”

    1.  “应用运行时发生了什么”

    1.  “您的 Android 工具箱”

+   第七章

    **有时片段需要额外的信息才能正常工作。**例如，如果一个片段显示一个联系人的详细信息，它需要知道要显示哪个联系人。但如果这些信息来自**另一个片段**呢？在本章中，你将通过学习**如何在片段之间传递数据**，进一步完善你的导航技能。你将了解如何**向导航目的地添加参数**，以便它们能够接收所需的信息。你将会遇到**Safe Args 插件**，并学习如何使用它来**编写类型安全的代码**。最后，你将探索**如何操作返回堆栈**，并控制返回按钮的行为。

    1.  “秘密消息应用在片段之间导航”

    1.  “MessageFragment 需要将消息传递给新的片段”

    1.  “创建 EncryptFragment…”

    1.  “将 EncryptFragment 添加到导航图”

    1.  “MessageFragment 需要导航到 EncryptFragment”

    1.  “将 Safe Args 添加到 build.gradle 文件”

    1.  “EncryptFragment 需要接受一个 String 参数”

    1.  “MessageFragment 需要将消息传递给 EncryptFragment”

    1.  “Safe Args 生成 Directions 类”

    1.  “更新 MessageFragment.kt 代码”

    1.  “EncryptFragment 需要获取参数的值”

    1.  “EncryptFragment.kt 的完整代码”

    1.  “应用运行时发生了什么”

    1.  “用户想要返回怎么办？”

    1.  “欢迎来到返回堆栈”

    1.  “使用导航图弹出片段”

    1.  “您的 Android 工具箱”

+   第八章

    大多数应用需要能够在目的地之间进行导航。而有了 Android 的导航组件，构建此 UI 变得简单得多。在这里，您将学习如何使用一些 Android 的导航 UI 组件，以便使**您的用户能更轻松地导航您的应用**。您将了解如何使用**主题**，并将默认应用栏替换为**工具栏**。您将学习如何添加**可用于导航的菜单项**。您将发现如何实现**底部导航栏导航**。最后，您将创建一个时尚的**导航抽屉**：这是一个从活动侧边滑出的面板。

    1.  “不同应用，不同结构”

    1.  “Android 包含导航 UI 组件”

    1.  “CatChat 应用的工作方式”

    1.  “在 AndroidManifest.xml 中应用主题”

    1.  “在样式资源文件中定义样式”

    1.  “将默认应用栏替换为工具栏”

    1.  “创建 InboxFragment”

    1.  “使用菜单资源文件指定工具栏中的项目”

    1.  “onCreateOptionsMenu()将菜单项添加到工具栏”

    1.  “通过 onOptionsItemSelected()响应菜单项点击”

    1.  “使用 AppBarConfiguration 配置工具栏”

    1.  “应用运行时的具体操作”

    1.  “大多数类型的 UI 导航都可以使用导航组件”

    1.  “创建 SentItemsFragment”

    1.  “底部导航栏需要一个新的菜单资源文件”

    1.  “将底部导航栏链接到导航控制器”

    1.  “导航抽屉允许您显示许多导航项”

    1.  “添加支持部分…”

    1.  “使用分组突出显示选定的项目”

    1.  “创建导航抽屉的标题”

    1.  “如何创建导航抽屉”

    1.  “配置工具栏的抽屉图标…”

    1.  “您的 Android 工具箱”

+   第九章

    -   大多数应用程序需要一个响应用户的流畅用户界面。您到目前为止已经学会了如何使用诸如**文本视图、按钮和下拉框**等视图，并应用了**Material 主题**以进行广泛的应用程序外观和感觉变更。但是您还可以做得更多。在这里，您将学习如何通过**协调布局**使用户界面更具响应性。您将创建可以根据需要**折叠或滚动**的**工具栏**。您还将发现**新奇的新视图**，如**复选框、单选按钮、芯片和浮动操作按钮**。最后，您将了解如何使用**吐司和 Snackbar**显示友好的弹出消息。

    1.  “Material 在整个 Androidville 中使用”

    1.  “Bits 和 Pizzas 应用程序”

    1.  “创建 OrderFragment”

    1.  “用工具栏替换默认应用栏”

    1.  “片段没有 setSupportActionBar() 方法”

    1.  “协调布局协调视图之间的动画”

    1.  “应用栏布局启用工具栏动画”

    1.  “告诉工具栏如何响应滚动事件”

    1.  “如何创建普通的折叠工具栏”

    1.  “如何将图像添加到折叠工具栏”

    1.  “我们需要构建 OrderFragment 的主要内容”

    1.  “使用单选按钮选择披萨类型”

    1.  “芯片是一种灵活的复合按钮类型”

    1.  “向 ChipGroup 添加多个芯片”

    1.  “FAB 是浮动操作按钮”

    1.  “您可以将 FAB 锚定到折叠工具栏”

    1.  “我们需要构建 OrderFragment 的布局”

    1.  “将 OnClickListener 添加到 FAB”

    1.  “吐司是一种简单的弹出消息”

    1.  “在 Snackbar 中显示披萨订单”

    1.  “披萨订单的 Snackbar 代码”

    1.  “OrderFragment.kt 的完整代码”

    1.  “您的 Android 工具箱”

+   第十章

    现在是时候告别 findViewById()了。正如你现在可能已经注意到的那样，你拥有的视图越多，你的应用程序变得越交互式，就越需要调用 findViewById()。如果你已经厌倦了每次想要使用视图时都要输入这个方法的代码，你并不孤单。在本章中，你将会发现如何通过实现视图绑定使 findViewById()成为过去时。你将了解如何将这种技术应用于活动和片段代码，并且你将了解为什么这种方法是访问布局视图更安全、更高效的方式。

    1.  “Behind the scenes of findViewById()”

    1.  “findViewById()也有其缺点”

    1.  “视图绑定来拯救”

    1.  “我们将如何使用视图绑定”

    1.  “重新访问秒表应用程序”

    1.  “在 app 的 build.gradle 文件中启用视图绑定”

    1.  “如何为活动添加视图绑定”

    1.  “使用绑定属性与视图交互”

    1.  “MainActivity.kt 的完整代码”

    1.  “代码的作用”

    1.  “片段也可以使用视图绑定（但代码有所不同）”

    1.  “为 Bits and Pizzas 启用视图绑定”

    1.  “片段视图绑定代码略有不同”

    1.  “从 onCreateView()到 onDestroyView()，片段可以访问视图”

    1.  “仔细观察片段生命周期方法 ![Images”](img/ch10.xhtml#fragment_lifecycle_methods_up_close)

    1.  “片段视图绑定代码的实现”

    1.  “_binding 指的是绑定对象…”

    1.  “OrderFragment.kt 的完整代码”

    1.  “你的 Android 工具箱”

+   第十一章

    -   当应用程序变得更加复杂时，片段需要处理的事务也越多。如果不小心处理，这可能导致试图做所有事情的**臃肿代码**。业务逻辑、导航、控制 UI、处理配置更改……你说了算，这些都在其中。在本章中，您将学习如何使用**视图模型**来处理这种情况。您将发现它们如何简化您的活动和片段代码。您将了解它们如何在配置更改中生存，保持应用程序的状态安全稳定。最后，我们将向您展示如何构建**视图模型工厂**，以及何时可能需要它。

    1.  “重新讨论配置更改”

    1.  “介绍视图模型”

    1.  “猜谜游戏将要做什么”

    1.  “应用程序的结构化方式”

    1.  “更新项目的 build.gradle 文件…”

    1.  “猜谜游戏应用程序有两个片段”

    1.  “导航应该如何工作”

    1.  “更新导航图”

    1.  “应用程序运行时会发生什么”

    1.  “屏幕旋转时游戏丢失状态”

    1.  “视图模型持有业务逻辑”

    1.  “将视图模型依赖添加到应用的 build.gradle 文件中…”

    1.  “创建 GameViewModel 对象”

    1.  “应用程序运行时会发生什么”

    1.  “![Images 视图模型近距离”](img/ch11.xhtml#view_models_up_close)

    1.  “ResultViewModel 需要保存结果”

    1.  “视图模型工厂创建视图模型”

    1.  “创建 ResultViewModelFactory 类”

    1.  “使用工厂创建视图模型”

    1.  “应用程序运行时会发生什么”

    1.  “您的 Android 工具箱”

+   第十二章

    **你的代码经常需要对属性值变化做出响应**。例如，如果视图模型的属性值发生变化，**片段可能需要通过更新其视图或导航到其他位置来做出响应**。但是**片段如何知道属性何时被更新**？在这里，我们将向你介绍 **LiveData**：一种 **告知感兴趣方发生变化的方式**。你将学习 **MutableLiveData** 的所有内容，以及如何 **使你的片段观察到此类属性**。你会发现 **LiveData 类型如何帮助保持应用程序的完整性**。

    1.  “重新审视猜谜游戏应用程序”

    1.  “片段决定何时更新视图”

    1.  “这就是我们要做的”

    1.  “GameViewModel 和 GameFragment 需要使用 LiveData”

    1.  “LiveData 对象使用 value 属性”

    1.  “片段观察视图模型属性并对更改作出反应。”

    1.  “GameFragment.kt 的完整代码”

    1.  “应用程序运行时发生了什么”

    1.  “片段可以更新 GameViewModel 的属性”

    1.  “应用程序运行时发生了什么”

    1.  “GameFragment 仍包含游戏逻辑”

    1.  “GameViewModel.kt 的完整代码”

    1.  “让 GameFragment 观察新属性”

    1.  “应用程序运行时发生了什么”

    1.  “你的 Android 工具箱”

+   第十三章

    **布局不仅可以控制应用程序的外观。** 到目前为止，你编写的所有布局都是由活动或片段代码告诉它们应该如何行为。但是想象一下，**如果布局能够自行思考**，**做出自己的决策**。在本章中，我们将向你介绍 **数据绑定**：一种 **提升布局智能的方式**。你将了解到如何直接从视图模型 **获取视图的值**。你将使用 **监听器绑定** 让按钮调用它们的方法。你甚至会发现，**只需一行简单的代码即可让视图响应 LiveData 的更新**。

    1.  “回到猜谜游戏应用程序”

    1.  “片段更新其布局中的视图”

    1.  “在应用程序 build.gradle 文件中启用数据绑定”

    1.  “ResultFragment 更新其布局中的文本”

    1.  “1\. 添加<layout>和<data>元素”

    1.  “2\. 设置布局的数据绑定变量”

    1.  “3\. 使用布局的数据绑定变量访问视图模型”

    1.  “应用程序运行时发生了什么”

    1.  “![Images <layout>近距离观察”](img/ch13.xhtml#less_thanlayoutgreater_than_up_close)

    1.  “GameFragment 也可以使用数据绑定”

    1.  “向 fragment_game.xml 添加<layout>和<data>元素”

    1.  “使用数据绑定变量设置布局文本”

    1.  “字符串资源再访”

    1.  “布局可以向字符串资源传递参数”

    1.  “我们需要设置 gameViewModel 变量”

    1.  “应用程序运行时发生了什么”

    1.  “您可以使用数据绑定调用方法”

    1.  “将 finishGame()添加到 GameViewModel.kt”

    1.  “使用数据绑定使按钮在点击时调用方法”

    1.  “应用程序运行时发生了什么”

    1.  “火炉边谈话”

    1.  “我们可以关闭视图绑定”

    1.  “你的 Android 工具箱”

+   第十四章

    **大多数应用程序需要持久化数据**。但如果你不采取措施将这些数据存储在某处，**一旦应用程序关闭，它将永远丢失**。通常在 Androidville，你会通过**将数据存储在数据库中**来保护数据，因此在本章中，我们将向你介绍**Room 持久化库**。你将学习如何**构建数据库**，**创建表格**，以及使用带注解的类和接口定义数据访问方法。你将了解如何使用协程在后台运行数据库代码。同时，你将学习如何通过***Transformations.map()***在数据变化时**即时转换你的活动数据**。

    1.  “大多数应用程序需要存储数据”

    1.  “Room 是一个位于 SQLite 之上的数据库库”

    1.  “创建 TasksFragment”

    1.  “Room 数据库是如何创建的”

    1.  “我们将把任务数据存储在表中”

    1.  “使用 @Entity 指定表名”

    1.  “使用接口指定数据操作”

    1.  “使用 @Insert 插入记录”

    1.  “使用 @Delete 删除记录”

    1.  “创建一个 TaskDatabase 抽象类”

    1.  “为任何 DAO 接口添加属性”

    1.  “MVVM 重温”

    1.  “数据库操作可能运行缓慢”

    1.  “1\. 使用 suspend 标记 TaskDao 的方法”

    1.  “2\. 在后台启动 insert() 方法”

    1.  “TasksViewModel 需要一个视图模型工厂”

    1.  “我们将使用数据绑定插入记录”

    1.  “代码运行时会发生什么”

    1.  “TasksFragment 需要显示记录”

    1.  “使用 getAll() 从数据库获取所有任务”

    1.  “A LiveData<List<Task>> 是一个更复杂的类型”

    1.  “让我们更新 TasksViewModel 代码”

    1.  “我们将把 tasksString 属性绑定到布局的文本视图”

    1.  “代码运行时会发生什么”

    1.  “你的 Android 工具箱”

+   第十五章

    **数据列表是大多数应用的关键部分。**在本章中，我们将展示如何使用 **recycler view** 创建一个 **超级灵活的** **可滚动列表**。您将学习如何为列表创建 **灵活的布局**，包括文本视图、复选框等。您将了解如何创建 **适配器**，以任何您选择的方式将数据 **填充** 到 recycler view 中。您将发现如何使用 **card view** 为数据赋予 **3D 材质外观**。最后，我们将向您展示如何使用 **布局管理器** 只需一两行代码就可以完全改变列表的外观。

    1.  “Tasks 应用当前的外观”

    1.  “我们可以将列表转换为 recycler view”

    1.  “告诉 recycler view 如何显示每个项目…”

    1.  “适配器向回收视图添加数据”

    1.  “定义适配器的视图持有者”

    1.  “重写 onCreateViewHolder()方法”

    1.  “向布局的视图添加数据”

    1.  “我们需要显示回收视图”

    1.  “我们已将回收视图添加到 TasksFragment 的布局中”

    1.  “TasksFragment 需要更新 TaskItemAdapter 的数据属性”

    1.  “代码运行时的情况”

    1.  “回收视图非常灵活”

    1.  “如何创建卡片视图”

    1.  “task_item.xml 的完整代码”

    1.  “适配器的视图持有者需要与新布局代码配合工作”

    1.  “TaskItemAdapter.kt 的完整代码”

    1.  “布局管理器 gallery”

    1.  “更新 fragment_tasks.xml 以将项目排列为网格”

    1.  “代码运行时的情况”

    1.  “你的 Android 工具箱”

+   Chapter 16

    -   你的应用需要尽可能流畅高效地运行。但如果不小心，大型或复杂的数据集可能会导致您的回收视图出现故障。在本章中，我们将向您介绍 DiffUtil：这是一个为您的回收视图增加额外智能的实用类。您将了解如何使用它来高效更新您的回收视图。您将发现 ListAdapters 如何使使用 DiffUtil 变得轻松。并且在此过程中，通过在您的回收视图代码中实现数据绑定，您将学习如何永久摆脱 findViewById()。

    1.  “Tasks 应用再访”

    1.  “如何获取回收视图的数据”

    1.  “数据属性的 setter 调用 notifyDataSetChanged()”

    1.  “告诉回收视图需要改变什么”

    1.  “我们要做的事情”

    1.  “我们需要实现 DiffUtil.ItemCallback”

    1.  “ListAdapter 接受 DiffUtil.ItemCallback 参数”

    1.  “TaskItemAdapter.kt 的更新代码”

    1.  “填充 ListAdapter 的列表…”

    1.  “TasksFragment.kt 的更新代码”

    1.  “代码运行时会发生什么”

    1.  “回收视图可以使用数据绑定”

    1.  “向 task_item.xml 添加数据绑定变量”

    1.  “在适配器的视图持有者代码中填充布局”

    1.  “使用绑定类来填充布局”

    1.  “TaskItemAdapter.kt 的完整代码”

    1.  “task_item.xml 的完整代码”

    1.  “代码运行时会发生什么”

    1.  “您的 Android 工具箱”

+   第十七章

    **某些应用程序依赖用户从列表中选择项目。** 在本章中，您将学习如何通过**使其项目可点击**，将**回收视图（recycler views）**作为应用设计的核心部分。您将了解如何通过点击记录使应用**实现回收视图导航**。您还将发现如何向用户显示所选记录的**额外信息**，并在数据库中进行更新。

    1.  “回收视图可用于导航”

    1.  “使每个项目可点击”

    1.  “我们应该在哪里创建吐司？”

    1.  “我们将向 TaskItemAdapter 传递一个 lambda”

    1.  “代码运行时会发生什么”

    1.  “我们希望使用回收视图导航到新的片段”

    1.  “创建 EditTaskFragment…”

    1.  “更新导航图”

    1.  “使 TasksFragment 导航至 EditTaskFragment”

    1.  “使 EditTaskFragment 显示任务 ID”

    1.  “代码运行时会发生什么”

    1.  “我们希望使用 EditTaskFragment 更新任务记录”

    1.  “使用 TaskDao 与数据库记录交互”

    1.  “创建 EditTaskViewModel”

    1.  “EditTaskViewModel 将告诉 EditTaskFragment 何时导航”

    1.  “EditTaskViewModel 需要一个视图模型工厂”

    1.  “fragment_edit_task.xml 需要显示任务”

    1.  “代码运行时会发生什么”

    1.  “您的 Android 工具箱”

+   第十八章

    -   所有到目前为止您构建的 UI 都使用了视图和布局文件。但是，使用 **Jetpack Compose**，**这不是唯一的选择**。在本章中，我们将前往 **Composeville**，学习如何使用称为 **composables** 的 Compose 组件构建 UI。您将学习如何使用内置的 composables，如 **Text**、**Image**、**TextField** 和 **Button**。您将了解如何将它们排列在 **Rows** 和 **Columns** 中，并使用 **themes** 进行样式设置。您将编写和预览自己的 **composable functions**。甚至您将了解如何使用 ***MutableState*** 对象来管理 composable 的状态。

    1.  “UI 组件不一定是 Views”

    1.  “创建一个新的 Compose 项目”

    1.  “Compose 项目没有布局文件”

    1.  “Compose 活动代码的示例”

    1.  “使用 Text composable 显示文本”

    1.  “在 composable 函数中使用 composables”

    1.  “使用设计或拆分选项预览组合部件”

    1.  “让我们让应用程序转换温度”

    1.  “添加一个 MainActivityContent composable 函数”

    1.  “在 MainActivity.kt 中添加图像”

    1.  “让我们显示温度文本”

    1.  “使用 Button composable 添加按钮”

    1.  “我们需要向 ConvertButton 传递一个 lambda”

    1.  “![Images Composition Up Close”](img/ch18.xhtml#composition_up_close)

    1.  “我们需要更改 TemperatureText 的参数值”

    1.  “应用程序运行时会发生什么”

    1.  “向 composable 函数添加 TextField”

    1.  “应用程序运行时会发生什么”

    1.  “向 Column composable 添加填充”

    1.  “您可以在列或行中居中 composables”

    1.  “应用主题：再探讨”

    1.  “Android Studio 包含额外的主题代码”

    1.  “MainActivity.kt 的完整代码”

    1.  “你的 Android 工具箱”

+   第十九章

    **当各个组件协同工作时，你能够获得最佳效果。** 到目前为止，你已经学会了如何使用视图或可组合项构建用户界面（UI）。但是，如果你想**同时使用**两者呢？在本章中，你将了解如何通过**将可组合项添加到基于视图的 UI 中**，来实现**兼收其效**。你将学会使**可组合项与视图模型协同工作**的技术。你甚至会了解到如何使它们**响应 *LiveData* 更新**。本章结束时，你将拥有**在视图中使用可组合项**的所有工具，甚至**迁移到纯 Compose UI** 的能力。

    1.  “你可以将可组合项添加到基于视图的 UI”

    1.  “猜谜游戏应用结构”

    1.  “我们将用可组合项替换 ResultFragment 的视图”

    1.  “ComposeView 允许你向布局中添加可组合项”

    1.  “使用 Kotlin 代码添加可组合项”

    1.  “为片段内容添加一个可组合函数”

    1.  “重现“开始新游戏”按钮”

    1.  “重现 ResultFragment 的 TextView”

    1.  “onCreateView() 返回 UI 的根视图”

    1.  “ResultFragment.kt 的完整代码”

    1.  “应用程序运行时的情况”

    1.  “接下来我们还将使 GameFragment 也使用可组合项”

    1.  “我们将在 fragment_game.xml 中添加一个 ComposeView”

    1.  “为 GameFragment 的内容添加一个可组合函数”

    1.  “重现“结束游戏”按钮”

    1.  “重现用 TextField 替换 EditText”

    1.  “重现“猜测”按钮”

    1.  “我们将在 Text 可组合项中显示不正确的猜测”

    1.  “创建 IncorrectGuessesText 可组合函数”

    1.  “你的 Android 工具箱”

+   附录 A

    即使经历了这一切，“仍然有更多”。我们认为您需要了解的只是少数几件事情。我们不想忽视它们，而且我们真的希望能给您一本无需在本地健身房进行深度训练就能搬起的书。在您放下这本书之前，请*浏览这些小贴士*。

    1.  “1\. 与其他应用共享数据”

    1.  “2\. WorkManager”

    1.  “3\. 对话框和通知”

    1.  “4\. 自动化测试”

    1.  “5\. 支持不同屏幕尺寸”

    1.  “6\. 更多 Compose 功能”

    1.  “7\. Retrofit”

    1.  “8\. Android 游戏开发工具包”

    1.  “9\. CameraX”

    1.  “10\. 发布您的应用”
