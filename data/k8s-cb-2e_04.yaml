- en: Chapter 4\. Creating and Modifying Fundamental Workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we present recipes that show you how to manage fundamental
    Kubernetes workload types: pods and deployments. We show how to create deployments
    and pods via CLI commands and from a YAML manifest and explain how to scale and
    update a deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Creating a Pod Using kubectl run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to quickly launch a long-running application such as a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `kubectl run` command, a generator that creates a pod on the fly. For
    example, to create a pod that runs the NGINX reverse proxy, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `kubectl run` command can take a number of arguments to configure additional
    parameters of the pods. For example, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set environment variables with `--env`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define container ports with `--port`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a command to run using `--command`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically create an associated service with `--expose`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test a run without actually running anything with `--dry-run=client`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical usages are as follows. To launch NGINX serving on port 2368 and create
    a service along with it, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch MySQL with the root password set, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch a `busybox` container and execute the command `sleep 3600` on start,
    enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also `kubectl run --help` for more details about the available arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Creating a Deployment Using kubectl create
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to quickly launch a long-running application such as a content management
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `kubectl create deployment` to create a deployment manifest on the fly.
    For example, to create a deployment that runs the WordPress content management
    system, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `kubectl create deployment` command can take a number of arguments to configure
    additional parameters of the deployments. For example, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define container ports with `--port`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the number of replicas using `--replicas`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test a run without actually running anything with `--dry-run=client`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the created manifest using `--output yaml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also `kubectl create deployment --help` for more details about the available
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Creating Objects from File Manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than creating an object via a generator such as `kubectl run`, you want
    to explicitly state its properties and then create it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `kubectl apply` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Recipe 7.3](ch07.html#namespace) you’ll see how to create a namespace using
    a YAML manifest. This is one of the simplest examples as the manifest is very
    short. It can be written in YAML or JSON—​for example, with a YAML manifest file
    *myns.yaml* like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create this object with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the namespace was created with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can point `kubectl apply` to a URL instead of a filename in your local
    filesystem. For example, to create the frontend for the canonical Guestbook application,
    get the URL of the raw YAML that defines the application in a single manifest
    and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to see the resources that were created by this operation, for example
    with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 4.4 Writing a Pod Manifest from Scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write a pod manifest from scratch and apply it declaratively, as
    opposed to using a command like `kubectl run`, which is imperative and does not
    require manually editing a manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pod is an `/api/v1` object, and like any other Kubernetes object, its manifest
    file contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`, which specifies the API version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind`, which indicates the type of the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`, which provides some metadata about the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec`, which provides the object specification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pod manifest contains an array of containers and an optional array of volumes
    (see [Chapter 8](ch08.html#ch_volumes_config)). In its simplest form, with a single
    container and no volume, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this YAML manifest in a file called *oreilly.yaml* and then use `kubectl`
    to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to see the resources that were created by this operation, for example
    with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The API specification of a pod is much richer than what is shown in the Solution,
    which is the most basic functioning pod. For example, a pod can contain multiple
    containers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A pod can also contain volume definitions to load data in the containers (see
    [Recipe 8.1](ch08.html#data_exchange_local_volume)), as well as probes to check
    the health of the containerized application (see Recipes [11.2](ch11.html#liveness)
    and [11.3](ch11.html#readiness)).
  prefs: []
  type: TYPE_NORMAL
- en: A description of the thinking behind many of the specification fields and a
    link to the full API object specification are detailed in the [documentation](https://oreil.ly/pSCBL).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unless for very specific reasons, never create a pod on its own. Use a `Deployment`
    object (see [Recipe 4.5](#deployments)) to supervise pods—​it will watch over
    the pods through another object called a `ReplicaSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Launching a Deployment Using a Manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to have full control over how a (long-running) app is launched and
    supervised.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a deployment manifest. For the basics, see also [Recipe 4.4](#pod_manifest).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have manifest file called *fancyapp.yaml* with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are a couple of things you might want to do explicitly
    when launching the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the number of pods (`replicas`), or identical copies, that should be launched
    and supervised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Label it, such as with `env=development` (see also Recipes [7.5](ch07.html#easy_label)
    and [7.6](ch07.html#labels)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set environment variables, such as `SIMPLE_SERVICE_VERSION`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s look at what the deployment entails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you want to get rid of a deployment, and with it the replica sets and pods
    it supervises, execute a command like `kubectl delete deploy/fancyapp`. Do *not*
    try to delete individual pods, as they will be re-created by the deployment. This
    is something that often confuses beginners.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments allow you to scale the app (see [Recipe 9.1](ch09.html#scaling-deployments))
    as well as roll out a new version or roll back a `ReplicaSet` to a previous version.
    They are, in general, good for stateless apps that require pods with identical
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A deployment is a supervisor for pods and replica sets (RSs), giving you fine-grained
    control over how and when a new pod version is rolled out or rolled back to a
    previous state. The RSs and pods that a deployment supervises are generally of
    no interest to you unless, for example, you need to debug a pod (see [Recipe 12.5](ch12.html#debug_pods)).
    [Figure 4-1](#deployment-revisions) illustrates how you can move back and forth
    between deployment revisions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment Revisions](assets/kcb2_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Deployment revisions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To generate the manifest for a deployment, you can use the `kubectl create`
    command and the `--dry-run=client` option. This will allow you to generate the
    manifest in YAML or JSON format and save the manifest for later use. For example,
    to create the manifest of a deployment called `fancy-app` using the container
    image `nginx`, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes [`Deployment` documentation](https://oreil.ly/IAghn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.6 Updating a Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a deployment and want to roll out a new version of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Update your deployment and let the default update strategy, `RollingUpdate`,
    automatically handle the rollout.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create a new container image and want to update the deployment
    based on it, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve now successfully rolled out a new revision of your deployment where
    only the container image used has changed. All other properties of the deployment,
    such as the number of replicas, stay unchanged. But what if you want to update
    other aspects of the deployment, such as changing environment variables? You can
    use a number of `kubectl` commands to update the deployment. For example, to add
    a port definition to the current deployment, you can use `kubectl edit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command will open the current deployment in your default editor or, when
    set and exported, in the editor specified by the environment variable `KUBE_EDITOR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to add the following port definition (see [Figure 4-2](#deployment-edit)
    for the full file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The result of the editing process (in this case, with `KUBE_EDITOR` set to `vi`)
    is shown in [Figure 4-2](#deployment-edit).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you save and exit the editor, Kubernetes kicks off a new deployment, now
    with the port defined. Let’s verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, we see that revision 3 has been rolled out with the changes we introduced
    with `kubectl edit`. However, the `CHANGE-CAUSE` column is empty. You can specify
    a change cause for a revision by using a special annotation. The following is
    an example of setting a change cause for the most recent revision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Editing Deployment](assets/kcb2_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Editing a deployment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are more `kubectl` commands that you can use to
    update your deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `kubectl apply` to update a deployment (or create it if it doesn’t exist)
    from a manifest file—​for example, `kubectl apply -f simpleservice.yaml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `kubectl replace` to replace a deployment from a manifest file—​for example,
    `kubectl replace -f simpleservice.yaml`. Note that unlike with `apply`, to use
    `replace`, the deployment must already exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `kubectl patch` to update a specific key—​for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What if you make a mistake or experience issues with the new version of the
    deployment? Luckily, Kubernetes makes it really easy to roll back to a known good
    state using the `kubectl rollout undo` command. For example, suppose the last
    edit was a mistake and you want to roll back to revision 2\. You can do this with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can then verify that the port definition has been removed with `kubectl
    get deploy/myapp -o yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The rollout of a deployment is triggered only if parts of the pod template (that
    is, keys below `.spec.template`) are changed, such as environment variables, ports,
    or the container image. Changes to aspects of the deployments, such as the replica
    count, do not trigger a new deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Running a Batch Job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run a process that runs for a certain time to completion, such as
    a batch conversion, backup operation, or database schema upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a Kubernetes [`Job`](https://oreil.ly/1whb2) to launch and supervise the
    pod(s) that will carry out the batch process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the Kubernetes manifest for the job in a file called *counter-batch-job.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then launch the job and take a look at its status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you want to verify that it actually carried out the task (counting
    from 1 to 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, as you can see, the `counter` job counted as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After a job has executed successfully, the pod that was created by the job
    will be in the *Completed* state. You can delete the job if you don’t need it
    anymore, which will clean up the pods it created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also temporarily suspend a job’s execution and resume it later. Suspending
    a job will also clean up the pods it created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To resume the job, simply flip the `suspend` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 4.8 Running a Task on a Schedule Within a Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run a task on a specific schedule within a pod managed by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Kubernetes `CronJob` objects. The `CronJob` object is a derivative of the
    more generic `Job` object (see [Recipe 4.7](#run_job)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can periodically schedule a job by writing a manifest similar to the one
    shown here. In the `spec`, you see a `schedule` section that follows the crontab
    format. You can also use some macros, such as `@hourly`, `@daily`, `@weekly`,
    `@monthly`, and `@yearly`. The `template` section describes the pod that will
    run and the command that will get executed (this one prints the current date and
    time every hour to `stdout`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like a job, a cron job can be also be suspended and resumed by flipping
    the `suspend` flag. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t need the cron job anymore, delete it to clean up the pods that
    it created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kubernetes `CronJob` documentation](https://oreil.ly/nrxxh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.9 Running Infrastructure Daemons per Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to launch an infrastructure daemon—​for example, a log collector or
    monitoring agent—​making sure that exactly one pod runs per node.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a `DaemonSet` to launch and supervise the daemon process. For example,
    to launch a Fluentd agent on each node in your cluster, create a file named *fluentd-daemonset.yaml*
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the `DaemonSet`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that in the preceding output, because the command is executed on Minikube,
    you see only one pod running as there’s only one node in this setup. If you had
    15 nodes in your cluster, you’d have 15 pods overall with 1 pod per node running.
    You can also restrict the daemon to certain nodes using the `nodeSelector` section
    in the `spec` of the `DaemonSet` manifest.
  prefs: []
  type: TYPE_NORMAL
