- en: Chapter 4\. Managing Services with systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you start your Linux computer, its initialization system launches
    a batch of processes, from a few dozen to hundreds, depending on how the system
    is set up. You can see this on your startup screen ([Figure 4-1](#fig-startup-messages);
    press the Escape key to hide your graphical startup screen and see the startup
    messages).
  prefs: []
  type: TYPE_NORMAL
- en: '![Linux startup messages](Images/lcb2_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Linux startup messages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In olden times we had the Unix System V initialization system (SysV init), BSD
    init, and Linux Standard Base (LSB) init for launching processes at startup. SysV
    init was the most common. Those days are fading away, and now systemd is the shiny
    new init system for Linux. It has been adopted by all the major Linux distributions,
    though of course there are a number of distributions that still use the legacy
    init systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn if your Linux distribution uses systemd. You
    will learn what processes, threads, services, and daemons are, and how to use
    systemd to manage services: start, stop, enable, disable, and check status. You
    will become acquainted with the *systemctl* command, which is the systemd system
    and service manager.'
  prefs: []
  type: TYPE_NORMAL
- en: systemd is designed to provide functionality suited to modern complex server
    and desktop systems, and it does considerably more than the legacy init systems.
    It provides complete service management from startup to shutdown, starting processes
    at boot, on-demand after boot, and shutting down services when they are not needed.
    It manages functions such as system logging, automounting filesystems, automatic
    service dependency resolution, name services, device management, network connection
    management, login management, and a host of other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds like a lot until you realize that processes do everything on a computer,
    and all of this functionality used to be provided by a large assortment of other
    programs. systemd brings it all together in an integrated software suite that
    should operate the same way on all Linux systems, though as always with Linux
    there are some minor exceptions, such as file locations and service names. Be
    aware that your particular Linux may have some differences from the examples in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: systemd attempts to decrease boot times and parcel out system resources more
    efficiently by starting processes concurrently and in parallel, and starting only
    necessary services, leaving other services to start after boot as needed. A service
    that is dependent on other services no longer has to wait to start for those services
    to become available because all it needs is a waiting Unix socket to become available.
    [Recipe 4.9](#rec-slow-startups) shows how to find processes that are slowing
    down your system startup.
  prefs: []
  type: TYPE_NORMAL
- en: systemd binaries are written in C, which provides some performance enhancement.
    The legacy inits are masses of shell scripts, and any compiled language operates
    faster than shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: systemd is backwards compatible with SysV init. Most Linux distributions retain
    the legacy SysV configuration files and scripts, including */etc/inittab* and
    the */etc/rc.d/* and */etc/init.d/* directories. When a service does not have
    a systemd configuration file, systemd looks for a SysV configuration file. systemd
    is also backward compatible with Linux Standard Base (LSB) init.
  prefs: []
  type: TYPE_NORMAL
- en: 'systemd service files are smaller and easier to understand than SysV init files.
    Compare a SysV init file for sshd with its systemd service file. This is a snippet
    of the sshd init file, */etc/init.d/ssh*, from MX Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This goes on for a total of 162 lines. This is a complete systemd service file
    from Ubuntu 20.04, */lib/systemd/system/ssh.service*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Even without reading the documentation, or knowing anything about systemd, you
    can understand some of what this file is supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: See [Rethinking PID 1](https://oreil.ly/dFz4K) for a detailed introduction to
    systemd by one of its inventors and maintainers, Lennart Poettering. Rethinking
    PID 1 details the rationale behind building a new init system, its architecture,
    advantages, and how it uses existing Linux kernel features in place of duplicating
    existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Learning if Your Linux Uses systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know if your Linux distribution uses systemd or something else.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look for the */run/systemd/system/* directory. If this exists, then your init
    system is systemd.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The */run/systemd/* directory may be present on your system if your distribution
    supports multiple init systems. But systemd is not the active init unless you
    see */run/systemd/system/*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other ways to learn which init system your system is using.
    Try querying */sbin/init*. Originally this was the SysV executable, and now most
    Linux distributions preserve the name and symlink it to the systemd executable.
    This example confirms that the init is systemd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On a system using SysV init, it has no symlink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The */proc* pseudofilesystem is an interface to your Linux kernel, and contains
    the current state of a running system. It is called a pseudofilesystem because
    it exists only in memory and not on disk. In this example, */proc/1/exe* is symlinked
    to the systemd executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On a SysV system, it links to *init*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The */proc/1/comm* file reports your active init system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On a SysV system, it reports *init*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The command attached to process ID (PID) 1 is your init. PID 1 is the first
    process launched at startup, which then starts all other processes. You can see
    this with the *ps* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the init is SysV, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See [Recipe 4.2](#rec-pid-1) for more information on PID 1.
  prefs: []
  type: TYPE_NORMAL
- en: Linux support for systemd varies. Most of the major Linux distributions have
    adoped systemd, including Fedora, Red Hat, CentOS, openSUSE, SUSE Linux Enterprise,
    Debian, Ubuntu, Linux Mint, Arch, Manjaro, Elementary, and Mageia Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Some popular distributions that do not support systemd, or include it but not
    as the default init, are Slackware, PCLinuxOS, Gentoo Linux, MX Linux, and antiX.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Distrowatch](https://distrowatch.com) for information on hundreds of Linux
    distributions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 proc*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 pstree*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.2 Understanding PID 1, the Mother of All Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a better understanding of services and processes on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PID 1 is the mother of all processes on Linux systems. This is the first process
    to start, and then it launches all other processes.
  prefs: []
  type: TYPE_NORMAL
- en: Processes are one or more running instances of a program. Every task in a Linux
    system is performed by a process. Processes can create independent copies of themselves,
    that is, they can *fork*. The forked copies are called *children*, and the original
    is the *parent*. Each child has its own unique PID, and its own allocation of
    system resources, such as CPU and memory. *Threads* are lightweight processes
    that run in parallel and share system resources with their parents.
  prefs: []
  type: TYPE_NORMAL
- en: Some processes run in the background and do not interact with users. Linux calls
    these processes *services* or *daemons*, and their names tend to end with the
    letter D, such as httpd, sshd, and systemd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Linux system starts PID 1 first, which then launches all other processes.
    Use the *ps* command to list all running processes in PID order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The *pstree* command organizes this mass of information into a tree diagram.
    This example shows all processes, their child processes, PIDs, and threads, which
    are enclosed in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The full *pstree* output is quite large. You can view a single process, identified
    by its PID, and its parents, children, and threads, like the following example
    for the Kate text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This shows that `systemd(1)` is Kate’s parent, `bash(5218)` is Kate’s child,
    and all the processes in curly braces are Kate’s threads.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Processes always exist in one of several states, and these states change according
    to system activity. The following *pstree* example displays the PID, user, state,
    and command fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*R* is either currently running or waiting in the run queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* means the process is multithreaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S* is interruptable sleep; the process is waiting for an event to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*s* is a session leader. Sessions are related processes managed as a unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I* is an idle kernel thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<* means high priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N* is low priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several rarely used states you can read about in *man 1 ps*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 4.7](#rec-kill-processes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 proc*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 pstree*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.3 Listing Services and Their States with systemctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You want to list all services installed on your system, and you want to know
    the states of the services: whether they are running, not running, or in an error
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*systemctl*, the systemd manager command, tells all. Run it with no options
    to see a detailed list of all loaded units. A systemd unit is any related batch
    of processes defined in a unit configuration file and managed by systemd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints a giant pile of information: 177 active loaded units on my test
    system with the full unit names, status, and long descriptions. Redirect the the
    output to a text file for easier study:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Treat yourself to more information overload by listing all units, active and
    inactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in 349 loaded units listed on my test system, including *not-found*
    and *inactive* units. How many total unit files? The following example shows 5
    out of 322:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are interested in service files because Linux users and administrators interact
    mainly with service files and rarely need to bother with any other type of unit
    file. How many are installed? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example displays the four most common states that a service can
    be in: enabled, disabled, static, or masked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'List only enabled services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'List only disabled services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'List only static services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'List only masked services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service unit files are in */usr/lib/systemd/system/* or */lib/systemd/system/*,
    according to where your Linux distribution puts them. These are plain-text files
    you can read.
  prefs: []
  type: TYPE_NORMAL
- en: enabled
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the service has become available and is managed by systemd.
    When a service is enabled, systemd creates a symlink in */etc/systemd/system/*
    from the unit file in */lib/systemd/system/*. It can be started, stopped, reloaded,
    and disabled by the user with the *systemctl* command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Enabling a service does not immediately start it, and disabling a service does
    not immediately stop it (see [Recipe 4.6](#rec-enable-services)).
  prefs: []
  type: TYPE_NORMAL
- en: disabled
  prefs: []
  type: TYPE_NORMAL
- en: Diabled means that there is no symlink in */etc/systemd/system/*, and it will
    not start automatically at boot. You can stop and start it manually.
  prefs: []
  type: TYPE_NORMAL
- en: masked
  prefs: []
  type: TYPE_NORMAL
- en: This means the service is linked to */dev/null/*. It is completely disabled
    and cannot be started by any means.
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: This means that the unit file is a dependency of other unit files, and cannot
    be started or stopped by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some less-common service states you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: indirect
  prefs: []
  type: TYPE_NORMAL
- en: Indirect states belong to services that are not meant to be managed by users,
    but are meant to be used by other services.
  prefs: []
  type: TYPE_NORMAL
- en: generated
  prefs: []
  type: TYPE_NORMAL
- en: Generated states indicate that the service has been converted from a nonnative
    systemd initialization configuration file, either SysV or LSB init.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 systemctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.4 Querying the Status of Selected Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the status of one service or a few specific services.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*systemctl status* provides a nice little bundle of useful status information.
    The following example queries the CUPS service. CUPS, the Common Unix Printing
    System, should be on all Linux systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Query multiple services with a space-delimited list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot of useful information in this little bit of output ([Figure 4-2](#fig-startup-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![systemctl status output for the CUPS printer service.](Images/lcb2_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. systemctl status output for the CUPS printer service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The dot next to the service name is a quick status indicator. It appears in
    colors on most terminals. White is an *inactive* or *deactivating* state. Red
    is a *failed* or *error* state. Green indicates an *active*, *reloading*, or *activating*
    state. The rest of the information in the output is described in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Loaded
  prefs: []
  type: TYPE_NORMAL
- en: 'Verifies that the unit file has been loaded into memory, displays its full
    path, the service is enabled (see the Discussion about states in [Recipe 4.3](#rec-list-services)),
    and `vendor preset: disabled/enabled` indicates if the installation default is
    to start at boot or not. When it is disabled, the vendor default is to not start
    at boot. This only shows the vendor preference and does not indicate if it is
    currently enabled or disabled.'
  prefs: []
  type: TYPE_NORMAL
- en: Active
  prefs: []
  type: TYPE_NORMAL
- en: Tells you if the service is active or inactive, and how long it has been in
    that state.
  prefs: []
  type: TYPE_NORMAL
- en: Process
  prefs: []
  type: TYPE_NORMAL
- en: Reports the PIDs and their commands and daemons.
  prefs: []
  type: TYPE_NORMAL
- en: Main PID
  prefs: []
  type: TYPE_NORMAL
- en: This is the process number for the cgroup slice.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs: []
  type: TYPE_NORMAL
- en: Reports how many tasks the service has started. Tasks are PIDs.
  prefs: []
  type: TYPE_NORMAL
- en: CGroup
  prefs: []
  type: TYPE_NORMAL
- en: Shows which unit slice the service belongs to and its PID. The three default
    unit slices are *user.slice*, *system.slice*, and *machine.slice*.
  prefs: []
  type: TYPE_NORMAL
- en: Linux control groups (cgroups) are sets of related processes and all of their
    future children. In systemd, a *slice* is a subdivision of a cgroup, and each
    slice manages a particular group of processes. Run *systemctl status* to see a
    diagram of the cgroup hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: By default, service and scope units are grouped in */lib/systemd/system/system.slice*.
  prefs: []
  type: TYPE_NORMAL
- en: User sessions are grouped in */lib/systemd/system/user.slice*.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines and containers registered with systemd are grouped in */lib/systemd/system/machine.slice*.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining lines are the most recent log entries from *journalctl*, the systemd
    log manager.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 systemctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 systemd.slice*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 journalctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kernel cgroups documentation](https://oreil.ly/FfUb3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.5 Starting and Stopping Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to stop and start services with systemd.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a job for *systemctl*. The following examples use the SSH service to
    demonstrate service management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop and then restart a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the service’s configuration. For example, you made a change to *sshd_config*
    and want to load the new configuration without restarting the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of these commands also work with multiple services, space-delimited, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re curious about the commands that systemd runs behind the scenes to
    start, reload, or stop the individual daemons, look in their unit files. Some
    services have start, reload, stop, and other instructions in their unit files,
    like this example for httpd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to do anything special with this information; it is there when
    you want to know how *systemctl* is managing a particular service.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 4.6](#rec-enable-services)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 systemctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.6 Enabling and Disabling Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a service or services to automatically start at boot, or you want to
    prevent a service from starting at boot, or to disable it completely.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling a service configures it to automatically start at boot.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling a service stops it from starting at boot, but it can be started and
    stopped manually.
  prefs: []
  type: TYPE_NORMAL
- en: Masking a service disables it so that it cannot be started at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example enables the *sshd* service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that enabling a service means creating a symlink from the
    service file in */lib/systemd/system/* to */etc/systemd/system/*. This does not
    start the service. You can start the service with *systemctl start*, or enable
    and start the service in one command with the *--now* option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This command disables the *sshd* service. It does not stop the service, so
    you must stop it manually after disabling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, disable and stop it with one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This command reenables the *mariadb* service, which disables and then enables
    it. If you have created the symlinks manually for a service, this is useful for
    quickly resetting them to the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command disables the *bluetooth* service completely by masking
    it, so that it cannot be started at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Unmasking the *bluetooth* service does not enable it, so it must be started
    manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you enable, disable, mask, or unmask a service, it remains in its current
    state unless you use the *--now* option. The *--now* option works with *enable*,
    *disable*, and *mask* to immediately stop or start the service, but it does not
    work with *unmask*.
  prefs: []
  type: TYPE_NORMAL
- en: See the Discussion in [Recipe 4.3](#rec-list-services) to learn more about how
    systemd uses symlinks to manage services.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 systemctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Discussion in [Recipe 4.3](#rec-list-services) to learn how systemd uses
    symlinks to manage services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.7 Stopping Troublesome Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know how to stop troublesome processes. A certain service may be
    unresponsive or running away, spawning forks and causing your system to hang.
    Your normal stop command is not working. What do you do?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stopping a process is called killing the process. On Linux systems with systemd,
    you should use *systemctl kill*. On systems without systemd, use the legacy *kill*
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '*systemctl kill* is preferable because it stops all processes that belong to
    a service and leaves no orphan processes, nor any processes that might restart
    the service and continue to make trouble. First, try it with no options other
    than the service name, then check the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The service has cleanly stopped. If this does not work, then try the nuclear
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The legacy *kill* command does not recognize service or command names, but
    rather requires the PID of the offending process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If this does not stop it, use the nuclear option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *top* command to identify runaway processes. Run it with no options,
    and the processes using up the most CPU resources are listed at the top. Press
    the q key to exit *top*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*kill* sends signals to processes, and the default signal is SIGTERM (signal
    terminate). SIGTERM is gentle, allowing processes to shut down cleanly. SIGTERM
    is also ignorable, and processes don’t have to pay attention to it. Signals can
    be identified by name or number; for most folks the numbers are easier to remember,
    so spelling out the default looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*kill -9* is SIGKILL. SIGKILL stops processes immediately and uncleanly, and
    also attempts to stop all child processes.'
  prefs: []
  type: TYPE_NORMAL
- en: Killing services with *systemctl kill* is easier than with *kill*, and more
    reliable. You only need the service name, and you don’t have to hunt down PIDs.
    It ensures that all processes belonging to the service are stopped, which *kill*
    cannot ensure.
  prefs: []
  type: TYPE_NORMAL
- en: There are a ton of signals that have accumulated over the years, and you can
    read all about them in *man 7 signal*. In my experience, the most relevant signals
    are SIGTERM and SIGKILL, but don’t let that stop you from learning more about
    the others.
  prefs: []
  type: TYPE_NORMAL
- en: If you are uncomfortable with terminology like kill, parents, children, and
    orphans, so am I. Maybe someday it will change.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 5 systemd.kill*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 systemctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 kill*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 7 signal*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.8 Managing Runlevels with systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to reboot to different system states in a manner similar to using SysV
    runlevels.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: systemd *targets* are similar to SysV runlevels. These are boot profiles that
    start your system with different options, such as multiuser mode with a graphical
    desktop, multiuser mode with no graphical desktop, and emergency and rescue modes
    to use when your current target will not boot. (See the Discussion for more information
    on runlevels.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command checks if the system is running and reports its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What is the default target?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the current runlevel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Reboot to rescue mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Reboot to emergency mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Reboot to the default mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Reboot to a different target without changing the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a different default runlevel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'List the runlevel target files and their symlinks on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'List the dependencies in a runlevel target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SysV runlevels are different states that your system can boot to, for example,
    with a graphical desktop, without a graphical desktop, and with emergency runlevels
    to use when your default runlevel has problems and will not boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'systemd *targets* approximately correspond to the legacy SysV runlevels:'
  prefs: []
  type: TYPE_NORMAL
- en: '*runlevel0.target*, *poweroff.target*, halt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*runlevel1.target*, *rescue.target*, single-user text mode, all local filesystems
    mounted, root user only, no networking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*runlevel3.target*, *multi-user.target*, multiuser text mode (no graphical
    environment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*runlevel5.target*, *graphical.target*, multiuser graphical mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*runlevel6.target*, *reboot.target*, reboot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*systemctl emergency* is a special target that is more restricted than *rescue*
    mode: no services, no mount points other than the root filesystem, no networking,
    root user only. It is the most minimal running system for debugging problems.
    You may see options to boot into a rescue or emergency mode in your GRUB2 bootloader
    screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '*systemctl is-system-running* reports various system states:'
  prefs: []
  type: TYPE_NORMAL
- en: '*initializing* means the system has not completed startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*starting* means the system is in the final stages of startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*running* is fully operational, and all processes are started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*degraded* means the system is operational, but one or more systemd units have
    failed. Run *systemctl | grep failed* to see which units failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*maintenance* means that either the *rescue* or *emergency* target is active.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*stopping* means that systemd is shutting down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*offline* means that systemd is not running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*unknown* means that there is a problem preventing systemd from determining
    the operational state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 systemctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 systemd-halt.service*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.9 Diagnosing Slow Startups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: systemd promises faster startups, but your system starts up slowly, and you
    want to find out why.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You want *systemd-analyze blame*. Run it with no options to see a list of system
    processes and how long they took to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Analyze only user processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is useful to review everything that starts at boot and perhaps find services
    you don’t want starting at boot. My favorite to disable is Bluetooth because I
    don’t use it on my servers or PCs, but many Linux distros enable it by default.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 systemd-analyze*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
