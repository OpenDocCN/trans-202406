- en: Chapter 5\. Managing Users and Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux has two types of users: human users and system users. Each user has a
    unique identity (UID), and at least one group identification (GID). All users
    have one primary group and may be members of multiple groups.'
  prefs: []
  type: TYPE_NORMAL
- en: Each human user owns a home directory for their personal files. User home directories
    belong in */home* and are named for the owner, like our example user Duchess,
    who owns */home/duchess*. Users may belong to multiple groups, and the additional
    group memberships are called *supplemental* groups. Users in a group have all
    the privileges of that group. (To learn all about privileges, see [Chapter 6](ch06.xhtml#cha-files-directories).)
    Privileges control access to files and commands, and are fundamental to system
    security.
  prefs: []
  type: TYPE_NORMAL
- en: System users represent system services and processes. System users need user
    accounts for controlling their privileges and do not have logins or directories
    in */home*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Human users are divided into two categories: the *root* user, or the superuser,
    is all-powerful and can do anything on the system. All other users are called
    normal or unprivileged users. Normal users are given just enough privileges to
    manage their own files and run commands that allow normal users to use them. Normal
    users can be given limited or complete root powers, which you will learn about
    in the recipes about *su* and *sudo*.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see all the users on your system in */etc/passwd*, and all the groups
    in */etc/group*.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized User Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*/etc/passwd* and */etc/group* are inherited from Unix and have not changed
    much since they were ported to Linux in 1992\. Since then, newer tools have evolved
    to manage users and groups, such as centralized databases that serve entire organizations.
    This chapter does not cover centralized user management tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux comes with a number of commands for managing users and groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '*useradd* creates new users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*groupadd* creates new groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*userdel* deletes users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*groupdel* deletes groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*usermod* is for making changes to existing users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*passwd* creates and changes passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are part of the *Shadow Password Suite*, and */etc/login.defs* is its
    main configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '*useradd* behaves differently on different systems, according to how it is
    configured. Traditionally, it lumped all new users into the same primary group,
    *users* (100). This meant that users had to be careful with permissions on their
    files to avoid exposing them to other group users. Red Hat changed this with its
    *User Private Group* scheme, which creates a personal private group for each new
    user. Most Linux distributions make this the default, though there are exceptions,
    such as openSUSE.'
  prefs: []
  type: TYPE_NORMAL
- en: The Shadow Password Suite was created by Julianne Frances Haugh way back in
    the 1980s, back before Linux was born, to improve Unix password security and to
    make user account management easier. It was ported to Linux in 1992, when Linux
    was barely a year old.
  prefs: []
  type: TYPE_NORMAL
- en: Before the Shadow Password Suite, all the relevant files had to be edited individually,
    there were multiple password management commands, and hashed passwords were stored
    in */etc/passwd* and */etc/group*. These two files must be world readable, so
    storing passwords in them, even when they’re hashed, is asking for trouble. Anyone
    can copy a world-readable file, and then crack the passwords at their leisure.
    Relocating the hashed passwords to the shadow files, */etc/shadow* and */etc/gshadow*,
    which are accessible only by root, added a strong layer of protection. The longevity
    of the Shadow Password Suite is a testament to how well it was designed and coded.
  prefs: []
  type: TYPE_NORMAL
- en: Newer arrivals are *adduser* and *addgroup* for Debian. They are Perl script
    wrappers for *useradd* and *groupadd*. These scripts walk you through a complete
    new user and new group configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create and remove human and system users,
    manage passwords, find UIDs and GIDs, set your desired defaults for creating new
    users, change group memberships, customize the common files your new users need,
    clean up after users that you have removed, become root, and grant limited root
    powers to normal users.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Finding a User’s UID and GID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to list users’ UIDs and GIDs.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *id* command with no options to see your own UID and GIDs. In the following
    example, the user is Duchess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Display another user’s UID and GIDs by providing their username as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Display your effective ID. This is your ID when you run a command as another
    user. You can see this with *sudo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three types of user IDs in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: Real UID/GID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective UID/GID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saved UID/GID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *real ID* is the UID and primary GID assigned to the user at creation. These
    are what you see when you run the *id* command, as yourself, with no options.
  prefs: []
  type: TYPE_NORMAL
- en: The *effective ID* is the UID used to run a process that requires different
    privileges than the user who launched the process, for example, the *passwd* command.
    *passwd* requires root privileges but uses the special permission modes to allow
    users to change their own passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this for yourself. First, take a look at the *passwd* command’s
    permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This shows that *passwd* is owned by root, both UID and GID. Now type the *passwd*
    command and press Enter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a second terminal to find the process for *passwd*, then print its process
    ID, effective ID, and real ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Even though an unprivileged user is running *passwd*, it runs with root permissions.
    (See [Recipe 6.11](ch06.xhtml#rec-sticky-symbolic) for information on the special
    permission modes.)
  prefs: []
  type: TYPE_NORMAL
- en: The *saved ID* is used by processes that need elevated privileges, usually root
    privileges. When a process needs to do work that requires fewer privileges, it
    can temporarily switch to a nonprivileged user ID. The effective UID is changed
    to the lower privilege value, and the original effective UID is saved to the SUID,
    saved user ID. When the process needs elevated privileges again, it changes to
    the SUID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *id* command has a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: '*-u* shows the effective UID number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-g* shows the effective GID number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-G* shows all group IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-n* prints the name rather than the number. You can use this in combination
    with *-u*, *-g*, and *-G*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-un* shows the effective UID username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-gn* shows the effective group name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-Gn* shows all effective GID names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-r* shows the real ID instead of the effective ID. You can use this in combination
    with *-u*, *-g*, and *-G*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 6.11](ch06.xhtml#rec-sticky-symbolic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 id*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2 Creating a Human User with useradd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a new user with a user private group and home directory populated
    with a set of default files like *.bashrc*, *.profile*, *.bash_history*, and any
    other files you want them to have.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *useradd* command is included in most Linux distributions and is configurable
    to suit your requirements. The default configuration varies across the various
    Linux distributions, so the quickest way to learn how your system is set up is
    to create a new test user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the *id* command, and then see if *useradd* created a home directory.
    The following examples are from Fedora 34:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the default configuration meets all the requirements listed
    in the Problem. Now you only need to set a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You may elect to force the user to reset their password at first login, after
    creating the user’s password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the login to your user, and they can start using their new account. The
    new user account is represented like this in */etc/passwd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Linuxes, for example openSUSE, configure *useradd* to not create the user’s
    home directory by default and to put all users into the *users (100)* group. This
    potentially exposes files to other users, if group permissions on the files allow
    it. The following example creates a user private group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*-m* creates the user’s home directory, and *-U* creates their private group
    with the same name as their username.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All new user accounts are inactive until you set a password.
  prefs: []
  type: TYPE_NORMAL
- en: The first group created for a user, whether it is a user private group or a
    common group for all users, is their *primary* group. All other groups the user
    is assigned to are *supplementary* groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some additional useful options:'
  prefs: []
  type: TYPE_NORMAL
- en: '*-G*, *--groups* is for adding the user to multiple supplemental groups in
    a comma-delimited list. The groups must already exist:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*-c*, *--comment* accepts any text string. Use this for the user’s full name,
    or any comment or description:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The four commas define five fields: full name, room number, work phone, home
    phone, and other. Way back in olden times this was called the GECOS data. GECOS
    is short for General Electric Comprehensive Operating Supervisor, a mainframe
    operating system. You may enter any text string in these fields, or nothing, though
    it is useful to include the user’s full name. Study your */etc/passwd* file to
    see how other entries use the GECOS fields.'
  prefs: []
  type: TYPE_NORMAL
- en: The *useradd* defaults are scattered across multiple configuration files; see
    [Recipe 5.4](#rec-change-useradd-defaults) to learn how to change the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 useradd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 login.defs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/default/useradd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/skel*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/login/defs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.3 Creating a System User with useradd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a system user with the *useradd* command.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example creates a new system user with no home directory, no
    login shell, and uses the correct UID numbering range for system users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*-r* means create a system user with a real ID in the correct numerical range
    for system users, and *-s* specifies the login shell. */bin/false* is a command
    that does nothing and prevents the user from logging into the system.'
  prefs: []
  type: TYPE_NORMAL
- en: See the Discussion in [Recipe 5.6](#rec-uid-gid-numbering) for information about
    UID and GID numbering.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In olden times, most services ran as the *nobody* user. Now it is a common practice
    for services to have their own unique users, as this provides stronger security
    than the *nobody* user owning multiple services. You will rarely have to create
    a system user, as services should create their own unique users when they are
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: The *nobody* user is always assigned UID 65534 and GID 65534.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 useradd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 false*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Discussion in [Recipe 5.6](#rec-uid-gid-numbering)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.4 Changing the useradd Default Settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default *useradd* settings are not right for you, and you want to change
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *useradd* configuration is spread across multiple configuration files:
    */etc/default/useradd*, */etc/login.defs*, and files in the */etc/skel* directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following values appear in */etc/default/useradd*. This example shows the
    openSUSE defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*GROUP=100* sets a single shared group as the default for all new users, traditionally
    *100*. The group must first exist, and *USERGROUPS_ENAB no* must be set in */etc/login.defs*.
    Then set *GROUP=* in */etc/default/useradd* to the GID of the user group. If our
    Duchess user is in a shared group, her *id* output shows *uid=1000(duchess) gid=100(users)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Enable private user groups by setting *USERGROUPS_ENAB yes* in */etc/login.defs*,
    then comment out *GROUP=* in */etc/default/useradd*. This creates a nonshared
    private group for each user. If our Duchess user has her own private group, her
    *id* output shows *uid=1000(duchess) gid=1000(duchess)*.
  prefs: []
  type: TYPE_NORMAL
- en: HOME=
  prefs: []
  type: TYPE_NORMAL
- en: sets the default directory for all user home directories. The default is */home*.
  prefs: []
  type: TYPE_NORMAL
- en: INACTIVE=-1
  prefs: []
  type: TYPE_NORMAL
- en: sets the number of days after a password expires until the account is locked.
    A value of 0 disables the account as soon as the password expires, and a value
    of –1 disables locking the account.
  prefs: []
  type: TYPE_NORMAL
- en: EXPIRE=
  prefs: []
  type: TYPE_NORMAL
- en: sets an expiration date on the account, in YYYY-MM-DD format. For example, if
    you set it to 2021-12-31, the account will be disabled on that date. Leaving *EXPIRE=*
    empty means the account will not expire.
  prefs: []
  type: TYPE_NORMAL
- en: SHELL=/bin/bash
  prefs: []
  type: TYPE_NORMAL
- en: sets the default command shell. */bin/bash* is the most commonly used Linux
    shell. Other values are any installed shell on the user’s system, such as */bin/zsh*
    or */usr/bin/tcsh*. *cat /etc/shells* lists all installed shells.
  prefs: []
  type: TYPE_NORMAL
- en: SKEL=/etc/skel
  prefs: []
  type: TYPE_NORMAL
- en: sets the location for the files that you want automatically distributed to new
    users. Most Linuxes put them in */etc/skel*. These are files such as *.bash_logout*,
    *.bash_profile* or *.profile*, *.bashrc*, and any other files you want new users
    to have. You may edit these files to suit your own requirements. *SKEL* is short
    for skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: CREATE_MAIL_SPOOL=yes
  prefs: []
  type: TYPE_NORMAL
- en: is a relic of olden times, and should be set to *yes*, as there may be some
    legacy processes that still need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following values in */etc/login.defs* are relevant to user creation defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '*USERGROUPS_ENAB yes* enables private user groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CREATE_HOME yes* configures *useradd* to automatically create private user
    home directories. This does not apply to system users (see [Recipe 5.3](#rec-create-system-user)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UID numbering range is defined in */etc/login.defs*. Every UID must be unique,
    so the user account creation commands assign UIDs from the range defined in this
    file. Typically, human UIDs start at 1000, and are automatically assigned by *useradd*.
    You can override this with the *-u* option, but you must select an unused number
    that follows the configured numbering scheme (see the Discussion in [Recipe 5.6](#rec-uid-gid-numbering)).
  prefs: []
  type: TYPE_NORMAL
- en: A mandatory password change at first login is a simple precaution against the
    original password possibly falling into the wrong hands as it passes from the
    administrator to the user.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 useradd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 login.defs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/default/useradd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/skel*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/login/defs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.5 Customizing the Documents, Music, Video, Pictures, and Downloads Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You followed [Recipe 5.2](#rec-create-user-useradd) to create a new user, now
    you want to customize the Documents, Music, Video, Pictures, and Downloads directories
    for new users.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating these directories is not a function of *useradd*, but rather the X
    Desktop Group (XDG) user directories tool. The Documents, Music, Video, etc.,
    directories are called the *well-known user directories*. These directories are
    set up from the */etc/xdg/user-dirs.defaults* configuration file, which establishes
    the default configuration for all users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These are name-value pairs. The names cannot be changed. The values are the
    directories that the names are mapped to, and they are relative to users’ home
    directories. For example, DOCUMENTS is mapped to */home/username/Documents*. The
    directories are created automatically for every new user when they start their
    graphical desktop environments for the first time. You may comment out any directories
    you wish to exclude or change the directories the names are mapped to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users may create their own personal configurations in *~/.config/user-dirs.dirs*.
    The directories must exist before applying the changes. The following example
    was created by our example user Duchess, who does not care for the boring default
    values. Note that the name-value pair syntax is different in *~/.config/user-dirs.dirs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When your changes are complete and the new directories have been created, use
    the *xdg-user-dirs-update* command to apply your changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Log out, then log back in, and you will see something like [Figure 5-1](#fig-thunar-xdg).
    XDG applies special icons to the well-known directories.
  prefs: []
  type: TYPE_NORMAL
- en: '![lcb2 0501](Images/lcb2_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Custom well-known directories
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The shortcuts in the side pane will not change, and the old directories are
    unchanged except they do not have the special icons. You will have to change the
    shortcuts and migrate the old directory contents manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore to the defaults in */etc/xdg/user-dirs.defaults* with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Log out and back in to see the changes. Again, none of your directories are
    removed or changed in any way, except for the special icons that mark the well-known
    user directories.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run the *xdg-user-dirs-update --set* command, you must use only the
    names as listed in *man 5 user-dirs.default*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the values, which are the target directories, are configurable. Target
    directories must be relative to users’ home directories. If you want to use directories
    outside of your home, create symlinks. For example, Duchess owns */users/stuff/duchess*
    and stores music files in it. The following example links this directory to */home/duchess/singendance*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 5 user-dirs.defaults*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 xdg-user-dirs-update*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 user-dirs.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[xdg-user-dirs at freedesktop](https://oreil.ly/FFDga)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.6 Creating User and System Groups with groupadd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create groups with *groupadd*.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example creates a new user group *musicians*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Use *groupadd* with the *-r* option to create a system group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'System groups differ from human user groups in the UID and GID numbering ranges
    assigned to them. This is configured in */etc/login.defs* for *groupadd* and *useradd*,
    as this example from Fedora 34 shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These define the number ranges available to the system administrator. All others
    are reserved for and managed by the system.
  prefs: []
  type: TYPE_NORMAL
- en: GID numbering is managed automatically by *groupadd*, according to the number
    ranges defined in */etc/login.defs* You may override this with the *-g* option,
    but your chosen GID must fall within the defined range, and must not already be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 groupadd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/login.defs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.7 Adding Users to Groups with usermod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to assign users to groups.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *usermod* command. The following example adds Duchess to the *musicians*
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This example adds Duchess to multiple groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you could edit */etc/group* and type Duchess’s name after the
    appropriate group or groups. When you list multiple group members, the list must
    be comma-delimited, with no spaces between the names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Be Careful to Append, Not Replace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you forget the *-a* option and use *-G* alone, all of the user’s existing
    groups will be removed and replaced with the new groups. This is especially damaging
    if this removes users from their *sudo* group.
  prefs: []
  type: TYPE_NORMAL
- en: When you change group memberships for logged-in users, users must log out and
    then log back in to activate the changes. There are various workarounds to activate
    a new group assignment without logging out, but they all have limitations, such
    as being limited to the current shell. Groups are enumerated at login, so the
    most reliable solution is to log out and log back in.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *-a* option means append, and *-G* is group or groups.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 usermod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.8 Creating Users with adduser on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are running Debian or a Debian-based Linux, and need to know how to create
    new users with *adduser*.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*adduser* walks you through a complete new user setup, like this example for
    Stash Cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Stash looks like this in */etc/passwd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *adduser* defaults are managed in */etc/adduser.conf*. This provides a
    number of useful defaults such as:'
  prefs: []
  type: TYPE_NORMAL
- en: DSHELL=
  prefs: []
  type: TYPE_NORMAL
- en: sets the default login shell. */bin/bash* is the most commonly used Linux shell.
    Other values are any installed shell on the user’s system, such as */bin/zsh*
    or */usr/bin/tcsh*. *cat /etc/shells* lists all installed shells.
  prefs: []
  type: TYPE_NORMAL
- en: USERGROUPS=yes
  prefs: []
  type: TYPE_NORMAL
- en: creates user private groups, *no* puts all users into the same group.
  prefs: []
  type: TYPE_NORMAL
- en: USERS_GID=100
  prefs: []
  type: TYPE_NORMAL
- en: is required when *USERGROUPS=no* is set.
  prefs: []
  type: TYPE_NORMAL
- en: EXTRA_GROUPS=
  prefs: []
  type: TYPE_NORMAL
- en: is your list of supplemental groups for new users, for example, *EXTRA_GROUPS="audio
    video plugdev libvirt"‍*.
  prefs: []
  type: TYPE_NORMAL
- en: ADD_EXTRA_GROUPS=1
  prefs: []
  type: TYPE_NORMAL
- en: makes the groups listed in *EXTRA_GROUPS=* the default for new users.
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/adduser.conf* contains the following user and group numbering scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Fedora Linux includes *adduser*, but it is not really *adduser*, just a symlink
    to *useradd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 5 adduser.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.9 Creating a System User with adduser on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a system user with *adduser* on your Ubuntu (or Debian, Mint,
    or other Debian derivative) system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example creates a new system user, *service1*, with *adduser*,
    without a home directory, and with its own unique primary group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks in */etc/passwd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System users do not have home directories.
  prefs: []
  type: TYPE_NORMAL
- en: Back in olden times, it was common for services to run as the *nobody* user
    and group, except Debian which uses *nobody* and *nogroup*. Recycling the same
    user for multiple services is a security weakness. It is unlikely you will ever
    have to create a system user, as the common practice now is for the package installer
    to create a unique user and group when you install a new service. But now you
    know how, just in case you ever need to.
  prefs: []
  type: TYPE_NORMAL
- en: '*nobody* and *nogroup* always have a real ID of 65534.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 adduser*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.10 Creating User and System Groups with addgroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know how to create user and system groups with Debian’s *addgroup*
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example creates a human user group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like this in */etc/group*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This example creates a new system group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difference between user and system groups is they each have different numbering
    ranges for UIDs and GIDs, which are configured in */etc/adduser.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 addgroup*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.11 Checking Password File Integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot going on in all these user files and group files, and you want
    to know if there is some kind of checker to verify that these files are written
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *pwck* command checks the integrity of */etc/passwd* and */etc/shadow*,
    and *grpck* checks */etc/group* and */etc/gshadow*. They look for correct format,
    valid data, valid names, and valid GIDs (see the man pages for a complete list).
    When you run these with no options, they report both warnings and errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the **`-q`** option to report only errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This shows an error in */etc/gshadow*. This is not a very helpful message because
    it’s not really an error. It is not a common practice to place passwords on user
    groups, so reporting this an as error is needlessly confusing. The other checks
    are useful, such as the correct number of fields, and a unique valid group name.
  prefs: []
  type: TYPE_NORMAL
- en: You will never edit */etc/shadow* or */etc/gshadow*, but only */etc/passwd*
    and */etc/group*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example shows an error that must be corrected. Type **`n`**,
    when prompted, to prevent deleting the entries. The first “delete line” example
    is from */etc/passwd*, and the second is in */etc/shadow*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Then correct the line in */etc/passwd*, and that will fix both error messages.
    In the example, *fakeservice:x:996:996::/home/fakeservice* is missing the last
    field, and should be *fakeservice:x:996:996::/home/fakeservice:/bin/false*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “directory does not exist” warnings for */etc/passwd* usually refer to
    default system users that are not in use. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The *www-data* user is unused when you are not running an HTTP server, and there
    is no */var/www* directory until you install an HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: The “no changes” message means that no changes were made to the password file.
  prefs: []
  type: TYPE_NORMAL
- en: See the man pages for a complete list of checks.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 pwck*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 grpck*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.12 Disabling a User Account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to disable a user account without deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To temporarily deactivate an account, disable the user’s password with the
    *passwd* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the user cannot log in. The following example unlocks the user’s account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This does not prevent a user from logging in via a different authentication
    method, such as an SSH key. To completely disable a user account, use *usermod*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user tries to log in, they see a “Your account has expired; please
    contact your system administrator” message. Restore their account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to disable a user is to replace the x in the password field in
    */etc/passwd* with an asterisk (*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Reenable Stash by replacing the asterisk with *x*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 passwd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.13 Deleting a User with userdel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to delete a user, and possibly their home directory and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example uses the *userdel* command to delete the user Stash from
    */etc/passwd*, Stash’s primary group and all group memberships, and the shadow
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If Stash belongs to a shared primary user group (discussed in [Recipe 5.4](#rec-change-useradd-defaults)),
    the group will not be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the *-r* option to delete the user’s home directory and its contents, and
    their mail spool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If the user owns files outside of their home directory, you will have to find
    and take care of them separately (see [Recipe 5.16](#rec-find-user-files)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read your */etc/passwd* and */etc/group* files before and after deleting a user
    to see the user disappear.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to clean up after removing a user.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man userdel*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.14 Deleting a User with deluser on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re running Ubuntu (or another Debian derivative) and want to use *deluser*
    to delete a user.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example deletes the user Stash from */etc/passwd*, Stash’s primary
    group from */etc/group*, and their corresponding shadow files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*deluser* will not remove the primary group of an existing user, so if Stash
    belongs to a shared primary group it will not be removed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example removes Stash’s home directory and makes a backup of all the deleted
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*--backup* creates a compressed archive of the user’s files in the current
    directory. Use the *--backup-to* option to select a different directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the user owns files outside of their home directory, you will have to hunt
    them down and deal with them manually (see [Recipe 5.16](#rec-find-user-files)).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 deluser*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.15 Removing a Group with delgroup on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have an Ubuntu system and want to use the *delgroup* command to delete groups.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example removes the *musicians* group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*delgroup* will not remove the primary group of an existing user. It will remove
    supplemental groups even when they have members. If you do not want to remove
    groups that have members, use the *--only-if-empty* option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default behavior of *delgroup* is configured in */etc/deluser.conf* and
    */etc/adduser.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 delgroup*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.16 Finding and Managing All Files for a User
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to delete a user, but you don’t want a bunch of orphaned files left
    over, and you need to find all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *find* command will locate all files on the local system by UID or GID.
    The following example searches the entire root directory for all files owned by
    the user’s UID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This can take some time if there are lot of files to search. If you are certain
    you do not have to search the entire filesystem, you can narrow your search to
    specific subdirectories, such as */etc*, */home*, or */var*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also search by GID, username, or group name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you know where all the files are, what to do with them? One option
    is to change their ownership to another user and let the new user deal with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You could combine *find* and *cp* to find and copy all the files to a different
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Using *cp -v* prints progress messages and copies only the files and not their
    parent directories. If you wish to copy the parent directories, use the *-r* option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Copying leaves the original files in place. After they are safely copied, you
    may wish to delete the originals. One way to do this is to run *find* again and
    use *rm* to delete the original files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This deletes the files but not the directories. Use the *-r* option to delete
    the directories if you are certain there are no other files in those directories
    that you want to keep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'One more option is to use *find* and *mv* to move the files to a different
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you see a “No such file or directory” message, usually that is because the
    file or directory was moved, which you can verify by looking in the directory
    they were moved to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find files owned by a nonexistent user or group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful with *mv* and *rm* because there is no undo. If you make a mistake,
    your best hope of recovery is from backup.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up after departed users can be a chore, because computers make it too
    easy to create as many files as your storage will hold. If you find yourself thinking
    that *find* is taking too long, keep in mind it will find everything while you
    go do something else.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 find*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 mv*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 cp*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 rm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.17 Using su to Be Root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know how to get root permissions to perform some administration
    chores.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *su* command to change to the root user when you need to do system
    chores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you do not know root’s password, or if there is no root password, see [Recipe
    5.21](#rec-root-password) to learn how to use *sudo* to set a root password.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are finished, exit root and return to your own account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The *-l* option invokes the root user’s environment, changing to root’s home
    directory and loading root’s environment variables. Omit *-l* to keep your own
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can change to any user, as long as you have their password.
  prefs: []
  type: TYPE_NORMAL
- en: Using *su* to change to root gives you absolute power over your system, and
    every command that you run is run as root. Consider using *sudo* (see [Recipe
    5.18](#rec-sudo)), which provides some safety features, such as protecting root’s
    password and leaving an audit trail.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 su*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.18 Granting Limited Root Powers with sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to delegate some system administration chores to other users, and you
    want to limit their root powers to what is needed for their specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *sudo* command. *sudo* is safer than *su* because it grants limited
    root powers to specific users for specific tasks, logs activity, and caches the
    user’s password for a limited amount of time, with a default of 15 minutes. After
    15 minutes, the user must provide *sudo* with their password again. The caching
    duration is configurable. *sudo* protects root’s password because *sudo* users
    use their own passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some Linux distributions, such as openSUSE, default to *sudo* asking for the
    root user’s password. See [Recipe 5.22](#rec-target-sudo-user) to learn how to
    change this.
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/sudoers* is the configuration file, and you should edit it with a special
    command, *visudo*. This opens */etc/sudoers* with your default text editor, and
    you can review and edit the default configuration. Once again, Duchess demonstrates
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '*%sudo ALL=(ALL) ALL* means that any user you add to the *sudo* group gets
    full *sudo* powers just like root. The percent sign indicates *%sudo* is a group
    from */etc/group*, and not a group configured in */etc/sudoers*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a junior admin, Stash, whose job is installing and removing
    software and keeping the system updated. You could create a system group for Stash.
    Or you could configure Stash for this task in */etc/sudoers*. The following example
    gives Stash *sudo* powers to run the listed commands. You need the username, the
    hostname of the local machine, and a comma-delimited list of allowed commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to give Stash more admin chores, such as managing services.
    The allowed commands list will get long, so you could create some command aliases
    instead. The following example aliases the software management commands to SOFTWARE,
    and the service management commands to SYSTEMD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Stash’s configuration looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You may create user groups in */etc/sudoers* (not related to system groups
    in */etc/group*), then assign them some command aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You may create a *Host_Alias* to give a user *sudo* rights on multiple machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then bring in the JRADMINs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When your limited *sudo* users try to run a not-allowed command, they see this
    message: “Sorry, user *duchess* is not allowed to execute `*/some/command*` as
    root on *server2*.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t put too much faith in limiting users to a specific set of commands. Many
    everyday applications provide a means for privilege escalation via shell escape,
    and your users can gain full root powers. This example shows how it works with
    *awk*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'And just like that, Duchess has full root powers. The humble *less* command
    also provides a shell escape. Read a file with *less* that is large enough to
    require paging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Type **`!*sh*`**, then when the prompt changes, type **`whoami`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Type **`exit`** to return your normal shell.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, it is extremely difficult to keep track of the many applications
    that can provide a shell escape. *journalctl* records everything, should you wish
    to monitor your *sudo* users (see [Recipe 20.1](ch20.xhtml#rec-logfiles)).
  prefs: []
  type: TYPE_NORMAL
- en: In some Linuxes, such as Fedora, the *wheel* group is the default *sudo* group.
    Check your */etc/sudoers* file to see how your distribution configures this. You
    can also create your own *sudo* group, and name it whatever you want.
  prefs: []
  type: TYPE_NORMAL
- en: The */etc/sudoers* file controls users only on the local machine. Including
    other machines, like the SERVERS alias, allows you to share a single configuration
    file on multiple machines. *sudo* ignores any items, such as hosts or users, that
    are not present on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dissect *root ALL=(ALL) ALL* to understand what all those ALLs mean.
  prefs: []
  type: TYPE_NORMAL
- en: root
  prefs: []
  type: TYPE_NORMAL
- en: is in the user field, and this field holds any single user, user alias, or system
    group.
  prefs: []
  type: TYPE_NORMAL
- en: ALL=
  prefs: []
  type: TYPE_NORMAL
- en: is in the host field. ALL means any host anywhere, or you could use a host alias,
    or name a single host.
  prefs: []
  type: TYPE_NORMAL
- en: (ALL)
  prefs: []
  type: TYPE_NORMAL
- en: is in the optional users field. *(ALL)* means the user or users can run commands
    as any other user, or you can specify certain users.
  prefs: []
  type: TYPE_NORMAL
- en: ALL
  prefs: []
  type: TYPE_NORMAL
- en: in is the command field. *ALL* is unrestricted, or you can specify a list of
    allowed commands.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 sudo*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 sudoers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.19 Extending the sudo Password Timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On most Linux distributions, *sudo* caches passwords for a default interval
    of 15 minutes. Then after 15 minutes you have to enter your password again. You
    are tired of having to enter your password so often when you have a lot of work
    to do, and want to make the caching interval longer.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Change the caching interval in */etc/sudoers*. Open the file for editing with
    *visudo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then look for a *Defaults* line and set your new cache interval. The following
    example sets it to 60 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If you set it to 0, *sudo* asks for your password every time you use it.
  prefs: []
  type: TYPE_NORMAL
- en: If you set *timestamp_timeout* to a negative number, like *-1*, your password
    never expires.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *sudo* password caching is a useful protection against accidents, such as
    forgetting you are running as root or wandering away and allowing someone else
    to have some fun with your computer.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 sudo*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 sudoers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.20 Creating Individual sudoers Configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to set some different *sudo* configurations for your users; for example,
    you want your junior admins to have a different password timeout than you. Yours
    is long, and you want theirs to be short.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may create individual configurations in */etc/sudoers.d*. The following
    example creates a 30-minute password timeout for Stash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Type **`Defaults timestamp_timeout=30`**, save the file, and you’re done. You
    can see the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You only need to enter configuration items that are different from the entries
    in */etc/sudoers*, not to replicate the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a nice feature for managing multiple users. Instead of managing one
    big configuration file, break it up into smaller per-user files.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 sudo*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 sudoers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.21 Managing the Root User’s Password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your Linux distribution set you up as system administrator during installation,
    with unrestricted *sudo* privileges, and did not create a root password. Or, your
    root user had a password but you forgot it. You need to know how to give root
    a new password.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to run as “real” root, use *sudo* to *su* to root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: At this point you can use the *passwd* command to give root a password so you
    can log in as root directly, or reset a lost root password.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when you need a root password and not *sudo*; for example, when
    you boot to an emergency runlevel.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 sudo*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 sudoers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 passwd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.22 Changing sudo to Not Ask for the Root Password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You want your *sudo* users to authenticate with their own passwords, but your
    Linux system asks for the root user’s password, like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the default behavior on some Linux distributions, such as openSUSE.
  prefs: []
  type: TYPE_NORMAL
- en: When you install Ubuntu Linux and make your user an administrator during installation,
    Ubuntu configures your user appropriately with full *sudo* powers, equivalent
    to root but using your own password. openSUSE does not, but instead configures
    your user to use the password of the target user, which is root.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up *sudo* users to always be asked for their own passwords, edit */etc/sudoers*
    by commenting out these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In openSUSE and Fedora, create *sudo* users with full root powers by adding
    them to the *wheel* group in */etc/group*. (For limited users, refer to [Recipe
    5.18](#rec-sudo).)
  prefs: []
  type: TYPE_NORMAL
- en: The change takes effect immediately after saving your changes and closing the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protecting the root user’s password is a primary reason to use *sudo*, rather
    than *su*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 5.18](#rec-sudo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
