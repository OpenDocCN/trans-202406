- en: Chapter 12\. Web Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web components are a way to build new HTML elements with their own behavior.
    This behavior is encapsulated in a *custom element*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a web component by defining a class that extends `HTMLElement`,
    as shown in [Example 12-1](#example12-1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. A barebones web component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you add the custom element to the DOM, the browser calls the `connectedCallback`
    method. This is typically where most of your component’s logic resides. This is
    one of the *lifecycle callbacks*. Some other lifecycle callbacks include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`disconnectedCallback`'
  prefs: []
  type: TYPE_NORMAL
- en: Called when you remove the custom element from the DOM. This is a good place
    to do cleanup, such as removing event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: '`attributeChangedCallback`'
  prefs: []
  type: TYPE_NORMAL
- en: Called when you change one of the element’s watched attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a Custom Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve created your custom element class, you must register it with the
    browser before using it in an HTML document. You can register your custom element
    by calling `define` on the global `customElements` object, as shown in [Example 12-2](#example12-2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-2\. Registering a custom element with the browser
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you try to define a custom element that has already been defined, the browser
    throws an error. If this is a possibility for you, you can call `customElements.get('my-component')`
    in order to check if it’s already defined. If this returns `undefined`, it’s safe
    to call `customElements.define`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you register the element, you can use it like any other HTML element, as
    shown in [Example 12-3](#example12-3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-3\. Using the custom element
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Custom elements must always have a hyphenated name. This is required by the
    specification. They also must always have a closing tag, even if there is no child
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to get HTML markup into a web component. For example,
    in the `connectedCallback`, you can manually create elements by calling `document.createElement`
    and manually appending them.
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify a component’s markup with a `<template>` element. This
    contains some HTML that you’ll use during the `connectedCallback` to give your
    component its content. These templates are very simple—they don’t support data
    binding, variable interpolation, or any kind of logic. They only serve as a starting
    point of the HTML content. Within the `connectedCallback`, you can select elements,
    set dynamic values, and add event listeners as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `<slot>` is a special element you can use in a template. A slot is a placeholder
    for some child content that is passed in. A component can have a default slot
    as well as one or more *named* slots. You can use named slots to place multiple
    pieces of content inside your component.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 12-4](#example12-4) shows a simple template that has a named and default
    slot.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-4\. A template with slots
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Suppose this template is used in an `<author-bio>` component, as shown in [Example 12-5](#example12-5).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-5\. Specifying content for slots
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the component’s child content, you can specify a `slot` attribute that corresponds
    to a named slot in the component template. The `span` element containing the text
    “John Doe” will be placed in the component’s `name` slot, inside the `h2` element.
    Any other child content, without a `slot` element, is placed in the default slot
    (the one with no name).
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A shadow DOM is a collection of elements that are isolated from the rest of
    the main DOM. Web components use shadow DOM extensively. One main advantage of
    using shadow DOM is for scoped CSS styles. Any styles you define in a shadow DOM
    *only* apply to elements inside that shadow DOM. Other elements in the document,
    even if they’d normally match the selector of a CSS rule, do not have the CSS
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: This style scoping goes both ways. If you have global styles on your page, they
    will not apply to any of the elements in a shadow DOM.
  prefs: []
  type: TYPE_NORMAL
- en: A shadow DOM, created by attaching a *shadow root* to a web component, can be
    open or closed. When a shadow DOM is open, you can access and modify its elements
    with JavaScript. When it is closed, a web component’s `shadowRoot` property is
    `null` so you can’t access the content within.
  prefs: []
  type: TYPE_NORMAL
- en: Light DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using shadow DOM is completely optional, however. The *Light DOM* refers to
    the regular, non-encapsulated DOM inside the web component. Because Light DOM
    is not encapsulated from the rest of the page, global styles will be applied to
    its child elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Component to Show Today’s Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a web component that formats and shows today’s date in the browser’s
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Intl.DateTimeFormat` inside the web component to format the current date
    (see [Example 12-6](#example12-6)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-6\. A custom element that formats the current date
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you can show today’s date by using this web component without any attributes
    or child content, as shown in [Example 12-7](#example12-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-7\. Showing the current date
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a `<todays-date>` element enters the DOM, the browser calls the `connectedCallback`
    method. In the `connectedCallback`, the `TodaysDate` class formats the current
    date with an `Intl.DateTimeFormat` object, which you may remember from [Chapter 11](ch11.html#ch_i18n).
    The `connectedCallback` sets this formatted date string as the element’s `textContent`,
    which is inherited from `Node` (an ancestor of `HTMLElement`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Component to Format a Custom Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a web component that formats an arbitrary date value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give the web component a `date` attribute, and use this to generate the formatted
    date (see [Example 12-8](#example12-8)). You can watch this attribute for changes
    and reformat the date if the date attribute changes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-8\. A custom date component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can now pass a date to the `date` attribute to get it formatted in the user’s
    locale (see [Example 12-9](#example12-9)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-9\. Using the `date-formatter` element
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe expands on [“Creating a Component to Show Today’s Date”](#recipe_todaysDate)
    by adding the ability to specify your own date via an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: By default, if you change the value of an attribute passed to a custom element,
    nothing happens. The logic in `connectedCallback` only runs when you first add
    the component to the DOM. To make the component react to attribute changes, you
    can implement the `attributeChangedCallback` method. In the `date-formatter` component,
    this method takes the updated `date` attribute and create a new formatted date.
    When an attribute changes, the browser calls this method with the attribute name,
    the old value, and the new value.
  prefs: []
  type: TYPE_NORMAL
- en: However, this alone won’t solve the problem. If you just implement `attribute​Change⁠dCallback`,
    you still won’t be notified of attribute changes. This is because the browser
    only calls `attributeChangedCallback` for *observed* attributes. This lets you
    define a subset of attributes so the browser only calls `attributeChangedCallback`
    for those attributes you’re interested in. To define these attributes, add a static
    `observedAttributes` property to your component class. This should be an array
    of attribute names.
  prefs: []
  type: TYPE_NORMAL
- en: In the `date-formatter` component, you’re only watching one attribute (the `date`
    attribute). Because of this, in `attributeChangedCallback` you don’t need to check
    the `name` argument since you already know it’s the `date` attribute that changed.
    In a component with multiple watched attributes, you can check the `name` to find
    out which attribute has changed.
  prefs: []
  type: TYPE_NORMAL
- en: If you change the value of the `date` attribute with JavaScript, the `attributeChangedCallback`
    will run and update the formatted date.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Feedback Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a reusable component where a user can provide feedback about
    whether or not the page is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a web component to present the feedback buttons and dispatch a custom
    event when the user clicks on one.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create a template element to contain the markup that this
    component uses, as shown in [Example 12-10](#example12-10).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-10\. Creating the template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This component uses a shadow DOM that contains the template markup (see [Example 12-11](#example12-11)).
    The CSS style rules are scoped to this component only.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-11\. The component implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now you can add this feedback component to your app (see [Example 12-12](#example12-12)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-12\. Using the feedback-rating component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can listen for the custom `feedback` event to be notified when the user
    selects a feedback option (see [Example 12-13](#example12-13)). It’s up to you
    what to do with this information; maybe you want to send the data to an analytics
    endpoint with the Fetch API.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-13\. Listening for the feedback event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `feedback-rating` component presents a prompt and two buttons. The user
    clicks one of the two buttons depending on whether they think the website content
    is helpful or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `click` event listener uses event delegation. Instead of adding a listener
    to each button, it adds a single listen that responds to a click anywhere inside
    the feedback prompt. If the clicked element does not have a `data-helpful` attribute,
    then the user must not have clicked on a feedback button, so do nothing. Otherwise,
    it converts the string value to a boolean and sets it as a property on the custom
    element that can be retrieved later. It also dispatches an event that you can
    listen for elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this event to cross the shadow DOM into the regular DOM, you must
    set the `composed: true` option. Otherwise, any event listener that you added
    to the custom element won’t be triggered.'
  prefs: []
  type: TYPE_NORMAL
- en: Once that event is triggered, you can check the feedback element itself (available
    as the `event.target` property) for the `helpful` property to determine which
    feedback button the user clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Because the styles and markup are contained in a shadow DOM, the CSS rules do
    not affect any elements outside of the shadow DOM. This is important to note,
    as otherwise an element selector like `button` would style every button on the
    page. Because the styles are scoped, they are only applied to buttons inside the
    custom element.
  prefs: []
  type: TYPE_NORMAL
- en: However, the content passed to the component’s slots *can* be styled by global
    CSS rules. The slotted content does not move into the shadow DOM, but rather remains
    in the standard, or light, DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Profile Card Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a reusable card component to show a user profile.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use slots in your web component to pass content to certain regions.
  prefs: []
  type: TYPE_NORMAL
- en: First, define the template with some styles and markup, as shown in [Example 12-14](#example12-14).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-14\. The profile card template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This template has three named slots (photo, name, and title) and one default
    slot for the biography. The component implementation itself is rather minimal;
    it just creates and attaches a shadow root with the template (see [Example 12-15](#example12-15)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-15\. The component implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To use the component, you can specify the `slot` attribute on child elements
    to specify which slot the content should go into (see [Example 12-16](#example12-16)).
    The biography element, which does not have a `slot` attribute, is placed in the
    default slot.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-16\. Using the profile card
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-1](#img_profileCard) shows the rendered result of the profile card
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The rendered profile card](assets/wacb_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. The rendered profile card
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the CSS styles, you might have noticed the `:host` selector, which represents
    styles that are applied to the custom element’s *shadow host*. This is the element
    that the shadow DOM is attached to.
  prefs: []
  type: TYPE_NORMAL
- en: With this example, you can see how web components let you create reusable content
    and layouts. Slots are a powerful tool that enables you to insert content exactly
    where it’s needed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lazy Loading Image Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a reusable component that contains an image that isn’t loaded until
    it scrolls into the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use an `IntersectionObserver` to wait for the element to scroll into view, then
    set the `src` element on the contained image.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe adapts [“Lazy Loading an Image When Scrolled into View”](ch06.html#recipe_lazyImage)
    from [Chapter 6](ch06.html#ch_observers), presenting its solution inside a web
    component (see Examples [12-17](#example12-17) and [12-18](#example12-18)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-17\. The `LazyImage` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Example 12-18\. Using the `LazyImage` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the element scrolls into view, the `IntersectionObserver` callback gets
    the `src` attribute and sets it as the image’s `src` attribute, which triggers
    the image to load.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This example illustrates how to create a custom element that extends a built-in
    element, but for lazy loading images you may not need it. Newer browsers support
    the `loading="lazy"` attribute on `img` tags, which has the same effect—the image
    is not loaded until it scrolls into view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Disclosure Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to show or hide some content by clicking a button. For example, you
    may have an “Advanced” section of a form that is collapsed by default, but can
    be expanded by clicking a button.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Build a disclosure web component. The component has two parts: the button that
    toggles the content, and the content itself. Each of these two parts will have
    a slot. The default slot will be for the content, and there will be a named slot
    for the button. This component can also be expanded or collapsed programmatically
    by changing the value of its `open` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: First, define the template for the disclosure component, as shown in [Example 12-19](#example12-19).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-19\. The disclosure component template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The component implementation is shown in [Example 12-20](#example12-20).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-20\. The disclosure component implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: One last thing—you need to add a small bit of CSS to the page. Otherwise, the
    child content will flicker on the page for a moment, then disappear. This is because
    before the custom element is registered, it has no behavior, and the browser isn’t
    aware of its slots. This means that any child content will be rendered in the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Then, once the custom element is defined, the child content moves into the slot
    and disappears.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, you can use CSS to hide the element’s content until it is registered
    by using the `:defined` pseudo-class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-21\. Fixing the flicker issue
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will initially hide the content. Once the custom element becomes defined,
    the element is shown. You won’t see the flicker because the content has already
    been moved to the slot.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can use the disclosure element, as shown in [Example 12-22](#example12-22).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-22\. Using the disclosure element
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The toggle button will have the text “Details,” since that is placed in the
    `title` slot. The remaining content is placed in the default slot.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The disclosure component uses its `open` attribute to determine whether or not
    to show the child content. When the toggle button is clicked, it adds or removes
    the attribute depending on the current state, then conditionally applies the `hidden`
    attribute to the child content.
  prefs: []
  type: TYPE_NORMAL
- en: You can also programmatically toggle the child content by adding or removing
    the `open` attribute. This works because the component is observing the `open`
    attribute. If you change it with JavaScript, or even in the browser developer
    tools, the browser calls the component’s `attributeChangedCallback` method with
    the new value.
  prefs: []
  type: TYPE_NORMAL
- en: The `open` attribute does not have a value. If you want the content to be open
    by default, simply add the `open` attribute with no value, as shown in [Example 12-23](#code_showContentDefault).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-23\. Showing the content by default
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you remove the attribute, the `newValue` argument to `attributeChangedCallback`
    will be `null`. In that case, it will hide the child content by applying the `hidden`
    attribute. If you add the attribute with no value, as shown in [Example 12-23](#code_showContentDefault),
    the `newValue` argument will be an empty string. If that’s the case, it will remove
    the `hidden` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Styled Button Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a reusable button component with different style options.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There will be three variants of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: the default variant, with a gray background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the “primary” variant, with a blue background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the “danger” variant, with a red background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, create the template with the custom button styling, along with CSS classes
    for the “primary” and “danger” variants, as shown in [Example 12-24](#example12-24).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-24\. The button template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this template is the CSS. The actual markup for the component itself
    is quite simple: just a button element with a default slot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The component itself will support two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`variant`'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the button variant (`primary` or `danger`)
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` attribute that is passed into the underlying `button` element. Set
    this to `button` to prevent submitting a form (see [Example 12-25](#example12-25)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-25\. The button component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To add a click listener, you actually don’t have to do any further work. You
    can add a click listener to the `styled-button` element and it will be triggered
    when you click the underlying button, thanks to event delegation. With event delegation,
    you can add an event listener to a parent element, and events on its children
    will also trigger the parent’s event listener.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, here is how you use the `styled-button` component (see [Example 12-26](#example12-26)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-26\. Using the `styled-button` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The styling is applied by setting a class name on the button element equal to
    the variant name. This will cause the corresponding CSS rule to apply the desired
    background color.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to have any code in the `connectedCallback` to apply the class,
    because the browser will call the `attributeChangedCallback` with the initial
    values as well as any subsequently updated values.
  prefs: []
  type: TYPE_NORMAL
- en: You can add a click event listener to the `styled-button` in the same way as
    you would a normal button (see [Example 12-27](#example12-27)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-27\. Adding a click listener
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
