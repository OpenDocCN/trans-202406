- en: Chapter 6\. Applications, Package Management, and Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talk about applications in Linux. Sometimes, the term *application*
    (or simply *app*) is used interchangeably with *program*, *binary*, or *executable*.
    We’ll explain the differences between these terms and initially will be focusing
    on terminology, including the definition of applications and packages.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss how Linux starts up and brings all the services we depend on into
    being. This is also known as the *boot process*. We will focus on init systems,
    specifically on the de-facto standard, the `systemd` ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: We then move on to package management, where we first review the application
    supply chain in general terms and see what the different moving parts are about.
    Then, to give you some context about existing mechanisms and challenges, we focus
    on how apps were traditionally distributed and installed. We discuss package management
    in traditional Linux distros, from Red Hat to Debian-based systems, and also have
    a peek at programming language–specific package managers such as Python or Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next part of the chapter, we focus on containers: what they are and
    how they work. We’ll review the building blocks of containers, what tooling you
    have available, and good practices around using containers.'
  prefs: []
  type: TYPE_NORMAL
- en: To round off this chapter, we look at modern ways to manage Linux apps, especially
    in desktop environments. Most of those modern package manager solutions are also
    making use of containers in some form or another.
  prefs: []
  type: TYPE_NORMAL
- en: And now, without further ado, let’s see what an application is and what other
    related terms there are.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into the nitty-gritty details of application management, init
    systems, and containers, let’s start with relevant definitions for this chapter
    and beyond. The reason why we only now go into details concerning apps is that
    there are a number of prerequisites (such as the Linux kernel, shell, filesystems,
    and security aspects) that you need to fully understand apps, and now that we’re
    in a position to build on what we’ve learned so far, we can tackle apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Program
  prefs: []
  type: TYPE_NORMAL
- en: This is usually either a binary file or a shell script that Linux can load into
    memory and execute. Another way to refer to this entity is *executable*. The type
    of the executable determines what exactly takes care of running it—for example,
    a shell (see [“Shells”](ch03.xhtml#shells)) would interpret and execute a shell
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Process
  prefs: []
  type: TYPE_NORMAL
- en: A running entity based on a program, loaded into main memory and either using
    the CPU or I/O, when not sleeping. See also [“Process Management”](ch02.xhtml#kernel-process-management)
    and [Chapter 3](ch03.xhtml#shells-scripting).
  prefs: []
  type: TYPE_NORMAL
- en: Daemon
  prefs: []
  type: TYPE_NORMAL
- en: Short for *daemon process*, sometimes called *service*, this is a background
    process that provides a certain function to other processes. For example, a printer
    daemon allows you to print. There are also daemons for web services, logging,
    time, and many more utilities you rely on on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: Application
  prefs: []
  type: TYPE_NORMAL
- en: 'A program including its dependencies. Usually a substantial program, including
    a user interface. We usually associate the term *application* with the entire
    life cycle of a program, its configuration, and its data: from finding and installing
    to upgrading to removing it.'
  prefs: []
  type: TYPE_NORMAL
- en: Package
  prefs: []
  type: TYPE_NORMAL
- en: A file that contains programs and configurations; used to distribute software
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Package manager
  prefs: []
  type: TYPE_NORMAL
- en: A program that takes a package as an input and, based on its content and the
    user instruction, installs it, upgrades it, or removes it from a Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: Supply Chain
  prefs: []
  type: TYPE_NORMAL
- en: A collection of software producers and distributors that enable you to find
    and use applications based on packages; see [“Linux Application Supply Chains”](#supply-chain)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Booting
  prefs: []
  type: TYPE_NORMAL
- en: The startup sequence in Linux that involves hardware and operating system initialization
    steps, including loading the kernel and launching service (or daemon) programs
    with the goal to bring Linux into a state that it can be used; see [“The Linux
    Startup Process”](#linux-boot) for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with these high-level definitions, we quite literally start at the
    beginning: let’s have a look at how Linux starts up and how all the daemons get
    launched so that we can use Linux to do our work.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Startup Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux [boot process](https://oreil.ly/fbnk3) is typically a multiphase effort
    in which hardware and the kernel work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 6-1](#fig-boot-process), you can see the boot process end to end,
    with the following five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0601](Images/lmlx_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. The Linux startup process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In modern environments, the [Unified Extensible Firmware Interface](https://uefi.org)
    (UEFI) spec defines the boot configuration (stored in NVRAM) and the boot loader.
    In older systems, in this step, after the Power On Self Test (POST) is completed,
    the Basic I/O System (BIOS; see [“The BIOS and UEFI”](ch02.xhtml#def-bios)) would
    initialize hardware (managing I/O ports and interrupts) and hand over control
    to the boot loader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The boot loader has one goal: to bootstrap the kernel. Depending on the boot
    medium, the details may differ slightly. There are a range of boot loader options,
    both current (e.g., GRUB 2, systemd-boot, SYSLINUX, rEFInd) and legacy (e.g.,
    LILO, GRUB 1).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel is usually located in the */boot* directory in a compressed form.
    That means the first step is to extract and load the kernel into main memory.
    After the initialization of its subsystems, filesystems, and drivers (as discussed
    in [Chapter 2](ch02.xhtml#kernel) and [“Mounting filesystems”](ch05.xhtml#fs-mount)),
    the kernel hands over control to the init system, and with that the boot process
    proper ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The init system is responsible for launching daemons (service processes) system-wide.
    This init process is the root of the process hierarchy and with it has the process
    ID (PID) 1\. In other words, the process with PID 1 runs until you power off the
    system. Besides being responsible for launching other daemons, the PID 1 process
    traditionally also takes care of orphaned processes (processes that don’t have
    a parent process anymore).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Usually, some other user-space-level initialization takes place after this,
    depending on the environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is usually a terminal, environment, and shell initialization going on,
    as discussed in [Chapter 3](ch03.xhtml#shells-scripting).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Display manager, graphical server, and the like, for desktop environments with
    a GUI are launched, taking user preferences and configurations into account.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this high-level overview of the Linux startup process, we conclude our
    introductory section and focus on a vital, user-facing component: the init systems.
    This part (the preceding steps 4 and 5) is the most relevant for you, in the context
    of this book, allowing you to customize and extend your Linux installation.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a good [comparison of init systems](https://oreil.ly/Vn6pu) available
    via the Gentoo wiki. We’ll restrict our discussion to `systemd`, which almost
    all current Linux distributions are using.
  prefs: []
  type: TYPE_NORMAL
- en: systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[`systemd`](https://systemd.io) was initially an init system, a replacement
    for `initd`, but today it’s a powerful supervisor that includes functions such
    as logging, network configuration, and network time synchronization. It provides
    for a flexible, portable way to define daemons and their dependencies, and a uniform
    interface to control the configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all current Linux distributions are using `systemd`, including Fedora
    since May 2011, openSUSE since September 2012, CentOS since April 2014, RHEL since
    June 2014, SUSE Linux since October 2014, Debian since April 2015, and Ubuntu
    since April 2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, `systemd` addresses the shortcomings of previous init systems
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing a uniform way to manage startup across distros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a faster, more comprehensible service configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offering a modern management suite including monitoring, resource usage control
    (via cgroups), and built-in auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, `init` starts services at initialization time in sequence (that
    is, in alphanumeric order), while `systemd` can start any service that has had
    its dependencies met, potentially speeding up the startup time.
  prefs: []
  type: TYPE_NORMAL
- en: The way you tell `systemd` what to run, when to run, and how to run is via units.
  prefs: []
  type: TYPE_NORMAL
- en: Units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A unit in `systemd` is a logical grouping with different semantics depending
    on its function and/or the resource it targets. `systemd` distinguishes a number
    of units, depending on the target resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`service` units'
  prefs: []
  type: TYPE_NORMAL
- en: Describe how to manage a service or application
  prefs: []
  type: TYPE_NORMAL
- en: '`target` units'
  prefs: []
  type: TYPE_NORMAL
- en: Capture dependencies
  prefs: []
  type: TYPE_NORMAL
- en: '`mount` units'
  prefs: []
  type: TYPE_NORMAL
- en: Define a mountpoint
  prefs: []
  type: TYPE_NORMAL
- en: '`timer` units'
  prefs: []
  type: TYPE_NORMAL
- en: Define timers for cron jobs and the like
  prefs: []
  type: TYPE_NORMAL
- en: 'Other, less important unit types include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket`'
  prefs: []
  type: TYPE_NORMAL
- en: Describes a network or IPC socket
  prefs: []
  type: TYPE_NORMAL
- en: '`device`'
  prefs: []
  type: TYPE_NORMAL
- en: For `udev` or `sysfs` filesystems
  prefs: []
  type: TYPE_NORMAL
- en: '`automount`'
  prefs: []
  type: TYPE_NORMAL
- en: Configures automatic mountpoints
  prefs: []
  type: TYPE_NORMAL
- en: '`swap`'
  prefs: []
  type: TYPE_NORMAL
- en: Describes swap space
  prefs: []
  type: TYPE_NORMAL
- en: '`path`'
  prefs: []
  type: TYPE_NORMAL
- en: For path-based activation
  prefs: []
  type: TYPE_NORMAL
- en: '`snapshot`'
  prefs: []
  type: TYPE_NORMAL
- en: Allows for reconstructing the current state of the system after changes
  prefs: []
  type: TYPE_NORMAL
- en: '`slice`'
  prefs: []
  type: TYPE_NORMAL
- en: Associated with cgroups (see [“Linux cgroups”](#cgroups))
  prefs: []
  type: TYPE_NORMAL
- en: '`scope`'
  prefs: []
  type: TYPE_NORMAL
- en: Manages sets of system processes created externally
  prefs: []
  type: TYPE_NORMAL
- en: 'To be known to `systemd`, a unit needs to be serialized into a file. `systemd`
    looks for unit files in multiple locations. The three most important filepaths
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/lib/systemd/system*'
  prefs: []
  type: TYPE_NORMAL
- en: Package-installed units
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/systemd/system*'
  prefs: []
  type: TYPE_NORMAL
- en: System admin–configured units
  prefs: []
  type: TYPE_NORMAL
- en: '*/run/systemd/system*'
  prefs: []
  type: TYPE_NORMAL
- en: Nonpersistent runtime modifications
  prefs: []
  type: TYPE_NORMAL
- en: With the basic unit of work (no pun intended) in `systemd` defined, let’s move
    on to how you control it via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Management with systemctl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tool you use to interact with `systemd` to manage services is [`systemctl`](https://oreil.ly/kigFH).
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 6-1](#table-systemctl-commands) I’ve compiled a list of often-used
    `systemctl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Useful `systemd` commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Use case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl enable XXXXX.service` | Enable the service; ready to be started
    |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl daemon-reload` | Reload all unit files and re-create entire dependency
    tree |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl start XXXXX.service` | Start the service |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl stop XXXXX.service` | Stop the service |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl restart XXXXX.service` | Stop and then start the service |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl reload XXXXX.service` | Issue `reload` command to service; falls
    back to `restart` |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl kill XXXXX.service` | Stop service execution |'
  prefs: []
  type: TYPE_TB
- en: '| `systemctl status XXXXX.service` | Get a short summary of service state including
    some log lines |'
  prefs: []
  type: TYPE_TB
- en: Note that there are many more commands that `systemctl` offers, from dependency
    management and query to controlling the overall system (`reboot`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `systemd` ecosystem has a number of other command-line tools you may find
    handy and that you should at least be aware of. This includes but is not limited
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`bootctl`](https://oreil.ly/WNKjd)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to check the boot loader status and manage available boot loaders.
  prefs: []
  type: TYPE_NORMAL
- en: '`timedatectl`'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to set and view [time- and date-related information](https://oreil.ly/hmgxb).
  prefs: []
  type: TYPE_NORMAL
- en: '`coredumpctl`'
  prefs: []
  type: TYPE_NORMAL
- en: Enables you to process saved core dumps. Consider this tool when you’re troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring with journalctl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The journal is a component of `systemd`; technically it is a binary file managed
    by the `systemd-journald` daemon, providing a centralized location for all messages
    logged by `systemd` components. We’ll cover it in detail in [“journalctl”](ch08.xhtml#journalctl).
    All you need to know for now is that this is the tool that allows you to view
    `systemd`-managed logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: scheduling greeter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After all that theory, let’s see `systemd` in action. As a simple use case
    example, let’s assume we want to launch our greeter app (see [“Running Example:
    greeter”](#app-greeter)) every hour.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a `systemd` unit file of type `service`. This tells `systemd`
    how to start the greeter app; store the following in a file called *greeter.service*
    (in any directory, could be a temporary one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The description of our services, shown when we use `systemctl status`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The location of our app
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a [timer unit](https://oreil.ly/Qv8qt) to launch the greeter
    service every hour. Store the following in a file called *greeter.timer*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the schedule using the [systemd time and date format](https://oreil.ly/pinVc)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we copy both unit files to */run/systemd/system* so that `systemd` recognizes
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’re now in a position to use the greeter timer, since `systemd` automatically
    picked it up when we copied it into the respective directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Debian-based systems such as Ubuntu enable and start service units by default.
    Red Hat family systems won’t start the service without an explicit `systemctl
    start greeter.timer`. This is also true for enabling services on boot, where Debian-based
    distros enable services by default, whereas Red Hat distros require an explicit
    confirmation in the form of `systemctl enable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the status of our greeter timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So `systemd` confirms that it knows about our greeter and that it’s scheduled
    to run. But how do you know if it worked? Let’s check the logs (note that the
    output was edited and that the `stdout` output is going directly to the logs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `journalctl` to look at and follow (`-f`) the logs of the *greeter.service*
    unit (selected with `-u`)
  prefs: []
  type: TYPE_NORMAL
- en: 'With this high-level `systemd` overview, let’s move on to how to manage applications
    the traditional way, with general-purpose package managers. But before we get
    into the technicalities of packages, let’s step back a bit and discuss apps, packages,
    and package managers in the context of a broader concept: supply chains.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux Application Supply Chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with what we mean by [*supply chain*](https://oreil.ly/EegdU):
    a system of organizations and individuals supplying a product to a consumer. While
    you may not think about supply chains a lot, you’re dealing with them on a daily
    basis—for example, when you buy food or fuel your car. In our discussion, the
    products are applications made up of software artifacts, and you can think of
    the consumer as either yourself as the person using an app or as a tool that manages
    the apps for you.'
  prefs: []
  type: TYPE_NORMAL
- en: On a conceptual level, [Figure 6-2](#fig-supply-chain) shows the main actors
    and phases of a typical Linux application supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0602](Images/lmlx_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Linux app supply chain
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The three distinct areas in a Linux application supply are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Software maintainers
  prefs: []
  type: TYPE_NORMAL
- en: These include individual developers, open source projects, and companies, such
    as independent software vendors (ISVs), that produce software artifacts and publish
    them, for example, as packages to a repository (repo).
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs: []
  type: TYPE_NORMAL
- en: This lists the package that contains all or part of an app together with metadata.
    The package usually captures the dependencies of an app. Dependencies are other
    packages that an app needs in order to function. This can be a library, some kind
    of exporters or importers, or other service programs. Keeping these dependencies
    up to date is hard.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling (a package manager)
  prefs: []
  type: TYPE_NORMAL
- en: On the target-system side, this can look up packages in the repository and install,
    update, and remove apps as instructed by the human user. Note that one or more
    packages can represent the app and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: While the details may differ from distribution to distribution and depend on
    the environment (server, desktop, etc.), the app supply chains all have the elements
    shown in [Figure 6-2](#fig-supply-chain) in common.
  prefs: []
  type: TYPE_NORMAL
- en: There are many options available for package and dependency management, such
    as traditional package managers, container-based solutions, and more recent approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-3](#fig-package-man-universe), I’ve tried to give you a high-level
    overview, without claiming this is a complete picture.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0603](Images/lmlx_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. The Linux package management and application dependency management
    universe
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A few notes on the three primary categories of options for package and dependency
    management:'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional package managers
  prefs: []
  type: TYPE_NORMAL
- en: Within this category, we usually differentiate between low-level and high-level
    tooling. If a package manager can resolve dependencies and provides a high-level
    interface (install, update, remove), we call it a *high-level* package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Container-based solutions
  prefs: []
  type: TYPE_NORMAL
- en: These initially came out of the server and cloud computing realm. Given their
    capabilities, one use case, but not necessarily their primary one, is application
    management. In other words, as a developer you’ll love containers since they enable
    you to easily test things and make it straightforward to ship your production-ready
    app. See also [“Containers”](#containers).
  prefs: []
  type: TYPE_NORMAL
- en: Modern package managers
  prefs: []
  type: TYPE_NORMAL
- en: These have their roots in desktop environments, and the main goal here is to
    make it as easy as possible for the end user to consume apps. See also [“Modern
    Package Managers”](#modern-package-man).
  prefs: []
  type: TYPE_NORMAL
- en: Packages and Package Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we discuss package formats and package managers that have
    been in use for a long time, in some cases decades. These usually stem from two
    major Linux distribution families: Red Hat (RHEL, Fedora, CentOS, etc.) and Debian-based
    systems (Debian, Ubuntu, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two concepts relevant to our discussions here are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The packages themselves
  prefs: []
  type: TYPE_NORMAL
- en: Technically a file that usually is zipped and may contain metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The tooling (called *package managers*)
  prefs: []
  type: TYPE_NORMAL
- en: Deals with those packages on the target system, to install and maintain apps.
    A package manager usually interacts with the repo on your behalf and maintains
    a local cache of packages.
  prefs: []
  type: TYPE_NORMAL
- en: The target system may be a desktop environment on your laptop or a server VM
    instance in the cloud, for example. Depending on the environment, packages may
    be more or less applicable—for example, a GUI app on a server is not necessarily
    something that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: RPM Package Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[RPM Package Manager](https://oreil.ly/Ef2FC) (for which the recursive acronym
    RPM is used) was originally created by Red Hat but is now widely used in various
    distros. The *.rpm* file format is used in Linux Standard Base and can contain
    binary or source files. The packages can be cryptographically verified and support
    delta updates via patch files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Package managers that use RPM include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`yum`](https://oreil.ly/sPb2H)'
  prefs: []
  type: TYPE_NORMAL
- en: In Amazon Linux, CentOS, Fedora, and RHEL
  prefs: []
  type: TYPE_NORMAL
- en: '[DNF](https://oreil.ly/0Pcod)'
  prefs: []
  type: TYPE_NORMAL
- en: In CentOS, Fedora, and RHEL
  prefs: []
  type: TYPE_NORMAL
- en: '[Zypper](https://oreil.ly/OVize)'
  prefs: []
  type: TYPE_NORMAL
- en: In openSUSE and SUSE Linux Enterprise
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see RPM in action: let’s say we have a fresh developer environment and
    want to install the Go programming language tool chain using `yum`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output in the following shell sessions has been edited and shortened
    to fit the space (there are many lines in the output that are not relevant to
    understanding the usage).
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we need to find the package for Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the Go package. Note the `#` prompt, suggesting we’re logged in as
    root. Perhaps a better way would be to use `sudo yum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with this info about the package, we can now install it using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Go package.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`yum`’s first step is to determine Go’s dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Here `yum` provides us with a summary of what it found in terms of dependencies
    and tells us what it plans to do. I need to confirm here interactively by entering
    a `y`. However, in a script I would use the `yum install golang -y` form of the
    command to automatically accept this.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: After verifying that all dependencies and the main package are installed, `yum`
    reports success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we want to verify the package, checking exactly what we
    have installed and where:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s have a look at the other widely used package manager using Debian
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Debian deb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[deb](https://oreil.ly/sctS1) packages and the *.deb* file format originate
    from the Debian distro. The deb packages can also contain binary or source files.
    Multiple package managers use deb, including low-level, no-dependency-management
    ones such as `dpkg`, and high-level ones such as `apt-get`, `apt`, and `aptitude`.
    Given that Ubuntu is a Debian-based distro, deb packages are widely used, on the
    desktop and server alike.'
  prefs: []
  type: TYPE_NORMAL
- en: To see deb packages in action, let’s assume we want to install the `curl` utility
    with `apt`. This is a useful tool to interact with HTTP APIs and to download files
    from a range of locations. Note that we again edited the output to make it fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we search for the `curl` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the `curl` package with `apt`. Note that there were overall dozens
    of more search results shown, most of them libraries and language-specific bindings
    (Python, Ruby, Go, Rust, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we install the `curl` package like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `curl` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`apt`’s first step is to determine the dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Here `apt` provides us with a dependencies summary and tells us what it will
    install. Interactive confirmation is needed here; in a script I would use `apt
    install curl -y` to automatically accept it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: After verifying that all dependencies and the main package are installed, `apt`
    reports success.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally we verify the `curl` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now move on to programming language–specific package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Language-Specific Package Managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are also programming language–specific package managers, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: C/C++
  prefs: []
  type: TYPE_NORMAL
- en: Have [many different package managers](https://oreil.ly/ibEK2), including Conan
    and vcpkg
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs: []
  type: TYPE_NORMAL
- en: Has package management built in (`go get`, `go mod`)
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs: []
  type: TYPE_NORMAL
- en: Has `npm` and others
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs: []
  type: TYPE_NORMAL
- en: Has `maven` and `nuts` and others
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: Has `pip` and PyPM
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs: []
  type: TYPE_NORMAL
- en: Has `rubygems` and Rails
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs: []
  type: TYPE_NORMAL
- en: Has `cargo`
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s look at containers and how you can manage applications with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of this book, we understand a *container* as a Linux process
    group that uses Linux namespaces, cgroups, and optionally CoW filesystems to provide
    application-level dependency management. Use cases for containers range from local
    [testing and development](https://oreil.ly/6RPcT) to working with distributed
    systems—for example, working with containerized microservices in [Kubernetes](https://kubernetes.io).
  prefs: []
  type: TYPE_NORMAL
- en: While containers are very useful for developers and sys admins, as an end user
    you will more likely be comfortable using higher-level tooling to manage applications—for
    example, the ones discussed in [“Modern Package Managers”](#modern-package-man).
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers are, per se, nothing new in Linux. However, they’ve enjoyed mainstream
    adoption only due to Docker, starting in roughly 2014\. Before that, we had a
    number of attempts to introduce containers, often targeting system administrators
    rather than developers, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Linux-VServer (2001)](https://oreil.ly/A5Uri)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenVZ (2005)](https://oreil.ly/yM3Tm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LXC (2008)](https://oreil.ly/BDSjL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Let Me Contain That for You (lmctfy) (2013)](https://oreil.ly/xpmMx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What all of these approaches have in common is that they use the basic building
    blocks the Linux kernel provides, such as namespaces or cgroups, to allow users
    to run applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker innovated on the concept and introduced two groundbreaking elements:
    a standardized way to define the packaging via container images and a human-friendly
    user interface (for example, `docker run`). The way container images are defined
    and distributed, as well as how containers are executed, formed the basis for
    what is now known as the [Open Container Initiative (OCI)](https://opencontainers.org)
    core specifications. When we talk about containers here, we focus on OCI-compliant
    implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three core OCI container specifications are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Runtime specification](https://oreil.ly/vrN0V)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines what a runtime needs to support, including operations and life-cycle
    phases
  prefs: []
  type: TYPE_NORMAL
- en: '[Image format specification](https://oreil.ly/p0WCY)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines how container images are constructed, based on metadata and layers
  prefs: []
  type: TYPE_NORMAL
- en: '[Distribution specification](https://oreil.ly/kNNeA)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines how container images are shipped, effectively the way repositories work
    in the context of containers
  prefs: []
  type: TYPE_NORMAL
- en: Another idea associated with containers is *immutability*. This means that once
    a configuration is put together, you cannot change it during its usage. In other
    words, changes require creating a new (static) configuration and a new resource
    (such as a process) with it. We will revisit this in the context of container
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re aware of what containers are on a conceptual level, let’s have
    a closer look at the building blocks of OCI-compliant containers.
  prefs: []
  type: TYPE_NORMAL
- en: Linux Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 1](ch01.xhtml#intro-to-linux), Linux initially had
    a global view on resources. To allow processes to have a local view on a resource
    (such as a filesystem, networking, or even users), Linux introduced namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, [Linux namespaces](https://oreil.ly/3SvR1) are all about resource
    visibility and can be used to isolate different aspects of the operating system
    resources. Isolation in this context is mostly about what a process sees, not
    necessarily a hard boundary (from a security perspective).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create namespaces, you have three relevant syscalls at your disposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`clone`](https://oreil.ly/JNot8)'
  prefs: []
  type: TYPE_NORMAL
- en: Used to create a child process that can share parts of its execution context
    with the parent process
  prefs: []
  type: TYPE_NORMAL
- en: '[`unshare`](https://oreil.ly/9BXiz)'
  prefs: []
  type: TYPE_NORMAL
- en: Used to remove a shared execution context from an existing process
  prefs: []
  type: TYPE_NORMAL
- en: '[`setns`](https://oreil.ly/PKGHm)'
  prefs: []
  type: TYPE_NORMAL
- en: Used to join an existing process to an existing namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding syscalls take a range of flags as parameters, enabling you to
    have fine-grained control over the namespaces you want to create, join, or leave:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLONE_NEWNS`'
  prefs: []
  type: TYPE_NORMAL
- en: Use for [filesystem mount points](https://oreil.ly/i1Igl). Visible via */proc/$PID/mounts*.
    Supported since Linux 2.4.19.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLONE_NEWUTS`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to create [hostname and (NIS) domain name](https://oreil.ly/7lB3U) isolation.
    Visible via `uname -n` and `hostname -f`. Supported since Linux 2.6.19.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLONE_NEWIPC`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to do [interprocess communication (IPC)](https://oreil.ly/h9tlW) resource
    isolation like System V IPC objects or POSIX message queues. Visible via */proc/sys/fs/mqueue*,
    */proc/sys/kernel*, and */proc/sysvipc*. Supported since Linux 2.6.19.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLONE_NEWPID`'
  prefs: []
  type: TYPE_NORMAL
- en: Use for [PID number space isolation](https://oreil.ly/Czzu7) (PID inside/PID
    outside the namespace). You can gather details about it via */proc/$PID/status*.
    Supported since Linux 2.6.24.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLONE_NEWNET`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to control visibility of [network system resources](https://oreil.ly/X9klx)
    such as network devices, IP addresses, IP routing tables, and port numbers. You
    can view it via `ip netns list`, */proc/net*, and */sys/class/net*. Supported
    since Linux 2.6.29.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLONE_NEWUSER`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to map [UID+GIDs](https://oreil.ly/uClq3) inside/outside the namespace.
    You can query UIDs and GIDs and their mappings via the `id` command and */proc/$PID/uid_map*
    and */proc/$PID/gid_map*. Supported since Linux 3.8.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLONE_NEWCGROUP`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to manage [cgroups in a namespace](https://oreil.ly/YAGGb). You can see
    it via */sys/fs/cgroup*, */proc/cgroups*, and */proc/$PID/cgroup*. Supported since
    Linux 4.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to view namespaces in use on your system is as follows (output edited
    to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next container building block focuses on resource consumption limits and
    reporting on resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Linux cgroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Where namespaces are about visibility, [*cgroups*](https://oreil.ly/m4wBr)
    provide a different kind of functionality: they are a mechanism to organize process
    groups. Along with the hierarchical organization, you can use cgroups to control
    system resources usage. In addition, cgroups provide resource usage tracking;
    for example, they show how much RAM or CPU seconds a process (group) is using.
    Think of cgroups as the declarative unit and the controller as a piece of kernel
    code that enforces a certain resource limitation or reports on its usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this time of writing, there are two versions of cgroups available in the
    kernel: cgroups v1 and v2\. cgroup v1 is still widely used, but v2 will eventually
    replace v1, so you should focus on v2.'
  prefs: []
  type: TYPE_NORMAL
- en: cgroup v1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With [cgroup v1](https://oreil.ly/iOEcV), the community had an ad hoc approach,
    adding new cgroups and controllers as needed. The following v1 cgroups and controllers
    exist (ordered from oldest to newest; note that the docs are all over the place
    and inconsistent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[CFS bandwidth control](https://oreil.ly/vGu0Y)'
  prefs: []
  type: TYPE_NORMAL
- en: Used via the `cpu` cgroup. Supported since Linux 2.6.24.
  prefs: []
  type: TYPE_NORMAL
- en: '[CPU accounting controller](https://oreil.ly/7NSLN)'
  prefs: []
  type: TYPE_NORMAL
- en: Used via the `cpuacct` cgroup. Supported since Linux 2.6.24.
  prefs: []
  type: TYPE_NORMAL
- en: '[`cpusets` cgroup](https://oreil.ly/sJp4X)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to assign CPU and memory to a task. Supported since Linux 2.6.24.
  prefs: []
  type: TYPE_NORMAL
- en: '[Memory resource controller](https://oreil.ly/VjsXY)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to isolate the memory behavior of tasks. Supported since Linux 2.6.25.
  prefs: []
  type: TYPE_NORMAL
- en: '[Device whitelist controller](https://oreil.ly/DklEJ)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to control device file usage. Supported since Linux 2.6.26.
  prefs: []
  type: TYPE_NORMAL
- en: '[`freezer` cgroup](https://oreil.ly/waLVz)'
  prefs: []
  type: TYPE_NORMAL
- en: Used for batch job management. Supported since Linux 2.6.28.
  prefs: []
  type: TYPE_NORMAL
- en: '[Network classifier cgroup](https://oreil.ly/fGcWg)'
  prefs: []
  type: TYPE_NORMAL
- en: Used to assign different priorities to packets. Supported since Linux 2.6.29.
  prefs: []
  type: TYPE_NORMAL
- en: '[Block IO controller](https://oreil.ly/V3Zto)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to throttle block I/D. Supported since Linux 2.6.33.
  prefs: []
  type: TYPE_NORMAL
- en: '[`perf_event` command](https://oreil.ly/AMWei)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to collect performance data. Supported since Linux 2.6.39.
  prefs: []
  type: TYPE_NORMAL
- en: '[Network priority cgroup](https://oreil.ly/4e9f2)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to dynamically set the priority of network traffic. Supported since
    Linux 3.3.
  prefs: []
  type: TYPE_NORMAL
- en: '[HugeTLB controller](https://oreil.ly/dzl7L)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to limit HugeTLB usage. Supported since Linux 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: '[Process number controller](https://oreil.ly/WkBss)'
  prefs: []
  type: TYPE_NORMAL
- en: Used to allow a cgroup hierarchy to create new processes after a certain limit
    is reached. Supported since Linux 4.3.
  prefs: []
  type: TYPE_NORMAL
- en: cgroup v2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[cgroup v2](https://oreil.ly/YWCEi) is a total rewrite of cgroups with the
    lessons learned from v1\. This is true both in terms of consistent configuration
    and use of the cgroups as well as the (centralized and uniform) documentation.
    Unlike the per-process cgroup v1 design, cgroup v2 has only single hierarchy,
    and all controllers are managed the same way. Here are the v2 controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU controller
  prefs: []
  type: TYPE_NORMAL
- en: Regulates distribution of CPU cycles, supporting different models (weight, max)
    and includes usage reporting
  prefs: []
  type: TYPE_NORMAL
- en: Memory controller
  prefs: []
  type: TYPE_NORMAL
- en: Regulates distribution of memory with a range of control parameters, supporting
    user-space memory, kernel data structures such as dentries and inodes, and TCP
    socket buffers
  prefs: []
  type: TYPE_NORMAL
- en: I/O controller
  prefs: []
  type: TYPE_NORMAL
- en: Regulates the distribution of I/O resources with both weight-based and absolute
    bandwidth or I/O operations per second (IOPS) limits, reporting on bytes and IOPS
    read/writes
  prefs: []
  type: TYPE_NORMAL
- en: Process number (PID) controller
  prefs: []
  type: TYPE_NORMAL
- en: Is similar to the v1 version
  prefs: []
  type: TYPE_NORMAL
- en: '`cpuset` controller'
  prefs: []
  type: TYPE_NORMAL
- en: Is similar to the v1 version
  prefs: []
  type: TYPE_NORMAL
- en: '`device` controller'
  prefs: []
  type: TYPE_NORMAL
- en: Manages access to device files, implemented on top of eBPF
  prefs: []
  type: TYPE_NORMAL
- en: '`rdma` controller'
  prefs: []
  type: TYPE_NORMAL
- en: Regulates the distribution and accounting of [remote direct memory access (RDMA)
    resources](https://oreil.ly/a5Wk3)
  prefs: []
  type: TYPE_NORMAL
- en: HugeTLB controller
  prefs: []
  type: TYPE_NORMAL
- en: Is similar to the v1 version
  prefs: []
  type: TYPE_NORMAL
- en: There are also miscellaneous cgroups in v2 that allow resource limits and tracking
    mechanisms for scalar resources (which can’t be abstracted like other cgroup resources).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view all of the v2 cgroups in your Linux system in a nice tree rendering
    via the `systemctl` command, as shown in the following example (output shortened
    and edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `systemctl` tool to render cgroups
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: An example of a specific cgroup that `systemd` manages
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful view on cgroups is interactive resource usage, as shown in the
    following (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Going forward, you can expect that, as modern kernel versions are more widely
    used, the cgroups v2 will become the standard. There are indeed certain distros,
    such as [Arch](https://oreil.ly/rxFF2), Fedora 31+, and Ubuntu 21.10, that already
    have v2 by default.
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-Write Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third building block of containers are CoW filesystems, as discussed in
    greater detail in [“Copy-on-Write Filesystems”](ch05.xhtml#cowfs). These are used
    at build time. They package the application and all of its dependencies into a
    single, self-contained file that you can distribute. Usually the CoW filesystems
    are used in combination with [bind mounts](https://oreil.ly/BS4nK) to layer the
    content of the different dependencies on top of each other in an efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker is a human-friendly container implementation developed and popularized
    by Docker Inc. in 2014\. With Docker, it’s easy to package up programs and their
    dependencies and launch them in a range of environments, from desktops to the
    cloud. What’s so unique about Docker is not the building blocks (namespaces, cgroups,
    CoW filesystems, and bind mounts). These existed a while before Docker came into
    being. What’s so special is that Docker combined these building blocks in a way
    that makes them easy to use by hiding the complexity of managing the low-level
    bits like namespaces and cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 6-4](#fig-docker-arch) and described in the passage that
    follows, there are two main concepts in Docker: the image and the running container.'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0604](Images/lmlx_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. High-level Docker architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The container image
  prefs: []
  type: TYPE_NORMAL
- en: A compressed archive file that contains metadata in JSON files and the layers,
    which are effectively directories. The Docker daemon pulls the container images
    as needed from a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: The container as the runtime artifact (for example, app A/B/C)
  prefs: []
  type: TYPE_NORMAL
- en: You can start, stop, kill, and remove it. You interact with the Docker daemon
    using a client CLI tool (`docker`). This CLI tool sends commands to the daemon,
    which in turn executes the respective operation, such as building or running a
    container.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-2](#tab-dockercmds) presents a short reference of often-used Docker
    CLI commands, covering both the build-time and the runtime phases. To get the
    full reference, including use cases, refer to the [Docker docs](https://oreil.ly/y1c1W).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. Often-used Docker commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `run` | Launch a container | Run NGINX as a daemon and remove container on
    exit: `docker run -d --rm nginx:1.21` |'
  prefs: []
  type: TYPE_TB
- en: '| `ps` | List containers | List all containers (including nonrunning): `docker
    ps -a` |'
  prefs: []
  type: TYPE_TB
- en: '| `inspect` | Display low-level info | To query the container IP: `docker inspect
    -f ''{{.Network​Set⁠tings.IPAddress}}''` |'
  prefs: []
  type: TYPE_TB
- en: '| `build` | Generate a container image locally | Build image based on current
    directory and tag: `docker build -t some:tag .` |'
  prefs: []
  type: TYPE_TB
- en: '| `push` | Upload a container image to a registry | Push to AWS registry: `docker
    push public.ecr.aws/some:tag` |'
  prefs: []
  type: TYPE_TB
- en: '| `pull` | Download a container image from a registry | Pull from AWS registry:
    `docker pull public.ecr.aws/some:tag` |'
  prefs: []
  type: TYPE_TB
- en: '| `images` | List local container images | List images from a certain registry:
    `docker images ubuntu` |'
  prefs: []
  type: TYPE_TB
- en: '| `image` | Manage container images | Remove all unused images: `docker image
    prune -all` |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s now have a closer look at the build-time artifact: the container image
    that Docker uses.'
  prefs: []
  type: TYPE_NORMAL
- en: Container Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To define the instructions on how to build a container image, you use a plain
    text file format called [Dockerfile](https://oreil.ly/dM8LO).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different directives you can have in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: Base images
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`; can be multiple for build/run phases'
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs: []
  type: TYPE_NORMAL
- en: '`LABEL` for lineage'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments and environment variables
  prefs: []
  type: TYPE_NORMAL
- en: '`ARGS`, `ENV`'
  prefs: []
  type: TYPE_NORMAL
- en: Build-time specifications
  prefs: []
  type: TYPE_NORMAL
- en: '`COPY`, `RUN`, etc., which define how the image is constructed, layer for layer'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime specifications
  prefs: []
  type: TYPE_NORMAL
- en: '`CMD` and `ENTRYPOINT`, which define how the container can be run'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `docker build` command, you turn a collection of files that represent
    your application (either as source or in binary format), along with the Dockerfile,
    into a container image. This container image is the artifact that you can then
    run or push to a registry, in order to distribute it for others to pull and eventually
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can run containers with interactive input (terminal attached) or as daemons
    (background). The [`docker run`](https://oreil.ly/87YZq) command takes a container
    image and a set of runtime inputs, such as environment variables, ports to expose,
    and volumes to mount. With this information, Docker creates the necessary namespaces
    and cgroups and launches the application defined in the container image (`CMD`
    or `ENTRYPOINT`).
  prefs: []
  type: TYPE_NORMAL
- en: With the Docker theory out of the way, let’s see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: containerized greeter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now put our `greeter` app (see [“Running Example: greeter”](#app-greeter))
    into a container and run it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we need to define the Dockerfile, which contains the instructions
    to build the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#custom_co_applications__package_management____span_class__keep_together__and_containers__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the base image using an explicit tag (`20.04`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#custom_co_applications__package_management____span_class__keep_together__and_containers__span__CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Assign some metadata via a [label](https://oreil.ly/eYWVo).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#custom_co_applications__package_management____span_class__keep_together__and_containers__span__CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Copy shell script. This could be a binary, a JAR file, or a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#custom_co_applications__package_management____span_class__keep_together__and_containers__span__CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#custom_co_applications__package_management____span_class__keep_together__and_containers__span__CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This and the next line define the user running the app. If you don’t do this,
    it will unnecessarily run as `root`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#custom_co_applications__package_management____span_class__keep_together__and_containers__span__CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Define what to run, in our case the shell script. The way we defined it, using
    `ENTRYPOINT`, it is possible to pass a parameter by running `docker run greeter:1
    _SOME_PARAMETER_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we build the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Build the container image and label it (with `-t greeter:1`). The `.` means
    that it uses the current directory and assumes that a Dockerfile is present there.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_applications__package_management____span_class__keep_together__and_containers__span__CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This and the next lines pull the base image and build it layer by layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check if the container image is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run a container based on the `greeter:1` image, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That wraps up our Docker 101\. We’ll now take a quick look at related tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Other Container Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You don’t have to use Docker to work with OCI containers; as an alternative,
    you can use a Red Hat–led and –sponsored combo: [`podman`](https://podman.io)
    and [`buildah`](https://buildah.io). These daemon-less tools allow you to build
    OCI container images (`buildah`) and run them (`podman`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are a number of tools that make working with OCI containers,
    namespaces, and cgroups easier, including but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`containerd`](https://oreil.ly/mIKkm)'
  prefs: []
  type: TYPE_NORMAL
- en: A daemon that manages the OCI container life cycle, from image transfer and
    storage to container runtime supervision
  prefs: []
  type: TYPE_NORMAL
- en: '[`skopeo`](https://oreil.ly/UAom6)'
  prefs: []
  type: TYPE_NORMAL
- en: For container image manipulation (copying, inspecting manifest, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: '[`systemd-cgtop`](https://oreil.ly/aDgBa)'
  prefs: []
  type: TYPE_NORMAL
- en: A kind of cgroups-aware variant of `top` that shows resource usage interactively
  prefs: []
  type: TYPE_NORMAL
- en: '[`nsenter`](https://oreil.ly/D0Gbc)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to execute a program in a specified, existing namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[`unshare`](https://oreil.ly/oOigx)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to run a program with specific namespaces (opt in via flags)
  prefs: []
  type: TYPE_NORMAL
- en: '[`lsns`](https://oreil.ly/jY7Q6)'
  prefs: []
  type: TYPE_NORMAL
- en: Lists information about Linux namespaces
  prefs: []
  type: TYPE_NORMAL
- en: '[`cinf`](https://oreil.ly/yaiMo)'
  prefs: []
  type: TYPE_NORMAL
- en: Lists information about Linux namespaces and cgroups associated with process
    IDs
  prefs: []
  type: TYPE_NORMAL
- en: With this we end our containers tour. Let’s now look at modern package managers
    and how they utilize containers to isolate applications from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Package Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the more traditional package managers that often are distribution-specific,
    there is a new sort of package manager. These modern solutions often make use
    of containers and aim to be cross-distribution or target specific environments.
    For example, they can make it easy for Linux desktop users to install GUI apps.
  prefs: []
  type: TYPE_NORMAL
- en: '[Snap](https://oreil.ly/n4fe6)'
  prefs: []
  type: TYPE_NORMAL
- en: A Canonical Ltd.–designed and –promoted software packaging and deployment system.
    It comes with a refined [sandboxing](https://oreil.ly/ImWPH) setup and can be
    used in desktop, cloud, and IoT environments.
  prefs: []
  type: TYPE_NORMAL
- en: '[Flatpak](https://oreil.ly/sEEu1)'
  prefs: []
  type: TYPE_NORMAL
- en: Optimized for Linux desktop environments, using cgroups, namespaces, bind mounts,
    and seccomp as its building blocks. While initially from the Red Hat part of the
    Linux distro universe, it is now available for dozens of distros, including Fedora,
    Mint, Ubuntu, Arch, Debian, openSUSE, and Chrome OS.
  prefs: []
  type: TYPE_NORMAL
- en: '[AppImage](https://oreil.ly/76Uhu)'
  prefs: []
  type: TYPE_NORMAL
- en: Has been around for years and promotes the idea that one app equals one file;
    that is, it requires no dependencies other than what is included in the targeted
    Linux system. Over time, a number of interesting features have found their way
    into AppImage, from efficient updates to desktop integration to software catalogs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Homebrew](https://oreil.ly/XegIz)'
  prefs: []
  type: TYPE_NORMAL
- en: Originally from the macOS world but available for Linux and enjoying increasing
    popularity. It’s written in Ruby and has a powerful yet intuitive user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a wide range of topics, all related to how to install,
    maintain, and use applications on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: We first defined basic application terms, then we looked at the Linux startup
    process, discussing `systemd`, the now standard way of managing startup and components.
  prefs: []
  type: TYPE_NORMAL
- en: To distribute applications, Linux uses packages and package managers. We discussed
    various managers in this context and how you can use containers for development
    and testing as well as dependency management. Docker containers use Linux primitives
    (cgroups, namespaces, CoW filesystems) to provide you with application-level dependency
    management (via container images).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at custom solutions for app management, including Snap and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in further reading on the topics in this chapter, have
    a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Startup process and init systems
  prefs: []
  type: TYPE_NORMAL
- en: '[“Analyzing the Linux Boot Process”](https://oreil.ly/bYPw5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Stages of Linux Booting Process”](https://oreil.ly/k90in)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Configure a Linux Service to Start Automatically After a Crash or
    Reboot”](https://oreil.ly/tvaMe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package management
  prefs: []
  type: TYPE_NORMAL
- en: '[“2021 State of the Software Supply Chain”](https://oreil.ly/66mo5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Linux Package Management”](https://oreil.ly/MFGlL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Understanding RPM Package Management Tutorial”](https://oreil.ly/jiRj8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Debian packages](https://oreil.ly/DmAvc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs: []
  type: TYPE_NORMAL
- en: '[“A Practical Introduction to Container Terminology”](https://oreil.ly/zn69i)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“From Docker to OCI: What Is a Container?”](https://oreil.ly/NUxrE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Building Containers Without Docker”](https://oreil.ly/VofA0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Why Red Hat Is Investing in CRI-O and Podman”](https://oreil.ly/KJB9O)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Demystifying Containers”](https://oreil.ly/Anvty)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Rootless Containers”](https://oreil.ly/FLTHf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Docker Storage Drivers Deep Dive”](https://oreil.ly/8QPPh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“The Hunt for a Better Dockerfile”](https://oreil.ly/MLAom)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know all the basics around applications let’s move on from the
    scope of a single Linux system to an interconnected setup and its necessary precondition:
    networking.'
  prefs: []
  type: TYPE_NORMAL
