- en: Chapter 20\. Troubleshooting a Linux PC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux includes numerous utilities to help diagnose and fix problems, enough
    to fill several thick books. In this chapter, the focus is on using system logs
    to find out what went wrong, building a central systemd logging server, monitoring
    hardware health, finding and stopping troublesome processes, getting the best
    performance from hardware, and tips and tricks for diagnosing hardware issues.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Get to know your system logs well, and you will find the causes of problems.
    If learning the cause does not point you to a solution, you have the information
    you need to ask for help, whether it’s product documentation, distribution documentation,
    paid support, or community support.
  prefs: []
  type: TYPE_NORMAL
- en: Get well-acquainted with the documentation for your Linux distributions, especially
    changelogs and release notes, and the documentation for the servers and applications
    that you use. Ubuntu, Fedora, and openSUSE all excel at maintaining their documentation
    and detailed release notes. Also get acquainted with the forums, wikis, and chats
    for your distro, servers, and applications. For every issue you encounter, it
    is likely many other users have dealt with the same issue.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most errors are caused by software. Even consumer-grade hardware is pretty
    robust, and it fails most often from abuse and age. The most common hardware failures
    are components with moving parts:'
  prefs: []
  type: TYPE_NORMAL
- en: SATA and SCSI disk drives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU coolers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power supplies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case fans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CD/DVD drives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are simple measures you can take to extend the life of your hardware.
    Overheating and unreliable electricity are electronics killers. Good cooling is
    essential for keeping your computers healthy. Good cooling comes from well-designed
    cases that provide proper airflow, heat sinks and CPU coolers, and case fans oriented
    so that air is pulled in and pushed out correctly. This can get a little noisy,
    and you can buy cases, power supplies, and fans that run quietly. Vacuum out your
    computer insides periodically with a nonstatic vacuum, and clean case filters.
    If you prefer using compressed air to blow the dust out, be careful with fans.
    If you spin them too fast you can damage their bearings.
  prefs: []
  type: TYPE_NORMAL
- en: A power conditioner provides continuous protection from voltage sags and spikes,
    and from radio and electromagnetic interference. Surge protectors cost less, but
    only provide protection from surges. Voltage sags are just as damaging as spikes.
    A power conditioner more than pays for itself in longer life and stable operation.
  prefs: []
  type: TYPE_NORMAL
- en: Patience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Patience is your best friend when debugging problems. It’s best to take it
    slowly and systematically:'
  prefs: []
  type: TYPE_NORMAL
- en: Review instructions and make sure you did not miss any steps or make a mistake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is an update available? Many times this is the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy error messages and log file entries, and use them in web searches and trouble
    tickets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the last things that happened before the error occurred? What are the
    exact steps that created the error? Is it reproducible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the last things that happened reversible? If the answer is yes, undo them
    one at a time and test. Making multiple changes at once means you may not discover
    what caused the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a last resort, reboot. Really! This works a surprising number of times to
    resolve the issue, though you may not learn what the problem was.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some graphical applications, such as the wonderful digiKam photo manager and
    editor, emit all manner of details when you start them from a terminal, as this
    snippet shows after digiKam failed to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I have no idea what this means, but someone does, so I can reference this in
    a web search, or ask for help in the digiKam forums.
  prefs: []
  type: TYPE_NORMAL
- en: When you ask for help, remember patience and courtesy. When you are asked for
    additional information, provide exactly what you are asked for. When you resolve
    your issue, share your solution and thank the people who helped you.
  prefs: []
  type: TYPE_NORMAL
- en: 20.1 Finding Useful Information in Logfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weird stuff is happening, and you need to know where to start figuring it out.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log everything, and then read your logfiles. */var/log* contains log files,
    and the *dmesg* and *journalctl* commands display log messages. systemd manages
    all logs with *journald*, so you will see a lot of duplication with *dmesg* and
    */var/log*.
  prefs: []
  type: TYPE_NORMAL
- en: '*dmesg* reads the kernel ring buffer, which is a special memory location for
    recording kernel activity. Look in *dmesg* to see everything that happened at
    startup; hardware activity after startup, such as attaching and removing USB devices;
    and network interface activity. The kernel ring buffer is a fixed size, so new
    entries overwrite the oldest entries. Nothing is lost because the kernel logs
    are stored in */var/log/messages*, */var/log/dmesg*, and *journalctl*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read *dmesg* like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are looking for something specific, use *grep*, like when you are
    having trouble with a storage drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finding Whole Words with grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to find a word with *grep* use the *-w* switch. For example, when
    you grep for *ping* you will get results like piping, escaping, sleeping. *-w*
    returns only whole word matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *dmesg -T* to see human-readable timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default is the seconds and nanoseconds since startup. Run *dmesg --follow*
    to monitor new events as they occur, such as plugging and unplugging USB devices.
    Press Ctrl-C to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for certain logging levels, such as errors and warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run *dmesg -h* to see commands and options.
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/log* is the legacy location for log files, and you will still find logs
    there, depending on how your Linux distribution manages them. */var/log* is easy
    to search because most of the files are in plain text. When you’re not sure where
    to start looking, *grep* the whole directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you thought you installed *graphicsmagick*, but can’t
    find it. Take a quick look in */var/log*, and there it is, a record of its installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Systemd stuffs all logging into *journalctl*, so you can use it exclusively
    and not bother with *dmesg* and */var/log*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Invoke it with *sudo* to see if that adds any more information. Usually it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: '*journalctl* defaults to displaying oldest entries first. Press the spacebar
    or PageUp/ Down keys to navigate a screen at a time, or use the arrow keys to
    scroll one line at a time. Ctrl-End goes all the way to the newest, and Ctrl-Home
    goes back to the oldest. Press the Q key to exit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'See newest entries first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It does not wrap long lines by default, so you have to use arrow keys to read
    long lines. Make it wrap by piping its output to *less*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'See the most recent entries, with explanation messages, if there are any. This
    shows an example of an explanation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for specific services, such as MariaDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Select date ranges, which you can define in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you do not specify times, the default is 00:00:00, midnight. Specify times
    in HH:MM:SS format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at activity from an hour ago until 5 minutes ago and show the unit filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*journalctl* sorts logs by system boot. Look at HTTP server activity since
    the most recent boot, and limit the number of lines displayed to the most recent
    50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'See what happened three boots ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'List all recorded boot sessions, with timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can filter for specific severity levels. When you specify a single level,
    in this example, *crit*, it shows all messages from *crit* up to the most severe
    level, *emerg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Define your own range, for example from *crit* to *warning*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow new events as they are logged, starting from the 10 most recent entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Ctrl-C stops it.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, use good old *grep* to find things, like usernames, or any
    search term you wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Severity levels are the standard syslog levels, from 0 to 7, with 0 being the
    most severe, and 7 the least severe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*journalctl* provides dozens of ways to filter and parse your output, and you
    can learn even more in *man 1 journalctl*.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 3 syslog*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 journalctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 dmesg*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*https://systemd.io*](https://systemd.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.2 Configuring journald
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re not sure what the default configuration is for *journald*, and you need
    to know how to see the current configuration and how to change it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*journald* is configured in */etc/systemd/journald.conf*. Some default options
    are commented out, and all compile-time defaults are documented in *man 5 journald.conf*.
    We will take a look at the most commonly used options.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Storage=auto* means different things on different distros. Ubuntu and Fedora
    use */run/log/journal/* for volatile storage, and persistent storage is in */var/log/journal*.
    See the locations of log files, used space, and free space with *systemctl*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'openSUSE puts volatile storage in */run/log/journal/* and persistent storage
    in */var/log/messages*. If you prefer to use */var/log/journal*, create it and
    change the group owner to *systemd-journal*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to change anything else, and the storage is changed after reboot.
    Other options are *volatile*, *persistent*, and *none*.
  prefs: []
  type: TYPE_NORMAL
- en: '*volatile* stores logs only in memory, in */run/log/journal/*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*persistent* stores logs on disk and uses */run/log/journal/* when the disk
    is not available, such as early in system startup.'
  prefs: []
  type: TYPE_NORMAL
- en: '*none* disables all local logging, and you have the option to send log messages
    to a central logging server.'
  prefs: []
  type: TYPE_NORMAL
- en: '*SystemMaxUse=* controls the size of log storage on disk, and *RuntimeMaxUse=*
    controls the size of volatile storage. The default is 10% of available space in
    the filesystem, to a maximum of 4 GB.'
  prefs: []
  type: TYPE_NORMAL
- en: '*SystemKeepFree=* and *RuntimeKeepFree=* control how much disk space is left
    free for other uses. The defaults are 15% and 4 GB. You may change these by specifying
    numbers of bytes, or use K, M, G, T, P, and E; for example, 25 G (gigabytes).'
  prefs: []
  type: TYPE_NORMAL
- en: '*MaxRetentionSec=* controls how long files are retained. The default is 0,
    which disables it, and files are retained according to other settings, such as
    available disk space. You may configure a time value, using `year`, `month`, `week`,
    `day`, `h`, or `m`, for example, `6 month`.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*journald* automatically handles log rotation. Active files are rotated into
    archived files, and archived files are deleted according to your configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 5 journald.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.3 Building a Logging Server with systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to set up a central logging server so that logs are preserved when
    systems go down, and for centralized management.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'systemd provides a remote logging daemon, *journald*. Client machines send
    their log messages to the *journald* server. The prerequisites are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A machine to host the log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network access to the logging server for clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *systemd-journal-remote* package installed on the log server and on all
    clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your public key infrastructure (PKI) already in place ([Recipe 13.5](ch13.xhtml#rec-create-pki)),
    with keys and certificates distributed to servers and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After installing *systemd-journal-remote*, edit */etc/systemd/journal-remote.conf*
    on the server. I like to store encryption keys and certificates in */etc/pki/journald/*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Set permissions for the server key and certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the group owner of the server private key to *systemd-journal-remote*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable and start the *systemd-journal-remote* service, starting *systemd-journal-remote.socket*
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of both to make sure they started correctly. Open the necessary
    ports in the server firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'On every client, create a new user, *systemd-journal-upload*. This is the user
    that the *systemd-journal-upload* process uses to transfer log messages to the
    central server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Set permissions for the client key and certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit */etc/systemd/journal-upload.conf* with the URL and TCP port to your log
    server, and the locations of the client key and certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the *systemd-journal-upload.service*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If it restarts successfully, without errors, run the following steps to test
    that the client is sending log entries to the server. Check the log directory
    on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking good so far. Now, send the server a message from the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your favorite *journalctl* incantation on the server to call up the most
    recent entries. If you see the client message, you know you set it all up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A central logging server preserves client logs and centralizes logging storage
    for easier maintenance and analysis. Every client has their own directory on the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: '*Seal=false* disables cryptographic signing of journal entries. To try it out,
    refer to the *--setup-keys* option in *man 1 journalctl*. I could not find a definitive
    answer if it provides a meaningful benefit, but it doesn’t hurt to learn about
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: '*SplitMode=host* stores each client log in their own file. Set it to *false*
    to dump everything into a single file.'
  prefs: []
  type: TYPE_NORMAL
- en: '*ServerKeyFile=*, *ServerCertificateFile=*, and *TrustedCertificateFile=* are
    where your encryption keys and certificates are stored.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 5 journal-remote.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 journald.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 journalctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.4 Monitoring Temperatures, Fans, and Voltages with lm-sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your want to measure temperatures inside your computer case, fan speeds, and
    voltages.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *lm-sensors* to continually monitor CPU, hard disk, and case temperatures.
    This is supplied by the *sensors* package on openSUSE, *lm_sensors* on Fedora,
    and *lm-sensors* on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing *lm-sensors*, run the *sensors-detect* command to calibrate
    *lm-sensors* to your hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Press Enter to accept all of the defaults. When it is finished you will see
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The modules will be loaded after a restart, or you can load them immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the *sensors* command and see what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This shows information for CPU cores, a graphics adapter, fans, and memory modules.
    You see the current temperatures, and the high, critical, and emergency temperature
    ranges. CPUs have built-in self-preservation and shut down when they get too hot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the *watch* command to see updated status every two seconds, with any differences
    highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a different update interval, like 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Press Ctrl-C to stop.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*lm_sensors* is not magic, it reads only devices that have temperature sensors
    and that also have Linux drivers. Most temperature sensors are not very precise,
    so don’t worry about small fluctuations.'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring temperatures, voltages, and fan speeds can give you early warning
    of trouble. It is cheaper to replace a fan than to rebuild a cooked computer.
    Voltage drops could indicate a failing power supply or a bad connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you modify the */etc/modules* file, check your kernel configuration
    to see if the modules suggested by *sensors-detect* are already loaded, or are
    statically compiled. Your kernel configuration file is in the */boot* directory,
    named *config-kernel-version*, like *config-5.8.0-45-generic*. For example, search
    for the *nct6775* module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The *m* means it is a loadable kernel module. Check if it is already loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If this returns nothing, go ahead and add it to */etc/modules*. If it were
    statically compiled, it would look like this in *config-**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The *y* means it is built-in to the kernel, so do not add it to */etc/modules*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 watch*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 sensors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 lsmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*https://kernel.org*](https://kernel.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.5 Adding a Graphical Interface to lm-sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a configurable graphical display for *lm-sensors* that updates automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have several good choices. Graphical frontends to *lm-sensors* also support
    other monitors, such as *smartmontools* and *hddtemp*. Psensor provides a large
    display, colored graphs, and simple configuration to rename labels and show just
    what you want to see ([Figure 20-1](#fig-trouble-1)).
  prefs: []
  type: TYPE_NORMAL
- en: Psensor supports alarms. Enable alarms individually, like for the CPU cores
    and fans, by clicking on each monitor to bring up a Preferences menu ([Figure 20-2](#fig-trouble-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Psensor tracks multiple hardware monitors.](Images/lcb2_2001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-1\. Psensor tracks multiple hardware monitors
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Enabling alarms and alarm thresholds.](Images/lcb2_2002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-2\. Enabling alarms and alarm thresholds
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You need to write a simple script to set up an alarm, like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Install *sox* to get the *play* command. Make your script executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When it works to your satisfaction, configure Psensor to use it. Open Psensor
    → Preferences → Sensors ([Figure 20-3](#fig-trouble-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up an alarm.](Images/lcb2_2003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-3\. Setting up an alarm
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A simple way to test it in Psensors is to set some of your maximum temperatures
    too low.
  prefs: []
  type: TYPE_NORMAL
- en: Many desktop environments, such as Xfce4, GNOME, and KDE, have nice little taskbar
    plug-ins, such as what’s shown in [Figure 20-4](#fig-trouble-4) for Xfce4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xfce taskbar plugin for lm-sensors.](Images/lcb2_2004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-4\. Xfce taskbar plug-in for lm-sensors
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All of them have *sensor* in their package names, except *gnome-shell-extension-freon*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can write your script to automatically shut the system down when an alarm
    is triggered, like this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 play*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 sensors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Psensor](https://oreil.ly/IcRok)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.6 Monitoring Hard Disk Health with smartmontools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know when a hard disk is faulty or, preferably, when it is becoming
    faulty, so you can replace it before you lose data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most hard disks and solid-state drives come with S.M.A.R.T. (Self-Monitoring
    Analysis and Reporting Technology) built in. S.M.A.R.T. tracks and records certain
    performance attributes, which you can monitor to (hopefully) predict immiment
    failures. Linux users have *smartmontools* to read this information and give warnings.
  prefs: []
  type: TYPE_NORMAL
- en: '*smartmontools* is provided by the *smartmontools* package. It should install
    and start a systemd service automatically, which you can check with *systemctl*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the *smartctl* command to see if your disk has S.M.A.R.T. support. Look
    for the *SMART* support lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable and disable *smartctl* for each disk you want to monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the *-x* flag for a complete data dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the short health check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Use the *-Hc* flags to see the complete report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a short self-test and a long self-test. They tell you how long each
    test will take when you start them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It will not notify you when it is finished, and you can check the log file
    at any time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to update the hard drive database periodically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: S.M.A.R.T. is about 60% reliable. It could be better, but the S.M.A.R.T. standard
    leaves a lot of room for interpretation, and every drive manufacturer implements
    it differently. Manufacturer documentation is scarce, and the best resources I
    have found are Wikipedia and [*https://smartmontools.org*](https://smartmontools.org).
    As always, your best insurance is regular backups.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, it’s free, it’s easy to use, and often useful. Pay attention to the
    *Pre-fail* attributes (as in the following snippet), and review the introduction
    to this chapter on how to get better performance and reliability from your systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *sudo smartctl -a /dev/sda* to dump all the S.M.A.R.T. data. The section
    that tends to cause alarm is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `TYPE` column tells the type of the attributes, either `Pre-fail` or `Old_age`.
    When you see all those `Pre-fail` and `Old_age` labels, it doesn’t mean your disk
    is doomed, that is just the type of attribute on that row.
  prefs: []
  type: TYPE_NORMAL
- en: '`Pre-fail` is a critical attribute, one that may indicate imminent failure,
    and it is always included in health assessments.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Old_age` is a noncritical attribute; it is not included in disk health reports.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ID#` and `ATTRIBUTE_NAME` identify each attribute. These vary by manufacturer.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLAG` is the attribute handling flag, and has no relevance to disk health.'
  prefs: []
  type: TYPE_NORMAL
- en: The `VALUE` column displays the current values for the attributes. These range
    from 0-255, except for 0, 254, and 255\. 253 means “unused,” like when you have
    a new drive. `VALUE` is a scale from good to bad, with higher numbers being good
    and lower numbers bad, except the temperature attributes, which are temperatures
    in Celsius.
  prefs: []
  type: TYPE_NORMAL
- en: '`WORST` is the lowest value recorded for that attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: '`THRESH` is the lowest threshold for each attribute, and when a `Pre-fail`
    attribute falls below `THRESH`, then disk failure may be imminent.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UPDATED` is supposed to indicate when the attributes have been updated. Always
    is both online and offline, and Offline supposedly means only when offline tests
    are run. Usually this is inaccurate, and not all that helpful in any case.'
  prefs: []
  type: TYPE_NORMAL
- en: If an attribute enters a failed state, the time it failed is recorded in *WHEN_FAILED*.
  prefs: []
  type: TYPE_NORMAL
- en: '*RAW_VALUE* is particular to each manufacturer. Ignore it.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 smartctl*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 smartd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 update-smart-drivedb*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 smartd.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.7 Configuring smartmontools to Send Email Reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want email notifications of any problems emailed to you by *smartd*.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, check if you already have system mail set up and working by sending
    a test message to another user on the system, such as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Press 1 to read the message, and q to quit. This shows that system mail is
    already set up. If it is not, install *mailx* and *postfix*. *mailx* is a mail
    user agent (MUA), which is a mail client like Evolution, Thunderbird, KMail, Mutt,
    and so on. *postfix* is a mail transfer agent (MTA). You need both. After installation,
    check if they are running with *systemctl*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If they are not, enable and start them. Then try your test message again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '*smartd* is configured in */etc/smartd.conf* or */etc/smartmontools/smartd.conf*.
    The default is to scan for all possible devices and email error reports to the
    root user. It is better to configure which devices you want monitored. Every Linux
    has its own special configuration. The following should work on all of them, and
    of course you must specify your own disks and email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your configuration changes and reload *smartd.service*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default behavior in *smartd.conf* is to scan for all available drives. It
    is more efficient to specify the drives you want to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *-a* flag is the same as all of these combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '*-H*, check the S.M.A.R.T. health status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-f*, report Usage Attributes (*VALUE* and *WORST*) failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-t*, report changes in Prefailure and Usage Attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-l*, report increases in ATA errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-l selftest*, report increases in Self-Test Log errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-l selfteststs*, report changes of Self-Test execution status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-C 197*, report nonzero values of the current pending sector count'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-U 198*, report nonzero values of the offline pending sector count'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That covers all the important stuff, and of course you may tweak it to report
    whatever attributes you like.
  prefs: []
  type: TYPE_NORMAL
- en: '*-M test* sends the specified user (in the preceding example, *-m root@localhost*)
    a test message at every startup. You can remove this when you are confident it
    is working the way you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several packages that provide the *mail* binary: *mailutils*, *mailx*,
    *bsd-mailx*, and *s-nail*, to name a few. For a simple local mailer for system
    daemons to use, any of them will do the job, and the *mail* binary takes the same
    options on all of them.'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to use *postfix*, but can use any MTA that you prefer, such as
    Exim or Sendmail.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 smartd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 smartdconf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.8 Diagnosing a Sluggish System with top
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your system usually runs well, but now everything is bogging down and taking
    forever. Applications are taking a long time to start or shut down, or are slow
    to respond to user input. You need to find out the cause, and then fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fire up the *top* command to see which processes are using excessive system
    resources. CPU and memory hogs make your nice powerful system feel ancient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '*top* runs until you stop it, refreshing every few seconds and displaying processes
    in order from the most to least active. Press the q key to exit.'
  prefs: []
  type: TYPE_NORMAL
- en: This shows a wealth of information. The relevant bit is that `Web Content` is
    using 80.5% share of CPU time. Poorly constructed websites are a common cause
    of bringing your system to a halt. The fast way to correct this is to kill the
    offending process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Process IDs are in the left column. Press the k key to open the kill dialog.
    If the default PID to kill is correct, press the Enter key. Press Enter to accept
    the default *15/sigterm* to terminate the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If that does not kill the process, use the nuclear option, *9*, which is *sigkill*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If you do not have sufficient permissions to kill the process, start *top* with
    *sudo*. Or, run *sudo kill <pid>* in another terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Killing a process is not always the best solution. If the process is controlled
    by systemd, systemd may immediately restart it, or other processes may be dependent
    on it, and then you risk making a mess. If possible, shut it down with *systemctl
    stop <service name>*. If the offending process is not controlled by systemd, then
    go ahead and kill it.
  prefs: []
  type: TYPE_NORMAL
- en: The default PID to kill is always the one at the top, the one using the most
    system resources. If that is not the one you want to stop, you can enter a different
    PID.
  prefs: []
  type: TYPE_NORMAL
- en: What is this *sigterm* stuff, you ask? *Signals* are inherited from Unix, and
    are very crufty, with numerous variations added over the years that you can learn
    all about in *man 2 signal*, such as *SIGHUP*, *SIGINT*, *SIGQUIT*, and a host
    of others.
  prefs: []
  type: TYPE_NORMAL
- en: The two that are most pertinent to users and system administrators are *SIGKILL*
    and *SIGTERM*. Always try *SIGTERM* first, because it stops a process gracefully,
    ensuring that any child processes are handed off to *INIT* and not orphaned, and
    parent processes are informed. The one downside to *SIGTERM* is the process can
    elect to ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use *SIGKILL* only when *SIGTERM* is ineffective. *SIGKILL* cannot be ignored,
    and it also kills child processes, which may affect other processes. A process
    can be left in limbo as a zombie process because the parent is not informed. Zombie
    processes are no big deal by themselves, they just sit there not doing anything.
    You can see if you have any in the header of *top*, on the right side of the Tasks
    line. The following example shows two zombies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t need to do anything as the parent application should automatically
    clean them up. If it doesn’t, it’s not a big deal, unless it generates a horde
    of zombies. That tells you there is a problem with the application. You can’t
    kill zombies because they are already dead. They use a miniscule bit of system
    resources, but if you want to try getting rid of them, try sending them a *SIGCHLD*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If the same process keeps using excessive system resources, review the configuration
    file or settings of its program to see if there are errors, or if you can tune
    it to be more efficient. Check your logfiles ([Recipe 20.1](#rec-logfiles)) for
    clues.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 top*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 kill*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.9 Viewing Selected Processes in top
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to track just one or a small number of processes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start *top* with a comma-delimited list of the processes you want to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now you can keep an eye on what you want to see, without having to wade through
    the remaining hordes of processes. Press the equals sign key (=) to return to
    the complete process list.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 top*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 kill*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20.10 Escaping from a Frozen Graphical Desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There you were, working happily, when your graphical desktop froze. The cursor
    moves, but very slowly, or it does not move at all.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is one of my favorite Linux features: dropping to the console from a graphical
    session. Press Ctrl-Alt-F2, and you should find yourself at the plain-text console
    that lies underneath your graphical session ([Figure 20-5](#fig-trouble-5)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Linux console.](Images/lcb2_2005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-5\. The Linux console
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Log in, and now you can run some troubleshooting commands. Start with *top*
    to find the wayward process clogging your system and kill it, check log files,
    run other diagnostics, whatever you need to do. Once you have resolved the problem,
    press Alt-F7 to return to your graphical desktop. The worse case is you will have
    to shut down or reboot, which is better than a forced shutdown from pressing the
    power button.
  prefs: []
  type: TYPE_NORMAL
- en: The various Linuxes map these key combinations in different ways. Alt-F7 is
    traditional for the graphical session. Fedora uses Alt-F1\. It hurts nothing to
    try them all.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another option is to open an SSH session from another computer and try to unfreeze
    your graphical desktop.
  prefs: []
  type: TYPE_NORMAL
- en: To me this is the best of all worlds, having both the console and graphical
    environment available at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: A forced shutdown isn’t necessarily a disaster as it used to be, especially
    when you are using a journaling filesystem such as Ext4, XFS, or Btrfs.
  prefs: []
  type: TYPE_NORMAL
- en: The standard configuration is seven consoles, F1 through F7\. Each one is an
    independent login session.
  prefs: []
  type: TYPE_NORMAL
- en: Use Ctrl-Alt-F*n* to leave a graphical session and enter the console, and when
    you are in the console, use Alt-F*n*.
  prefs: []
  type: TYPE_NORMAL
- en: 20.11 Troubleshooting Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You think you have failing hardware and need to know how to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you suspect a hardware problem, first try the recipes in this chapter about
    hardware monitoring. Some system UEFI firmwares include hardware health monitors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the monitors do not point you in a clear direction, shut down the machine,
    open the case, clean out the dust, clean the filters if there are any, then remove
    and reseat everything that can be unplugged and reconnected: power cables, SATA
    cables, graphics adapters and other PCI expansion cards, memory modules, and fan
    connectors. Carefully reconnect everything, and pay special attention to reseating
    your memory modules correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Not Kill Your Hardware, or Yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be careful! Ground yourself by touching something else to discharge static electricity.
    Wear an anti-static wrist strap, and place your components on an anti-static mat.
    Unplug your machine, and NEVER touch anything inside the case while it is plugged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Test the power supply with a multimeter, if you know how to do this, or try
    a different power supply. Testing with a multimeter is fairly easy, and there
    are plenty of how-tos. If you have spare parts, swapping out a suspect component
    and trying a different one can pinpoint faulty hardware.
  prefs: []
  type: TYPE_NORMAL
- en: After you are finished and everything is back together, see if the problem is
    corrected. In my computer adventures a number of problems were solved by reseating
    the memory modules or moving them to different slots. Note that on most motherboards
    you must install RAM pairs in certain slots. Some issues related to RAM are data
    corruption, incomplete boots, and odd behaviors like when you press the power
    switch to start up your system, it fluctuates like the power supply is faulty,
    and does not start.
  prefs: []
  type: TYPE_NORMAL
- en: Make certain that your case fans are oriented the right way. Air must be pulled
    into the case, usually from the front and sides, and then evacuated out the back.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few hardware testers in Linux-land. Some vendors provide their
    own hardware and system testers; for example, Lenovo ThinkPads come with comprehensive
    testers that test every component on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '[GtkStressTesting](https://oreil.ly/7gEST) is a good utility for stress testing
    CPU, memory, and other components, and it extracts detailed motherboard information.
    Follow the instructions in the Setup Guide to install it on your system. It includes
    monitors similar to *lm-sensors*.'
  prefs: []
  type: TYPE_NORMAL
- en: One feature it does not have is I/O monitoring, which you need to spot performance
    bottlenecks. For this, use *iotop*, which monitors disk performance in a *top*-like
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It can be difficult to determine whether a problem is software or hardware.
    Be systematic and thorough, as hurrying takes longer. Use the available help for
    your Linux distribution, as there are always issues particular to each distro.
    Always read the release notes.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 iotop*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GtkStressTesting](https://oreil.ly/7gEST)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for your hardware components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your Linux distribution’s documentation, forums, wikis, and release notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10](Images/ch10.html#cha-discover-hardware)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 20.6](#rec-smartmon)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
