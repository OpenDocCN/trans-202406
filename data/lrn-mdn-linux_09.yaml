- en: Chapter 9\. Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final chapter is a bit of a mixed bag. We cover a range of topics, from
    virtual machines to security to new ways to use Linux. What the topics in this
    chapter have in common is that most of them are relevant for you only if you have
    a specific use case in mind, or if you require them in a professional setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off the chapter with how processes on a single machine can communicate
    and share data. There is a wealth of interprocess communication (IPC) mechanisms
    available, and here we focus on well-established and -used features: signals,
    named pipes, and Unix domain sockets.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we look at virtual machines (VMs). In contrast to the containers we discussed
    in [“Containers”](ch06.xhtml#containers) (which are good for application-level
    dependency management), VMs provide strong isolation for your workloads. You come
    across VMs most often in the context of the public cloud and in the general case
    in data centers. Having said that, using VMs locally can also be useful, such
    as for testing or to simulate distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: The next section in this chapter focuses on modern Linux distributions, which
    are usually container-centric and assume immutability. You’ll often find said
    distros in the context of distributed systems such as Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We then move on to selected security topics, covering Kerberos, a widely used
    authentication suite, and pluggable authentication modules (PAM), an extension
    mechanism Linux provides for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of this chapter, we review Linux solutions and use cases that,
    at the time of writing, are not yet mainstream. But they could be relevant to
    you and are worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Interprocess Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux there is a long list of [interprocess communication (IPC)](https://oreil.ly/tWp40)
    options available, ranging from pipes to sockets to shared memory. IPC enables
    processes to communicate, synchronize activities, and share data. For example,
    the [Docker daemon](https://oreil.ly/aZur8) uses configurable sockets to manage
    containers. In this section, we review some popular IPC options and their use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Signals*](https://oreil.ly/0y6ru) were originally developed as a way for
    the kernel to notify user space processes about a certain event. Think of signals
    as an asynchronous notification sent to a process. There are many signals available
    (use the `man 7 signal` command to learn more), and most of them come with a default
    action, such as stop or terminate the process.'
  prefs: []
  type: TYPE_NORMAL
- en: With most signals, you define a custom handler, rather than letting Linux carry
    on with the default action. This is useful when you want to, for example, do some
    clean-up work or simply ignore certain signals. [Table 9-1](#tab-signals) shows
    the most common signals that you should be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Common signals
  prefs: []
  type: TYPE_NORMAL
- en: '| Signal | Meaning | Default action | Handle option | Key combination |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGHUP` | Tell a daemon process to reread its config file | Terminate process
    | `nohup` or custom handler | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGINT` | User interruption from keyboard | Terminate process | Custom handler
    | Ctrl+C |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGQUIT` | User quit from keyboard | [core dump](https://oreil.ly/jeuEo)
    and terminate process | Custom handler | Ctrl+\ |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGKILL` | Kill signal | Terminate process | Cannot be handled | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGSTOP` | Stop process | Stop process | Cannot be handled | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTSTP` | User caused stop from keyboard | Stop process | Custom handler
    | Ctrl+Z |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTERM` | Graceful termination | Terminate process | Custom handler | N/A
    |'
  prefs: []
  type: TYPE_TB
- en: There are also signals that don’t have defined meanings (`SIGUSR1` and `SIGUSR2`)
    that processes can use to communicate with each other, sending asynchronous notification,
    if both parties agree on the semantics of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'One typical way to send a signal to a process is the somewhat strangely named
    `kill` command (due to its default behavior to cause processes to terminate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_topics_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We set up a very simple program here that simply sleeps. With `&`, we put it
    into the background.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_topics_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The shell job control confirms that our program runs as a job with ID 1 in the
    background and reports its PID (`17030`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_advanced_topics_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `ps`, we check if the program is still running.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_advanced_topics_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Here is our program (compare PID).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_advanced_topics_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `kill` sends the `SIGTERM` to the process, and the default action
    is to terminate the process gracefully. We provide `kill` with the PID of our
    process (`17030`), and since we didn’t register a custom handler, it is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll look at how to handle a signal with [`trap`](https://oreil.ly/pp6O4).
    This allows us to define a custom handler in a shell environment (command line
    or script):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_topics_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: With `trap "echo kthxbye" SIGINT`, we register a handler, telling Linux that
    when the user presses Ctrl+C (causing a `SIGINT` signal to be sent to our process),
    Linux should execute `echo kthxbye` before the default action (terminate).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_topics_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We see the user interruption (`^C` is the same as Ctrl+C) and then our custom
    handler getting executed, printing `kthxbye`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Signals are a simple yet powerful IPC mechanism, and now you know the basics
    of how to send and handle signals in Linux. Next up, we discuss two more elaborate
    and powerful IPC mechanisms—named pipes and UNIX domain sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Named Pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [“Streams”](ch03.xhtml#shell-streams), we talked about pipes (`|`) that you
    can use to pass data from one process to another by connecting the `stdout` of
    one process with `stdin` of another process. We call these pipes *unnamed*. Taking
    this idea a step further, [named pipes](https://oreil.ly/iHMrK) are pipes to which
    you can assign custom names.
  prefs: []
  type: TYPE_NORMAL
- en: Just like unnamed pipes, named pipes work with normal file I/O (`open`, `write`,
    etc.) and provide first in, first out (FIFO) delivery. Unlike unnamed pipes, the
    lifetime of a named pipe is not limited to the processes it’s used with. Technically,
    named pipes are a wrapper around pipes, using the `pipefs` pseudo filesystem (see
    [“Pseudo Filesystems”](ch05.xhtml#pseudo-fs)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a named pipe in action to better appreciate what you can do with
    them. We create a named pipe called `examplepipe` in the following, along with
    one publisher and one consumer process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_topics_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a named pipe called `examplepipe`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_topics_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the pipe with `ls` reveals its type: the first letter is a `p`,
    indicating it’s a named pipe we’re looking at.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_advanced_topics_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Using a loop, we publish the character `x` into our pipe. Note that unless some
    other process reads from `examplepipe`, the pipe is blocked. No further writing
    into it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_advanced_topics_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We launch a second process that reads from the pipe in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_advanced_topics_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: As a result of our setup we see `x` appearing on the terminal, roughly every
    five seconds. In other words, it appears every time the process with PID `19636`
    is able to read from the named pipe with `cat`.
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes are easy to use. Thanks to their design, they look and feel like
    normal files. But they’re also limited, since they support only one direction
    and one consumer. The next IPC mechanism we look at addresses these limitations.
  prefs: []
  type: TYPE_NORMAL
- en: UNIX Domain Sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already talked about sockets in the context of networking. There are
    also other kinds of sockets that work exclusively in the context of a single machine,
    and one such kind is called [UNIX domain sockets](https://oreil.ly/nCd6r): these
    are bidirectional, multiway communication endpoints. This means you can have multiple
    consumers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Domain sockets come in [three flavors](https://oreil.ly/AlVUf): stream-oriented
    (`SOCK_STREAM`), datagram-oriented (`SOCK_DGRAM`), and sequenced-packet (`SOCK_SEQPACKET`).
    The addressing works based on filesystem pathnames. Rather than having IP addresses
    and ports, a simple file path is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you would be using domain sockets [programmatically](https://oreil.ly/o8Ikj).
    However, you might find yourself in a situation where you need to troubleshoot
    a system and want to use, for example, the [`socat` tool](https://oreil.ly/lWjrs)
    from the command line to interact manually with a socket.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is about an established technique that allows us to emulate multiple
    VMs using a physical machine such as your laptop or a server in a data center.
    This yields a more flexible and powerful way to run different workloads, potentially
    from different tenants in a strongly isolated manner. We focus on hardware-assisted
    virtualization for x86 architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 9-1](#fig-virt), you see the virtualization architecture on a conceptual
    level, comprising the following (starting from the bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU
  prefs: []
  type: TYPE_NORMAL
- en: Must support hardware virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel-based virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: Found in the Linux kernel; discussed in [“Kernel-Based Virtual Machine”](#kvm).
  prefs: []
  type: TYPE_NORMAL
- en: Components in the user space
  prefs: []
  type: TYPE_NORMAL
- en: 'Components in the user space include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Virtual Machine Monitor (VMM)
  prefs: []
  type: TYPE_NORMAL
- en: Manages VMs and emulates virtual devices, such as [QEMU](https://www.qemu.org)
    and Firecracker (see [“Firecracker”](#firecracker)). There is also [libvirt](https://libvirt.org),
    a library that exposes a generic API aiming to standardize VMM, which you can
    use programmatically (not explicitly shown in the figure; consider it part of
    the VMM block).
  prefs: []
  type: TYPE_NORMAL
- en: The guest kernel
  prefs: []
  type: TYPE_NORMAL
- en: Typically also a Linux kernel but could also be Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The guest processes
  prefs: []
  type: TYPE_NORMAL
- en: Running on the guest kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0901](Images/lmlx_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Virtualization architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The processes that run natively on the host kernel (in [Figure 9-1](#fig-virt),
    process 1 and process 2) are isolated from the guest processes. This means that
    in general the physical CPU and memory of the host are not affected by guest activities.
    For example, if there’s an attack going on in the VM, the host kernel and processes
    are unaffected (as long as the VM is not given special access to the host system).
    Note that there may be exceptions to this in practice, such as [rowhammer](https://oreil.ly/L7qH9)
    or [Meltdown and Spectre](https://oreil.ly/ZlgRE).
  prefs: []
  type: TYPE_NORMAL
- en: Kernel-Based Virtual Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Kernel-based Virtual Machine (KVM)](https://oreil.ly/vTINW) is a Linux-native
    virtualization solution for x86 hardware that supports virtualization extensions,
    such as the case with [AMD-V](https://oreil.ly/XXAM8) or [Intel VT](https://oreil.ly/SAbNc).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to the KVM kernel modules: the core module (`kvm.ko`) and
    CPU architecture-specific modules (`kvm-intel.ko`/`kvm-amd.ko`). With KVM, the
    Linux kernel is the hypervisor, taking care of most of the heavy lifting. In addition,
    there are drivers such as the integrated [Virtio](https://oreil.ly/g37Qe) that
    allow for I/O virtualization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, hardware usually supports virtualization and KVM is already available,
    but in order to see if your system is capable of using KVM, you can do the following
    check (output edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_topics_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Search for `svm` or `vmx` in the CPU information (note that it reports on a
    per-CPU basis, so if you have eight cores, you would see this `flags` block repeated
    eight times).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_topics_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We see `vmx` is listed, so we’re good concerning hardware-assisted virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_advanced_topics_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we check if the KVM kernel modules are available.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_advanced_topics_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that we have the `kvm_intel` kernel module loaded, so we’re all
    set concerning KVM usage.
  prefs: []
  type: TYPE_NORMAL
- en: One modern way to manage KVMs is with Firecracker.
  prefs: []
  type: TYPE_NORMAL
- en: Firecracker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Firecracker](https://oreil.ly/UpNPK) is a VMM that can manage KVM instances.
    It is written in Rust and was developed at Amazon Web Services primarily for serverless
    offerings, such as AWS Lambda and AWS Fargate.'
  prefs: []
  type: TYPE_NORMAL
- en: Firecracker is [designed](https://oreil.ly/6D8Wk) to safely run multitenant
    workloads on the same physical machine. The Firecracker VMM manages so-called
    *microVMs* that expose an HTTP API to the host, allowing you to launch, query,
    and stop the microVMs. It emulates network interfaces by using [TUN/TAP devices](https://oreil.ly/ojWvm)
    on the host, and block devices are backed by files on the host, supporting Virtio
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, in addition to the virtualization discussed so
    far, Firecracker by default uses seccomp filters (see [“seccomp Profiles”](ch04.xhtml#seccomp))
    to limit the host system calls it can use. cgroups can also be used. From an observability
    point of view, you can gather logs and metrics from Firecracker, via named pipes.
  prefs: []
  type: TYPE_NORMAL
- en: With that we move on to modern Linux distributions that focus on immutability
    and leverage containers.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Linux Distros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most prominent traditional Linux distributions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Red Hat family (RHEL, Fedora, and CentOS/Rocky)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Debian-based family (Ubuntu, Mint, Kali, Parrot OS, elementary OS, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SUSE family (openSUSE and Enterprise)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gentoo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arch Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all perfectly fine distros. Depending on your needs and preferences,
    you can choose from being fully in control and taking care of everything yourself
    (from installation to patching) to having a fully managed offering where the distro
    takes care of most of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the rise of containers, as discussed in [“Containers”](ch06.xhtml#containers),
    the role of the host operating system has changed. In the context of containers,
    traditional package managers (see [“Packages and Package Managers”](ch06.xhtml#package-managers))
    play a different role: most base container images tend to be built from particular
    Linux distros, and dependencies are met within the containers with *.deb* or *.rpm*
    packages, while the container images package up all the application-level dependencies
    on top of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, making incremental changes to a system turns out to be a big challenge.
    This is especially true when you need to do it at scale, such as when you need
    to administrate a fleet of machines. Hence, for modern distros, the focus is increasingly
    on immutability. The idea is that any change in the configuration or code (think:
    a patch that fixes a security issue or a new feature) causes the creation of a
    new artifact, such as a container image that gets launched (in contrast to changing
    the running system).'
  prefs: []
  type: TYPE_NORMAL
- en: When I say “modern Linux distros,” I mean distros that are container-centric,
    with immutability and auto-upgrading (pioneered by Chrome) front and center. Let’s
    have a look at some examples of modern distros.
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat Enterprise Linux CoreOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2013, a young start-up called CoreOS made [CoreOS Linux (later renamed Container
    Linux)](https://oreil.ly/XjqPV) available. Its main features included a dual-partition
    scheme for system updates and the lack of a package manager. In other words, all
    apps would run as containers natively. In the ecosystem, a number of tools were
    developed that are still in use (such as `etcd`; think: a distributed version
    of the */etc* directory for configuration tasks).'
  prefs: []
  type: TYPE_NORMAL
- en: After Red Hat acquired CoreOS (the company), it announced the intention to merge
    the CoreOS Linux with Red Hat’s own Project Atomic (that had similar goals). This
    merger led to [Red Hat Enterprise Linux CoreOS (RHCOS)](https://oreil.ly/38kzX),
    which is not meant to be used on its own but in the context of the Red Hat Kubernetes
    distribution called OpenShift Container Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Flatcar Container Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A little bit after Red Hat announced its plans around Container Linux, a German
    startup called Kinvolk GmbH (now part of Microsoft) announced that it would fork
    and continue to develop Container Linux under the new brand name [Flatcar Container
    Linux](https://oreil.ly/rNJrt).
  prefs: []
  type: TYPE_NORMAL
- en: Flatcar describes itself as a container-native, lightweight operating system
    with use cases in container orchestrators such as Kubernetes and IoT/edge computing.
    It continues the CoreOS tradition of auto-upgrades (optional with its own update
    manager, [Nebraska](https://oreil.ly/Qepv6)) and has a powerful yet simple-to-use
    provisioning utility called [Ignition](https://oreil.ly/4vEQv) that enables you
    to have fine-grained control over boot devices (also used by RHCOS for that purpose).
    Further, there is no package manager; everything is running in containers. You
    can manage the life cycle of the containerized apps with `systemctl` on a single
    machine or more typically with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Bottlerocket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Bottlerocket](https://oreil.ly/fIKrQ) is a Linux-based operating system developed
    by AWS and meant for [hosting containers](https://oreil.ly/5Eaxd). Written in
    Rust, it is used in a number of their offerings, such as Amazon EKS and Amazon
    ECS.'
  prefs: []
  type: TYPE_NORMAL
- en: Akin to Flatcar and CoreOS, instead of a package manager, Bottlerocket uses
    an OCI image-based model for app upgrades and rollbacks. Bottlerocket uses a (by
    and large) read-only, integrity-checked filesystem based on [dm-verity](https://oreil.ly/xicaW).
    To gain access (via SSH, although discouraged) and control Bottlerocket, it runs
    a so-called [control container](https://oreil.ly/KB6eX), in a separate `containerd`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: RancherOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[RancherOS](https://oreil.ly/73UxM) is a Linux distro where everything is a
    container managed by Docker. Sponsored by Rancher (now SUSE), it is optimized
    for container workloads as in their Kubernetes distro. It runs two Docker instances:
    the system Docker, which runs as the first process, and the user Docker, which
    is used to create application containers. RancherOS has a small footprint, which
    makes it really great to use in the context of embedded systems and edge computing.'
  prefs: []
  type: TYPE_NORMAL
- en: Selected Security Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml#access-control), we discussed a number of access control
    mechanisms. We discussed *authentication* (*authn*, for short), which verifies
    the identity of a user and is a precondition for any sort of *authorization* (*authz*,
    for short). In this section, we briefly discuss two widely used authn tools that
    you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kerberos](https://kerberos.org) is an authn suite developed by the Massachusetts
    Institute of Technology in the 1980s. Today, it’s formally specified in [RFC 4120](https://oreil.ly/7woDK)
    and related IETF documents. The core idea of Kerberos is that we’re usually dealing
    with insecure networks, but we want a secure way for clients and services to prove
    their identity to one another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, the Kerberos authn process, shown in [Figure 9-2](#fig-kerberos),
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0902](Images/lmlx_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Kerberos protocol concept
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A client (for example, a program on your laptop) sends a request to a Kerberos
    component called the Key Distribution Center (KDC), asking for credentials for
    a given service, such as printing or a directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KDC responds with the requested credentials—that is, a ticket for the service
    and a temporary encryption key (session key).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client transmits the ticket (which contains the client’s identity and a
    copy of the session key) to the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The session key, shared by the client and service, is used to authenticate the
    client and may optionally be used to authenticate the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are also challenges with Kerberos, such as the central role that the KDC
    plays (a single point of failure) and its strict time requirements (it requires
    clock synchronization between the client and the server via NTP). Overall, while
    not simple to operate and administrate, Kerberos is widely used and supported
    in the enterprise and cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable Authentication Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Historically, a program would manage the user authentication process itself.
    With [pluggable authentication modules (PAM)](http://www.linux-pam.org), a flexible
    way to develop programs that are independent of a concrete authentication scheme
    has arrived in Linux (PAM has been around since the end of the 1990s in the wider
    UNIX ecosystem). PAM uses a modular architecture, providing developers a powerful
    library to interface with it. It also allows system administrators to plug in
    different modules, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`pam_localuser`](https://oreil.ly/NCs0A)'
  prefs: []
  type: TYPE_NORMAL
- en: Requires that a user is listed in */etc/passwd*
  prefs: []
  type: TYPE_NORMAL
- en: '[`pam_keyinit`](https://oreil.ly/PkGt9)'
  prefs: []
  type: TYPE_NORMAL
- en: For session keyrings
  prefs: []
  type: TYPE_NORMAL
- en: '[`pam_krb5`](https://oreil.ly/YinOv)'
  prefs: []
  type: TYPE_NORMAL
- en: For Kerberos 5 password-based checks
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve reached the end of the advanced security topics and now turn
    to more aspirational topics.
  prefs: []
  type: TYPE_NORMAL
- en: Other Modern and Future Offerings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we look at exciting Linux offerings, including new ways to
    set up Linux and ways to work with Linux in new environments. In the server world
    (be it an on-premises data center or the public cloud), Linux is already the de
    facto standard, and Linux is under the hood in many mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: What the topics here in this section have in common is that at the time of writing,
    they have not yet entered the mainstream. However, if you’re curious about what
    future developments might look like or where there’s still high growth potential
    for Linux, read on.
  prefs: []
  type: TYPE_NORMAL
- en: NixOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[NixOS](https://nixos.org) is a source-based Linux distro, taking a functional
    approach to package management and system configuration as well as rollbacks for
    upgrades. I call this a “functional approach” because the artifacts are based
    on immutability.'
  prefs: []
  type: TYPE_NORMAL
- en: The [Nix package manager](https://oreil.ly/Km84W) builds the entire operating
    system, from the kernel to system packages and apps. Nix offers multiuser package
    management and even allows you to install and use multiple versions of the same
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most other Linux distros, NixOS does not follow the Linux Standard Base
    filesystem layout as discussed in [“Common Filesystem Layouts”](ch05.xhtml#common-fs-layouts)
    (with system programs located in */usr/bin*, */usr/lib*, and so on, and the configuration
    usually located in */etc*).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of interesting ideas in NixOS and its ecosystem, making it
    especially relevant for CI pipelines. Even if you don’t want to go all in, you
    can, for example, use the Nix package manager standalone (outside of NixOS).
  prefs: []
  type: TYPE_NORMAL
- en: Linux on the Desktop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the viability of [Linux on the desktop](https://oreil.ly/eBPYT) is subject
    to ongoing discussions, there is without doubt plenty of choice concerning desktop-friendly
    distros and with them a selection of [window managers](https://oreil.ly/qylKC).
  prefs: []
  type: TYPE_NORMAL
- en: In good UNIX tradition, the Graphical User Interface (GUI) part is separated
    from the rest of the operating system. Usually, an [X window manager](https://oreil.ly/bTcHy)
    takes care of the GUI responsibilities (from window management to styling and
    rendering) with the help of a [display manager](https://oreil.ly/hl5gv).
  prefs: []
  type: TYPE_NORMAL
- en: On top of the window manager, implementing a desktop experience (such as icons,
    widgets, and toolbars), sit the [desktop environments](https://oreil.ly/y1VIr),
    such as KDE or MATE.
  prefs: []
  type: TYPE_NORMAL
- en: There are many beginner-friendly desktop Linux distros available nowadays, making
    it easy to switch from Windows or macOS. The same is true for a range of open
    source applications, from office apps (writing docs or working with spreadsheets,
    such as LibreOffice) to drawing and image editing (Gimp), to all major web browsers,
    games, media players, and utilities, to development environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The catalyst for Linux on the desktop might in fact come from a rather unexpected
    direction: with [Windows 11 allowing you to run graphical Linux apps](https://oreil.ly/tGgaf)
    out of the box, this might change the incentives and uptake for good. Time will
    tell.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux on Embedded Systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Linux on embedded systems](https://oreil.ly/mFKVR) is a wide field, with implementations
    ranging from cars to networking equipment (such as routers), to smart home devices
    (for example fridges) and media devices/smart TVs.'
  prefs: []
  type: TYPE_NORMAL
- en: One particularly interesting generic platform you can acquire for little money
    is a [Raspberry Pi (RPI)](https://www.raspberrypi.org). It comes with its own
    Linux distro called Raspberry Pi OS (a Debian-based system) and lets you install
    this and other Linux distros simply via a microSD card. The RPI has a number of
    General Purpose Input/Outputs (GPIOs), making it straightforward to use external
    sensors and circuits via a breadboard. You can experiment with, and learn electronics
    and program the hardware with, for example, Python.
  prefs: []
  type: TYPE_NORMAL
- en: Linux in Cloud IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, the viability of cloud-based development environments has made
    enormous progress to a point where now (commercial) offerings exist that combine
    an IDE (usually Visual Studio Code), Git, and a range of programming languages
    in a Linux environment. All you as a developer need is a web browser and network
    access, and you can edit, test, and run code “in the cloud.”
  prefs: []
  type: TYPE_NORMAL
- en: Two notable examples of Cloud IDEs, at the time of writing, are [Gitpod](https://www.gitpod.io),
    which is available either as a managed offering or as an open source to host yourself,
    and [Codespaces](https://oreil.ly/bWNDT), which is deeply integrated into GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered advanced topics and refined your knowledge of basic techniques
    and tooling. If you want to enable IPC, you can use signals and named pipes. For
    isolating workloads, you can use VMs, especially modern variants such as Firecracker.
    We also discussed modern Linux distributions: if you plan to run containers (Docker),
    you may want to consider these container-centric distros that enforce immutability.
    We then moved on to selected security topics, specially Kerberos and PAM for flexible
    and/or large-scale authentication. Finally, we reviewed not-yet-mainstream Linux
    solutions such as Linux on the desktop and how you can get started with Linux
    on embedded systems, such as the Raspberry Pi, for local experimentation or development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some further reading for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: IPC
  prefs: []
  type: TYPE_NORMAL
- en: '[“An Introduction to Linux IPC”](https://oreil.ly/C2iwX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Inter-process Communication in Linux: Using Pipes and Message Queues”](https://oreil.ly/cbi1Z)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“The Linux Kernel Implementation of Pipes and FIFOs”](https://oreil.ly/FUvoo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Socat Cheatsheet”](https://oreil.ly/IwiyP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMs
  prefs: []
  type: TYPE_NORMAL
- en: '[“What Is a Virtual Machine?” (VMware)](https://oreil.ly/vJ9Uf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“What Is a Virtual Machine (VM)?” (Red Hat/IBM)](https://oreil.ly/wJEG1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Create and Manage KVM Virtual Machines from CLI”](https://oreil.ly/cTH8b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“KVM” via Debian Wiki](https://oreil.ly/XLVwj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[QEMU machine emulator and virtualizer website](https://oreil.ly/wDCrH)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Firecracker website](https://oreil.ly/yIOxz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern distros
  prefs: []
  type: TYPE_NORMAL
- en: '[“Containers and Clustering”](https://oreil.ly/Z8ZNC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Immutability & Loose Coupling: A Match Made in Heaven”](https://oreil.ly/T89ed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Tutorial: Install Flatcar Container Linux on Remote Bare Metal Servers”](https://oreil.ly/hZN1b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of image-based Linux distributions and associated tooling](https://oreil.ly/gTav0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Security Features of Bottlerocket, an Open Source Linux-Based Operating System”](https://oreil.ly/Bfj7l)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“RancherOS: A Simpler Linux for Docker Lovers”](https://oreil.ly/61t6G)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selected security
  prefs: []
  type: TYPE_NORMAL
- en: '[“Kerberos: The Network Authentication Protocol”](https://oreil.ly/rSPKm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“PAM Tutorial”](https://oreil.ly/Pn9fL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other modern and future offerings
  prefs: []
  type: TYPE_NORMAL
- en: '[“How X Window Managers Work, and How to Write One”](https://oreil.ly/LryXW)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Purely Functional Linux with NixOS”](https://oreil.ly/qY62s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“NixOS: Purely Functional System Configuration Management”](https://oreil.ly/8YALG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“What Is a Raspberry Pi?”](https://oreil.ly/wnHxa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Kubernetes on Raspberry Pi 4b with 64-bit OS from Scratch”](https://oreil.ly/cnAsx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ve reached the end of the book. I hope this is the start of your own Linux
    journey. Thanks for staying with me, and if you have feedback, I’m always interested
    to hear from you, either via Twitter or via good old email: *modern-linux@pm.me*.'
  prefs: []
  type: TYPE_NORMAL
