- en: Chapter 2\. Getting Started with OpenShift and Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 使用OpenShift和Kubernetes入门
- en: In this chapter, we cover a variety of topics that present a foundational understanding
    of Kubernetes and OpenShift. We begin with an overview of the Kubernetes architecture
    and then describe several deployment options that will enable you to get both
    a basic Kubernetes environment and an OpenShift environment up and running. Next,
    we give an introduction to the command-line tools `kubectl` and `oc`, which are
    used for interacting with Kubernetes and OpenShift respectively. We then introduce
    a short review of the fundamental Kubernetes concepts of pods, deployments, and
    service accounts. In the second half of this chapter, we present several enhancement
    concepts that OpenShift provides over traditional Kubernetes. We then conclude
    this chapter with a discussion of more advanced topics that are often used when
    running Kubernetes or OpenShift in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了多个主题，这些主题提供了对Kubernetes和OpenShift的基础理解。我们首先概述了Kubernetes的架构，然后描述了几种部署选项，这些选项将使您能够同时启动基本的Kubernetes环境和OpenShift环境。接下来，我们介绍了用于与Kubernetes和OpenShift交互的命令行工具`kubectl`和`oc`。然后，我们简要回顾了Pods、Deployments和Service
    Accounts等基本Kubernetes概念。在本章的后半部分，我们介绍了OpenShift相比传统Kubernetes提供的几个增强概念。最后，我们讨论了在生产环境中运行Kubernetes或OpenShift时常用的更高级的主题。
- en: Kubernetes Architecture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes架构
- en: 'The [Kubernetes architecture](https://oreil.ly/QEYUe) at a high level is relatively
    straightforward. It is composed of a *master node* and a set of *worker nodes*.
    The nodes can be either physical servers or VMs. Users of the Kubernetes environment
    interact with the master node using either a CLI (`kubectl`), an API, or a GUI.
    The master node is responsible for scheduling work across the worker nodes. In
    Kubernetes, the unit of work that is scheduled is called a *pod*, and a pod can
    hold one or more containers. The primary components that exist on the master node
    are the *kube-apiserver*, *kube-scheduler*, *kube-controller-manager,* and *etcd*:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubernetes架构](https://oreil.ly/QEYUe)在高层次上相对简单。它由*主节点*和一组*工作节点*组成。节点可以是物理服务器或虚拟机。Kubernetes环境的用户可以使用CLI（`kubectl`）、API或GUI与主节点交互。主节点负责在工作节点上安排工作。在Kubernetes中，调度的工作单元称为*Pod*，一个Pod可以包含一个或多个容器。存在于主节点上的主要组件包括*kube-apiserver*、*kube-scheduler*、*kube-controller-manager*和*etcd*：'
- en: kube-apiserver
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: kube-apiserver
- en: The kube-apiserver makes available the Kubernetes API that is used to operate
    the Kubernetes environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: kube-apiserver提供了用于操作Kubernetes环境的Kubernetes API。
- en: kube-scheduler
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: The kube-scheduler component is responsible for selecting the nodes on which
    pods should be created.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: kube-scheduler组件负责选择应在其上创建Pod的节点。
- en: kube-controller-manager
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: Kubernetes provides several high-level abstractions for supporting replicas
    of pods, managing nodes, and so on. Each of these is implemented with a controller
    component, which we describe later in this chapter. The kube-controller-manager
    is responsible for managing and running controller components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了几个支持Pod副本、管理节点等高级抽象。每个抽象都是通过控制器组件实现的，我们稍后在本章中描述。kube-controller-manager负责管理和运行控制器组件。
- en: etcd
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: etcd
- en: The etcd component is a distributed key-value store and is the primary datastore
    of the Kubernetes control plane. This component stores and replicates all the
    critical information states of your Kubernetes environment. The key feature of
    etcd is its ability to support a watch. A *watch* is a remote procedure call (RPC)
    mechanism that allows for callbacks to functions on key-value create, update,
    or delete operations. Kubernetes’s outstanding performance and scalability characteristics
    depend on etcd being a highly efficient data storage mechanism.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: etcd组件是一个分布式键值存储，是Kubernetes控制平面的主要数据存储。该组件存储并复制您的Kubernetes环境的所有关键信息状态。etcd的关键特性是其支持观察功能。*观察*是一种远程过程调用（RPC）机制，允许在键值的创建、更新或删除操作时进行回调函数。Kubernetes的优秀性能和可伸缩性特性依赖于etcd作为高效的数据存储机制。
- en: 'The worker nodes are responsible for running the pods that are scheduled on
    them. The primary Kubernetes components that exist on worker nodes are the `kubelet`,
    *kube-proxy*, and *container runtime*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点负责运行在其上调度的Pod。存在于工作节点上的主要Kubernetes组件包括`kubelet`、*kube-proxy*和*容器运行时*：
- en: '`kubelet`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubelet`'
- en: The `kubelet` is responsible for making sure that the containers in each pod
    are created and stay up and running. The `kubelet` will restart containers upon
    recognizing that they have terminated unexpectedly or failed other health checks
    defined by the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubelet` 负责确保每个 Pod 中的容器被创建并保持运行状态。当 `kubelet` 发现容器异常终止或者未通过用户定义的其他健康检查时，它将重新启动容器。'
- en: kube-proxy
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy
- en: One of Kubernetes’s key strengths is the networking support it implements for
    containers. The kube-proxy component provides networking support in the form of
    connection forwarding, load balancing, and mapping of a single IP address to a
    pod. Kube-proxy is unique in that it gives a distributed load-balancing capability
    that is critical to the high availability architecture of Kubernetes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的关键优势之一是它为容器实现的网络支持。kube-proxy 组件提供连接转发、负载均衡以及将单个 IP 地址映射到 Pod 的网络支持。kube-proxy
    的独特之处在于，它提供了分布式负载均衡能力，这对 Kubernetes 的高可用架构至关重要。
- en: container runtime
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时
- en: The container runtime component is responsible for running the containers that
    exist in each pod. Kubernetes supports several container runtime environment options,
    including Docker, `rkt`, CRI-O, and containerd.^([1](ch02.html#ch01fn14))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时组件负责运行每个 Pod 中存在的容器。Kubernetes 支持多种容器运行时环境选项，包括 Docker、`rkt`、CRI-O 和 containerd。^([1](ch02.html#ch01fn14))
- en: '[Figure 2-1](#graphical_representation_of_the_kubernet) shows a graphical representation
    of the Kubernetes architecture encompassing a master node and two worker nodes.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](#graphical_representation_of_the_kubernet)展示了 Kubernetes 架构的图形表示，包括一个主节点和两个工作节点。'
- en: '![](assets/hcok_0201.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0201.png)'
- en: Figure 2-1\. Graphical representation of the Kubernetes architecture
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. Kubernetes 架构的图形表示
- en: As shown in [Figure 2-1](#graphical_representation_of_the_kubernet), users interact
    with the Kubernetes API server using either a GUI or by `kubectl` CLI. Both of
    these use the Kubernetes API to interact with the kube-apiserver on the Kubernetes
    master node. The Kubernetes master node’s kube-scheduler component schedules pods
    to run on different worker nodes. Each pod contains one or more containers and
    is assigned its own IP address.In many real-world applications, Kubernetes deploys
    multiple replicas (running copies) of the same pod to improve scalability and
    ensure high availability. Pods A1 and A2 are pod replicas that differ only in
    the IP address they are allocated. Similarly, Pods B1 and B2 are also replica
    copies of the same pod. The containers located in the same pod are permitted to
    communicate with one another using standard interprocess communication (IPC) mechanisms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 [图 2-1](#graphical_representation_of_the_kubernet) 所示，用户可以通过 GUI 或者 `kubectl`
    CLI 与 Kubernetes API 服务器进行交互。这两者都使用 Kubernetes API 与运行在 Kubernetes 主节点上的 kube-apiserver
    进行交互。Kubernetes 主节点的 kube-scheduler 组件负责将 Pod 调度到不同的工作节点上。每个 Pod 包含一个或多个容器，并分配有自己的
    IP 地址。在许多实际应用中，Kubernetes 部署同一个 Pod 的多个副本以提高可扩展性并确保高可用性。Pod A1 和 A2 是不同 IP 地址的
    Pod 副本。同样，Pod B1 和 B2 也是同一个 Pod 的副本。同一个 Pod 中的容器允许使用标准的进程间通信（IPC）机制进行通信。
- en: In the next section, we present several approaches to getting OpenShift and
    Kubernetes environments up and running.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍几种启动和运行 OpenShift 和 Kubernetes 环境的方法。
- en: Deployment Options for Kubernetes and OpenShift
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 的部署选项
- en: Kubernetes and OpenShift have both reached incredible levels of popularity.
    As a result, several options are available for deploying either basic Kubernetes
    or Red Hat’s OpenShift Kubernetes distribution. In the following sections, we
    summarize the different types of deployment options that are currently available,
    including Red Hat’s CodeReady Containers, IBM Cloud, and several OpenShift deployment
    options.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 都已经达到了令人难以置信的流行水平。因此，现在有多种选择可以部署基本的 Kubernetes 或者 Red
    Hat 的 OpenShift Kubernetes 发行版。在接下来的几节中，我们将总结当前可用的不同部署选项，包括 Red Hat 的 CodeReady
    Containers、IBM Cloud 和多种 OpenShift 部署选项。
- en: Red Hat’s CodeReady Containers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Red Hat 的 CodeReady Containers
- en: Red Hat provides a minimal preconfigured OpenShift version 4 cluster called
    [CodeReady Containers](https://oreil.ly/1rI07) that you can run on your laptop
    or desktop computer. The CodeReady OpenShift environment is intended to be used
    for development and testing purposes. CodeReady Containers provide a fully functional
    cloud development environment on your local machine and contain all the tooling
    necessary for you to develop container-based applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat 提供了一个名为 [CodeReady Containers](https://oreil.ly/1rI07) 的最小预配置 OpenShift
    4 版本集群，您可以在笔记本电脑或台式计算机上运行。CodeReady OpenShift 环境旨在用于开发和测试目的。CodeReady Containers
    在您的本地机器上提供了一个功能完整的云开发环境，并包含您开发基于容器的应用程序所需的所有工具。
- en: IBM Cloud
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IBM Cloud
- en: '[IBM Cloud](https://cloud.ibm.com) gives users their choice of either a traditional
    Kubernetes cluster or a Red Hat OpenShift cluster. IBM Cloud’s Kubernetes offering
    is a cloud service providing Kubernetes as a Service that brings all of the standard
    Kubernetes features, including intelligent scheduling, self-healing, horizontal
    scaling, service discovery and load balancing, automated rollout and rollbacks,
    and secret and configuration management. In addition, IBM Cloud’s Kubernetes Service
    includes automated operations for cluster deployment, updates, and scaling, expert
    security, optimized configuration, and seamless integration with the IBM Cloud
    Infrastructure platform. It produces highly available multizone clusters across
    6 regions and 35 datacenters. IBM Cloud offers both a free Kubernetes cluster
    with over 40 free services and pay-as-you-go options.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[IBM Cloud](https://cloud.ibm.com) 提供用户选择传统的 Kubernetes 集群或 Red Hat OpenShift
    集群的选项。IBM Cloud 的 Kubernetes 提供的是作为服务的云服务，提供标准的 Kubernetes 功能，包括智能调度、自愈能力、水平扩展、服务发现和负载平衡、自动发布和回滚以及秘密和配置管理。此外，IBM
    Cloud 的 Kubernetes 服务包括集群部署、更新和扩展的自动化操作，专家级安全性，优化的配置以及与 IBM Cloud 基础设施平台的无缝集成。它在
    6 个区域和 35 个数据中心提供高可用的多区域集群。IBM Cloud 提供一个免费的 Kubernetes 集群，包括超过 40 个免费服务以及按使用量付费的选项。'
- en: IBM Cloud also provides users with highly available, fully managed [OpenShift
    clusters](https://oreil.ly/qsOdD). IBM’s OpenShift offering implements unique
    security and productivity capabilities designed to eliminate substantial time
    spent on updating, scaling, and provisioning. Additionally, IBM Cloud’s OpenShift
    delivers the resiliency to handle unexpected surges and protects against attacks
    that can lead to financial and productivity losses. In addition to pay-as-you-go
    and subscription options, IBM Cloud offers a free preconfigured OpenShift version
    4.3 environment that is available for four hours at no charge.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Cloud 还为用户提供高可用的完全托管的 [OpenShift 集群](https://oreil.ly/qsOdD)。IBM 的 OpenShift
    提供了独特的安全性和生产力功能，旨在减少更新、扩展和配置的大量时间。此外，IBM Cloud 的 OpenShift 具备处理意外涌入并保护免受可能导致财务和生产力损失的攻击的韧性。除按使用量付费和订阅选项外，IBM
    Cloud 还提供一个免费的预配置 OpenShift 4.3 环境，可免费使用四小时。
- en: OpenShift Deployment Options
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenShift 部署选项
- en: Several deployment options for OpenShift are defined at the [Getting Started
    with OpenShift](https://www.openshift.com/try) website. The options described
    include installing OpenShift version 4 on your laptop, deploying it in your datacenter
    or public cloud, or having Red Hat manage OpenShift for you. In addition, Red
    Hat offers hands-on OpenShift tutorials and playground OpenShift environments
    for unstructured learning and experimentation. [Figure 2-2](#openshift_deployment_options_available_a)
    shows the myriad of OpenShift deployment options available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Getting Started with OpenShift](https://www.openshift.com/try) 网站上定义了几种 OpenShift
    的部署选项。所描述的选项包括在笔记本电脑上安装 OpenShift 4 版本，在数据中心或公共云中部署，或让 Red Hat 为您管理 OpenShift。此外，Red
    Hat 还提供了实验性学习和实验的 Playground OpenShift 环境以及操作 OpenShift 的实际教程。[Figure 2-2](#openshift_deployment_options_available_a)
    展示了可用的多样化 OpenShift 部署选项。
- en: '![](assets/hcok_0202.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0202.png)'
- en: Figure 2-2\. OpenShift deployment options available at [Get Started with OpenShift](https://www.openshift.com/try)
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 在 [Get Started with OpenShift](https://www.openshift.com/try) 上提供的 OpenShift
    部署选项
- en: In the next section, we describe the command-line tools used for interacting
    with these platforms.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述与这些平台交互所使用的命令行工具。
- en: Kubernetes and OpenShift Command-Line Tools
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 命令行工具
- en: As discussed in [Chapter 1](ch01.html#kubernetes_and_openshift_overview), OpenShift
    provides a 100% conformant Kubernetes platform and supplements it with a variety
    of tools and capabilities focused on improving the productivity of developers
    and IT operations. In this section, we begin with an introduction to `kubectl`
    and `oc`, which are the standard command-line tools used for interacting with
    Kubernetes and OpenShift respectively. We present several concepts that OpenShift
    uses to represent the enhancements it serves over traditional Kubernetes. OpenShift
    concepts that we describe include authentication, projects, applications, security
    contexts, and image streams.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](ch01.html#kubernetes_and_openshift_overview)中讨论的那样，OpenShift提供了一个符合100%标准的Kubernetes平台，并通过各种工具和功能增强了开发人员和IT运营的生产力。在本节中，我们首先介绍了`kubectl`和`oc`，这两个是用于与Kubernetes和OpenShift交互的标准命令行工具。我们介绍了OpenShift用来表示其对传统Kubernetes的增强的几个概念，包括身份验证、项目、应用程序、安全上下文和镜像流。
- en: 'After covering some core concepts in Kubernetes, the next sections give several
    examples in the form of YAML files. For all Kubernetes environments, the samples
    included can be run using the standard Kubernetes command-line tool `kubectl`.
    Many Kubernetes environments, including the ones mentioned earlier in this chapter,
    describe how `kubectl` can be installed. Once you have your Kubernetes environment
    up and running and `kubectl` installed, all of the YAML file samples in the following
    sections can be run by first saving the YAML to a file (e.g., *kubesample1.yaml*)
    and then by running the following `kubectl` command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了Kubernetes的一些核心概念后，接下来的章节以YAML文件的形式给出了几个示例。对于所有的Kubernetes环境，可以使用标准的Kubernetes命令行工具`kubectl`来运行所包含的样本。许多Kubernetes环境，包括本章节早前提到的那些，描述了如何安装`kubectl`。一旦你的Kubernetes环境准备就绪并且安装了`kubectl`，可以通过首先将YAML保存到文件（例如*kubesample1.yaml*），然后运行以下`kubectl`命令来运行以下章节中的所有YAML文件样本：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As previously discussed, the OpenShift distribution of Kubernetes adds several
    new enhancements and capabilities beyond those used by traditional Kubernetes.
    OpenShift provides access to these features by extending the capabilities of `kubectl`.
    To make it explicit that the OpenShift version of `kubectl` has extended functionality,
    OpenShift renamed its version of `kubectl` to be a new command-line tool called
    `oc.` Thus, the following is equivalent to the previous `kubectl` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OpenShift对Kubernetes的分发增加了几个新的增强功能和能力。OpenShift通过扩展`kubectl`的功能来提供对这些功能的访问。为了明确OpenShift版本的`kubectl`具有扩展功能，OpenShift将其版本的`kubectl`重命名为一个称为`oc`的新命令行工具。因此，以下命令等同于之前的`kubectl`命令：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to one-for-one matching support for all `kubectl` commands, `oc`
    adds commands for administrative functions like managing roles and role bindings
    for users and groups.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有`kubectl`命令的一对一匹配支持外，`oc`还添加了用于管理用户和组的角色和角色绑定等管理功能的命令。
- en: For more information on the breadth of commands available from the OpenShift
    `oc` CLI, please see the [OpenShift command line documentation](https://oreil.ly/7NQW3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解有关OpenShift `oc` CLI可用命令的详细信息，请参阅[OpenShift命令行文档](https://oreil.ly/7NQW3)。
- en: Kubernetes Fundamentals
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes基础知识
- en: Kubernetes has several concepts that are specific to its model for managing
    containers. In this section we briefly review key Kubernetes concepts, including
    pods, deployments, and service accounts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes有几个特定于其容器管理模型的概念。在本节中，我们简要回顾了关键的Kubernetes概念，包括Pods、Deployments和Service
    Accounts。
- en: What’s a Pod?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Pod？
- en: 'Because Kubernetes supports the management and orchestration of containers,
    you would assume that the smallest deployable unit supported by Kubernetes would
    be a container. However, the designers of Kubernetes learned from experience^([2](ch02.html#ch01fn15))
    that it was more optimal to have the smallest deployable unit be something that
    could hold multiple containers. In Kubernetes, this smallest deployable unit is
    called a *pod*. A pod can hold one or more application containers. The application
    containers that are in the same pod have the following benefits:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Kubernetes支持容器的管理和编排，你可能会认为Kubernetes支持的最小部署单元应该是一个容器。然而，Kubernetes的设计者从经验中学到（参见[2](ch02.html#ch01fn15)），将最小部署单元定义为能够容纳多个容器的东西更为优化。在Kubernetes中，这个最小的部署单元称为*Pod*。一个Pod可以容纳一个或多个应用容器。处于同一个Pod中的应用容器具有以下优势：
- en: They share an IP address and port space
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们共享一个IP地址和端口空间。
- en: They share the same hostname
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们共享相同的主机名
- en: They can communicate with one another using native IPC
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用本地 IPC 进行通信。
- en: In contrast, application containers that run in separate pods are guaranteed
    to have different IP addresses and different hostnames. Essentially, containers
    in different pods should be viewed as running on different servers even if they
    ended up on the same node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，运行在单独 pod 中的应用程序容器保证具有不同的 IP 地址和不同的主机名。实际上，即使它们最终在同一节点上运行，不同 pod 中的容器应被视为运行在不同的服务器上。
- en: 'Kubernetes contributes a robust set of features that make pods easy to use:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一系列强大的功能，使得 pod 的使用变得非常简单：
- en: Easy-to-use pod management API
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 易于使用的 pod 管理 API
- en: Kubernetes provides the `kubectl` CLI, which supports a variety of operations
    on pods, including creating, viewing, deleting, updating, interacting, and scaling
    pods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供 `kubectl` CLI，支持对 pod 进行各种操作，包括创建、查看、删除、更新、交互和扩展 pod。
- en: File copy support
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 支持文件复制
- en: Kubernetes makes it very easy to copy files back and forth between your local
    host machine and your pods running in the cluster.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 可以非常方便地在本地主机和集群中运行的 pod 之间传输文件。
- en: Connectivity from your local machine to your pod
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地主机连接到 pod 的网络
- en: In many cases, you will want to have network connectivity from your local host
    machine to your pods running in the cluster. Kubernetes supports port forwarding
    whereby a network port on your local host machine is connected via a secure tunnel
    to a port on your pod that is running in the cluster. This is an excellent feature
    to assist in debugging applications and services without having to expose them
    publicly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您希望从本地主机到集群中运行的 pod 的网络连接。Kubernetes 支持端口转发，通过安全隧道将本地主机上的网络端口连接到集群中运行的
    pod 上的端口。这是一个极好的功能，有助于在不公开暴露应用程序和服务的情况下进行调试。
- en: Volume storage support
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 支持卷存储
- en: Kubernetes pods support the attachment of remote network storage volumes to
    enable the containers in pods to access persistent storage that remains long after
    the lifetime of the pods and the containers that initially utilized the storage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes pod 支持将远程网络存储卷附加到使 pod 中的容器能够访问持久存储的 pod，这些存储可以在 pod 和最初使用存储的容器的生命周期之后继续存在。
- en: Probe-based health-check support
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 基于探针的健康检查支持
- en: Kubernetes provides health checks in the form of probes to ensure that the main
    processes of your containers are still running. In addition, Kubernetes administers
    liveness checks that ensure the containers are actually functioning and capable
    of doing real work. With this health-check support, Kubernetes can recognize if
    your containers have crashed or become nonfunctional and restart them on your
    behalf.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了探针形式的健康检查，以确保容器的主要进程仍在运行。此外，Kubernetes 还提供了活跃性检查，以确保容器实际上正在运行并能够执行真正的工作。借助这种健康检查支持，Kubernetes
    可以识别您的容器是否已崩溃或变得无法正常工作，并代表您重新启动它们。
- en: How Do I Describe What’s in My Pod?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何描述我的 pod 内容？
- en: 'Pods and all other resources managed by Kubernetes are described using a YAML
    file. The following is a simple YAML file that describes a rudimentary pod resource:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 和 Kubernetes 管理的所有其他资源都使用 YAML 文件进行描述。以下是描述基本 pod 资源的简单 YAML 文件示例：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This YAML file contains the following fields and sections:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 YAML 文件包含以下字段和部分：
- en: '`apiVersion`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion`'
- en: This field is used to declare which version of the Kubernetes API schema is
    being used. Kubernetes continues to experience rapid growth in features and functionality.
    It manages the complexity that results from its growth in capabilities by supporting
    multiple versions of its API. By setting the `apiVersion` field, you can control
    the API version that your resource uses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段用于声明正在使用的 Kubernetes API 模式的版本。Kubernetes 在功能和功能上持续快速增长。通过支持其 API 的多个版本，它管理了由于功能增长而产生的复杂性。通过设置
    `apiVersion` 字段，您可以控制您的资源使用的 API 版本。
- en: '`kind`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`'
- en: Use the `kind` field to identify the type of resource the YAML file is describing.
    In the preceding example, the YAML file declares that it is describing a `Pod`
    object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kind` 字段来识别 YAML 文件描述的资源类型。在上述示例中，YAML 文件声明正在描述一个 `Pod` 对象。
- en: '`metadata`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata`'
- en: The `metadata` section contains information about the resource that the YAML
    is defining. In the preceding example, the `metadata` contains a name field that
    declares the name of this pod. The `metadata` section can contain other types
    of identifying information, such as labels and annotations. We describe these
    in more detail in [“Deployments”](#deployments).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata` 部分包含有关 YAML 定义的资源的信息。在上述示例中，`metadata` 包含一个名称字段，声明了此 pod 的名称。`metadata`
    部分可以包含其他类型的标识信息，例如标签和注释。我们将在 [“部署”](#deployments) 中更详细地描述这些内容。'
- en: '`spec`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`'
- en: The `spec` section provides a specification for what the desired state for this
    resource should be. As shown in the example, the desired state for this pod is
    to have a container with the name `nginx` that is built from the Docker image
    identified as `nginx:1.7.9`*.* The container shares the IP address of the pod
    it is contained in, and the `containerPort` field is used to allocate this container
    a network port (in this case, `80`) that it can use to send and receive network
    traffic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分提供了此资源的期望状态的规范。如示例所示，此 pod 的期望状态是具有名称为 `nginx` 的容器，该容器是从标识为 `nginx:1.7.9`
    的 Docker 镜像构建的。该容器共享所在 pod 的 IP 地址，并且 `containerPort` 字段用于为此容器分配一个网络端口（在本例中为 `80`），以便它可以用于发送和接收网络流量。'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `apply` command will either create a resource or update any existing matching
    resources. There is also a supported `create` command that will assume the resources
    described by the YAML document do not yet exist. You can typically use `apply`
    wherever you use `create`. In some cases, such as the special `generateName` attribute,
    only `create` is supported.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 命令将创建一个资源或更新任何现有的匹配资源。还有一个支持的 `create` 命令，它将假定 YAML 文档描述的资源尚不存在。通常可以在任何使用
    `create` 的地方使用 `apply`。在某些情况下，例如特殊的 `generateName` 属性，只支持 `create`。'
- en: 'To run the previous example, save the file as *pod.yaml*. You can now run it
    by doing the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行前面的示例，请将文件保存为 *pod.yaml*。现在可以通过以下方式运行它：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running this command, you should see the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该看到以下输出：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To confirm that your pod is actually running, use the `kubectl get pods` command
    to verify:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认您的 pod 是否真正在运行，请使用 `kubectl get pods` 命令进行验证：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After running this command, you should see output similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该看到类似以下的输出：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the pod is running, you can also view the logs of the process running
    within the pod with the `logs` command (if there are multiple containers, select
    the specific container you want to view with the `-c` option):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pod 运行时，您还可以使用 `logs` 命令查看 pod 内运行的进程的日志（如果有多个容器，请使用 `-c` 选项选择要查看的特定容器）：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you need to debug your running container, you can create an interactive
    shell that runs within the container by using the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要调试正在运行的容器，可以使用以下命令创建一个在容器内部运行的交互式 shell：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command instructs Kubernetes to run an interactive shell for the container
    that runs in the pod named `nginx`. Because this pod has only one container, Kubernetes
    knows which container you want to connect to even if you have not specified the
    container name. Accessing the container interactively to modify it at runtime
    is typically considered a bad practice. However, interactive shells can be useful
    as you are learning or debugging apps before deploying to production. After you
    run the preceding command, you can interact with the container’s runtime environment,
    as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指示 Kubernetes 为名为 `nginx` 的 pod 运行一个交互式 shell。因为此 pod 只有一个容器，Kubernetes 知道您要连接的容器即使您没有指定容器名称。在运行时访问容器以进行交互修改通常被认为是一种不良实践。然而，在学习或调试应用程序在部署到生产环境之前时，交互式
    shell 可能会很有用。运行上述命令后，您可以与容器的运行时环境进行交互，如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If your pod has multiple containers within it, you will need to include the
    container name as well in your `kubectl exec` command. To do this, use the `-c`
    option and include the container name in addition to the pod name. Here is an
    example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 pod 中有多个容器，您需要在 `kubectl exec` 命令中同时包含容器名称。为此，请使用 `-c` 选项并在 pod 名称之外包含容器名称。以下是一个示例：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To delete the pod that you just created, run the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除刚刚创建的 pod，请运行以下命令：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the following confirmation that the pod has been deleted:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下确认 pod 已被删除：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When using Kubernetes, you can expect to have large numbers of pods running
    in a cluster. In the next section, we describe how labels and annotations are
    used to help you keep track of and identify your pods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Kubernetes 时，您可以预期在集群中运行大量的 Pod。在下一节中，我们将描述如何使用标签和注释来帮助您跟踪和识别您的 Pod。
- en: Deployments
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: '*Deployments* are a high-level Kubernetes abstraction that not only allow you
    to control the number of pod replicas that are instantiated, but also provide
    support for rolling out new versions of the pods. Deployments are configurable
    such that they can leverage extra resources for faster rollouts that have no downtime,
    or they can perform slower rollouts that do canary testing. The advantage of a
    slower rollout is that it can reduce the risk and validate new software by releasing
    the software to a small percentage of users, thus ensuring that the new version
    of the application is stable. Deployments rely on the `ReplicaSet` resource to
    manage pod replicas and then add pod version management support on top of this
    capability. Deployments also enable newly rolled-out versions of pods to be rolled
    back to previous versions if there is something wrong with the new versions of
    the pods. Furthermore, deployments support two options for upgrading pods, `Recreate`
    and `RollingUpdate`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署* 是 Kubernetes 的高级抽象，不仅允许您控制实例化的 Pod 副本数目，还支持滚动部署新版本的 Pod。部署是可配置的，以便利用额外的资源进行更快的无停机滚动，或者执行能够进行金丝雀测试的更慢滚动。较慢的滚动部署的优势在于，它可以通过向一小部分用户发布软件来降低风险，并验证新软件，从而确保新版本的应用程序是稳定的。部署依赖于
    `ReplicaSet` 资源来管理 Pod 副本，然后在此基础上添加 Pod 版本管理支持。部署还使新部署的 Pod 版本可以回滚到先前的版本，如果新版本的
    Pod 存在问题。此外，部署支持两种升级 Pod 的选项，`Recreate` 和 `RollingUpdate`：'
- en: '`Recreate`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recreate`'
- en: The `Recreate` pod upgrade option is very straightforward. In this approach,
    the deployment resource modifies its associated `ReplicaSet` to point to the new
    version of the pod. It then proceeds to terminate all the pods. The `ReplicaSet`
    then notices that all the pods have been terminated and thus spawns new pods to
    ensure that the number of desired replicas are up and running. The `Recreate`
    approach will typically result in your pod application not being accessible for
    a period of time, and thus it is not recommended for applications that need to
    always be available.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recreate` Pod 升级选项非常直接。在这种方法中，部署资源修改其关联的 `ReplicaSet` 以指向 Pod 的新版本。然后，它终止所有的
    Pod。然后 `ReplicaSet` 察觉到所有的 Pod 都已终止，因此生成新的 Pod 以确保所需副本数目在运行中。`Recreate` 方法通常会导致您的
    Pod 应用在一段时间内无法访问，因此不推荐需要始终可用的应用程序使用此方法。'
- en: '`RollingUpdate`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`RollingUpdate`'
- en: Kubernetes’s deployment resource also provides a `RollingUpdate` option. With
    the `RollingUpdate` option, your pods are replaced with the newer versions incrementally
    over time. This approach results in there being a mixture of both the old version
    and the new version of the pod running simultaneously and thus avoids having your
    pod application unavailable during this maintenance period. The readiness of each
    pod is measured and used to inform kube-proxy and ingress controllers which pod
    replicas are available to handle network requests to ensure that no requests are
    dropped during the update process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的部署资源还提供 `RollingUpdate` 选项。使用 `RollingUpdate` 选项时，您的 Pod 将逐步被新版本替换。这种方法导致旧版本和新版本的
    Pod 同时运行，并因此避免在维护期间使您的 Pod 应用程序不可用。每个 Pod 的可用性会被测量，并用于通知 kube-proxy 和入口控制器哪些 Pod
    副本可用于处理网络请求，以确保在更新过程中不会丢失任何请求。
- en: 'The following is an example YAML specification for a deployment that uses the
    `RollingUpdate` option:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 `RollingUpdate` 选项的部署的示例 YAML 规范：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous deployment example encompasses many of the characteristics that
    we have seen in `ReplicaSet`s and pods. In its metadata it contains labels and
    annotations. For the deployment, an annotation with `deployment.kubernetes.io/​revi⁠sion`
    as the key and `1` as its value provides information that this is the first revision
    of the contents in this deployment. Similar to `ReplicaSet`s, the deployment declares
    the number of replicas it provides and uses a `matchLabels` field to declare what
    labels it uses to identify the pods it manages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的部署示例包含了许多我们在`ReplicaSet`和pod中看到的特征。在其元数据中包含标签和注释。对于部署，具有`deployment.kubernetes.io/revision`作为键和`1`作为其值的注释提供了有关此部署内容的第一个修订版的信息。类似于`ReplicaSet`，部署声明了它提供的副本数量，并使用`matchLabels`字段声明用于标识其管理的pod的标签。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Label matching is a very common aspect of Kubernetes API. If you need to organize
    or categorize resources, add descriptive labels that serve as lightweight metadata.
    You can also query or find resources using the `-l` option in kubectl like `kubectl
    get` or `kubectl patch`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 标签匹配是Kubernetes API中非常常见的一个方面。如果需要组织或分类资源，请添加描述性标签作为轻量级元数据。您还可以使用kubectl中的`-l`选项查询或查找资源，例如`kubectl
    get`或`kubectl patch`。
- en: Similar to `ReplicaSet`s, the deployment has both a `spec` section for the deployment
    and a nested `spec` section inside a `template` that is used to describe the containers
    that comprise the pod replicas managed by this deployment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ReplicaSet`类似，部署既有用于部署的`spec`部分，也有一个嵌套的`spec`部分，位于`template`内部，用于描述由此部署管理的pod副本中包含的容器。
- en: The fields that are new and specific to a deployment resource are the `strategy`
    field and its subfields of `type` and `RollingUpdate`. The `type` field is used
    to declare the deployment strategy being used and can currently be set to `Recreate`
    or `RollingUpdate`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 针对部署资源新添加并具体的字段是`strategy`字段及其子字段`type`和`RollingUpdate`。`type`字段用于声明正在使用的部署策略，目前可以设置为`Recreate`或`RollingUpdate`。
- en: 'If the `RollingUpdate` option is selected, the subfields of `maxUnavailable`
    and `maxSurge` need to be set as well. The options are used as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了`RollingUpdate`选项，则还需要设置`maxUnavailable`和`maxSurge`的子字段。这些选项的使用如下：
- en: '`maxSurge`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge`'
- en: The `maxSurge RollingUpdate` option enables extra resources to be allocated
    during a rollout. The value of this option can be set to a number or a percentage.
    As a simple example, assume a deployment is supporting three replicas and `maxSurge`
    is set to `2`. In this scenario, there will be a total of five replicas available
    during the `RollingUpdate`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge RollingUpdate`选项允许在升级过程中分配额外的资源。此选项的值可以设置为数字或百分比。举个简单的例子，假设一个部署支持三个副本，并且`maxSurge`设置为`2`。在这种情况下，在`RollingUpdate`期间将总共有五个副本可用。'
- en: At the peak of the deployment, there will be three replicas with the old version
    of the pods running and two with the new version of the pods running. At this
    point, one of the old version pod replicas will need to be terminated, and then
    another replica of the new pod version can be created. At this stage, there would
    be a total of five replicas, three that have the new revision and two that have
    the old version of the pods. Finally, having reached a point of the correct number
    of pod replicas being available with the new version, the two pods with the old
    version can be terminated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署的高峰期，将有三个使用旧版本pod运行的副本和两个使用新版本pod运行的副本。在此时，需要终止一个旧版本pod副本，然后可以创建另一个新版本pod的副本。在此阶段，将会有总共五个副本，其中三个具有新修订版，两个具有旧版本pod。最终，达到正确数量的具有新版本的pod副本可用后，可以终止两个具有旧版本的pod的副本。
- en: '`maxUnavailable`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxUnavailable`'
- en: This `RollingUpdate` option is used to declare the number of the deployment
    replica pods that may be unavailable during the update. It can be set to either
    a number or a percentage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此`RollingUpdate`选项用于声明在更新期间可能不可用的部署副本pod的数量。可以将其设置为数字或百分比。
- en: 'The following YAML example shows a deployment that has been updated to initiate
    a rollout:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的YAML示例显示了一个已更新以启动滚动升级的部署：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that a new annotation label with a key of `kubernetes.op/change-cause`
    has been added with a value that denotes an update to the version of nginx running
    in the container. Also notice that the name of the image used by the container
    in the `spec` section has changed to `nginx:1.13.10`. This declaration is what
    actually drives the pod replicas managed by the deployment to now have a new version
    of the container images when the upgrade occurs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，已添加一个带有键为`kubernetes.op/change-cause`的新注释标签，其值表示容器中运行的 nginx 版本已更新。还请注意，容器在`spec`部分中使用的映像名称已更改为`nginx:1.13.10`。这个声明实际上是驱动由部署管理的
    Pod 副本，在升级发生时现在具有容器映像的新版本。
- en: 'To demonstrate the capabilities of deployments, let’s run the two previous
    examples. Save the first deployment example as *deploymentset.yaml* and the second
    example as *deploymentset2.yaml*. You can now run the first deployment example
    by doing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示部署的能力，让我们运行前两个示例。将第一个部署示例保存为*deploymentset.yaml*，第二个示例保存为*deploymentset2.yaml*。您现在可以通过执行以下操作来运行第一个部署示例：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After running this command, you should see the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该看到以下输出：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To confirm that your pod replicas managed by the deployment are actually running,
    use the `kubectl get pods` command to verify:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认由部署管理的 Pod 副本实际上正在运行，请使用`kubectl get pods`命令进行验证：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After running this command, you should see output similar to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该看到类似以下的输出：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With deployments, we have a new command called `kubectl get deployments` that
    provides status on the deployments as they update their images. Run this command
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用部署，我们有一个新命令叫做`kubectl get deployments`，它会提供有关部署状态的信息，当它们更新其映像时。按以下方式运行此命令：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After running this command, you should see output similar to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该看到类似以下的输出：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now to make things interesting, let’s update the image in our deployment by
    applying the second deployment example that we saved in *deploymentset2.yaml*.
    Note that we could have just updated the original YAML that we saved in *deploymentset.yaml*
    instead of using two separate files. We begin the update by doing the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让事情变得有趣，让我们通过应用我们在*deploymentset2.yaml*中保存的第二个部署示例来更新部署中的映像。请注意，我们本可以直接更新我们在*deploymentset.yaml*中保存的原始
    YAML 文件，而不是使用两个单独的文件。我们开始更新，执行以下操作：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After running this command, you should see the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该看到以下输出：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when we rerun the `kubectl get deployments` command, which provides status
    on the deployments as they update their images, we see a much more interesting
    result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们重新运行`kubectl get deployments`命令时，该命令会提供有关部署正在更新其映像的状态，我们将看到一个更加有趣的结果：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As shown in this output, the deployment currently has three pod replicas running.
    Three of the pod replicas are up to date, which means they are now running the
    updated nginx image. In addition, there are three pod replicas in total, and of
    these three replicas, two are available to handle requests. After some amount
    of time, when the rolling image update is complete, we reach the desired state
    of having three updated pod replicas available. We can confirm this by rerunning
    the `kubectl get deployments` command and viewing that the output now matches
    our desired state:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，当前部署有三个正在运行的 Pod 副本。其中三个 Pod 副本已经更新到最新的 nginx 映像，两个副本可以处理请求。经过一段时间后，当滚动映像更新完成时，我们达到了希望的状态，即有三个更新后的
    Pod 副本可用。我们可以通过重新运行`kubectl get deployments`命令来确认，查看输出现在与我们的期望状态匹配：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To delete the deployment that was just created, run the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除刚创建的部署，请运行以下命令：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should get the following confirmation that the deployment has been deleted:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到以下确认，部署已被删除：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deployments also include commands for pausing rollouts, resuming rollouts, and
    rolling back the update of an image. The commands are quite helpful if you have
    some concerns about the new image being rolled out that merits investigation or
    if you determine that the updated image being rolled out is problematic and needs
    to be rolled back to a previous version. See the [Kubernetes Deployment documentation](https://oreil.ly/BJ115)
    for more information on how to use these deployment capabilities.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还包括暂停部署、恢复部署和回滚映像更新的命令。如果您对新的映像部署有疑虑，这些命令将非常有帮助，或者如果确定正在部署的更新映像存在问题，需要回滚到先前版本。有关如何使用这些部署功能的更多信息，请参阅
    [Kubernetes Deployment documentation](https://oreil.ly/BJ115)。
- en: In the next section, we examine the extra steps that are needed to run the previous
    examples in a secure Kubernetes production-level environment such as OpenShift.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细探讨在安全的 Kubernetes 生产环境（如 OpenShift）中运行先前示例所需的额外步骤。
- en: Running the Pod and Deployment Examples in Production on OpenShift
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 OpenShift 上生产环境中运行 Pod 和 Deployment 示例
- en: 'The pod and deployment examples presented in the previous sections are perfect
    for instructional purposes and for running in a local development environment.
    When running in production on a highly secure Kubernetes platform such as OpenShift,
    there are other factors that need to be addressed. First, the nginx container
    image we used in the previous examples is configured to run as a privileged root
    user. By default, secure production Kubernetes platforms such as OpenShift are
    configured to not allow a container image to run as root. This is because running
    a container image as root increases the risk that malicious code could find a
    way to cause harm to the host system.^([3](ch02.html#ch01fn16)) To address this
    issue, we will replace the nginx container used earlier in this chapter with a
    version of the image that does not need to run as a privileged root user. The
    nginx container image from Bitnami runs as a nonroot container and can be used
    in a production OpenShift environment. The following example is an updated version
    of our previously created *pod.yaml*, which uses the Bitnami nonroot nginx container
    image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前章节中呈现的 Pod 和 Deployment 示例非常适合教学目的和在本地开发环境中运行。但是，在像 OpenShift 这样的高度安全的 Kubernetes
    平台上运行生产环境时，需要考虑其他因素。首先，在之前示例中使用的 nginx 容器镜像被配置为以特权根用户身份运行。默认情况下，安全的生产 Kubernetes
    平台（如 OpenShift）配置为不允许容器镜像以 root 用户身份运行。这是因为以 root 用户身份运行容器镜像会增加恶意代码对主机系统造成危害的风险。^([3](ch02.html#ch01fn16))
    为解决这个问题，我们将用一个不需要以特权根用户身份运行的镜像版本替换本章早期使用的 nginx 容器。Bitnami 的 nginx 容器镜像以非 root
    容器形式运行，可以在生产 OpenShift 环境中使用。以下示例是我们先前创建的 *pod.yaml* 的更新版本，使用了 Bitnami 的非 root
    nginx 容器镜像：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that all resources are either *cluster scoped,* meaning that only one
    resource of that kind can exist within the cluster, or *namespace scoped,* meaning
    that the resources are isolated from other similar resources on the cluster. Within
    OpenShift, you may also see the term *project,* which predated the concept that
    Red Hat worked with the community to generalize as namespace. *Project* and *namespace*
    are synonymous, and OpenShift will respond to either `get projects` or `get namespaces`.
    You can think of namespaces as like folders within a filesystem that you use to
    assign to a group of users who are collaborating on a collection of files. We
    will talk more about namespaces or projects in [“OpenShift Enhancements”](#openshift_enhancements).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有资源要么是 *集群范围* 的，意味着集群中只能存在一个此类资源，要么是 *命名空间范围* 的，意味着这些资源与集群中的其他相似资源隔离开来。在
    OpenShift 中，您还可能会看到术语 *项目*，这是在 Red Hat 与社区合作通用命名空间概念之前的旧术语。*项目* 和 *命名空间* 是同义词，OpenShift
    可以响应 `get projects` 或 `get namespaces`。您可以将命名空间想象成文件系统中的文件夹，用于分配给一组协作文件的用户。我们将在
    [“OpenShift Enhancements”](#openshift_enhancements) 中详细讨论命名空间或项目。
- en: 'Another issue with our earlier pod and deployment examples that needs to be
    addressed is that when they were created, we did not isolate our resources from
    others by creating a Kubernetes namespace that was specific to our resources.
    Instead, the earlier examples placed our resources in the Kubernetes default namespace.
    To encourage proper isolation of applications, secure production Kubernetes platforms
    such as OpenShift will enforce that your Kubernetes resources are not created
    in the default namespace but instead are created in a user-defined namespace that
    provides the required isolation. To create a properly configured namespace, OpenShift
    provides the `oc new-project` command. OpenShift’s project capability is described
    more thoroughly in [“OpenShift Enhancements”](#openshift_enhancements). For now,
    however, we will use the `oc new-project` command to create a new project called
    `book`, which will provide the required isolation to be able to run our pod example.
    We create our new project by running the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的Pod和部署示例还存在另一个需要解决的问题，那就是它们创建时并没有通过创建一个特定于我们资源的Kubernetes命名空间来将我们的资源与其他资源隔离开来。相反，早期的示例将我们的资源放置在Kubernetes的默认命名空间中。为了鼓励应用程序的正确隔离，安全的生产环境Kubernetes平台如OpenShift将强制执行，要求您的Kubernetes资源不要在默认命名空间中创建，而是在提供所需隔离的用户定义命名空间中创建。为了创建一个正确配置的命名空间，OpenShift提供了`oc
    new-project`命令。OpenShift的项目功能在[“OpenShift增强”](#openshift_enhancements)中有更详细的描述。然而，现在，我们将使用`oc
    new-project`命令创建一个名为`book`的新项目，这将为我们的Pod示例提供所需的隔离。我们通过运行以下命令来创建我们的新项目：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can then use the `oc apply -f` command, pass in our updated *pod.yaml,*
    and use the `-n` option to declare that we want our resources created in the `book`
    namespace:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`oc apply -f`命令，传入我们更新的*pod.yaml*，并使用`-n`选项声明我们要在`book`命名空间中创建我们的资源：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have used a nonroot container image and are no longer using the
    default namespace, our pod example will be permitted by OpenShift to run in production.
    We can confirm this is the case by using the `oc get pods` command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用了非root容器镜像，并且不再使用默认命名空间，我们的Pod示例将被OpenShift允许在生产环境中运行。我们可以通过使用`oc get
    pods`命令来确认这一点：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can clean up and remove the pod example by using the `oc delete pod` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`oc delete pod`命令来清理和删除Pod示例：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The same techniques we used for the pod example can be applied to the deployment
    examples as well. Simply update the nginx image that is used in *deploymentset.yaml,*
    and make sure to use the `book` namespace when doing the `oc apply` command. In
    the next section, we’ll introduce another fundamental Kubernetes concept called
    *service accounts,* which are used to provide authentication for key parts of
    the Kubernetes platform.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将用于Pod示例的相同技术应用于部署示例。只需更新*deploymentset.yaml*中使用的nginx镜像，并确保在执行`oc apply`命令时使用`book`命名空间。在接下来的章节中，我们将介绍另一个名为*服务账户*的基本Kubernetes概念，用于为Kubernetes平台的关键部分提供认证。
- en: Service Accounts
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务账户
- en: When you interact with your cluster, you often represent yourself as a user
    identity. In the world of Kubernetes, we build intelligence into the system to
    help it interact with its world. Many times, pods may use the Kubernetes API to
    interact with other parts of the system or to spawn jobs. When we deploy a pod,
    it may interact with volume storage, interact with the host filesystem, interact
    with the host networking, or be sensitive to which operating system user it is
    given access to use for filesystem access. In most cases, you want to restrict
    the default permissions for a given pod from doing anything more than the absolute
    basics. Basically, the less surface area that a pod is given access to in the
    cluster, the host operating system, the networking layer, and your storage layer,
    the fewer attack vectors that can be exploited.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与集群交互时，通常会以用户身份表示自己。在Kubernetes的世界中，我们向系统中构建智能，帮助它与外部世界进行交互。许多时候，Pod可能会使用Kubernetes
    API与系统的其他部分交互或生成作业。当我们部署一个Pod时，它可能会与卷存储交互，与主机文件系统交互，与主机网络交互，或者依赖于分配给它用于文件系统访问的操作系统用户的敏感性。在大多数情况下，您希望限制给定Pod的默认权限，以免其做更多的事情。基本上，给予Pod在集群、主机操作系统、网络层和存储层的访问权限越少，可以利用的攻击向量就越少。
- en: For a pod to interact with the system, it is assigned a service account. Think
    of this as a functional identity. The service accounts are subjects that can authenticate
    with kube-apiserver via tokens and are authorized for certain behaviors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 pod 能够与系统交互，它被分配了一个服务账户。可以将其视为功能身份。服务账户是可以通过令牌与 kube-apiserver 进行认证并授权特定行为的主体。
- en: In some Kubernetes systems, the service account projected into the pod can have
    identity outside of Kubernetes. A powerful use case is when using the open source
    [Istio](https://istio.io) service mesh project with Kubernetes. In this scenario,
    the Istio identity is projected via the service account, and this allows one pod
    to authenticate with another when making service requests. Some cloud providers
    and other security tools also allow for projection of a service account identity
    into the pod, and this allows for authentication with these external platforms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 Kubernetes 系统中，投射到 pod 中的服务账户可能具有 Kubernetes 之外的身份。一个强大的用例是在使用开源的[Istio](https://istio.io)服务网格项目与
    Kubernetes 时。在这种情况下，通过服务账户投射 Istio 身份，这允许一个 pod 在进行服务请求时与另一个 pod 进行认证。一些云提供商和其他安全工具也允许将服务账户身份投射到
    pod 中，这样可以与这些外部平台进行认证。
- en: In OpenShift, service accounts are also used to associate a grouping of security
    privileges with each pod. The object that OpenShift uses for creating specialized
    groupings of security privileges is called a *security context constraint*. In
    the next section, we provide a more detailed discussion of security context constraints,
    as well as several other important enhancements that OpenShift delivers to supplement
    basic Kubernetes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenShift 中，服务账户也用于将一组安全权限与每个 pod 关联起来。OpenShift 用于创建特定安全权限组合的对象称为*安全上下文约束*。在下一节中，我们将详细讨论安全上下文约束以及
    OpenShift 提供的其他重要增强功能，以补充基本的 Kubernetes 功能。
- en: OpenShift Enhancements
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift 增强
- en: OpenShift introduces several new concepts that it uses to simplify development
    and operations. Approaches that are specific to OpenShift include authentication,
    projects, applications, security contexts, and image streams.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 引入了几个新概念，用于简化开发和运维。OpenShift 特有的方法包括认证、项目、应用程序、安全上下文和镜像流。
- en: Authentication
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: 'Security is paramount to the OpenShift Kubernetes platform. As a result, all
    users must authenticate with the cluster to be able to access it. OpenShift supports
    a variety of common authentication methods, including basic authentication with
    username and password, OAuth access tokens, and X.509 client certificates.^([4](ch02.html#ch01fn17))
    OpenShift provides the `oc login` command for performing authentication, which
    is run by doing the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安全对于 OpenShift Kubernetes 平台至关重要。因此，所有用户必须对集群进行认证才能访问它。OpenShift 支持多种常见的认证方法，包括基本认证（使用用户名和密码）、OAuth
    访问令牌和 X.509 客户端证书。^([4](ch02.html#ch01fn17)) OpenShift 提供了`oc login`命令用于执行认证，操作如下：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In a basic authentication use case, when this command is run, the user will
    be asked to enter the OpenShift Container Platform server URL and whether or not
    secure connections are needed, and then the user will be asked to input their
    username and password. In addition, OpenShift’s configurable OAuth server allows
    for users to integrate OpenShift identity with external providers, such as LDAP
    servers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本认证用例中，当运行此命令时，用户将被要求输入 OpenShift 容器平台服务器 URL，以及是否需要安全连接，然后用户将被要求输入其用户名和密码。此外，OpenShift
    的可配置 OAuth 服务器允许用户将 OpenShift 身份与外部提供者（如 LDAP 服务器）集成。
- en: Projects
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目
- en: Standard Kubernetes provides the concept of a [*namespace*](https://oreil.ly/IAiIw),
    which allows you to define isolation for your Kubernetes resources. Namespaces
    enable cluster resources to be divided among a large number of users, and the
    isolation that results from the scoping that they administer keeps users from
    accidentally using someone else’s resource due to a naming collision. Namespaces
    are incredibly useful, and OpenShift has adapted namespaces for grouping applications.
    OpenShift accomplishes this by taking a Kubernetes namespace and adding a special
    standard list of annotations to the namespace. OpenShift refers to this specific
    type of namespace as a *project.* OpenShift uses projects as its mechanism for
    grouping applications. Projects support the notion of access permissions. This
    enables you to add one or more users who have access to the project, and role-based
    access control is used to set the permissions and capabilities that various users
    have when accessing a project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Kubernetes 提供了[*命名空间*](https://oreil.ly/IAiIw)的概念，允许您为 Kubernetes 资源定义隔离。命名空间使得集群资源可以分配给大量用户，并且由于它们管理的作用域而产生的隔离，使用户不会因为命名冲突而意外使用他人的资源。命名空间非常有用，OpenShift
    已经为应用程序的分组适应了命名空间。OpenShift 通过采用 Kubernetes 命名空间并向命名空间添加特殊的标准注解列表来实现此目的。OpenShift
    将这种特定类型的命名空间称为*项目*。OpenShift 使用项目作为其分组应用程序的机制。项目支持访问权限的概念。这使您可以添加一个或多个能访问项目的用户，并使用基于角色的访问控制设置用户在访问项目时拥有的权限和能力。
- en: 'Projects are created using the `oc new-project` command and by providing a
    project name, description, and display name as shown:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 项目是使用`oc new-project`命令创建的，并提供项目名称、描述和显示名称，如下所示：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'OpenShift makes it easy to switch between projects by using the `oc project`
    command. Here we switch to a different project called `secondproject`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`oc project`命令，OpenShift 可以轻松地在项目之间进行切换。在这里，我们切换到名为`secondproject`的不同项目：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To view the list of projects that you are authorized to access, you can use
    the `oc get projects` command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您有权限访问的项目列表，可以使用`oc get projects`命令：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For more information on the use of projects, please see the [OpenShift project
    documentation](https://oreil.ly/xXs4d).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有关项目使用的更多信息，请参阅[OpenShift 项目文档](https://oreil.ly/xXs4d)。
- en: Applications
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: When using a basic Kubernetes environment, one of the more tedious steps that
    needs to be performed by a cloud native application developer is creating their
    own container images. Typically, this involves finding the proper base image and
    creating a `Dockerfile` with all the necessary commands for taking a base image
    and adding in the developer’s code to create an assembled image that can be deployed
    by Kubernetes. OpenShift introduced the [application construct](https://oreil.ly/3RpbY)
    to greatly simplify the process of creating, deploying, and running container
    images in Kubernetes environments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基本的 Kubernetes 环境时，云原生应用程序开发人员需要执行的比较繁琐的步骤之一是创建自己的容器镜像。通常，这涉及查找适当的基础镜像，并创建包含所有必要命令的`Dockerfile`，以将基础镜像和开发人员的代码组合成一个可以由
    Kubernetes 部署的组装镜像。OpenShift 引入了[应用程序构造](https://oreil.ly/3RpbY)，大大简化了在 Kubernetes
    环境中创建、部署和运行容器镜像的过程。
- en: Applications are created using the `oc new-app` command. This command supports
    a variety of options that enable container images to be built many ways. For example,
    with the `new-app` command, application images can be built from local or remote
    Git repositories, or the application image can be pulled from a Docker Hub or
    private image registry. In addition, the `new-app` command supports the creation
    of application images by inspecting the root directory of the repository to determine
    the proper way to create the application image. For example, the OpenShift `new-app`
    command will look for a `JenkinsFile` in the root directory of your repository,
    and if it finds this file, it will use it to create the application image. Furthermore,
    if the `new-app` command does not find a `JenkinsFile`, it will attempt to detect
    the programming language that your application is built in by looking at the files
    in your repository. If it is able to determine the programming language that was
    used, the `new-app` command will locate an acceptable base image for the programming
    language you are using and will use this to build your application image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是使用`oc new-app`命令创建的。此命令支持多种选项，可以多种方式构建容器镜像。例如，使用`new-app`命令，应用程序镜像可以从本地或远程Git存储库构建，或者可以从Docker
    Hub或私有镜像注册表拉取应用程序镜像。此外，`new-app`命令支持通过检查存储库的根目录来确定创建应用程序镜像的正确方式。例如，OpenShift的`new-app`命令将在存储库的根目录中查找`JenkinsFile`，如果找到此文件，它将用于创建应用程序镜像。此外，如果`new-app`命令未找到`JenkinsFile`，它将尝试通过查看存储库中的文件来检测应用程序所使用的编程语言。如果它能够确定所使用的编程语言，`new-app`命令将找到适用于所使用编程语言的合适基础镜像，并用于构建应用程序镜像。
- en: 'The following example illustrates using the the `oc new-app` command to create
    a new application image from an OpenShift example ruby hello world application:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用`oc new-app`命令从OpenShift示例ruby hello world应用程序创建新的应用程序镜像：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This command will create the application as part of whichever OpenShift project
    was most recently selected to be the current context for the user. For more information
    on the application image creation options supported by the `new-app` command,
    see the [OpenShift application creation documentation](https://oreil.ly/3RpbY).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在最近选择为用户当前上下文的任何OpenShift项目中创建应用程序。有关`new-app`命令支持的应用程序镜像创建选项的更多信息，请参阅[OpenShift应用程序创建文档](https://oreil.ly/3RpbY)。
- en: Security Context Constraints
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全上下文约束。
- en: Security is always at the forefront in OpenShift. But with added security can
    come extra complexity and aggravation. If enhanced security is used and a container
    is not given the proper security options, it will fail. If security is relaxed
    to avoid issues, then vulnerabilities can result. In an effort to enable users
    to leverage enhanced security with less aggravation, OpenShift includes a security
    construct called *security context constraints*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenShift中，安全始终是首要考虑的。但增强安全性可能带来额外的复杂性和烦恼。如果使用增强的安全性但未为容器提供适当的安全选项，则会导致失败。如果放宽安全性以避免问题，则可能会导致漏洞。为了使用户能够在减少烦恼的情况下利用增强的安全性，OpenShift包含了一种安全构造称为*安全上下文约束*。
- en: 'The security context constraints identify a set of security privileges that
    a pod’s container is guaranteed to execute with. Thus, before the pod’s container
    begins execution, it knows what security privileges it will get. The following
    is a list of the common security privilege options that are provided by security
    context constraints:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束确定了Pod容器保证执行的一组安全特权。因此，在Pod容器开始执行之前，它就知道将获得哪些安全特权。以下是由安全上下文约束提供的常见安全特权选项列表：
- en: Allow pods to run privileged containers
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Pod运行特权容器。
- en: Security context constraints can declare if a pod is permitted to run privileged
    containers or if it can run only nonprivileged containers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束可以声明是否允许Pod运行特权容器，或者它只能运行非特权容器。
- en: Require Security-Enhanced Linux (SELinux)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要求启用安全增强Linux（SELinux）。
- en: '[SELinux](https://oreil.ly/SlHNy) is a security architecture for Linux that
    defines access controls for applications, processes, and files on a system. SELinux
    presents extra protections beyond what standard Linux uses. Security context constraints
    provide the `MustRunAs` attribute value for declaring if SELinux must be run by
    a pod’s container and a `RunAsAny` attribute value for declaring if the pod’s
    container can run either standard Linux or SELinux.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[SELinux](https://oreil.ly/SlHNy) 是用于 Linux 的安全架构，为系统上的应用程序、进程和文件定义访问控制。SELinux
    提供了比标准 Linux 更多的额外保护。安全上下文约束为声明是否必须由 pod 容器运行 SELinux 提供了 `MustRunAs` 属性值，以及声明
    pod 容器可以运行标准 Linux 或 SELinux 的 `RunAsAny` 属性值。'
- en: Run the pod’s container as a specific user or as nonroot
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将 pod 容器作为特定用户或非 root 用户运行
- en: Containers running as root have a bigger vulnerability footprint than containers
    running as a nonroot. Security context constraints provide a `MustRunAsNonRoot`
    attribute value to denote that a Pod’s container is not permitted to run as root.
    Additionally, the security context constraints use a `RunAsAny` attribute value
    that permits a pod’s container to run as either a root or nonroot user. Finally,
    the security context constraint administers a `MustRunAsRange` attribute value
    that allows a pod’s container to run if the user ID is within a specific range
    of user IDs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以 root 用户身份运行的容器比以非 root 用户身份运行的容器更容易受到攻击。安全上下文约束提供了 `MustRunAsNonRoot` 属性值，以指示
    Pod 的容器不得以 root 身份运行。此外，安全上下文约束使用 `RunAsAny` 属性值，允许 pod 容器以 root 或非 root 用户身份运行。最后，安全上下文约束管理了一个
    `MustRunAsRange` 属性值，允许 pod 容器在用户 ID 在特定用户 ID 范围内时运行。
- en: Allow the pod’s container access to File System Group block storage
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 pod 容器访问文件系统组块存储
- en: Security context constraints can be used to limit the block storage that a pod’s
    container has access to. Block storage portions are identified through the use
    of a File System Group identifier. Security context constraints provide a `RunAsAny`
    attribute value that permits a pod’s container to access any File System Group
    of block storage, as well as a `MustRunAs` attribute value, which is used to denote
    that the pod’s block storage must be in the range of File System Group IDs listed
    in the security context constraint.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束可用于限制 pod 容器可以访问的块存储。块存储部分通过文件系统组标识符来识别。安全上下文约束提供了 `RunAsAny` 属性值，允许
    pod 容器访问任何块存储的文件系统组，以及一个 `MustRunAs` 属性值，用于指示 pod 的块存储必须在安全上下文约束中列出的文件系统组 ID 范围内。
- en: 'OpenShift includes several built-in security context constraint profiles that
    can be reused. To view the list of projects that you are authorized to access,
    you can use the `oc get scc` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 包含几个可重复使用的内置安全上下文约束配置文件。要查看您有权访问的项目列表，可以使用 `oc get scc` 命令：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As shown, OpenShift contributes security context constraint profiles for common
    scenarios, such as privileged, restricted, or running as nonroot. To see all the
    individual capability settings for the security constraint profile, use the `oc
    describe scc` command and pass in the name of the profile that you want more details
    on. For example, if you wanted more details on how powerful the privileged constraint
    profile is, you would invoke the `oc describe scc` command as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如示所示，OpenShift 为常见场景（如特权、受限或作为非 root 运行）提供安全上下文约束配置文件。要查看安全约束配置文件的所有单独功能设置，请使用
    `oc describe scc` 命令，并传递您想要详细了解的配置文件名称。例如，如果您想要详细了解特权约束配置文件的功能强大程度，可以如下调用 `oc
    describe scc` 命令：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running this command will list a large number of constraint attributes associated
    with this profile. Here are a few of the more interesting ones:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将列出与此配置文件关联的大量约束属性。以下是其中几个比较有趣的属性：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For comparison purposes, we can run the same command for the restricted profile.
    As shown in the following output, the constraint attribute values are much more
    restrictive than those in the privileged profile:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较目的，我们可以对受限配置文件运行相同的命令。如下输出所示，约束属性值比特权配置文件中的约束属性值严格得多：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The key point here is that security context constraint profiles are able to
    group and encapsulate large groups of capability attributes and ensure that all
    the attributes are met before a pod is permitted to execute. This reduces the
    chance of improperly setting the capability attributes and reduces the chance
    of an unexpected pod failure due to an incorrect security setting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于安全上下文约束配置文件能够分组和封装大量的能力属性，并确保在允许执行 Pod 之前满足所有属性要求。这降低了错误设置能力属性的可能性，并减少了因不正确的安全设置导致的意外
    Pod 失败的机会。
- en: Security context constraint profiles are associated with pods by using the Kubernetes
    service account object. For more information on the use of security context constraints,
    see the [OpenShift security context constraints documentation](https://oreil.ly/W41Sq).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束配置文件通过使用 Kubernetes 服务账户对象与 Pod 关联。有关安全上下文约束使用的更多信息，请参阅[OpenShift 安全上下文约束文档](https://oreil.ly/W41Sq)。
- en: Image Streams
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像流
- en: One of the key steps in deploying a cloud native application is retrieving the
    correct container application image from a repository. When running in production,
    there are several possible pitfalls with this retrieval process. First, container
    images are retrieved by a tag identifier, but it is possible that container images
    can be overwritten, and thus the image that is referenced by the tag can change.
    If this change goes unnoticed, it could result in introducing unexpected errors
    into the cloud native application that is deployed. Second, when running in production,
    the image retrieval process also needs to be supplemented with support for automating
    builds and deployments, and many image repositories are limited in their ability
    to support this automation. Third, in some cases a container image needs to have
    multiple tags associated with it because the container image is used for different
    purposes in different environments. Unfortunately, many image repositories do
    not support the ability to associate multiple tags with a container application
    image.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 部署云原生应用的关键步骤之一是从仓库中检索正确的容器应用镜像。在生产环境中，这个检索过程可能会遇到几个潜在的问题。首先，容器镜像是通过标签标识符检索的，但容器镜像可能会被覆盖，因此标签引用的镜像可能会发生变化。如果这种变化未被注意到，可能会导致部署的云原生应用引入意外错误。其次，在生产环境中，镜像检索过程还需要支持构建和部署的自动化，但许多镜像仓库在支持这种自动化能力上有所限制。第三，有些情况下，一个容器镜像需要与多个标签关联，因为在不同的环境中，这个容器镜像可能有不同的用途。不幸的是，许多镜像仓库不支持将多个标签与容器应用镜像关联起来的能力。
- en: To address all of these issues, OpenShift introduced the concept of *image streams*.^([5](ch02.html#ch01fn18))
    Image streams are intended to provide a more stable pointer for tagged images.
    The image stream maintains an SHA-256 secure hash function to the image it points
    to in order to ensure that the image is not mistakenly changed. Image streams
    also support multiple tags for images to better support using them in multiple
    environments. In addition, image streams include triggers that enable builds and
    deployments to be started automatically when the image stream is updated. Furthermore,
    image streams can not only reference container images from external repositories,
    but can also be scheduled to periodically reimport the external container image
    to ensure that they always have the most recently updated copy of the container
    image they are referencing in the external repository.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决所有这些问题，OpenShift 引入了 *镜像流* 的概念。镜像流旨在为标记的镜像提供更稳定的指针。镜像流通过维护一个 SHA-256 安全哈希函数与其指向的镜像关联，以确保不会错误更改镜像。镜像流还支持为镜像添加多个标签，以更好地支持在多个环境中使用这些镜像。此外，镜像流包括触发器，允许在更新镜像流时自动启动构建和部署。此外，镜像流不仅可以引用外部仓库中的容器镜像，还可以安排定期重新导入外部容器镜像，以确保始终具有最新更新的镜像副本。
- en: 'Creating and updating image streams is relatively straightforward. The `oc
    import-image` command is used to create an image stream. In the following example,
    the `oc import-image` command is used to create an initial image stream called
    `nginx` with an initial image stream tag for the imported image that has the value
    `1.12`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和更新镜像流相对直接。使用 `oc import-image` 命令创建镜像流。在以下示例中，使用 `oc import-image` 命令创建一个名为
    `nginx` 的初始镜像流，并为导入的镜像创建一个初始镜像流标签，其值为 `1.12`：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As shown in this example, the initial container image that is being imported
    into the `nginx` image stream is the image that is located at `centos/nginx-112-centos7`.
    The `confirm` option states that the image stream should be created if it doesn’t
    already exist.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，导入到`nginx`图像流中的初始容器图像是位于`centos/nginx-112-centos7`的图像。`confirm`选项指示如果图像流不存在，则应创建该图像流。
- en: 'Once the image stream is created, we can examine it using the `oc describe`
    command. In the following example, the `is` value is the short name for an input
    stream resource. The specific input stream that we want described is the one with
    the name `nginx`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像流后，我们可以使用`oc describe`命令来检查它。在以下示例中，`is`值是输入流资源的简称。我们想要描述的特定输入流是名称为`nginx`的流：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output from this command looks like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出如下所示：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can add an extra tag for this image by using the `oc tag` command. We add
    an `nginx:latest` tag to the existing `nginx:1.12` tag by doing the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`oc tag`命令为此图像添加额外的标签。我们通过以下方式向现有的`nginx:1.12`标签添加一个`nginx:latest`标签：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, we can tag an image from an external repository and schedule this image
    to be periodically reimported by calling the `oc tag` command. As shown in the
    following example, we reference the image from the external repository, associate
    it with an image stream tag, and then add the scheduled option to denote that
    the tag should be periodically updated:^([6](ch02.html#ch01fn19))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过调用`oc tag`命令为来自外部仓库的图像打标签，并安排定期重新导入此图像。如以下示例所示，我们引用外部仓库中的图像，将其与图像流标签关联，然后添加定期更新选项以指示应定期更新标签：^([6](ch02.html#ch01fn19))
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For more information on the use of image streams, please see the documentation
    on [managing image streams](https://oreil.ly/YMfdZ).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用图像流的更多信息，请参阅[管理图像流的文档](https://oreil.ly/YMfdZ)。
- en: Kubernetes and OpenShift Advanced Topics
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 高级主题
- en: Several advanced concepts are frequently used when running Kubernetes or OpenShift
    in production. In this section, we discuss these advanced topics, including webhooks,
    admission controllers, role-based access control, and operators.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行 Kubernetes 或 OpenShift 时经常使用几个高级概念。在本节中，我们讨论这些高级主题，包括 Webhooks、准入控制器、基于角色的访问控制和运算符。
- en: Webhooks
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webhooks
- en: A *webhook* is an HTTP callback.^([7](ch02.html#ch01fn20)) Essentially, a webhook
    enables information to be pushed to an external entity when an interesting event
    is occurring. Typically, an HTTP Post operation is used to push the event information,
    and the event information is most commonly represented as a JSON payload. In Kubernetes,
    webhooks are used for a variety of security-related operations. For example, Kubernetes
    can use a webhook to query an external service to determine if a user has the
    correct privileges to perform a specific operation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*Webhook* 是 HTTP 回调。^([7](ch02.html#ch01fn20)) 本质上，Webhook 在发生有趣事件时将信息推送给外部实体。通常使用
    HTTP Post 操作推送事件信息，并且事件信息通常以 JSON 负载表示。在 Kubernetes 中，Webhooks 用于各种安全相关操作。例如，Kubernetes
    可以使用 Webhook 查询外部服务，以确定用户是否具有执行特定操作的正确权限。'
- en: Webhooks are also used by OpenShift as [a mechanism for triggering builds](https://oreil.ly/bmfyW).
    With webhooks, you can configure your GitHub repository to send an alert whenever
    there is a change in the repository. This alert can be used to kick off a new
    build and, if the build succeeds, perform a deployment as well.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 也使用 Webhooks 作为[触发构建的机制](https://oreil.ly/bmfyW)。通过 Webhooks，您可以配置
    GitHub 仓库，在仓库发生更改时发送警报。此警报可用于启动新的构建，并且如果构建成功，还可以执行部署。
- en: Webhooks are also used heavily by Kubernetes admission controllers, which are
    described in the next section. For more information on the use of webhooks in
    Kubernetes, see [Webhook Mode in the Kubernetes documentation](https://oreil.ly/Aiw7t).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Webhooks 也被 Kubernetes 准入控制器大量使用，下一节将对其进行描述。有关 Kubernetes 中使用 Webhooks 的更多信息，请参见[Kubernetes
    文档中的 Webhook 模式](https://oreil.ly/Aiw7t)。
- en: Admission Controllers
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准入控制器
- en: The key to keeping your Kubernetes platform secure is to protect it from requests
    that can cause harm. *Admission controllers* are one of the mechanisms that Kubernetes
    uses to protect the platform from harmful requests. In some cases, an admission
    controller will prevent a request from creating the Kubernetes object at all.
    In other cases, the admission controller will allow the request to be processed,
    but it will modify the request to make it safer. As an example, if a request comes
    in to start a pod and the request does not specify whether the pod should be started
    in privileged or nonprivileged mode, the admission controller could change the
    request such that in this situation the pod is requested to be started in nonprivileged
    mode.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 Kubernetes 平台安全的关键在于保护免受可能造成伤害的请求。*准入控制器* 是 Kubernetes 用来防止平台受到有害请求的机制之一。在某些情况下，准入控制器将阻止请求创建
    Kubernetes 对象。在其他情况下，准入控制器将允许请求被处理，但会修改请求以使其更安全。例如，如果有一个请求进来要启动一个 Pod，但请求没有指定
    Pod 应该以特权模式还是非特权模式启动，准入控制器可以修改请求，在这种情况下要求 Pod 以非特权模式启动。
- en: A number of admission controllers are embedded in the kube-controller-manager,
    and many are enabled in Kubernetes by default to keep the Kubernetes platform
    secure. In some cases, the admin needs enforcement beyond the scope of the included
    admission controllers. Kubernetes allows the admin to add additional admission
    controllers via registration of webhooks to process requests on Kubernetes objects.
    We will go into more detail regarding admission controllers in [Chapter 3](ch03.html#advanced_resource_management).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 多个准入控制器嵌入在 kube-controller-manager 中，默认情况下在 Kubernetes 中启用以保持平台安全。在某些情况下，管理员需要超出包含的准入控制器范围的强制执行。Kubernetes
    允许管理员通过注册 Webhook 添加额外的准入控制器来处理 Kubernetes 对象上的请求。我们将在 [第 3 章](ch03.html#advanced_resource_management)
    中更详细地讨论准入控制器。
- en: Role-Based Access Control
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: Authorization in Kubernetes is integrated into the platform. Kubernetes authorization
    uses a role-based access control (RBAC) model and provides a fully featured authorization
    platform that allows operators to define various roles via the Kubernetes objects
    `ClusterRole` and `Role` and to bind them to users and groups using `Cluster​Ro⁠leBinding`
    and `RoleBinding`. Think of RBAC as a way of setting permissions on a file system,
    but in the case of Kubernetes, it’s setting permissions on the Kubernetes object
    model. We’ll cover the details of how to use RBAC and how best to build a multitenancy
    model around it in [Chapter 4](ch04.html#single_cluster_availability).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的授权已集成到平台中。Kubernetes 授权使用基于角色的访问控制（RBAC）模型，并提供了一个完全功能的授权平台，允许操作员通过
    Kubernetes 对象 `ClusterRole` 和 `Role` 来定义各种角色，并使用 `ClusterRoleBinding` 和 `RoleBinding`
    将它们绑定到用户和组。将 RBAC 视为在文件系统上设置权限的一种方式，但在 Kubernetes 的情况下，它是在 Kubernetes 对象模型上设置权限。我们将在
    [第 4 章](ch04.html#single_cluster_availability) 中详细讨论如何使用 RBAC，并围绕它建立多租户模型的最佳实践。
- en: Operators
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符
- en: Kubernetes has built-in abstractions like deployments that are extremely well-suited
    stateless applications. In addition, Kubernetes has a very elegant design based
    on control loops that enables it to support a declarative programming model and
    allows the platform to execute robustly at large scale even when failures are
    common.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 具有内置的抽象概念，如部署，非常适合无状态应用程序。此外，Kubernetes 基于控制循环的优雅设计使其能够支持声明式编程模型，并允许平台在大规模甚至在常见失败时执行稳健地。
- en: To support complex stateful applications, Kubernetes needed an extensibility
    model that would enable users to add custom resources and perform life-cycle management
    for those resources. Additionally, it would be ideal if the extensibility model
    could also support the control loop architecture that is used extensively inside
    the Kubernetes platform. Kubernetes includes the [operator pattern](https://oreil.ly/OujZb),
    which provides an extensibility model for custom resources that meet all of these
    requirements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持复杂的有状态应用程序，Kubernetes 需要一个可扩展的模型，使用户能够添加自定义资源并对这些资源进行生命周期管理。此外，如果可扩展模型还能支持
    Kubernetes 平台内广泛使用的控制循环架构将是理想的。Kubernetes 包括 [操作符模式](https://oreil.ly/OujZb)，为满足所有这些要求的自定义资源提供了一个可扩展性模型。
- en: Operators support the creation of custom resources. What this means is that
    you can define a new resource type in Kubernetes by creating a custom resource
    definition, and this new resource can be stored in the Kubernetes etcd database
    just like any standard Kubernetes resource. Additionally, you can create a custom
    controller for your resource that performs the same type of control loop behavior
    that the standard Kubernetes controllers perform. The custom controller can then
    monitor the actual state of your stateful application, compare it to the desired
    state, and then take actions to attempt to achieve the desired state for the application.
    For example, let’s say you create an operator for a special type of database,
    which is a stateful application. The operator and its controller can make sure
    that the actual number of replicas of the database that are running matches the
    desired number of copies. Furthermore, since the operator has a custom controller,
    any custom life-cycle management code that is needed for starting up new copies
    of the database or updating existing copies of the database can be added to the
    controller.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符支持创建自定义资源。这意味着您可以通过创建自定义资源定义在 Kubernetes 中定义新的资源类型，并且这个新资源可以像任何标准 Kubernetes
    资源一样存储在 Kubernetes etcd 数据库中。此外，您可以为您的资源创建一个自定义控制器，执行与标准 Kubernetes 控制器执行相同类型的控制循环行为。自定义控制器可以监视您的有状态应用程序的实际状态，将其与期望状态进行比较，然后采取行动尝试实现应用程序的期望状态。例如，假设您为一种特殊类型的数据库创建了一个运算符，这是一个有状态应用程序。运算符及其控制器可以确保正在运行的数据库副本的实际数量与所需的副本数量匹配。此外，由于运算符具有自定义控制器，可以将启动新数据库副本或更新现有数据库副本所需的任何自定义生命周期管理代码添加到控制器中。
- en: The operator pattern is well-designed, and a key advantage is that it is seamless.
    The custom resources associated with an operator are managed using the `kubectl`
    command-line tool and look just like a standard Kubernetes resource from a management
    perspective. To ease the creation of operators, an operator software development
    kit exists to generate the custom resource definitions and a large portion of
    the controller code required to run the operator’s control loop. As a result of
    the clean architectural design of the operator framework and also due to extensive
    tooling available, creating new operators as the means of adding stateful applications
    continues to grow in popularity. There is now an [Operator Hub](https://operatorhub.io)
    that hosts a large number of existing and reusable operators for managing a variety
    of applications for the Kubernetes platform. We will go into more detail about
    operators and their consumption within Kubernetes in [Chapter 7](ch07.html#multicluster_policy_configuration).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符模式设计良好，其关键优势是无缝。与运算符关联的自定义资源使用`kubectl`命令行工具进行管理，从管理角度看，与标准 Kubernetes 资源完全相同。为了简化运算符的创建，存在一个运算符软件开发工具包，用于生成所需的自定义资源定义和运行运算符控制循环所需的大部分控制器代码。由于运算符框架的清晰架构设计以及可用的广泛工具，通过创建新的运算符作为添加有状态应用程序的手段的做法继续受到欢迎。现在有一个[运算符中心](https://operatorhub.io)，其中托管了大量现有和可重用的运算符，用于管理各种
    Kubernetes 平台上的应用程序。我们将在[第7章](ch07.html#multicluster_policy_configuration)中更详细地讨论运算符及其在
    Kubernetes 中的使用。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered a wide range of topics to give you a broad foundation
    and solid introduction to Kubernetes and OpenShift. We touched upon several topics
    that are critical for running in production, and we will explore many of these
    topics in greater detail in subsequent chapters of this book. In addition, this
    chapter helps to illustrate how the Kubernetes and OpenShift ecosystems have matured
    into platforms that provide a lot of enterprise-level functionality and flexibility.
    In [Chapter 3](ch03.html#advanced_resource_management), we cover a crucial production
    topic: advanced management of Kubernetes resources while running in production.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了广泛的主题，为您提供了对 Kubernetes 和 OpenShift 的广泛基础和扎实介绍。我们涉及了一些对于在生产环境中运行至关重要的主题，并且我们将在本书的后续章节中更详细地探讨这些主题。此外，本章有助于说明
    Kubernetes 和 OpenShift 生态系统如何发展成为提供大量企业级功能和灵活性的平台。在[第3章](ch03.html#advanced_resource_management)中，我们将涵盖一个关键的生产主题：在生产环境中运行时
    Kubernetes 资源的高级管理。
- en: ^([1](ch02.html#ch01fn14-marker)) Lantao Liu and Mike Brown, “Kubernetes Containerd
    Integration Goes GA,” Kubernetes Blog (May 24, 2018), [*https://oreil.ly/SlHmh*](https://oreil.ly/SlHmh).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#ch01fn14-marker)) Lantao Liu 和 Mike Brown, “Kubernetes Containerd
    集成正式发布,” Kubernetes 博客 (2018年5月24日), [*https://oreil.ly/SlHmh*](https://oreil.ly/SlHmh).
- en: '^([2](ch02.html#ch01fn15-marker)) Brendan Burns et al., “Borg, Omega, and Kubernetes:
    Lessons Learned from Three Container-Management Systems over a Decade,” *ACM Queue*
    14 (2016): 70–93, [*http://bit.ly/2vIrL4S*](http://bit.ly/2vIrL4S).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch02.html#ch01fn15-marker)) Brendan Burns 等人, “Borg、Omega 和 Kubernetes:
    从十年三个容器管理系统的经验中学到的教训,” *ACM Queue* 14 (2016): 70–93, [*http://bit.ly/2vIrL4S*](http://bit.ly/2vIrL4S).'
- en: ^([3](ch02.html#ch01fn16-marker)) Tomas Pizarro Moreno, “Running Non-root Containers
    on OpenShift,” Bitnami Engineering (October 27, 2017), [*https://oreil.ly/pxSGf*](https://oreil.ly/pxSGf).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#ch01fn16-marker)) Tomas Pizarro Moreno, “在 OpenShift 上运行非根容器,”
    Bitnami Engineering (2017年10月27日), [*https://oreil.ly/pxSGf*](https://oreil.ly/pxSGf).
- en: ^([4](ch02.html#ch01fn17-marker)) The [OpenShift authentication documentation](https://oreil.ly/23ON5)
    provides more detail on supported authentication methods.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#ch01fn17-marker)) [OpenShift 认证文档](https://oreil.ly/23ON5) 提供了有关支持的认证方法的更多细节。
- en: ^([5](ch02.html#ch01fn18-marker)) The [documentation on image streams](https://oreil.ly/T7vSF)
    provides more information.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#ch01fn18-marker)) [关于镜像流的文档](https://oreil.ly/T7vSF) 提供了更多信息。
- en: ^([6](ch02.html#ch01fn19-marker)) Maciej Szulik, “How to Simplify Container
    Image Management in Kubernetes with OpenShift Image Streams,” Red Hat OpenShift
    Blog (March 23, 2017), [*https://oreil.ly/JEV4u*](https://oreil.ly/JEV4u).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#ch01fn19-marker)) Maciej Szulik, “如何通过 OpenShift Image Streams
    简化 Kubernetes 中的容器镜像管理,” Red Hat OpenShift 博客 (2017年3月23日), [*https://oreil.ly/JEV4u*](https://oreil.ly/JEV4u).
- en: ^([7](ch02.html#ch01fn20-marker)) Wikipedia provides an [overview of webhooks](https://oreil.ly/PLH43).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#ch01fn20-marker)) Wikipedia 提供了对 [webhooks](https://oreil.ly/PLH43)
    的概述。
