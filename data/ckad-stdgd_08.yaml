- en: Chapter 8\. Multi-Container Pods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章\. 多容器 Pod
- en: '[Chapter 5](ch05.xhtml#pods_namespaces) explained how to manage single-container
    Pods. That’s the norm, as you’ll want to run a microservice inside of a single
    Pod to reinforce separation of concerns and increase cohesion. Technically, a
    Pod allows you to configure and run multiple containers.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](ch05.xhtml#pods_namespaces) 解释了如何管理单容器 Pod。这是正常情况，因为你希望在一个单独的 Pod 中运行一个微服务，以加强关注点的分离并增加内聚性。从技术上讲，一个
    Pod 允许你配置和运行多个容器。'
- en: 'In this chapter, we’ll discuss the need for multi-container Pods, their relevant
    use cases, and the design patterns that have emerged in the Kubernetes community.
    The exam outline specifically mentions prominent design patterns: the init container,
    the sidecar container, and others. We’ll get a good grasp of their application
    with the help of representative examples.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论多容器 Pod 的需求、相关的用例以及 Kubernetes 社区中出现的设计模式。考试大纲特别提到了几种主要的设计模式：初始化容器、旁车容器等。我们将通过代表性示例深入了解它们的应用。
- en: Working with Multiple Containers in a Pod
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Pod 中使用多个容器
- en: 'Especially for Kubernetes beginners, how to appropriately design a Pod isn’t
    necessarily apparent. If you read the Kubernetes user documentation and tutorials
    on the internet, you’ll quickly discover that you can create a Pod that runs multiple
    containers at the same time. The question then arises: “Should I deploy my microservices
    stack to a single Pod with multiple containers, or should I create multiple Pods,
    each running a single microservice?” The short answer is to operate a single microservice
    per Pod. This modus operandi promotes a decentralized, decoupled, and distributed
    architecture. Furthermore, it helps with rolling out new versions of a microservice
    without necessarily interrupting other parts of the system.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于 Kubernetes 初学者来说，如何适当地设计一个 Pod 并不一定显而易见。如果你阅读 Kubernetes 用户文档和互联网上的教程，你很快就会发现，你可以创建一个同时运行多个容器的
    Pod。那么问题来了：“我应该将我的微服务堆栈部署到一个具有多个容器的单个 Pod 中，还是应该创建多个每个运行一个微服务的 Pod？”简短的答案是每个 Pod
    运行一个微服务。这种操作模式促进了分散化、解耦和分布式架构。此外，它有助于在不必中断系统其他部分的情况下推出微服务的新版本。
- en: So, what’s the point of running multiple containers in a Pod? There are two
    common use cases. Sometimes, you’ll want to initialize your Pod by executing setup
    scripts, commands, or any other kind of preconfiguration procedure before the
    application container should start. This logic runs in an init container. Other
    times, you’ll want to provide helper functionality that runs alongside the application
    container to avoid the need to bake the logic into application code. For example,
    you may want to massage the log output produced by the application. Containers
    running helper logic are called *sidecars*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在一个 Pod 中运行多个容器有什么意义呢？有两种常见的用例。有时，你希望通过执行设置脚本、命令或任何其他类型的预配置过程来初始化你的 Pod，这些逻辑在初始化容器中运行。其他时候，你可能希望提供与应用程序容器并行运行的辅助功能，以避免将逻辑嵌入到应用程序代码中。例如，你可能希望处理应用程序产生的日志输出。运行辅助逻辑的容器被称为*旁车容器*。
- en: Init Containers
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化容器
- en: '*Init containers* provide initialization logic concerns to be run before the
    main application starts. To draw an analogy, let’s look at a similar concept in
    programming languages. Many programming languages, especially object-oriented
    ones like Java or C++, come with a constructor or a static method block. Those
    language constructs initialize fields, validate data, and set the stage before
    a class can be created. Not all classes need a constructor, but they are equipped
    with the capability.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*初始化容器* 提供了在主应用程序启动之前运行的初始化逻辑关注点。打个比方，我们来看一下编程语言中的类似概念。许多编程语言，尤其是像 Java 或 C++
    这样的面向对象语言，都带有构造函数或静态方法块。这些语言构造用于初始化字段、验证数据，并在创建类之前设置舞台。并非所有类都需要构造函数，但它们都具备这种能力。'
- en: In Kubernetes, this functionality can be achieved with the help of init containers.
    Init containers are always started before the main application containers, which
    means they have their own life cycle. To split up the initialization logic, you
    can even distribute the work into multiple init containers that are run in the
    order of definition in the manifest. Of course, initialization logic can fail.
    If an init container produces an error, the whole Pod is restarted, causing all
    init containers to run again in sequential order. Thus, to prevent any side effects,
    making init container logic idempotent is a good practice. [Figure 8-1](#init_containers)
    shows a Pod with two init containers and the main application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，这个功能可以通过 init 容器来实现。Init 容器总是在主应用容器之前启动，这意味着它们有自己的生命周期。为了拆分初始化逻辑，甚至可以将工作分配到多个按照清单定义顺序运行的
    init 容器中。当然，初始化逻辑可能会失败。如果一个 init 容器产生错误，整个 Pod 将会重新启动，导致所有 init 容器按顺序再次运行。因此，为了防止任何副作用，使
    init 容器逻辑幂等是一个好的实践。[图 8-1](#init_containers) 展示了一个带有两个 init 容器和主应用程序的 Pod。
- en: '![ckd2 0801](Images/ckd2_0801.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 0801](Images/ckd2_0801.png)'
- en: Figure 8-1\. Sequential and atomic life cycle of init containers in a Pod
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. Pod 中 init 容器的顺序和原子生命周期
- en: 'In the past couple of chapters, we’ve explored how to define a container within
    a Pod: you simply specify its configuration under `spec.containers`. For init
    containers, Kubernetes provides a separate section: `spec.initContainers`. Init
    containers are always executed before the main application containers, regardless
    of the definition order in the manifest.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们探讨了如何在 Pod 中定义一个容器：您只需在 `spec.containers` 下指定其配置即可。对于 init 容器，Kubernetes
    提供了一个单独的部分：`spec.initContainers`。Init 容器始终在主应用程序容器之前执行，无论清单中的定义顺序如何。
- en: The manifest shown in [Example 8-1](#init_container_pod) defines an init container
    and a main application container. For the most part, init containers use the same
    attributes as regular containers. There’s one big difference, however. They cannot
    define probes, discussed in [Chapter 14](ch14.xhtml#container_probes). The init
    container sets up a configuration file in the directory */usr/shared/app*. This
    directory has been shared through a Volume so that it can be referenced by a Node.js-based
    application running in the main container.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-1](#init_container_pod) 中显示的清单定义了一个 init 容器和一个主应用程序容器。大部分情况下，init 容器使用与常规容器相同的属性。但有一个很大的区别。它们不能定义探针，这在
    [第 14 章](ch14.xhtml#container_probes) 中讨论过。init 容器在目录 */usr/shared/app* 中设置了一个配置文件。通过
    Volume 共享此目录，以便 Node.js 应用程序在主容器中运行时可以引用它。'
- en: Example 8-1\. A Pod defining an init container
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. 定义一个带有 init 容器和主应用容器的 Pod
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When starting the Pod, you’ll see that the status column of the `get` command
    provides information on init containers as well. The prefix `Init:` signifies
    that an init container is in the process of being executed. The status portion
    after the colon character shows the number of init containers completed versus
    the overall number of init containers configured:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Pod 时，您会看到 `get` 命令的状态列也提供有关 init 容器的信息。前缀 `Init:` 表示正在执行 init 容器的过程。冒号后面的状态部分显示了已完成的
    init 容器数量与配置的总 init 容器数量：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Errors can occur during the execution of init containers. If any container fails
    in the sequential initialization chain, then the whole Pod will fail to start.
    You can always retrieve the logs of an init container by using the `--container`
    command-line option (or `-c` in its short form), as shown in [Figure 8-2](#target_container).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 init 容器期间可能会出现错误。如果顺序初始化链中任何容器失败，则整个 Pod 将无法启动。您可以始终通过使用 `--container` 命令行选项（或其简短形式
    `-c`）来检索 init 容器的日志，如 [图 8-2](#target_container) 所示。
- en: '![ckd2 0802](Images/ckd2_0802.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 0802](Images/ckd2_0802.png)'
- en: Figure 8-2\. Targeting a specific container
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. 针对特定容器
- en: 'The following command renders the logs of the `configurer` init container,
    which equates to the `echo` command we configured in the YAML manifest:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的命令显示了 `configurer` init 容器的日志，这相当于我们在 YAML 清单中配置的 `echo` 命令：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Sidecar Pattern
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旁车模式
- en: 'The life cycle of an init container looks like this: it starts up, runs its
    logic, then terminates once the work has been done. Init containers are not meant
    to keep running over a longer period of time. But some scenarios call for a different
    usage pattern. For example, you may want to create a Pod that runs multiple containers
    continuously alongside one another.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器的生命周期如下：启动、运行逻辑，然后一旦完成工作就终止。初始化容器不打算长时间运行。但有些场景需要不同的使用模式。例如，您可能希望创建一个 Pod，在其中持续运行多个容器。
- en: Sidecar containers introduced in Kubernetes 1.29
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 1.29 引入了边车容器。
- en: Future exams using Kubernetes 1.29 or higher may cover the formalized [sidecar
    container](https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/).
    Sidecar containers are secondary containers that will start with the Pod and remain
    running during the entire life of the Pod.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 未来使用 Kubernetes 1.29 或更高版本的考试可能会涵盖正式化的 [边车容器](https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/)。边车容器是辅助容器，它们将与
    Pod 一起启动并在整个 Pod 的生命周期内保持运行。
- en: 'Typically, there are two different categories of containers: the container
    that runs the application and another container that provides helper functionality
    to the primary application. In the Kubernetes space, the container providing helper
    functionality is called a sidecar. The most commonly used capabilities of a sidecar
    container include file synchronization, logging, and watcher capabilities. The
    sidecars are not part of the main traffic or API of the primary application. They
    usually operate asynchronously and are not involved in the public API.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，容器分为两种不同的类别：运行应用程序的容器和为主应用程序提供辅助功能的另一个容器。在 Kubernetes 中，提供辅助功能的容器称为边车。边车容器最常用的功能包括文件同步、日志记录和监视功能。边车通常不是主应用程序的主要流量或
    API 的一部分。它们通常是异步操作的，不涉及公共 API。
- en: To illustrate the behavior of a sidecar, consider the following use case. The
    main application container runs a web server—in this case, NGINX. Once started,
    the web server produces two standard logfiles. The file */var/log/nginx/access.log*
    captures requests to the web server’s endpoint. The other file, */var/log/nginx/error.log*,
    records failures while processing incoming requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明边车的行为，考虑以下用例。主应用容器运行一个 Web 服务器——在本例中是 NGINX。一旦启动，Web 服务器会生成两个标准日志文件。文件 */var/log/nginx/access.log*
    记录对 Web 服务器端点的请求。另一个文件 */var/log/nginx/error.log* 则记录处理传入请求时的失败。
- en: As part of the Pod’s functionality, we want to implement a monitoring service.
    The sidecar container polls the file’s *error.log* periodically and checks if
    any failures have been discovered. More specifically, the service tries to find
    failures assigned to the error log level, indicated by `[error]` in the log file.
    If an error is found, the monitoring service will react to it. For example, it
    could send a notification to the system administrators. We want to keep the functionality
    as simple as possible. The monitoring service will simply render an error message
    to standard output. The file exchange between the main application container and
    the sidecar container happens through a Volume, as shown in [Figure 8-3](#sidecar_pattern).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Pod 功能的一部分，我们希望实现一个监控服务。边车容器定期轮询文件的 *error.log*，检查是否发现任何故障。更具体地说，该服务试图查找日志文件中标有
    `[error]` 的故障。如果发现错误，监控服务将对其作出反应。例如，它可以向系统管理员发送通知。我们希望保持功能尽可能简单。监控服务只会将错误消息输出到标准输出。主应用容器和边车容器之间的文件交换通过一个
    Volume 实现，如 [图 8-3](#sidecar_pattern) 所示。
- en: '![ckd2 0803](Images/ckd2_0803.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 0803](Images/ckd2_0803.png)'
- en: Figure 8-3\. The sidecar pattern in action
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 边车模式的实际运行情况
- en: The YAML manifest shown in [Example 8-2](#sidecar_pattern_pod) sets up the described
    scenario. The trickiest portion of the code is the lengthy bash command. This
    command runs an infinite loop. As part of each iteration, we inspect the contents
    of the file *error.log*, *grep* for an error and potentially act on it. The loop
    executes every 10 seconds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 8-2](#sidecar_pattern_pod) 中显示的 YAML 文件设置了描述的场景。代码的最棘手部分是长长的 bash 命令。该命令运行一个无限循环。在每次迭代中，我们检查
    *error.log* 文件的内容，使用 *grep* 查找错误并可能采取行动。循环每 10 秒执行一次。
- en: Example 8-2\. An exemplary sidecar pattern implementation
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 典型的边车模式实现
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When starting up the Pod, you’ll notice that the overall number of containers
    will show 2\. After all containers can be started, the Pod signals a `Running`
    status:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Pod时，您会注意到总容器数将显示为2\. 在所有容器都可以启动之后，Pod 会发出 `Running` 状态的信号：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will find that *error.log* does not contain any failure to begin with.
    It starts out as an empty file. With the following commands, you’ll provoke an
    error on purpose. After waiting for at least 10 seconds, you’ll find the expected
    message on the terminal, which you can query for with the `logs` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现 *error.log* 最初并不包含任何故障信息。它开始为空文件。通过以下命令，您可以故意引发错误。等待至少10秒后，您将在终端上找到预期的消息，您可以使用
    `logs` 命令查询该消息：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Adapter Pattern
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式
- en: As application developers, we want to focus on implementing business logic.
    For example, as part of a two-week sprint, we’re tasked with adding a shopping
    cart feature. In addition to the functional requirements, we also have to think
    about operational aspects such as exposing administrative endpoints or crafting
    meaningful and properly formatted log output. It’s easy to fall into the habit
    of rolling all aspects into the application code, which makes it more complex
    and harder to maintain. Cross-cutting concerns in particular need to be replicated
    across multiple applications and are often copied and pasted from one code base
    to another.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序开发者，我们希望专注于实现业务逻辑。例如，在一个为期两周的迭代中，我们被要求添加购物车功能。除了功能需求外，我们还需要考虑暴露管理端点或者制定有意义且正确格式的日志输出等操作方面的内容。很容易陷入将所有方面都包含在应用程序代码中的习惯中，这使得代码更加复杂和难以维护。特别是横切关注点需要在多个应用程序之间复制，并且经常从一个代码库复制粘贴到另一个。
- en: In Kubernetes, we can avoid bundling cross-cutting concerns into the application
    code by running them in another container apart from the main application container.
    The adapter pattern transforms the output produced by the application to make
    it consumable in the format needed by another part of the system. [Figure 8-4](#adapter_pattern)
    illustrates a concrete example of the adapter pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，我们可以通过在主应用容器之外的另一个容器中运行它们来避免将横切关注点捆绑到应用程序代码中。适配器模式将应用程序产生的输出转换为另一部分系统所需的格式，以使其可消费。[图 8-4](#adapter_pattern)
    展示了适配器模式的一个具体示例。
- en: '![ckd2 0804](Images/ckd2_0804.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 0804](Images/ckd2_0804.png)'
- en: Figure 8-4\. The adapter pattern in action
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. 适配器模式的实际应用
- en: The business application running the main container produces timestamped information—in
    this case, the available disk space—and writes it to the file *diskspace.txt*.
    As part of the architecture, we want to consume the file from a third-party monitoring
    application. The problem is that the external application requires the information
    to exclude the timestamp. Of course, we could change the logging format to avoid
    writing the timestamp, but what if we actually want to know when the log entry
    has been written? This is where the adapter pattern can help. A sidecar container
    executes transformation logic that turns the log entries into the format needed
    by the external system without having to change application logic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行主容器的业务应用程序生成带时间戳的信息，例如可用磁盘空间，并将其写入文件 *diskspace.txt*。作为架构的一部分，我们希望从第三方监控应用程序消费该文件。问题在于外部应用程序要求的信息需要排除时间戳。当然，我们可以更改日志格式以避免写入时间戳，但如果我们确实想知道何时写入日志条目呢？这就是适配器模式可以帮助的地方。一个sidecar容器执行转换逻辑，将日志条目转换为外部系统所需的格式，而无需更改应用程序逻辑。
- en: The YAML manifest in [Example 8-3](#adapter_pattern_pod) illustrates what this
    implementation of the adapter pattern could look like. The `app` container produces
    a new log entry every five seconds. The `transformer` container consumes the contents
    of the file, removes the timestamp, and writes it to a new file. Both containers
    have access to the same mount path through a Volume.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: YAML清单中的 [示例 8-3](#adapter_pattern_pod) 展示了适配器模式的实现可能看起来如何。`app` 容器每五秒生成一个新的日志条目。`transformer`
    容器消耗文件内容，移除时间戳，并将其写入新文件。通过一个Volume，这两个容器都可以访问相同的挂载路径。
- en: Example 8-3\. An exemplary adapter pattern implementation
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. 一个示例适配器模式的实现
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After creating the Pod, we’ll find two running containers. We should be able
    to locate the original file, */var/logs/diskspace.txt*, after shelling into the
    `transformer` container. The transformed data exists in a separate file in the
    user home directory:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Pod 后，我们将找到两个正在运行的容器。在进入 `transformer` 容器后，我们应该能够找到原始文件 */var/logs/diskspace.txt*。转换后的数据存在用户主目录中的另一个文件中：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Ambassador Pattern
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大使模式
- en: Another important design pattern covered by the CKAD is the ambassador pattern.
    The ambassador pattern provides a proxy for communicating with external services.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CKAD 还涵盖了另一个重要的设计模式，即大使模式。大使模式为与外部服务通信提供了一个代理。
- en: Many use cases can justify the introduction of the ambassador pattern. The overarching
    goal is to hide and/or abstract the complexity of interacting with other parts
    of the system. Typical responsibilities include retry logic upon a request failure,
    security concerns such as providing authentication or authorization, and monitoring
    latency or resource usage. [Figure 8-5](#ambassador_pattern) illustrates this
    pattern.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用例可以证明引入大使模式的合理性。总体目标是隐藏和/或抽象与系统其他部分交互的复杂性。典型的责任包括在请求失败时的重试逻辑、安全问题（如提供认证或授权）以及监控延迟或资源使用情况。[图 8-5](#ambassador_pattern)
    展示了这种模式。
- en: '![ckd2 0805](Images/ckd2_0805.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 0805](Images/ckd2_0805.png)'
- en: Figure 8-5\. The ambassador pattern in action
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-5\. 大使模式的实际应用
- en: In this example, we’ll want to implement rate-limiting functionality for HTTP(S)
    calls to an external service. For example, the requirements for the rate limiter
    could say that an application can make a maximum of 5 calls every 15 minutes.
    Instead of strongly coupling the rate-limiting logic to the application code,
    it will be provided by an ambassador container. Any calls made from the business
    application need to be funneled through the ambassador container. [Example 8-4](#rate_limiter_implementation)
    shows a Node.js-based rate limiter implementation that makes calls to the external
    service [Postman](https://www.postman.com).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望为对外部服务的 HTTP(S) 调用实现速率限制功能。例如，速率限制器的要求可能是每 15 分钟最多允许应用程序进行 5 次调用。我们不会将速率限制逻辑紧密耦合到应用程序代码中，而是由大使容器提供。从业务应用程序发出的任何调用都必须通过大使容器进行。[示例 8-4](#rate_limiter_implementation)
    展示了一个基于 Node.js 的速率限制器实现，它向外部服务 [Postman](https://www.postman.com) 发起调用。
- en: Example 8-4\. Node.js HTTP rate limiter implementation
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. Node.js HTTP 速率限制器实现
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The corresponding Pod shown in [Example 8-5](#ambassador_pattern_pod) runs the
    main application container on a different port than the ambassador container.
    Every call to the HTTP endpoint of the container named `business-app` would delegate
    to the HTTP endpoint of the container named `ambassador`. It’s important to mention
    that containers running inside of the same Pod can communicate via `localhost`.
    No additional networking configuration is required.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 8-5](#ambassador_pattern_pod) 中展示的对应的 Pod 在不同端口上运行主应用容器和大使容器。对容器 `business-app`
    的每次 HTTP 端点调用都会委派给容器 `ambassador` 的 HTTP 端点。需要指出的是，同一 Pod 内运行的容器可以通过 `localhost`
    进行通信。不需要额外的网络配置。
- en: Example 8-5\. An exemplary ambassador pattern implementation
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. 一个优秀的大使模式实现
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s test the functionality. First, we’ll create the Pod, shell into the container
    that runs the business application, and execute a series of `curl` commands. The
    first five calls will be allowed to the external service. On the sixth call, we’ll
    receive an error message, as the rate limit has been reached within the given
    time frame:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试功能。首先，我们将创建 Pod，进入运行业务应用程序的容器，并执行一系列 `curl` 命令。前五次调用将被允许访问外部服务。在第六次调用时，由于在给定时间段内达到了速率限制，我们将收到一个错误消息：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Summary
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Real-world scenarios call for running multiple containers inside of a Pod. An
    init container helps with setting the stage for the main application container
    by executing initializing logic. Once the initialized logic has been processed,
    the container will be terminated. The main application container starts only if
    the init container ran through its functionality successfully.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界的场景要求在一个 Pod 内部运行多个容器。通过一个初始化容器执行初始化逻辑，可以为主应用容器设置舞台。一旦初始化逻辑完成，该容器将被终止。只有初始化容器顺利运行完其功能后，主应用容器才会启动。
- en: Other design patterns that involve multiple containers per Pod are the adapter
    pattern and the ambassador pattern. The adapter pattern helps with “translating”
    data produced by the application so that it becomes consumable by third-party
    services. The ambassador pattern acts as a proxy for the application container
    when communicating with external services by abstracting the “how.”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及多个容器的其他设计模式包括适配器模式和大使模式。适配器模式有助于“转换”应用程序产生的数据，使其能够被第三方服务使用。大使模式在与外部服务通信时充当应用容器的代理，通过抽象“如何”来实现。
- en: Exam Essentials
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考试要点
- en: Understand the need for running multiple containers in a Pod
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在Pod中运行多个容器的必要性。
- en: Pods can run multiple containers. You will need to understand the difference
    between init containers and sidecar containers and their respective life cycles.
    Practice accessing a specific container in a multi-container Pod with the help
    of the command-line option `--container` or `-c`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Pod可以运行多个容器。你需要了解初始化容器和旁路容器之间的区别及其各自的生命周期。练习在多容器Pod中使用命令行选项`--container`或`-c`访问特定容器。
- en: Know how to create an init container
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何创建一个初始化容器。
- en: Init containers see a lot of use in enterprise Kubernetes cluster environments.
    Understand the need for using them in their respective scenarios. Practice defining
    a Pod with one or even more init containers and observe their linear execution
    when creating the Pod. It’s important to experience the behavior of a Pod in failure
    situations that occur in an init container.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器在企业Kubernetes集群环境中有很高的使用率。理解在各自场景中使用它们的必要性。练习定义一个具有一个或多个初始化容器的Pod，并在创建Pod时观察它们的线性执行。体验在初始化容器发生故障时Pod的行为是很重要的。
- en: Understand multi-container design patterns and how to implement them
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 理解多容器设计模式及其实现方法。
- en: Multi-container Pods are best understood by implementing a scenario for one
    of the established patterns. Based on what you’ve learned, come up with your own
    applicable use case and create a multi-container Pod to solve it. It’s helpful
    to be able to identify sidecar patterns and understand why they are important
    in practice and how to stand them up yourself. As you implement your own sidecars,
    you may notice that you have to brush up on your knowledge of bash.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个已建立模式的场景，最好理解多容器Pod。根据你学到的知识，提出你自己的适用案例并创建一个多容器Pod来解决它。能够识别旁路模式，并理解它们在实践中为何重要以及如何自己搭建它们是很有帮助的。当你实现自己的旁路容器时，你可能会发现需要复习一下bash的知识。
- en: Sample Exercises
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例练习
- en: Solutions to these exercises are available in [Appendix A](app01_split_004.xhtml#appendix_a_multicontainer_pods).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的解决方案可以在[附录A](app01_split_004.xhtml#appendix_a_multicontainer_pods)中找到。
- en: Create a YAML manifest for a Pod named `complex-pod`. The main application container
    named `app` should use the image `nginx:1.25.1` and expose the container port
    80\. Modify the YAML manifest so that the Pod defines an init container named
    `setup` that uses the image `busybox:1.36.1`. The init container runs the command
    `wget -O- google.com`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为名为`complex-pod`的Pod创建一个YAML清单。主应用容器名为`app`，使用镜像`nginx:1.25.1`并暴露容器端口80\. 修改YAML清单，使得Pod定义一个名为`setup`的初始化容器，使用镜像`busybox:1.36.1`。初始化容器运行命令`wget
    -O- google.com`。
- en: Create the Pod from the YAML manifest.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从YAML清单创建Pod。
- en: Download the logs of the init container. You should see the output of the `wget`
    command.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下载初始化容器的日志。你应该看到`wget`命令的输出。
- en: Open an interactive shell to the main application container and run the `ls`
    command. Exit out of the container.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开主应用容器的交互式Shell，并运行`ls`命令。退出容器。
- en: Force-delete the Pod.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 强制删除Pod。
- en: Create a YAML manifest for a Pod named `data-exchange`. The main application
    container named `main-app` should use the image `busybox:1.36.1`. The container
    runs a command that writes a new file every 30 seconds in an infinite loop in
    the directory */var/app/data*. The filename follows the pattern *{counter++}-data.txt*.
    The variable counter is incremented every interval and starts with the value 1.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为名为`data-exchange`的Pod创建一个YAML清单。主应用容器名为`main-app`，使用镜像`busybox:1.36.1`。容器运行的命令是每30秒在目录*/var/app/data*中无限循环写入一个新文件，文件名遵循*{counter++}-data.txt*的模式。变量counter在每个间隔中递增，初始值为1。
- en: Modify the YAML manifest by adding a sidecar container named `sidecar`. The
    sidecar container uses the image `busybox:1.36.1` and runs a command that counts
    the number of files produced by the `main-app` container every 60 seconds in an
    infinite loop. The command writes the number of files to standard output.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改 YAML 配置文件，添加名为 `sidecar` 的辅助容器。该辅助容器使用镜像 `busybox:1.36.1`，并且在无限循环中每 60 秒统计
    `main-app` 容器生成的文件数量。该命令将文件数量输出到标准输出。
- en: Define a Volume of type `emptyDir`. Mount the path */var/app/data* for both
    containers.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个类型为 `emptyDir` 的卷。为两个容器挂载路径 */var/app/data*。
- en: Create the Pod. Tail the logs of the sidecar container.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建 Pod。查看 sidecar 容器的日志。
- en: Delete the Pod.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除 Pod。
