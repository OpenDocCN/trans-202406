- en: Chapter 5\. JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve already seen JSX in action in the previous chapters. You know it’s all
    about writing JavaScript expressions containing XML that looks very much like
    HTML. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And you know you can always “interrupt the flow” of XML by including more JavaScript
    expressions wrapped in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s true even if the expressions happen to be conditions, loops, or more
    JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, you’ll to learn more about JSX and explore some features that
    may surprise and/or delight you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To see the examples above in action, load *05.01.hellojsx.html* from the book’s
    repo. The file is also an illustration of how you can have several React applications
    on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: A Couple Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To experiment and get familiar with the JSX transforms, you can play with the
    live editor at [*https://babeljs.io/repl*](https://babeljs.io/repl) (shown in
    [Figure 5-1](#FIG0501)). Make sure you check the “Prettify” option for better
    readability of the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0501](Images/rur2_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Babel as a live JSX transformation tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see in [Figure 5-2](#FIG0502), the JSX transform is lightweight
    and simple: the JSX source of “Hello world!” from [Chapter 1](ch01.xhtml#ch1)
    becomes a series of calls to `React​.crea⁠teElement()`, using the function syntax
    React works with. It’s just JavaScript, so it’s easy to read and understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0502](Images/rur2_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. “Hello World” transformed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another online tool you may find helpful when learning JSX or transitioning
    an existing app’s markup from HTML is the [HTML-to-JSX compiler](https://magic.reactjs.net/htmltojsx.htm)
    (shown in [Figure 5-3](#FIG0503)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0503](Images/rur2_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. HTML-to-JSX tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, on to some of the particularities of JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace in JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whitespace in JSX is similar to HTML but not identical. For example, if you
    have this JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When React renders it in the browser (you can inspect the resulting HTML in
    the browser’s dev tools), the generated HTML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is effectively an `h1` DOM node with five children, which are text element
    nodes with content: “1”, “plus”, “2”, “is” and “3”, which renders as “1 plus 2
    is 3.” Exactly as you’d expect in HTML, multiple spaces become one when rendered
    in the browser, as depicted in [Figure 5-4](#FIG0504).'
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0504](Images/rur2_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Rendering whitespace (see *05.02.whitespace.html* in the repo)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, in this next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '…you end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, all the whitespace is trimmed, so the end result displayed
    in the browser is “1plus2is3.” You can always add space where you need it with
    `{'' ''}` or turn the literal strings into expressions and add the space there.
    In other words, any of these work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Comments in JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, you see how a new concept sneaked in—adding comments
    to JSX markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the expressions wrapped in `{}` are just JavaScript, you can easily
    add multiline comments using `/* comment */`. You can also add single-line comments
    using `// comment`, but you have to make sure the closing `}` of the expression
    is on a separate line so it’s not considered part of the comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because `{// comment}` is not working (the `}` is now commented out), there’s
    little benefit to using single-line comments. You can keep your comments consistent
    and stick to multiline comments in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: HTML Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use HTML entities in JSX like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example produces a “double right angle quote,” as shown in [Figure 5-5](#FIG0505).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0505](Images/rur2_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. HTML entity in JSX
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, if you use the entity as part of an expression, you will run into
    double-encoding issues. In this example, the HTML gets encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see the result in [Figure 5-6](#FIG0506).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0506](Images/rur2_0506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Double-encoded HTML entity
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To prevent the double-encoding, you can use the Unicode version of the HTML
    entity, which in this case is `\u00bb` (see [*https://dev.w3.org/html5/html-author/charref*](https://dev.w3.org/html5/html-author/charref)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, you can define a constant somewhere at the top of your module
    together with any common spacing. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the constant anywhere you need, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Anti-XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be wondering why you have to jump through hoops to use HTML entities.
    There’s a good reason that outweighs the drawbacks: you need to fight cross-site
    scripting (XSS).'
  prefs: []
  type: TYPE_NORMAL
- en: 'React escapes all strings to prevent a class of XSS attacks. So when you ask
    the user to give you some input and they provide a malicious string, React protects
    you. Take this user input, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Under some circumstances, you may end up writing this into the DOM. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a disaster, because the page reads “John,” but the `<script>` tag loads
    a potentially malicious JavaScript from a third-party web site, likely owned by
    a criminal. This compromises your app and, in turn, the users that trust you.
  prefs: []
  type: TYPE_NORMAL
- en: 'React protects you in cases like this out of the box. React escapes the content
    of `firstname` when you do the following (as shown in [Figure 5-7](#FIG0507)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![rur2 0507](Images/rur2_0507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. Escaping strings (see *05.05.antixss.html* in the repo)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Spread Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX borrows a feature from ECMAScript called the *spread operator* and adopts
    it as a convenience when defining properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have a collection of attributes you want to pass to an `<a>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can always do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But this feels like a lot of boilerplate code. By using spread attributes,
    you can accomplish this in just one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the example above (see *05.06.spread.html* in the repo), you have an object
    of attributes you want to define ahead of time, maybe some of them conditionally.
    Another common use for spread attributes is when you get this object of attributes
    from the outside—often from a parent component. Let’s see how that case plays
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Parent-to-Child Spread Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you’re building a `FancyLink` component that uses a regular `<a>` behind
    the scenes. You want your component to accept all the attributes that `<a>` does
    (`href`, `target`, `rel`, etc.) plus some more that are not part of HTML proper
    (say, `variant`). People can use your component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How can your component take advantage of spread attributes and avoid redefining
    all the properties of `<a>`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one approach where your app may allow only 3 sizes for links and you
    let the users of the component specify the desired size via the custom `variant`
    property. You do the sizing magic with the help of a `switch` statement and CSS
    classes. Then you pass all of the other properties to `<a>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Did you notice the use of `props.children`? This is a convenient way of allowing
    any number of children to be passed over to your component, which you can access
    when composing your UI. In the case of the `FancyLink` component, the following
    is perfectly valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, you do your custom work based on the value of the
    `variant` property, then simply carry over all the properties to `<a>`. This includes
    the `variant` property, which will appear in the resulting DOM, although the browser
    has no use for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do a little better and not pass around unnecessary properties by cloning
    the props passed to you and removing the ones the browser will ignore anyway.
    Something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to do the shallow cloning is to use the JavaScript spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you can clone only the props you’ll pass to the browser and at
    the same time assign the other ones to local variables (thus removing the need
    to delete them afterward), all in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So the end result for the `FancyLink` could look like so (see *05.07.fancylink.html*
    in the repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Returning Multiple Nodes in JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You always have to return a single node (or an array) from your render function.
    Returning two nodes is not allowed. In other words, this is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A Wrapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fix is trivial—just wrap all the nodes in another component such as a `<div>`
    (and add a space between the “Hello” and “World” while you’re at it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A Fragment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To remove the need for an extra wrapper element, newer versions of React added
    *fragments*, which are wrappers that do not add additional DOM nodes when the
    component is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the `React.Fragment` part can be omitted and these empty elements
    also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the time of writing this `<></>` syntax is not supported by the in-browser
    version of Babel and you need to spell out `React​.Frag⁠ment`.
  prefs: []
  type: TYPE_NORMAL
- en: An Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another option is to return an *array* of nodes, as long as the nodes in the
    array have proper `key` attributes. Note the required commas after every element
    of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, you can also sneak in whitespace and other strings in the array,
    and these don’t need a `key`. In a way, this is similar to accepting any number
    of children passed from the parent and propagating them over in your render function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Differences Between JSX and HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX should look familiar—it’s just like HTML, except it’s stricter as it’s XML.
    And it has the added benefits of providing an easy way to add dynamic values,
    loops, and conditions (just wrap them in `{}`).
  prefs: []
  type: TYPE_NORMAL
- en: To start with JSX, you can always use the [HTML-to-JSX compiler](https://magic.reactjs.net/htmltojsx.htm),
    but the sooner you start typing your very own JSX, the better. Let’s consider
    the few differences between HTML and JSX that may surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these differences were touched upon in previous chapters, but let’s
    quickly review them again.
  prefs: []
  type: TYPE_NORMAL
- en: No class, What for?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of the `class` and `for` attributes (both reserved words in ECMAScript),
    you need to use `className` and `htmlFor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: style Is an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `style` attribute takes an object value, not a semicolon-separated string
    as in regular HTML. And the names of the CSS properties are camelCase, not dash-delimited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Closing Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In HTML some tags don’t need to be closed; in JSX (XML) they all do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: camelCase Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Did you spot the `charset` versus `charSet` in the preceding snippet? All attributes
    in JSX need to be camelCase. This is a common source of confusion when starting
    out—you might type `onclick` and notice that nothing happens until you go back
    and change it to `onClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions to this rule are all `data-` and `aria-` prefixed attributes, for
    which JSX does not require camelCase.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaced Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you may want to have a single object that returns several components.
    This can be used to accomplish what is sometimes referred to as *namespacing*,
    where all components of a library have the same prefix. For example a `Library`
    object can contain a `Reader` and `Book` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These are then referred to using a *dot notation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: JSX and Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some differences between JSX and HTML when working with forms. Let’s
    take a look.
  prefs: []
  type: TYPE_NORMAL
- en: onChange Handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using form elements, users change the values of the input elements when
    interacting with them. In React, you can subscribe to such changes via the `onChange`
    attribute. This is much more convenient than dealing with the various form elements
    in pure DOM. Also when typing in `textarea`s and `<input type="text">` fields,
    `onChange` fires as the user types, which is easier to work with rather than firing
    when the element loses focus. This means no more subscribing to all sorts of mouse
    and keyboard events just to monitor typing changes.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an example form that has a text input and two radio buttons. A change
    handler simply logs where the change happens and what the element’s new value
    is. As you see you can also have an overall form handler that fires when anything
    in the form changes. You can use this if you want to handle all the form’s changes
    in one central location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can play live with the example *05.11.forms.onchange.html* in the book’s
    repo. When you type `**x**` in the text input, the change handler is called twice
    because it’s assigned once to the input and once to the form. In the console you’ll
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Same for the radio buttons. Clicking “Option 1” logs to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: value Versus defaultValue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In HTML, if you have `<input id="i" value="hello" />` and then change the value
    by typing “bye,” you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In React, the `value` property (accessible via `event.target.value` in an event
    handler) always has the up-to-date content of the text input. If you want to specify
    an initial default value, you can use the `defaultValue` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, you have an `<input>` component with a prefilled
    “hello” content and `onChange` handler. Appending “!” to the end of “hello” results
    in `value` being “hello!” and `defaultValue` remaining “hello” (see *05.12.forms.value.html*
    in the repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: <textarea> Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For consistency with text inputs, React’s version of `<textarea>` also takes
    a `defaultValue` property. It keeps `target.value` up to date while `defaultValue`
    remains the original. If you go HTML-style and use a child of the `textarea` to
    define a value (not recommended and React will give you a warning), it will be
    treated as if it was a `defaultValue`.
  prefs: []
  type: TYPE_NORMAL
- en: The whole reason HTML `<textarea>` (as defined by W3C) takes a child as its
    value is so that developers can use new lines in the input. However React, being
    all JavaScript, doesn’t suffer from this limitation. When you need a new line,
    you just use `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that you need to use a JavaScript literal `{'hello\nworld'}`. Otherwise
    if you use a literal string property value (e.g., `defaultValue="hello\nworld"`)
    you don’t have access to the special newline meaning of `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: <select> Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use a `<select>` input in HTML, you specify preselected entries using
    `<option selected>`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In React, you specify `value` or `defaultValue` property of the `<select>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: React warns you if you get mixed up and set the `selected` attribute of an `<option>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with multiselects is similar, only you provide an array of preselected
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when working with multiselects—you don’t get `event.target.value`
    in your change handlers. Instead, just as in HTML, you iterate over the `event.tar⁠get​.selectedOptions`.
    For example, a handler that logs the selected values to the console could look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Controlled and Uncontrolled Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the non-React world, the browser maintains the state of form elements such
    as the text in a text input. This state may even be restored if you navigate away
    from a page and then come back. React supports this behavior but also allows you
    to step in and take over the control of the form elements’ state.
  prefs: []
  type: TYPE_NORMAL
- en: When you leave the form elements to behave as the browser wishes, they are known
    as *uncontrolled components* because React does not control them. The opposite—when
    you take over with the help of React—results in *controlled* components.
  prefs: []
  type: TYPE_NORMAL
- en: How do you create one versus the other? A component is *controlled* when you
    set the `value` property (of text inputs, `textarea`s, and selects) or the `checked`
    property (of radio inputs and checkboxes).
  prefs: []
  type: TYPE_NORMAL
- en: When you don’t set these properties, the components are *uncontrolled*. You
    can still initialize (prefill) the form element with a default value by using
    the property `defaultValue` as you saw in several examples in this chapter. Or
    `defaultChecked` in case of radio elements and checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s clarify these concepts with a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrolled example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s an uncontrolled text input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to have prefilled text in the input, use `defaultValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When you want to get the value the user has typed, you can have the `onChange`
    handler on the input or the whole form, as demonstrated in a previous example.
    Let’s consider a more complete example. Imagine you’re creating a profile editing
    form. Your data is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The form needs two text inputs, two radio inputs, and a checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The radio inputs do have `value` properties, but that does not make them controlled.
    Radio buttons (and checkboxes) become controlled when their `checked` property
    is set.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateProfile()` event handler should update the `profile` object. It can
    be fairly simple and generic. For checkboxes (`event.target.type === 'checkbox'`)
    you look for the `target.checked` property. In all other cases, you need the `target.value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 5-8](#FIG0508) shows how the profile is updated after you change the
    gender, accept the terms, and update the first name (see *05.13.uncontrolled.html*
    in the repo).'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it important to treat checkboxes differently (look for `checked` property)
    but not radio inputs? The radio inputs are special in HTML given that you have
    several inputs with the same name and different values, and you get the value
    by referring to the name. You can still access `target.checked` on radio buttons
    if desired, but in this case it’s not necessary. And it’s always `true,` because
    the `onChange` callback is called when you click an element, and when you click
    a radio input, it’s always checked.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0508](Images/rur2_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Uncontrolled component in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Uncontrolled example with an onSubmit handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if you don’t want to (over)react on every change? You want to let the
    users play with the form and you worry about the data only when they submit the
    form. In this case you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use built-in DOM collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use React-created references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how to use the DOM collections (refer to *05.14.uncontrolled.onsubmit.html*
    in the repo). The form is essentially the same, except for the `onSubmit` event
    handler and a new submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what the newly updated `updateProfile()` could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: First, `preventDefault()` kills the propagation of the event and avoids the
    browser’s default behavior of reloading the page. Then it’s a question of looping
    over the profile’s fields and finding the corresponding form element with the
    same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DOM provides access to the collection of form elements by various means,
    one of them being by name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It’s the last variant of this DOM form access that `updateProfile()` uses in
    its loop.
  prefs: []
  type: TYPE_NORMAL
- en: Controlled example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you assign a `value` property (to a `text` input, `textarea`, or `select`)
    or `checked` (to a `radio` input or `checkbox`), it’s your responsibility to control
    the component. You need to maintain the state of the inputs as part of your component
    state. So now, the whole form needs to be a *stateful* component. Let’s see how,
    using a class component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming there’s no other state to maintain but the form itself, you can clone
    the `profile` object as part of the initial state of the component inside the
    constructor. You also need to bind the `updateForm()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The form elements now set `value` instead of `defaultValue` and all the values
    are maintained in `this.state`. Additionally, all inputs now need to have an `onChange`
    handler because they are now being *controlled*. For example, the first name input
    becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It will be a similar situation for the other elements except the submit button,
    as users don’t change its value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `updateForm()`. Using dynamic property names (the `target.name`
    in square brackets), it can be simple. All it needs to do is read the form element
    value and assign it to the state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After the `setState()` call, the form is rerendered and the new form element
    values are read from the updated state (e.g., `value={this.state.firstname}`).
  prefs: []
  type: TYPE_NORMAL
- en: And this is it for the controlled component. As you can see, you need a bit
    of code just to get off the ground. This is the bad news. The good news is that
    now you can update the form values from your state, which is the single source
    of truth. You’re in control.
  prefs: []
  type: TYPE_NORMAL
- en: 'So which is better: controlled or uncontrolled? It depends on your use case.
    There isn’t really a “better” option. Also consider that at the time of writing,
    the official React documentation reads, “*In most cases*, we recommend using controlled
    components to implement forms.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you mix and match controlled and uncontrolled components? Sure. In the
    last two examples, the “Save” button is always uncontrolled (`<input type="submit"
    value="Save" />`) as there’s nothing *to* control; its `value` cannot be changed
    by the user. You can always opt for a mix: control the components you need to
    and leave the others to the browser.'
  prefs: []
  type: TYPE_NORMAL
