- en: Chapter 4\. Using Custom Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we introduce you to custom resources (CR), one of the central
    extension mechanisms used throughout the Kubernetes ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Custom resources are used for small, in-house configuration objects without
    any corresponding controller logic—purely declaratively defined. But custom resources
    also play a central role for many serious development projects on top of Kubernetes
    that want to offer a Kubernetes-native API experience. Examples are service meshes
    such as Istio, Linkerd 2.0, and AWS App Mesh, all of which have custom resources
    at their heart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember “A Motivational Example” from [Chapter 1](ch01.html#intro)? At its
    core, it has a CR that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Custom resources are available in every Kubernetes cluster since version 1.7\.
    They are stored in the same `etcd` instance as the main Kubernetes API resources
    and served by the same Kubernetes API server. As shown in [Figure 4-1](#apiextensions-apiserver),
    requests fall back to the `apiextensions-apiserver`, which serves the resources
    defined via CRDs, if they are neither of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Handled by aggregated API servers (see [Chapter 8](ch08.html#ch_custom-api-servers)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native Kubernetes resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![API Extensions API server inside of the Kubernetes API server](assets/prku_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. The API Extensions API server inside the Kubernetes API server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A CustomResourceDefinition (CRD) is a Kubernetes resource itself. It describes
    the available CRs in the cluster. For the preceding example CR, the corresponding
    CRD looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The name of the CRD—in this case, `ats.cnat.programming-kubernetes.info`—must
    match the plural name followed by the group name. It defines the kind `At` CR
    in the API group `cnat.programming-kubernetes.info` as a namespaced resource called
    `ats`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this CRD is created in a cluster, `kubectl` will automatically detect the
    resource, and the user can access it via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Discovery Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behind the scenes, `kubectl` uses discovery information from the API server
    to find out about the new resources. Let’s look a bit deeper into this discovery
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'After increasing the verbosity level of `kubectl`, we can actually see how
    it learns about the new resource type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The discovery steps in detail are:'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, `kubectl` does not know about `ats`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hence, `kubectl` asks the API server about all existing API groups via the */apis*
    discovery endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, `kubectl` asks the API server about resources in all existing API groups
    via the */apis/`group version`* group discovery endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, `kubectl` translates the given type, `ats`, to a triple of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group (here `cnat.programming-kubernetes.info`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Version (here `v1alpha1`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource (here `ats`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The discovery endpoints provide all the necessary information to do the translation
    in the last step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is all implemented by the discovery `RESTMapper`. We also saw this very
    common type of `RESTMapper` in [“REST Mapping”](ch03.html#RESTMapping).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `kubectl` CLI also maintains a cache of resource types in *~/.kubectl* so
    that it does not have to re-retrieve the discovery information on every access.
    This cache is invalidated every 10 minutes. Hence, a change in the CRD might show
    up in the CLI of the respective user up to 10 minutes later.
  prefs: []
  type: TYPE_NORMAL
- en: Type Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s look at the CRD and the offered features in more detail: as in the
    `cnat` example, CRDs are Kubernetes resources in the `apiextensions.k8s.io/v1beta1`
    API group provided by the `apiextensions-apiserver` inside the Kubernetes API
    server process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema of CRDs looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Many of the fields are optional or are defaulted. We will explain the fields
    in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a CRD object, the `apiextensions-apiserver` inside of `kube-apiserver`
    will check the names and determine whether they conflict with other resources
    or whether they are consistent in themselves. After a few moments it will report
    the result in the status of the CRD, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the missing name fields in the spec are defaulted and reflected
    in the status as accepted names. Moreover, the following conditions are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NamesAccepted` describes whether the given names in the spec are consistent
    and free of conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Established` describes that the API server serves the given resource under
    the names in `status.acceptedNames`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that certain fields can be changed long after the CRD has been created.
    For example, you can add short names or columns. In this case, a CRD can be established—that
    is, served with the old names—although the spec names have conflicts. Hence the
    `NamesAccepted` condition would be false and the spec names and accepted names
    would differ.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Features of Custom Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we discuss advanced features of custom resources, such as validation
    or subresources.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Custom Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRs can be validated by the API server during creation and updates. This is
    done based on the [OpenAPI v3 schema](http://bit.ly/2RqtN5i) specified in the
    `validation` fields in the CRD spec.
  prefs: []
  type: TYPE_NORMAL
- en: When a request creates or mutates a CR, the JSON object in the spec is validated
    against this spec, and in case of errors the conflicting field is returned to
    the user in an HTTP code `400` response. [Figure 4-2](#apiextensions-apiserver-validation)
    shows where validation takes places in the request handler inside the `apiextensions-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: More complex validations can be implemented in validating admission webhooks—that
    is, in a Turing-complete programming language. [Figure 4-2](#apiextensions-apiserver-validation)
    shows that these webhooks are called directly after the OpenAPI-based validations
    described in this section. In [“Admission Webhooks”](ch09.html#admission-webhooks),
    we will see how admission webhooks are implemented and deployed. There, we’ll
    look into validations that take other resources into account and therefore go
    far beyond OpenAPI v3 validation. Luckily, for many use cases OpenAPI v3 schemas
    are sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: '![Validation step in the handler stack of the `apiextensions-apiserver`](assets/prku_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Validation step in the handler stack of the apiextensions-apiserver
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The OpenAPI schema language is based on the [JSON Schema standard](http://bit.ly/2J7aIT7),
    which uses JSON/YAML itself to express a schema. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This schema specifies that the value is actually a JSON object;^([1](ch04.html#idm46336863073336))
    that is, it is a string map and not a slice or a value like a number. Moreover,
    it has (aside from `metadata`, `kind`, and `apiVersion`, which are implicitly
    defined for custom resources) two additional properties: `spec` and `status`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each is a JSON object as well. `spec` has the required fields `schedule` and
    `command`, both of which are strings. `schedule` has to match a pattern for an
    ISO date (sketched here with some regular expressions). The optional `status`
    property has a string field called `phase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating OpenAPI schemata manually can be tedious. Luckily, work is underway
    to make this much easier via code generation: the Kubebuilder project—see [“Kubebuilder”](ch06.html#kubebuilder)—has
    developed [`crd-gen` in *sig.k8s.io/controller-tools*](http://bit.ly/2J00kvi),
    and this is being extended step by step so that it’s usable in other contexts.
    The generator [`crd-schema-gen`](http://bit.ly/31N0eQf) is a fork of `crd-gen`
    in this direction.'
  prefs: []
  type: TYPE_NORMAL
- en: Short Names and Categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like native resources, custom resources might have long resource names. They
    are great on the API level but tedious to type in the CLI. CRs can have short
    names as well, like the native resource `daemonsets`, which can be queried with
    `kubectl get ds`. These short names are also known as aliases, and each resource
    can have any number of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view all of the available short names, use the `kubectl api-resources` command
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, `kubectl` learns about short names via discovery information (see [“Discovery
    Information”](#discovery)). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After that, a `kubectl get at` will list all `cnat` CRs in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Further, CRs—as with any other resource—can be part of categories. The most
    common use is the `all` category, as in `kubectl get all`. It lists all user-facing
    resources in a cluster, like pods and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CRs defined in the cluster can join a category or create their own category
    via the `categories` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With this, `kubectl get all` will also list the `cnat` CR in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Printer Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `kubectl` CLI tool uses server-side printing to render the output of `kubectl
    get`. This means that it queries the API server for the columns to display and
    the values in each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom resources support server-side printer columns as well, via `additionalPrinterColumns`.
    They are called “additional” because the first column is always the name of the
    object. These columns are defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `name` field is the column name, the `type` is an OpenAPI type as defined
    in the [data types](http://bit.ly/2N0DSY4) section of the specification, and the
    `format` (as defined in the same document) is optional and might be interpreted
    by `kubectl` or other clients.
  prefs: []
  type: TYPE_NORMAL
- en: Further, `description` is an optional human-readable string, used for documentation
    purposes. The `priority` controls in which verbosity mode of `kubectl` the column
    is displayed. At the time of this writing (with Kubernetes 1.14), only zero is
    supported, and all columns with higher priority are hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `JSONPath` defines which values are to be displayed. It is a simple
    JSON path inside of the CR. Here, “simple” means that it supports object field
    syntax like `.spec.foo.bar`, but not more complex JSON paths that loop over arrays
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, the example CRD from the introduction could be extended with `additionalPrinterColumns`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `kubectl` would render a `cnat` resource as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we have a look at subresources.
  prefs: []
  type: TYPE_NORMAL
- en: Subresources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly mentioned subresources in [“Status Subresources: UpdateStatus”](ch03.html#client-go-subresource).
    Subresources are special HTTP endpoints, using a suffix appended to the HTTP path
    of the normal resource. For example, the pod standard HTTP path is */api/v1/namespace/`namespace`/pods/`name`*.
    Pods have a number of subresources, such as */logs*, */portforward*, */exec*,
    and */status*. The corresponding subresource HTTP paths are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/logs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/portforward*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/exec*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/status*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subresource endpoints use a different protocol than the main resource endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of this writing, custom resources support two subresources: */scale*
    and */status*. Both are opt-in—that is, they must be explicitly enabled in the
    CRD.'
  prefs: []
  type: TYPE_NORMAL
- en: Status subresource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The */status* subresource is used to split the user-provided specification
    of a CR instance from the controller-provided status. The main motivation for
    this is privilege separation:'
  prefs: []
  type: TYPE_NORMAL
- en: The user usually should not write status fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller should not write specification fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The RBAC mechanism for access control does not allow rules at that level of
    detail. Those rules are always per resource. The */status* subresource solves
    this by providing two endpoints that are resources on their own. Each can be controlled
    with RBAC rules independently. This is often called a *spec-status split*. Here’s
    an example of such a rule for the `ats` resource, which applies only to the */status*
    subresource (while `"ats"` would match the main resource):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Resources (including custom resources) that have a */status* subresource have
    changed semantics, also for the main resource endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: They ignore changes to the status on the main HTTP endpoint during create (the
    status is just dropped during a create) and updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Likewise, the */status* subresource endpoint ignores changes outside of the
    status of the payload. A create operation on the */status* endpoint is not possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever something outside of `metadata` and outside of `status` changes (this
    especially means changes in the spec), the main resource endpoint will increase
    the `metadata.generation` value. This can be used as a trigger for a controller
    indicating that the user desire has changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that usually both `spec` and `status` are sent in update requests, but
    technically you could leave out the respective other part in a request payload.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the */status* endpoint will ignore everything outside of the
    status, including metadata changes like labels or annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spec-status split of a custom resource is enabled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note here that the `status` field in that YAML fragment is assigned the empty
    object. This is the way to set a field that has no other properties. Just writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: will result in a validation error because in YAML the result is a `null` value
    for `status`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Enabling the spec-status split is a breaking change for an API. Old controllers
    will write to the main endpoint. They won’t notice that the status is always ignored
    from the point where the split is activated. Likewise, a new controller can’t
    write to the new */status* endpoint until the split is activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kubernetes 1.13 and later, subresources can be configured per version. This
    allows us to introduce the */status* subresource without a breaking change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This enables the */status* subresource for `v1beta1`, but not for `v1alpha1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The optimistic concurrency semantics (see [“Optimistic Concurrency”](ch01.html#optimistic-concurrency))
    are the same as for the main resource endpoints; that is, `status` and `spec`
    share the same resource version counter and */status* updates can conflict due
    to writes to the main resource, and vice versa. In other words, there is no split
    of `spec` and `status` on the storage layer.
  prefs: []
  type: TYPE_NORMAL
- en: Scale subresource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second subresource available for custom resources is */scale*. The */scale*
    subresource is a (projective)^([2](ch04.html#idm46336862332104)) view on the resource,
    allowing us to view and to modify replica values only. This subresource is well
    known for resources like deployments and replica sets in Kubernetes, which obviously
    can be scaled up and down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kubectl scale` command makes use of the */scale* subresource; for example,
    the following will modify the specified replica value in the given instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this, an update of the replica value is written to `spec.replicas` and
    returned from there during a `GET`.
  prefs: []
  type: TYPE_NORMAL
- en: The label selector cannot be changed through the */status* subresource, only
    read. Its purpose is to give a controller the information to count the corresponding
    objects. For example, the `ReplicaSet` controller counts the corresponding pods
    that satisfy this selector.
  prefs: []
  type: TYPE_NORMAL
- en: The label selector is optional. If your custom resource semantics do not fit
    label selectors, just don’t specify the JSON path for one.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example of `kubectl scale --replicas=3 ...` the value `3` is
    written to `spec.replicas`. Any other simple JSON path can be used, of course;
    for example, `spec.instances` or `spec.size` would be a sensible field name, depending
    on the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kind of the object read from or written to the endpoint is `Scale` from
    the `autoscaling/v1` API group. Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the optimistic concurrency semantics are the same for the main resource
    and for the */scale* subresource. That is, main resource writes can conflict with
    */scale* writes, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: A Developer’s View on Custom Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Custom resources can be accessed from Golang using a number of clients. We
    will concentrate on:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `client-go` dynamic client (see [“Dynamic Client”](#dynamic-client))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a typed client:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As provided by [kubernetes-sigs/controller-runtime](http://bit.ly/2ZFtDKd) and
    used by the Operator SDK and Kubebuilder (see [“controller-runtime Client of Operator
    SDK and Kubebuilder”](#controller-runtime))
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As generated by `client-gen`, like that in [*k8s.io/client-go/kubernetes*](http://bit.ly/2FnmGWA)
    (see [“Typed client created via client-gen”](#clientgen-client))
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of which client to use depends mainly on the context of the code
    to be written, especially the complexity of implemented logic and the requirements
    (e.g., to be dynamic and to support GVKs unknown at compile time).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding list of clients:'
  prefs: []
  type: TYPE_NORMAL
- en: Decreases in the flexibility to handle unknown GVKs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increases in type safety.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increases in the completeness of features of the Kubernetes API they provide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic client in [*k8s.io/client-go/dynamic*](http://bit.ly/2Y6eeSK) is
    totally agnostic to known GVKs. It does not even use any Go types other than [*unstructured.Unstructured*](http://bit.ly/2WYZ6oS),
    which wraps just `json.Unmarshal` and its output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic client makes use of neither a scheme nor a RESTMapper. This means
    that the developer has to provide all the knowledge about types manually by providing
    a resource (see [“Resources”](ch03.html#resources)) in the form of a GVR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If a REST client config is available (see [“Creating and Using a Client”](ch03.html#rest-client-config)),
    the dynamic client can be created in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The REST access to a given GVR is just as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This gives you the deployment `foo` in the given namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must know the scope of the resource (i.e., whether it is namespaced or cluster-scoped).
    Cluster-scoped resources just leave out the `Namespace(namespace)` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input and output of the dynamic client is an `*unstructured.Unstructured`—that
    is, an object that contains the same data structure that `json.Unmarshal` would
    output on unmarshaling:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects are represented by `map[string]interface{}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays are represented by `[]interface{}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive types are `string`, `bool`, `float64`, or `int64`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method `UnstructuredContent()` provides access to this data structure inside
    of an unstructured object (we can also just access `Unstructured.Object`). There
    are helpers in the same package to make retrieval of fields easy and manipulation
    of the object possible—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'which returns the name of the deployment—`"foo"` in this case. `found` is true
    if the field was actually found (not only empty, but actually existing). `err`
    reports if the type of an existing field is unexpected (i.e., not a string in
    this case). Other helpers are the generic ones, once with a deep copy of the result
    and once without:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other typed variants that do a type-cast and return an error if that
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally a generic setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The dynamic client is used in Kubernetes itself for controllers that are generic,
    like the garbage collection controller, which deletes objects whose parents have
    disappeared. The garbage collection controller works with any resource in the
    system and hence makes extensive use of the dynamic client.
  prefs: []
  type: TYPE_NORMAL
- en: Typed Clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typed clients do not use `map[string]interface{}`-like generic data structures
    but instead use real Golang types, which are different and specific for each GVK.
    They are much easier to use, have considerably increased type safety, and make
    code much more concise and readable. On the downside, they are less flexible because
    the processed types have to be known at compile time, and those clients are generated,
    and this adds complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Before going into two implementations of typed clients, let’s look into the
    representation of kinds in the Golang type system (see [“API Machinery in Depth”](ch03.html#api-machinery-core)
    for the theory behind the Kubernetes type system).
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kinds are represented as Golang structs. Usually the struct is named as the
    kind (though technically it doesn’t have to be) and is placed in a package corresponding
    to the group and version of the GVK at hand. A common convention is to place the
    GVK *`group`*/*`version`*.*`Kind`* into a Go package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: and define a Golang struct *`Kind`* in the file *types.go*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Golang type corresponding to a GVK embeds the `TypeMeta` struct from
    the package [*k8s.io/apimachinery/pkg/apis/meta/v1*](http://bit.ly/2Y5HdWT). `TypeMeta`
    just consists of the `Kind` and `ApiVersion` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, every top-level kind—that is, one that has its own endpoint and
    therefore one (or more) corresponding GVRs (see [“REST Mapping”](ch03.html#RESTMapping))—has
    to store a name, a namespace for namespaced resources, and a pretty long number
    of further metalevel fields. All these are stored in a struct called `ObjectMeta`
    in the package [*k8s.io/apimachinery/pkg/apis/meta/v1*](http://bit.ly/2XSt8eo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of additional fields. We highly recommend you read through
    the [extensive inline documentation](http://bit.ly/2IutNyh), because it gives
    a good picture of the core functionality of Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes top-level types (i.e., those that have an embedded `TypeMeta`, and
    an embedded `ObjectMeta`, and—in this case—are persisted into `etcd`) look very
    similar to each other in the sense that they usually have a `spec` and a `status`.
    See this example of a deployment from [*k8s.io/kubernetes/apps/v1/types.go*](http://bit.ly/2RroTFb):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While the actual content of the types for `spec` and `status` differs significantly
    between different types, this split into `spec` and `status` is a common theme
    or even a convention in Kubernetes, though it’s not technically required. Hence,
    it is good practice to follow this structure of CRDs as well. Some CRD features
    even require this structure; for example, the */status* subresource for custom
    resources (see [“Status subresource”](#status-subresource))—when enabled—always
    applies to the `status` substructure only of the custom resource instance. It
    cannot be renamed.
  prefs: []
  type: TYPE_NORMAL
- en: Golang package structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen, the Golang types are traditionally placed in a file called
    *types.go* in the package *pkg/apis/`group`/`version`*. In addition to that file,
    there are a couple more files we want to go through now. Some of them are manually
    written by the developer, while some are generated with code generators. See [Chapter 5](ch05.html#ch_autocodegen)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *doc.go* file describes the API’s purpose and includes a number of package-global
    code generation tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, *register.go* includes helpers to register the custom resource Golang
    types into a scheme (see [“Scheme”](ch03.html#scheme)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then, *zz_generated.deepcopy.go* defines deep-copy methods on the custom resource
    Golang top-level types (i.e., `SomeKind` and `SomeKindList` in the preceding example
    code). In addition, all substructs (like those for the `spec` and `status`) become
    deep-copyable as well.
  prefs: []
  type: TYPE_NORMAL
- en: Because the example uses the tag `+k8s:deepcopy-gen=package` in *doc.go*, the
    deep-copy generation is on an opt-out basis; that is, `DeepCopy` methods are generated
    for every type in the package that does not opt out with `+k8s:deepcopy-gen=false`.
    See [Chapter 5](ch05.html#ch_autocodegen) and especially [“deepcopy-gen Tags”](ch05.html#deepcopy-tags)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Typed client created via client-gen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the API package *pkg/apis/`group`/`version`* in place, the client generator
    `client-gen` creates a typed client (see [Chapter 5](ch05.html#ch_autocodegen)
    for details, especially [“client-gen Tags”](ch05.html#clientgen-tags)), in *pkg/generated/clientset/versioned*
    by default (pkg/client/clientset/versioned in old versions of the generator).
    More precisely, the generated top-level object is a client set. It subsumes a
    number of API groups, versions, and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [top-level file](http://bit.ly/2GdcikH) looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The client set is represented by the interface `Interface` and gives access
    to the API group client interface for each version—for example, `CnatV1alpha1Interface`
    in this sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of a client set can be created with the `NewForConfig` helper function.
    This is analogous to the clients for core Kubernetes resources discussed in [“Creating
    and Using a Client”](ch03.html#rest-client-config):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code generation machinery allows us to program logic for
    custom resources in the very same way as for core Kubernetes resources. Higher-level
    tools like informers are also available; see `informer-gen` in [Chapter 5](ch05.html#ch_autocodegen).
  prefs: []
  type: TYPE_NORMAL
- en: controller-runtime Client of Operator SDK and Kubebuilder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of completeness, we want to take a quick look at the third client,
    which is listed as the second option in [“A Developer’s View on Custom Resources”](#crd-dev).
    The `controller-runtime` project provides the basis for the operator solutions
    Operator SDK and Kubebuilder presented in [Chapter 6](ch06.html#ch_operator-solutions).
    It includes a client that uses the Go types presented in [“Anatomy of a type”](#anatomy-of-CRD-types).
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the `client-gen`–generated client of the previous [“Typed client
    created via client-gen”](#clientgen-client), and similarly to the [“Dynamic Client”](#dynamic-client),
    this client is one instance, capable of handling any kind that is registered in
    a given scheme.
  prefs: []
  type: TYPE_NORMAL
- en: It uses discovery information from the API server to map the kinds to HTTP paths.
    Note that [Chapter 6](ch06.html#ch_operator-solutions) will go into greater detail
    on how this client is used as part of those two operator solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick example of how to use `controller-runtime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The client object’s `List()` method accepts any `runtime.Object` registered
    in the given scheme, which in this case is the one borrowed from `client-go` with
    all standard Kubernetes kinds being registered. Internally, the client uses the
    given scheme to map the Golang type `*corev1.PodList` to a GVK. In a second step,
    the `List()` method uses discovery information to get the GVR for pods, which
    is `schema.GroupVersionResource{"", "v1", "pods"}`, and therefore accesses */api/v1/namespace/default/pods*
    to get the list of pods in the passed namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same logic can be used with custom resources. The main difference is to
    use a custom scheme that contains the passed Go type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note how the invocation of the `List()` command does not change at all.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you write an operator that accesses many different kinds using this
    client. With the typed client of [“Typed client created via client-gen”](#clientgen-client),
    you would have to pass many different clients into the operator, making the plumbing
    code pretty complex. In contrast, the `controller-runtime` client presented here
    is just one object for all kinds, assuming all of them are in one scheme.
  prefs: []
  type: TYPE_NORMAL
- en: All three types of clients have their uses, with advantages and disadvantages
    depending on the context in which they are used. In generic controllers that handle
    unknown objects, only the dynamic client can be used. In controllers where type
    safety helps a lot to enforce code correctness, the generated clients are a good
    fit. The Kubernetes project itself has so many contributors that stability of
    the code is very important, even when it is extended and rewritten by so many
    people. If convenience and high velocity with minimal plumbing is important, the
    `controller-runtime` client is a good fit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced you to custom resources, the central extension mechanisms used
    in the Kubernetes ecosystem, in this chapter. By now you should have a good understanding
    of their features and limitations as well as the available clients.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to code generation for managing said resources.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.html#idm46336863073336-marker)) Do not confuse Kubernetes and JSON
    objects here. The latter is just another term for a string map, used in the context
    of JSON and in OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.html#idm46336862332104-marker)) “Projective” here means that the
    `scale` object is a projection of the main resource in the sense that it shows
    only certain fields and hides everything else.
  prefs: []
  type: TYPE_NORMAL
