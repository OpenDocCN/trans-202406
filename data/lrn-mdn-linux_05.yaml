- en: Chapter 5\. Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focus on files and filesystems. The UNIX concept of “everything
    is a file” lives on in Linux, and while that’s not true 100% of the time, most
    resources in Linux are indeed files. Files can be everything from the content
    of the letter you write to your school to the funny GIF you download (from an
    obviously safe and trusted site).
  prefs: []
  type: TYPE_NORMAL
- en: There are other things that are also exposed as files in Linux—for example,
    devices and pseudo-devices such as in `echo "Hello modern Linux users" > /dev/pts/0`,
    which prints “Hello modern Linux users” to the screen. While you may not associate
    these resources with files, you can access them with the same methods and tools
    you know from regular files. For example, the kernel exposes certain runtime information
    (as discussed in [“Process Management”](ch02.xhtml#kernel-process-management))
    about a process, such as its PID or the binary used to run the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'What all these things have in common is a standardized, uniform interface:
    opening a file, gathering information about a file, writing to a file, and so
    forth. In Linux, [filesystems](https://oreil.ly/9CEdn) provide this uniform interface.
    This interface, together with the fact that Linux treats files as a stream of
    bytes, without any expectations about the structure, enables us to build tools
    that work with a range of different file types.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the uniform interface that filesystems provide reduces your cognitive
    load, making it faster for you to learn how to use Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we first define some relevant terms. Then, we look at how Linux
    implements the “everything is a file” abstraction. Next, we review special-purpose
    filesystems the kernel uses to expose information about processes or devices.
    We then move on to regular files and filesystems, something you would typically
    associate with documents, data, and programs. We compare filesystem options and
    discuss common operations.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into the filesystem terminology, let’s first make some implicit
    assumptions and expectations about filesystems more explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: While there are exceptions, most of the widely used filesystems today are hierarchical.
    That is, they provide the user with a single filesystem tree, starting at the
    root (`/`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the filesystem tree, you find two different types of objects: directories
    and files. Think of directories as an organizational unit, allowing you to group
    files. If you’d like to apply the tree analogy, directories are the nodes in the
    tree, whereas the leaves are either files or directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can navigate a filesystem by listing the content of a directory (`ls`),
    changing into that directory (`cd`), and printing the current working directory
    (`pwd`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permissions are built-in: as discussed in [“Permissions”](ch04.xhtml#permissions),
    one of the attributes a filesystem captures is ownership. Consequently, ownership
    enforces access to files and directories via the assigned permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, filesystems are implemented in the kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While filesystems are usually, for performance reasons, implemented in the kernel
    space, there’s also an option to implement them in user land. See the [Filesystem
    in Userspace (FUSE) documentation](https://oreil.ly/hIVgq) and the [libfuse project
    site](https://oreil.ly/cEZyY).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this informal high-level explanation out of the way, we now focus on some
    more crisp definitions of terms that you’ll need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Drive
  prefs: []
  type: TYPE_NORMAL
- en: A (physical) block device such as a hard disk drive (HDD) or a solid-state drive
    (SSD). In the context of virtual machines, a drive also can be emulated—for example,
    */dev/sda* (SCSI device) or */dev/sdb* (SATA device) or */dev/hda* (IDE device).
  prefs: []
  type: TYPE_NORMAL
- en: Partition
  prefs: []
  type: TYPE_NORMAL
- en: You can logically split up drives into partitions, a set of storage sectors.
    For example, you may decide to create two partitions on your HDD, which then would
    show up as */dev/sdb1* and */dev/sdb2*.
  prefs: []
  type: TYPE_NORMAL
- en: Volume
  prefs: []
  type: TYPE_NORMAL
- en: A volume is somewhat similar to a partition, but it is more flexible, and it
    is also formatted for a specific filesystem. We’ll discuss volumes in detail in
    [“Logical Volume Manager”](#lvm).
  prefs: []
  type: TYPE_NORMAL
- en: Super block
  prefs: []
  type: TYPE_NORMAL
- en: When formatted, filesystems have a special section in the beginning that captures
    the metadata of the filesystem. This includes things like filesystem type, blocks,
    state, and how many inodes per block.
  prefs: []
  type: TYPE_NORMAL
- en: Inodes
  prefs: []
  type: TYPE_NORMAL
- en: In a filesystem, inodes store metadata about files, such as size, owner, location,
    date, and permissions. However, inodes do not store the filename and the actual
    data. This is kept in directories, which really are just a special kind of regular
    file, mapping inodes to filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was a lot of theory, so let’s see these concepts in action. First, here’s
    how to see what drives, partitions, and volumes are present in your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List all block devices but exclude pseudo (loop) devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We have a disk drive called *sda* with some 223 GB overall.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_filesystems_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: There are two partitions here, with *sda1* being the boot partition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_filesystems_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The second partition, called *sda2*, contains two volumes (see [“Logical Volume
    Manager”](#lvm) for details).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an overall idea of the physical and logical setup, let’s have
    a closer look at the filesystems in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List filesystems but exclude [squashfs types](https://oreil.ly/vS88y) (specialized
    read-only compressed filesystem originally developed for CDs, now also for snapshots).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go a step further and look at individual filesystem objects such as
    directories or files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: File type information
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Information about device and inode
  prefs: []
  type: TYPE_NORMAL
- en: In the previous command, if we used `stat .` (note the dot), we would have gotten
    the respective directory file information, including its inode, number of blocks
    used, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-1](#tab-fsbasics) lists some basic filesystem commands that allow
    you to explore the concepts we introduced earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Selection of low-level filesystem and block device commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Use case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `lsblk` | List all block devices |'
  prefs: []
  type: TYPE_TB
- en: '| `fdisk`, `parted` | Manage disk partitions |'
  prefs: []
  type: TYPE_TB
- en: '| `blkid` | Show block device attributes such as UUID |'
  prefs: []
  type: TYPE_TB
- en: '| `hwinfo` | Show hardware information |'
  prefs: []
  type: TYPE_TB
- en: '| `file -s` | Show filesystem and partition information |'
  prefs: []
  type: TYPE_TB
- en: '| `stat`, `df -i`, `ls -i` | Show and list inode-related information |'
  prefs: []
  type: TYPE_TB
- en: 'Another term you’ll come across in the context of filesystems is that of *links*.
    Sometimes you want to refer to files with different names or provide shortcuts.
    There are two types of links in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: Hard links
  prefs: []
  type: TYPE_NORMAL
- en: Reference inodes and can’t refer to directories. They also do not work across
    filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links, or [symlinks](https://oreil.ly/yRWYA)
  prefs: []
  type: TYPE_NORMAL
- en: Special files with their content being a string representing the path of another
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see links in action (some outputs shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a hard link to *myfile*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a soft link to the same file (notice the `-s` option).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_filesystems_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: List the files. Notice the different file types and the rendering of the name.
    We could also have used `ls -ali *alias`, which would show that the inodes were
    the same on the two names associated with the hard link.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_filesystems_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Show the file details of the hard link.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_filesystems_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Show the file details of the soft link.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with filesystem terminology let’s explore how Linux
    makes it possible to treat any kind of resource as a file.
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual File System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux manages to provide a file-like access to many sorts of resources (in-memory,
    locally attached, or networked storage) through an abstraction called the [virtual
    file system (VFS)](https://oreil.ly/3sZQ1). The basic idea is to introduce a layer
    of indirection between the clients (syscalls) and the individual filesystems implementing
    operations for a concrete device or other kind of resource. This means that VFS
    separates the generic operation (open, read, seek) from the actual implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'VFS is an abstraction layer in the kernel that provides clients a common way
    to access resources, based on the file paradigm. A file, in Linux, doesn’t have
    any prescribed structure; it’s just a stream of bytes. It’s up to the client to
    decide what the bytes mean. As shown in [Figure 5-1](#fig-vfs-overview), VFS abstracts
    access to different kinds of filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: Local filesystems, such as `ext3`, XFS, FAT, and NTFS
  prefs: []
  type: TYPE_NORMAL
- en: These filesystems use drivers to access local block devices such as HDDs or
    SSDs.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory filesystems, such as `tmpfs`, that are not backed by long-term storage
    devices but live in main memory (RAM)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover these and the previous category in [“Regular Files”](#regular-files).
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo filesystems like `procfs`, as discussed in [“Pseudo Filesystems”](#pseudo-fs)
  prefs: []
  type: TYPE_NORMAL
- en: These filesystems are also in-memory in nature. They’re used for kernel interfacing
    and device abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Networked filesystems, such as NFS, Samba, Netware (nee Novell), and others
  prefs: []
  type: TYPE_NORMAL
- en: These filesystems also use a driver; however, the storage devices where the
    actual data resides is not locally attached but remote. This means that the driver
    involves network operations. For this reason, we’ll cover them in [Chapter 7](ch07.xhtml#networking).
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0501](Images/lmlx_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Linux VFS overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Describing the makeup of the VFS isn’t easy. There are over 100 syscalls related
    to files; however, in its core, the operations can be grouped into a handful of
    categories, as listed in [Table 5-2](#tab-vfsinterface).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Select syscalls making up the VFS interface
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Example syscalls |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Inodes | `chmod`, `chown`, `stat` |'
  prefs: []
  type: TYPE_TB
- en: '| Files | `open`, `close`, `seek`, `truncate`, `read`, `write` |'
  prefs: []
  type: TYPE_TB
- en: '| Directories | `chdir`, `getcwd`, `link`, `unlink`, `rename`, `symlink` |'
  prefs: []
  type: TYPE_TB
- en: '| Filesystems | `mount`, `flush`, `chroot` |'
  prefs: []
  type: TYPE_TB
- en: '| Others | `mmap`, `poll`, `sync`, `flock` |'
  prefs: []
  type: TYPE_TB
- en: 'Many VFS syscalls dispatch to the filesystem-specific implementation. For other
    syscalls, there are VFS default implementations. Further, the Linux kernel defines
    relevant VFS data structures—see [*include/linux/fs.h*](https://oreil.ly/Fkq8i)—such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inode`'
  prefs: []
  type: TYPE_NORMAL
- en: The core filesystem object, capturing type, ownership, permissions, links, pointers
    to blocks containing the file data, creation and access statistics, and more
  prefs: []
  type: TYPE_NORMAL
- en: '`file`'
  prefs: []
  type: TYPE_NORMAL
- en: Representing an open file (including path, current position, and inode)
  prefs: []
  type: TYPE_NORMAL
- en: '`dentry` (directory entry)'
  prefs: []
  type: TYPE_NORMAL
- en: Stores its parent and children
  prefs: []
  type: TYPE_NORMAL
- en: '`super_block`'
  prefs: []
  type: TYPE_NORMAL
- en: Representing a filesystem including mount information
  prefs: []
  type: TYPE_NORMAL
- en: Others
  prefs: []
  type: TYPE_NORMAL
- en: Including `vfsmount` and `file_system_type`
  prefs: []
  type: TYPE_NORMAL
- en: With the VFS overview done, let’s have a closer look at the details, including
    volume management, filesystem operations, and common file system layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Volume Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously talked about carving up drives using partitions. While doing this
    is possible, partitions are hard to use, especially when resizing (changing the
    amount of storage space) is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Logical volume manager (LVM) uses a layer of indirection between physical entities
    (such as drives or partitions) and the file system. This yields a setup that allows
    for risk-free, zero-downtime expanding and automatic storage extension through
    the pooling of resources. The way LVM works is depicted in [Figure 5-2](#fig-lvm-overview),
    with key concepts explained in the passage that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0502](Images/lmlx_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Linux LVM overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Physical volumes (PV)
  prefs: []
  type: TYPE_NORMAL
- en: Can be a disk partition, an entire disk drive, and other devices.
  prefs: []
  type: TYPE_NORMAL
- en: Logical volumes (LV)
  prefs: []
  type: TYPE_NORMAL
- en: Are block devices created from VGs. These are conceptually comparable to partitions.
    You have to create a filesystem on an LV before you can use it. You can easily
    resize LVs while in use.
  prefs: []
  type: TYPE_NORMAL
- en: Volume groups (VG)
  prefs: []
  type: TYPE_NORMAL
- en: Are a go-between between a set of PVs and LVs. Think of a VG as pools of PVs
    collectively providing resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To [manage volumes with LVM](https://oreil.ly/rYXVI), a number of tools are
    required; however, they are consistently named and relatively easy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: PV management tools
  prefs: []
  type: TYPE_NORMAL
- en: '`lvmdiskscan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pvdisplay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pvcreate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pvscan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VG management tools
  prefs: []
  type: TYPE_NORMAL
- en: '`vgs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vgdisplay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vgcreate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vgextend`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LV management tools
  prefs: []
  type: TYPE_NORMAL
- en: '`lvs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lvscan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lvcreate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some LVM commands in action, using a concrete setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List logical volumes; we have two here (*root* and *swap_1*) using volume group
    *elementary-vg*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Display volume groups; we have one here called *elementary-vg*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_filesystems_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Display physical volumes; we have one here (*/dev/sda2*) that’s assigned to
    the volume group *elementary-vg*.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you use a partition or an LV, two more steps, which we’ll cover next,
    are necessary to use a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following section, we’ll discuss how to create a filesystem, given a
    partition or a logical volume (created using LVM). There are two steps involved:
    creating the filesystem—in other non-Linux operating systems, this step is sometimes
    called *formatting*—and then mounting it, or inserting it into the filesystem
    tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use a filesystem, the first step is to create one. This means that
    you’re setting up the management pieces that make up a filesystem, taking a partition
    or a volume as the input. Consult [Table 5-1](#tab-fsbasics) if you’re unsure
    how to gather the necessary information about the input, and once you have everything
    together, use [`mkfs`](https://oreil.ly/uqI57) to create a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '`mkfs` takes two primary inputs: the type of filesystem you want to create
    (see one of the options we discuss in [“Common Filesystems”](#common-regular-fs))
    and the device you want to create the filesystem on (for example, a logical volume):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a filesystem of type `ext4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the filesystem on the logical volume */dev/some_vg/some_lv*.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the previous command, there’s not much to it to create a
    filesystem, so the main work for you is to figure out what filesystem type to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created the filesystem with `mkfs`, you can then make it available
    in the filesystem tree.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mounting a filesystem means attaching it to the filesystem tree (which starts
    at */*). Use the [`mount` command](https://oreil.ly/c6ryR) to attach a filesystem.
    `mount` takes two main inputs: the device you want to attach and the place in
    the filesystem tree. In addition, you can provide other inputs, including mount
    options (via `-o`) such as read-only, and bind mounts—via [`--bind`](https://oreil.ly/C2QuV)—for
    mounting directories into the filesystem tree. We’ll revisit this latter option
    in the context of containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `mount` on its own as well. Here’s how to list existing mounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List mounts but only show certain filesystem types (`ext4` and `tmpfs` here).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example mount: the LVM VG */dev/mapper/elementary--vg-root* of type `ext4`
    is mounted at the root.'
  prefs: []
  type: TYPE_NORMAL
- en: You must make sure that you mount a filesystem using the type it has been created
    with. For example, if you’re trying to mount an SD card using `mount -t vfat /dev/sdX2
    /media`, you have to know the SD card is formatted using `vfat`. You can let `mount`
    try all filesystems until one works using the `-a` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the mounts are valid only for as long as the system is running, so
    in order to make it permanent, you need to use the [fstab file (*/etc/fstab*)](https://oreil.ly/zoSE1).
    For example, here is mine (output slightly edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to manage partitions, volumes, and filesystems. Next up, we
    review common ways to organize filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Common Filesystem Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have a filesystem in place, an obvious challenge is to come up with
    a way to organize its content. You may want to organize things like where programs
    are stored, configuration data, system data, and user data. We will refer to this
    organization of directories and their content as the *filesystem layout*. Formally,
    the layout is called the [Filesystem Hierarchy Standard (FHS)](https://oreil.ly/q0c4a).
    It defines directories, including their structure and recommended content. The
    Linux Foundation maintains the FHS, and it’s a good starting point for Linux distributions
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind FHS is laudable. However, in practice you will find that the
    filesystem layout very much depends on the Linux distribution you’re using. Thus,
    I strongly recommend you use the `man hier` command to learn about your concrete
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: To provide you with a high-level idea of what you can expect when you see certain
    top-level directories, I compiled a list of common ones in [Table 5-3](#tab-fslayouts).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-3\. Common top-level directories
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory | Semantics |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *bin*, *sbin* | System programs and commands (usually links to */usr/bin*
    and */usr/sbin*) |'
  prefs: []
  type: TYPE_TB
- en: '| *boot* | Kernel images and related components |'
  prefs: []
  type: TYPE_TB
- en: '| *dev* | Devices (terminals, drives, etc.) |'
  prefs: []
  type: TYPE_TB
- en: '| *etc* | System configuration files |'
  prefs: []
  type: TYPE_TB
- en: '| *home* | User home directories |'
  prefs: []
  type: TYPE_TB
- en: '| *lib* | Shared system libraries |'
  prefs: []
  type: TYPE_TB
- en: '| *mnt*, *media* | Mount points for removable media (e.g., USB sticks) |'
  prefs: []
  type: TYPE_TB
- en: '| *opt* | Distro specific; can host package manager files |'
  prefs: []
  type: TYPE_TB
- en: '| *proc*, *sys* | Kernel interfaces; see also [“Pseudo Filesystems”](#pseudo-fs)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *tmp* | For temporary files |'
  prefs: []
  type: TYPE_TB
- en: '| *usr* | User programs (usually read-only) |'
  prefs: []
  type: TYPE_TB
- en: '| *var* | User programs (logs, backups, network caches, etc.) |'
  prefs: []
  type: TYPE_TB
- en: With that, let’s move on to some special kinds of filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filesystems are a great way to structure and access information. By now you
    have likely already internalized the Linux motto that “everything is a file.”
    We looked at how Linux provides a uniform interface via VFS in [“The Virtual File
    System”](#vfs). Now, let’s take a closer look at how an interface is provided
    in cases where the VFS implementor is not a block device (such as an SD card or
    an SSD drive).
  prefs: []
  type: TYPE_NORMAL
- en: 'Meet pseudo filesystems: they only pretend to be filesystems so that we can
    interact with them in the usual manner (`ls`, `cd`, `cat`), but really they are
    wrapping some kernel interface. The interface can be a range of things, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Information about a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interaction with devices such as keyboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities such as special devices you can use as data sources or sinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have a closer look at the three major pseudo filesystems Linux has, starting
    with the oldest.
  prefs: []
  type: TYPE_NORMAL
- en: procfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux inherited the [*/proc*](https://oreil.ly/QEdmm) filesystem (`procfs`)
    from UNIX. The original intention was to publish process-related information from
    the kernel, to make it consumable for system commands such as `ps` or `free`.
    It has very few rules around structure, allows read-write access, and over time
    many things found their way into it. In general, you find two types of information
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: Per-process information in */proc/PID/*. This is process-relevant information
    that the kernel exposes via directories with the PID as the directory name. Details
    concerning the information available there are listed in [Table 5-4](#tab-procfsprocess).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other information such as mounts, networking-related information, TTY drivers,
    memory information, system version, and uptime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can glean per-process information as listed in [Table 5-4](#tab-procfsprocess)
    simply by using commands like `cat`. Note that most are read-only; the write semantics
    depend on the underlying resource.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-4\. Per-process information in procfs (most notable)
  prefs: []
  type: TYPE_NORMAL
- en: '| Entry | Type | Information |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `attr` | Directory | Security attributes |'
  prefs: []
  type: TYPE_TB
- en: '| `cgroup` | File | Control groups |'
  prefs: []
  type: TYPE_TB
- en: '| `cmdline` | File | Command line |'
  prefs: []
  type: TYPE_TB
- en: '| `cwd` | Link | Current working directory |'
  prefs: []
  type: TYPE_TB
- en: '| `environ` | File | Environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| `exe` | Link | Executable of the process |'
  prefs: []
  type: TYPE_TB
- en: '| `fd` | Directory | File descriptors |'
  prefs: []
  type: TYPE_TB
- en: '| `io` | File | Storage I/O (bytes/char read and written) |'
  prefs: []
  type: TYPE_TB
- en: '| `limits` | File | Resource limits |'
  prefs: []
  type: TYPE_TB
- en: '| `mem` | File | Memory used |'
  prefs: []
  type: TYPE_TB
- en: '| `mounts` | File | Mounts used |'
  prefs: []
  type: TYPE_TB
- en: '| `net` | Directory | Network stats |'
  prefs: []
  type: TYPE_TB
- en: '| `stat` | File | Process status |'
  prefs: []
  type: TYPE_TB
- en: '| `syscall` | File | Syscall usage |'
  prefs: []
  type: TYPE_TB
- en: '| `task` | Directory | Per-task (thread) information |'
  prefs: []
  type: TYPE_TB
- en: '| `timers` | File | Timers information |'
  prefs: []
  type: TYPE_TB
- en: 'To see this in action, let’s inspect the process status. We’re using `status`
    here rather than `stat`, which doesn’t come with human-readable labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the process status about the currently running command, showing only the
    first 10 lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The current state (running, on-CPU).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_filesystems_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The PID of the current process.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_filesystems_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The process ID of the parent process of the command; in this case, it’s the
    shell where I ran the `cat` command in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one more example of using `procfs` to glean information, this time
    from the networking space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the previous command, we can glean ARP information about the current
    process from this special */proc/self/net/arp*.
  prefs: []
  type: TYPE_NORMAL
- en: '`procfs` is very useful if you’re [low-level debugging](https://oreil.ly/nJ01w)
    or developing system tooling. It is relatively messy, so you’ll need the kernel
    docs or, even better, the kernel source code at hand to understand what each file
    represents and how to interpret the information in it.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to a more recent, more orderly way the kernel exposes information.
  prefs: []
  type: TYPE_NORMAL
- en: sysfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where `procfs` is pretty Wild West, the [*/sys*](https://oreil.ly/EHJEJ) filesystem
    (`sysfs`) is a Linux-specific, structured way for the kernel to expose select
    information (such as about devices) using a standardized layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the directories in `sysfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*block/*'
  prefs: []
  type: TYPE_NORMAL
- en: This directory symbolic links to discovered block devices.
  prefs: []
  type: TYPE_NORMAL
- en: '*bus/*'
  prefs: []
  type: TYPE_NORMAL
- en: In this directory, you find one subdirectory for each physical bus type supported
    in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '*class/*'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains device classes.
  prefs: []
  type: TYPE_NORMAL
- en: '*dev/*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This directory contains two subdirectories: *block/* for block devices and
    *char/* for character devices on the system, structured with `major-ID:minor-ID`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*devices/*'
  prefs: []
  type: TYPE_NORMAL
- en: In this directory, the kernel provides a representation of the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: '*firmware/*'
  prefs: []
  type: TYPE_NORMAL
- en: Via these directories, you can manage firmware-specific attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '*fs/*'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains subdirectories for some filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '*module/*'
  prefs: []
  type: TYPE_NORMAL
- en: In these directories you find subdirectories for each module loaded in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: There are more subdirectories in `sysfs`, but some are newish and/or would benefit
    from better documentation. You’ll find certain information duplicated in `sysfs`
    that is also available in `procfs`, but other information (such as memory information)
    is only available in `procfs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see `sysfs` in action (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_filesystems_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List information about block device `sda`, showing only the first seven lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_filesystems_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `backing_dev_info` link using `MAJOR:MINOR` format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_filesystems_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Captures device [capabilities](https://oreil.ly/GFUid), such as if it is removable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_filesystems_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the device major and minor number (`8:0`); see also the [block device
    drivers reference](https://oreil.ly/DK9GT) for what the numbers mean.
  prefs: []
  type: TYPE_NORMAL
- en: Next up in our little pseudo filesystem review are devices.
  prefs: []
  type: TYPE_NORMAL
- en: devfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [*/dev*](https://oreil.ly/EkO8V) filesystem (`devfs`) hosts device special
    files, representing devices ranging from physical devices to things like a random
    number generator or a write-only data sink.
  prefs: []
  type: TYPE_NORMAL
- en: 'The devices available and managed via `devfs` are:'
  prefs: []
  type: TYPE_NORMAL
- en: Block devices
  prefs: []
  type: TYPE_NORMAL
- en: Handle data in blocks—for example, storage devices (drives)
  prefs: []
  type: TYPE_NORMAL
- en: Character devices
  prefs: []
  type: TYPE_NORMAL
- en: Handle things character by character, such as a terminal, a keyboard, or a mouse
  prefs: []
  type: TYPE_NORMAL
- en: Special devices
  prefs: []
  type: TYPE_NORMAL
- en: Generate data or allow you to manipulate it, including the famous */dev/null*
    or */dev/random*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see `devfs` in action. For example, assume you want to get a random
    string. You could do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The previous command generates a 42-character random sequence containing uppercase
    and lowercase as well as numerical characters. And while */dev/urandom* looks
    like a file and can be used like one, it indeed is a special file that, using
    a number of sources, generates (more or less) random output.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you think about the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That’s right! The string “something” appeared on your display, and that is by
    design. */dev/tty* stands for the terminal, and with that command we sent something
    (quite literally) to it.
  prefs: []
  type: TYPE_NORMAL
- en: With a good understanding of filesystems and their features, let’s now turn
    our attention to filesystems that you want to use to manage regular files such
    as documents and data files.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we focus on regular files and [filesystems](https://oreil.ly/LOuvP)
    for such file types. Most of the day-to-day files we’re dealing with when working
    fall into this category: office documents, YAML and JSON configuration files,
    images (PNG, JPEG, etc.), source code, plain text files, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux comes with a wealth of options. We’ll focus on local filesystems, both
    those native for Linux as well as those in other operating systems (such as Windows/DOS)
    that Linux allows you to use. First, let’s have a look at some common filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Common Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *common filesystem* doesn’t have a formal definition. It’s simply an
    umbrella term for filesystems that are either the defaults used in Linux distributions
    or widely used in storage devices such as removable devices (USB sticks and SD
    cards) or read-only devices, like CDs and DVDs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 5-5](#tab-fstypesregular) I provide a quick overview and comparison
    of some common filesystems that enjoy in-kernel support. Later in this section,
    we’ll review some popular filesystems in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-5\. Common filesystems for regular files
  prefs: []
  type: TYPE_NORMAL
- en: '| Filesystem | Linux support since | File size | Volume size | Number of files
    | Filename length |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`ext2`](https://oreil.ly/cL9W7) | 1993 | 2 TB | 32 TB | 10^(18) | 255 characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`ext3`](https://oreil.ly/IEnxW) | 2001 | 2 TB | 32 TB | variable | 255 characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`ext4`](https://oreil.ly/482ku) | 2008 | 16 TB | 1 EB | 4 billion | 255
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| [`btrfs`](https://oreil.ly/gJQex) | 2009 | 16 EB | 16 EB | 2^(18) | 255 characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| [XFS](https://oreil.ly/5LHGl) | 2001 | 8 EB | 8 EB | 2^(64) | 255 characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ZFS](https://oreil.ly/HH1Lb) | 2006 | 16 EB | 2^(128) Bytes | 10^(14) files
    per directory | 255 characters |'
  prefs: []
  type: TYPE_TB
- en: '| NTFS | 1997 | 16 TB | 256 TB | 2^(32) | 255 characters |'
  prefs: []
  type: TYPE_TB
- en: '| `vfat` | 1995 | 2 GB | N/A | 2^(16) per directory | 255 characters |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The information provided in [Table 5-5](#tab-fstypesregular) is meant to give
    you a rough idea about the filesystems. Sometimes it’s hard to pinpoint the exact
    time a filesystem would be officially considered part of Linux; sometimes the
    numbers make sense only with the relevant context applied. For example, there
    are differences between theoretical limits and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a closer look at some widely used filesystems for regular files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ext4`](https://oreil.ly/Ot9DI)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A widely used filesystem, used by default in many distributions nowadays. It’s
    a backward-compatible evolution of `ext3`. Like `ext3`, it offers journaling—that
    is, changes are recorded in a log so that in the worst-case scenario (think: power
    outage), the recovery is fast. It’s a great general-purpose choice. See the [`ext4`
    manual](https://oreil.ly/9kSXn) for usage.'
  prefs: []
  type: TYPE_NORMAL
- en: '[XFS](https://oreil.ly/WzHIZ)'
  prefs: []
  type: TYPE_NORMAL
- en: A journaling filesystem that was originally designed by Silicon Graphics (SGI)
    for their workstations in the early 1990s. Offering support for large files and
    high-speed I/O, it’s now used, for example, in the Red Hat distributions family.
  prefs: []
  type: TYPE_NORMAL
- en: '[ZFS](https://oreil.ly/ApA2z)'
  prefs: []
  type: TYPE_NORMAL
- en: Originally developed by Sun Microsystems in 2001, ZFS combines filesystem and
    volume manager functionality. While now there is the [OpenZFS project](https://oreil.ly/7itzs),
    offering a path forward in an open source context, there are some concerns about
    [ZFS’s integration with Linux](https://oreil.ly/mM8du).
  prefs: []
  type: TYPE_NORMAL
- en: '[FAT](https://oreil.ly/sfUa3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is really a family of FAT filesystems for Linux, with `vfat` being used
    most often. The main use case is interoperability with Windows systems, as well
    as removable media that uses FAT. Many of the native considerations around volumes
    do not apply.
  prefs: []
  type: TYPE_NORMAL
- en: Drives are not the only place one can store data, so let’s have a look at in-memory
    options.
  prefs: []
  type: TYPE_NORMAL
- en: In-Memory Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of in-memory filesystems available; some are general purpose
    and others have very specific use cases. In the following, we list some widely
    used in-memory filesystems (in alphabetical order):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`debugfs`](https://oreil.ly/j30dd)'
  prefs: []
  type: TYPE_NORMAL
- en: A special-purpose filesystem used for debugging; usually mounted with `mount
    -t debugfs none /sys/kernel/debug`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`loopfs`](https://oreil.ly/jZi4I)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows mapping a filesystem to blocks rather than devices. See also a [mail
    thread on the background](https://oreil.ly/kMZ7j).
  prefs: []
  type: TYPE_NORMAL
- en: '`pipefs`'
  prefs: []
  type: TYPE_NORMAL
- en: A special (pseudo) filesystem mounted on `pipe:` that enables pipes.
  prefs: []
  type: TYPE_NORMAL
- en: '`sockfs`'
  prefs: []
  type: TYPE_NORMAL
- en: Another special (pseudo) filesystem that makes network sockets look like files,
    sitting between the syscalls and the [sockets](https://oreil.ly/ANDjr).
  prefs: []
  type: TYPE_NORMAL
- en: '[`swapfs`](https://oreil.ly/g1WsU)'
  prefs: []
  type: TYPE_NORMAL
- en: Used to realize swapping (not mountable).
  prefs: []
  type: TYPE_NORMAL
- en: '[`tmpfs`](https://oreil.ly/ICkgj)'
  prefs: []
  type: TYPE_NORMAL
- en: A general-purpose filesystem that keeps file data in kernel caches. It’s fast
    but nonpersistent (power off means data is lost).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to a special category of filesystems, specifically relevant in
    the context of [“Containers”](ch06.xhtml#containers).
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-Write Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy-on-write (CoW) is a nifty concept to increase I/O speed and at the same
    time use less space. The way it works is depicted in [Figure 5-3](#fig-cow-concept),
    with further explanation in the passage that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0503](Images/lmlx_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. The CoW principle in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The original file, File 1, consisting of blocks A, B, and C, is copied to a
    file called File 2\. Rather than copying the actual blocks, only the metadata
    (pointers to the blocks) is copied. This is fast and doesn’t use up much space
    since only metadata is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When File 2 is modified (let’s say something in block C is changed), only then
    is block C copied: a new block called C′ is created, and while File 2 still points
    to (uses) the unmodified blocks A and B, it now uses a new block (C′) to capture
    new data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we get to implementations, we need to understand a second concept relevant
    in this context: [union mounts](https://oreil.ly/dh6vW). This is the idea that
    you can combine (mount) multiple directories into one location so that, to the
    user of the resulting directory, it appears that said directory contains the combined
    content (or: union) of all the participating directories. With union mounts, you
    often come across the terms *upper filesystem* and *lower filesystem*, hinting
    at the layering order of the mounts. You’ll find more details in the article [“Unifying
    Filesystems with Union Mounts”](https://oreil.ly/yqV9H).'
  prefs: []
  type: TYPE_NORMAL
- en: With union mounts, the devil is in the details. You have to come up with rules
    around what happens when a file exists in multiple places or what writing to or
    removing files means.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a quick look at implementations of CoW in the context of Linux filesystems.
    We’ll have a closer look at some of these in the context of [Chapter 6](ch06.xhtml#running-apps),
    when we discuss their use as a building block for container images.
  prefs: []
  type: TYPE_NORMAL
- en: '[Unionfs](https://oreil.ly/rWKZO)'
  prefs: []
  type: TYPE_NORMAL
- en: Originally developed at Stony Brook University, Unionfs implements a union mount
    for CoW filesystems. It allows you to transparently overlay files and directories
    from different filesystems using priorities at mount time. It was widely popular
    and used in the context of CD-ROMs and DVDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[OverlayFS](https://oreil.ly/5HzmC)'
  prefs: []
  type: TYPE_NORMAL
- en: A union mount filesystem implementation for Linux introduced in 2009 and added
    to the kernel in 2014\. With OverlayFS, once a file is opened, all operations
    are directly handled by the underlying (lower or upper) filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '[AUFS](https://oreil.ly/kdjge)'
  prefs: []
  type: TYPE_NORMAL
- en: Another attempt to implement an in-kernel union mount, AUFS (short for advanced
    multilayered unification filesystem; originally AnotherUnionFS) has not been merged
    into the kernel yet. It is used to default in Docker (see [“Docker”](ch06.xhtml#docker);
    nowadays Docker defaults to OverlayFS with storage driver `overlay2`).
  prefs: []
  type: TYPE_NORMAL
- en: '[`btrfs`](https://oreil.ly/z1uxq)'
  prefs: []
  type: TYPE_NORMAL
- en: Short for b-tree filesystem (and pronounced *butterFS* or *betterFS*), `btrfs`
    is a CoW initially designed by Oracle Corporation. Today, a number of companies
    contribute to the `btrfs` development, including Facebook, Intel, SUSE, and Red
    Hat.
  prefs: []
  type: TYPE_NORMAL
- en: It comes with a number of features such as snapshots (for software-based RAID)
    and automatic detection of silent data corruptions. This makes `btrfs` very suitable
    for professional environments—for example, on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed files and filesystems in Linux. Filesystems are
    a great and flexible way to organize access to information in a hierarchical manner.
    Linux has many technologies and projects around filesystems. Some are open source
    based, but there is also a range of commercial offerings.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the basic building blocks, from drives to partitions and volumes.
    Linux realizes the “everything is a file” abstraction using VFS, supporting virtually
    any kind of filesystem, local or remote.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel uses pseudo filesystems such as */proc* and */sys* to expose information
    about processes or devices. You can interact with these (in-memory) filesystems
    that represent kernel APIs just like with filesystems such as `ext4` (that you
    use to store files).
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to regular files and filesystems, where we compared common
    local filesystem options, as well as in-memory and CoW filesystem basics. Linux’s
    filesystem support is comprehensive, allowing you to use (at least read) a range
    of fil⁠e­systems, including those originating from other operating systems such
    as Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can dive deeper into the topics covered in this chapter with the following
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs: []
  type: TYPE_NORMAL
- en: '[“UNIX File Systems: How UNIX Organizes and Accesses Files on Disk”](https://oreil.ly/8a3Zr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“KHB: A Filesystems Reading List”](https://oreil.ly/aFqjg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VFS
  prefs: []
  type: TYPE_NORMAL
- en: '[“Overview of the Linux Virtual File System”](https://oreil.ly/pnvQ4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Introduction to the Linux Virtual Filesystem (VFS)”](https://oreil.ly/sqSHK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“LVM” on ArchWiki](https://oreil.ly/kOfU1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“LVM2 Resource Page”](https://oreil.ly/Ds7me)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Use GUI LVM Tools”](https://oreil.ly/UTFpL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Linux Filesystem Hierarchy”](https://oreil.ly/osXbo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Persistent BPF Objects”](https://oreil.ly/sFdVo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular files
  prefs: []
  type: TYPE_NORMAL
- en: '[“Filesystem Efficiency—Comparison of EXT4, XFS, BTRFS, and ZFS” thread on
    reddit](https://oreil.ly/Y3rAh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Linux Filesystem Performance Tests”](https://oreil.ly/ZrPci)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Comparison of File Systems for an SSD” thread on Linux.org](https://oreil.ly/DBboM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Kernel Korner—Unionfs: Bringing Filesystems Together”](https://oreil.ly/Odkls)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Getting Started with btrfs for Linux”](https://oreil.ly/TLylF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equipped with knowledge around filesystems, we’re now ready to bring things
    together and focus on how to manage and launch applications.
  prefs: []
  type: TYPE_NORMAL
