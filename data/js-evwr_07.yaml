- en: Chapter 6\. CRUD Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time I heard the term “CRUD application,” I wrongfully assumed that
    it referred to an application that did something dirty or tricky. Admittedly,
    “CRUD” sounds as if it refers to something that would be scraped off the bottom
    of a shoe. In fact, the acronym was first popularized in the early 1980s by British
    technology author James Martin in reference to applications that create, read,
    update, and delete data. Though the term has been around for well over a quarter
    of a century, it still applies to many applications developed today. Consider
    the applications that you interact with daily—to-do lists, spreadsheets, content
    management systems, text editors, social media websites, and several others—and
    chances are that many of them fall into the CRUD application format. A user creates
    some data, accesses or reads data, and may update or delete that data.
  prefs: []
  type: TYPE_NORMAL
- en: Our Notedly application will follow the CRUD pattern. Users will be able to
    create, read, update, and delete their own notes. In this chapter, we’ll implement
    the essential CRUD functionality of our API by connecting our resolvers and database.
  prefs: []
  type: TYPE_NORMAL
- en: Separating Our GraphQL Schema and Resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently our *src/index.js* file is home to our Express/Apollo server code
    as well as our API’s schema and resolvers. As you can imagine, this could get
    a bit unwieldy as our codebase grows. Before this happens, let’s take some time
    to do a minor refactor that separates our schema, resolvers, and server code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let’s move our GraphQL schema to its own file. First, we’ll make
    a new file called *src/schema.js* in the *src* folder and then move our schema
    content, found in our `typeDefs` variable, to that file. To do so, we’ll also
    need to import the `gql` schema language that comes with the `apollo-server-express`
    package and export our schema as a module, using Node’s `module.exports` method.
    While we’re at it, we can also remove the `hello` query, which we won’t need in
    our final application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update our *src/index.js* file to use this external schema file
    by importing it and removing the `gql` import from `apollo-server-express` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have isolated our GraphQL schema to its own file, let’s do something
    similar for our GraphQL resolver code. Our resolver code will encompass the vast
    majority of our API’s logic, so first we’ll create a folder to house this code,
    called *resolvers*. Within the *src/resolvers* directory we’ll begin with three
    files: *src/resolvers/index.js*, *src/resolvers/query.js*, and *src/resolvers/mutation.js*.
    Similar to the pattern we followed in our database models, the *src/resolvers/index.js*
    file will be used to import our resolver code into a single exported module. Go
    ahead and set up this file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can set up the *src/resolvers/query.js* for the API query code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then move the mutation code to the *src/resolvers/mutation.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the server to import the resolver code by adding the following line to
    the *src/index.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step in refactoring our resolvers is to connect them to our database
    models. As you may have noticed, our resolver modules reference these models,
    but have no way of accessing them. To fix this problem, we’ll use a concept that
    Apollo Server calls *context*, which allows us to pass specific information along
    from our server code to an individual resolver with each request. For now, this
    may feel excessive, but it will be useful for incorporating user authentication
    into our application. To do this, we’ll update our Apollo Server setup code in
    *src/index.js* with a `context` function that will return our database models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll update each of our resolvers to make use of this context by adding
    `{` `models` `}` as the third parameter in each function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following in *src/resolvers/query.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the mutation code to the *src/resolvers/mutation.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our *src/index.js* file will now be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Writing Our GraphQL CRUD Schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve refactored our code for flexibility, let’s begin implementing
    our CRUD operations. We are already able to Create and Read notes, which leaves
    us with implementing our Update and Delete functionality. First, we’ll want to
    update our schema.
  prefs: []
  type: TYPE_NORMAL
- en: Since update and delete operations will make changes to our data, they will
    be mutations. Our update note will require an ID argument to locate the note as
    well as the new note content. The update query will then return the newly updated
    note. For our delete operation, our API will return a Boolean value of `true`
    to inform us that the note deletion was successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Mutation` schema in *src/schema.js* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With these additions, our schema is now ready to perform CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD Resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our schema in place, we can now update our resolvers to either remove or
    update a note. Let’s begin with our `deleteNote` mutation. To delete a note, we
    will use Mongoose’s `findOneAndRemove` method and pass it the `id` of the item
    that we want to delete. If our item is found and deleted, we’ll return `true`
    to the client, but if our item fails to delete, we’ll return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *src/resolvers/mutation.js*, add the following, within the `module.exports`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run our mutation in the GraphQL Playground. In a new tab in the
    Playground, write the following mutation, being sure to use an ID from one of
    the notes in your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the note was successfully deleted, you should receive a response of `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a nonexistent ID, you’ll receive a response of `"deleteNote": false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our delete functionality in place, let’s write our `updateNote` mutation.
    To do this, we will use Mongoose’s `findOneAndUpdate` method. This method will
    take an initial parameter of a query to find the correct note in the database,
    followed by a second parameter where we’ll `$set` new note content. Lastly, we’ll
    pass a third parameter of `new: true`, which instructs the database to return
    the updated note content to us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *src/resolvers/mutation.js*, add the following within the `module.exports`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now visit the GraphQL Playground in our browser to try out our `updateNote`
    mutation. In a new tab in the playground, write a mutation with the parameters
    of an `id` and `content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If our mutation worked as intended, the GraphQL response should read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we pass an incorrect ID, the response fails and we will receive an internal
    server error with an `Error updating note` message.
  prefs: []
  type: TYPE_NORMAL
- en: We are now able to create, read, update, and delete notes. With this we have
    full CRUD functionality in our API.
  prefs: []
  type: TYPE_NORMAL
- en: Date and Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created our database schema, we requested that Mongoose automatically
    store timestamps to record when entries are created and updated in the database.
    This information will be useful in our application, as it will allow us to show
    the user when a note was created or last edited within our user interface. Let’s
    add `createdAt` and `updatedAt` fields to our schema so we can return these values.
  prefs: []
  type: TYPE_NORMAL
- en: You may recall that GraphQL allows for the default types of `String`, `Boolean`,
    `Int`, `Float`, and `ID`. Unfortunately GraphQL does not come with a built-in
    date scalar type. We *could* use the `String` type, but this would mean that we
    wouldn’t be taking advantage of the type validation that GraphQL offers, ensuring
    that our dates and times are actually dates and times. Instead, we’ll create a
    custom scalar type. A custom type allows us to define a new type and validate
    it against every query and mutation that requests data of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update our GraphQL schema in *src/schema.js* by adding a custom scalar
    at the top of our `GQL` string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within the `Note` type, add the `createdAt` and `updatedAt` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The last step is to validate this new type. While we can write our own validation,
    for our use case we’ll use the [`graphql-iso-date` package](https://oreil.ly/CtmP6).
    To do so we’ll add validation to any resolver function that requests a value with
    a type of `DateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *src/resolvers/index.js* file, import the package and add a `DateTime`
    value to the exported resolvers like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now if we visit the GraphQL Playground in our browser and refresh the page,
    we can validate that our custom types work as intended. If we consult our schema,
    we can see that the `createdAt` and `updatedAt` fields have a type of `DateTime`.
    As [Figure 6-1](#crud_datetime) shows, the documentation of this type states that
    it is a “date-time string at UTC.”
  prefs: []
  type: TYPE_NORMAL
- en: '![The DateTime type as shown in GraphQL Playground](assets/jsev_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Our schema now features DateTime types
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To test this, let’s write a `newNote` mutation in the GraphQL Playground that
    includes our date fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will return `createdAt` and `updatedAt` values as an ISO-formatted date.
    If we then run an `updateNote` mutation against the same note, we’ll see an `updatedAt`
    value that differs from the `createdAt` date.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on defining and validating custom scalar types, I recommend
    Apollo Server’s [“Custom scalars and enums” documentation](https://oreil.ly/0rWAC).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we added create, read, update, and delete (CRUD) functionality
    to our API. CRUD applications are an incredibly common pattern used by many applications.
    I encourage you to look at the applications that you interact with daily and think
    about how their data may fit into this pattern. In the next chapter, we will add
    functionality to our API to create and authenticate user accounts.
  prefs: []
  type: TYPE_NORMAL
