- en: Chapter 3\. Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章 容器
- en: Containers are a popular and standard format for packaging applications. The
    format is an open standard promoted by the [Open Container Initiative (OCI)](https://opencontainers.org),
    an open governance structure for the express purpose of creating open industry
    standards around container formats and runtimes. The openness of this format ensures
    portability and interoperability across different operating systems, vendors,
    platforms, or clouds. Kubernetes runs containerized apps, so before going into
    the GitOps approach to managing apps on Kubernetes, we provide a list of recipes
    useful for understanding how to package your application as a container image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是打包应用程序的流行和标准格式。这种格式是由[开放容器倡议（OCI）](https://opencontainers.org)推广的一种开放标准，是为了在容器格式和运行时周围创建开放行业标准的开放治理结构。这种格式的开放性确保了在不同操作系统、供应商、平台或云上的可移植性和互操作性。Kubernetes
    运行容器化应用程序，因此在进入 GitOps 方法管理 Kubernetes 上的应用程序之前，我们提供了一些有用的配方，帮助您了解如何将应用程序打包为容器镜像。
- en: The first step for creating images is to use a container engine for packaging
    your application by building a layered structure containing a base OS and additional
    layers on top such as runtimes, libraries, and applications. Docker is a widespread
    open source implementation of a container engine and runtime, and it can generate
    a container image by specifying a manifest called a Dockerfile (see [Recipe 3.1](#recipe_3_1)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建镜像的第一步是使用容器引擎打包应用程序，构建包含基础操作系统和额外层（如运行时、库和应用程序）的分层结构。Docker 是广泛使用的开源容器引擎和运行时实现，可以通过指定一个称为
    Dockerfile 的清单生成容器镜像（见[配方 3.1](#recipe_3_1)）。
- en: Since the format is open, it’s possible to create container images with other
    tools. [Docker](https://www.docker.com), a popular container engine, requires
    the installation and the execution of a *daemon* that can handle all the operations
    with the container engine. Developers can use a software development kit (SDK)
    to interact with the Docker daemon or use *dockerless* solutions such as JiB to
    create container images (see [Recipe 3.2](#recipe_3_2)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于格式开放，可以使用其他工具创建容器镜像。[Docker](https://www.docker.com)，一个流行的容器引擎，需要安装并执行一个*守护程序*来处理容器引擎的所有操作。开发者可以使用软件开发工具包（SDK）与
    Docker 守护程序进行交互，或者使用像 JiB 这样的*无 Docker*解决方案来创建容器镜像（见[配方 3.2](#recipe_3_2)）。
- en: If you don’t want to rely on a specific programming language or SDK to build
    container images, you can use another *daemonless* solution like Buildah (see
    [Recipe 3.3](#recipe_3_3)) or Buildpacks (see [Recipe 3.4](#recipe_3_4)). Those
    are other popular open source tools for building OCI container images. By avoiding
    dependencies from the OS, such tools make automation more manageable and portable
    (see [Chapter 6](ch06.xhtml#ch_Cloud_Native_CICD)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不想依赖特定的编程语言或 SDK 来构建容器镜像，可以使用另一个*无守护程序*解决方案，如 Buildah（见[配方 3.3](#recipe_3_3)）或
    Buildpacks（见[配方 3.4](#recipe_3_4)）。这些是构建 OCI 容器镜像的其他流行开源工具。通过避免依赖操作系统，这些工具使得自动化更易管理和可移植（见[第
    6 章](ch06.xhtml#ch_Cloud_Native_CICD)）。
- en: Kubernetes doesn’t provide a native mechanism for building container images.
    However, its highly extensible architecture allows interoperability with external
    tools and the platform’s extensibility to create container images. Shipwright
    is an open source framework for building container images on Kubernetes, providing
    an abstraction that can use tools such as kaniko, Buildpacks, or Buildah (see
    [Recipe 3.5](#recipe_3_5)) to create container images.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 没有提供用于构建容器镜像的原生机制。但其高度可扩展的架构允许与外部工具进行互操作，并通过平台的可扩展性创建容器镜像。Shipwright
    是一个在 Kubernetes 上构建容器镜像的开源框架，提供一个抽象层，可以使用诸如 kaniko、Buildpacks 或 Buildah 等工具来创建容器镜像（见[配方
    3.5](#recipe_3_5)）。
- en: At the end of this chapter, you’ll learn how to create OCI-compliant container
    images from a Dockerfile, either from a host with Docker installed, or using tools
    such as Buildah and Buildpacks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，您将学习如何使用 Dockerfile 从主机上安装了 Docker 或使用 Buildah 和 Buildpacks 等工具创建符合 OCI
    标准的容器镜像。
- en: 3.1 Building a Container Using Docker
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 使用 Docker 构建容器
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a container image for your application with Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Docker 为您的应用创建一个容器镜像。
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The first thing you need to do is install [Docker](https://oreil.ly/jd0kH).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要安装[Docker](https://oreil.ly/jd0kH)。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Docker is available for Mac, Windows, and Linux. Download the installer for
    your operating system and refer to the [documentation](https://oreil.ly/7vGmZ)
    to start the Docker service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 可用于 Mac、Windows 和 Linux。下载适合您操作系统的安装程序，并参考[文档](https://oreil.ly/7vGmZ)启动
    Docker 服务。
- en: 'Developers can create a container image by defining a *Dockerfile*. The best
    definition for a Dockerfile comes from the [Docker documentation](https://oreil.ly/RMm2y)
    itself: “A Dockerfile is a text document that contains all the commands a user
    could call on the command line to assemble an image.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以通过定义 *Dockerfile* 来创建容器镜像。关于 Dockerfile 的最佳定义来自于[Docker 文档](https://oreil.ly/RMm2y)本身：“Dockerfile
    是一个文本文档，其中包含用户可以在命令行上调用的所有命令，用于组装镜像。”
- en: Container images present a layered structure, as you can see in [Figure 3-1](#fig3-1).
    Each container image provides the foundation layer for a container, and any update
    is just an additional layer that can be committed on the foundation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像呈现层次结构，如您在[图 3-1](#fig3-1)中所见。每个容器镜像都为容器提供基础层，任何更新只是额外的可以在基础上提交的层。
- en: '![Container image layers](assets/gocb_0301.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![容器镜像层](assets/gocb_0301.png)'
- en: Figure 3-1\. Container image layers
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 容器镜像层
- en: You can create a Dockerfile like the one shown here, which will generate a container
    image for Python apps. You can also find this example in [this book’s repository](https://oreil.ly/J7cXP).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建像这里显示的 Dockerfile，它将为 Python 应用程序生成一个容器镜像。您也可以在[本书的代码库](https://oreil.ly/J7cXP)中找到此示例。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_containers_CO1-1)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_containers_CO1-1)'
- en: '`FROM`: always start from a base image as a foundational layer. In this case
    we start from a Universal Base Image (UBI), publicly available based on RHEL 8
    with Python 3.9 runtime.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`: 始终从一个基础镜像作为基础层开始。在本例中，我们从一个基于 RHEL 8 的 Universal Base Image (UBI) 公开可用的
    Python 3.9 运行时开始。'
- en: '[![2](assets/2.png)](#co_containers_CO1-2)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_containers_CO1-2)'
- en: '`ENV`: set an environment variable for the app.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`: 为应用设置一个环境变量。'
- en: '[![3](assets/3.png)](#co_containers_CO1-3)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_containers_CO1-3)'
- en: '`EXPOSE`: expose a port to the container network, in this case port TCP 8080.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`: 将端口暴露到容器网络中，在本例中是 TCP 8080 端口。'
- en: '[![4](assets/4.png)](#co_containers_CO1-4)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_containers_CO1-4)'
- en: '`WORKDIR`: set a directory inside the container to work with.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`: 在容器内设置工作目录。'
- en: '[![5](assets/5.png)](#co_containers_CO1-5)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_containers_CO1-5)'
- en: '`COPY`: copy the assets from the source code files on your workstation to the
    container image layer, in this case, to the `WORKDIR`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`: 将工作站上源代码文件中的资产复制到容器镜像层，本例中复制到 `WORKDIR`。'
- en: '[![6](assets/6.png)](#co_containers_CO1-6)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_containers_CO1-6)'
- en: '`RUN`: run a command inside the container, using the tools already available
    within the base image. In this case, it runs the `pip` tool to install dependencies.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`: 在容器内运行命令，使用基础镜像中已有的工具。在本例中，运行 `pip` 工具来安装依赖项。'
- en: '[![7](assets/7.png)](#co_containers_CO1-7)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_containers_CO1-7)'
- en: '`ENTRYPOINT`: define the entry point for your app inside the container. It
    can be a binary or a script. In this case, it runs the Python interpreter.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`: 定义容器内应用的入口点。可以是二进制文件或脚本。在本例中，运行 Python 解释器。'
- en: '[![8](assets/8.png)](#co_containers_CO1-8)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_containers_CO1-8)'
- en: '`CMD`: the command that is used when starting a container. In this case it
    uses the name of the Python app `app.py`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`: 启动容器时使用的命令。在本例中使用 Python 应用程序 `app.py` 的名称。'
- en: 'You can now create your container image with the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用以下命令创建您的容器镜像：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Change the container image name with the your registry, user, and repo. Example:
    `quay.io/youruser/yourrepo:latest`. See [Chapter 2](ch02.xhtml#ch_Requirements)
    for how to create a new account on registries such as Quay.io.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的注册表、用户和存储库更改容器镜像名称。例如：`quay.io/youruser/yourrepo:latest`。请参阅[第 2 章](ch02.xhtml#ch_Requirements)了解如何在
    Quay.io 等注册表上创建新帐户。
- en: Your container image is building now. Docker will fetch existing layers from
    a public container registry (DockerHub, Quay, Red Hat Registry, etc.) and add
    a new layer with the content specified in the Dockerfile. Such layers could also
    be available locally, if already downloaded, in special storage called a *container
    cache* or *Docker cache*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您的容器镜像正在构建中。Docker 将从公共容器注册表（如 DockerHub、Quay、Red Hat Registry 等）获取现有的层，并根据
    Dockerfile 中指定的内容添加新的层。如果已经下载，这些层也可以在特殊存储（称为*容器缓存*或*Docker 缓存*）中本地可用。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your container image is now available in your Docker cache and ready to be
    used. You can verify its presence with this command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你的容器镜像现在已经在你的 Docker 缓存中可用，并且可以使用以下命令验证其存在：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the list of available container images from the cache in output.
    Those could be images you have built or downloaded with the `docker pull` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中获取缓存中可用的容器镜像列表。这些可能是你构建或使用 `docker pull` 命令下载的镜像：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once your image is created, you can consume it locally or push it to a public
    container registry to be consumed elsewhere, like from a CI/CD pipeline.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了你的镜像，你可以在本地使用它，或将其推送到公共容器注册表中，以便从 CI/CD 流水线等其他地方使用。
- en: 'You need to first log in to your public registry. In this example, we are using
    Quay:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要登录你的公共注册表。在这个示例中，我们使用 Quay：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get output similar to this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似这样的输出：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then you can push your container image to the registry:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将你的容器镜像推送到注册表中：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As confirmed, you should get output similar to this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如确认的，你应该得到类似这样的输出：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You can create container images in this way with Docker from your workstation
    or any host where the Docker service/daemon is running.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从工作站或任何运行 Docker 服务/守护程序的主机上使用 Docker 这种方式创建容器镜像。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Additionally, you can use functionalities offered by a public registry such
    as [Quay.io](https://quay.io) that can directly create the container image from
    a Dockerfile and store it to the registry.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用公共注册表（如 [Quay.io](https://quay.io)）提供的功能，直接从 Dockerfile 创建容器镜像并将其存储到注册表中。
- en: The build requires access to all layers, thus an internet connection to the
    registries storing base layers is needed, or at least having them in the container
    cache. Docker has a layered structure where any change to your app is committed
    on top of the existing layers, so there’s no need to download all the layers each
    time since it will add only deltas for each new change.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建需要访问所有层，因此需要与存储基础层的注册表连接的互联网连接，或者至少在容器缓存中有这些层。Docker 具有分层结构，你的应用程序的任何更改都将提交到现有层的顶部，因此每次只需要添加新变更的增量，无需每次下载所有层。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Container images typically start from a base OS layer such as Fedora, CentOS,
    Ubuntu, Alpine, etc. However, they can also start from `scratch`, an empty layer
    for super-minimal images containing only the app’s binary. See the [`scratch`
    documentation](https://oreil.ly/vj0gs) for more info.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像通常从基础操作系统层开始，如 Fedora、CentOS、Ubuntu、Alpine 等。但是，它们也可以从 `scratch` 开始，这是一个空白层，用于包含仅包含应用程序二进制的超小型镜像。有关更多信息，请参阅
    [`scratch` 文档](https://oreil.ly/vj0gs)。
- en: 'If you want to run your previously created container image, you can do so with
    this command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行之前创建的容器镜像，可以使用以下命令：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`docker run` has many options to start your container. The most common are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 有很多选项可以启动你的容器。最常见的是：'
- en: '`-p`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`'
- en: Binds the port of the container with the port of the host running such container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器的端口绑定到运行该容器的主机的端口。
- en: '`-t`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`'
- en: Attaches a TTY to the container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 TTY 附加到容器。
- en: '`-i`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`'
- en: Goes into an interactive mode.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 进入交互模式。
- en: '`-d`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`'
- en: Goes in the background, printing a hash that you can use to interact asynchronously
    with the running container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 进入后台，打印一个哈希值，你可以用它与正在运行的容器异步交互。
- en: 'The preceding command will start your app in the Docker network and bind it
    to port 8080 of your workstation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在 Docker 网络中启动你的应用程序，并将其绑定到工作站的端口 8080：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From a new terminal, try accessing your running container:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个新的终端尝试访问你正在运行的容器：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should get output like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似这样的输出：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See Also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Best practices for writing Dockerfiles](https://oreil.ly/2hMQD)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写 Dockerfile 的最佳实践](https://oreil.ly/2hMQD)'
- en: '[Manage Docker images](https://oreil.ly/hUByf)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[管理 Docker 镜像](https://oreil.ly/hUByf)'
- en: 3.2 Building a Container Using Dockerless Jib
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 使用 Dockerless Jib 构建容器
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are a software developer, and you want to create a container image without
    installing Docker or any additional software on your workstation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一名软件开发人员，想要在工作站上创建一个容器镜像，而无需安装 Docker 或任何其他额外的软件。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: As discussed in [Recipe 3.1](#recipe_3_1), you need to install the Docker engine
    to create container images. Docker requires permissions to install a service running
    as a daemon, thus a privileged process in your operating system. Today, *dockerless*
    solutions are also available for developers; a popular one is Jib.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [Recipe 3.1](#recipe_3_1) 中讨论的，你需要安装 Docker 引擎来创建容器镜像。Docker 需要权限安装一个作为守护程序运行的服务，因此是操作系统中的一个特权进程。今天，对于开发者来说也有
    *dockerless* 解决方案可用，其中一个流行的是 Jib。
- en: '[Jib](https://oreil.ly/NYCtv) is an open source framework for Java made by
    Google to build OCI-compliant container images, without the need for Docker or
    any container runtime. Jib comes as a library that Java developers can import
    in their Maven or Gradle projects. This means you can create a container image
    for your app without writing or maintaining any Dockerfiles, delegating this complexity
    to Jib.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jib](https://oreil.ly/NYCtv) 是 Google 开发的一个开源框架，用于构建符合 OCI 标准的 Java 容器镜像，无需
    Docker 或任何容器运行时。Jib 作为一个库，Java 开发者可以将其导入到他们的 Maven 或 Gradle 项目中。这意味着您可以为您的应用程序创建一个容器镜像，而无需编写或维护任何
    Dockerfile，将这个复杂性交给 Jib 处理。'
- en: We see the benefits from this approach as the following:^([1](ch03.xhtml#idm45120847711664))
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下方法中看到其优势：^([1](ch03.xhtml#idm45120847711664))
- en: Pure Java
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 Java
- en: No Docker or Dockerfile knowledge is required. Simply add Jib as a plug-in,
    and it will generate the container image for you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 无需 Docker 或 Dockerfile 知识。只需将 Jib 添加为插件，它将为您生成容器镜像。
- en: Speed
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 速度
- en: The application is divided into multiple layers, splitting dependencies from
    classes. There’s no need to rebuild the container image like for Dockerfiles;
    Jib takes care of modifying the layers that changed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序分为多个层，将依赖项与类分开。与 Dockerfile 不同，无需重新构建容器镜像；Jib 负责修改发生变化的层。
- en: Reproducibility
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可复现性
- en: Unnecessary updates are not triggered because the same contents generate the
    same image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不会触发不必要的更新，因为相同的内容生成相同的镜像。
- en: 'The easiest way to kickstart a container image build with Jib on existing Maven
    is by adding the plug-in via the command line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的 Maven 项目中通过命令行添加插件是启动使用 Jib 构建容器镜像的最简单方法：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can do so by adding Jib as a plug-in into your *pom.xml*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过在 *pom.xml* 中添加 Jib 作为插件来实现：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this way, you can also manage other settings such as authentication or parameters
    for the build.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您还可以管理其他设置，例如构建的认证或参数。
- en: Let’s now add Jib to an existing Java application, a Hello World application
    in Spring Boot that you can find in the [book’s repository](https://oreil.ly/dn1LF).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 Jib 添加到现有的 Java 应用程序中，这是一个在 Spring Boot 中的 Hello World 应用程序，您可以在[书籍的存储库](https://oreil.ly/dn1LF)中找到。
- en: 'Run the following command to create a container image without using Docker,
    and push it directly to a container registry. In this example, we use Quay.io,
    and we will store the container image at *quay.io/gitops-cookbook/jib-example:latest*,
    so you will need to provide your credentials for the registry:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来创建一个容器镜像，而不使用 Docker，并直接将其推送到容器注册表。在本例中，我们使用 Quay.io，并将容器镜像存储在 *quay.io/gitops-cookbook/jib-example:latest*，因此您需要提供注册表的凭据：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The authentication here is handled with command-line options, but Jib can manage
    existing authentication with Docker CLI or read credentials from your *settings.xml*
    file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的认证是通过命令行选项处理的，但 Jib 可以通过 Docker CLI 管理现有的认证，或者从您的 *settings.xml* 文件中读取凭据。
- en: 'The build takes a few moments, and the result is a Java-specific container
    image, based on the *adoptOpenJDK* base image, built locally and pushed directly
    to a registry. In this case, to Quay.io:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建需要一些时间，结果是一个特定于 Java 的容器镜像，基于 *adoptOpenJDK* 基础镜像，在本地构建并直接推送到注册表。在这种情况下，到
    Quay.io：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you have Docker and run the command `docker images`, you won’t see this image
    in your local cache!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了 Docker 并运行 `docker images` 命令，您在本地缓存中看不到这个镜像！
- en: Discussion
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Your container image is not present in your local cache, as you don’t need any
    container runtime to build images with Jib. You won’t see it with the `docker
    images` command, but you can pull it from the public container registry afterward,
    and it will store it in your cache.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不需要任何容器运行时来使用 Jib 构建镜像，因此您的容器镜像不会出现在本地缓存中。您无法通过 `docker images` 命令看到它，但稍后可以从公共容器注册表拉取它，并将其存储在您的缓存中。
- en: This approach is suitable for development velocity and automation, where the
    CI system doesn’t need to have Docker installed on the nodes where it runs. Jib
    can create the container image without any Dockerfiles. Additionally, it can push
    the image to a container registry.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常适合开发速度和自动化，CI 系统不需要在运行它的节点上安装 Docker。Jib 可以创建容器镜像而无需任何 Dockerfile。此外，它可以将镜像推送到容器注册表。
- en: If you also want to store it locally from the beginning, Jib can connect to
    Docker hosts and do it for you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也想从一开始将其存储在本地，Jib 可以连接到 Docker 主机并为您执行此操作。
- en: 'You can pull your container image from the registry to try it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从注册表中拉取您的容器镜像来尝试它：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Get the `hello` endpoint:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 `hello` 终端：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See Also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Using Jib with Quarkus projects](https://oreil.ly/sTcpJ)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在Quarkus项目中使用Jib](https://oreil.ly/sTcpJ)'
- en: 3.3 Building a Container Using Buildah
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 使用Buildah构建容器
- en: Problem
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Sometimes installing or managing Docker is not possible. Dockerless solutions
    for creating container images are useful in use cases such as local development
    or CI/CD systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时安装或管理Docker是不可能的。对于创建容器镜像的无Docker解决方案在本地开发或CI/CD系统等使用案例中非常有用。
- en: Solution
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The OCI specification is an open standard, and this favors multiple open source
    implementations for the container engine and the container image building mechanism.
    Two growing popular examples today are [Podman](https://podman.io) and [Buildah](https://buildah.io).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: OCI规范是一个开放标准，这有利于容器引擎和容器镜像构建机制的多个开源实现。今天两个日益流行的例子是[Podman](https://podman.io)和[Buildah](https://buildah.io)。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While Docker uses a single monolithic application for creating, running, and
    shipping container images, the codebase for container management functionalities
    here has been split between different projects like Podman, Buildah, and Skopeo.
    Podman support is already available on Mac and Windows, however Buildah is currently
    only available on Linux or Linux subsystems such as WSL2 for Windows. See the
    [documentation](https://oreil.ly/W9l1a) to install it on your workstation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker使用单一的分散应用程序来创建、运行和发货容器镜像，但是这里容器管理功能的代码库已经在不同的项目（如Podman、Buildah和Skopeo）之间拆分。Podman支持已经在Mac和Windows上可用，然而Buildah目前只在Linux或Linux子系统（如WSL2用于Windows）上可用。请查看[文档](https://oreil.ly/W9l1a)在您的工作站上安装它。
- en: Those are two complementary open source projects and command-line tools that
    work on OCI containers and images; however, they differ in their specialization.
    While Podman specializes in commands and functions that help you to maintain and
    modify container images, such as pulling, tagging, and pushing, Buildah specializes
    in building container images. Decoupling functions in different processes is done
    by design, as the authors wanted to move from the single privileged process Docker
    model to a lightweight, rootless, daemonless, and decoupled set of tools to improve
    agility and security.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是两个互补的开源项目和命令行工具，它们在OCI容器和镜像上工作；然而，它们在专业化上有所不同。Podman专注于帮助您维护和修改容器镜像的命令和功能，如拉取、标记和推送，而Buildah专注于构建容器镜像。通过设计将不同功能解耦在不同的进程中进行，因为作者希望从单一特权进程的Docker模型转向轻量级、无根、无守护进程和解耦的工具集，以提高敏捷性和安全性。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Following the same approach, you find [Skopeo](https://oreil.ly/oJnAK), a tool
    used to move container images; and [CRI-O](https://cri-o.io), a container engine
    complaint with the Kubernetes container runtime interface for running applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的方法，您会发现[Skopeo](https://oreil.ly/oJnAK)，这是一个用于移动容器镜像的工具；以及[CRI-O](https://cri-o.io)，这是一个符合Kubernetes容器运行时接口的容器引擎，用于运行应用程序。
- en: Buildah supports the Dockerfile format, but its goal is to provide a lower-level
    interface to build container images without requiring a Dockerfile. Buildah is
    a daemonless solution that can create images inside a container without mounting
    the Docker socket. This functionality improves security and portability since
    it’s easy to add Buildah builds on the fly to a CI/CD pipeline where the Linux
    or Kubernetes nodes do not require a Docker installation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah支持Dockerfile格式，但其目标是提供一个更低级别的接口来构建容器镜像，而无需Dockerfile。Buildah是一个无守护进程的解决方案，可以在容器内部创建镜像而无需挂载Docker套接字。这种功能提升了安全性和可移植性，因为可以轻松地将Buildah构建添加到CI/CD管道中，而Linux或Kubernetes节点不需要安装Docker。
- en: As we discussed, you can create a container image with or without a Dockerfile.
    Let’s now create a simple HTTPD container image without a Dockerfile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，您可以使用或不使用Dockerfile创建容器镜像。现在让我们创建一个简单的HTTPD容器镜像，而无需Dockerfile。
- en: 'You can start from any base image such as CentOS:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从任何基础镜像开始，比如CentOS：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get output similar to this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于这样的输出：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Similarly to Docker and `docker images`, you can run the command `buildah containers`
    to get the list of available images from the container cache. If you also have
    installed Podman, this is similar to `podman images`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker和`docker images`类似，您可以运行命令`buildah containers`来获取来自容器缓存的可用镜像列表。如果您还安装了Podman，这与`podman
    images`类似。
- en: In this case, the container image ID is `centos-working-container`, and you
    can refer to it for creating the other layers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，容器镜像ID是`centos-working-container`，您可以参考它来创建其他层。
- en: 'Now let’s install the `httpd` package inside a new layer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在一个新层内安装`httpd`包：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should get output similar to this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似于这样的输出：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let’s copy a welcome HTML page inside the container running HTTPD. You
    can find the source code in [this book’s repo](https://oreil.ly/azx91):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在运行 HTTPD 的容器内复制一个欢迎 HTML 页面。你可以在 [本书的存储库](https://oreil.ly/azx91) 中找到源代码。
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For each new layer added, you should get output with the new container image
    hash, similar to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每添加一个新层，你应该得到类似于以下内容的带有新容器镜像哈希的输出：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get output similar to this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似于这样的输出：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Your container image is now in the container cache, ready to run or push to
    another registry.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的容器镜像现在位于容器缓存中，准备运行或推送到另一个注册表。
- en: 'As mentioned before, Buildah can also create container images from a Dockerfile.
    Let’s make the same container image from the Dockerfile listed here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Buildah 也可以根据 Dockerfile 创建容器镜像。让我们从这里列出的 Dockerfile 中创建相同的容器镜像：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you have also installed Podman, you can run it this way:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你也安装了 Podman，你可以这样运行它：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then you can test it by opening the browser on [*http://localhost:8080*](http://localhost:8080).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以通过在 [*http://localhost:8080*](http://localhost:8080) 上打开浏览器来测试它。
- en: Discussion
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'With Buildah, you have the opportunity to create container images from scratch
    or starting from a Dockerfile. You don’t need to install Docker, and everything
    is designed around security: rootless mechanism, daemonless utilities, and more
    refined control of creating image layers.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Buildah，你有机会从头开始或从 Dockerfile 开始创建容器镜像。你不需要安装 Docker，一切都围绕安全性设计：非特权机制、无守护程序的实用程序和更精细的控制创建镜像层。
- en: Buildah can also build images from scratch, thus it creates an empty layer similar
    to the `FROM scratch` Dockerfile statement. This aspect is useful for creating
    very lightweight images containing only the packages needed to run your application,
    as you can see in [Figure 3-2](#fig3-2).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah 还可以从零开始构建镜像，因此它创建一个类似于 `FROM scratch` Dockerfile 语句的空层。这个方面对于创建只包含运行应用程序所需包的超轻量级镜像非常有用，正如你可以在
    [图 3-2](#fig3-2) 中看到的。
- en: '![Buildah image shrink](assets/gocb_0302.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Buildah image shrink](assets/gocb_0302.png)'
- en: Figure 3-2\. Buildah image shrink
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. Buildah 图像缩小
- en: A good example use case for a scratch build is considering the development images
    versus staging or production images. During development, container images may
    require a compiler and other tools. However, in production, you may only need
    the runtime or your packages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的示例用例是考虑开发镜像与分阶段或生产镜像。在开发过程中，容器镜像可能需要编译器和其他工具。然而，在生产环境中，你可能只需要运行时或你的包。
- en: See Also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Running Buildah inside a container](https://oreil.ly/GUfss)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在容器内运行 Buildah](https://oreil.ly/GUfss)'
- en: 3.4 Building a Container with Buildpacks
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 使用 Buildpacks 构建容器
- en: Problem
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Creating container image by using Dockerfiles can be challenging at scale. You
    want a tool complementing Docker that can inspect your application source code
    to create container images without writing a Dockerfile.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模情况下，通过 Dockerfiles 创建容器显得有些挑战。你需要一个工具来补充 Docker，可以检查你的应用程序源代码，从而无需编写 Dockerfile
    就能创建容器镜像。
- en: Solution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[Cloud Native Buildpacks](https://oreil.ly/psc6h) is an open source project
    that provides a set of executables to inspect your app source code and to create
    a plan to build and run your application.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cloud Native Buildpacks](https://oreil.ly/psc6h) 是一个开源项目，提供一组可执行文件来检查你的应用程序源代码，并创建一个构建和运行你的应用程序计划。'
- en: Buildpacks can create OCI-compliant container images without a Dockerfile, starting
    from the app source code, as you can see in [Figure 3-3](#fig3-3).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Buildpacks 可以根据应用程序源代码创建符合 OCI 标准的容器镜像，而无需 Dockerfile，正如你可以在 [图 3-3](#fig3-3)
    中看到的。
- en: '![Buildpacks builds](assets/gocb_0303.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Buildpacks 构建](assets/gocb_0303.png)'
- en: Figure 3-3\. Buildpacks builds
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. Buildpacks 构建
- en: 'This mechanism consists of two phases:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制由两个阶段组成：
- en: Detection
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 检测
- en: Buildpacks tooling will navigate your source code to discover which programming
    language or framework is used (e.g., POM, NPM files, Python requirements, etc.)
    and assign a suitable buildpack for the build.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Buildpacks 工具将浏览你的源代码，以发现使用的编程语言或框架（例如 POM、NPM 文件、Python requirements 等），并为构建分配适当的
    buildpack。
- en: Building
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 构建
- en: Once a buildpack is found, the source is compiled and Buildpacks creates a container
    image with the appropriate entry point and startup scripts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个 buildpack，源代码就会被编译，并且 Buildpacks 将创建一个带有适当入口点和启动脚本的容器镜像。
- en: To use Buildpacks, you have to download the [pack](https://oreil.ly/K0gGM) CLI
    for your operating system (Mac, Windows, Linux), and also have Docker installed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Buildpacks，你需要下载适合你操作系统（Mac、Windows、Linux）的 [pack](https://oreil.ly/K0gGM)
    CLI，并且安装 Docker。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'On macOS, `pack` is available through [Homebrew](https://brew.sh) as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，通过[Homebrew](https://brew.sh)安装`pack`，如下所示：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let’s start creating our container image with Buildpacks from a sample
    Node.js app. You can find the app source code in this [book’s repository](https://oreil.ly/eViRN):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始使用Buildpacks从一个示例Node.js应用程序创建我们的容器镜像。您可以在这个[书的存储库](https://oreil.ly/eViRN)中找到应用程序源代码。
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The app directory structure contains a *package.json* file, a manifest listing
    Node.js packages required for this build, which helps Buildpacks understand which
    buildpack to use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的目录结构包含一个*package.json*文件，列出了此构建所需的Node.js包，这有助于Buildpacks理解使用哪个构建包。
- en: 'You can verify it with this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令来验证：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should get output similar to this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下输出：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now you can decide to pick one of the suggested buildpacks. Let’s try the `paketobuildpacks/builder:base`,
    which also contains the Node.js runtime:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以决定选择其中一个建议的构建包。让我们尝试`paketobuildpacks/builder:base`，它也包含Node.js运行时：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Run `pack builder inspect paketobuildpacks/builder:base` to know the exact content
    of libraries and frameworks available in this buildpack.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pack builder inspect paketobuildpacks/builder:base`命令以了解此构建包中可用的库和框架的确切内容。
- en: 'The building process should start accordingly, and after a while, it should
    finish, and you should get output similar to this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程应该会相应地开始，并在一段时间后完成，您应该会得到类似于以下输出：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let’s run it with Docker:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用Docker来运行它：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get output similar to this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下输出：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'View the running application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 查看正在运行的应用程序：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should get output similar to this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下输出：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discussion
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Cloud Native Buildpacks is an incubating project in the Cloud Native Computing
    Foundation (CNCF), and it supports both Docker and Kubernetes. On Kubernetes,
    it can be used with [Tekton](https://tekton.dev), a Kubernetes-native CI/CD system
    that can run Buildpacks as a Tekton `Task` to create container images. It recently
    adopted the [Boson Project](https://oreil.ly/F0OTs) to provide a functions-as-a-service
    (FaaS) experience on Kubernetes with Knative, by enabling the build of functions
    via buildpacks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Native Buildpacks是Cloud Native Computing Foundation（CNCF）中的一个孵化项目，支持Docker和Kubernetes。在Kubernetes上，它可以与[Tekton](https://tekton.dev)一起使用，Tekton是一个Kubernetes原生的CI/CD系统，可以作为Tekton
    `Task`运行Buildpacks来创建容器镜像。它最近采用了[Boson项目](https://oreil.ly/F0OTs)，通过构建包使得在Kubernetes上使用Knative提供函数即服务（FaaS）体验成为可能。
- en: See Also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Using Buildpacks with Tekton Pipelines](https://oreil.ly/wFIHd)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Tekton Pipelines与Buildpacks](https://oreil.ly/wFIHd)'
- en: '[FaaS Knative Boson project’s buildpacks](https://oreil.ly/p1U6n)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FaaS Knative Boson项目的构建包](https://oreil.ly/p1U6n)'
- en: 3.5 Building a Container Using Shipwright and kaniko in Kubernetes
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 在Kubernetes中使用Shipwright和kaniko构建容器
- en: Problem
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a container image, and you want to do it with Kubernetes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个容器镜像，并且您希望使用Kubernetes来完成。
- en: Solution
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Kubernetes is well known as a container orchestration platform to deploy and
    manage apps. However, it doesn’t include support for building container images
    out-of-the-box. Indeed, according to [Kubernetes documentation](https://oreil.ly/qgpKi):
    “(Kubernetes) Does not deploy source code and does not build your application.
    Continuous Integration, Delivery, and Deployment (CI/CD) workflows are determined
    by organization cultures and preferences as well as technical requirements.”'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes作为一个容器编排平台以部署和管理应用程序而闻名。然而，它不包含开箱即用的构建容器镜像的支持。根据[Kubernetes文档](https://oreil.ly/qgpKi)的说法：“（Kubernetes）不部署源代码，也不构建您的应用程序。持续集成、交付和部署（CI/CD）工作流取决于组织文化、偏好以及技术要求。”
- en: As mentioned, one standard option is to rely on CI/CD systems for this purpose,
    like Tekton (see [Chapter 6](ch06.xhtml#ch_Cloud_Native_CICD)). Another option
    is to use a framework to manage builds with many underlying tools, such as the
    one we discussed in the previous recipes. One example is Shipwright.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个标准的选择是依赖于CI/CD系统，例如Tekton（参见[第6章](ch06.xhtml#ch_Cloud_Native_CICD)）。另一个选择是使用一个管理构建的框架，该框架支持许多底层工具，就像我们在之前的示例中讨论的那样。一个例子是Shipwright。
- en: '[Shipwright](https://shipwright.io) is an extensible framework for building
    container images on Kubernetes. It supports popular tools such as Buildah, Cloud
    Native Buildpacks, and kaniko. It uses Kubernetes-style APIs, and it runs workloads
    using Tekton.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[Shipwright](https://shipwright.io)是一个在Kubernetes上构建容器镜像的可扩展框架。它支持流行工具如Buildah、Cloud
    Native Buildpacks和kaniko。它使用Kubernetes风格的API，并通过Tekton运行工作负载。'
- en: The benefit for developers is a simplified approach for building container images,
    by defining a minimal YAML file that does not require any previous knowledge of
    containers or container engines. This approach makes this solution agnostic and
    highly integrated with the Kubernetes API ecosystem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对开发人员的好处是通过定义一个最小的 YAML 文件来简化构建容器镜像的方法，不需要任何关于容器或容器引擎的先前知识。这种方法使得此解决方案与 Kubernetes
    API 生态系统高度集成且无关。
- en: The first thing to do is to install Shipwright to your Kubernetes cluster, say
    kind or Minikube (see [Chapter 2](ch02.xhtml#ch_Requirements)), following the
    [documentation](https://oreil.ly/FWvXv) or from [OperatorHub.io](https://oreil.ly/6Ds5R).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将 Shipwright 安装到您的 Kubernetes 集群中，比如 kind 或 Minikube（参见[第二章](ch02.xhtml#ch_Requirements)），根据
    [文档](https://oreil.ly/FWvXv) 或 [OperatorHub.io](https://oreil.ly/6Ds5R) 进行操作。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using Operators and Operator Lifecycle Manager (OLM) gives consistency for installing/uninstalling
    software on Kubernetes, along with dependency management and lifecycle control.
    For instance, the Tekton Operator dependency is automatically resolved and installed
    if you install Shipwright via the Operator. Check the OLM [documentation](https://oreil.ly/V3k2p)
    for details with this approach.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运算符和运算符生命周期管理器（OLM）在 Kubernetes 上安装/卸载软件时提供了一致性，以及依赖管理和生命周期控制。例如，如果通过运算符安装
    Shipwright，Tekton Operator 依赖项会自动解析并安装。查看 OLM [文档](https://oreil.ly/V3k2p) 了解此方法的详细信息。
- en: 'Let’s follow the standard procedure from the documentation. First you need
    to install the Tekton dependency. At the time of writing this book, it is version
    `0.30.0`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照文档中的标准流程进行。首先，您需要安装 Tekton 依赖项。在撰写本书时，版本为 `0.30.0`：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then you install Shipwright. At the time of writing this book, it is version
    `0.7.0`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装 Shipwright。在撰写本书时，版本为 `0.7.0`：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, you install Shipwright build strategies:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装 Shipwright 构建策略：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once you have installed Shipwright, you can start creating your container image
    build using one of these tools:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Shipwright，您可以开始使用其中一个工具创建您的容器镜像构建：
- en: kaniko
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kaniko
- en: Cloud Native Buildpacks
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生 Buildpacks
- en: BuildKit
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BuildKit
- en: Buildah
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildah
- en: Let’s explore kaniko.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 kaniko。
- en: '[kaniko](https://oreil.ly/ncdWg) is another dockerless solution to build container
    images from a Dockerfile inside a container or Kubernetes cluster. Shipwright
    brings additional APIs to Kubernetes to use tools such as kaniko to create container
    images, acting as an abstract layer that can be considered an extensible building
    system for Kubernetes.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[kaniko](https://oreil.ly/ncdWg) 是另一种无需 Docker 的解决方案，用于在容器或 Kubernetes 集群中从
    Dockerfile 构建容器镜像。Shipwright 通过额外的 API 将工具（如 kaniko）引入 Kubernetes，以创建容器镜像，作为可扩展的
    Kubernetes 构建系统的抽象层。'
- en: 'Let’s explore the APIs that are defined from Cluster Resource Definitions (CRDs):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索从集群资源定义（CRD）中定义的 API：
- en: '`ClusterBuildStrategy`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterBuildStrategy`'
- en: Represents the type of build to execute.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 表示要执行的构建类型。
- en: '`Build`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Build`'
- en: Represents the build. It includes the specification of one `ClusterBuildStrategy`
    object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表示构建。它包括一个 `ClusterBuildStrategy` 对象的规范。
- en: '`BuildRun`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildRun`'
- en: Represents a running build. The build starts when this object is created.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表示正在运行的构建。创建此对象时启动构建。
- en: 'Run the following command to check all available `ClusterBuildStrategy` (CBS)
    objects:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来检查所有可用的 `ClusterBuildStrategy`（CBS）对象：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should get a list of available CBSs to consume:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得一份可消费的 CBS 列表：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This CRD is cluster-wide, available for all namespaces. If you don’t see any
    items, please install the Shipwright build strategies as discussed previously.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此 CRD 是集群范围的，适用于所有命名空间。如果您没有看到任何项目，请按照之前讨论的方式安装 Shipwright 构建策略。
- en: Shipwright will generate a container image on the Kubernetes nodes container
    cache, and then it can push it to a container registry.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Shipwright 将在 Kubernetes 节点容器缓存上生成一个容器镜像，然后可以将其推送到容器注册表。
- en: 'You need to provide the credentials to push the image to the registry in the
    form of a Kubernetes Secret. For example, if you use Quay you can create one like
    the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要提供凭据以将图像推送到注册表，以 Kubernetes Secret 的形式。例如，如果使用 Quay，可以创建如下所示的凭据：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: With Quay, you can use an encrypted password instead of using your account password.
    See the documentation for more details.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quay，您可以使用加密密码而不是使用您的账户密码。有关更多详细信息，请参阅文档。
- en: 'Now let’s create a *build-kaniko.yaml* file containing the `Build` object that
    will use kaniko to containerize a Node.js sample app. You can find the source
    code in this [book’s repository](https://oreil.ly/S84zu):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个*build-kaniko.yaml*文件，其中包含将使用 kaniko 将 Node.js 示例应用程序容器化的`Build`对象。您可以在这个[书籍的存储库](https://oreil.ly/S84zu)中找到源代码：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[![1](assets/1.png)](#co_containers_CO2-1)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_containers_CO2-1)'
- en: Repository to grab the source code from.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 用于获取源代码的存储库。
- en: '[![2](assets/2.png)](#co_containers_CO2-2)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_containers_CO2-2)'
- en: The directory where the source code is present.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码所在的目录。
- en: '[![3](assets/3.png)](#co_containers_CO2-3)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_containers_CO2-3)'
- en: The `ClusterBuildStrategy` to use.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的`ClusterBuildStrategy`。
- en: '[![4](assets/4.png)](#co_containers_CO2-4)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_containers_CO2-4)'
- en: The destination of the resulting container image. Change this with your container
    registry repo.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 结果容器映像的目的地。请更改为您的容器注册表仓库。
- en: '[![5](assets/5.png)](#co_containers_CO2-5)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_containers_CO2-5)'
- en: The secret to use to authenticate to the container registry and push the image.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 用于身份验证并推送映像到容器注册表的密钥。
- en: 'Now, let’s create the `Build` object:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Build`对象：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should get output similar to this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于这样的输出：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s list the available builds:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出可用的构建：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should get output similar to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下的输出：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At this point, your `Build` is `REGISTERED`, but it’s not started yet. Let’s
    create the following object in order to start it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的`Build`已`REGISTERED`，但尚未开始。让我们创建以下对象以便启动它：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you check the list of running pods, you should see one being created:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查正在运行的 pod 列表，应该会看到一个正在创建中：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When the `STATUS` changes, the build will start, and you can track the progress
    by checking the logs from the containers used by this pod to run the build in
    multiple steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当`STATUS`变化时，构建将开始，并且您可以通过检查此 pod 中用于在多个步骤中运行构建的容器的日志来跟踪进度：
- en: step-source-default
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤-源默认
- en: The first step, used to get the source code
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 用于获取源代码的第一步
- en: step-build-and-push
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤-构建和推送
- en: The step to run the build, either from source code or from a Dockerfile like
    in this case with kaniko
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建的步骤，可以是从源代码或像这种情况下使用 kaniko 的 Dockerfile
- en: step-results
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤-结果
- en: The result of the build
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的结果
- en: 'Let’s check the logs of the building phase:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查构建阶段的日志：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The image is built and pushed to the registry, and you can check the result
    from this command as well:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 映像已构建并推送到注册表，您也可以通过此命令检查结果：
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: And on your registry, as shown in [Figure 3-4](#fig3-4).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 并在您的注册表上，如[图 3-4](#fig3-4)所示。
- en: '![Image pushed to Quay.io](assets/gocb_0304.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![Image pushed to Quay.io](assets/gocb_0304.png)'
- en: Figure 3-4\. Image pushed to Quay
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. 图像推送到 Quay
- en: Discussion
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Shipwright provides a convenient way to create container images on Kubernetes,
    and its agnostic approach makes it robust and interoperable. The project aims
    at being the Build API for Kubernetes, providing an easier path for developers
    to automate on Kubernetes. As Tekton runs under the hood creating builds, Shipwright
    also makes transitioning from micropipeline to extended pipeline workflows on
    Kubernetes easier.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Shipwright 提供了在 Kubernetes 上创建容器映像的便捷方法，其不可知的方法使其强大且可互操作。该项目旨在成为 Kubernetes
    的 Build API，为开发人员在 Kubernetes 上自动化提供更简便的路径。当 Tekton 在后台运行创建构建时，Shipwright 也使得从微流水线过渡到扩展流水线工作流更加容易。
- en: 'As a reference, if you would like to create a build with Buildah instead of
    kaniko, it’s just a `ClusterBuildStrategy` change in your `Build` object:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，如果您想要使用 Buildah 而不是 kaniko 创建一个构建，只需在您的`Build`对象中更改`ClusterBuildStrategy`：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[![1](assets/1.png)](#co_containers_CO3-1)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_containers_CO3-1)'
- en: As we discussed previously in [Recipe 3.3](#recipe_3_3), Buildah can create
    the container image from the source code. It doesn’t need a Dockerfile.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在[Recipe 3.3](#recipe_3_3)中讨论的那样，Buildah可以根据源代码创建容器映像。它不需要 Dockerfile。
- en: '[![2](assets/2.png)](#co_containers_CO3-2)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_containers_CO3-2)'
- en: Selecting Buildah as the `ClusterBuildStrategy`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Buildah作为`ClusterBuildStrategy`。
- en: 3.6 Final Thoughts
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 最后的想法
- en: The container format is the de facto standard for packaging applications, and
    today many tools help create container images. Developers can create images with
    Docker or with other tools and frameworks and then use the same with any CI/CD
    system to deploy their apps to Kubernetes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 容器格式是打包应用程序的事实标准，今天许多工具帮助创建容器映像。开发人员可以使用 Docker 或其他工具和框架创建映像，然后在任何 CI/CD 系统中使用它们部署其应用程序到
    Kubernetes。
- en: While Kubernetes per se doesn’t build container images, some tools interact
    with the Kubernetes API ecosystem to add this functionality. This aspect improves
    development velocity and consistency across environments, delegating this complexity
    to the platform.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 本身不构建容器映像，但一些工具与 Kubernetes API 生态系统交互以添加此功能。这一方面提高了开发速度和环境一致性，将这种复杂性委托给平台。
- en: In the following chapters, you will see how to control the deployment of your
    containers running on Kubernetes with tools such as Kustomize or Helm, and then
    how to add automation to support highly scalable workloads with CI/CD and GitOps.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将看到如何使用 Kustomize 或 Helm 等工具控制在 Kubernetes 上运行的容器的部署，然后如何添加自动化支持高度可扩展的工作负载与
    CI/CD 和 GitOps。
- en: ^([1](ch03.xhtml#idm45120847711664-marker)) For a presentation about Jib, see
    Appu Goundan and Qingyang Chen’s [presentation from Velocity San Jose 2018](https://oreil.ly/W4j49).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45120847711664-marker)) 欲了解有关 Jib 的演示，请参阅 Appu Goundan 和
    Qingyang Chen 在 Velocity San Jose 2018 的[演示](https://oreil.ly/W4j49)。
