- en: Chapter 3\. Creating, Updating, and Deleting Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the basics of moving data into and out of the database,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new documents to a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing documents from a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating existing documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the correct level of safety versus speed for all of these operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inserts are the basic method for adding data to MongoDB. To insert a single
    document, use the collection’s `insertOne` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`insertOne` will add an `"_id"` key to the document (if you do not supply one)
    and store the document in MongoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: insertMany
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to insert multiple documents into a collection, you can use `insertMany`.
    This method enables you to pass an array of documents to the database. This is
    far more efficient because your code will not make a round trip to the database
    for each document inserted, but will insert them in bulk.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the shell, you can try this out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sending dozens, hundreds, or even thousands of documents at a time can make
    inserts significantly faster.
  prefs: []
  type: TYPE_NORMAL
- en: '`insertMany` is useful if you are inserting multiple documents into a single
    collection. If you are just importing raw data (e.g., from a data feed or MySQL),
    there are command-line tools like *mongoimport* that can be used instead of a
    batch insert. On the other hand, it is often handy to munge data before saving
    it to MongoDB (converting dates to the date type or adding a custom `"_id"`, for
    example). In such cases `insertMany` can be used for importing data, as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Current versions of MongoDB do not accept messages longer than 48 MB, so there
    is a limit to how much can be inserted in a single batch insert. If you attempt
    to insert more than 48 MB, many drivers will split up the batch insert into multiple
    48 MB batch inserts. Check your driver documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: When performing a bulk insert using `insertMany`, if a document halfway through
    the array produces an error of some type, what happens depends on whether you
    have opted for ordered or unordered operations. As the second parameter to `insertMany`
    you may specify an options document. Specify `true` for the key `"ordered"` in
    the options document to ensure documents are inserted in the order they are provided.
    Specify `false` and MongoDB may reorder the inserts to increase performance. Ordered
    inserts is the default if no ordering is specified. For ordered inserts, the array
    passed to `insertMany` defines the insertion order. If a document produces an
    insertion error, no documents beyond that point in the array will be inserted.
    For unordered inserts, MongoDB will attempt to insert all documents, regardless
    of whether some insertions produce errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, because ordered inserts is the default, only the first two
    documents will be inserted. The third document will produce an error, because
    you cannot insert two documents with the same `"_id"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If instead we specify unordered inserts, the first, second, and fourth documents
    in the array are inserted. The only insert that fails is the third document, again
    because of a duplicate `"_id"` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you study these examples closely, you might note that the output of these
    two calls to `insertMany` hints that other operations besides simply inserts might
    be supported for bulk writes. While `insertMany` does not support operations other
    than insert, MongoDB does support a Bulk Write API that enables you to batch together
    a number of operations of different types in one call. While that is beyond the
    scope of this chapter, you can read about the [Bulk Write API](https://docs.mongodb.org/manual/core/bulk-write-operations/)
    in the MongoDB documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Insert Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB does minimal checks on data being inserted: it checks the document’s
    basic structure and adds an `"_id"` field if one does not exist. One of the basic
    structure checks is size: all documents must be smaller than 16 MB. This is a
    somewhat arbitrary limit (and may be raised in the future); it is mostly intended
    to prevent bad schema design and ensure consistent performance. To see the Binary
    JSON (BSON) size, in bytes, of the document *`doc`*, run ``Object.bsonsize(*`doc`*)``
    from the shell.'
  prefs: []
  type: TYPE_NORMAL
- en: To give you an idea of how much data 16 MB is, the entire text of *War and Peace*
    is just 3.14 MB.
  prefs: []
  type: TYPE_NORMAL
- en: These minimal checks also mean that it is fairly easy to insert invalid data
    (if you are trying to). Thus, you should only allow trusted sources, such as your
    application servers, to connect to the database. All of the MongoDB drivers for
    major languages (and most of the minor ones, too) do check for a variety of invalid
    data (documents that are too large, contain non-UTF-8 strings, or use unrecognized
    types) before sending anything to the database.
  prefs: []
  type: TYPE_NORMAL
- en: insert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In versions of MongoDB prior to 3.0, `insert` was the primary method for inserting
    documents into MongoDB. MongoDB drivers introduced a new CRUD API at the same
    time as the MongoDB 3.0 server release. As of MongoDB 3.2 the *mongo* shell also
    supports this API, which includes `insertOne` and `insertMany` as well as several
    other methods. The goal of the current CRUD API is to make the semantics of all
    CRUD operations consistent and clear across the drivers and the shell. While methods
    such as `insert` are still supported for backward compatibility, they should not
    be used in applications going forward. You should instead prefer `insertOne` and
    `insertMany` for creating documents.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that there’s data in our database, let’s delete it. The CRUD API provides
    `deleteOne` and `deleteMany` for this purpose. Both of these methods take a filter
    document as their first parameter. The filter specifies a set of criteria to match
    against in removing documents. To delete the document with the `` `"_id"` `` value
    of `4`, we use `deleteOne` in the *mongo* shell as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used a filter that could only match one document since `"_id"`
    values are unique in a collection. However, we can also specify a filter that
    matches multiple documents in a collection. In this case, `deleteOne` will delete
    the first document found that matches the filter. Which document is found first
    depends on several factors, including the order in which the documents were inserted,
    what updates were made to the documents (for some storage engines), and what indexes
    are specified. As with any database operation, be sure you know what effect your
    use of `deleteOne` will have on your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete all the documents that match a filter, use `deleteMany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a more realistic use case, suppose you want to remove every user from the
    *mailing.list* collection where the value for `"opt-out"` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In versions of MongoDB prior to 3.0, `remove` was the primary method for deleting
    documents. MongoDB drivers introduced the `deleteOne` and `deleteMany` methods
    at the same time as the MongoDB 3.0 server release, and the shell began supporting
    these methods in MongoDB 3.2\. While `remove` is still supported for backward
    compatibility, you should use `deleteOne` and `deleteMany` in your applications.
    The current CRUD API provides a cleaner set of semantics and, especially for multidocument
    operations, helps application developers avoid a couple of common pitfalls with
    the previous API.
  prefs: []
  type: TYPE_NORMAL
- en: drop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to use `deleteMany` to remove all documents in a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing documents is usually a fairly quick operation. However, if you want
    to clear an entire collection, it is faster to `drop` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: and then recreate any indexes on the empty collection.
  prefs: []
  type: TYPE_NORMAL
- en: Once data has been removed, it is gone forever. There is no way to undo a delete
    or drop operation or recover deleted documents, except, of course, by restoring
    a previously backed up version of the data. See [Chapter 23](ch23.xhtml#chapter-backup)
    for a detailed discussion of MongoDB backup and restore.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once a document is stored in the database, it can be changed using one of several
    update methods: `updateOne`, `updateMany`, and `replaceOne`. `updateOne` and `updateMany`
    each take a filter document as their first parameter and a modifier document,
    which describes changes to make, as the second parameter. `replaceOne` also takes
    a filter as the first parameter, but as the second parameter `replaceOne` expects
    a document with which it will replace the document matching the filter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating a document is atomic: if two updates happen at the same time, whichever
    one reaches the server first will be applied, and then the next one will be applied.
    Thus, conflicting updates can safely be sent in rapid-fire succession without
    any documents being corrupted: the last update will “win.” The Document Versioning
    pattern (see [“Schema Design Patterns”](ch09.xhtml#schemeDesignPatterns)) is worth
    considering if you don’t want the default behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Document Replacement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`replaceOne` fully replaces a matching document with a new one. This can be
    useful to do a dramatic schema migration (see [Chapter 9](ch09.xhtml#chapter-app-design)
    for scheme migration strategies). For example, suppose we are making major changes
    to a user document, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to move the `"friends"` and `"enemies"` fields to a `"relationships"`
    subdocument. We can change the structure of the document in the shell and then
    replace the database’s version with a `replaceOne`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, doing a `findOne` shows that the structure of the document has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A common mistake is matching more than one document with the criteria and then
    creating a duplicate `"_id"` value with the second parameter. The database will
    throw an error for this, and no documents will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we create several documents with the same value for `"name"`,
    but we don’t realize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if it’s Joe #2’s birthday, we want to increment the value of his `"age"`
    key, so we might say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? When you do the update, the database will look for a document
    matching `{"name" : "joe"}`. The first one it finds will be the 65-year-old Joe.
    It will attempt to replace that document with the one in the `joe` variable, but
    there’s already a document in this collection with the same `"_id"`. Thus, the
    update will fail, because `"_id"` values must be unique. The best way to avoid
    this situation is to make sure that your update always specifies a unique document,
    perhaps by matching on a key like `"_id"`. For the preceding example, this would
    be the correct update to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using `"_id"` for the filter will also be efficient since`"_id"` values form
    the basis for the primary index of a collection. We’ll cover primary and secondary
    indexes and how indexing affects updates and other operations more in [Chapter 5](ch05.xhtml#chapter_d1e5128).
  prefs: []
  type: TYPE_NORMAL
- en: Using Update Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually only certain portions of a document need to be updated. You can update
    specific fields in a document using atomic *update operators*. Update operators
    are special keys that can be used to specify complex update operations, such as
    altering, adding, or removing keys, and even manipulating arrays and embedded
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we’re keeping website analytics in a collection and want to increment
    a counter each time someone visits a page. We can use update operators to do this
    increment atomically. Each URL and its number of page views is stored in a document
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time someone visits a page, we can find the page by its URL and use the
    `"$inc"` modifier to increment the value of the `"pageviews"` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we do a `findOne`, we see that `"pageviews"` has increased by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When using operators, the value of `"_id"` cannot be changed. (Note that `"_id"`
    *can* be changed by using whole-document replacement.) Values for any other key,
    including other uniquely indexed keys, can be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the “$set” modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`"$set"` sets the value of a field. If the field does not yet exist, it will
    be created. This can be handy for updating schemas or adding user-defined keys.
    For example, suppose you have a simple user profile stored as a document that
    looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty bare-bones user profile. If the user wanted to store his favorite
    book in his profile, he could add it using `"$set"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the document will have a `"favorite book"` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user decides that he actually enjoys a different book, `"$set"` can
    be used again to change the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`"$set"` can even change the type of the key it modifies. For instance, if
    our fickle user decides that he actually likes quite a few books, he can change
    the value of the `"favorite book"` key into an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user realizes that he actually doesn’t like reading, he can remove the
    key altogether with `"$unset"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now the document will be the same as it was at the beginning of this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `"$set"` to reach in and change embedded documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You must always use a `$`-modifier for adding, changing, or removing keys.
    A common error people make when starting out is to try to set the value of a key
    to some other value by doing an update that resembles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will result in an error. The update document must contain update operators.
    Previous versions of the CRUD API did not catch this type of error. Earlier update
    methods would simply complete a whole document replacement in such situations.
    It is this type of pitfall that led to the creation of a new CRUD API.
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing and decrementing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `"$inc"` operator can be used to change the value for an existing key or
    to create a new key if it does not already exist. It’s useful for updating analytics,
    karma, votes, or anything else that has a changeable, numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are creating a game collection where we want to save games and update
    scores as they change. When a user starts playing, say, a game of pinball, we
    can insert a document that identifies the game by name and the user playing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the ball hits a bumper, the game should increment the player’s score.
    Since points in pinball are given out pretty freely, let’s say that the base unit
    of points a player can earn is 50\. We can use the `"$inc"` modifier to add 50
    to the player’s score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the document after this update, we’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `"score"` key did not already exist, so it was created by `"$inc"` and
    set to the increment amount: `50`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the ball lands in a “bonus” slot, we want to add 10,000 to the score. We
    can do this by passing a different value to `"$inc"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we look at the game, we’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `"score"` key existed and had a numeric value, so the server added 10,000
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '`"$inc"` is similar to `"$set"`, but it is designed for incrementing (and decrementing)
    numbers. `"$inc"` can be used only on values of type integer, long, double, or
    decimal. If it is used on any other type of value, it will fail. This includes
    types that many languages will automatically cast into numbers, like nulls, booleans,
    or strings of numeric characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Also, the value of the `"$inc"` key must be a number. You cannot increment by
    a string, array, or other nonnumeric value. Doing so will give a “Modifier `"$inc"`
    allowed for numbers only” error message. To modify other types, use `"$set"` or
    one of the following array operators.
  prefs: []
  type: TYPE_NORMAL
- en: Array operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An extensive class of update operators exists for manipulating arrays. Arrays
    are common and powerful data structures: not only are they lists that can be referenced
    by index, but they can also double as sets.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`"$push"` adds elements to the end of an array if the array exists and creates
    a new array if it does not. For example, suppose that we are storing blog posts
    and want to add a `"comments"` key containing an array. We can push a comment
    onto the nonexistent `"comments"` array, which will create the array and add the
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to add another comment, we can simply use `"$push"` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the “simple” form of `"push"`, but you can use it for more complex
    array operations as well. The MongoDB query language provides modifiers for some
    operators, including `"$push"`. You can push multiple values in one operation
    using the `"$each"` modifer for `"$push"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This would push three new elements onto the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want the array to grow to a certain length, you can use the `"$slice"`
    modifier with `"$push"` to prevent an array from growing beyond a certain size,
    effectively making a “top N” list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This example limits the array to the last 10 elements pushed.
  prefs: []
  type: TYPE_NORMAL
- en: If the array is smaller than 10 elements (after the push), all elements will
    be kept. If the array is larger than 10 elements, only the last 10 elements will
    be kept. Thus, `"$slice"` can be used to create a queue in a document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can apply the `"$sort"` modifier to `"$push"` operations before
    trimming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will sort all of the objects in the array by their `"rating"` field and
    then keep the first 10\. Note that you must include `"$each"`; you cannot just
    `"$slice"` or `"$sort"` an array with `"$push"`.
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays as sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You might want to treat an array as a set, only adding values if they are not
    present. This can be done using `"$ne"` in the query document. For example, to
    push an author onto a list of citations, but only if they aren’t already there,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This can also be done with `"$addToSet"`, which is useful for cases where `"$ne"`
    won’t work or where `"$addToSet"` describes what is happening better.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have a document that represents a user. You might
    have a set of email addresses that they have added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding another address, you can use “`$addToSet"` to prevent duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `"$addToSet"` in conjunction with `"$each"` to add multiple
    unique values, which cannot be done with the `"$ne"`/`"$push"` combination. For
    instance, you could use these operators if the user wanted to add more than one
    email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Removing elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a few ways to remove elements from an array. If you want to treat
    the array like a queue or a stack, you can use `"$pop"`, which can remove elements
    from either end. ``{"$pop" : {"*`key`*" : 1}}`` removes an element from the end
    of the array. ``{"$pop" : {"*`key`*" : -1}}`` removes it from the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes an element should be removed based on specific criteria, rather than
    its position in the array. `"$pull"` is used to remove elements of an array that
    match the given criteria. For example, suppose we have a list of things that need
    to be done, but not in any specific order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do the laundry first, we can remove it from the list with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we do a find, we’ll see that there are only two elements remaining in
    the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Pulling removes all matching documents, not just a single match. If you have
    an array that looks like `[1, 1, 2, 1]` and pull `1`, you’ll end up with a single-element
    array, `[2]`.
  prefs: []
  type: TYPE_NORMAL
- en: Array operators can be used only on keys with array values. For example, you
    cannot push onto an integer or pop off of a string. Use `"$set"` or `"$inc"` to
    modify scalar values.
  prefs: []
  type: TYPE_NORMAL
- en: Positional array modifications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Array manipulation becomes a little trickier when you have multiple values
    in an array and want to modify some of them. There are two ways to manipulate
    values in arrays: by position or by using the position operator (the `$` character).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays use 0-based indexing, and elements can be selected as though their index
    were a document key. For example, suppose we have a document containing an array
    with a few embedded documents, such as a blog post with comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to increment the number of votes for the first comment, we can say
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, though, we don’t know what index of the array to modify without
    querying for the document first and examining it. To get around this, MongoDB
    has a positional operator, `$`, that figures out which element of the array the
    query document matched and updates that element. For example, if we have a user
    named John who updates his name to Jim, we can replace it in the comments by using
    the positional operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The positional operator updates only the first match. Thus, if John had left
    more than one comment, his name would be changed only for the first comment he
    left.
  prefs: []
  type: TYPE_NORMAL
- en: Updates using array filters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MongoDB 3.6 introduced another option for updating individual array elements:
    `arrayFilters`. This option enables us to modify array elements matching particular
    critera. For example, if we want to hide all comments with five or more down votes,
    we can do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This command defines `elem` as the identifier for each matching element in the
    `"comments"` array. If the `votes` value for the comment identified by `elem`
    is less than or equal to `-5`, we will add a field called `"hidden"` to the `"comments"`
    document and set its value to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Upserts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *upsert* is a special type of update. If no document is found that matches
    the filter, a new document will be created by combining the criteria and updated
    documents. If a matching document is found, it will be updated normally. Upserts
    can be handy because they can eliminate the need to “seed” your collection: you
    can often have the same code create and update documents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our example that records the number of views for each page
    of a website. Without an upsert, we might try to find the URL and increment the
    number of views or create a new document if the URL doesn’t exist. If we were
    to write this out as a JavaScript program it might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This means we are making a round trip to the database, plus sending an update
    or insert, every time someone visits a page. If we are running this code in multiple
    processes, we are also subject to a race condition where more than one document
    can be inserted for a given URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can eliminate the race condition and cut down the amount of code by just
    sending an upsert to the database (the third parameter to `updateOne` and `updateMany`
    is an options document that enables us to specify this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This line does exactly what the previous code block does, except it’s faster
    and atomic! The new document is created by using the criteria document as a base
    and applying any modifier documents to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you do an upsert that matches a key and increments to the value
    of that key, the increment will be applied to the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The upsert creates a new document with a `"rep"` of `25` and then increments
    that by 3, giving us a document where `"rep"` is `28`. If the upsert option were
    not specified, `{"rep" : 25}` would not match any documents, so nothing would
    happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the upsert again (with the criterion `{"rep" : 25}`), it will create
    another new document. This is because the criterion does not match the only document
    in the collection. (Its `"rep"` is `28`.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes a field needs to be set when a document is created, but not changed
    on subsequent updates. This is what `"$setOnInsert"` is for. `"$setOnInsert"`
    is an operator that only sets the value of a field when the document is being
    inserted. Thus, we could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this update again, it will match the existing document, nothing will
    be inserted, and so the `"createdAt"` field will not be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that you generally do not need to keep a `"createdAt"` field, as `ObjectId`s
    contain a timestamp of when the document was created. However, `"$setOnInsert"`
    can be useful for creating padding, initializing counters, and for collections
    that do not use `ObjectId`s.
  prefs: []
  type: TYPE_NORMAL
- en: The save shell helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`save` is a shell function that lets you insert a document if it doesn’t exist
    and update it if it does. It takes one argument: a document. If the document contains
    an `"_id"` key, `save` will do an upsert. Otherwise, it will do an insert. `save`
    is really just a convenience function so that programmers can quickly modify documents
    in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Without `save`, the last line would have been more cumbersome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Updating Multiple Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this chapter we have used `updateOne` to illustrate update operations.
    `updateOne` updates only the first document found that matches the filter criteria.
    If there are more matching documents, they will remain unchanged. To modify all
    of the documents matching a filter, use `updateMany`. `updateMany` follows the
    same semantics as `updateOne` and takes the same parameters. The key difference
    is in the number of documents that might be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '`updateMany` provides a powerful tool for performing schema migrations or rolling
    out new features to certain users. Suppose, for example, we want to give a gift
    to every user who has a birthday on a certain day. We can use `updateMany` to
    add a `"gift"` to their accounts. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The call to `updateMany` adds a `"gift"` field to each of the three documents
    we inserted into the *users* collection immediately before.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Updated Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For some use cases it is important to return the document modified. In earlier
    versions of MongoDB, `findAndModify` was the method of choice in such situations.
    It is handy for manipulating queues and performing other operations that need
    get-and-set−style atomicity. However, `findAndModify` is prone to user error because
    it’s a complex method combining the functionality of three different types of
    operations: delete, replace, and update (including upserts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB 3.2 introduced three new collection methods to the shell to accommodate
    the functionality of `findAndModify`, but with semantics that are easier to learn
    and remember: `findOneAndDelete`, `findOneAndReplace`, and `findOneAndUpdate`.
    The primary difference between these methods and, for example, `updateOne` is
    that they enable you to atomically get the value of a modified document. MongoDB
    4.2 extended `findOneAndUpdate` to accept an aggregation pipeline for the update.
    The pipeline can consist of the following stages: `$addFields` and its alias `$set`,
    `$project` and its alias `$unset`, and `$replaceRoot` and its alias `$replaceWith`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a collection of processes run in a certain order. Each is represented
    with a document that has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`"status"` is a string that can be `"READY"`, `"RUNNING"`, or `"DONE"`. We
    need to find the job with the highest priority in the `"READY"` state, run the
    process function, and then update the status to `"DONE"`. We might try querying
    for the ready processes, sorting by priority, and updating the status of the highest-priority
    process to mark it as `"RUNNING"`. Once we have processed it, we update the status
    to `"DONE"`. This looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This algorithm isn’t great because it is subject to a race condition. Suppose
    we have two threads running. If one thread (call it A) retrieved the document
    and another thread (call it B) retrieved the same document before A had updated
    its status to `"RUNNING"`, then both threads would be running the same process.
    We can avoid this by checking the result as part of the update query, but this
    becomes complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Also, depending on timing, one thread may end up doing all the work while another
    thread uselessly trails it. Thread A could always grab the process, and then B
    would try to get the same process, fail, and leave A to do all the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Situations like this are perfect for `findOneAndUpdate`. `findOneAndUpdate`
    can return the item and update it in a single operation. In this case, it looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the status is still `"READY"` in the returned document because
    the `findOneAndUpdate` method defaults to returning the state of the document
    before it was modified. It will return the updated document if we set the `"returnNewDocument"`
    field in the options document to `true`. An options document is passed as the
    third parameter to `findOneAndUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the program becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this one, there are two other methods you should be aware of.
    `findOneAndReplace` takes the same parameters and returns the document matching
    the filter either before or after the replacement, depending on the value of `returnNewDocument`.
    `findOneAndDelete` is similar except it does not take an update document as a
    parameter and has a subset of the options of the other two methods. `findOneAndDelete`
    returns the deleted document.
  prefs: []
  type: TYPE_NORMAL
