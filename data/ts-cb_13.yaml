- en: Chapter 12\. Type Development Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All recipes up until now have dealt with specific aspects of the TypeScript
    programming language and its type system. You have learned about effectively using
    basic types in Chapters [2](ch02.html#ch02) and [3](ch03.html#ch03), making your
    code more reusable through generics in [Chapter 4](ch04.html#ch04), and crafting
    advanced types for very delicate situations using conditional types in [Chapter 5](ch05.html#ch05),
    string template literal types in [Chapter 6](ch06.html#ch06), and variadic tuple
    types in [Chapter 7](ch07.html#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: We established a collection of helper types in [Chapter 8](ch08.html#ch08) and
    worked around standard library limitations in [Chapter 9](ch09.html#ch09). We
    learned how to work with JSX as a language extension in [Chapter 10](ch10.html#ch10)
    and how and when to use classes in [Chapter 11](ch11.html#ch11). Every recipe
    discussed in detail the pros and cons of each approach, giving you better tools
    to decide correctly for every situation, creating better types, more robust programs,
    and a stable development flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a lot! One thing is still missing, though, the final piece that brings
    everything together: how do we approach new type challenges? Where do we start?
    What do we need to look out for?'
  prefs: []
  type: TYPE_NORMAL
- en: The answers to these questions make up the contents of this chapter. Here you
    will learn about the concept of *low maintenance types*. We will explore a process
    on how you can start with simple types first and gradually get more refined and
    stronger. You will learn about the secret features of the [TypeScript playground](https://www.typescriptlang.org/play)
    and how to deal with libraries that make validation easier. You will find guides
    to help you make hard decisions and learn about workarounds to the most common
    yet tough-to-beat type errors that will definitely hit you in your TypeScript
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: If the rest of the book brought you from novice to apprentice, the next recipes
    will lead you to become an expert. Welcome to the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 Writing Low Maintenance Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time your model changes, you need to touch a dozen types throughout your
    codebase. That is tedious, and it’s also easy to miss something.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Derive types from others, infer from usage, and create low maintenance types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we have spent a lot of time creating types from other
    types. The moment we can derive a type from something that already exists means
    we spend less time writing and adapting type information and more time fixing
    bugs and errors in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is a layer of metainformation on top of JavaScript. Our goal is
    still to write JavaScript but make it as robust and easy as possible: tooling
    helps you stay productive and doesn’t get in your way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s how I write TypeScript in general: I write regular JavaScript, and where
    TypeScript needs extra information, I happily add some extra annotations. One
    condition: I don’t want to be bothered maintaining types. I’d rather create types
    that can update themselves if their dependencies or surroundings change. I call
    this approach *creating low maintenance types*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating low maintenance types is a three-part process:'
  prefs: []
  type: TYPE_NORMAL
- en: Model your data or infer from existing models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define derivates (mapped types, partials, etc.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define behavior with conditional types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s take a look at this brief and incomplete `copy` function. I want to copy
    files from one directory to another. To make my life easier, I created a set of
    default options so I don’t have to repeat myself too much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That’s a pattern you might see a lot in JavaScript. What you see immediately
    is that TypeScript misses *some* type information. Especially the `options` argument
    of the `copy` function is `any` at the moment. So let’s add a type for that!
  prefs: []
  type: TYPE_NORMAL
- en: 'I could create types explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a reasonable approach. You think about types, then you assign types,
    and then you get all the editor feedback and type-checking you are used to. But
    what if something changes? Let’s assume we add another field to `Options`; we
    would have to adapt our code three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But why? The information is already there! In `defaultOptions`, we tell TypeScript
    exactly what we’re looking for. Let’s optimize:'
  prefs: []
  type: TYPE_NORMAL
- en: Drop the `PartialOptions` type and use the utility type `Partial<T>` to get
    the same effect. You might have guessed this one already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `typeof` operator in TypeScript to create a new type on the fly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There you go. Just annotate where we need to tell TypeScript what we’re looking
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: If we add new fields, we don’t have to maintain anything at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we rename a field, we get *just* the information we care about: all uses
    of `copy` where we have to change the options we pass to the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have one single source of truth: the actual `defaultOptions` object. This
    is the object that counts because it’s the only information we have at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And our code becomes a little bit more concise. TypeScript becomes less intrusive
    and more aligned to how we write JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is one that has accompanied us from the beginning: the toy
    shop that started in [Recipe 3.1](ch03.html#ch03_item_modelling_data), and has
    continued in Recipes [4.5](ch04.html#ch04_new_object_types) and [5.3](ch05.html#ch05_grouping_elements).
    Revisit all three items and think about how we can change only the model to get
    all other types updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Refining Types Step by Step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your API needs elaborate types, using advanced features like generics, conditional
    types, and string template literal types. You don’t know where to start.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refine your types step by step. Start with basic primitive and object types,
    subset, add generics, and then go all-in advanced. The process described in this
    lesson will help you craft types. It’s also a good way to recap everything you’ve
    learned.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have an [Express-style server](https://expressjs.com) that allows us to define
    a route (or path) and executes a callback if the URL is requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The request object
  prefs: []
  type: TYPE_NORMAL
- en: Here we get information on the [HTTP method used](https://oreil.ly/zcoUS)—for
    example, `GET`, `POST`, `PUT`, `DELETE`—and additional parameters that come in.
    In this example `userID` should be mapped to a parameter `userID` that, well,
    contains the user’s identifier!
  prefs: []
  type: TYPE_NORMAL
- en: The response or reply object
  prefs: []
  type: TYPE_NORMAL
- en: Here we want to prepare a proper response from the server to the client. We
    want to send correct status codes (method `status`) and send JSON output over
    the wire.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we see in this example is heavily simplified, but it gives a good idea
    of what we are up to. The previous example is also riddled with errors! Take a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Three lines of implementation code and three errors? What happened?
  prefs: []
  type: TYPE_NORMAL
- en: The first error is nuanced. While we tell our app that we want to listen to
    `GET` requests (hence `app.get`), we do something only if the request method is
    `POST`. At this particular point in our application, `req.method` can’t be `POST`.
    So we would never send any response, which might lead to unexpected timeouts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s great that we explicitly send a status code! `20` isn’t a valid status
    code, though. Clients might not understand what’s happening here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the response we want to send back. We access the parsed arguments but
    have a typo. It’s `userID`, not `userId`. All our users would be greeted with
    “Welcome, user undefined!” Something you definitely have seen in the wild!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solving issues like this is TypeScript’s main purpose. TypeScript wants to understand
    your JavaScript code better than you do. And where TypeScript can’t figure out
    what you mean, you can assist by providing extra type information. The problem
    is that it’s often hard to start adding types. You might have the most puzzling
    edge cases in your mind but don’t know how to get to them.
  prefs: []
  type: TYPE_NORMAL
- en: I want to propose a process that may help you get started and also shows you
    where there’s a good place to stop. You can increase the strengths of your types
    step by step. It gets better with each refinement, and you can increase type safety
    over a longer period of time. Let’s start!
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Basic typing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start with some basic type information. We have an `app` object that points
    to a `get` function. The `get` function takes a `path`, which is a string, and
    a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`CallbackFn` is a function type that returns `void` and takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`req`, which is of type `ServerRequest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reply`, which is of type `ServerReply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`ServerRequest` is a pretty complex object in most frameworks. We do a simplified
    version for demonstration purposes. We pass in a `method` string, for `"GET"`,
    `"POST"`, `"PUT"`, `"DELETE"`, and so on. It also has a `params` record. Records
    are objects that associate a set of keys with a set of properties. For now, we
    want to allow every `string` key to be mapped to a `string` property. We’ll refactor
    this one later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For `ServerReply`, we lay out some functions, knowing that a real `ServerReply`
    object has many more. A `send` function takes an optional argument `obj` with
    the data we want to send. We have the possibility to set a status code with the
    `status` function using a fluent interface:^([1](ch12.html#id971))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With some very basic compound types and a simple primitive type for paths,
    we already added a lot of type safety to our project. We can rule out a couple
    of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That’s great, but there’s still a lot to do. We can still send wrong status
    codes (any number is possible) and have no clue about the possible HTTP methods
    (any string is possible). So let’s refine our types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Subset primitive types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see primitive types as a set of all possible values of that certain
    category. For example, `string` includes all possible strings that can be expressed
    in JavaScript, `number` includes all possible numbers with double float precision,
    and `boolean` includes all possible Boolean values, which are `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript allows you to refine those sets to smaller subsets. For example,
    we can create a type `Methods` that includes all possible strings we can receive
    for HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Methods` is a smaller set of the bigger `string` set. `Methods` is also a
    union type of literal types, the smallest unit of a given set. A literal string.
    A literal number. There is no ambiguity: it’s just `"GET"`. You put them in a
    union with other literal types, creating a subset of whatever bigger types you
    have. You can also do a subset with literal types of both `string` and `number`,
    or different compound object types. There are lots of possibilities to combine
    and put literal types into unions.'
  prefs: []
  type: TYPE_NORMAL
- en: This has an immediate effect on our server callback. Suddenly, we can differentiate
    between those four methods (or more if necessary) and can exhaust all possibilities
    in code. TypeScript will guide us.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s one less category of errors. We now know exactly which possible HTTP
    methods are available. We can do the same for HTTP status codes, by defining a
    subset of valid numbers that `statusCode` can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Type `StatusCode` is again a union type. And with that, we exclude another
    category of errors. Suddenly, code like that fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And our software becomes a lot safer. But we can do more!
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Adding generics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we define a route with `app.get`, we implicitly know that the only HTTP
    method possible is `"GET"`. But with our type definitions, we still have to check
    for all possible parts of the union.
  prefs: []
  type: TYPE_NORMAL
- en: The type for `CallbackFn` is correct, as we could define callback functions
    for all possible HTTP methods, but if we explicitly call `app.get`, it would be
    nice to save some extra steps, which are only necessary to comply with typings.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript generics can help. We want to define `ServerRequest` in a way that
    we can specify a part of `Methods` instead of the entire set. For that, we use
    the generic syntax where we can define parameters as we would do with functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ServerRequest` becomes a generic type, as indicated by the angle brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define a generic parameter called `Met`, which is a subset of type `Methods`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use this generic parameter as a generic variable to define the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that change, we can specify different `ServerRequest` variants without
    duplicating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we changed the interface of `ServerRequest`, we have to change all our
    other types that use `ServerRequest`, like `CallbackFn` and the `get` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the `get` function, we pass an actual argument to our generic type. We
    know that this won’t be just a subset of `Methods`; we know exactly which subset
    we are dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we use `app.get`, we only have one possible value for `req.method`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This ensures we don’t assume HTTP methods like `"POST"` or similar are available
    when we create an `app.get` callback. We know exactly what we are dealing with
    at this point, so let’s reflect that in our types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already did a lot to make sure that `request.method` is reasonably typed
    and represents the actual state of affairs. One nice benefit of subsetting the
    `Methods` union type is that we can create a general-purpose callback function
    *outside* of `app.get` that is type safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 4: Advanced types to type-check'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What we haven’t touched yet is typing the `params` object. So far, we get a
    record that allows accessing every `string` key. It’s our task now to make that
    a little more specific!
  prefs: []
  type: TYPE_NORMAL
- en: 'We do so by adding another generic variable, one for methods and one for the
    possible keys in our `Record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic type variable `Par` can be a subset of type `string`, and the default
    value is every string. With that, we can tell `ServerRequest` which keys we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the new argument to our `get` function and the `CallbackFn` type,
    so we can set the requested parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don’t set `Par` explicitly, the type works like we are accustomed to,
    since `Par` defaults to `string`. If we set it, though, we suddenly have a proper
    definition for the `req.params` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That’s great! One little thing can be improved, though. We still can pass *every*
    string to the `path` argument of `app.get`. Wouldn’t it be better if we could
    reflect `Par` in there as well? We can! This is where *string template literal
    types* (see [Chapter 6](ch06.html#ch06)) come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a type called `IncludesRouteParams` to make sure that `Par` is
    properly included in the Express-style way of adding a colon in front of the parameter
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic type `IncludesRouteParams` takes one argument, which is a subset
    of `string`. It creates a union type of two template literals:'
  prefs: []
  type: TYPE_NORMAL
- en: The first template literal starts with *any* `string`, then includes a `/` character
    followed by a `:` character, followed by the parameter name. This ensures that
    we catch all cases where the parameter is at the end of the route string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second template literal starts with *any* `string`, followed by the same
    pattern of `/`, `:`, and the parameter name. Then we have another `/` character,
    followed by *any* string. This branch of the union type makes sure we catch all
    cases where the parameter is somewhere within a route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how `IncludesRouteParams` with the parameter name `userID` behaves
    with different test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s include our new utility type in the `get` function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Great! We get another safety mechanism to ensure that we don’t miss out on adding
    the parameters to the actual route. That’s powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Locking literal types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But guess what: I’m still not happy with it. A few issues with that approach
    become apparent the moment your routes get a little more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: The first issue is that we need to explicitly state our parameters in the generic
    type parameter. We have to bind `Par` to `"userID"`, even though we would specify
    it anyway in the `path` argument of the function. This is not JavaScript-y!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach handles only one route parameter. The moment we add a union—for
    example, `"userID" | "orderId"`—the fail-safe check is satisfied with only *one*
    of those arguments being available. That’s how sets work. It can be one or the
    other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be a better way. And there is. Otherwise, this recipe would end on
    a very bitter note.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s inverse the order! Instead of defining the route params in a generic
    type variable, we extract the variables from the `path` passed as the first argument
    of `app.get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We remove the `Par` generic type and add `Path`, which can be a subset of any
    `string`. When we set `path` to this generic type `Path`, the moment we pass a
    parameter to `get`, we catch its string literal type. We pass `Path` to a new
    generic type `ParseRouteParams` that we haven’t created yet.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work on `ParseRouteParams`. Here, we switch the order of events again.
    Instead of passing the requested route params to the generic to make sure the
    path is all right, we pass the route path and extract the possible route params.
    For that, we need to create a conditional type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Adding conditional types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional types are syntactically similar to the ternary operator in JavaScript.
    You check for a condition, and if the condition is met, you return branch A; otherwise,
    you return branch B. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check if `Route` is a subset of every path that ends with the parameter
    at the end Express-style (with a preceding `"/:"`). If so, we infer this string,
    which means we capture its contents into a new variable. If the condition is met,
    we return the newly extracted string; otherwise, we return `never`, as in: “there
    are no route parameters.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try it, we get something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s already much better than we did earlier. Now, we want to catch all other
    possible parameters. For that, we have to add another condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our conditional type now works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first condition, we check if there is a route parameter somewhere in
    between the route. If so, we extract both the route parameter and everything else
    that comes after. We return the newly found route parameter `P` in a union where
    we call the same generic type recursively with the rest `R`. For example, if we
    pass the route `"/api/users/:userID/orders/:orderID"` to `ParseRouteParams`, we
    infer `"userID"` into `P` and `"orders/:orderID"` into `R`. We call the same type
    with `R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is where the second condition comes in. Here we check if there is a type
    at the end. This is the case for `"orders/:orderID"`. We extract `"orderID"` and
    return this literal type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there are no more route parameters left, we return `never`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s apply this new type and see what our final usage of `app.get` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s it! Let’s recap. The types we just created for one function `app.get`
    make sure that we exclude a ton of possible errors:'
  prefs: []
  type: TYPE_NORMAL
- en: We can only pass proper numeric status codes to `res.status()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.method` is one of four possible strings, and when we use `app.get`, we
    know it can only be `"GET"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can parse route params and make sure we don’t have any typos inside our callback
    parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we look at the example from the beginning of this recipe, we get the following
    error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And all that before we actually run our code! Express-style servers are a perfect
    example of the dynamic nature of JavaScript. Depending on the method you call
    and the string you pass for the first argument, a lot of behavior changes inside
    the callback. Take another example and all your types look entirely different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The great thing about this approach is that every step added more type safety:'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily stop at basic types and get more out of it than having no types
    at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subsetting helps you get rid of typos by reducing the number of valid values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generics help you tailor behavior to use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced types like string template literal types give your app more meaning
    in a stringly-typed world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locking in generics allows you to work with literals in JavaScript and treat
    them as types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditional types make your types as flexible as your JavaScript code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best thing? Once you added your types, people will just write plain JavaScript
    and still get all the type information. That’s a win for everybody.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Checking Contracts with satisfies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to work with literal types but need an annotation type-check to make
    sure you fulfill a contract.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `satisfies` operator to do annotation-like type-checking while retaining
    the literal types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mapped types are great, as they allow for the flexibility in object structures
    JavaScript is known for. But they have some crucial implications for the type
    system. Take this example from a generic messaging library, which takes a “channel
    definition” where multiple channel tokens can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The keys from this channel definition object are what the user wants them to
    be. So this is a valid channel definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a problem, however: when we want to access the keys we defined so flexibly.
    Let’s say we have a function that opens a channel. We pass the whole channel definition
    object, as well as the channel we want to open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So what are the keys of `ChannelDefinition`? Well, it’s every key: `[key: string]`.
    So the moment we assign a specific type, TypeScript treats `impl` as this specific
    type, ignoring the actual implementation. The contract is fulfilled. Moving on.
    This allows for wrong keys to be passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So we are more interested in the actual implementation, not the type we assign
    to our constant. This means we have to get rid of the `ChannelDefinition` type
    and make sure we care about the actual type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `openChannel` function should take any object that is a subtype
    of `Ch⁠ann⁠el​De⁠fi⁠ni⁠tion` but work with the concrete subtype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript now works on two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks if `T` actually extends `ChannelDefinition`. If so, we work with type
    `T`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All our function parameters are typed with the generic `T`. This also means
    we get the *real* keys of `T` through `keyof T`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To benefit from that, we have to get rid of the type definition for `impl`.
    The explicit type definition overrides all actual types. From the moment we explicitly
    specify the type, TypeScript treats it as `ChannelDefinition`, not the actual
    underlying subtype. We also have to set *const context*, so we can convert all
    strings to their unit type (and thus be compliant with `Messages`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Without *const context*, the inferred type of `impl` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With *const context*, the actual type of `impl` is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Const context* allows us to satisfy the contract made by `ChannelDefinition`.
    Now `openChannel` works correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This works but comes with a caveat. The only point where we can check if `impl`
    is actually a valid subtype of `ChannelDefinition` is when we are using it. Sometimes
    we want to annotate early to figure out potential breaks in our contract. We want
    to see if this specific implementation *satisfies* a contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, there is a keyword for that. We can define objects and do a type-check
    to see if this implementation satisfies a type, but TypeScript will treat it as
    a literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we can make sure that we fulfill contracts but have the same benefits
    as with *const context*. The only difference is that the fields are not set to
    `readonly`, but since TypeScript takes the literal type of everything, there is
    no way to set fields to anything else after a satisfaction type-check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we get the best of both worlds: proper type-checks at annotation
    time as well as the power of narrowed types for specific situations.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Testing Complex Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have written very elaborate and complex types, and you want to make sure
    that they behave correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some commonly known helper types work like a test framework. Test your types!
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In dynamically typed programming languages people always circle around the discussion
    of if you need types when you can have a proper test suite. This is at least what
    one camp says; the other thinks, why should we test so much when we can have types?
    The answer is probably somewhere in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: It is true that types can solve a lot of test cases. Is the result a number?
    Is the result an object with certain properties of certain types? This is something
    we can easily check via types. Does my function produce correct results? Are the
    values what I expect them to be? This belongs to tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, we learned a lot about very complex types. With conditional
    types, we opened up the metaprogramming capabilities of TypeScript, where we could
    craft new types based on certain features of previous types. Powerful, Turing
    complete, and very advanced. This leads to the question: how do we ensure that
    those complex types actually do what they should do? Maybe we should *test our
    types*?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We actually can. There are a few helper types known within the community that
    can serve as some sort of testing framework. The following types come from the
    excellent [Type Challenges repository](https://tsch.js.org), which allows you
    to test your TypeScript type system skills to an extreme. They include very challenging
    tasks: some that have relevance to real-world use cases and others that are just
    for fun.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Their testing library starts with a few types that expect a truthy or a falsy
    value. They are pretty straightforward. By using generics and literal types, we
    can check if this one Boolean is true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'They don’t do much on their own but are fantastic when being used with `Equal<X,
    Y>` and `NotEqual<X, Y>`, which return either `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`Equal<X, Y>` is interesting as it creates generic functions and checks them
    against both types that should be compared with each other. Since there is no
    resolution on each conditional type, TypeScript compares both conditional types
    and can see if there is compatibility. It’s a step within TypeScript’s conditional
    type logic that is masterfully explained by [Alex Chashin on Stack Overflow](https://oreil.ly/ywWd4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next batch allows us to check if a type is `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It’s a simple conditional type that checks `0` against `1 & T`, which should
    always narrow down to `1` or `never`, which always yields the `false` branch of
    the conditional type. Except when we intersect with `any`. An intersection with
    `any` is always `any`, and `0` is a subset of `any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next batch is reinterpretations of `Remap` and `DeepRemap` we saw in [Recipe
    8.3](ch08.html#ch08_remapping), along with `Alike` as a way to compare types that
    are equal in structure but not construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Equal` check before should theoretically be able to understand that `{
    x : number, y: string }` is equal to `{ x: number } & { y: string }`, but implementation
    details of the TypeScript type-checker don’t see them as equal. That’s where `Alike`
    comes into play.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last batch of the type challenges testing file does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It does subset checks with a simple conditional type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It checks if a tuple you have constructed can be seen as a valid argument for
    a function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Having a small helper type library like this for type testing and debugging
    is really helpful when your types get more complex. Add them to your global type
    definition files (see [Recipe 9.7](ch09.html#ch09_augmenting_globals)) and use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5 Validating Data Types at Runtime with Zod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You rely on data from external sources and can’t trust them to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define schemas using a library called *Zod* and use it to validate data from
    external sources.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations! We’re almost at the end. If you have followed along from start
    to finish, you have been constantly reminded that TypeScript’s type system follows
    a couple of goals. First and foremost, it wants to give you excellent tooling
    so you can be productive when developing applications. It also wants to cater
    to all JavaScript frameworks and make sure they are fun and easy to use. It sees
    itself as an add-on to JavaScript, as a syntax for static types. There are also
    some non-goals or trade-offs. It prefers productivity over correctness, it allows
    developers to bend the rules to their needs, and it has no claim of being provably
    sound.
  prefs: []
  type: TYPE_NORMAL
- en: In [Recipe 3.9](ch03.html#ch03_item_assertions) we learned that we can influence
    TypeScript if we think that types should be something different through *type
    assertions*, and in [Recipe 9.2](ch09.html#ch09_unsafe_operations) we learned
    how we can make *unsafe operations* more robust and easier to spot. Since TypeScript’s
    type system is compile-time only, all our safeguards evaporate once we run JavaScript
    in our selected runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, compile-time type-checks are good enough. As long as we are within
    the *inner world* where we write our own types, let TypeScript check that everything
    is OK, and our code is good to go. In JavaScript applications, however, we also
    deal with a lot of things beyond our control: user input, for example. APIs from
    third parties that we need to access and process. Inevitably, we reach a point
    in our development process where we need to leave the boundaries of our well-typed
    application and deal with data that we can’t trust.'
  prefs: []
  type: TYPE_NORMAL
- en: While developing, working with external sources or user input might work well
    enough, but to make sure that the data we use stays the same when running in production
    requires extra effort. You may want to validate that your data adheres to a certain
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there are libraries that deal with that kind of task. One library
    that has gained popularity in recent years is [Zod](https://zod.dev). Zod is TypeScript-first,
    which means it makes sure not only that the data you consume is valid and what
    you expect but also that you get TypeScript types you can use throughout your
    program. Zod sees itself as the guard between the outer world outside of your
    control and the inner world where everything is well-typed and also type-checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of an API that gives you data for the `Person` type we’ve seen throughout
    the book. A `Person` has a name and age, a profession that is optional, and also
    a status: in our system, they can be either active, inactive, or only registered,
    waiting for confirmation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The API also packs a couple of `Person` objects in an array contained within
    a `Result` type. In short, it’s an example for a classic response type for HTTP
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You know how to type models like this. By now, you are fluent in recognizing
    and applying both syntax and patterns. We want to have the same type, but at runtime
    for data outside our control, we use Zod. And writing the same type in JavaScript
    (the value namespace) looks very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you see, we are in JavaScript, and we add names to the *value* namespace,
    not the *type* namespace (see [Recipe 2.9](ch02.html#ch02_item_namespaces)), but
    the tools we get from Zod’s fluent interface are very familiar to us TypeScript
    developers. We define objects, strings, numbers, and arrays. We can also define
    union types and literals. All the building blocks for defining models are here,
    and we can also nest types, as we see by defining `Person` first and reusing it
    in `Results`.
  prefs: []
  type: TYPE_NORMAL
- en: The fluent interface also allows us to make certain properties optional. All
    things that we know from TypeScript. Furthermore, we can set validation rules.
    We can say that age should be above or equal to 0 and below 100\. Things that
    we can’t do reasonably within the type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those objects are not types that we can use like we would use TypeScript types.
    They are *schemas*, waiting for data they can parse and validate. Since Zod is
    TypeScript-first, we have helper types that allow us to cross the bridge from
    the value space to the type space. With `z.infer` (a type, not a function), we
    can extract the type we defined through Zod’s schema functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how do we apply Zod’s validation techniques? Let’s talk about a function
    called `fetchData`, which calls an API that gets entries of type `ResultType`.
    We just don’t know if the values we receive actually adhere to the types we’ve
    defined. So, after fetching data as `json`, we use the `Results` schema to parse
    the data we’ve received. If this process is successful, we get data that is of
    type `ResultType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that we already had our first safeguard in how we defined the function
    interface. `Promise<ResultType>` is based on what we get from `z.infer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Results.parse(data)` is of the inferred type but without a name. The structural
    type system makes sure that we return the right thing. There might be errors,
    and we can `catch` them using the respective `Promise.catch` methods or `try`-`catch`
    blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage with `try`-`catch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'While we can ensure that we continue only if we have correct data, we are not
    forced to do error checking. If we want to make sure that we look at the parsing
    result first before we continue with our program, `safeParse` is the way to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This already makes Zod a valuable asset if you need to rely on external data.
    Furthermore, it allows you to adapt to API changes. Let’s say that your program
    can work only with active and inactive states of `Person`; it does not know how
    to handle `registered`. It’s easy to apply a transform where, based on the data
    you get, you modify the `"registered"` state to be actually `"active"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You then work with two different types: the *input* type represents what the
    API is giving you, and the *output* type is the data you have after parsing. Thankfully,
    we can get both types from the respective Zod helper types `z.input` and `z.output`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Zod’s typings are clever enough to understand that you removed one of the three
    literals from `status`. So there are no surprises and you actually deal with the
    data you’ve been expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zod’s API is elegant, easy to use, and closely aligned with TypeScript’s features.
    For data at the boundaries that you can’t control, where you need to rely on third
    parties to provide the expected shape of data, Zod is a lifesaver without you
    having to do too much work. It comes at a cost, though: runtime validation takes
    time. The bigger the dataset, the longer it takes. Also, at 12KB it’s big. Be
    certain that you need this kind of validation for data at your boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: If the data you request comes from some other team within your company, maybe
    the person sitting next to you, no library, not even Zod, beats talking with each
    other and collaborating toward the same goals. Types are a way to guide collaboration,
    not a means to get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 Working Around Index Access Restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When accessing an object’s property using index access, TypeScript complains
    that the type you want to assign is not assignable to `never`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript looks for the lowest common denominator of possible values. Use a
    generic type to lock in specific keys so TypeScript doesn’t assume the rule needs
    to apply for all.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes when writing TypeScript, actions you’d usually do in JavaScript work
    a little differently and cause some weird and puzzling situations. Sometimes you
    just want to assign a value to an object property via index access and get an
    error like “Type `'string | number'` is not assignable to type `'never'`. Type
    `'string'` is not assignable to type `'never'`.(2322).”
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t out of the ordinary; it’s just where “unexpected intersection types”
    make you think a little bit more about the type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at this example. We create a function that lets us update from one
    object `anotherPerson` to object `person` via providing a key. Both `person` and
    `an⁠oth⁠er​Pe⁠rs⁠on` have the same type `Person`, but TypeScript throws errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Property assignments via the index access operator are hard for TypeScript to
    track down. Even if you narrow all possible access keys via `keyof Person`, the
    possible values that can be assigned are `string` or `number` (for name and age,
    respectively). While this is fine if you have index access on the righthand side
    of a statement (reading), it gets a little interesting if you have index access
    on the lefthand side of a statement (writing).
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript can’t guarantee that the value you pass along is actually correct.
    Look at this function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Nothing prevents me from adding a falsely typed value to every key. Except for
    TypeScript, which throws an error. But why does TypeScript tell us the type is
    `never`?
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow for *some* assignments TypeScript compromises. Instead of not allowing
    *any* assignments at all on the righthand side, TypeScript looks for the lowest
    common denominator of possible values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, both keys are subsets of `number`. `address` is the entire set of numbers;
    `on` on the other side is either `0` or `1`. It’s absolutely possible to set `0`
    or `1` to both fields! And this is what you get with TypeScript as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript gets to the possible assignable values by doing an *intersection
    type* of all property types. In the case of the `Switch`, it’s `number & (0 |
    1)`, which boils down to `0 | 1`. In the case of all `Person` properties, it’s
    `string & number`, which has no overlap; therefore it’s `never`. Hah! There’s
    the culprit!
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to get around this strictness (which is for your own good) is by using
    generics. Instead of allowing all `keyof Person` values to access, we *bind* a
    specific subset of `keyof Person` to a generic variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When I `update("age")`, `K` is bound to the literal type of `"age"`. No ambiguity
    there!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a theoretical loophole since we could instantiate `update` with a
    much broader generic value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is something the TypeScript team allows, for now. See also [this comment](https://oreil.ly/0Fetp)
    by Anders Hejlsberg. Note that he asks to see use cases for such a scenario, which
    perfectly details how the TypeScript team works. The original assignment via index
    access on the righthand side has so much potential for error that they give you
    enough safeguards until you make it very intentional what you want to do. This
    is ruling out entire classes of errors without getting too much in the way.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7 Deciding Whether to Use Function Overloads or Conditional Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With conditional types, you have more possibilities to define function signatures
    than before. You wonder if you still need function overloads or if they’re obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function overloads provide better readability and an easier way to define expectations
    from your type than conditionals. Use them when the situation requires.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With type system features like conditional types or variadic tuple types, one
    technique to describe a function’s interface has faded into the background: function
    overloads. And for good reason. Both features have been implemented to deal with
    the shortcomings of regular function overloads.'
  prefs: []
  type: TYPE_NORMAL
- en: 'See this concatenation example directly from the TypeScript 4.0 release notes.
    This is an array `concat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To correctly type a function like this so it takes all possible edge cases
    into account, we would end up in a sea of overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And this only takes into account arrays that have up to six elements. Variadic
    tuple types help greatly with these situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The new function signature requires a lot less effort to parse and is very
    clear on what types it expects to get as arguments and what it returns. The return
    value also maps to the return type. No extra assertions: TypeScript can make sure
    that you are returning the correct value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a similar situation with conditional types. This example is very similar
    to [Recipe 5.1](ch05.html#ch05_function_signatures). Think of software that retrieves
    orders based on customer, article, or order ID. You might want to create something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is just half the truth. What if you end up with ambiguous types where
    you don’t know exactly if you get *only* a `Customer` or only a `Product`? You
    need to take care of all possible combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Add more possibilities, and you end up with more combinations. Here, conditional
    types can reduce your function signature tremendously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Since conditional types distribute a union, `FetchReturn` returns a union of
    return types.
  prefs: []
  type: TYPE_NORMAL
- en: 'So there is good reason to use those techniques instead of drowning in too
    many function overloads. So, to return to the question: do we still need function
    overloads?'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we do.
  prefs: []
  type: TYPE_NORMAL
- en: Different function shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One scenario where function overloads remain handy is if you have different
    argument lists for your function variants. This means not only the arguments (parameters)
    themselves can have some variety (this is where conditionals and variadic tuples
    are fantastic) but also the number and position of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a search function that has two different ways of being called:'
  prefs: []
  type: TYPE_NORMAL
- en: Call it with the search query. It returns a `Promise` you can await.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call it with the search query and a callback. In this scenario, the function
    does not return anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This *can* be done with conditional types but is very unwieldy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined our argument list using tuple types. Since TypeScript 4.0, we can
    name tuple fields just like we would objects. We create a union because we have
    two different variants of our function signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ReturnSearch` type selects the return type based on the argument list variant.
    If it’s just a string, return a `Promise`. Otherwise return `void`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add our types by constraining a generic variable to `SearchArguments` so
    that we can correctly select the return type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That is a lot! And it features a ton of complex features we love to see in
    TypeScript’s feature list: conditional types, generics, generic constraints, tuple
    types, union types! We get *some* nice autocomplete, but it’s nowhere near the
    clarity of a simple function overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We use a union type only for the implementation part. The rest is very explicit
    and clear. We know our arguments, and we know what to expect in return. No ceremony,
    just simple types. The best part of function overloads is that the *actual* implementation
    does not pollute the type space. You can go for a round of `any` and just not
    care.
  prefs: []
  type: TYPE_NORMAL
- en: Exact arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another situation where function overloads can make things easier is when you
    need exact arguments and their mapping. Let’s look at a function that applies
    an event to an event handler. For example, we have a `MouseEvent` and want to
    call a `Mo⁠use⁠Eve⁠nt​Ha⁠nd⁠ler` with it. Same for keyboard events and so on.
    If we use conditionals and union types to map event and handler, we might end
    up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this looks fine. It might be a bit cumbersome, though, if you
    think about all the variants you need to keep track of.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a bigger problem. The way TypeScript deals with all possible variants
    of the event is causing an *unexpected intersection*, as we see in [Recipe 12.6](#ch12_unexpected_intersections).
    This means that, in the function body, TypeScript can’t tell what kind of handler
    you are passing. Therefore, it also can’t tell which kind of event we’re getting.
    So TypeScript says the event can be both: a mouse event and a keyboard event.
    You need to pass handlers that can deal with both, which is not how we intend
    our function to work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual error message is “TS 2345: Argument of type `*Ke⁠ybo⁠ard⁠Eve⁠nt<H⁠TML⁠Bu⁠tt⁠on​El⁠em⁠en⁠t>
    | MouseEvent<HTMLButtonElement, MouseEvent>*` is not assignable to parameter of
    type `*Mo⁠us⁠eEv⁠ent⁠<HT⁠MLB⁠utt⁠onE⁠lem⁠ent⁠, Mo⁠use⁠Eve⁠nt> ⁠& Key⁠boa⁠rd ​Eve⁠nt<H⁠TML⁠But⁠ton⁠Ele⁠me⁠nt>*`.”'
  prefs: []
  type: TYPE_NORMAL
- en: This is why we need an `as any` type assertion to make it possible to actually
    call the handler with the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function signature works in a lot of scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'But once there’s ambiguity, things don’t work out as they should:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'When `mouseOrKeyboardHandler` is a keyboard handler, we can’t reasonably pass
    a mouse event. Wait: this is exactly what the TS2345 error from before tried to
    tell us! We just shifted the problem to another place and made it silent with
    an `as any` assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit, exact function signatures make *everything* easier. The mapping becomes
    clearer, the type signatures are easier to understand, and there’s no need for
    conditionals or unions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Function overloads help us with all possible scenarios. We make sure there
    are no ambiguous types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: For the implementation, we can even use `any`. Since you can make sure that
    you won’t run into a situation that implies ambiguity, you can rely on the happy-go-lucky
    type and don’t need to bother.
  prefs: []
  type: TYPE_NORMAL
- en: The catch-all function body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Last but not least, there’s the combination of conditional types *and* function
    overloads. Remember the example from [Recipe 5.1](ch05.html#ch05_function_signatures):
    we saw that conditional types gave the function body a hard time to map values
    to the respective generic return types. Moving the conditional type to a function
    overload and using a very broad function signature for implementation helps both
    the users of the function as well as the implementers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Function overloads are still very useful and, for a lot of scenarios, the way
    to go. They’re easier to read, easier to write, and, in a lot of cases, more exact
    than what we get with other means.
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not either-or. You can happily mix and match conditionals and function
    overloads if your scenario needs it.
  prefs: []
  type: TYPE_NORMAL
- en: 12.8 Naming Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`T` and `U` don’t tell you anything about generic type parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow a naming pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript’s generics are arguably one of the most powerful features of the
    language. They open a door to TypeScript’s own metaprogramming language, which
    allows for a very flexible and dynamic generation of types. It comes close to
    being its own functional programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Especially with the arrival of *string literal types* and *recursive conditional
    types* in the most recent TypeScript versions, we can craft types that do astonishing
    things. This type from [Recipe 12.2](#ch12_refining_types) parses Express-style
    from route information and retrieves an object with all its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define a *generic type*, we also define *generic type parameters*.
    They can be of a certain type (or more correctly, be a certain subtype):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'They can have default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: And when using default values, *order* is important. This is just one of many
    similarities to regular JavaScript functions! So since we are almost talking functions,
    why are we using single-letter names for generic type parameters?
  prefs: []
  type: TYPE_NORMAL
- en: Most generic type parameters start with the letter `T`. Subsequent parameters
    go along the alphabet (`U`, `V`, `W`) or are abbreviations like `K` for `key`.
    This can lead to highly unreadable types, however. If I look at `Extract<T, U>`,
    it is hard to tell if we extract `T` from `U`, or the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a bit more elaborate helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Now we know that we want to extract *from* the first parameter everything that
    is assignable to `Union`. Furthermore, we understand that we want to have a union
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types are documentation, and our type parameters can have speaking names, just
    like you would do with regular functions. Go for a naming scheme, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: All type parameters start with an uppercase letter, like you would name all
    other types!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only use single letters if the usage is completely clear. For example, `ParseRouteParams`
    can have only one argument, the route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t abbreviate to `T` (that’s way too …​ generic!) but to something that clarifies
    what we are dealing with. For example, `ParseRouteParams<R>`, where `R` stands
    for `Route`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rarely use single letters; stick to short words or abbreviations: `Elem` for
    `Element`, `Route` can stand as is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use prefixes to differentiate from built-in types. For example, `Element` is
    taken, so use `GElement` (or stick with `Elem`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use prefixes to make generic names clearer: `URLObj` is clearer than `Obj`,
    for instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same patterns apply to inferred types within a generic type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at `ParseRouteParams` again and be more explicit with our names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It becomes a lot clearer what each type is meant to be. We also see that we
    need to iterate over all `Entry`s in `Param`, even if `Param` is just a set of
    one type.
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, it’s a lot more readable than before!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one caveat: it’s almost impossible to distinguish type parameters
    from actual types. There’s another scheme that has been heavily popularized by
    [Matt Pocock](https://oreil.ly/Y1i-Q): using a `T` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This comes close to a [Hungarian Notation](https://oreil.ly/c23gW) for types.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever variation you use, making sure that generic types are readable to you
    and your colleagues, and that their parameters speak for themselves, is as important
    as in other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 12.9 Prototyping on the TypeScript Playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your project is so big, it’s hard for you to properly fix bugs in typings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Move your types to the TypeScript playground and develop them in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The TypeScript playground](https://www.typescriptlang.org/play) as shown in
    [Figure 12-1](#img-playground) is a web application that has been with TypeScript
    since its first release, showcasing how TypeScript syntax is compiled to JavaScript.
    Its capabilities were originally limited and focused on “breaking the ice” for
    new developers, but in recent years it has become a powerhouse of online development,
    rich in features and indispensable for TypeScript development. The TypeScript
    team asks people to submit issues including a re-creation of the bug using the
    playground. They also test new and upcoming features by allowing the nightly version
    to be loaded into the application. In short: the TypeScript playground is essential
    for TypeScript development.'
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 1201](assets/tscb_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. The TypeScript playground showing one of the built-in examples
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For your regular development practices, the TypeScript playground is a great
    way to develop types in isolation, independent from your current project. As TypeScript
    configurations grow, they become confusing, and it becomes hard to understand
    which types contribute to your actual project. If you encounter weird or unexpected
    behavior in your types, try re-creating them in the playground, in isolation,
    without the rest of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playground doesn’t feature a full *tsconfig.json*, but you can define the
    important pieces of your configuration via a user interface, as seen in [Figure 12-2](#img-tsconfig-panel).
    Alternatively, you can set compiler flags using annotations directly in the source
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Not as comfortable but highly ergonomic as it allows you to share compiler flags
    much more easily.
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 1202](assets/tscb_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Instead of writing an actual tsconfig.json, you set compiler flags
    using the TSConfig panel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You also can compile TypeScript, get extracted type information, run small pieces
    of code to see how they behave, and export everything to various destinations,
    including other popular online editors and IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: You can select various versions to ensure that your bug isn’t dependent on version
    updates, and you can run various, well-documented examples to learn the basics
    of TypeScript while trying out actual source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in [Recipe 12.10](#ch12_multiple_library_versions), developing JavaScript
    would be nothing without using dependencies. In the TypeScript playground, it’s
    possible to fetch type information for dependencies directly from NPM. If you
    import, for example, React within the TypeScript playground, the playground will
    try to acquire types:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it will look at the respective package on NPM and check if there are
    types defined or *.d.ts* files somewhere in its contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, it will check on NPM if Definitely Typed type information exists and
    will download the respective `@types` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is recursive, meaning that if some types require types from other packages,
    type acquisition will also go through the type dependencies. For some packages,
    you can even define which version to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here, `types` is set to `legacy`, which loads the respective legacy version
    from NPM.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more to the ecosystem. An important tool of the TypeScript playground
    is *Twoslash*. Twoslash is a markup format for TypeScript files that lets you
    highlight code, handle multiple files, and show the files the TypeScript compiler
    creates. It’s fantastic for blogs and websites—you basically have an inline TypeScript
    compiler for code examples—but it’s also fantastic if you need to create complex
    debugging scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler flag annotations are handled by Twoslash, but you can also get
    inline hints on current types by adding a marker in a comment directly under a
    variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You can see the result in [Figure 12-3](#img-twoslash).
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 1203](assets/tscb_1203.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3\. Twoslash in action: setting compiler flags via annotations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Twoslash is also part of the [bug workbench](https://oreil.ly/jVU3u), which
    is a fork of the playground with an emphasis on creating and displaying complex
    reproductions of bugs. Here, you can also define multiple files to see how imports
    and exports work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Multifile support is triggered by the first `@filename` annotation. Everything
    before this line becomes a file called *input.tsx*, basically your main entry
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the playground can work as your entire demo suite for workshops
    and trainings. Using Twoslash, you can create multiple files in a GitHub Gist
    repository and load the TypeScript files along with documentation as part of a
    Gist docset, as seen in [Figure 12-4](#img-docsets).
  prefs: []
  type: TYPE_NORMAL
- en: This is immensely powerful for immersive learning. From mere reproductions to
    full-fledged demo suites, the TypeScript playground is the one-stop source for
    TypeScript developers—whether you need to file bugs, try out something new, or
    work on types in isolation. It’s a great resource to start with, and from there
    you can easily migrate to “real” IDEs and tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 1204](assets/tscb_1204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4\. A Gist docset in the playground
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 12.10 Providing Multiple Library Versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You write external types for a library and want to maintain type updates relative
    to library version updates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use reference triple-slash directives, as well as modules, namespaces, and interfaces
    for declaration merging.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programming would be tough without external libraries that take care of a lot
    of work for you. JavaScript’s ecosystem is arguably one of the richest when it
    comes to third-party dependencies, mainly through [NPM](https://npmjs.org). Also,
    most of them come with TypeScript support, either through built-in types or through
    types from Definitely Typed. According to the TypeScript team, almost [80% of
    NPM is typed](https://oreil.ly/G2Ktl). However, there is still the odd holdout:
    for example, libraries are not written in TypeScript, or legacy code from your
    own company that you still need to make compatible with today’s software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a library called *“lib”*, which exposes a `Connector` class that you
    can use to target internal systems. This library exists in multiple versions,
    and features have been added constantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth noting that this library can be used by multiple projects within
    your organization, with varying versions. Your task is to write types so your
    teams get proper autocomplete and type information.
  prefs: []
  type: TYPE_NORMAL
- en: In TypeScript, you can provide multiple versions of a library’s types by creating
    an ambient module declaration for each version of the library. An ambient module
    declaration is a file with a *.d.ts* extension that provides TypeScript with the
    types for a library not written in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, TypeScript is greedy: it includes type definitions and *globs*
    everything it can. If you want to limit TypeScript’s file access, make sure to
    use the `"exclude"` and `"include"` properties in *tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a folder *next to* the folders we included in *tsconfig.json*. Here,
    we create a file called *lib.v1.d.ts*, where we store the basic information on
    how objects are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use modules to define the name of the module and that we also use
    interfaces for most of our types. Both modules and interfaces are open to declaration
    merging, which means we can add new types in different files and TypeScript merges
    them together. This is crucial if we want to define multiple versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that we use the constructor interface pattern (see [Recipe 11.3](ch11.html#ch11_constructor_interfaace))
    for `Connector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In doing so, we can change the signature of the constructor and make sure that
    an instantiable class is being recognized by TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another file called *lib.v2.d.ts*, next to *lib.v1.d.ts*, we redeclare `"lib"`
    and add more methods to `Connection`. Through declaration merging, the `close`
    method gets added to the `Connection` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Using triple-slash directives, we refer from *lib.v2.d.ts* to *lib.v1.d.ts*,
    signaling that everything from version 1 is to be included in version 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'All those files exist in a folder called *@lib*. Using the configuration we
    declared earlier, TypeScript won’t pick them up. We can, however, write a new
    file *lib.d.ts* and put it in *@types*, and from there, refer to the version we
    want to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: A simple change from *“../@lib/lib.v2.d.ts”* to *“../@lib/lib.v1.d.ts”* will
    change the version we target, while we still maintain all library versions independently.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious, try looking into the included library files from TypeScript.
    They are a treasure trove of external type definitions, and there is a lot to
    learn. If you use your editor to find references, for example, to `Object.keys`,
    you will see that this function exists in multiple locations, and based on your
    TypeScript configuration, the right file will be included. [Figure 12-5](#img-object-keys)
    shows how Visual Studio Code displays various file locations for `Object.keys`.
    TypeScript is so flexible that you can use the same techniques for your project,
    even extending TypeScript’s built-in types themselves (see [Recipe 9.7](ch09.html#ch09_augmenting_globals)).
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 1205](assets/tscb_1205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5\. Finding references to built-in types in Visual Studio Code shows
    you how TypeScript manages multiple versions of ECMAScript and the DOM
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In conclusion, providing multiple versions of a library’s types in TypeScript
    can be done by creating ambient module declarations for each version of the library
    and referencing the appropriate declaration in your TypeScript code. Hopefully,
    you will be able to use package managers in your project to manage different versions
    of libraries and their corresponding types, making it easier to handle dependencies
    and avoid conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 12.11 Knowing When to Stop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing elaborate and complicated types is exhausting!
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t write elaborate and complicated types. TypeScript is gradual; use what
    makes you productive.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I want to end this book with some general advice on how to stop at the right
    time. If you have read through the entire book and ended up here, you have read
    through more than one hundred recipes with a lot of advice about everyday TypeScript
    problems. Be it project setup, complicated situations where you need to find the
    right type, or workarounds when TypeScript runs into a situation where it’s too
    strict for its own good, we have covered it all.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions can get very complex, especially when we enter the area of conditional
    types and everything around them, like helper types, variadic tuple types, and
    string template literal types. TypeScript’s type system is undoubtedly powerful,
    especially if you understand that every decision, every feature, has its roots
    in the fact that JavaScript lies underneath it all. Creating a type system that
    gives you strong, static types for a programming language that is so inherently
    dynamic is an amazing achievement. I have nothing but the deepest admiration for
    the bright minds in Redmond who made all of this possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, undeniably, things can get very complicated at times. Types can be
    hard to read or create, and the fact that the type system is its own Turing-complete
    meta-programming system that needs testing libraries doesn’t help. And developers
    take pride in understanding every aspect of their craft and tools, often preferring
    a complex type solution over simpler types that don’t give the same type safety
    but are ultimately easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: A project that goes into the nitty-gritty of the type system is called [Type
    Challenges](https://tsch.js.org). It’s a fantastic project of brainteasers that
    show what’s possible with the type system. I fiddle around with some of the more
    challenging riddles, getting great ideas for how to explain the type system better.
    And while puzzles are fantastic for training a developer’s mind, most of them
    lack a significant grasp of real-world, everyday situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'And those are the situations where we often overlook TypeScript’s wonderful
    capability that you don’t often see in mainstream programming languages: its gradual
    adoption of types. Tools like `any`, generic type parameters, and type assertions
    and the fact that you can write simple JavaScript with a couple of comments make
    the barrier to entry so much lower. The latest effort from the TypeScript team
    and TC39 is to lower the barrier even more by adding [type annotations to JavaScript](https://oreil.ly/yQnIO),
    a proposal currently in discussion. The goal of this proposal is not to make JavaScript
    type safe but to remove compile steps if we want to have simple, easy-to-understand
    type annotations. JavaScript engines can treat them as comments, and type-checkers
    can get real information on the program’s semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As developers, project leaders, engineers, and architects, we should use this
    feature. Simple types are always better types: easier to understand and much easier
    to consume.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [TypeScript website](https://typescriptlang.org) changed its claim from
    “JavaScript that scales” to “JavaScript with syntax for types,” which should give
    you an idea of how to approach TypeScript in projects: write JavaScript, annotate
    where necessary, write simple but comprehensive types, and use TypeScript as a
    way to document, understand, and communicate your software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I think TypeScript follows the [Pareto principle](https://oreil.ly/smytJ):
    80% of type safety comes from 20% of its features. This doesn’t mean the rest
    of it is bad or unnecessary. We just spent one hundred recipes to understand situations
    where we effectively need TypeScript’s more advanced features. It should just
    give you an idea of where to put effort. Don’t run into advanced TypeScript trickery
    on every occasion. Monitor if loser types are a problem. Estimate the effort to
    change types in your program, and make well-informed decisions. Also know that
    in a refinement process (see [Recipe 12.2](#ch12_refining_types)), the reason
    for multiple steps is to easily be able to stop.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch12.html#id971-marker)) Fluent interfaces allow for chainable operations
    by returning the instance with every method call.
  prefs: []
  type: TYPE_NORMAL
