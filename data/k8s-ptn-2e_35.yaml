- en: Chapter 28\. Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operator is a controller that uses a CRD to encapsulate operational knowledge
    for a specific application in an algorithmic and automated form. The *Operator*
    pattern allows us to extend the *Controller* pattern from the preceding chapter
    for more flexibility and greater expressiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned in [Chapter 27, “Controller”](ch27.html#Controller), how to extend
    the Kubernetes platform in a simple and decoupled way. However, for extended use
    cases, plain custom controllers are not powerful enough, as they are limited to
    watching and managing Kubernetes intrinsic resources only. Moreover, sometimes
    we want to add new concepts to the Kubernetes platform, which requires additional
    domain objects. For example, let’s say we chose Prometheus as our monitoring solution
    and want to add it as a monitoring facility to Kubernetes in a well-defined way.
    Wouldn’t it be wonderful to have a Prometheus resource describing our monitoring
    setup and all the deployment details, similar to how we define other Kubernetes
    resources? Moreover, could we have resources relating to services we have to monitor
    (e.g., with a label selector)?
  prefs: []
  type: TYPE_NORMAL
- en: These situations are precisely the kind of use cases where CustomResourceDefinition
    (CRD) resources are very helpful. They allow extensions of the Kubernetes API,
    by adding custom resources to your Kubernetes cluster and using them as if they
    were native resources. Custom resources, together with a controller acting on
    these resources, form the *Operator* pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'This [quote by Jimmy Zelinskie](https://oreil.ly/bFEU-) probably describes
    the characteristics of operators best:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An operator is a Kubernetes controller that understands two domains: Kubernetes
    and something else. By combining knowledge of both areas, it can automate tasks
    that usually require a human operator that understands both domains.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in [Chapter 27, “Controller”](ch27.html#Controller), we can efficiently
    react to state changes of default Kubernetes resources. Now that you understand
    one half of the *Operator* pattern, let’s have a look at the other half—representing
    custom resources on Kubernetes using CRD resources.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Resource Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a CRD, we can extend Kubernetes to manage our domain concepts on the Kubernetes
    platform. Custom resources are managed like any other resource, through the Kubernetes
    API, and are eventually stored in the backend store etcd.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding scenario is actually implemented with these new custom resources
    by the CoreOS Prometheus operator to allow seamless integration of Prometheus
    to Kubernetes. The Prometheus CRD is defined in [Example 28-1](#ex-operator-crd),
    which also explains most of the available fields for a CRD.
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-1\. CustomResourceDefinition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_operator_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: API group it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_operator_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Kind used to identify instances of this resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_operator_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Naming rule for creating the plural form, used for specifying a list of those
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_operator_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Scope—whether the resource can be created cluster-wide or is specific to a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_operator_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Versions available for this CRD.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_operator_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of a supported version.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_operator_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Exactly one version has to be the storage version used for storing the definition
    in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_operator_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Whether this version is served via the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_operator_CO1-10)'
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI V3 schema for validation (not shown here).
  prefs: []
  type: TYPE_NORMAL
- en: An OpenAPI V3 schema can also be specified to allow Kubernetes to validate a
    custom resource. For simple use cases, this schema can be omitted, but for production-grade
    CRDs, the schema should be provided so that configuration errors can be detected
    early.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Kubernetes allows us to specify two possible subresources for
    our CRD via the spec field `subresources`:^([1](ch28.html#idm45902082939568))
  prefs: []
  type: TYPE_NORMAL
- en: scale
  prefs: []
  type: TYPE_NORMAL
- en: 'With this property, a CRD can specify how it manages its replica count. This
    field can be used to declare the JSON path, where the number of desired replicas
    of this custom resource is specified: the path to the property that holds the
    actual number of running replicas and an optional path to a label selector that
    can be used to find copies of custom resource instances. This label selector is
    usually optional but is required if you want to use this custom resource with
    the HorizontalPodAutoscaler explained in [Chapter 29, “Elastic Scale”](ch29.html#ElasticScale).'
  prefs: []
  type: TYPE_NORMAL
- en: status
  prefs: []
  type: TYPE_NORMAL
- en: When this property is set, a new API call becomes available that allows you
    to update only the `status` field of a resource. This API call can be secured
    individually and allows the operator to reflect the *actual* status of the resource,
    which might differ from the *declared* state in the `spec` field. When a custom
    resource is updated as a whole, any sent `status` section is ignored, as is the
    case with standard Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 28-2](#ex-operator-crd-subresource) shows a potential subresource
    path as is also used for a regular Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-2\. Subresource definition for a CustomResourceDefinition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: JSON path to the number of declared replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_operator_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: JSON path to the number of active replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_operator_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: JSON path to a label selector to query for the number of active replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Once we define a CRD, we can easily create such a resource, as shown in [Example 28-3](#ex-operator-cr-example).
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-3\. A Prometheus custom resource
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `metadata` section has the same format and validation rules as any other
    Kubernetes resource. The `spec` contains the CRD-specific content, and Kubernetes
    validates against the given validation rule from the CRD.
  prefs: []
  type: TYPE_NORMAL
- en: Custom resources alone are not of much use without an active component to act
    on them. To give them some meaning, we need again our well-known controller, which
    watches the lifecycle of these resources and acts according to the declarations
    found within the resources.
  prefs: []
  type: TYPE_NORMAL
- en: Controller and Operator Classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into writing our operator, let’s look at a few kinds of classifications
    for controllers, operators, and especially CRDs. Based on the operator’s action,
    broadly, the classifications are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation CRDs
  prefs: []
  type: TYPE_NORMAL
- en: Meant for installing and operating applications on the Kubernetes platform.
    Typical examples are the Prometheus CRDs, which we can use for installing and
    managing Prometheus itself.
  prefs: []
  type: TYPE_NORMAL
- en: Application CRDs
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, these are used to represent an application-specific domain concept.
    This kind of CRD allows applications deep integration with Kubernetes, which involves
    combining Kubernetes with an application-specific domain behavior. For example,
    the ServiceMonitor CRD is used by the Prometheus operator to register specific
    Kubernetes Services to be scraped by a Prometheus server. The Prometheus operator
    takes care of adapting the Prometheus server configuration accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that an operator can act on different kinds of CRDs as the Prometheus operator
    does in this case. The boundary between these two categories of CRDs is blurry.
  prefs: []
  type: TYPE_NORMAL
- en: In our categorization of controller and operator, an operator is-a controller
    that uses CRDs.^([2](ch28.html#idm45902082785568)) However, even this distinction
    is a bit fuzzy as there are variations in between.
  prefs: []
  type: TYPE_NORMAL
- en: One example is a controller, which uses a ConfigMap as a kind of replacement
    for a CRD. This approach makes sense in scenarios where default Kubernetes resources
    are not enough but creating CRDs is not feasible either. In this case, ConfigMap
    is an excellent middle ground, allowing encapsulation of domain logic within the
    content of a ConfigMap. An advantage of using a plain ConfigMap is that you don’t
    need to have the cluster-admin rights you need when registering a CRD. In certain
    cluster setups, it is just not possible for you to register such a CRD (e.g.,
    when running on public clusters like OpenShift Online).
  prefs: []
  type: TYPE_NORMAL
- en: However, you can still use the concept of *Observe-Analyze-Act* when you replace
    a CRD with a plain ConfigMap that you use as your domain-specific configuration.
    The drawback is that you don’t get essential tool support like `kubectl get` for
    CRDs; you have no validation on the API Server level and no support for API versioning.
    Also, you don’t have much influence on how you model the `status` field of a ConfigMap,
    whereas for a CRD, you are free to define your status model as you wish.^([3](ch28.html#idm45902082739712))
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of CRDs is that you have a fine-grained permission model based
    on the kind of CRD, which you can tune individually, as is explained in [Chapter 26,
    “Access Control”](ch26.html#AccessControl). This kind of RBAC security is not
    possible when all your domain configuration is encapsulated in ConfigMaps, as
    all ConfigMaps in a namespace share the same permission setup.
  prefs: []
  type: TYPE_NORMAL
- en: From an implementation point of view, it matters whether we implement a controller
    by restricting its usage to vanilla Kubernetes objects or whether we have custom
    resources managed by the controller. In the former case, we already have all types
    available in the Kubernetes client library of our choice. For the CRD case, we
    don’t have the type information out of the box, and we can either use a schemaless
    approach for managing CRD resources or define the custom types on our own, possibly
    based on an OpenAPI schema contained in the CRD definition. Support for typed
    CRDs varies by client library and framework used.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 28-1](#img-operator-spectrum) shows our controller and operator categorization
    starting from simpler resource definition options to more advanced with the boundary
    between controller and operator being the use of custom resources.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spectrum of controllers and operators](assets/kup2_2801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-1\. Spectrum of controllers and operators
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For operators, there is even a more advanced Kubernetes extension hook option.
    When Kubernetes-managed CRDs are not sufficient to represent a problem domain,
    you can extend the Kubernetes API with its own aggregation layer. We can add a
    custom-implemented `APIService` resource as a new URL path to the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: To connect a Service that is backed by a Pod with the `APIService`, you can
    use a resource like that shown in [Example 28-4](#ex-operator-api-service).
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-4\. API aggregation with a custom APIService
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Besides the Service and Pod implementation, we need some additional security
    configuration for setting up the ServiceAccount under which the Pod is running.
  prefs: []
  type: TYPE_NORMAL
- en: After it is set up, every request to the API Server `https://<api server ip>/apis/sample-api.k8spatterns.io/v1alpha1/namespaces/<ns>/...`
    is directed to our custom Service implementation. It’s up to this custom Service
    implementation to handle these requests, including persisting the resources managed
    via this API. This approach is different from the preceding CRD case, where Kubernetes
    itself completely manages the custom resources.
  prefs: []
  type: TYPE_NORMAL
- en: With a custom API Server, you have many more degrees of freedom, which allows
    you to go beyond watching resource lifecycle events. On the other hand, you also
    have to implement much more logic, so for typical use cases, an operator dealing
    with plain CRDs is often good enough.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed exploration of the API Server capabilities is beyond the scope of
    this chapter. The [official documentation](https://oreil.ly/eCcU9) as well as
    a complete [sample-apiserver](https://oreil.ly/qPCX7) have more detailed information.
    Also, you can use the [apiserver-builder](https://oreil.ly/G_qud) library, which
    helps with implementing API Server aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how you can develop and deploy operators with CRDs.
  prefs: []
  type: TYPE_NORMAL
- en: Operator Development and Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several toolkits and frameworks are available for developing operators. The
    three main projects aiding in the creation of operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubebuilder developed under the SIG API Machinery of Kubernetes itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator Framework, a CNCF project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metacontroller from Google Cloud Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We touch on each of these very briefly to give you a good starting point for
    developing and maintaining your own Operators.
  prefs: []
  type: TYPE_NORMAL
- en: Kubebuilder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Kubebuilder*, a project by the SIG API Machinery,^([4](ch28.html#idm45902082690816))
    is a framework and library for creating Kubernetes APIs via CustomResourceDefinitions.'
  prefs: []
  type: TYPE_NORMAL
- en: It comes with outstanding [documentation](https://oreil.ly/cmYBo) that also
    covers general aspects for programming Kubernetes. Kubebuilder’s focus is on creating
    Golang-based operators by adding higher-level abstractions on top of the Kubernetes
    API to remove some of the overhead. It also offers scaffolding of new projects
    and supports multiple CRDs that can be watched by a single operator. Other projects
    can consume Kubebuilder as a library, and it also offers a plugin architecture
    to extend the support to languages and platforms beyond Golang. For programming
    against the Kubernetes API, Kubebuilder is an excellent starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Operator framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Operator Framework provides extensive support for developing operators.
    It offers several subcomponents:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Operator SDK* provides a high-level API for accessing a Kubernetes cluster
    and a scaffolding to start an operator project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Operator Lifecycle Manager* manages the release and updates of operators
    and their CRDs. You can think of it as a kind of “operator operator.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Operator Hub* is a publicly available catalog of operators dedicated to sharing
    operators built by the community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the first edition of this book in 2019, we mentioned the high feature overlap
    of Kubebuilder and the Operator-SDK, and we speculated that both projects might
    eventually merge. It turned out that instead of a full merge, a different strategy
    was chosen by the community: all the overlapping parts have been moved to Kubebuilder,
    and the Operator-SDK uses Kubebuilder now as a dependency. This move is a good
    example of the power and self-healing effect of community-driven open source projects.
    The [article](https://oreil.ly/0GM5e) “What Are the Differences Between Kubebuilder
    and Operator-SDK?” contains more information about the relationship between Kubebuilder
    and the Operator-SDK. The *Operator-SDK* offers everything needed for developing
    and maintaining Kubernetes operators. It is built on top of Kubebuilder and uses
    it directly for scaffolding and managing operators written in Golang. Beyond that,
    it benefits from Kubebuilder’s plugin system for creating operators based on other
    technologies. As of 2023, the Operator-SDK provides plugins for creating operators
    based on Ansible playbooks or Helm Charts and Java-based operators that use a
    Quarkus runtime. When scaffolding a project, the SDK also adds the appropriate
    hooks for integration with the Operator Lifecycle Manager and the Operator Hub.'
  prefs: []
  type: TYPE_NORMAL
- en: The *Operator Lifecycle Manager* (OLM) provides valuable help when using operators.
    One issue with CRDs is that these resources can be registered only cluster-wide
    and require cluster-admin permissions. While regular Kubernetes users can typically
    manage all aspects of the namespaces they have granted access to, they can’t just
    use operators without interaction with a cluster administrator.
  prefs: []
  type: TYPE_NORMAL
- en: To streamline this interaction, the OLM is a cluster service running in the
    background under a service account with permission to install CRDs. A dedicated
    CRD called ClusterServiceVersion (CSV) is registered along with the OLM and allows
    us to specify the Deployment of an operator together with references to the CRD
    definitions associated with this operator. As soon as we have created such a CSV,
    one part of the OLM waits for that CRD and all its dependent CRDs to be registered.
    If this is the case, the OLM deploys the operator specified in the CSV. Then,
    another part of the OLM can be used to register these CRDs on behalf of a nonprivileged
    user. This approach is an elegant way to allow regular cluster users to install
    their operators.
  prefs: []
  type: TYPE_NORMAL
- en: Operators can be easily published at the [Operator Hub](https://oreil.ly/K2t68).
    Operator Hub makes it easy to discover and install operators. The metadata-like
    name, icon, description, and more is extracted from the operator’s CSV and rendered
    in a friendly web UI. Operator Hub also introduces the concept of *channels* that
    allow you to provide different streams like “stable” or “alpha,” to which users
    can subscribe for automatic updates of various maturity levels.
  prefs: []
  type: TYPE_NORMAL
- en: Metacontroller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Metacontroller is very different from the other two operator building frameworks
    as it extends Kubernetes with APIs that encapsulate the common parts of writing
    custom controllers. It acts similarly to Kubernetes Controller Manager by running
    multiple controllers that are not hardcoded but are defined dynamically through
    Metacontroller-specific CRDs. In other words, it’s a delegating controller that
    calls out to the service providing the actual controller logic.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to describe Metacontroller is as declarative behavior. While CRDs
    allow us to store new types in Kubernetes APIs, Metacontroller makes it easy to
    define the behavior for standard or custom resources declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: When we define a controller through Metacontroller, we have to provide a function
    that contains only the business logic specific to our controller. Metacontroller
    handles all interactions with the Kubernetes APIs, runs a reconciliation loop
    on our behalf, and calls our function through a webhook. The webhook gets called
    with a well-defined payload describing the CRD event. As the function returns
    the value, we return a definition of the Kubernetes resources that should be created
    (or deleted) on behalf of our controller function.
  prefs: []
  type: TYPE_NORMAL
- en: This delegation allows us to write functions in any language that can understand
    HTTP and JSON and that do not have any dependency on the Kubernetes API or its
    client libraries. The functions can be hosted on Kubernetes, or externally on
    a Functions-as-a-Service provider, or somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot go into many details here, but if your use case involves extending
    and customizing Kubernetes with simple automation or orchestration, and you don’t
    need any extra functionality, you should have a look at Metacontroller, especially
    when you want to implement your business logic in a language other than Go. Some
    controller examples will demonstrate how to implement StatefulSet, Blue-Green
    Deployment, Indexed Job, and Service per Pod by using Metacontroller only.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at a concrete operator example. We extend our example in [Chapter 27,
    “Controller”](ch27.html#Controller), and introduce a CRD of the type ConfigWatcher.
    An instance of this CRD then specifies a reference to the ConfigMap to watch and
    specifies which Pods to restart if this ConfigMap changes. With this approach,
    we remove the dependency of the ConfigMap on the Pods, as we don’t have to modify
    the ConfigMap itself to add triggering annotations. Also, with our simple annotation-based
    approach in the Controller example, we can connect only a ConfigMap to a single
    application too. With a CRD, arbitrary combinations of ConfigMaps and Pods are
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: This ConfigWatcher custom resource is shown in [Example 28-5](#ex-operator-cr-config-watcher).
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-5\. Simple ConfigWatcher resource
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to ConfigMap to watch.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_operator_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Label selector to determine Pods to restart.
  prefs: []
  type: TYPE_NORMAL
- en: In this definition, the attribute `configMap` references the name of the `ConfigMap`
    to watch. The field `podSelector` is a collection of labels and their values,
    which identify the Pods to restart.
  prefs: []
  type: TYPE_NORMAL
- en: We define the type of this custom resource with a CRD (shown in [Example 28-6](#ex-operator-crd-config-watcher)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-6\. ConfigWatcher CRD
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Connected to a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_operator_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated API group.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_operator_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Unique kind of this CRD.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_operator_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Labels of the resource as used in tools like `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_operator_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Initial version.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_operator_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI V3 schema specification for this CRD.
  prefs: []
  type: TYPE_NORMAL
- en: For our operator to be able to manage custom resources of this type, we need
    to attach a ServiceAccount with the proper permissions to our operator’s Deployment.
    For this task, we introduce a dedicated Role used later in a RoleBinding to attach
    it to the ServiceAccount in [Example 28-7](#ex-operator-role). We explain the
    concept and usage of ServiceAccounts, Roles, and RoleBindings in much more details
    in [Chapter 26, “Access Control”](ch26.html#AccessControl). For now, it is sufficient
    to know that the Role definition in [Example 28-6](#ex-operator-crd-config-watcher)
    grants permission for all API operations to any instance of ConfigWatcher resources.
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-7\. Role definition allowing access to custom resource
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these CRDs in place, we can now define custom resources as in [Example 28-5](#ex-operator-cr-config-watcher).
  prefs: []
  type: TYPE_NORMAL
- en: To make sense of these resources, we have to implement a controller that evaluates
    these resources and triggers a Pod restart when the ConfigMap changes.
  prefs: []
  type: TYPE_NORMAL
- en: We expand here on our controller script in [Example 27-2](ch27.html#ex-controller-script)
    and adapt the event loop in the controller script.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a ConfigMap update, instead of checking for a specific annotation,
    we do a query on all resources of the kind ConfigWatcher and check whether the
    modified ConfigMap is included as a `configMap` value. [Example 28-8](#ex-operator-watch-config-controller-script)
    shows the reconciliation loop. Refer to our Git repository for the full example,
    which also includes detailed instructions for installing this operator.
  prefs: []
  type: TYPE_NORMAL
- en: Example 28-8\. WatchConfig controller reconciliation loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Start a watch stream to watch for ConfigMap changes for a given namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_operator_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Check for a `MODIFIED` event only.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_operator_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of all installed ConfigWatcher custom resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_operator_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Extract from this list all ConfigWatcher elements that refer to this ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_operator_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: For every ConfigWatcher found, delete the configured Pod via a selector. The
    logic for calculating a label selector as well as the deletion of the Pods are
    omitted here for clarity. Refer to the example code in our Git repository for
    the full implementation.
  prefs: []
  type: TYPE_NORMAL
- en: As for the controller example, this controller can be tested with a sample web
    application that is provided in our example Git repository. The only difference
    with this Deployment is that we use an unannotated ConfigMap for the application
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Although our operator is quite functional, it is also clear that our shell script-based
    operator is still quite simple and doesn’t cover edge or error cases. You can
    find many more interesting, production-grade examples in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: The canonical place to find real-world operators is [Operator Hub](https://oreil.ly/K2t68).
    The operators in this catalog are all based on the concepts covered in this chapter.
    We have already seen how a Prometheus operator can manage Prometheus installations.
    Another Golang-based operator is the etcd operator for managing an etcd key-value
    store and automating operational tasks like backing up and restoring the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for an operator written in the Java programming language,
    the [*Strimzi Operator*](https://oreil.ly/S1olv) is an excellent example of an
    operator that manages a complex messaging system like Apache Kafka on Kubernetes.
    Another good starting point for Java-based operators is the *Java Operator Plugin*,
    part of the Operator-SDK. As of 2023, it is still a young initiative; the best
    entry point for learning more about creating Java-based operators is the [tutorial](https://oreil.ly/pEPen)
    that explains the process to create a fully working operator.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have learned how to extend the Kubernetes platform, operators are still
    not a silver bullet. Before using an operator, you should carefully look at your
    use case to determine whether it fits the Kubernetes paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, a plain controller working with standard resources is good enough.
    This approach has the advantage that it doesn’t need any cluster-admin permission
    to register a CRD, but it has its limitations when it comes to security and validation.
  prefs: []
  type: TYPE_NORMAL
- en: An operator is a good fit for modeling a custom domain logic that fits nicely
    with the declarative Kubernetes way of handling resources with reactive controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, consider using an operator with CRDs for your application
    domain for any of the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: You want tight integration into the already-existing Kubernetes tooling like
    `kubectl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are working on a greenfield project where you can design the application
    from the ground up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You benefit from Kubernetes concepts like resource paths, API groups, API versioning,
    and especially namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to have good client support for accessing the API with watches, authentication,
    role-based authorization, and selectors for metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your custom use case fits these criteria, but you need more flexibility in
    how custom resources can be implemented and persisted, consider using a custom
    API Server. However, you should also not consider Kubernetes extension points
    as the golden hammer for everything.
  prefs: []
  type: TYPE_NORMAL
- en: If your use case is not declarative, if the data to manage does not fit into
    the Kubernetes resource model, or you don’t need a tight integration into the
    platform, you are probably better off writing your standalone API and exposing
    it with a classical Service or Ingress object.
  prefs: []
  type: TYPE_NORMAL
- en: The [Kubernetes documentation](https://oreil.ly/WdqWi) itself also has a chapter
    for suggestions on when to use a controller, operator, API aggregation, or custom
    API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Operator Example](https://oreil.ly/iN2B4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenAPI V3](https://oreil.ly/aIGNA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubebuilder](https://oreil.ly/GeHKy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Operator Framework](https://oreil.ly/5JWcN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Metacontroller](https://oreil.ly/etanj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Client Libraries](https://oreil.ly/1iiab)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Extend the Kubernetes API with CustomResourceDefinitions](https://oreil.ly/8ungP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Custom Resources](https://oreil.ly/0xhlw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sample-Controller](https://oreil.ly/kyIsL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Are Red Hat OpenShift Operators?](https://oreil.ly/voY92)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch28.html#idm45902082939568-marker)) Kubernetes subresources are additional
    API endpoints that provide further functionality within a resource type.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch28.html#idm45902082785568-marker)) [is-a](https://oreil.ly/hZykR) emphasizes
    the inheritance relationship between operator and controller, that an operator
    has all characteristics of a controller plus a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch28.html#idm45902082739712-marker)) However, you should be aware of common
    [API conventions](https://oreil.ly/klv65) for `status` and other fields when designing
    your CRDs. Following common community conventions makes it easier for people and
    tooling to read your new API objects.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch28.html#idm45902082690816-marker)) Special Interest Groups (SIGs) are
    how the Kubernetes community organizes feature areas. You can find a list of current
    SIGs on the [Kubernetes community site](https://oreil.ly/q6qd9).
  prefs: []
  type: TYPE_NORMAL
