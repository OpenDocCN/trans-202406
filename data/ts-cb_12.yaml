- en: Chapter 11\. Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When TypeScript was released for the very first time in 2012, the JavaScript
    ecosystem and the features of the JavaScript language were not comparable to what
    we have today. TypeScript introduced many features not only in the form of a type
    system but also syntax, enriching an already existing language with possibilities
    to abstract parts of your code across modules, namespaces, and types.
  prefs: []
  type: TYPE_NORMAL
- en: One of these features was classes, a staple in object-oriented programming.
    TypeScript’s classes originally drew a lot of influence from C#, which is not
    surprising if you know the people behind both programming languages.^([1](ch11.html#id917))
    But they are also designed based on concepts from the abandoned ECMAScript 4 proposals.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, JavaScript gained much of the language features pioneered by TypeScript
    and others; classes, along with private fields, static blocks, and decorators,
    are now part of the ECMAScript standard and have been shipped to language runtimes
    in the browser and the server.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves TypeScript in a sweet spot between the innovation it brought to
    the language in the early days and standards, which is what the TypeScript team
    sees as a baseline for all upcoming features of the type system. While the original
    design is close to what JavaScript ended up with, there are some differences worth
    mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at how classes behave in TypeScript and JavaScript,
    the possibilities we have to express ourselves, and the differences between the
    standard and the original design. We look at keywords, types, and generics, and
    we train an eye to spot what’s being added by TypeScript to JavaScript, and what
    JavaScript brings to the table on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Choosing the Right Visibility Modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two flavors in TypeScript for property visibility and access: one
    through special keyword syntax—`public`, `protected`, `private`—and another one
    through actual JavaScript syntax, when properties start with a hash character.
    Which one should you choose?'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prefer JavaScript-native syntax as it has some implications at runtime that
    you don’t want to miss. If you rely on a complex setup that involves variations
    of visibility modifiers, stay with the TypeScript ones. They won’t go away.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript’s classes have been around for quite a while, and while they draw
    huge inspiration from ECMAScript classes that followed a few years after, the
    TypeScript team also decided to introduce features that were useful and popular
    in traditional class-based object-oriented programming at the time.
  prefs: []
  type: TYPE_NORMAL
- en: One of those features is *property visibility modifiers*, also referred to as
    *access modifiers*. Visibility modifiers are special keywords you can put in front
    of members—properties and methods—to tell the compiler how they can be seen and
    accessed from other parts of your software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All visibility modifiers, as well as JavaScript private fields, work on methods
    as well as properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default visibility modifier is `public`, which can be written explicitly
    or just omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another modifier is `protected`, limiting visibility to classes and subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`protected` access can be overwritten in derived classes to be `public` instead.
    `protected` access also prohibits accessing members from class references that
    are not from the same subclass. So while this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'using the base class or a different subclass won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last visibility modifier is `private`, which allows access only from within
    the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Visibility modifiers also can be used in constructors as a shortcut to define
    properties and initialize them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With all the features described here, it should be noted that TypeScript’s visibility
    modifiers are compile-time annotations that get erased after the compilation step.
    Often, entire property declarations get removed if they are not initialized via
    the class description but in the constructor, as we saw in the last example.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are also valid only during compile-time checks, meaning that a `private`
    property in TypeScript will be fully accessible in JavaScript afterward; thus,
    you can bypass the `private` access check by asserting your instances `as any`,
    or access them directly once your code has been compiled. They are also *enumerable*,
    which means that their names and values become visible when being serialized via
    `JSON.stringify` or `Object.getOwnPropertyNames`. In short: the moment they leave
    the boundaries of the type system they behave like regular JavaScript class members.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next to visibility modifiers, it’s also possible to add `readonly` modifiers
    to class properties.
  prefs: []
  type: TYPE_NORMAL
- en: Since limited access to properties is a feature that is reasonable not only
    within a type system, ECMAScript has adopted a similar concept called *private
    fields* for regular JavaScript classes.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a visibility modifier, private fields actually introduce new syntax
    in the form of a pound sign or *hash* in front of the member’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Introducing a new syntax for private fields has resulted in heated debate within
    the community on the pleasance and aesthetics of the pound sign. Some participants
    even called them abominable. If this addition irritates you as well, it might
    help to think of the pound sign as a little fence that you put in front of the
    things you don’t want everybody to have access to. Suddenly, the pound sign syntax
    becomes a lot more pleasant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pound sign becomes a part of the property’s name, meaning that it also
    needs to be accessed with the sign in front of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Private fields are JavaScript through and through; there is nothing the TypeScript
    compiler will remove, and they retain their functionality—hiding information inside
    the class—even after the compilation step. The transpiled result, with the latest
    ECMAScript version as a target, looks almost identical to the TypeScript version,
    just without type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Private fields can’t be accessed in runtime code, and they are also not enumerable,
    meaning that no information of their contents will be leaked in any way.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is now that both private visibility modifiers and private fields
    exist in TypeScript. Visibility modifiers have been there forever and have more
    variety combined with `protected` members. Private fields, on the other hand,
    are as close to JavaScript as they can get, and with TypeScript’s goal to be a
    “JavaScript syntax for types,” they pretty much hit the mark when it comes to
    the long-term plans of the language. So which one should you choose?
  prefs: []
  type: TYPE_NORMAL
- en: First, no matter which modifier you choose, they both fulfill their goal of
    telling you at compile time when there’s property access where it shouldn’t be.
    This is the first feedback you get informing you that something might be wrong,
    and this is what we’re aiming for when we use TypeScript. So if you need to hide
    information from the outside, every tool does its job.
  prefs: []
  type: TYPE_NORMAL
- en: But when you look further, it again depends on your setting. If you already
    set up a project with elaborate visibility rules, you might not be able to migrate
    them to the native JavaScript version immediately. Also, the lack of `protected`
    visibility in JavaScript might be problematic for your goals. There is no need
    to change something if what you have already works.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run into problems with the runtime visibility showing details you want
    to hide: if you depend on others using your code as a library and they should
    not be able to access all the internal information, then private fields are the
    way to go. They are well-supported in browsers and other language runtimes, and
    TypeScript comes with polyfills for older platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 Explicitly Defining Method Overrides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your class hierarchy, you extend from base classes and override specific
    methods in subclasses. When you refactor the base class, you might end up carrying
    around old, unused methods because nothing tells you that the base class has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switch on the `noImplicitOverride` flag and use the `override` keyword to signal
    overrides.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to draw shapes on a canvas. Your software is able to take a collection
    of points with `x` and `y` coordinates, and based on a specific render function,
    it will draw either polygons, rectangles, or other elements on an HTML canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'You decide to go for a class hierarchy, where the base class `Shape` takes
    an arbitrary list of `Point` elements and draws lines between them. This class
    takes care of housekeeping through setters and getters but also implements the
    `render` function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To use it, create a 2D context from an HTML canvas element, create a new instance
    of `Shape`, and pass the context to the `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to use the established base class and derive subclasses for specific
    shapes, like rectangles. We keep the housekeeping methods and specifically override
    the `constructor`, as well as the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of `Rectangle` is pretty much the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As our software evolves, we inevitably change classes, methods, and functions,
    and somebody in our codebase will rename the `render` method to `draw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is not a problem per se, but if we are not using the `render` method of
    `Rectangle` anywhere in our code, perhaps because we publish this software as
    a library and didn’t use it in our tests, nothing tells us that the `render` method
    in `Rectangle` still exists, with no connection to the original class whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: This is why TypeScript allows you to annotate methods you want to override with
    the `override` keyword. This is a syntax extension from TypeScript and will be
    removed the moment TypeScript transpiles your code to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a method is marked with the `override` keyword, TypeScript will make sure
    that a method of the same name and signature exists in the base class. If you
    rename `render` to `draw`, TypeScript will tell you that the method `render` wasn’t
    declared in the base class `Shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This error is a great safeguard to ensure that renames and refactors don’t break
    your existing contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even though a `constructor` could be seen as an overridden method, its semantics
    are different and handled through other rules (for example, making sure that you
    call `super` when instantiating a subclass).
  prefs: []
  type: TYPE_NORMAL
- en: 'By switching on the `noImplicitOverrides` flag in your *tsconfig.json*, you
    can further ensure that you need to mark functions with the `override` keyword.
    Otherwise, TypeScript will throw another error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Techniques like implementing interfaces that define the basic shape of a class
    already provide a solid baseline to prevent you from running into problems like
    this. So, it’s good to see the `override` keyword and `noImplictOverrides` as
    additional safeguards when creating class hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: When your software needs to rely on class hierarchies to work, using `override`
    together with `noImplicitAny` is a good way to ensure that you don’t forget anything.
    Class hierarchies, like any hierarchies, tend to grow complicated over time, so
    take any safeguard you can get.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Describing Constructors and Prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to instantiate subclasses of a specific abstract class dynamically,
    but TypeScript won’t allow you to instantiate abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Describe your classes with the *constructor interface* pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use class hierarchies with TypeScript, the structural features of TypeScript
    sometimes get in your way. Look at the following class hierarchy for instance,
    where we want to filter a set of elements based on different rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FilterItem` abstract class needs to be implemented by other classes. In
    this example `AFilter` and `BFilter`, both concretizations of `FilterItem`, serve
    as a baseline for filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Things get interesting when we are not working with instances right off the
    bat. Let’s say we want to instantiate new filters based on a token we get from
    an AJAX call. To make it easier for us to select the filter, we store all possible
    filters in a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The map’s generics are set to a `string` (for the token from the backend) and
    everything that complements the type signature of `FilterItem`. We use the `typeof`
    keyword here to be able to add classes to the map, not objects. We want to instantiate
    them afterward, after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far everything works as you would expect. The problem occurs when you want
    to fetch a class from the map and create a new object with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a problem! TypeScript only knows at this point that we get a `FilterItem`
    back and we can’t instantiate `FilterItem`. Abstract classes mix type information
    (*type namespace*) with an actual implementation (*value namespace*). As a first
    step, let’s just look at the types: what are we expecting to get back from `filterMap`?
    Let’s create an interface (or type alias) that defines how the *shape* of `FilterItem`
    should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `new` keyword. This is a way for TypeScript to define the type signature
    of a constructor function. If we substitute the abstract class for an actual interface,
    lots of errors start appearing. No matter where you put the `implements IFilter`
    command, no implementation seems to satisfy our contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What’s happening here? It seems like neither the implementation nor the class
    itself can get all the properties and functions we’ve defined in our interface
    declaration. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript classes are special; they have not just one type we could easily
    define but two: the type of the static side and the type of the instance side.
    It might be clearer if we transpile our class to what it was before ES6, a constructor
    function and a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'One type to create the object. One type for the object itself. So let’s split
    it up and create two type declarations for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first type, `FilterConstructor`, is the *constructor interface*. Here are
    all static properties and the constructor function itself. The constructor function
    returns an instance: `IFilter`. `IFilter` contains type information of the instance
    side. All the functions we declare.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By splitting this up, our subsequent typings also become a lot clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We add instances of type `FilterConstructor` to our map. This means we only
    can add classes that produce the desired objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we want in the end is an instance of `IFilter`. This is what the constructor
    function returns when being called with `new`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our code compiles again, and we get all the autocompletion and tooling we desire.
    Even better, we are not able to add abstract classes to the map because they don’t
    produce a valid instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The constructor interface pattern is used throughout TypeScript and the standard
    library. To get an idea, look at the `ObjectContructor` interface from *lib.es5.d.ts*.
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 Using Generics in Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript generics are designed to be inferred a lot, but in classes, this
    doesn’t always work.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explicitly annotate generics at instantiation if you can’t infer them from your
    parameters; otherwise, they default to `unknown` and accept a broad range of values.
    Use generic constraints and default parameters for extra safety.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes also allow for generics. Instead of only being able to add generic type
    parameters to functions, we can also add generic type parameters to classes. While
    generic type parameters at class methods are valid only in function scope, generic
    type parameters for classes are valid for the entirety of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a collection, a simple wrapper around an array with a restricted
    set of convenience functions. We can add `T` to the class definition of `Collection`
    and reuse this type parameter throughout the entire class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we are able to explicitly substitute `T` with a generic type annotation,
    for example, allowing a collection of only numbers or only strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We as developers are not required to explicitly annotate generic type parameters.
    TypeScript usually tries to infer generic types from usage. If we *forget* to
    add a generic type parameter, TypeScript falls back to `unknown`, allowing us
    to add everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s stay at this point for a second. TypeScript is very honest with us. The
    moment we construct a new instance of `Collection`, we don’t know what the type
    of our items is. `unknown` is the most accurate depiction of the collection’s
    state. And it comes with all the downsides: we can add anything, and we need to
    do type-checks every time we retrieve a value. While TypeScript does the only
    thing possible at this point, we might want to do better. A concrete type for
    `T` is mandatory for `Collection` to properly work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if we can rely on inference. TypeScript’s inference on classes works
    just like it does on functions. If there is a parameter of a certain type, TypeScript
    will take this type and substitute the generic type parameter. Classes are designed
    to keep state, and state changes throughout their use. The state also defines
    our generic type parameter `T`. To correctly infer `T`, we need to require a parameter
    at construction, maybe an initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This works, but it leaves a lot to be desired for our API design. What if we
    don’t have initial values? While other classes might have parameters that can
    be used for inference, this might not make a lot of sense for a collection of
    various items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Collection`, it is absolutely essential to provide a type through annotation.
    The only way left is to ensure we don’t forget to add an annotation. To achieve
    this, we can make sure of TypeScript’s generic default parameters and the bottom
    type `never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the generic type parameter `T` to default to `never`, which adds some
    very interesting behavior to our class. `T` still can be explicitly substituted
    with every type through annotation, working just as before, but the moment we
    forget an annotation the type is not `unknown`, it’s `never`. Meaning that no
    value is compatible with our collection, resulting in many errors the moment we
    try to add something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This fallback makes the use of our generic classes a lot safer.
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 Deciding When to Use Classes or Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript offers a lot of syntax for object-oriented concepts like namespaces,
    or static and abstract classes. Those features don’t exist in JavaScript, so what
    should you do?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stick with namespace declarations for additional type declarations, avoid abstract
    classes when possible, and prefer ECMAScript modules instead of static classes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing we see from people who worked a lot with traditional object-oriented
    programming languages like Java or C# is their urge to wrap everything inside
    a class. In Java, you don’t have any other options as classes are the only way
    to structure code. In JavaScript (and thus TypeScript), plenty of other possibilities
    do what you want without any extra steps. One of those is static classes or classes
    with static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'While this works and is even—sans type annotations—valid JavaScript, it’s way
    too much ceremony for something that can easily be just plain, boring functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The interface for your users is exactly the same. You can access module scope
    variables just the way you would access static properties in a class, but you
    have them module scoped automatically. You decide what to export and what to make
    visible, not some TypeScript field modifiers. Also, you don’t end up creating
    an `Environment` instance that doesn’t do anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the implementation becomes easier. Check out the class version of `variables()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'as opposed to the module version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'No `this` means less to think about. As an added benefit, your bundlers have
    an easier time doing tree shaking, so you end up with only the things you actually
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That’s why a proper module is always preferred to a class with static fields
    and methods. That’s just an added boilerplate with no extra benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with static classes, people with a Java or C# background cling to namespaces,
    a feature that TypeScript introduced to organize code long before ECMAScript modules
    were standardized. They allowed you to split things across files, merging them
    again with reference markers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Back then, TypeScript even had a bundling feature. It should still work. But
    as noted, this was before ECMAScript introduced modules. Now with modules, we
    have a way to organize and structure code that is compatible with the rest of
    the JavaScript ecosystem. And that’s a plus.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why do we need namespaces? Namespaces are still valid if you want to extend
    definitions from a third-party dependency, for example, that lives inside node
    modules. Say you want to extend the global `JSX` namespace and make sure `img`
    elements feature alt texts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Or you want to write elaborate type definitions in ambient modules. But other
    than that? There is not much use for it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespaces wrap your definitions into an object, writing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This emits something very elaborate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This not only adds cruft but also keeps your bundlers from tree shaking properly!
    Using them also becomes a bit wordier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Dropping them makes things a lot easier. Stick to what JavaScript offers. Not
    using namespaces outside of declaration files makes your code clear, simple, and
    tidy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, there are abstract classes. Abstract classes are a way
    to structure a more complex class hierarchy where you predefine a behavior but
    leave the actual implementation of some features to classes that *extend* from
    your abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s for all subclasses of `Lifeform` to implement `move`. This is a concept
    that exists in basically every class-based programming language. The problem is
    that JavaScript isn’t traditionally class based. For example, an abstract class
    like the following generates a valid JavaScript class but is not allowed to be
    instantiated in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This can lead to some unwanted situations if you’re writing regular JavaScript
    but rely on TypeScript to provide the information in the form of implicit documentation,
    such as if a function definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You or your users might read this as an invitation to pass a `Lifeform` object
    to `moveLifeform`. Internally, it calls `lifeform.move()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lifeform` can be instantiated in JavaScript, as it is a valid class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `move` does not exist in `Lifeform`, thus breaking your application!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is due to a false sense of security. What you actually want is to put
    some pre-defined implementation in the prototype chain and have a contract that
    tells you what to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The moment you look up `Lifeform`, you can see the interface and everything
    it expects, but you seldom run into a situation where you instantiate the wrong
    class by accident.
  prefs: []
  type: TYPE_NORMAL
- en: With everything said about when *not* to use classes and namespaces, when should
    you use them? Every time you need multiple instances of the same object, where
    the internal state is paramount to the functionality of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6 Writing Static Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class-based object-oriented programming taught you to use static classes for
    certain features, but you wonder how those principles are supported in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditional static classes don’t exist in TypeScript, but TypeScript has static
    modifiers for class members for several purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static classes are classes that can’t be instantiated into concrete objects.
    Their purpose is to contain methods and other members that exist once and are
    the same when being accessed from various points in your code. Static classes
    are necessary for programming languages that have only classes as their means
    of abstraction, like Java or C#. In JavaScript, and subsequently TypeScript, there
    are many more ways to express ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, we can’t declare classes to be `static`, but we can define `static`
    members on classes. The behavior is what you’d expect: the method or property
    is not part of an object but can be accessed from the class itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [Recipe 11.5](#ch11_when_to_use_classes), classes with only static
    members are an antipattern in TypeScript. Functions exist; you can keep state
    per module. A combination of exported functions and module-scoped entries is usually
    the way to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: But there is still a use for `static` parts of a class. We established in [Recipe
    11.3](#ch11_constructor_interfaace) that a class consists of static members and
    dynamic members.
  prefs: []
  type: TYPE_NORMAL
- en: The `constructor` is part of the static features of a class, and properties
    and methods are part of the dynamic features of a class. With the `static` keyword
    we can add to those static features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think of a class called `Point` that describes a point in a two-dimensional
    space. It has `x` and `y` coordinates, and we create a method that calculates
    the distance between this point and another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is good behavior, but the API might feel a bit weird if we choose a starting
    point and end point, especially since the distance is the same no matter which
    one is first. A static method on `Point` gets rid of the order, and we have a
    nice `distance` method that takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar version using the constructor function/prototype pattern that was
    used pre-ECMAScript classes in JavaScript would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As in [Recipe 11.3](#ch11_constructor_interfaace), we can easily see which parts
    are static and which parts are dynamic. Everything that is in the *prototype*
    belongs to the dynamic parts. Everything else is *static*.
  prefs: []
  type: TYPE_NORMAL
- en: But classes are not only syntactic sugar to the constructor function/prototype
    pattern. With the inclusion of private fields, which are absent in regular objects,
    we can do something that is actually related to classes and their instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to, for example, hide the `distanceTo` method because it might be
    confusing and we’d prefer our users to use the static method instead, a simple
    private modifier in front of `distanceTo` makes it inaccessible from the outside
    but still keeps it accessible from within static members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The visibility also goes in the other direction. Let’s say you have a class
    that represents a certain `Task` in your system, and you want to limit the number
    of existing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a static private field called `nextId` that we start at `0`, and we
    increase this private field with every constructed instance `Task`. If we reach
    `100`, we throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to limit the number of instances by a dynamic value from a backend,
    we can use a `static` instantiation block that fetches this data and updates the
    static private fields accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Other than fields in instances, TypeScript at the time of writing does not check
    if static fields are instantiated. If we, for example, load the number of available
    slots from a backend asynchronously, we have a certain time frame during which
    we can construct instances but have no check if we reached our maximum.
  prefs: []
  type: TYPE_NORMAL
- en: So, even if there is no construct of a static class in TypeScript and static-only
    classes are considered an antipattern, there might be a good use for static members
    in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 Working with Strict Property Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes keep state, but nothing tells you if this state is being initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Activate strict property initialization by setting `strictPropertyInitialization`
    to `true` in your *tsconfig*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes can be seen as code templates for creating objects. You define properties
    and methods, and only through instantiation do actual values get assigned. TypeScript
    classes take basic JavaScript classes and enhance them with more syntax to define
    types. For example, TypeScript allows you to define the properties of the instance
    in a type- or interface-like manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this notation only defines the shape: it doesn’t set any concrete
    values, yet. When being transpiled to regular JavaScript, all those properties
    are erased; they exist only in the *type namespace*.'
  prefs: []
  type: TYPE_NORMAL
- en: This notation is arguably very readable and gives the developer a good idea
    of what properties to expect. But there is no guarantee that these properties
    actually exist. If we don’t initialize them, everything is either missing or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript has safeguards for this. With the `strictPropertyInitialization`
    flag set to `true` in your *tsconfig.json*, TypeScript will make sure that all
    properties you’d expect are actually initialized when creating a new object from
    your class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`strictPropertyInitialization` is part of TypeScript’s `strict` mode. If you
    set `strict` to `true` in your *tsconfig*—which you should—you also activate strict
    property initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is activated, TypeScript will greet you with many red squiggly lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Beautiful! Now it’s up to us to make sure that every property will receive
    a value. There are multiple ways to do this. If we look at the `Account` example,
    we can define some constraints or rules, if our application’s domain allows us
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` and `userName` need to be set; they control the communication to our backend
    and are necessary for display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` also needs to be set, but it has a default value of `active`. Usually,
    accounts in our software are active, unless they are set intentionally to `inactive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orders` is an array that contains order IDs, but what if we haven’t ordered
    anything? An empty array works just as well, or maybe we set `orders` to not be
    defined yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given those constraints, we already can rule out two errors. We set `state`
    to be `active` by default, and we make `orders` optional. There’s also the possibility
    to set `orders` to be of type `number[] | undefined`, which is the same thing
    as optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The other two properties still throw errors. By adding a `constructor` and
    initializing these properties, we rule out the other errors as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it, a proper TypeScript class! TypeScript also allows for a constructor
    shorthand, where you can turn constructor parameters into class properties with
    the same name and value by adding a visibility modifier like `public`, `private`,
    or `protected`. It’s a convenient feature that gets rid of a lot of boilerplate
    code. It’s important that you don’t define the same property in the class shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the class right now, you see that we rely only on TypeScript
    features. The transpiled class, the JavaScript equivalent, looks a lot different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Everything is in the `constructor`, because the `constructor` defines an instance.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While TypeScript shortcuts and syntax for classes seem nice, be careful how
    much you buy into them. TypeScript switched gears in recent years to be mostly
    a syntax extension for types on top of regular JavaScript, but their class features
    that have existed for many years now are still available and add different semantics
    to your code than you’d expect. If you lean toward your code being “JavaScript
    with types,” be careful when you venture into the depths of TypeScript class features.
  prefs: []
  type: TYPE_NORMAL
- en: Strict property initialization also understands complex scenarios, like setting
    the property within a function that is being called via the `constructor`. It
    also understands that an async class might leave your class with a potentially
    uninitialized state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you just want to initialize your class via an `id` property and fetch
    the `userName` from a backend. If you do the async call within your constructor
    and set `userName` after the `fetch` call is complete, you still get strict property
    initialization errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: And it’s true! Nothing tells you that the `fetch` call will be successful, and
    even if you `catch` errors and make sure that the property will be initialized
    with a fallback value, there is a certain amount of time when your object has
    an uninitialized `userName` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do a few things to get around this. One nice pattern is having a static
    factory function that works asynchronously, where you get the data first and then
    call a constructor that expects both properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This allows both objects to be instantiated in a non-async context if you have
    access to both properties, or within an async context if you have only `id` available.
    We switch responsibilities and remove `async` from the constructor entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another technique is to simply ignore the uninitialized state. What if the
    state of `userName` is totally irrelevant to your application, and you want to
    access it only when needed? Use the *definite assignment assertion* (an exclamation
    mark) to tell TypeScript you will treat this property as initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The responsibility is now in your hands, and with the exclamation mark you have
    TypeScript-specific syntax you can qualify as unsafe operation, runtime errors
    included.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8 Working with this Types in Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You extend from base classes to reuse functionality, and your methods have signatures
    that refer to an instance of the same class. You want to make sure that no other
    subclasses are getting mixed in your interfaces, but you don’t want to override
    methods just to change the type.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `this` as type instead of the actual class type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we want to model a bulletin board software’s different user
    roles using classes. We start with a general `User` class that is identified by
    its user ID and has the ability to open threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This class also contains an `equals` method. Somewhere in our codebase, we need
    to make sure that two references to users are the same, and since we identify
    users by their ID, we can easily compare numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '`User` is the base class of all users, so if we add roles with more privileges,
    we can easily inherit from the base `User` class. For example, `Admin` has the
    ability to close threads, and it stores a set of other privileges that we might
    use in other methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is much debate in the programming community if inheritance is a technique
    better to ignore since its benefits hardly outweigh its pitfalls. Nevertheless,
    some parts of JavaScript rely on inheritance, such as Web Components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we inherit from `User`, we don’t need to write another `openThread` method,
    and we can reuse the same `equals` method since all administrators are also users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting up our classes, we can create new objects of type `User` and
    `Admin` by instantiating the right classes. We can also call the `equals` method
    to compare if two users might be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing is bothersome, though: the direction of comparison. Of course, comparing
    two numbers is commutative; it shouldn’t matter if we compare a `user` to an `admin`,
    but if we think about the surrounding classes and subtypes, there is some room
    for improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s OK to check if a `user` equals an `admin`, because it might gain privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s doubtful if we want an `admin` to equal a `user`, because the broader supertype
    has less information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have another subclass of `Moderator` adjacent to `Admin`, we definitely
    don’t want to be able to compare them as they don’t share properties outside the
    base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Still, in the way `equals` is developed now, all comparisons would work. We
    can work around this by changing the type of what we want to compare. We annotated
    the input parameter with `User` first, but in reality we want to compare *with
    another instance of the same type*. There is a type for that, and it is called
    `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is different from the erasable `this` parameter we know from functions,
    which we learned about in [Recipe 2.7](ch02.html#ch02_item_this_types), as the
    `this` parameter type allows us to set a concrete type for the `this` global variable
    within the scope of a function. The `this` type is a reference to the class where
    the method is located. And it changes depending on the implementation. So if we
    annotate a `user` with `this` in `User`, it becomes an `Admin` in the class that
    inherits from `User`, or a `Moderator`, and so on. With that, `admin.equals` expects
    another `Admin` class to be compared to; otherwise, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The other way around still works. Since `Admin` contains all properties from
    `User` (it’s a subclass, after all), we can easily compare `user.equals(admin)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`this` types can also be used as return types. Take a look at this `OptionBuilder`,
    which implements the *builder pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a soft wrapper around a `Map`, which allows us to set key/value pairs.
    It has a chainable interface, which means that after each `add` call, we get the
    current instance back, allowing us to do `add` call after `add` call. Note that
    we annotated the return type with `OptionBuilder<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now creating a `StringOptionBuilder` that inherits from `OptionBuilder`
    and sets the type of possible elements to `string`. We also add a `safeAdd` method
    with checks if a certain value is already set before it is written, so we don’t
    override previous settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When we start using the new builder, we see that we can’t reasonably use `safeAdd`
    if we have an `add` as the first step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript tells us that `safeAdd` does not exist on type `OptionBuilder<string>`.
    Where has this function gone? The problem is that `add` has a very broad annotation.
    Of course `StringOptionBuilder` is a subtype of `OptionBuilder<string>`, but with
    the annotation, we lose the information on the narrower type. The solution? Use
    `this` as return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The same effect happens as with the previous example. In `OptionBuilder<T>`,
    `this` becomes `OptionBuilder<T>`. In `StringBuilder`, `this` becomes `StringBuilder`.
    If you return `this` and leave out the return type annotation, `this` becomes
    the *inferred* return type. So using `this` explicitly depends on your preference
    (see [Recipe 2.1](ch02.html#ch02_item_annotation)).
  prefs: []
  type: TYPE_NORMAL
- en: 11.9 Writing Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to log the execution of your methods for your telemetry, but adding
    manual logs to every method is cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a class method decorator called `log` to annotate your methods.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *decorator* design pattern has been described in the renowned book *Design
    Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma et al.
    (Addison-Wesley) and describes a technique that can *decorate* classes and methods
    to dynamically add or overwrite certain behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: What began as a naturally emerging design pattern in object-oriented programming
    has become so popular that programming languages that feature object-oriented
    aspects have added decorators as a language feature with a special syntax. You
    can see forms of it in Java (called *annotations*) or C# (called *attributes*)
    and in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript proposal for decorators has been in proposal hell for quite a
    while but reached stage 3 (ready for implementation) in 2022\. And with all features
    reaching stage 3, TypeScript is one of the first tools to pick up the new specification.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Decorators have existed in TypeScript for a long time under the `experimentalDecorators`
    compiler flag. With TypeScript 5.0, the native ECMAScript decorator proposal is
    fully implemented and available without a flag. The actual ECMAScript implementation
    differs fundamentally from the original design, and if you developed decorators
    prior to TypeScript 5.0, they won’t work with the new specification. Note that
    a switched-on `experimentalDecorators` flag turns off the ECMAScript native decorators.
    Also, in regard to types, *lib.decorators.d.ts* contains all type information
    for the ECMAScript native decorators, while types in *lib.decorators.legacy.d.ts*
    contain old type information. Make sure your settings are correct and that you
    don’t consume types from the wrong definition file.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators allow us to decorate almost anything in a class. For this example,
    we want to start with a method decorator that allows us to log the execution of
    method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are described as functions with a *value* and a *context*, both depending
    on the type of class element you want to decorate. Those decorator functions return
    another function that will be executed before your own method (or before field
    initialization, or before an accessor call, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `log` decorator for methods could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `log` function follows a `ClassMethodDecorator` type defined in the original
    [decorator proposal](https://oreil.ly/76JuE):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Many decorator context types are available. *lib.decorator.d.ts* defines the
    following decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can read from the names exactly which part of a class they target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we haven’t written detailed types yet. We resort to a lot of `any`,
    mostly because the types can get very complex. If we want to add types for all
    parameters, we need to resort to a lot of generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic type parameters are necessary to describe the method we are passing
    in. We want to catch the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`This` is a generic type parameter for the `this` parameter type (see [Recipe
    2.7](ch02.html#ch02_item_this_types)). We need to set `this` as decorators are
    run in the context of an object instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we have the method’s arguments as `Args`. As we learned in [Recipe 2.4](ch02.html#ch02_item_tuple_types),
    a method or function’s arguments can be described as a tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, but not least, the `Return` type parameter. The method needs to return
    a value of a certain type, and we want to specify this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all three, we are able to describe the input method as well as the output
    method in the most generic way, for all classes. We can use generic constraints
    to make sure that our decorator works only in certain cases, but for `log`, we
    want to be able to log every method call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the time of writing, ECMAScript decorators in TypeScript are fairly new.
    Types get better over time, so the type information you get may already be much
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to log our class fields and their initial value before the `constructor`
    method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'For that, we create another decorator called `logField`, which works on a `ClassFieldDecoratorContext`.
    The [decorator proposal](https://oreil.ly/76JuE) describes the decorator for class
    fields as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the *value* is `undefined`. The initial value is being passed to
    the replacement method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: There’s one thing that feels off. Why would we need different decorators for
    different kinds of members? Shouldn’t our `log` decorator be capable of handling
    it all? Our decorator is called in a specific *decorator context*, and we can
    identify the right context via the `kind` property (a pattern we saw in [Recipe
    3.2](ch03.html#ch03_item_discriminated_unions)). So there’s nothing easier than
    writing a `log` function that does different decorator calls depending on the
    context, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, yes and no. Of course, having a wrapper function that branches correctly
    is the way to go, but the type definitions, as we’ve seen, are pretty complex.
    Finding *one* function signature that can handle them all is close to impossible
    without defaulting to `any` everywhere. And remember: we need the right function
    signature typings; otherwise, the decorators won’t work with class members.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple different function signatures just scream *function overloads*. So
    instead of finding one function signature for all possible decorators, we create
    overloads for *field decorators*, *method decorators*, and so on. Here, we can
    type them just as we would type the single decorators. The function signature
    for the implementation takes `any` for `value` and brings all required decorator
    context types in a union, so we can do proper discrimination checks afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Instead of fumbling all the actual code into the `if` branches, we’d rather
    call the original methods. If you don’t want to have your `logMethod` or `logField`
    functions exposed, then you can put them in a module and only export `log`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are a lot of different decorator types, and they all have various fields
    that differ slightly. The type definitions in *lib.decorators.d.ts* are excellent,
    but if you need a bit more information, check out [the original decorator proposal
    at TC39](https://oreil.ly/76JuE). Not only does it include extensive information
    on all types of decorators, but it also contains additional TypeScript typings
    that complete the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last thing we want to do: adapt `logMethod` to log both *before*
    and *after* the call. For normal methods, it’s as easy as temporarily storing
    the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: But for asynchronous methods, things get a little more interesting. Calling
    an asynchronous method yields a `Promise`. The `Promise` itself might already
    have been executed, or the execution is deferred to later. This means if we stick
    with the implementation from before, the *called* log message might appear before
    the method actually yields a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a workaround, we need to chain the log message as the next step after the
    `Promise` yields a result. To do so, we need to check if the method is actually
    a `Promise`. JavaScript Promises are interesting because all they need to be awaited
    is having a `then` method. This is something we can check in a helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we decide whether to log directly or deferred based on if we
    have a `Promise`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Decorators can get very complex but are ultimately a useful tool to make classes
    in JavaScript and TypeScript more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch11.html#id917-marker)) C# and TypeScript are made by Microsoft, and
    Anders Hejlsberg has been heavily involved in both programming languages.
  prefs: []
  type: TYPE_NORMAL
