- en: Chapter 5\. Developing Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are at the heart of Helm charts, and they make up a majority of the
    files and content of a chart. These are the files that live within the *templates*
    directory. Helm will render the templates and send them to Kubernetes when you
    run commands like `helm install` and `helm upgrade`. If you use the `helm template`
    command, the templates are rendered and displayed as output (i.e., sent to standard
    out).
  prefs: []
  type: TYPE_NORMAL
- en: The template engine enables a wide range of ways to build templates. In simple
    situations, you can substitute values in Kubernetes manifest YAML files with values
    passed in by the user or from the *values.yaml* file. In more complex situations,
    you can build logic into templates that simplify what chart consumers need to
    input. Or you can build in features that can configure applications themselves.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you will learn how to develop templates and understand how the
    template syntax works. We’ll also cover a number of cool features that Helm has
    added to the templates that enable you to work with YAML and interact with Kubernetes.
    Along the way we will look at some patterns you can apply to your own templates.
  prefs: []
  type: TYPE_NORMAL
- en: The Template Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm uses the Go text template engine provided as part of the Go standard library.
    The syntax is used in `kubectl` (the command-line application for Kubernetes)
    templates, Hugo (the static site generator), and numerous other applications built
    in Go. The template engine, as it is used in Helm, is designed to work with various
    types of text files.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to know the Go programming language to develop templates. There
    are some Go-isms in the template engine, but if you don’t know Go you can treat
    them as nuances of the template language. We will call them out as you learn to
    develop templates.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logic, control structures, and data evaluations are wrapped by `{{` and `}}`.
    These are called actions. Anything outside of actions is copied to output.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the curly brackets are used to start and stop actions they can be accompanied
    by a `-` to remove leading or trailing whitespace. The following example illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The generated output of this is “Hello,World.” The whitespace has been removed
    from the side with the `-` up to the next nonwhitespace character. There needs
    to be an ASCII whitespace between the `-` and the rest of the action. For example,
    `{{–12}}` evaluates to –12 because the `-` is considered part of the number instead
    of the bracket.
  prefs: []
  type: TYPE_NORMAL
- en: Within actions there are a wide variety of features you can leverage, including
    pipelines, if/else statements, loops, variables, subtemplates, and functions.
    Using these together provides a powerful way to program templates.
  prefs: []
  type: TYPE_NORMAL
- en: Information Helm Passes to Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Helm renders a template it passes a single data object to the template
    with information you can access. Inside the template that object is represented
    as a `.` (i.e., a period). It is referred to as a dot. This object has a wide
    variety of information available on it.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml#building_a_chart), you already saw how values in the
    *values.yaml* file are available as properties on `.Values`. The properties on
    `.Values` are specific to each chart based entirely on the values in the *values.yaml*
    file and those passed into a chart. The properties on `.Values` do not have a
    schema and vary from chart to chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the values, information about the release, as first described
    in [Chapter 2](ch02.xhtml#Using_Helm), can be accessed as properties of `.Release`.
    This information includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Release.Name`'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the release.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Release.Namespace`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the namespace the chart is being released to.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Release.IsInstall`'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `true` when the release is a workload being installed.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Release.IsUpgrade`'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `true` when the release is an upgrade or rollback.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Release.Service`'
  prefs: []
  type: TYPE_NORMAL
- en: Lists the service performing the release. When Helm installs a chart, this value
    is set to `"Helm"`. Different applications, those that build on Helm, can set
    this to their own value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information in the *Chart.yaml* file can also be found on the data object
    at `.Chart`. This information does follow the schema for the *Chart.yaml* file.
    This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Chart.Name`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the name of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Chart.Version`'
  prefs: []
  type: TYPE_NORMAL
- en: The version of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Chart.AppVersion`'
  prefs: []
  type: TYPE_NORMAL
- en: The application version, if set.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Chart.Annotations`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains a key/value list of annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the properties that can be in a *Chart.yaml* file is accessible. The
    names differ in that they start with a lowercase letter in *Chart.yaml* but start
    with an uppercase letter when they are properties on the `.Chart` object.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to pass custom information from the *Chart.yaml* file to the templates,
    you need to use annotations. The `.Chart` object only contains the fields from
    the *Chart.yaml* file that are in the schema. You can’t add new fields to pass
    them in, but you can add your custom information to the annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different Kubernetes clusters can have different capabilities. This can depend
    on things like the version of Kubernetes you are using or if there are custom
    resource definitions (CRDs) installed. Helm provides some data about the capabilities
    of the cluster as properties of `.Capabilities`. Helm interrogates the cluster
    you are deploying an application into to get this information. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Capabilities.APIVersions`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the API versions and resource types available in your cluster. You
    will learn how to use this in a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Capabilities.KubeVersion.Version`'
  prefs: []
  type: TYPE_NORMAL
- en: The full Kubernetes version.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Capabilities.KubeVersion.Major`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the major Kubernetes version. Because Kubernetes has not been incrementing
    the major version, this is set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Capabilities.KubeVersion.Minor`'
  prefs: []
  type: TYPE_NORMAL
- en: The minor version of Kubernetes being used in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: When `helm template` is used, Helm does not interrogate a cluster the same way
    it does for `helm install` or `helm upgrade`. The capabilities information provided
    to templates being processed when `helm template` is run is default information
    Helm already knows about compliant Kubernetes clusters. Helm works this way because
    the `template` command is expected to only be used for processing templates and
    doing so in a manner that does not accidentally leak information from a configured
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Charts can contain custom files. For example, you can have a configuration file
    you want to pass to an application through a `ConfigMap` or `Secret` as a file
    in the chart. The nonspecial files in a chart that are not listed in the *.helmignore*
    file are available on `.Files` within templates. This will not give you access
    to the template files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of data passed into the template is details about the current
    template being executed. Helm passes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Template.Name`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the namespaced filepath to the template. For example, in the *anvil*
    chart from [Chapter 4](ch04.xhtml#building_a_chart) a path would be *anvil/templates/deployment.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Template.BasePath`'
  prefs: []
  type: TYPE_NORMAL
- en: The namespaced path to the *templates* directory of the current chart (e.g.,
    *anvil/templates*).
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter you will learn how you can change the scope of `.` in
    some circumstances. When the scope changes, properties like `.Capabilities.KubeVersion.Minor`
    will become inaccessible at that location. When template execution begins, `.`
    is mapped to `$` and `$` does not change. Even when the scope changes, `$.Capabilities.KubeVersion.Minor`
    and other passed-in data is still accessible. You will find `$` is typically only
    used when the scope has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned about the data being passed into the template, we will
    look at how you can use and manipulate that data within a template.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pipeline is a sequence of commands, functions, and variables chained together.
    The value of a variable or the output of a function is used as the input to the
    next function in a pipeline. The output of the final element of a pipeline is
    the output of the pipeline. The following illustrates a simple pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are three parts to this pipeline, each separated by a `|`. The first is
    `.Values.character`, which is a calculated value of `character`. This is either
    the value of `character` from the *values.yaml* file or one passed in when the
    chart is being rendered by `helm install`, `helm upgrade`, or `helm template`.
    This value is passed as the last argument to the `default` function. If the value
    is empty, `default` will use the value of “Sylvester” in its place. The output
    of `default` is passed as an input to `quote`, which ensures the value is wrapped
    in quotation marks. The output of `quote` is returned from the action.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines are a powerful tool you can use to transform data you want in the
    template. They can be used for a variety of purposes, from creating powerful transformations
    to protecting against simple bugs. Can you spot the bug in the following YAML
    output?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `id` looks like a string, but it is not. The only letter is an
    *e*, and the rest are numbers. YAML parsers, including the one used by Kubernetes,
    will interpret that as a number in scientific notation. This will cause errors.
    A short string like this is a common output when you get a shortened version of
    a digest or commit ID from Git. A simple fix is to wrap the value in quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the value is wrapped in quotes, the YAML parsers will interpret it as a
    string. This is a case where using the `quote` function on the end of a pipeline
    can fix or avoid a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Template Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within actions and pipelines, there are template functions you can use. You
    have already seen some of these, including the `default` and `quote` functions
    described earlier in this chapter. Functions provide a means to transform the
    data you have into the format you need rendered or to generate data where none
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the functions are provided by Helm and are designed to be useful when
    building charts. The functions range from the simple, like the `indent` and `nindent`
    functions used to indent output, to the complex ones that are able to reach into
    the cluster and get information on current resources and resource types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate functions we can look at a common pattern used in charts to improve
    readability. When `helm create` is run, as you saw in [Chapter 4](ch04.xhtml#building_a_chart),
    a Kubernetes `Deployment` template is created as part of the chart. The `Deployment`
    template includes a section for a security context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Read the full chart from [Chapter 4](ch04.xhtml#building_a_chart) at [*https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil*](https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil).
  prefs: []
  type: TYPE_NORMAL
- en: In the *values.yaml* file there is a YAML entry for `podSecurityContext`. This
    is meant to be the exact YAML passed in the `template` section of a `Deployment`
    for `securityContext`. Inside, the template the information from the *values.yaml*
    file is no longer YAML. Instead it is a data object. The `toYaml` function turns
    the data into YAML.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML under `securityContext` needs to be indented properly or the Deployment’s
    manifest will have YAML errors due to a section not being properly indented. This
    is accomplished through the use of two functions. To the left of `toYaml` a `-`
    is used with `{{` to remove all the whitespace up to the `:` on the previous line.
    The output of `toYaml` is passed to `nindent`. This function adds a newline at
    the start of the text it receives and then indents each line.
  prefs: []
  type: TYPE_NORMAL
- en: '`nindent` is used instead of the `indent` function for readability. The `indent`
    function does not add a newline at the beginning. `nindent` is used so that the
    YAML under `securityContext` can be on a new line. This is another common pattern
    found in templates.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to `toYaml`, Helm has functions to convert data to JSON with `toJson`
    and to TOML with `toToml`. `toYaml` is often used when creating Kubernetes manifests,
    while `toJson` and `toToml` are more often used when creating configuration files
    to be passed to applications through `Secret`s and `ConfigMap`s.
  prefs: []
  type: TYPE_NORMAL
- en: The order of arguments passed into a function is intentional. When pipelines
    are used, the output of one function is passed as the last argument to the next
    function in the pipeline. In the previous example the output of `toYaml` is passed
    as the last argument to `nindent`, which takes two arguments. The order of arguments
    on functions is designed for common pipeline use cases.
  prefs: []
  type: TYPE_NORMAL
- en: There are more than a [hundred functions](https://oreil.ly/Xtoya) available
    to use within templates. These include functions for handling math, dictionaries
    and lists, reflection, hash generation, date functions, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, you have seen template functions. Helm also includes functions
    that detect the capabilities of a Kubernetes cluster and methods to work with
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The `.Capabilities` object has the method `.Capabilities.APIVersions.Has`, which
    takes in a single argument for the Kubernetes API or type you want to check the
    existence of. It returns either true or false to let you know if that resource
    is available in your cluster. You can check for a group and version such as `batch/v1`
    or a resource type such as `apps/v1/Deployment`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Checking for the existence of resources and API groups is useful when dealing
    with custom resource definitions and multiple versions of Kubernetes resource
    types. As Kubernetes API versions move from alpha, to beta, to released versions,
    you want to use the latest version of a resource type as alpha and beta are deprecated
    and removed from Kubernetes. If your application will be installed on a wide range
    of Kubernetes versions, it is useful to support API versions in all of those clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When `helm template` is used, Helm will use a default set of API versions for
    a compliant Kubernetes cluster instead of interacting with your cluster to generate
    the known capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other place you will find methods is on `.Files`. It includes the following
    methods to help you work with files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Files.Get name`'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a means of getting the contents of the file as a string. `name`, in
    this case, is the name including filepath from the root of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Files.GetBytes`'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `.Files.Get` but instead of returning a string, the file is returned
    as an array of bytes. In Go terms, this is a byte slice (i.e., `[]byte`).
  prefs: []
  type: TYPE_NORMAL
- en: '`.Files.Glob`'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a glob pattern and returns another `files` object containing only the
    files whose names match the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Files.AsConfig`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a files group and returns it as flattened YAML suitable to include in
    the `data` section of a Kubernetes `ConfigMap` manifest. This is useful when paired
    with `.Files.Glob`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Files.AsSecrets`'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `.Files.AsConfig`. Instead of returning flattened YAML it returns
    the data in a format that can be included in the `data` section of a Kubernetes
    `Secret` manifest. It’s Base64 encoded. This is useful when paired with `.Files.Glob`.
    For example, `{{ .Files.Glob("mysecrets/**").AsSecrets }}`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.Files.Lines`'
  prefs: []
  type: TYPE_NORMAL
- en: Has an argument for a filename and returns the contents of the file as an array
    split by newlines (i.e., `\n`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the use of these, the following template is from an *example*
    chart. It reads all the files in the *config* subdirectory of a chart and embeds
    each one in a `Secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As the following example output from Helm shows, each file can be found at
    its own key in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Querying Kubernetes Resources In Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm contains a template function that enables you to look up resources in the
    Kubernetes cluster. The `lookup` template function is able to return either an
    individual object or a list of objects. This function returns an empty response
    when commands that do not interact with the cluster are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example looks up a `Deployment` named *runner* in the *anvil*
    namespace and makes the metadata annotations available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four arguments passed into the `lookup` function:'
  prefs: []
  type: TYPE_NORMAL
- en: API version
  prefs: []
  type: TYPE_NORMAL
- en: This is the version of any object, whether included in Kubernetes or installed
    as part of an add-on. Examples of this look like `"v1"` and `"apps/v1"`.
  prefs: []
  type: TYPE_NORMAL
- en: Kind of object
  prefs: []
  type: TYPE_NORMAL
- en: This can be any resource type.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace to look for the object in
  prefs: []
  type: TYPE_NORMAL
- en: This can be left blank to look in all namespaces you have access to or for global
    resources such as Namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Name of the resource you are looking for
  prefs: []
  type: TYPE_NORMAL
- en: This can be left blank to return a list of resources instead of a specific one.
  prefs: []
  type: TYPE_NORMAL
- en: When a list of resources is returned, you will need to loop over the results
    to access the data on each of the individual objects. Where a lookup for an object
    returns a *dict*, a lookup for a list of objects returns a *list*. These are two
    different types Helm provides for use in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a list is returned, the objects are on the `items` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The items can be iterated over using a loop, which you will learn about later
    in the chapter. This example returns all the `ConfigMap`s in the *anvil* namespace,
    assuming you have access to the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: You should be careful when using this function. For example, it will return
    different results when used as part of a dry run as opposed to when an upgrade
    is run. A dry run does not interact with a cluster, so this function will return
    no results. When an upgrade is run it will return results.
  prefs: []
  type: TYPE_NORMAL
- en: The results returned when installing or upgrading in various clusters can also
    be different. For example, in a development environment and in a production environment
    the resources installed in a cluster will have differences that can lead to unequal
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: if/else/with
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go templates have `if` and `else` statements along with something similar but
    mildly different called `with`. `if` and `else` work the same way they do in most
    programming languages. To illustrate an `if` statement, we can look at a pattern
    from the chart generated using the `helm create` command covered in [Chapter 4](ch04.xhtml#building_a_chart).
    In that chart the *values.yaml* file contains a section on `ingress` with an enabled
    property. It looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *ingress.yaml* file that creates the `Ingress` resource for Kubernetes,
    the first and last lines are for the `if` statement that implements this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `if` statement evaluates whether the output of the pipeline
    following the `if` statement is true or false. If it’s true, the content inside
    is evaluated. In order to know where the end of the block is, you need an `end`
    statement. This is important because indentation or more typical brackets could
    be part of the material you want rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Using `if` statements is how the common *enabled* pattern is typically implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '`if` statements can have an `else` statement that is executed if the `if` statement
    evaluates to false. The following example prints a YAML comment to output when
    `Ingress` is not enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you will want to have multiple elements evaluated in an `if` statement
    by combining them with an `and` or an `or` statement. In templates this is a little
    different than you might be used to. Consider the following segment from a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case `and` is implemented as a function with two arguments. That means
    `and` comes before either of the two items being used. The same idea applies to
    the use of `or`, which is also implemented as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When one of the elements to be used with `and` or `or` is a function or pipeline,
    you can use parentheses. The following example has one of the arguments to `or`
    being an equal check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output of the equality check, implemented using the `eq` function, is passed
    as the first argument to `or`. The parentheses enable you to group elements together
    to build more complex logic.
  prefs: []
  type: TYPE_NORMAL
- en: '`with` is similar to `if` with the caveat that the scope within a `with` block
    changes. To continue with an example from `Ingress`, the following block shows
    the scope change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the value passed into `with` is empty, the block is skipped. If the value
    is not empty, the block is executed and the value of `.` inside the block is `.Values.ingress.annotations`.
    In this situation, the scope within the block has changed to the value checked
    by `with`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The pattern of checking a value using `with` and then sending it to output using
    the `toYaml` and `nindent` functions is common for elements you have in a *values.yaml*
    file that you want to directly output in a template. This is regularly used for
    image pull secrets, node selectors, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with `if` statements, `with` can have an accompanying `else` block
    that you can use when the value is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within templates you can create your own variables and use them to pass as arguments
    to functions, print in the output, and more. Variables start with a `$` and are
    typed. Once a variable is created for one type, such as a string, you cannot set
    the value to another type, such as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating and initializing a variable has a special syntax through the use of
    `:=`, like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case a new variable is created and the value of `.Values.character`
    is assigned to it. This variable can be used elsewhere; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The value of `$var` is passed to `default` in the same way `.Values.character`
    was passed earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to create a variable with an initial value is different from the
    method used to change the value of an existing variable. When you assign a new
    value to the existing variable, you use `=`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case the variable is changed in another action. Variables live on for
    the life of the template execution and are available in the same action or different
    ones later in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Variable handling is reflective of the syntax and style used in the Go programming
    language. It follows the same semantics through the use of `:=`, `=`, and typing.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using loops is a common method to simplify a user’s interaction with a chart.
    For example, you can use loops to collect a list of hosts to use when exposing
    a web application, through values, and then loop over the list to create more
    complex Kubernetes `Ingress` resources.
  prefs: []
  type: TYPE_NORMAL
- en: The loop syntax in templates is a little different than that in many programming
    languages. Instead of `for` loops, there are `range` loops that can be used to
    iterate over *dicts* (also known as maps) and lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates dicts and lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can think of a list as an array, while a map, with a key name and value,
    is similar to dictionaries in Python or a HashMap in Java. Within Helm templates
    you can create your own dictionaries and lists using the `dict` and `list` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways you can use the `range` function. The following example
    iterates over the *characters* while changing the scope, which is the value of
    `.`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case `range` iterates over each item in the list and sets the value
    of `.` to the value of each item in the list as Helm iterates over the item. In
    this example, the value is passed to `quote` in the pipeline. The scope for `.`
    is changed in the block up to `end`, which acts as the closing bracket or statement
    for the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this snippet is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The other way to use `range` is by having it create new variables for the key
    and value. This will work on both lists and dicts. This next example creates the
    variables that you can use in the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$key` variable contains the key in a map or dict and a number in a list.
    `$value` contains the value. If this is a complex type, such as another dict,
    that will be available as the `$value`. The new variables are in scope up to the
    end of the `range` block, which is signified by the corresponding `end` action.
    The output of this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Named Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times where you will want to create a template to call from within
    your template of a Kubernetes manifest—for example, when you have a value generated
    by some complex logic or when you have a section that is repeated across numerous
    Kubernetes manifests. You can create your own templates, which Helm won’t automatically
    render, and use them within templates of Kubernetes manifests.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this can be found when you run `helm create` to generate a chart.
    By default Helm creates several Kubernetes manifests with some shared elements,
    such as labels. To keep the labels consistent and so they only need to be updated
    in one place, Helm generates a template and then calls that template each time
    the labels are needed.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of labels used in the templates. There are the labels used
    on higher-level resources, such as `Deployment`s, and then there are the labels
    used in specifications that are paired with selectors used for updates. These
    labels need to be treated differently because the labels used on specifications
    and selectors are typically immutable. This means you won’t want them to contain
    elements such as application versions because those can change as an application
    is upgraded, but the specifications and selectors cannot be updated with new versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following template selection contains the selector labels used to generate
    specifications and selector sections in the generated template. The name, *anvil*,
    is from the chart generated in [Chapter 4](ch04.xhtml#building_a_chart):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_developing_templates_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A comment prior to defining the function. Comments in actions open with `/*`
    and are closed by `*/`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_developing_templates_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: You define a template with a `define` statement followed by the name for the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_developing_templates_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The content of a template is just like the content of any other template.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_developing_templates_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The definition for a template is closed through an `end` statement that matches
    to the `define` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This template includes several useful things you should consider using in your
    own templates:'
  prefs: []
  type: TYPE_NORMAL
- en: A comment describing the template. This is ignored when the template is rendered
    but is useful in the same way code comments are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name is namespaced, using `.` as the separator, to include the chart name.
    In [Chapter 6](ch06.xhtml#advanced_charts) you will learn about library charts
    and dependent charts. Using a namespace on a template name enables the use of
    library charts and avoids collisions on dependent charts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `define` and `end` calls use actions that remove whitespace before and after
    them so that their use does not add extra lines to the final output YAML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This template is called in the `spec` section of resources, such as the `Deployment`
    in the *anvil* chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `matchLabels` section here is immutable, so it cannot be changed and it
    looks for the `labels` in the `template` section.
  prefs: []
  type: TYPE_NORMAL
- en: There are two functions you can use to include another template in your template.
    The `template` function is a basic function for including another template. It
    cannot be used in pipelines. Then there is the `include` function that works in
    a similar manner but can be used in pipelines. In the preceding example, `include`
    is used to call another template and the output of that template is passed to
    `nindent` to ensure the output has the proper indentation level. Since the output
    has a different indentation level for each call, the indentation level cannot
    be included as part of the template that defines it.
  prefs: []
  type: TYPE_NORMAL
- en: The `include` function takes two arguments. The first is the name of the template
    to call. This needs to be the full name including any namespace. The second is
    the data object to pass. This can be one you create yourself, using the `dict`
    function, or it can be all or part of the global object used within the template.
    In this case the whole global object is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template function Helm created to generate the wider selection of labels,
    used on the labels for the higher-level resources where the labels are mutable,
    both adds labels and includes the selector labels. It has user-defined templates
    that call other user-defined templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Because these labels are mutable, there are useful labels included here that
    will change for various reasons. So as not to repeat the labels used for selectors,
    which are useful here as well, those labels are included by calling the function
    that generates them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another situation you may find yourself in where a named template would be
    useful is when you want to encapsulate complex logic. To illustrate this idea,
    consider a chart where you want to be able to pass in a container version as a
    tag, a digest, or fall back on the application version as a default. The part
    of the `Pod` specification that accepts the container image, including the version,
    is a single line. To provide all three of those options you need many lines of
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This new `getImage` template is able to handle a digest, tag, and default to
    the application version if neither of the other two are present. First, a digest
    is checked for and used. A digest is immutable, and it is the most precise method
    to specify the revision of an image to use. If no digest is passed in, a tag is
    checked. Tags are pointers to digests and can be changed. If no tag is found,
    the `AppVersion` is used as a tag.
  prefs: []
  type: TYPE_NORMAL
- en: This function targets the structure of the *anvil* chart, first created for
    [Chapter 4](ch04.xhtml#building_a_chart). The image details are expected to be
    within the structure of that chart and its *values.yaml* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template for the `Deployment`, the image would be referenced using the
    new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Templates can act like functions in a software program. They are a useful way
    for you to break off complex logic and have shared functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring Your Templates for Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is limited structure that is enforced on the templates in the *templates*
    directory. Multiple Kubernetes manifests can be in the same YAML file, which means
    that the templates for multiple Kubernetes manifests can be in the same file,
    too. Named templates can live in any of the template files and be referenced in
    the others. The *NOTES.txt* template is a special file that displays to the user,
    and tests are handled in a special way. Tests are covered in [Chapter 6](ch06.xhtml#advanced_charts).
    Other than that, it is a blank canvas for you to create templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To aid in creating maintainable templates that are easy to navigate, the Helm
    maintainers recommend several patterns. These patterns are useful for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You may go long periods without making structural changes to the templates in
    a chart and then come back to it. Being able to quickly rediscover the layout
    will make the processes faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other people will look at the templates in charts. This may be team members
    who create the chart or those that consume it. Consumers can, and sometimes do,
    open up a chart to inspect it prior to installing it or as part of a process to
    fork it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you debug a chart, which is covered in the next section, it is easier to
    do so with some structure in the templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first pattern is that each Kubernetes manifest should be in its own template
    file and that file should have a descriptive name. For example, name your template
    *deployment.yaml* if there is a single deployment. If you have the case of multiple
    manifests of the same type, such as the case when you have a database deployed
    using primaries and replicas, you use names such as *statefulset-primary.yaml*
    and *statefulset-replica.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: A second guideline is to put the named templates, which you include in your
    own templates, into a file named *_helpers.tpl*. Because these are essentially
    helper templates for your other templates, the name is descriptive. As mentioned
    earlier, the _ at the start of the name causes it to bubble up to the top of directory
    listings so you can easily find it among your templates.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `helm create` command to start a new chart, the contents of
    the templates it starts with, by default, will already follow these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing templates it’s useful to debug the templates. Helm provides
    three features you can use in your development workflow to find issues. These
    are in addition to testing, which is covered in [Chapter 6](ch06.xhtml#advanced_charts).
  prefs: []
  type: TYPE_NORMAL
- en: Dry Run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The commands to install, upgrade, roll back, and uninstall Helm charts all
    have a flag to initiate a dry run and simulate the process but not fully execute
    on that process. This is accomplished using the `--dry-run` flag on these commands.
    For example, if you use the `--dry-run` flag on the `install` command on the *anvil*
    chart, you could use the command `helm install myanvil anvil --dry-run`. Helm
    would render the templates, check the templates to make sure what would be sent
    to Kubernetes was well formed, and would then send it to output. The output would
    look similar to the output on a normal install but would have two additional sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The two new sections are the *HOOKS* and *MANIFEST* sections that will contain
    the YAML Helm would normally pass to Kubernetes. Instead it is sent to the output.
    For brevity the full generated YAML is not included because this would be pages
    long.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there were a problem in the templates, the response would be quite different.
    To illustrate this, try removing the first `}` from the *deployment.yaml* file
    in the *anvil* chart and performing a dry-run install again. Removing the `}`
    will cause an error parsing the actions in the templates. Instead of outputting
    the status, Helm will output an error like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The information here outlines a hint where to look for the issue. It includes:'
  prefs: []
  type: TYPE_NORMAL
- en: The file where the error is occurring. *anvil/templates/deployment.yaml*, in
    this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line number in the file where the error occurred. Here it is line 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error message with a hint about the problem. The error message will often
    not display what the issue is, but rather where the parser is having an issue.
    In this case a single `}` is unexpected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helm will check for more than errors in the template syntax. It will also check
    the syntax of the output. To illustrate this, in the same *deployment.yaml* file
    remove the `apiVersion:` at the start of it. Make sure to add back the missing
    `}` so that the action is fixed. The beginning of the file will now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing a dry-run install will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering why there is an error converting between YAML and JSON.
    This is a product of the YAML parsing library that Helm and Kubernetes use. The
    useful part of the error message is the part that starts with `line 2`. The first
    line is not complete, so the second line is in the wrong context even though it
    is well formed. The file is not valid YAML, and Helm is telling you where to start
    looking for the problem. If you took the same section of YAML and tested it in
    an online YAML validator, you would get the same error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm is also able to validate the schemas of Kubernetes resources. This is
    accomplished because Kubernetes provides schema definitions for its manifests.
    To illustrate this, change the `apiVersion` in the *deployment.yaml* to be `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing a dry-run install will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The deployment is no longer valid, and Helm was able to provide specific feedback
    on what is missing. In this case, the `apiVersion` property is not set.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a dry-run isn’t the only way you can get access to this feature. The
    `helm template` command provides a similar experience but without the full debugging
    feature set. The `template` command does turn the `template` commands into YAML.
    At this point it will provide an error if the generated YAML cannot be parsed.
    What it won’t do is validate the YAML against the Kubernetes schema. The `template`
    command won’t warn you if `apiVersion` is turned to `foo`. This is due to Helm
    not communicating with a Kubernetes cluster to get the schema for validation when
    the `template` command is used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Installed Manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times where you install an application into a cluster and something
    else changes the manifests afterwards. This leads to differences between what
    you declared and what you have running. One example of this is when a service
    mesh automatically adds a sidecar container to the `Pod`s created by your Helm
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the original manifests deployed by Helm using the `helm get manifest`
    command. This command will retrieve the manifests for a release as they were when
    Helm installed the release. It is able to retrieve this information for any revision
    of a release still available in the history, as found using the `helm history`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue the *myanvil* example, to retrieve the manifests for this instance
    of the *anvil* chart you would run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will include all of the manifests with `---` at the start of each
    new manifest. The following is the first 15 lines from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`---` is used as a separator between YAML documents. In addition to that, Helm
    adds a YAML comment with the source template used to generate the manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: Linting Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the problems you will encounter don’t show up as violations of the API
    specification and aren’t problems in the templates. For example, Kubernetes resources
    are required to have names that can be used as part of a domain name. This restricts
    the characters that you can use in names and their length. The OpenAPI schema
    provided by Kubernetes does not provide enough information to detect names that
    will fail when sent to Kubernetes. The *lint* command, previously covered in [Chapter 4](ch04.xhtml#building_a_chart),
    is able to detect problems like this and tell you where they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this you can modify the *anvil* chart to add `Wile` to the end
    of the Deployment name in *deployment.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `helm lint anvil` will produce an error informing you of the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `helm lint` is pointing you to a problem and telling you where
    it is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The templates you include in a chart provide a powerful ability to create resources
    within Kubernetes. It’s akin to a programming language around templates. The template
    system has features like logic, built-in functions, custom templates, and debugging.
    This means you can collect the input you desire through values and generate the
    Kubernetes manifests you need.
  prefs: []
  type: TYPE_NORMAL
- en: There is still more to charts, including dependencies, testing, schemas for
    values files, and more. [Chapter 6](ch06.xhtml#advanced_charts) is going to expand
    on what you can have and do with charts.
  prefs: []
  type: TYPE_NORMAL
