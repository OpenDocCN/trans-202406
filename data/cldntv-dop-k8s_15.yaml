- en: Chapter 13\. Development Workflow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。开发工作流程
- en: Surfing is such an amazing concept. You’re taking on Nature with a little stick
    and saying, *I’m gonna ride you!* And a lot of times Nature says, *No you’re not!*
    and crashes you to the bottom.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 冲浪是一个令人惊奇的概念。你用一根小棍子挑战大自然，说着 *我要骑你！*，但很多时候大自然会回答 *不，你做不到！*，把你摔到水底。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jolene Blalock
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乔琳·布拉洛克
- en: In this chapter, we’ll expand on the discussion in [Chapter 12](ch12.html#deploying),
    turning our attention to the whole application life cycle, from local development
    to deploying updates to a Kubernetes cluster, including the tricky topic of database
    migrations. We’ll cover some tools that help you develop, test, and deploy your
    applications, including Skaffold and Telepresence. We will also introduce Knative
    and OpenFaaS, two options for running “serverless” architectures on your clusters.
    We’ll also look at more complex deployments, and ordering application rollouts
    using Helm hooks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展讨论第 12 章中的内容，关注整个应用程序生命周期，从本地开发到在 Kubernetes 集群中部署更新，包括数据库迁移这个棘手的主题。我们将介绍一些工具，帮助你开发、测试和部署应用程序，包括
    Skaffold 和 Telepresence。我们还将介绍 Knative 和 OpenFaaS，这两个选项可在你的集群上运行“无服务器”架构。我们还将查看更复杂的部署，并使用
    Helm 钩子来顺序应用程序的部署。
- en: Development Tools
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: In [Chapter 12](ch12.html#deploying), we looked at some tools to help you write,
    build, and deploy your Kubernetes resource manifests. That’s fine as far as it
    goes, but often when you’re developing an application that runs in Kubernetes,
    you want to be able to try things out and see changes instantly, without going
    through a full build-push-deploy-update loop.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 12 章](ch12.html#deploying) 中，我们看了一些工具，帮助你编写、构建和部署你的 Kubernetes 资源清单。这在一定程度上很好，但是当你开发运行在
    Kubernetes 中的应用程序时，通常希望能够即时尝试并查看变化，而不必经历完整的构建-推送-部署-更新循环。
- en: Skaffold
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Skaffold
- en: '[Skaffold](https://oreil.ly/UTaRj) is an open source tool from Google designed
    to provide a fast local development workflow. It automatically rebuilds your containers
    as you develop locally, and deploys those changes to either a local or remote
    cluster.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[Skaffold](https://oreil.ly/UTaRj) 是来自 Google 的开源工具，旨在提供快速的本地开发工作流程。它在你本地开发时自动重建你的容器，并将这些更改部署到本地或远程集群。'
- en: You define your desired workflow in a *skaffold.yaml* file in your repository
    and run the `skaffold` command-line tool to start the pipeline. As you make changes
    to files in your local directory, Skaffold wakes up, builds a new container with
    the changes, and then deploys it for you automatically, saving you a round trip
    to the container.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的仓库中的 *skaffold.yaml* 文件中定义你想要的工作流程，并运行 `skaffold` 命令行工具启动流水线。当你在本地目录中的文件上进行更改时，Skaffold
    将唤醒，使用更改构建一个新的容器，然后自动为你部署它，省去了往返到容器的时间。
- en: 'We have a Skaffold example in the [demo repo](https://oreil.ly/LAI8f) to show
    how it works. Follow the Skaffold [installation instructions](https://oreil.ly/heDih)
    for your operating system, point your `kubectl` at your local development Kubernetes
    cluster, and switch to the *hello-skaffold* directory to see how it works:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [演示仓库](https://oreil.ly/LAI8f) 中有一个 Skaffold 示例来展示它的工作原理。按照你操作系统的 Skaffold
    [安装说明](https://oreil.ly/heDih)，将你的 `kubectl` 指向你的本地开发 Kubernetes 集群，并切换到 *hello-skaffold*
    目录查看其工作方式：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Skaffold automatically built and deployed the demo application using Helm and
    is now watching for changes to the code or the chart. It uses a randomly generated
    SHA as a temporary placeholder container tag as you are doing development. If
    you `curl localhost:8888` you should see `Hello, skaffold!`, because that is what
    is set in the `main.go` for this example. Leave Skaffold running and go change
    that *main.go* file to say something else, like `Hola, skaffold!`. As soon as
    you save your changes, Skaffold will automatically rebuild and redeploy the updated
    copy of the app:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold 自动使用 Helm 构建和部署演示应用程序，现在正在监视代码或图表的更改。它使用随机生成的 SHA 作为临时占位符容器标签，这是在进行开发时的情况。如果你
    `curl localhost:8888`，你应该会看到 `Hello, skaffold!`，因为这是在本示例的 `main.go` 中设置的。保持 Skaffold
    运行状态，并更改 *main.go* 文件以说一些其他内容，比如 `Hola, skaffold!`。只要保存更改，Skaffold 将自动重新构建和重新部署应用程序的更新副本：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now if you `curl localhost:8888`, you’ll see your modified code running. Skaffold
    built a new copy of the demo container and released a new version to your cluster
    using Helm. Keep making changes with Skaffold running, and it will continue updating
    the application automatically. When you’ve had enough fun, you can stop Skaffold
    with `Ctrl+C` and it will automatically uninstall the demo app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您`curl localhost:8888`，您将看到您修改后的代码正在运行。Skaffold构建了演示容器的新副本，并使用Helm发布了一个新版本到您的集群。继续在运行Skaffold时进行更改，它将继续自动更新应用程序。当您玩够了，可以使用`Ctrl+C`停止Skaffold，并自动卸载演示应用程序。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use Skaffold for other types of builds, such as Bazel, or using your
    own custom-build scripts. It supports using [Google Cloud Build](https://cloud.google.com/build)
    as a remote image builder, rather than using your local machine. You can also
    incorporate your test suite into the workflow and automatically run through your
    tests as part of the build and deploy process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Skaffold进行其他类型的构建，例如Bazel，或使用您自己的自定义构建脚本。它支持使用[Google Cloud Build](https://cloud.google.com/build)作为远程镜像构建工具，而不是使用您的本地计算机。您还可以将测试套件整合到工作流程中，并在构建和部署过程中自动运行测试。
- en: Telepresence
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telepresence
- en: '[Telepresence](https://www.telepresence.io) takes a slightly different approach
    from Skaffold. You don’t need a local Kubernetes cluster; a Telepresence Pod runs
    in your real cluster as a placeholder for your application. Traffic for the application
    Pod is then intercepted and routed to the container running on your local machine.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[Telepresence](https://www.telepresence.io)与Skaffold采取了稍微不同的方法。您不需要本地Kubernetes集群；Telepresence
    Pod在您的实际集群中作为应用程序的占位符运行。然后拦截和路由应用程序Pod的流量，将其转发到在您本地计算机上运行的容器。'
- en: This enables the developer to make their local machine participate in the remote
    cluster. As they make changes to application code, they will be reflected in the
    live cluster, without a new container having to be deployed to it. If your application
    has a particularly long build time, this may be an appealing tool to try.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这使开发者能够使其本地计算机参与远程集群。随着他们对应用程序代码的更改，这些更改将在实时集群中反映出来，而无需部署新的容器。如果您的应用程序构建时间特别长，这可能是一个值得尝试的吸引人工具。
- en: One common complaint about developing applications in containers is that a new
    container needs to be built containing the new code changes, and this can be a
    frustrating experience if the rebuild is slow. Telepresence aims to ease this
    frustration and speed up the local development process while still using containers
    and Kubernetes so that the runtime environment between local development and what
    is deployed in production does not need to be entirely different.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用程序时，常见的抱怨之一是需要构建一个新的容器来包含新的代码更改，如果重新构建速度慢的话，这可能会让人沮丧。Telepresence旨在减轻这种沮丧，并加快本地开发过程，同时仍然使用容器和Kubernetes，这样本地开发和生产部署之间的运行环境不需要完全不同。
- en: Waypoint
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Waypoint
- en: HashiCorp, the developers behind popular tools like Vault, Terraform, and Consul,
    have built a new tool focused on simplifying the end-to-end application development
    experience. [Waypoint](https://www.waypointproject.io) introduces a declarative
    *waypoint.hcl* file that allows you to define the build, deploy, config, and release
    steps for your application regardless of the runtime or platform it uses. Using
    a standard wrapper like Waypoint means that your CI/CD tooling and processes can
    be standardized, even if your applications use different build and deploy steps.
    Developers can check out an application repository, run `waypoint build`—while
    not having to consider if this particular application uses a Dockerfile or something
    like a [CloudNative Buildpack](https://buildpacks.io)—and expect to end up with
    the correct artifact for running the application. Similarly, `waypoint deploy`
    abstracts away whether this particular application uses Kubernetes, Helm, or maybe
    it runs as an AWS Lambda function. Having a standard CLI experience for developers
    and the CI/CD tooling can greatly simplify how the build and deployment process
    works across different types of applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp，开发了像Vault、Terraform和Consul这样流行工具的开发者，已经构建了一个新工具，专注于简化端到端的应用开发体验。[Waypoint](https://www.waypointproject.io)引入了一个声明性的*waypoint.hcl*文件，允许您定义应用的构建、部署、配置和发布步骤，无论其使用的运行时或平台如何。使用像Waypoint这样的标准包装器意味着您的CI/CD工具和流程可以标准化，即使您的应用程序使用不同的构建和部署步骤。开发者可以检出一个应用程序仓库，运行`waypoint
    build`—而不必考虑这个特定的应用程序是否使用Dockerfile或类似[CloudNative Buildpack](https://buildpacks.io)，并期望得到用于运行应用程序的正确构件。同样，`waypoint
    deploy`抽象了这个特定应用程序使用Kubernetes、Helm或者它可能作为AWS Lambda函数运行的细节。为开发者和CI/CD工具提供标准的CLI体验可以极大地简化不同类型应用程序的构建和部署流程。
- en: Knative
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knative
- en: 'While the other tools we’ve looked at are focused on speeding up the local
    development loop, [Knative](https://oreil.ly/SXohX) is more ambitious. It aims
    to provide a standard mechanism for deploying all kinds of workloads to Kubernetes:
    not just containerized applications, but *serverless*-style functions too.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们看到的其他工具侧重于加速本地开发循环，[Knative](https://oreil.ly/SXohX)则更为雄心勃勃。它旨在提供一种标准机制，用于将各种工作负载部署到Kubernetes：不仅限于容器化应用程序，还包括*无服务器*风格的函数。
- en: Knative integrates with both Kubernetes and Istio (see [“Istio”](ch09.html#istio))
    to provide a complete application/function deployment platform, including setting
    up a build process, automated deployment, and an *eventing* mechanism that standardizes
    the way applications use messaging and queueing systems (for example, Pub/Sub,
    Kafka, or RabbitMQ).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Knative与Kubernetes和Istio集成（参见[“Istio”](ch09.html#istio)）以提供完整的应用/函数部署平台，包括设置构建流程、自动化部署以及*事件*机制，标准化应用程序使用消息传递和队列系统的方式（例如Pub/Sub、Kafka或RabbitMQ）。
- en: OpenFaaS
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenFaaS
- en: '[OpenFaas](https://www.openfaas.com) is another project that makes it possible
    to run serverless functions on Kubernetes. It includes a CLI tool for building
    and deploying functions to your clusters, and can trigger on HTTP events, a cron
    schedule, MQTT, Kafka, and RabbitMQ messages, and other popular event-driven systems
    and message queues. These serverless types of architectures work well with the
    microservice mindset and can lead to more efficient usage of your servers.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[OpenFaas](https://www.openfaas.com)是另一个项目，可以在Kubernetes上运行无服务器函数。它包括用于构建和部署函数到集群的CLI工具，并能触发HTTP事件、定时任务、MQTT、Kafka和RabbitMQ消息以及其他流行的事件驱动系统和消息队列。这些无服务器架构与微服务思维方式结合得很好，并且可以更有效地利用服务器资源。'
- en: An interesting side project from the folks working on OpenFaaS is called [*arkade*](https://oreil.ly/XBbiD),
    which works sort of like an App Store or marketplace for installing popular cloud
    native tools (like OpenFaaS itself) with one unified tool. With one `arkade` command
    you can install OpenFaaS on your Kubernetes cluster and start deploying your serverless
    workloads.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 来自OpenFaaS开发团队的一个有趣的旁支项目被称为[*arkade*](https://oreil.ly/XBbiD)，它类似于一个应用商店或市场，用于安装流行的云原生工具（例如OpenFaaS本身）的统一工具。通过一个`arkade`命令，您可以在您的Kubernetes集群上安装OpenFaaS并开始部署您的无服务器工作负载。
- en: Crossplane
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Crossplane
- en: '[Crossplane](https://crossplane.io) is a tool that aims to bring the standardization
    of Kubernetes to non-Kubernetes cloud resources. Many applications require pieces
    of infrastructure that live outside of Kubernetes, such as an AWS S3 bucket, an
    RDS database instance, or an Azure Cosmos DB instance. Often this means that developers
    end up using tools like [Terraform](https://www.terraform.io) to deploy these
    external dependencies first, and then switch to deploying the application using
    Dockerfiles, Kubernetes manifests, and Helm charts.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[Crossplane](https://crossplane.io) 是一个旨在将Kubernetes的标准化引入非Kubernetes云资源的工具。许多应用程序需要在Kubernetes之外生活的基础设施组件，例如AWS
    S3存储桶、RDS数据库实例或Azure Cosmos DB实例。通常，这意味着开发人员最终需要使用像[Terraform](https://www.terraform.io)这样的工具先部署这些外部依赖，然后再切换到使用Dockerfile、Kubernetes清单和Helm图表部署应用程序。'
- en: 'Crossplane uses CRDs (see [“Operators and Custom Resource Definitions (CRDs)”](ch09.html#crds))
    to define these types of infrastructure that live outside of Kubernetes as if
    they were native Kubernetes objects. It uses the APIs of the cloud providers to
    actually create and deploy these cloud resources, much like you would using the
    Terraform CLI or your cloud provider’s CLI and SDK tools. Imagine that you could
    declare a PostgreSQL RDS instance that your application requires to run like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane使用CRD（参见[“Operators and Custom Resource Definitions (CRDs)”](ch09.html#crds)）来定义那些生活在Kubernetes之外的基础设施类型，使它们就像本地的Kubernetes对象一样。它使用云供应商的API实际创建和部署这些云资源，就像您使用Terraform
    CLI或您的云提供商的CLI和SDK工具一样。想象一下，您可以像这样声明一个您的应用程序需要运行的PostgreSQL RDS实例：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you can bundle this manifest for your application’s RDS instance alongside
    of your other Kubernetes manifests and deploy them together. The Kubernetes reconciliation
    loop will then ensure that this RDS instance is provisioned, just as it does for
    your application Pods. Another benefit here is when the infrastructure is managed
    and deployed together with the application, you can easily pass configuration
    between them. For example, the Crossplane CRD can automatically create a Kubernetes
    Secret for the password when it creates the database, and pass it to your application
    to use to connect. We expect that as Kubernetes continues to gain widespread adoption
    that this sort of extending the use of Kubernetes for managing other types of
    infrastructure will become popular.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将应用程序的RDS实例清单与其他Kubernetes清单一起打包并一起部署。然后，Kubernetes协调循环将确保此RDS实例被配置，就像为您的应用程序Pods做的那样。另一个好处是，当基础架构与应用程序一起管理和部署时，您可以轻松地在它们之间传递配置。例如，Crossplane
    CRD可以在创建数据库时自动为密码创建一个Kubernetes Secret，并将其传递给您的应用程序以供连接使用。我们预计随着Kubernetes的广泛采用，这种扩展Kubernetes管理其他类型基础设施的方式将变得流行起来。
- en: Deployment Strategies
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署策略
- en: If you were upgrading a running application by hand, without Kubernetes, one
    way to do it would be to just shut down the application, install the new version,
    and restart it. But that means downtime.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您手动升级运行中的应用程序（没有使用Kubernetes），一种方法是只需关闭应用程序，安装新版本，然后重新启动。但这意味着会有停机时间。
- en: 'If you had multiple instances of your application spread across several servers,
    a better way would be to upgrade each one in turn so that there would be no interruption
    in service: a so-called *zero-downtime deployment*.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序在多个服务器上分布有多个实例，一个更好的方式是依次升级每个实例，这样就不会中断服务：所谓的*零停机部署*。
- en: Not all applications need zero downtime. Internal services that consume message
    queues, for example, are idempotent, so they can be upgraded all at once. This
    means the upgrade happens faster, but for user-facing applications, we are usually
    more concerned with avoiding downtime than achieving quick upgrades.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有应用都需要零停机时间。例如，消费消息队列的内部服务是幂等的，因此它们可以一次性进行升级。这意味着升级速度更快，但对于用户界面的应用程序来说，我们通常更关心避免停机时间，而不是追求快速升级。
- en: In Kubernetes, you can choose whichever of these strategies is most appropriate.
    `RollingUpdate` is the zero-downtime, Pod-by-Pod option, while `Recreate` is the
    fast, all-Pods-at-once option. There are also some fields that you can tweak to
    get the exact behavior that you need for your application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，您可以选择最合适的策略。`RollingUpdate`是逐个Pod进行的零停机时间选项，而`Recreate`是快速一次性升级所有Pod的选项。此外，还有一些字段可以调整，以获得您应用程序所需的确切行为。
- en: 'In Kubernetes, an application’s deployment strategy is defined in the Deployment
    manifest. The default is `RollingUpdate`, so if you don’t specify a strategy,
    this is what you’ll get. To change the strategy to `Recreate`, set it like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，应用程序的部署策略在部署清单中定义。默认为`RollingUpdate`，如果不指定策略，就会使用这个。要将策略更改为`Recreate`，请像这样设置：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now let’s look more closely at these deployment strategies and see how they
    work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看看这些部署策略，看看它们是如何工作的。
- en: Rolling Updates
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动更新
- en: In a rolling update, Pods are upgraded one at a time, until all replicas have
    been replaced with the new version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在滚动更新中，Pod 会逐个升级，直到所有副本都被新版本替换。
- en: For example, imagine we’re running an application with three replicas, each
    running `v1`. The developer starts an upgrade to `v2` with a `kubectl apply...`
    or `helm upgrade...` command. What happens?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们运行一个具有三个副本的应用程序，每个副本都运行`v1`。开发人员使用`kubectl apply...`或`helm upgrade...`命令启动了升级到`v2`的过程。会发生什么？
- en: First, one of the three `v1` Pods will be terminated. Kubernetes will flag it
    as unready, and stop sending it traffic. A new `v2` Pod will be spun up to take
    its place. Meanwhile, the remaining `v1` Pods continue receiving incoming requests.
    While we’re waiting for the first `v2` Pod to become ready, we’re down to two
    Pods, but we’re still serving users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，三个`v1` Pod中的一个将被终止。Kubernetes将标记它为未就绪，并停止向其发送流量。将会启动一个新的`v2` Pod来替代它。与此同时，剩余的`v1`
    Pod继续接收传入的请求。在等待第一个`v2` Pod变为就绪时，我们只剩下两个 Pod，但仍在为用户提供服务。
- en: When the `v2` Pod becomes ready, Kubernetes will start sending it user traffic,
    alongside the other two `v1` Pods. Now we’re back to our full complement of three
    Pods.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当`v2` Pod准备就绪时，Kubernetes将开始向其发送用户流量，同时还会发送到其他两个`v1` Pod。现在我们又回到了三个 Pod 的完整组合。
- en: This process will continue, Pod by Pod, until all of the `v1` Pods have been
    replaced with `v2` Pods. While there are times when fewer Pods than usual are
    available to handle traffic, the application as a whole is never actually down.
    That’s zero-downtime deployment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会一直进行，逐个 Pod 地，直到所有的`v1` Pod都被替换成了`v2` Pod。尽管有时候会出现比平时更少的 Pod 用于处理流量，但整个应用实际上从未真正下线。这就是零停机部署。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: During a rolling update, both old and new versions of your application will
    be in service at the same time. While this usually isn’t a problem, you may need
    to take steps to ensure that this is safe; if your changes involve a database
    migration, for example (see [“Handling Migrations with Helm”](#helm-db-migrate)),
    a normal rolling update won’t be possible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在滚动更新期间，旧版本和新版本的应用将同时处于服务状态。虽然通常这不会成为问题，但你可能需要采取措施来确保安全；例如，如果你的更改涉及数据库迁移（见[“使用Helm处理迁移”](#helm-db-migrate)），普通的滚动更新可能就不可行了。
- en: If your Pods can sometimes crash or fail after a short time in a ready state,
    use the `minReadySeconds` field to have the rollout wait until each Pod is stable
    (see [“minReadySeconds”](ch05.html#minreadyseconds)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Pod 有时候在就绪状态后短时间内可能会崩溃或失败，可以使用`minReadySeconds`字段让滚动更新等待每个 Pod 稳定（参见[“minReadySeconds”](ch05.html#minreadyseconds)）。
- en: Recreate
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新创建
- en: In `Recreate` mode, all running replicas are terminated at once, and then new
    ones are created.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Recreate`模式下，所有运行中的副本会同时被终止，然后重新创建新的副本。
- en: For applications that do not directly handle requests, this should be acceptable.
    One advantage of `Recreate` is that it avoids the situation where two different
    versions of the application are running simultaneously (see [“Rolling Updates”](#rollingupdate)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不直接处理请求的应用程序来说，这是可以接受的。`Recreate`的一个优点是它避免了同时运行两个不同版本的应用程序的情况（参见[“滚动更新”](#rollingupdate)）。
- en: maxSurge and maxUnavailable
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: maxSurge 和 maxUnavailable
- en: 'As a rolling update progresses, sometimes you will have more Pods running than
    the nominal `replicas` value, and sometimes less. Two important settings govern
    this behavior: `maxSurge` and `maxUnavailable`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随着滚动更新的进行，有时候会有比名义上的`replicas`值更多或更少的 Pod 在运行。两个重要的设置管理这种行为：`maxSurge`和`maxUnavailable`：
- en: '`maxSurge` sets the maximum number of excess Pods. For example, if you have
    10 replicas and you set `maxSurge` to 30%, then no more than 13 Pods will be allowed
    to run at any one time.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxSurge`设置了额外 Pod 的最大数量。例如，如果你有 10 个副本并将`maxSurge`设置为30%，那么任何时候运行的 Pod 数量不会超过
    13 个。'
- en: '`maxUnavailable` sets the maximum number of unavailable Pods. With a nominal
    10 replicas and `maxUnavailable` of 20%, Kubernetes will never let the number
    of available Pods drop below 8.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxUnavailable`设置了不可用 Pod 的最大数量。对于名义上有 10 个副本并且`maxUnavailable`设置为20%的 Kubernetes，不会让可用
    Pod 的数量少于 8 个。'
- en: 'These can be set as either a whole number, or as a percentage:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以设置为整数或百分比：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Usually, the default value of `25%` for both settings is fine, and you probably
    won’t need to adjust these, but depending on your load requirements you may need
    to tweak them to make sure your application can maintain acceptable capacity during
    an upgrade. At very large scale, you may find that running at 75% availability
    during a deployment is not sufficient to handle your incoming traffic, and you’ll
    need to reduce `maxUnavailable` slightly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于这两个设置，默认值`25%`是可以接受的，您可能不需要调整它们，但根据负载要求，您可能需要对其进行微调，以确保应用程序在升级期间能够保持可接受的容量。在非常大的规模上，您可能会发现在部署期间以`75%`的可用性运行不足以处理您的传入流量，因此您需要稍微减少`maxUnavailable`。
- en: The bigger the value of `maxSurge`, the faster your rollout but the more load
    it places on your cluster’s resources. Large values of `maxUnavailable` also speed
    up rollouts, at the expense of your application’s capacity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge`的值越大，您的发布速度越快，但这会增加您集群资源的负载。较大的`maxUnavailable`值也加快了发布速度，但会减少应用程序的容量。'
- en: On the other hand, small values of `maxSurge` and `maxUnavailable` reduce the
    impact on your cluster and your users, but can make your rollouts take much longer.
    Only you can decide what the right trade-off is for your application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，较小的`maxSurge`和`maxUnavailable`值减少了对您集群和用户的影响，但可能会使您的发布过程时间更长。只有您可以决定对您的应用程序来说，正确的权衡是什么。
- en: Blue/Green Deployments
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝/绿部署
- en: In a *blue/green* deployment, rather than killing and replacing Pods one at
    a time, a whole new Deployment is created, and a new separate stack of Pods running
    `v2` is launched beside the existing `v1` Deployment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*蓝/绿*部署中，与逐个杀死和替换Pods不同，会创建一个全新的Deployment，并启动一个新的运行`v2`的Pods堆栈，放置在现有的`v1`
    Deployment旁边。
- en: One advantage of this is that you don’t have to deal with both old and new versions
    of the application processing requests simultaneously. On the other hand, your
    cluster will need to be big enough to run twice the number of replicas required
    for your application, which can be expensive, and means a lot of unused capacity
    sitting around most of the time (unless you scale the cluster up and down as needed).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个优点是您无需同时处理旧版本和新版本的应用程序处理请求。另一方面，您的集群需要足够大，以运行所需应用程序副本的两倍，这可能很昂贵，并且大部分时间都会有很多未使用的容量（除非根据需要调整集群的规模）。
- en: We learned in [“Service Resources”](ch04.html#services) that Kubernetes uses
    labels to decide which Pods should receive traffic from a Service. One way to
    implement a blue/green deployment is to set different labels on your old and new
    Pods (see [“Labels”](ch09.html#labels)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“服务资源”](ch04.html#services)中了解到，Kubernetes使用标签来决定哪些Pods应该从服务接收流量。实施蓝/绿部署的一种方法是在旧Pods和新Pods上设置不同的标签（见[“标签”](ch09.html#labels)）。
- en: 'With a small tweak to the Service definition for our example application, you
    can send traffic to only Pods labeled `deployment: blue`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '通过对示例应用程序的服务定义进行小调整，您可以仅将流量发送到标记为`deployment: blue`的Pods：'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When deploying a new version, you can label it `deployment: green`. It won’t
    receive any traffic, even when it’s fully up and running, because the Service
    only sends traffic to `blue` Pods. You can test it and make sure it’s ready before
    making the cutover.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '在部署新版本时，您可以将其标记为`deployment: green`。即使完全运行，它也不会接收任何流量，因为Service仅将流量发送到`blue`
    Pods。您可以对其进行测试，并确保它准备就绪，然后再进行切换。'
- en: 'To switch over to the new `Deployment`, edit the `Service` to change the selector
    to `deployment: green`. Now the new `green` Pods will start receiving traffic,
    and once all the old `blue` Pods are idle, you can shut them down.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '要切换到新的`Deployment`，编辑`Service`以更改选择器为`deployment: green`。现在新的`green` Pods将开始接收流量，一旦所有旧的`blue`
    Pods处于空闲状态，您可以关闭它们。'
- en: Rainbow Deployments
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 彩虹部署
- en: In some rare cases, particularly when Pods have very long-lived connections
    (websockets, for example), just blue and green may not be enough. You may need
    to maintain three or more versions of your application in flight at the same time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些罕见情况下，特别是当Pods具有非常长寿的连接（例如websockets）时，仅仅使用蓝色和绿色可能不够。您可能需要同时维护三个或更多版本的应用程序。
- en: This is sometimes referred to as a *rainbow deployment*. Every time you deploy
    an update, you get a new color set of Pods. As connections finally drain from
    your oldest set of Pods, they can be shut down.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这被称为*彩虹部署*。每次部署更新时，您都会获得一组新的颜色Pods集合。随着连接最终从您最老的Pods集合中排干，它们可以关闭。
- en: Brandon Dimcheff describes a [rainbow deployment example](https://oreil.ly/fuFoi)
    in detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Brandon Dimcheff 在详细描述了一个 [彩虹部署示例](https://oreil.ly/fuFoi)。
- en: Canary Deployments
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: The advantage of blue/green (or rainbow) deployments is that if you decide you
    don’t like the new version, or it isn’t behaving correctly, you can simply switch
    back to the old version, which is still running. However, it is expensive because
    you need the cluster capacity to run both versions simultaneously, which means
    you may need to run more nodes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝/绿（或彩虹）部署的优点在于，如果你决定不喜欢新版本或者它的行为不正确，你可以简单地切换回仍在运行的旧版本。然而，这种方法很昂贵，因为你需要集群能力同时运行两个版本，这意味着你可能需要运行更多的节点。
- en: One alternative approach that avoids this problem is a *canary deployment*.
    Like a canary in a coal mine, a small handful of new Pods are exposed to the dangerous
    world of production to see what happens to them. If they survive, the rollout
    can continue to completion. If there *is* a problem, the blast radius is strictly
    limited.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这个问题的一种替代方法是金丝雀部署。像煤矿中的金丝雀一样，一小部分新的 Pods 暴露在生产环境中，观察它们的反应。如果它们能够生存下来，升级过程就可以继续进行。如果出现问题，影响范围则严格限制。
- en: Just as with blue/green deployments, you can do this using labels (see [“Labels”](ch09.html#labels)).
    There is a detailed example of running a canary deployment in the Kubernetes [documentation](https://oreil.ly/PqUe0).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就像蓝/绿部署一样，你可以使用标签来做到这一点（参见 [“标签”](ch09.html#labels)）。在 Kubernetes 文档中有一个详细的金丝雀部署示例，可以参考
    [文档](https://oreil.ly/PqUe0)。
- en: A more sophisticated way to do this is to use a service mesh such as Istio,
    Linkerd, or one of the other tools we mention in [“Service Mesh”](ch09.html#service-mesh),
    which allows you to randomly route a variable proportion of traffic to one or
    more service versions. This also makes it easy to do things like A/B testing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的方法是使用服务网格，例如 Istio、Linkerd 或我们在 [“服务网格”](ch09.html#service-mesh) 中提到的其他工具之一，它们允许你随机路由变量比例的流量到一个或多个服务版本。这也使得像
    A/B 测试之类的操作变得更加容易。
- en: Handling Migrations with Helm
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 处理迁移
- en: Stateless applications are easy to deploy and upgrade, but when a database is
    involved the situation can be more complicated. Changes to the schema of a database
    usually require a *migration* task to be run before the new version of the application
    is running. For example, with Rails apps, you need to run `rails db:migrate` before
    starting the new application Pods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态应用容易部署和升级，但涉及到数据库时情况可能更复杂。通常情况下，对数据库模式的更改需要在新应用版本运行之前运行迁移任务。例如，在 Rails 应用中，你需要在启动新的应用
    Pods 之前运行 `rails db:migrate`。
- en: On Kubernetes, you can use a Job resource to do this (see [“Jobs”](ch09.html#jobs)).
    Another option would be to use an `initContainer` (see [“Init Containers”](ch08.html#init-containers)).
    You could also script this using `kubectl` commands as part of your deploy process,
    or if you are using Helm, then you can use a built-in feature called *hooks*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，你可以使用 Job 资源来执行此操作（参见 [“Jobs”](ch09.html#jobs)）。另一个选择是使用 `initContainer`（参见
    [“Init Containers”](ch08.html#init-containers)）。你也可以在部署过程中使用 `kubectl` 命令来编写脚本，或者如果你使用
    Helm，那么你可以使用一个名为 *hooks* 的内置功能。
- en: Helm Hooks
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 钩子
- en: Helm hooks allow you to control the order in which things happen during a deployment.
    They also let you bail out of an upgrade if things go wrong.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 钩子允许你控制部署过程中发生事情的顺序。它们还允许你在升级过程中遇到问题时中止操作。
- en: 'Here is an example of a database migration Job for a Rails application deployed
    with Helm:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 Helm 部署的 Rails 应用程序数据库迁移 Job 示例：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `helm.sh/hook` properties are defined in the `annotations` section:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm.sh/hook` 属性在 `annotations` 部分中定义：'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `pre-upgrade` setting tells Helm to apply this Job manifest before doing
    an upgrade. The Job will run the standard Rails migration command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`pre-upgrade` 设置告诉 Helm 在执行升级之前应用此 Job 清单。该 Job 将运行标准的 Rails 迁移命令。'
- en: 'The `"helm.sh/hook-delete-policy": hook-succeeded` tells Helm to delete the
    Job if it completes successfully (that is, exits with status 0).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`"helm.sh/hook-delete-policy": hook-succeeded` 告诉 Helm 如果任务成功完成（即退出状态为 0），则删除该
    Job。'
- en: Handling Failed Hooks
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理失败的钩子
- en: If the Job returns a nonzero exit code, this is a sign that there was an error
    and the migration did not complete successfully. Helm will leave the Job in place
    in its failed state so that you can debug what went wrong.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Job 返回非零退出代码，这表明出现错误，迁移过程未能成功完成。Helm 将保留 Job 处于失败状态，以便你可以调试出错原因。
- en: If this happens, the release process will stop, and the application will not
    be upgraded. Running `kubectl get pods` will show you the failed Pod, allowing
    you to inspect the logs and see what happened.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，发布过程将停止，应用程序将不会升级。运行 `kubectl get pods` 将显示失败的 Pod，允许您检查日志并查看发生了什么。
- en: Once the issue has been resolved, you can delete the failed job (`kubectl delete
    job <job-name>`) and then try the upgrade again. Another option for automatically
    cleaning up a failed job would be to add the `ttlSecondsAfterFinished` field that
    we cover in [“Cleaning up completed Jobs”](ch05.html#job-ttl).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决后，您可以删除失败的作业（`kubectl delete job <job-name>`），然后再次尝试升级。另一个自动清理失败作业的选项是添加我们在
    [“清理已完成的作业”](ch05.html#job-ttl) 中介绍的 `ttlSecondsAfterFinished` 字段。
- en: Other Hooks
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他钩子
- en: 'Hooks have phases other than just `pre-upgrade`. You can use a hook at any
    of the following stages of a release:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子除了 `pre-upgrade` 之外还有其他阶段。您可以在发布的以下任何阶段使用钩子：
- en: '`pre-install` executes after templates are rendered, but before any resources
    are created.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-install` 在渲染模板后，但在创建任何资源之前执行。'
- en: '`post-install` executes after all resources are loaded.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-install` 在所有资源加载后执行。'
- en: '`pre-delete` executes on a deletion request before any resources are deleted.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-delete` 在删除请求前执行，而不是删除任何资源。'
- en: '`post-delete` executes on a deletion request after all of the release’s resources
    have been deleted.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-delete` 在删除请求后，释放的所有资源都已删除。'
- en: '`pre-upgrade` executes on an upgrade request after templates are rendered,
    but before any resources are loaded (for example, before a `kubectl apply` operation).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-upgrade` 在渲染模板后，但在加载任何资源之前执行（例如，在 `kubectl apply` 操作之前）。'
- en: '`post-upgrade` executes on an upgrade after all resources have been upgraded.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-upgrade` 在所有资源升级后执行。'
- en: '`pre-rollback` executes on a rollback request after templates are rendered,
    but before any resources have been rolled back.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-rollback` 在回滚请求后，但在回滚任何资源之前执行渲染模板。'
- en: '`post-rollback` executes on a rollback request after all resources have been
    modified.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-rollback` 在回滚请求后，所有资源已被修改时执行。'
- en: Chaining Hooks
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子链
- en: 'Helm hooks also come with the ability to chain them together in a specific
    order, using the `helm.sh/hook-weight` property. The hooks will be run in order
    from lowest to highest, so a Job with a `hook-weight` of 0 will run before one
    with a `hook-weight` of `1`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 钩子还具有将它们按特定顺序链在一起的能力，使用 `helm.sh/hook-weight` 属性。这些钩子将按从低到高的顺序运行，因此具有 `hook-weight`
    为 0 的作业将在具有 `hook-weight` 为 `1` 的作业之前运行：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can find everything you need to know about hooks in the Helm [documentation](https://oreil.ly/NHKvD).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Helm 的 [文档](https://oreil.ly/NHKvD) 中找到关于钩子的所有信息。
- en: Another way to implement more complex deployment situations is by using Kubernetes
    `Operators`. These allow you to build your own custom set of tasks tailored to
    your use-cases, including any special logic or custom steps that need to happen
    as part of deploying new versions of your applications. A common example where
    using an `Operator` makes good sense is for upgrading databases, which often require
    additional maintenance or preparation tasks as part of upgrading to a new version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现更复杂部署情况的方法是使用 Kubernetes 的 `Operators`。这使您能够构建适合您用例的自定义任务集，包括作为部署应用程序新版本一部分需要发生的任何特殊逻辑或自定义步骤。一个常见的使用
    `Operator` 的例子是升级数据库，通常需要作为升级到新版本的一部分进行额外的维护或准备任务。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Developing Kubernetes applications can be tedious if you have to build, push,
    and deploy a container image to test every little code change. Tools like Skaffold
    and Telepresence make this loop much faster, speeding up development.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须构建、推送和部署容器映像以测试每个小的代码更改，那么开发 Kubernetes 应用程序可能会很繁琐。像 Skaffold 和 Telepresence
    这样的工具可以加快这个循环，加快开发速度。
- en: 'In particular, rolling out changes to production is far easier with Kubernetes
    than with traditional servers, provided you understand the basic concepts, and
    how you can customize them to suit your application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，与传统服务器相比，使用 Kubernetes 更容易将更改推广到生产环境，前提是您理解基本概念以及如何自定义它们以适应您的应用程序：
- en: The default `RollingUpdate` deployment strategy in Kubernetes upgrades a few
    Pods at a time, waiting for each replacement Pod to become ready before shutting
    down the old one.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 中默认的 `RollingUpdate` 部署策略每次升级少量 Pod，等待每个替换 Pod 就绪后再关闭旧的 Pod。
- en: Rolling updates avoid downtime at the expense of making the rollout take longer.
    It also means that both old and new versions of your application will be running
    simultaneously during the rollout period.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动更新避免了停机时间，但代价是使部署时间变长。这也意味着在部署期间您的应用的新旧版本将同时运行。
- en: You can adjust the `maxSurge` and `maxUnavailable` fields to fine tune rolling
    updates. Depending on the versions of the Kubernetes API you are using, the defaults
    may or may not be appropriate for your situation.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以调整`maxSurge`和`maxUnavailable`字段来优化滚动更新。取决于您使用的Kubernetes API版本，预设值可能适合也可能不适合您的情况。
- en: The `Recreate` strategy just blows away all the old Pods and starts up new ones
    all at once. This is fast, but results in downtime, so it’s not suitable for user-facing
    applications.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recreate`策略会直接清除所有旧的Pod并一次性启动新的Pod。这很快，但会导致停机时间，因此不适合面向用户的应用程序。'
- en: In a blue/green deployment, all the new Pods are started up and made ready without
    receiving any user traffic. Then all traffic is switched over to the new Pods
    in one go, before retiring the old Pods.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝/绿部署中，所有新的Pod都会启动并准备就绪，但不接收任何用户流量。然后在一次性切换所有流量到新的Pod之前，将所有流量转移到新的Pod上，然后淘汰旧的Pod。
- en: Rainbow deployments are similar to blue/green deployments, but with more than
    two versions in service simultaneously.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彩虹部署类似于蓝/绿部署，但同时有多个版本在服务中。
- en: You can implement blue/green and rainbow deployments in Kubernetes by adjusting
    the labels on your Pods and changing the selector on the frontend Service to direct
    traffic to the appropriate set of Pods. Service mesh tools also add the ability
    to split traffic to different running versions of your application.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过调整Pod的标签并更改前端Service上的选择器来在Kubernetes中实现蓝/绿和彩虹部署，以将流量引导到适当的Pod集合。服务网格工具还增加了将流量分配到应用的不同运行版本的能力。
- en: Helm hooks provide a way to apply certain Kubernetes resources (usually Jobs)
    at a particular stage of a deployment, for example, to run a database migration.
    Hooks can define the order in which resources should be applied during a deployment,
    and cause the deployment to halt if something does not succeed.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm钩子提供了一种在部署的特定阶段应用某些Kubernetes资源（通常是作业）的方法，例如运行数据库迁移。钩子可以定义部署期间应用资源的顺序，并在某些操作失败时导致部署停止。
- en: Knative and OpenFaaS allow you to run “serverless” functions on your clusters,
    making it easy to deploy event-driven architectures wherever you can run Kubernetes
    (pretty much anywhere!).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative和OpenFaaS允许您在集群上运行“无服务器”函数，使得在可以运行Kubernetes的任何地方（几乎任何地方！）部署事件驱动架构变得更加容易。
