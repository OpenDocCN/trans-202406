- en: Chapter 2\. Getting Started with OpenShift and Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. OpenShift 和 Kubernetes 入门
- en: In this chapter, we cover a variety of topics that present a foundational understanding
    of Kubernetes and OpenShift. We begin with an overview of the Kubernetes architecture
    and then describe several deployment options that will enable you to get both
    a basic Kubernetes environment and an OpenShift environment up and running. Next,
    we give an introduction to the command-line tools `kubectl` and `oc`, which are
    used for interacting with Kubernetes and OpenShift respectively. We then introduce
    a short review of the fundamental Kubernetes concepts of pods, deployments, and
    service accounts. In the second half of this chapter, we present several enhancement
    concepts that OpenShift provides over traditional Kubernetes. We then conclude
    this chapter with a discussion of more advanced topics that are often used when
    running Kubernetes or OpenShift in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了多个主题，这些主题构成了对 Kubernetes 和 OpenShift 的基础理解。我们从 Kubernetes 架构概述开始，然后描述了几种部署选项，这些选项可以帮助您快速建立基本的
    Kubernetes 环境和 OpenShift 环境。接下来，我们介绍了用于与 Kubernetes 和 OpenShift 交互的命令行工具 `kubectl`
    和 `oc`。然后，我们简要回顾了 pods、deployments 和 service accounts 的基本 Kubernetes 概念。在本章的后半部分，我们介绍了
    OpenShift 提供的几个增强概念，超越了传统 Kubernetes。最后，我们讨论了在生产环境中运行 Kubernetes 或 OpenShift 时经常使用的更高级的主题。
- en: Kubernetes Architecture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: 'The [Kubernetes architecture](https://oreil.ly/QEYUe) at a high level is relatively
    straightforward. It is composed of a *master node* and a set of *worker nodes*.
    The nodes can be either physical servers or VMs. Users of the Kubernetes environment
    interact with the master node using either a CLI (`kubectl`), an API, or a GUI.
    The master node is responsible for scheduling work across the worker nodes. In
    Kubernetes, the unit of work that is scheduled is called a *pod*, and a pod can
    hold one or more containers. The primary components that exist on the master node
    are the *kube-apiserver*, *kube-scheduler*, *kube-controller-manager,* and *etcd*:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubernetes 架构](https://oreil.ly/QEYUe)在高层次上相对简单。它由一个 *master 节点* 和一组 *worker
    节点* 组成。节点可以是物理服务器或虚拟机。Kubernetes 环境的用户使用 CLI (`kubectl`)、API 或 GUI 与 master 节点进行交互。master
    节点负责在 worker 节点上调度工作。在 Kubernetes 中，被调度的工作单元称为 *pod*，一个 pod 可以包含一个或多个容器。存在于 master
    节点上的主要组件包括 *kube-apiserver*、*kube-scheduler*、*kube-controller-manager* 和 *etcd*：'
- en: kube-apiserver
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: kube-apiserver
- en: The kube-apiserver makes available the Kubernetes API that is used to operate
    the Kubernetes environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: kube-apiserver 提供了用于操作 Kubernetes 环境的 Kubernetes API。
- en: kube-scheduler
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: The kube-scheduler component is responsible for selecting the nodes on which
    pods should be created.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: kube-scheduler 组件负责选择在其上创建 pods 的节点。
- en: kube-controller-manager
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: Kubernetes provides several high-level abstractions for supporting replicas
    of pods, managing nodes, and so on. Each of these is implemented with a controller
    component, which we describe later in this chapter. The kube-controller-manager
    is responsible for managing and running controller components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了几个高级抽象来支持 pods 的副本、节点管理等。每个抽象都由一个控制器组件实现，我们将在本章后面描述。kube-controller-manager
    负责管理和运行控制器组件。
- en: etcd
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: etcd
- en: The etcd component is a distributed key-value store and is the primary datastore
    of the Kubernetes control plane. This component stores and replicates all the
    critical information states of your Kubernetes environment. The key feature of
    etcd is its ability to support a watch. A *watch* is a remote procedure call (RPC)
    mechanism that allows for callbacks to functions on key-value create, update,
    or delete operations. Kubernetes’s outstanding performance and scalability characteristics
    depend on etcd being a highly efficient data storage mechanism.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: etcd 组件是一个分布式键值存储，是 Kubernetes 控制平面的主要数据存储。该组件存储和复制 Kubernetes 环境中所有关键信息状态。etcd
    的关键特性是支持 *watch*。*Watch* 是一种远程过程调用（RPC）机制，允许在键值创建、更新或删除操作时回调函数。Kubernetes 出色的性能和可伸缩性特性依赖于
    etcd 作为高效的数据存储机制。
- en: 'The worker nodes are responsible for running the pods that are scheduled on
    them. The primary Kubernetes components that exist on worker nodes are the `kubelet`,
    *kube-proxy*, and *container runtime*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点负责运行调度在其上的 pods。存在于工作节点上的主要 Kubernetes 组件包括 `kubelet`、*kube-proxy* 和 *container
    runtime*：
- en: '`kubelet`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubelet`'
- en: The `kubelet` is responsible for making sure that the containers in each pod
    are created and stay up and running. The `kubelet` will restart containers upon
    recognizing that they have terminated unexpectedly or failed other health checks
    defined by the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubelet` 负责确保每个 Pod 中的容器被创建并保持运行状态。在识别到容器异常终止或未通过用户定义的其他健康检查时，`kubelet` 将重新启动容器。'
- en: kube-proxy
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy
- en: One of Kubernetes’s key strengths is the networking support it implements for
    containers. The kube-proxy component provides networking support in the form of
    connection forwarding, load balancing, and mapping of a single IP address to a
    pod. Kube-proxy is unique in that it gives a distributed load-balancing capability
    that is critical to the high availability architecture of Kubernetes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的关键优势之一是其为容器实现的网络支持。kube-proxy 组件提供连接转发、负载均衡以及将单个 IP 地址映射到 Pod 的网络支持。kube-proxy
    的独特之处在于它提供了关键的分布式负载均衡能力，这对 Kubernetes 的高可用架构至关重要。
- en: container runtime
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时
- en: The container runtime component is responsible for running the containers that
    exist in each pod. Kubernetes supports several container runtime environment options,
    including Docker, `rkt`, CRI-O, and containerd.^([1](ch02.html#ch01fn14))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时组件负责运行每个 Pod 中存在的容器。Kubernetes 支持多种容器运行时环境选项，包括 Docker、`rkt`、CRI-O 和 containerd。^([1](ch02.html#ch01fn14))
- en: '[Figure 2-1](#graphical_representation_of_the_kubernet) shows a graphical representation
    of the Kubernetes architecture encompassing a master node and two worker nodes.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](#graphical_representation_of_the_kubernet) 显示了 Kubernetes 架构的图形表示，包括一个主节点和两个工作节点。'
- en: '![](assets/hcok_0201.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0201.png)'
- en: Figure 2-1\. Graphical representation of the Kubernetes architecture
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. Kubernetes 架构的图形表示
- en: As shown in [Figure 2-1](#graphical_representation_of_the_kubernet), users interact
    with the Kubernetes API server using either a GUI or by `kubectl` CLI. Both of
    these use the Kubernetes API to interact with the kube-apiserver on the Kubernetes
    master node. The Kubernetes master node’s kube-scheduler component schedules pods
    to run on different worker nodes. Each pod contains one or more containers and
    is assigned its own IP address.In many real-world applications, Kubernetes deploys
    multiple replicas (running copies) of the same pod to improve scalability and
    ensure high availability. Pods A1 and A2 are pod replicas that differ only in
    the IP address they are allocated. Similarly, Pods B1 and B2 are also replica
    copies of the same pod. The containers located in the same pod are permitted to
    communicate with one another using standard interprocess communication (IPC) mechanisms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [2-1](#graphical_representation_of_the_kubernet) 所示，用户可以使用 GUI 或 `kubectl`
    CLI 与 Kubernetes API 服务器进行交互。这两者都使用 Kubernetes API 与 Kubernetes 主节点上的 kube-apiserver
    进行交互。Kubernetes 主节点的 kube-scheduler 组件调度 Pod 在不同的工作节点上运行。每个 Pod 包含一个或多个容器，并分配了自己的
    IP 地址。在许多实际应用中，Kubernetes 部署同一个 Pod 的多个副本（运行副本）以提高可伸缩性并确保高可用性。Pod A1 和 A2 是仅在分配的
    IP 地址上有所不同的 Pod 副本。同样，Pods B1 和 B2 也是同一个 Pod 的副本。位于同一 Pod 中的容器允许使用标准的进程间通信（IPC）机制进行通信。
- en: In the next section, we present several approaches to getting OpenShift and
    Kubernetes environments up and running.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍几种运行 OpenShift 和 Kubernetes 环境的方法。
- en: Deployment Options for Kubernetes and OpenShift
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 的部署选项
- en: Kubernetes and OpenShift have both reached incredible levels of popularity.
    As a result, several options are available for deploying either basic Kubernetes
    or Red Hat’s OpenShift Kubernetes distribution. In the following sections, we
    summarize the different types of deployment options that are currently available,
    including Red Hat’s CodeReady Containers, IBM Cloud, and several OpenShift deployment
    options.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 都已经达到了令人难以置信的流行水平。因此，目前有几种可用于部署基本 Kubernetes 或 Red Hat
    的 OpenShift Kubernetes 分发的选项。在接下来的几节中，我们总结了当前可用的不同部署选项，包括 Red Hat 的 CodeReady
    Containers、IBM Cloud 和几种 OpenShift 部署选项。
- en: Red Hat’s CodeReady Containers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Red Hat 的 CodeReady Containers
- en: Red Hat provides a minimal preconfigured OpenShift version 4 cluster called
    [CodeReady Containers](https://oreil.ly/1rI07) that you can run on your laptop
    or desktop computer. The CodeReady OpenShift environment is intended to be used
    for development and testing purposes. CodeReady Containers provide a fully functional
    cloud development environment on your local machine and contain all the tooling
    necessary for you to develop container-based applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat 提供了一个名为[CodeReady Containers](https://oreil.ly/1rI07)的最小预配置的 OpenShift
    版本4集群，可以在您的笔记本电脑或台式电脑上运行。CodeReady OpenShift 环境旨在用于开发和测试目的。CodeReady Containers
    在您的本地机器上提供了一个完全功能的云开发环境，并包含了您开发基于容器的应用程序所需的所有工具。
- en: IBM Cloud
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IBM Cloud
- en: '[IBM Cloud](https://cloud.ibm.com) gives users their choice of either a traditional
    Kubernetes cluster or a Red Hat OpenShift cluster. IBM Cloud’s Kubernetes offering
    is a cloud service providing Kubernetes as a Service that brings all of the standard
    Kubernetes features, including intelligent scheduling, self-healing, horizontal
    scaling, service discovery and load balancing, automated rollout and rollbacks,
    and secret and configuration management. In addition, IBM Cloud’s Kubernetes Service
    includes automated operations for cluster deployment, updates, and scaling, expert
    security, optimized configuration, and seamless integration with the IBM Cloud
    Infrastructure platform. It produces highly available multizone clusters across
    6 regions and 35 datacenters. IBM Cloud offers both a free Kubernetes cluster
    with over 40 free services and pay-as-you-go options.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[IBM Cloud](https://cloud.ibm.com) 提供给用户选择传统的 Kubernetes 集群或 Red Hat OpenShift
    集群。IBM Cloud的 Kubernetes 提供的是作为服务的云服务，提供所有标准的 Kubernetes 功能，包括智能调度、自愈、水平扩展、服务发现与负载平衡、自动发布和回滚以及秘密和配置管理。此外，IBM
    Cloud 的 Kubernetes 服务还包括集群部署、更新和扩展的自动化操作，专家安全性、优化配置以及与 IBM Cloud 基础设施平台的无缝集成。它在6个区域和35个数据中心提供高可用的多区域集群。IBM
    Cloud 提供了一个免费的 Kubernetes 集群，包含超过40个免费服务，并提供按使用付费的选项。'
- en: IBM Cloud also provides users with highly available, fully managed [OpenShift
    clusters](https://oreil.ly/qsOdD). IBM’s OpenShift offering implements unique
    security and productivity capabilities designed to eliminate substantial time
    spent on updating, scaling, and provisioning. Additionally, IBM Cloud’s OpenShift
    delivers the resiliency to handle unexpected surges and protects against attacks
    that can lead to financial and productivity losses. In addition to pay-as-you-go
    and subscription options, IBM Cloud offers a free preconfigured OpenShift version
    4.3 environment that is available for four hours at no charge.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Cloud 也为用户提供高可用、完全托管的[OpenShift集群](https://oreil.ly/qsOdD)。IBM的OpenShift产品实施了独特的安全性和生产力功能，旨在消除更新、扩展和配置所需的大量时间。此外，IBM
    Cloud的OpenShift提供了抗击意外激增并防范可能导致财务和生产力损失的攻击的弹性。除了按使用和订阅选项外，IBM Cloud还提供了一个免费的预配置OpenShift版本4.3环境，可以免费使用四小时。
- en: OpenShift Deployment Options
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenShift 部署选项
- en: Several deployment options for OpenShift are defined at the [Getting Started
    with OpenShift](https://www.openshift.com/try) website. The options described
    include installing OpenShift version 4 on your laptop, deploying it in your datacenter
    or public cloud, or having Red Hat manage OpenShift for you. In addition, Red
    Hat offers hands-on OpenShift tutorials and playground OpenShift environments
    for unstructured learning and experimentation. [Figure 2-2](#openshift_deployment_options_available_a)
    shows the myriad of OpenShift deployment options available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Getting Started with OpenShift](https://www.openshift.com/try)网站上定义了多种OpenShift的部署选项。所描述的选项包括在您的笔记本电脑上安装OpenShift版本4，将其部署在您的数据中心或公共云中，或让Red
    Hat为您管理OpenShift。此外，Red Hat还提供了面向OpenShift的实践教程和OpenShift游乐场环境，供非结构化学习和实验使用。[图2-2](#openshift_deployment_options_available_a)展示了可用的OpenShift部署选项的多样性。
- en: '![](assets/hcok_0202.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0202.png)'
- en: Figure 2-2\. OpenShift deployment options available at [Get Started with OpenShift](https://www.openshift.com/try)
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. OpenShift 部署选项详见[Get Started with OpenShift](https://www.openshift.com/try)
- en: In the next section, we describe the command-line tools used for interacting
    with these platforms.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍用于与这些平台交互的命令行工具。
- en: Kubernetes and OpenShift Command-Line Tools
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 命令行工具
- en: As discussed in [Chapter 1](ch01.html#kubernetes_and_openshift_overview), OpenShift
    provides a 100% conformant Kubernetes platform and supplements it with a variety
    of tools and capabilities focused on improving the productivity of developers
    and IT operations. In this section, we begin with an introduction to `kubectl`
    and `oc`, which are the standard command-line tools used for interacting with
    Kubernetes and OpenShift respectively. We present several concepts that OpenShift
    uses to represent the enhancements it serves over traditional Kubernetes. OpenShift
    concepts that we describe include authentication, projects, applications, security
    contexts, and image streams.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](ch01.html#kubernetes_and_openshift_overview) 所述，OpenShift 提供了一个符合
    Kubernetes 平台标准的平台，并通过各种工具和能力来提高开发人员和 IT 运营的生产力。在本节中，我们首先介绍 `kubectl` 和 `oc`，它们分别是与
    Kubernetes 和 OpenShift 交互的标准命令行工具。我们介绍了几个 OpenShift 用来表示其在传统 Kubernetes 上提供的增强功能的概念。我们描述的
    OpenShift 概念包括认证、项目、应用、安全上下文和镜像流。
- en: 'After covering some core concepts in Kubernetes, the next sections give several
    examples in the form of YAML files. For all Kubernetes environments, the samples
    included can be run using the standard Kubernetes command-line tool `kubectl`.
    Many Kubernetes environments, including the ones mentioned earlier in this chapter,
    describe how `kubectl` can be installed. Once you have your Kubernetes environment
    up and running and `kubectl` installed, all of the YAML file samples in the following
    sections can be run by first saving the YAML to a file (e.g., *kubesample1.yaml*)
    and then by running the following `kubectl` command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 Kubernetes 的一些核心概念之后，接下来的章节将以 YAML 文件的形式给出几个示例。对于所有 Kubernetes 环境，可以使用标准的
    Kubernetes 命令行工具 `kubectl` 运行所包含的样本。许多 Kubernetes 环境，包括本章前面提到的环境，都描述了如何安装 `kubectl`。一旦您的
    Kubernetes 环境运行起来并安装了 `kubectl`，则以下几节中的所有 YAML 文件样本都可以通过首先将 YAML 保存到文件（例如 *kubesample1.yaml*），然后运行以下
    `kubectl` 命令来运行：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As previously discussed, the OpenShift distribution of Kubernetes adds several
    new enhancements and capabilities beyond those used by traditional Kubernetes.
    OpenShift provides access to these features by extending the capabilities of `kubectl`.
    To make it explicit that the OpenShift version of `kubectl` has extended functionality,
    OpenShift renamed its version of `kubectl` to be a new command-line tool called
    `oc.` Thus, the following is equivalent to the previous `kubectl` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的那样，OpenShift Kubernetes 分发增加了几项新的增强功能和能力，超越了传统 Kubernetes 的使用方式。OpenShift
    通过扩展 `kubectl` 的功能来提供对这些功能的访问。为了明确表明 OpenShift 版本的 `kubectl` 具有扩展功能，OpenShift
    将其 `kubectl` 版本重命名为一个新的命令行工具叫做 `oc.` 因此，以下命令等效于之前的 `kubectl` 命令：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to one-for-one matching support for all `kubectl` commands, `oc`
    adds commands for administrative functions like managing roles and role bindings
    for users and groups.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对所有 `kubectl` 命令提供一对一的匹配支持外，`oc` 还添加了用于管理用户和组的角色和角色绑定等管理功能的命令。
- en: For more information on the breadth of commands available from the OpenShift
    `oc` CLI, please see the [OpenShift command line documentation](https://oreil.ly/7NQW3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 OpenShift `oc` CLI 提供的命令的广度，请参阅 [OpenShift 命令行文档](https://oreil.ly/7NQW3)。
- en: Kubernetes Fundamentals
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 基础知识
- en: Kubernetes has several concepts that are specific to its model for managing
    containers. In this section we briefly review key Kubernetes concepts, including
    pods, deployments, and service accounts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 具有几个与其管理容器模型相关的概念。在本节中，我们简要回顾了关键的 Kubernetes 概念，包括 pod、部署和服务账户。
- en: What’s a Pod?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Pod？
- en: 'Because Kubernetes supports the management and orchestration of containers,
    you would assume that the smallest deployable unit supported by Kubernetes would
    be a container. However, the designers of Kubernetes learned from experience^([2](ch02.html#ch01fn15))
    that it was more optimal to have the smallest deployable unit be something that
    could hold multiple containers. In Kubernetes, this smallest deployable unit is
    called a *pod*. A pod can hold one or more application containers. The application
    containers that are in the same pod have the following benefits:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Kubernetes 支持容器的管理和编排，您可能会认为 Kubernetes 支持的最小可部署单元是一个容器。然而，Kubernetes 的设计者从经验中学到，最小的可部署单元最好是能够容纳多个容器的单元。在
    Kubernetes 中，这个最小的可部署单元称为 *pod*。一个 pod 可以容纳一个或多个应用程序容器。位于同一个 pod 中的应用程序容器具有以下好处：
- en: They share an IP address and port space
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们共享一个 IP 地址和端口空间
- en: They share the same hostname
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们共享相同的主机名
- en: They can communicate with one another using native IPC
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用本地 IPC 相互通信
- en: In contrast, application containers that run in separate pods are guaranteed
    to have different IP addresses and different hostnames. Essentially, containers
    in different pods should be viewed as running on different servers even if they
    ended up on the same node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，运行在单独 Pod 中的应用容器保证拥有不同的 IP 地址和不同的主机名。实质上，不同 Pod 中的容器应被视为运行在不同的服务器上，即使它们最终在同一个节点上结束。
- en: 'Kubernetes contributes a robust set of features that make pods easy to use:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一组强大的功能，使得 Pod 容易使用：
- en: Easy-to-use pod management API
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 易于使用的 Pod 管理 API
- en: Kubernetes provides the `kubectl` CLI, which supports a variety of operations
    on pods, including creating, viewing, deleting, updating, interacting, and scaling
    pods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供`kubectl`命令行界面，支持对 Pod 进行各种操作，包括创建、查看、删除、更新、交互和扩展 Pod。
- en: File copy support
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文件复制支持
- en: Kubernetes makes it very easy to copy files back and forth between your local
    host machine and your pods running in the cluster.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 让在本地主机和在集群中运行的 Pod 之间复制文件变得非常简单。
- en: Connectivity from your local machine to your pod
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地计算机到 Pod 的连接性
- en: In many cases, you will want to have network connectivity from your local host
    machine to your pods running in the cluster. Kubernetes supports port forwarding
    whereby a network port on your local host machine is connected via a secure tunnel
    to a port on your pod that is running in the cluster. This is an excellent feature
    to assist in debugging applications and services without having to expose them
    publicly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您可能希望从本地主机到集群中运行的 Pod 的网络连接。Kubernetes 支持端口转发，通过安全隧道将本地主机上的网络端口连接到集群中运行的
    Pod 上的端口。这是一个非常有用的功能，可帮助调试应用程序和服务，而无需将它们公开。
- en: Volume storage support
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 卷存储支持
- en: Kubernetes pods support the attachment of remote network storage volumes to
    enable the containers in pods to access persistent storage that remains long after
    the lifetime of the pods and the containers that initially utilized the storage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Pod 支持挂载远程网络存储卷，以使 Pod 中的容器能够访问持久存储，即使 Pod 和最初利用该存储的容器的生命周期结束后仍然保留。
- en: Probe-based health-check support
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 基于探针的健康检查支持
- en: Kubernetes provides health checks in the form of probes to ensure that the main
    processes of your containers are still running. In addition, Kubernetes administers
    liveness checks that ensure the containers are actually functioning and capable
    of doing real work. With this health-check support, Kubernetes can recognize if
    your containers have crashed or become nonfunctional and restart them on your
    behalf.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供基于探针的健康检查，以确保容器的主要进程仍在运行。此外，Kubernetes 还执行活跃性检查，确保容器实际上正在运行并能够执行真正的工作。借助这种健康检查支持，Kubernetes
    可以识别出您的容器是否崩溃或变得无法使用，并代表您重新启动它们。
- en: How Do I Describe What’s in My Pod?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何描述我的 Pod 中有什么？
- en: 'Pods and all other resources managed by Kubernetes are described using a YAML
    file. The following is a simple YAML file that describes a rudimentary pod resource:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 和其他所有由 Kubernetes 管理的资源都使用 YAML 文件进行描述。以下是描述基本 Pod 资源的简单 YAML 文件：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This YAML file contains the following fields and sections:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此 YAML 文件包含以下字段和部分：
- en: '`apiVersion`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion`'
- en: This field is used to declare which version of the Kubernetes API schema is
    being used. Kubernetes continues to experience rapid growth in features and functionality.
    It manages the complexity that results from its growth in capabilities by supporting
    multiple versions of its API. By setting the `apiVersion` field, you can control
    the API version that your resource uses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段用于声明使用的 Kubernetes API 架构的版本。Kubernetes 在功能和功能上继续快速增长。通过支持其 API 的多个版本，Kubernetes
    管理其增长能力所导致的复杂性。通过设置`apiVersion`字段，您可以控制资源使用的 API 版本。
- en: '`kind`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`'
- en: Use the `kind` field to identify the type of resource the YAML file is describing.
    In the preceding example, the YAML file declares that it is describing a `Pod`
    object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kind`字段来识别 YAML 文件描述的资源类型。在上述示例中，YAML 文件声明它描述的是一个`Pod`对象。
- en: '`metadata`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata`'
- en: The `metadata` section contains information about the resource that the YAML
    is defining. In the preceding example, the `metadata` contains a name field that
    declares the name of this pod. The `metadata` section can contain other types
    of identifying information, such as labels and annotations. We describe these
    in more detail in [“Deployments”](#deployments).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata` 部分包含有关 YAML 定义的资源的信息。在上述示例中，`metadata` 包含一个名为 name 的字段，声明了此 Pod
    的名称。`metadata` 部分还可以包含其他类型的标识信息，例如标签和注释。我们将在 [“Deployments”](#deployments) 中更详细地描述这些内容。'
- en: '`spec`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`'
- en: The `spec` section provides a specification for what the desired state for this
    resource should be. As shown in the example, the desired state for this pod is
    to have a container with the name `nginx` that is built from the Docker image
    identified as `nginx:1.7.9`*.* The container shares the IP address of the pod
    it is contained in, and the `containerPort` field is used to allocate this container
    a network port (in this case, `80`) that it can use to send and receive network
    traffic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分提供了此资源的期望状态的规范。如示例所示，此 Pod 的期望状态是具有名称为 `nginx` 的容器，该容器由标识为 `nginx:1.7.9`
    的 Docker 镜像构建。容器共享其所在 Pod 的 IP 地址，而 `containerPort` 字段用于分配此容器可用于发送和接收网络流量的网络端口（在本例中为
    `80`）。'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `apply` command will either create a resource or update any existing matching
    resources. There is also a supported `create` command that will assume the resources
    described by the YAML document do not yet exist. You can typically use `apply`
    wherever you use `create`. In some cases, such as the special `generateName` attribute,
    only `create` is supported.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 命令将创建一个资源或更新任何现有的匹配资源。还支持 `create` 命令，该命令将假定尚不存在由 YAML 文档描述的资源。通常情况下，您可以在任何需要
    `create` 的地方使用 `apply`。在某些情况下，例如特殊的 `generateName` 属性，仅支持 `create`。'
- en: 'To run the previous example, save the file as *pod.yaml*. You can now run it
    by doing the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行前面的示例，请将文件保存为 *pod.yaml*。现在可以通过以下方式运行它：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running this command, you should see the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该会看到以下输出：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To confirm that your pod is actually running, use the `kubectl get pods` command
    to verify:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认您的 Pod 是否真正运行，请使用 `kubectl get pods` 命令进行验证：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After running this command, you should see output similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该会看到类似以下的输出：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the pod is running, you can also view the logs of the process running
    within the pod with the `logs` command (if there are multiple containers, select
    the specific container you want to view with the `-c` option):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Pod 运行时，您还可以使用 `logs` 命令查看 Pod 内运行进程的日志（如果有多个容器，请使用 `-c` 选项选择要查看的特定容器）：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you need to debug your running container, you can create an interactive
    shell that runs within the container by using the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要调试正在运行的容器，可以通过以下命令在容器内创建一个交互式 shell：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command instructs Kubernetes to run an interactive shell for the container
    that runs in the pod named `nginx`. Because this pod has only one container, Kubernetes
    knows which container you want to connect to even if you have not specified the
    container name. Accessing the container interactively to modify it at runtime
    is typically considered a bad practice. However, interactive shells can be useful
    as you are learning or debugging apps before deploying to production. After you
    run the preceding command, you can interact with the container’s runtime environment,
    as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指示 Kubernetes 为名为 `nginx` 的 Pod 中运行的容器启动一个交互式 shell。因为此 Pod 只有一个容器，所以即使您没有指定容器名称，Kubernetes
    也知道您要连接的容器。通常认为在运行时访问容器的交互式 shell 是一种不良实践。然而，在学习或调试应用程序部署到生产之前，交互式 shell 可能是有用的。运行前述命令后，您可以与容器的运行时环境进行交互，如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If your pod has multiple containers within it, you will need to include the
    container name as well in your `kubectl exec` command. To do this, use the `-c`
    option and include the container name in addition to the pod name. Here is an
    example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Pod 包含多个容器，则在 `kubectl exec` 命令中还需要包含容器名称。为此，请使用 `-c` 选项，并在 Pod 名称之外包含容器名称。以下是一个示例：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To delete the pod that you just created, run the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除刚刚创建的 Pod，请运行以下命令：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the following confirmation that the pod has been deleted:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到已删除 Pod 的以下确认：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When using Kubernetes, you can expect to have large numbers of pods running
    in a cluster. In the next section, we describe how labels and annotations are
    used to help you keep track of and identify your pods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Kubernetes 时，您可以期望在集群中运行大量的 pod。在接下来的部分中，我们描述了如何使用标签和注释来帮助您跟踪和识别您的 pod。
- en: Deployments
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: '*Deployments* are a high-level Kubernetes abstraction that not only allow you
    to control the number of pod replicas that are instantiated, but also provide
    support for rolling out new versions of the pods. Deployments are configurable
    such that they can leverage extra resources for faster rollouts that have no downtime,
    or they can perform slower rollouts that do canary testing. The advantage of a
    slower rollout is that it can reduce the risk and validate new software by releasing
    the software to a small percentage of users, thus ensuring that the new version
    of the application is stable. Deployments rely on the `ReplicaSet` resource to
    manage pod replicas and then add pod version management support on top of this
    capability. Deployments also enable newly rolled-out versions of pods to be rolled
    back to previous versions if there is something wrong with the new versions of
    the pods. Furthermore, deployments support two options for upgrading pods, `Recreate`
    and `RollingUpdate`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署* 是 Kubernetes 的高级抽象，不仅允许您控制实例化的 pod 副本数目，还支持新版本的 pod 的逐步发布。部署是可配置的，以便利用额外的资源进行无
    downtime 的快速发布，或者进行包含金丝雀测试的较慢发布。较慢发布的优势在于它可以通过将软件发布给一小部分用户来降低风险并验证新软件，从而确保新版本的应用程序稳定。部署依赖于
    `ReplicaSet` 资源来管理 pod 副本，然后在此能力之上添加 pod 版本管理支持。部署还允许将新发布的 pod 版本回滚到先前的版本，如果新版本的
    pod 出现问题。此外，部署支持两种升级 pod 的选项，即 `Recreate` 和 `RollingUpdate`：'
- en: '`Recreate`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recreate`'
- en: The `Recreate` pod upgrade option is very straightforward. In this approach,
    the deployment resource modifies its associated `ReplicaSet` to point to the new
    version of the pod. It then proceeds to terminate all the pods. The `ReplicaSet`
    then notices that all the pods have been terminated and thus spawns new pods to
    ensure that the number of desired replicas are up and running. The `Recreate`
    approach will typically result in your pod application not being accessible for
    a period of time, and thus it is not recommended for applications that need to
    always be available.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recreate` pod 升级选项非常直接。在这种方法中，部署资源修改其关联的 `ReplicaSet`，以指向新版本的 pod。然后，它继续终止所有的
    pod。`ReplicaSet` 然后注意到所有的 pod 都已终止，因此生成新的 pod 以确保所需副本数目正在运行。`Recreate` 方法通常会导致您的
    pod 应用程序在一段时间内不可访问，因此不建议对需要始终可用的应用程序使用此方法。'
- en: '`RollingUpdate`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`RollingUpdate`'
- en: Kubernetes’s deployment resource also provides a `RollingUpdate` option. With
    the `RollingUpdate` option, your pods are replaced with the newer versions incrementally
    over time. This approach results in there being a mixture of both the old version
    and the new version of the pod running simultaneously and thus avoids having your
    pod application unavailable during this maintenance period. The readiness of each
    pod is measured and used to inform kube-proxy and ingress controllers which pod
    replicas are available to handle network requests to ensure that no requests are
    dropped during the update process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的部署资源还提供了 `RollingUpdate` 选项。通过 `RollingUpdate` 选项，您的 pod 会逐步被新版本替换。这种方法会导致旧版本和新版本的
    pod 同时运行，从而在维护期间避免使您的 pod 应用程序不可用。每个 pod 的就绪状态会被测量，并用于通知 kube-proxy 和入口控制器，哪些
    pod 副本可用来处理网络请求，以确保在更新过程中不会丢失任何请求。
- en: 'The following is an example YAML specification for a deployment that uses the
    `RollingUpdate` option:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `RollingUpdate` 选项的部署的 YAML 规范示例：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous deployment example encompasses many of the characteristics that
    we have seen in `ReplicaSet`s and pods. In its metadata it contains labels and
    annotations. For the deployment, an annotation with `deployment.kubernetes.io/​revi⁠sion`
    as the key and `1` as its value provides information that this is the first revision
    of the contents in this deployment. Similar to `ReplicaSet`s, the deployment declares
    the number of replicas it provides and uses a `matchLabels` field to declare what
    labels it uses to identify the pods it manages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的部署示例包含了我们在`ReplicaSet`s和Pod中看到的许多特征。在其元数据中，它包含标签和注释。对于部署，一个以`deployment.kubernetes.io/revision`为键，值为`1`的注释提供了此部署内容的第一个修订版信息。与`ReplicaSet`s类似，部署声明了其提供的副本数量，并使用`matchLabels`字段声明用于识别其管理的Pod的标签。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Label matching is a very common aspect of Kubernetes API. If you need to organize
    or categorize resources, add descriptive labels that serve as lightweight metadata.
    You can also query or find resources using the `-l` option in kubectl like `kubectl
    get` or `kubectl patch`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 标签匹配是Kubernetes API中非常常见的一个方面。如果需要组织或分类资源，请添加描述性标签，作为轻量级元数据。您还可以使用`kubectl get`或`kubectl
    patch`中的`-l`选项查询或查找资源。
- en: Similar to `ReplicaSet`s, the deployment has both a `spec` section for the deployment
    and a nested `spec` section inside a `template` that is used to describe the containers
    that comprise the pod replicas managed by this deployment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ReplicaSet`s类似，部署（deployment）既有一个用于描述部署的`spec`部分，也有一个嵌套在`template`内部的`spec`部分，用于描述由此部署管理的Pod副本的容器。
- en: The fields that are new and specific to a deployment resource are the `strategy`
    field and its subfields of `type` and `RollingUpdate`. The `type` field is used
    to declare the deployment strategy being used and can currently be set to `Recreate`
    or `RollingUpdate`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 部署资源中新的并且特定的字段是`strategy`字段及其子字段`type`和`RollingUpdate`。`type`字段用于声明正在使用的部署策略，目前可以设置为`Recreate`或`RollingUpdate`。
- en: 'If the `RollingUpdate` option is selected, the subfields of `maxUnavailable`
    and `maxSurge` need to be set as well. The options are used as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了`RollingUpdate`选项，则还需要设置`maxUnavailable`和`maxSurge`的子字段。选项的使用如下：
- en: '`maxSurge`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge`'
- en: The `maxSurge RollingUpdate` option enables extra resources to be allocated
    during a rollout. The value of this option can be set to a number or a percentage.
    As a simple example, assume a deployment is supporting three replicas and `maxSurge`
    is set to `2`. In this scenario, there will be a total of five replicas available
    during the `RollingUpdate`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge RollingUpdate`选项在滚动更新期间允许分配额外的资源。此选项的值可以设置为数字或百分比。作为一个简单的例子，假设一个部署支持三个副本，并且`maxSurge`设置为`2`。在这种情况下，在`RollingUpdate`期间将有总共五个副本可用。'
- en: At the peak of the deployment, there will be three replicas with the old version
    of the pods running and two with the new version of the pods running. At this
    point, one of the old version pod replicas will need to be terminated, and then
    another replica of the new pod version can be created. At this stage, there would
    be a total of five replicas, three that have the new revision and two that have
    the old version of the pods. Finally, having reached a point of the correct number
    of pod replicas being available with the new version, the two pods with the old
    version can be terminated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署的高峰期，将会有三个使用旧版本Pod的副本和两个使用新版本Pod的副本运行。在这一点上，需要终止一个旧版本Pod副本，然后可以创建另一个新版本Pod的副本。在这个阶段，将会有总共五个副本，其中三个具有新修订版，两个具有旧版本Pod。最终，当达到新版本的正确数量的Pod副本可用时，两个旧版本的Pod可以被终止。
- en: '`maxUnavailable`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxUnavailable`'
- en: This `RollingUpdate` option is used to declare the number of the deployment
    replica pods that may be unavailable during the update. It can be set to either
    a number or a percentage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此`RollingUpdate`选项用于声明在更新期间可能不可用的部署副本Pod的数量。可以将其设置为数字或百分比。
- en: 'The following YAML example shows a deployment that has been updated to initiate
    a rollout:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的YAML示例展示了一个已更新以启动一个滚动更新的部署：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that a new annotation label with a key of `kubernetes.op/change-cause`
    has been added with a value that denotes an update to the version of nginx running
    in the container. Also notice that the name of the image used by the container
    in the `spec` section has changed to `nginx:1.13.10`. This declaration is what
    actually drives the pod replicas managed by the deployment to now have a new version
    of the container images when the upgrade occurs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，已添加了一个新的带有键`kubernetes.op/change-cause`的注释标签，并且该值表示容器中运行的nginx版本已更新。还请注意，在`spec`部分中用于容器的镜像名称已更改为`nginx:1.13.10`。这个声明实际上驱动了由部署管理的
    Pod 副本现在在升级发生时具有新版本的容器镜像。
- en: 'To demonstrate the capabilities of deployments, let’s run the two previous
    examples. Save the first deployment example as *deploymentset.yaml* and the second
    example as *deploymentset2.yaml*. You can now run the first deployment example
    by doing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示部署的功能，让我们运行前两个示例。将第一个部署示例保存为*deploymentset.yaml*，将第二个示例保存为*deploymentset2.yaml*。现在，您可以通过以下方式运行第一个部署示例：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After running this command, you should see the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该会看到以下输出：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To confirm that your pod replicas managed by the deployment are actually running,
    use the `kubectl get pods` command to verify:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认您的由部署管理的 Pod 副本是否实际在运行，请使用`kubectl get pods`命令进行验证：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After running this command, you should see output similar to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该会看到类似以下的输出：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With deployments, we have a new command called `kubectl get deployments` that
    provides status on the deployments as they update their images. Run this command
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署，我们有了一个名为`kubectl get deployments`的新命令，它在它们更新其镜像时提供部署状态。请按以下方式运行此命令：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After running this command, you should see output similar to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该会看到类似以下的输出：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now to make things interesting, let’s update the image in our deployment by
    applying the second deployment example that we saved in *deploymentset2.yaml*.
    Note that we could have just updated the original YAML that we saved in *deploymentset.yaml*
    instead of using two separate files. We begin the update by doing the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让事情变得有趣，让我们通过应用我们在*deploymentset2.yaml*中保存的第二个部署示例来更新部署中的镜像。请注意，我们本可以只更新我们在*deploymentset.yaml*中保存的原始
    YAML，而不是使用两个单独的文件。我们通过以下步骤开始更新：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After running this command, you should see the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该会看到以下输出：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when we rerun the `kubectl get deployments` command, which provides status
    on the deployments as they update their images, we see a much more interesting
    result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们重新运行`kubectl get deployments`命令时，该命令会提供有关部署状态的信息，因为它们更新其镜像，我们将看到一个更加有趣的结果：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As shown in this output, the deployment currently has three pod replicas running.
    Three of the pod replicas are up to date, which means they are now running the
    updated nginx image. In addition, there are three pod replicas in total, and of
    these three replicas, two are available to handle requests. After some amount
    of time, when the rolling image update is complete, we reach the desired state
    of having three updated pod replicas available. We can confirm this by rerunning
    the `kubectl get deployments` command and viewing that the output now matches
    our desired state:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如此输出所示，当前部署有三个正在运行的 Pod 副本。其中三个 Pod 副本已经更新为运行更新后的 nginx 镜像。此外，总共有三个 Pod 副本，其中两个可用于处理请求。在一段时间后，当滚动更新完成时，我们达到了希望的状态，即有三个更新后的
    Pod 副本可用。我们可以通过重新运行`kubectl get deployments`命令来确认，查看输出现在与我们的期望状态匹配：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To delete the deployment that was just created, run the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除刚刚创建的部署，请运行以下命令：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should get the following confirmation that the deployment has been deleted:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下确认，即部署已被删除：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deployments also include commands for pausing rollouts, resuming rollouts, and
    rolling back the update of an image. The commands are quite helpful if you have
    some concerns about the new image being rolled out that merits investigation or
    if you determine that the updated image being rolled out is problematic and needs
    to be rolled back to a previous version. See the [Kubernetes Deployment documentation](https://oreil.ly/BJ115)
    for more information on how to use these deployment capabilities.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还包括命令来暂停部署、恢复部署以及回滚图像更新。如果您对正在部署的新图像有一些值得调查的顾虑，或者确定正在部署的更新图像有问题并且需要回滚到先前的版本，这些命令将非常有帮助。详见[Kubernetes部署文档](https://oreil.ly/BJ115)，了解如何使用这些部署功能的更多信息。
- en: In the next section, we examine the extra steps that are needed to run the previous
    examples in a secure Kubernetes production-level environment such as OpenShift.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨在安全的Kubernetes生产级环境（如OpenShift）中运行先前示例所需的额外步骤。
- en: Running the Pod and Deployment Examples in Production on OpenShift
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在OpenShift上生产环境中运行Pod和部署示例
- en: 'The pod and deployment examples presented in the previous sections are perfect
    for instructional purposes and for running in a local development environment.
    When running in production on a highly secure Kubernetes platform such as OpenShift,
    there are other factors that need to be addressed. First, the nginx container
    image we used in the previous examples is configured to run as a privileged root
    user. By default, secure production Kubernetes platforms such as OpenShift are
    configured to not allow a container image to run as root. This is because running
    a container image as root increases the risk that malicious code could find a
    way to cause harm to the host system.^([3](ch02.html#ch01fn16)) To address this
    issue, we will replace the nginx container used earlier in this chapter with a
    version of the image that does not need to run as a privileged root user. The
    nginx container image from Bitnami runs as a nonroot container and can be used
    in a production OpenShift environment. The following example is an updated version
    of our previously created *pod.yaml*, which uses the Bitnami nonroot nginx container
    image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中呈现的Pod和部署示例非常适合教学目的以及在本地开发环境中运行。但在像OpenShift这样的高度安全的Kubernetes平台上运行时，需要考虑其他因素。首先，在先前示例中使用的nginx容器镜像被配置为以特权根用户运行。默认情况下，像OpenShift这样的安全生产Kubernetes平台配置为不允许容器镜像以根身份运行。这是因为以根身份运行容器镜像会增加恶意代码可能对主机系统造成损害的风险。^([3](ch02.html#ch01fn16))
    为解决这个问题，我们将在本章前面创建的*pod.yaml*示例中使用一个不需要以特权根用户运行的图像版本，来替换先前使用的nginx容器。Bitnami提供的nginx容器镜像作为非根容器运行，可以在生产OpenShift环境中使用。以下示例是我们之前创建的*pod.yaml*的更新版本，使用了Bitnami的非根nginx容器镜像：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that all resources are either *cluster scoped,* meaning that only one
    resource of that kind can exist within the cluster, or *namespace scoped,* meaning
    that the resources are isolated from other similar resources on the cluster. Within
    OpenShift, you may also see the term *project,* which predated the concept that
    Red Hat worked with the community to generalize as namespace. *Project* and *namespace*
    are synonymous, and OpenShift will respond to either `get projects` or `get namespaces`.
    You can think of namespaces as like folders within a filesystem that you use to
    assign to a group of users who are collaborating on a collection of files. We
    will talk more about namespaces or projects in [“OpenShift Enhancements”](#openshift_enhancements).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有资源都是*集群范围*，意味着集群中只能存在一个该类资源，或者是*命名空间范围*，意味着这些资源与集群上的其他类似资源隔离。在OpenShift中，您可能还会看到*项目*这个术语，它在Red
    Hat与社区合作通用化为命名空间的概念之前就已存在。*项目*和*命名空间*是同义词，OpenShift将对`get projects`或`get namespaces`作出响应。您可以将命名空间类比为文件系统中的文件夹，用于分配给协作创建一组文件的用户组。我们将在[“OpenShift增强”](#openshift_enhancements)中进一步讨论命名空间或项目。
- en: 'Another issue with our earlier pod and deployment examples that needs to be
    addressed is that when they were created, we did not isolate our resources from
    others by creating a Kubernetes namespace that was specific to our resources.
    Instead, the earlier examples placed our resources in the Kubernetes default namespace.
    To encourage proper isolation of applications, secure production Kubernetes platforms
    such as OpenShift will enforce that your Kubernetes resources are not created
    in the default namespace but instead are created in a user-defined namespace that
    provides the required isolation. To create a properly configured namespace, OpenShift
    provides the `oc new-project` command. OpenShift’s project capability is described
    more thoroughly in [“OpenShift Enhancements”](#openshift_enhancements). For now,
    however, we will use the `oc new-project` command to create a new project called
    `book`, which will provide the required isolation to be able to run our pod example.
    We create our new project by running the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们早期 Pod 和部署示例的另一个问题需要解决的是，在创建它们时，我们没有通过创建一个专用于我们资源的 Kubernetes 命名空间来将我们的资源与其他资源隔离开来。相反，早期示例将我们的资源放置在
    Kubernetes 默认命名空间中。为了鼓励应用程序的正确隔离，安全的生产 Kubernetes 平台（如 OpenShift）将强制执行您的 Kubernetes
    资源不在默认命名空间中创建，而是在提供所需隔离的用户定义命名空间中创建。要创建正确配置的命名空间，OpenShift 提供了 `oc new-project`
    命令。OpenShift 的项目功能在 [“OpenShift Enhancements”](#openshift_enhancements) 中有更详细的描述。然而，目前我们将使用
    `oc new-project` 命令来创建一个名为 `book` 的新项目，这将提供所需的隔离以便运行我们的 Pod 示例。我们通过运行以下命令来创建我们的新项目：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can then use the `oc apply -f` command, pass in our updated *pod.yaml,*
    and use the `-n` option to declare that we want our resources created in the `book`
    namespace:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后可以使用 `oc apply -f` 命令，传入我们更新后的 *pod.yaml* 文件，并使用 `-n` 选项声明我们希望在 `book` 命名空间中创建我们的资源：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have used a nonroot container image and are no longer using the
    default namespace, our pod example will be permitted by OpenShift to run in production.
    We can confirm this is the case by using the `oc get pods` command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用了非根容器镜像，并且不再使用默认命名空间，OpenShift 将允许我们的 Pod 示例在生产环境中运行。我们可以通过使用 `oc get
    pods` 命令来确认这一点：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can clean up and remove the pod example by using the `oc delete pod` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `oc delete pod` 命令清理并移除 Pod 示例：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The same techniques we used for the pod example can be applied to the deployment
    examples as well. Simply update the nginx image that is used in *deploymentset.yaml,*
    and make sure to use the `book` namespace when doing the `oc apply` command. In
    the next section, we’ll introduce another fundamental Kubernetes concept called
    *service accounts,* which are used to provide authentication for key parts of
    the Kubernetes platform.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于 Pod 示例的相同技术也可以应用于部署示例。只需更新用于 *deploymentset.yaml* 中的 nginx 镜像，并确保在执行 `oc
    apply` 命令时使用 `book` 命名空间。在下一节中，我们将介绍 Kubernetes 平台的另一个基本概念，称为 *服务账户*，它们用于为 Kubernetes
    平台的关键部分提供身份验证。
- en: Service Accounts
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务账户
- en: When you interact with your cluster, you often represent yourself as a user
    identity. In the world of Kubernetes, we build intelligence into the system to
    help it interact with its world. Many times, pods may use the Kubernetes API to
    interact with other parts of the system or to spawn jobs. When we deploy a pod,
    it may interact with volume storage, interact with the host filesystem, interact
    with the host networking, or be sensitive to which operating system user it is
    given access to use for filesystem access. In most cases, you want to restrict
    the default permissions for a given pod from doing anything more than the absolute
    basics. Basically, the less surface area that a pod is given access to in the
    cluster, the host operating system, the networking layer, and your storage layer,
    the fewer attack vectors that can be exploited.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与您的集群交互时，您通常将自己表示为用户身份。在 Kubernetes 的世界中，我们将智能构建到系统中，以帮助它与其世界进行交互。许多时候，Pod
    可能使用 Kubernetes API 与系统的其他部分交互或者生成作业。当我们部署一个 Pod 时，它可能与卷存储交互，与主机文件系统交互，与主机网络交互，或者对赋予它的操作系统用户对文件系统访问权限敏感。在大多数情况下，您希望限制给定
    Pod 的默认权限，以免其超出绝对基础功能。基本上，Pod 在集群、主机操作系统、网络层和存储层中被赋予访问权限越少，可以被利用的攻击向量就越少。
- en: For a pod to interact with the system, it is assigned a service account. Think
    of this as a functional identity. The service accounts are subjects that can authenticate
    with kube-apiserver via tokens and are authorized for certain behaviors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 pod 与系统交互，它被分配了一个服务账户。可以将其视为功能性身份。服务账户是可以通过令牌与 kube-apiserver 进行身份验证并被授权执行某些行为的主体。
- en: In some Kubernetes systems, the service account projected into the pod can have
    identity outside of Kubernetes. A powerful use case is when using the open source
    [Istio](https://istio.io) service mesh project with Kubernetes. In this scenario,
    the Istio identity is projected via the service account, and this allows one pod
    to authenticate with another when making service requests. Some cloud providers
    and other security tools also allow for projection of a service account identity
    into the pod, and this allows for authentication with these external platforms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 Kubernetes 系统中，投影到 pod 中的服务账户可能具有 Kubernetes 之外的身份。一个强大的使用情况是在 Kubernetes
    中使用开源[Istio](https://istio.io)服务网格项目。在这种情况下，Istio 身份通过服务账户进行投影，这允许一个 pod 在进行服务请求时与另一个
    pod 进行身份验证。一些云提供商和其他安全工具也允许将服务账户身份投影到 pod 中，这允许与这些外部平台进行身份验证。
- en: In OpenShift, service accounts are also used to associate a grouping of security
    privileges with each pod. The object that OpenShift uses for creating specialized
    groupings of security privileges is called a *security context constraint*. In
    the next section, we provide a more detailed discussion of security context constraints,
    as well as several other important enhancements that OpenShift delivers to supplement
    basic Kubernetes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenShift 中，服务账户还用于将一组安全权限与每个 pod 关联起来。OpenShift 用于创建专门的安全权限组合的对象称为*安全上下文约束*。在下一节中，我们将更详细地讨论安全上下文约束，以及
    OpenShift 提供的其他重要增强功能，以补充基本的 Kubernetes。
- en: OpenShift Enhancements
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift 增强功能
- en: OpenShift introduces several new concepts that it uses to simplify development
    and operations. Approaches that are specific to OpenShift include authentication,
    projects, applications, security contexts, and image streams.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 引入了几个新概念，用于简化开发和运维。OpenShift 特有的方法包括认证、项目、应用程序、安全上下文和镜像流。
- en: Authentication
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: 'Security is paramount to the OpenShift Kubernetes platform. As a result, all
    users must authenticate with the cluster to be able to access it. OpenShift supports
    a variety of common authentication methods, including basic authentication with
    username and password, OAuth access tokens, and X.509 client certificates.^([4](ch02.html#ch01fn17))
    OpenShift provides the `oc login` command for performing authentication, which
    is run by doing the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安全对于 OpenShift Kubernetes 平台至关重要。因此，所有用户必须对集群进行身份验证才能访问它。OpenShift 支持各种常见的认证方法，包括基本认证（用户名和密码）、OAuth
    访问令牌和 X.509 客户端证书。OpenShift 提供了`oc login`命令用于执行身份验证，通过以下方式运行：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In a basic authentication use case, when this command is run, the user will
    be asked to enter the OpenShift Container Platform server URL and whether or not
    secure connections are needed, and then the user will be asked to input their
    username and password. In addition, OpenShift’s configurable OAuth server allows
    for users to integrate OpenShift identity with external providers, such as LDAP
    servers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本认证使用情况下，当运行此命令时，用户将被要求输入 OpenShift 容器平台服务器的 URL 以及是否需要安全连接，然后用户将被要求输入他们的用户名和密码。此外，OpenShift
    的可配置 OAuth 服务器允许用户将 OpenShift 身份与外部提供者（如 LDAP 服务器）集成。
- en: Projects
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目
- en: Standard Kubernetes provides the concept of a [*namespace*](https://oreil.ly/IAiIw),
    which allows you to define isolation for your Kubernetes resources. Namespaces
    enable cluster resources to be divided among a large number of users, and the
    isolation that results from the scoping that they administer keeps users from
    accidentally using someone else’s resource due to a naming collision. Namespaces
    are incredibly useful, and OpenShift has adapted namespaces for grouping applications.
    OpenShift accomplishes this by taking a Kubernetes namespace and adding a special
    standard list of annotations to the namespace. OpenShift refers to this specific
    type of namespace as a *project.* OpenShift uses projects as its mechanism for
    grouping applications. Projects support the notion of access permissions. This
    enables you to add one or more users who have access to the project, and role-based
    access control is used to set the permissions and capabilities that various users
    have when accessing a project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Kubernetes 提供了 [*命名空间*](https://oreil.ly/IAiIw) 的概念，允许您为 Kubernetes 资源定义隔离。命名空间使集群资源可以在大量用户之间分割，通过它们所管理的作用域所产生的隔离，防止用户因命名冲突而意外使用其他人的资源。命名空间非常有用，OpenShift
    已经调整了命名空间以用于应用程序分组。OpenShift 将 Kubernetes 命名空间添加特殊的标准注释列表，将其称为 *项目*。OpenShift
    使用项目作为分组应用程序的机制。项目支持访问权限的概念。这使您可以添加一个或多个具有对项目访问权限的用户，并使用基于角色的访问控制设置不同用户在访问项目时具有的权限和能力。
- en: 'Projects are created using the `oc new-project` command and by providing a
    project name, description, and display name as shown:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `oc new-project` 命令创建项目，并提供项目名称、描述和显示名称，如下所示：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'OpenShift makes it easy to switch between projects by using the `oc project`
    command. Here we switch to a different project called `secondproject`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 通过使用 `oc project` 命令轻松切换项目。在这里，我们切换到名为 `secondproject` 的不同项目：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To view the list of projects that you are authorized to access, you can use
    the `oc get projects` command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您有权访问的项目列表，可以使用 `oc get projects` 命令：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For more information on the use of projects, please see the [OpenShift project
    documentation](https://oreil.ly/xXs4d).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于项目使用的更多信息，请参阅 [OpenShift 项目文档](https://oreil.ly/xXs4d)。
- en: Applications
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: When using a basic Kubernetes environment, one of the more tedious steps that
    needs to be performed by a cloud native application developer is creating their
    own container images. Typically, this involves finding the proper base image and
    creating a `Dockerfile` with all the necessary commands for taking a base image
    and adding in the developer’s code to create an assembled image that can be deployed
    by Kubernetes. OpenShift introduced the [application construct](https://oreil.ly/3RpbY)
    to greatly simplify the process of creating, deploying, and running container
    images in Kubernetes environments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基本的 Kubernetes 环境时，云原生应用程序开发人员需要执行的更繁琐的步骤之一是创建自己的容器镜像。通常情况下，这涉及查找合适的基础镜像，并创建一个
    `Dockerfile`，其中包含将基础镜像与开发人员的代码组合以创建可由 Kubernetes 部署的装配图像所需的所有命令。OpenShift 引入了
    [应用程序构造](https://oreil.ly/3RpbY)，极大地简化了在 Kubernetes 环境中创建、部署和运行容器镜像的过程。
- en: Applications are created using the `oc new-app` command. This command supports
    a variety of options that enable container images to be built many ways. For example,
    with the `new-app` command, application images can be built from local or remote
    Git repositories, or the application image can be pulled from a Docker Hub or
    private image registry. In addition, the `new-app` command supports the creation
    of application images by inspecting the root directory of the repository to determine
    the proper way to create the application image. For example, the OpenShift `new-app`
    command will look for a `JenkinsFile` in the root directory of your repository,
    and if it finds this file, it will use it to create the application image. Furthermore,
    if the `new-app` command does not find a `JenkinsFile`, it will attempt to detect
    the programming language that your application is built in by looking at the files
    in your repository. If it is able to determine the programming language that was
    used, the `new-app` command will locate an acceptable base image for the programming
    language you are using and will use this to build your application image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是使用 `oc new-app` 命令创建的。该命令支持多种选项，可以多种方式构建容器镜像。例如，使用 `new-app` 命令，应用程序镜像可以从本地或远程
    Git 存储库构建，或者可以从 Docker Hub 或私有镜像注册表拉取应用程序镜像。此外，`new-app` 命令支持通过检查存储库的根目录来确定创建应用程序镜像的正确方法。例如，OpenShift
    的 `new-app` 命令将在您的存储库根目录中查找 `JenkinsFile`，如果找到此文件，将使用它来创建应用程序镜像。此外，如果 `new-app`
    命令没有找到 `JenkinsFile`，它将尝试通过查看存储库中的文件来检测您的应用程序使用的编程语言。如果能够确定所使用的编程语言，`new-app`
    命令将找到适合该编程语言的基础镜像，并将用它来构建您的应用程序镜像。
- en: 'The following example illustrates using the the `oc new-app` command to create
    a new application image from an OpenShift example ruby hello world application:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用 `oc new-app` 命令从 OpenShift 示例 ruby hello world 应用程序创建新的应用程序镜像：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This command will create the application as part of whichever OpenShift project
    was most recently selected to be the current context for the user. For more information
    on the application image creation options supported by the `new-app` command,
    see the [OpenShift application creation documentation](https://oreil.ly/3RpbY).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将把应用程序创建为最近为用户选择的 OpenShift 项目的一部分。有关 `new-app` 命令支持的应用程序镜像创建选项的更多信息，请参阅[OpenShift
    应用程序创建文档](https://oreil.ly/3RpbY)。
- en: Security Context Constraints
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全上下文约束
- en: Security is always at the forefront in OpenShift. But with added security can
    come extra complexity and aggravation. If enhanced security is used and a container
    is not given the proper security options, it will fail. If security is relaxed
    to avoid issues, then vulnerabilities can result. In an effort to enable users
    to leverage enhanced security with less aggravation, OpenShift includes a security
    construct called *security context constraints*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenShift 中，安全始终是首要考虑的。但是增强的安全性可能会带来额外的复杂性和麻烦。如果使用了增强的安全性而容器没有获得适当的安全选项，则会失败。如果放宽安全性以避免问题，则可能导致漏洞。为了使用户能够在减少麻烦的同时利用增强的安全性，OpenShift
    包括了一种称为*安全上下文约束*的安全结构。
- en: 'The security context constraints identify a set of security privileges that
    a pod’s container is guaranteed to execute with. Thus, before the pod’s container
    begins execution, it knows what security privileges it will get. The following
    is a list of the common security privilege options that are provided by security
    context constraints:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束标识出一组安全特权，保证 pod 的容器在执行之前知道将获得什么安全特权。以下是安全上下文约束提供的常见安全特权选项列表：
- en: Allow pods to run privileged containers
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 pod 运行特权容器
- en: Security context constraints can declare if a pod is permitted to run privileged
    containers or if it can run only nonprivileged containers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束可以声明 pod 是否被允许运行特权容器或者仅能运行非特权容器。
- en: Require Security-Enhanced Linux (SELinux)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 需要安全增强型 Linux (SELinux)
- en: '[SELinux](https://oreil.ly/SlHNy) is a security architecture for Linux that
    defines access controls for applications, processes, and files on a system. SELinux
    presents extra protections beyond what standard Linux uses. Security context constraints
    provide the `MustRunAs` attribute value for declaring if SELinux must be run by
    a pod’s container and a `RunAsAny` attribute value for declaring if the pod’s
    container can run either standard Linux or SELinux.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[SELinux](https://oreil.ly/SlHNy) 是 Linux 的安全架构，为系统上的应用程序、进程和文件定义访问控制。SELinux
    提供了比标准 Linux 更多的额外保护。安全上下文约束提供了 `MustRunAs` 属性值，用于声明 pod 的容器是否必须运行 SELinux，以及
    `RunAsAny` 属性值，用于声明 pod 的容器是否可以运行标准 Linux 或 SELinux。'
- en: Run the pod’s container as a specific user or as nonroot
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将 pod 的容器作为特定用户或非 root 运行
- en: Containers running as root have a bigger vulnerability footprint than containers
    running as a nonroot. Security context constraints provide a `MustRunAsNonRoot`
    attribute value to denote that a Pod’s container is not permitted to run as root.
    Additionally, the security context constraints use a `RunAsAny` attribute value
    that permits a pod’s container to run as either a root or nonroot user. Finally,
    the security context constraint administers a `MustRunAsRange` attribute value
    that allows a pod’s container to run if the user ID is within a specific range
    of user IDs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以 root 身份运行的容器比以非 root 身份运行的容器具有更大的漏洞足迹。安全上下文约束提供了 `MustRunAsNonRoot` 属性值来表示不允许
    Pod 的容器以 root 身份运行。此外，安全上下文约束使用了 `RunAsAny` 属性值，允许 pod 的容器以 root 或非 root 用户运行。最后，安全上下文约束管理了
    `MustRunAsRange` 属性值，允许 pod 的容器在用户 ID 在特定用户 ID 范围内时运行。
- en: Allow the pod’s container access to File System Group block storage
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 pod 的容器访问文件系统组块存储
- en: Security context constraints can be used to limit the block storage that a pod’s
    container has access to. Block storage portions are identified through the use
    of a File System Group identifier. Security context constraints provide a `RunAsAny`
    attribute value that permits a pod’s container to access any File System Group
    of block storage, as well as a `MustRunAs` attribute value, which is used to denote
    that the pod’s block storage must be in the range of File System Group IDs listed
    in the security context constraint.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束可用于限制 pod 的容器访问的块存储。通过文件系统组标识符标识块存储部分。安全上下文约束提供了 `RunAsAny` 属性值，允许 pod
    的容器访问任何块存储的文件系统组，并提供了 `MustRunAs` 属性值，用于表示 pod 的块存储必须在安全上下文约束中列出的文件系统组 ID 范围内。
- en: 'OpenShift includes several built-in security context constraint profiles that
    can be reused. To view the list of projects that you are authorized to access,
    you can use the `oc get scc` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 包括几个内置安全上下文约束配置文件，可供重复使用。要查看您有权访问的项目列表，可以使用 `oc get scc` 命令：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As shown, OpenShift contributes security context constraint profiles for common
    scenarios, such as privileged, restricted, or running as nonroot. To see all the
    individual capability settings for the security constraint profile, use the `oc
    describe scc` command and pass in the name of the profile that you want more details
    on. For example, if you wanted more details on how powerful the privileged constraint
    profile is, you would invoke the `oc describe scc` command as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，OpenShift 为常见场景贡献了安全上下文约束配置文件，如特权、受限或以非 root 运行。要查看安全约束配置文件的所有单独功能设置，请使用
    `oc describe scc` 命令并传递您想要更多详细信息的配置文件名称。例如，如果您想要更多了解特权约束配置文件的强大功能，可以调用 `oc describe
    scc` 命令如下：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running this command will list a large number of constraint attributes associated
    with this profile. Here are a few of the more interesting ones:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将列出与此配置文件关联的大量约束属性。以下是一些较为有趣的内容：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For comparison purposes, we can run the same command for the restricted profile.
    As shown in the following output, the constraint attribute values are much more
    restrictive than those in the privileged profile:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较目的，我们可以在受限制的配置文件中运行相同的命令。如下输出所示，约束属性值比特权配置文件中的要严格得多：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The key point here is that security context constraint profiles are able to
    group and encapsulate large groups of capability attributes and ensure that all
    the attributes are met before a pod is permitted to execute. This reduces the
    chance of improperly setting the capability attributes and reduces the chance
    of an unexpected pod failure due to an incorrect security setting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点在于安全上下文约束配置文件能够组织和封装大量的能力属性，并确保在允许Pod执行之前满足所有这些属性。这减少了设置能力属性不当的机会，减少了由于安全设置不正确而导致的意外Pod失败的可能性。
- en: Security context constraint profiles are associated with pods by using the Kubernetes
    service account object. For more information on the use of security context constraints,
    see the [OpenShift security context constraints documentation](https://oreil.ly/W41Sq).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文约束配置文件通过使用Kubernetes服务账号对象与Pod相关联。有关使用安全上下文约束的更多信息，请参阅[OpenShift安全上下文约束文档](https://oreil.ly/W41Sq)。
- en: Image Streams
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像流
- en: One of the key steps in deploying a cloud native application is retrieving the
    correct container application image from a repository. When running in production,
    there are several possible pitfalls with this retrieval process. First, container
    images are retrieved by a tag identifier, but it is possible that container images
    can be overwritten, and thus the image that is referenced by the tag can change.
    If this change goes unnoticed, it could result in introducing unexpected errors
    into the cloud native application that is deployed. Second, when running in production,
    the image retrieval process also needs to be supplemented with support for automating
    builds and deployments, and many image repositories are limited in their ability
    to support this automation. Third, in some cases a container image needs to have
    multiple tags associated with it because the container image is used for different
    purposes in different environments. Unfortunately, many image repositories do
    not support the ability to associate multiple tags with a container application
    image.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署云原生应用程序的关键步骤之一是从仓库中检索正确的容器应用程序镜像。在生产环境中，此检索过程可能存在几个潜在问题。首先，容器镜像是通过标记标识符检索的，但可能会发生容器镜像被覆盖的情况，因此标记引用的镜像可能会发生变化。如果这种变化未被注意到，可能会导致部署的云原生应用程序中引入意外错误。其次，在生产环境中，镜像检索过程还需要支持自动化构建和部署，而许多镜像仓库在支持此自动化方面的能力有限。第三，在某些情况下，容器镜像需要具有多个标签与之关联，因为在不同环境中，容器镜像用于不同目的。不幸的是，许多镜像仓库不支持将多个标签与容器应用程序镜像关联的能力。
- en: To address all of these issues, OpenShift introduced the concept of *image streams*.^([5](ch02.html#ch01fn18))
    Image streams are intended to provide a more stable pointer for tagged images.
    The image stream maintains an SHA-256 secure hash function to the image it points
    to in order to ensure that the image is not mistakenly changed. Image streams
    also support multiple tags for images to better support using them in multiple
    environments. In addition, image streams include triggers that enable builds and
    deployments to be started automatically when the image stream is updated. Furthermore,
    image streams can not only reference container images from external repositories,
    but can also be scheduled to periodically reimport the external container image
    to ensure that they always have the most recently updated copy of the container
    image they are referencing in the external repository.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决所有这些问题，OpenShift引入了*镜像流*的概念。^([5](ch02.html#ch01fn18)) 镜像流旨在为标记的镜像提供更稳定的指针。镜像流维护了一个SHA-256安全哈希函数，指向其所指向的镜像，以确保镜像不会被错误地更改。镜像流还支持为镜像提供多个标记，以更好地支持在多个环境中使用它们。此外，镜像流包括触发器，当更新镜像流时可以自动启动构建和部署。此外，镜像流不仅可以引用外部仓库中的容器镜像，还可以安排定期重新导入外部容器镜像，以确保始终具有最新更新的容器镜像副本。
- en: 'Creating and updating image streams is relatively straightforward. The `oc
    import-image` command is used to create an image stream. In the following example,
    the `oc import-image` command is used to create an initial image stream called
    `nginx` with an initial image stream tag for the imported image that has the value
    `1.12`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和更新镜像流相对来说是比较简单的。使用`oc import-image`命令来创建镜像流。在下面的示例中，使用`oc import-image`命令创建了一个名为`nginx`的初始镜像流，其导入的镜像流标签的值为`1.12`：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As shown in this example, the initial container image that is being imported
    into the `nginx` image stream is the image that is located at `centos/nginx-112-centos7`.
    The `confirm` option states that the image stream should be created if it doesn’t
    already exist.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，被导入到 `nginx` 图像流中的初始容器图像是位于 `centos/nginx-112-centos7` 的图像。`confirm` 选项指示，如果尚不存在，则应创建图像流。
- en: 'Once the image stream is created, we can examine it using the `oc describe`
    command. In the following example, the `is` value is the short name for an input
    stream resource. The specific input stream that we want described is the one with
    the name `nginx`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像流后，我们可以使用 `oc describe` 命令来查看它。在以下示例中，`is` 值是输入流资源的简称。我们要描述的特定输入流是名为 `nginx`
    的输入流：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output from this command looks like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出如下所示：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can add an extra tag for this image by using the `oc tag` command. We add
    an `nginx:latest` tag to the existing `nginx:1.12` tag by doing the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `oc tag` 命令为此图像添加额外的标签。我们通过以下方式向现有的 `nginx:1.12` 标签添加一个 `nginx:latest`
    标签：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, we can tag an image from an external repository and schedule this image
    to be periodically reimported by calling the `oc tag` command. As shown in the
    following example, we reference the image from the external repository, associate
    it with an image stream tag, and then add the scheduled option to denote that
    the tag should be periodically updated:^([6](ch02.html#ch01fn19))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过调用 `oc tag` 命令，从外部仓库标记一个图像，并安排定期重新导入该图像。如下例所示，我们引用外部仓库中的图像，并将其与图像流标签关联，然后添加定期更新选项以表示应定期更新该标签：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For more information on the use of image streams, please see the documentation
    on [managing image streams](https://oreil.ly/YMfdZ).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有关图像流使用的更多信息，请参阅 [管理图像流文档](https://oreil.ly/YMfdZ)。
- en: Kubernetes and OpenShift Advanced Topics
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift 高级主题
- en: Several advanced concepts are frequently used when running Kubernetes or OpenShift
    in production. In this section, we discuss these advanced topics, including webhooks,
    admission controllers, role-based access control, and operators.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当在生产环境中运行 Kubernetes 或 OpenShift 时，经常会使用几个高级概念。在本节中，我们讨论这些高级主题，包括 Webhooks、准入控制器、基于角色的访问控制和运算符。
- en: Webhooks
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webhooks
- en: A *webhook* is an HTTP callback.^([7](ch02.html#ch01fn20)) Essentially, a webhook
    enables information to be pushed to an external entity when an interesting event
    is occurring. Typically, an HTTP Post operation is used to push the event information,
    and the event information is most commonly represented as a JSON payload. In Kubernetes,
    webhooks are used for a variety of security-related operations. For example, Kubernetes
    can use a webhook to query an external service to determine if a user has the
    correct privileges to perform a specific operation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*Webhook* 是一个 HTTP 回调。基本上，Webhook 在发生有趣事件时允许向外部实体推送信息。通常，使用 HTTP Post 操作推送事件信息，并且事件信息最常以
    JSON 负载表示。在 Kubernetes 中，Webhook 用于各种与安全相关的操作。例如，Kubernetes 可以使用 Webhook 查询外部服务，以确定用户是否具有执行特定操作的正确权限。'
- en: Webhooks are also used by OpenShift as [a mechanism for triggering builds](https://oreil.ly/bmfyW).
    With webhooks, you can configure your GitHub repository to send an alert whenever
    there is a change in the repository. This alert can be used to kick off a new
    build and, if the build succeeds, perform a deployment as well.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 在 OpenShift 中也被用作 [触发构建的机制](https://oreil.ly/bmfyW)。使用 Webhook，您可以配置
    GitHub 仓库，在仓库发生更改时发送警报。此警报可用于启动新构建，并在构建成功后执行部署。
- en: Webhooks are also used heavily by Kubernetes admission controllers, which are
    described in the next section. For more information on the use of webhooks in
    Kubernetes, see [Webhook Mode in the Kubernetes documentation](https://oreil.ly/Aiw7t).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 在 Kubernetes 的准入控制器中也被大量使用，下一节将对其进行描述。有关 Kubernetes 中 Webhook 使用的更多信息，请参阅
    [Kubernetes 文档中的 Webhook 模式](https://oreil.ly/Aiw7t)。
- en: Admission Controllers
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[准入控制器](https://oreil.ly/Aiw7t)'
- en: The key to keeping your Kubernetes platform secure is to protect it from requests
    that can cause harm. *Admission controllers* are one of the mechanisms that Kubernetes
    uses to protect the platform from harmful requests. In some cases, an admission
    controller will prevent a request from creating the Kubernetes object at all.
    In other cases, the admission controller will allow the request to be processed,
    but it will modify the request to make it safer. As an example, if a request comes
    in to start a pod and the request does not specify whether the pod should be started
    in privileged or nonprivileged mode, the admission controller could change the
    request such that in this situation the pod is requested to be started in nonprivileged
    mode.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 Kubernetes 平台安全的关键是防止可能造成损害的请求。*准入控制器*是 Kubernetes 使用的一种机制，用于保护平台免受有害请求的影响。在某些情况下，准入控制器会阻止请求创建
    Kubernetes 对象。在其他情况下，准入控制器会允许请求被处理，但会修改请求以使其更安全。例如，如果收到一个启动 Pod 的请求，并且请求没有指定 Pod
    应以特权模式还是非特权模式启动，准入控制器可以修改请求，以确保 Pod 以非特权模式启动。
- en: A number of admission controllers are embedded in the kube-controller-manager,
    and many are enabled in Kubernetes by default to keep the Kubernetes platform
    secure. In some cases, the admin needs enforcement beyond the scope of the included
    admission controllers. Kubernetes allows the admin to add additional admission
    controllers via registration of webhooks to process requests on Kubernetes objects.
    We will go into more detail regarding admission controllers in [Chapter 3](ch03.html#advanced_resource_management).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 kube-controller-manager 中内嵌了多个准入控制器，默认情况下很多准入控制器都是启用的，以确保 Kubernetes 平台的安全性。然而，在某些情况下，管理员需要超出这些内置准入控制器的限制。Kubernetes
    允许管理员通过注册 Webhook 来添加额外的准入控制器，以处理 Kubernetes 对象上的请求。我们将在[第三章](ch03.html#advanced_resource_management)详细讨论准入控制器。
- en: Role-Based Access Control
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: Authorization in Kubernetes is integrated into the platform. Kubernetes authorization
    uses a role-based access control (RBAC) model and provides a fully featured authorization
    platform that allows operators to define various roles via the Kubernetes objects
    `ClusterRole` and `Role` and to bind them to users and groups using `Cluster​Ro⁠leBinding`
    and `RoleBinding`. Think of RBAC as a way of setting permissions on a file system,
    but in the case of Kubernetes, it’s setting permissions on the Kubernetes object
    model. We’ll cover the details of how to use RBAC and how best to build a multitenancy
    model around it in [Chapter 4](ch04.html#single_cluster_availability).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的授权功能已集成到平台中。Kubernetes 授权使用基于角色的访问控制（RBAC）模型，并提供一个功能齐全的授权平台，允许操作员通过
    Kubernetes 对象 `ClusterRole` 和 `Role` 定义各种角色，并通过 `ClusterRoleBinding` 和 `RoleBinding`
    将其绑定到用户和组。可以把 RBAC 想象成在文件系统上设置权限的一种方式，但在 Kubernetes 的情况下，它是在 Kubernetes 对象模型上设置权限。我们将在[第四章](ch04.html#single_cluster_availability)详细讨论如何使用
    RBAC 以及如何在其周围构建最佳的多租户模型。
- en: Operators
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作员
- en: Kubernetes has built-in abstractions like deployments that are extremely well-suited
    stateless applications. In addition, Kubernetes has a very elegant design based
    on control loops that enables it to support a declarative programming model and
    allows the platform to execute robustly at large scale even when failures are
    common.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 具有内置的抽象层，例如部署（deployments），非常适合无状态应用程序。此外，Kubernetes 基于控制循环的优雅设计使其能够支持声明式编程模型，并且在大规模环境中即使故障频发，平台仍能健壮执行。
- en: To support complex stateful applications, Kubernetes needed an extensibility
    model that would enable users to add custom resources and perform life-cycle management
    for those resources. Additionally, it would be ideal if the extensibility model
    could also support the control loop architecture that is used extensively inside
    the Kubernetes platform. Kubernetes includes the [operator pattern](https://oreil.ly/OujZb),
    which provides an extensibility model for custom resources that meet all of these
    requirements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持复杂的有状态应用程序，Kubernetes 需要一个可扩展的模型，使用户能够添加自定义资源并执行这些资源的生命周期管理。此外，理想情况下，这个可扩展模型还应支持
    Kubernetes 平台内广泛使用的控制循环架构。Kubernetes 包含[操作员模式](https://oreil.ly/OujZb)，为满足所有这些需求的自定义资源提供了一个可扩展模型。
- en: Operators support the creation of custom resources. What this means is that
    you can define a new resource type in Kubernetes by creating a custom resource
    definition, and this new resource can be stored in the Kubernetes etcd database
    just like any standard Kubernetes resource. Additionally, you can create a custom
    controller for your resource that performs the same type of control loop behavior
    that the standard Kubernetes controllers perform. The custom controller can then
    monitor the actual state of your stateful application, compare it to the desired
    state, and then take actions to attempt to achieve the desired state for the application.
    For example, let’s say you create an operator for a special type of database,
    which is a stateful application. The operator and its controller can make sure
    that the actual number of replicas of the database that are running matches the
    desired number of copies. Furthermore, since the operator has a custom controller,
    any custom life-cycle management code that is needed for starting up new copies
    of the database or updating existing copies of the database can be added to the
    controller.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符支持创建自定义资源。这意味着您可以通过创建自定义资源定义在 Kubernetes 中定义新的资源类型，并且这些新资源可以像任何标准 Kubernetes
    资源一样存储在 Kubernetes etcd 数据库中。此外，您还可以为您的资源创建自定义控制器，该控制器执行与标准 Kubernetes 控制器相同类型的控制循环行为。自定义控制器可以监视您的有状态应用程序的实际状态，将其与期望状态进行比较，然后采取行动尝试实现应用程序的期望状态。例如，假设您为特殊类型的数据库创建了一个操作符，这是一个有状态的应用程序。操作符及其控制器可以确保运行的数据库副本数量与所需的副本数量相匹配。此外，由于操作符具有自定义控制器，因此可以将用于启动新数据库副本或更新现有数据库副本的任何自定义生命周期管理代码添加到控制器中。
- en: The operator pattern is well-designed, and a key advantage is that it is seamless.
    The custom resources associated with an operator are managed using the `kubectl`
    command-line tool and look just like a standard Kubernetes resource from a management
    perspective. To ease the creation of operators, an operator software development
    kit exists to generate the custom resource definitions and a large portion of
    the controller code required to run the operator’s control loop. As a result of
    the clean architectural design of the operator framework and also due to extensive
    tooling available, creating new operators as the means of adding stateful applications
    continues to grow in popularity. There is now an [Operator Hub](https://operatorhub.io)
    that hosts a large number of existing and reusable operators for managing a variety
    of applications for the Kubernetes platform. We will go into more detail about
    operators and their consumption within Kubernetes in [Chapter 7](ch07.html#multicluster_policy_configuration).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符模式设计良好，其关键优势之一是其无缝性。与操作符关联的自定义资源通过 `kubectl` 命令行工具进行管理，在管理角度上看，与标准 Kubernetes
    资源几乎没有区别。为了简化操作符的创建，存在操作符软件开发工具包，可以生成所需的自定义资源定义以及运行操作符控制循环所需的大部分控制器代码。由于操作符框架的清晰架构设计以及丰富的工具支持，使用操作符作为添加有状态应用程序的手段继续增长其流行度。现在有一个
    [Operator Hub](https://operatorhub.io)，其中托管了大量用于管理各种 Kubernetes 平台应用程序的现有和可重复使用的操作符。我们将在
    [第7章](ch07.html#multicluster_policy_configuration) 中更详细地讨论操作符及其在 Kubernetes 中的使用情况。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered a wide range of topics to give you a broad foundation
    and solid introduction to Kubernetes and OpenShift. We touched upon several topics
    that are critical for running in production, and we will explore many of these
    topics in greater detail in subsequent chapters of this book. In addition, this
    chapter helps to illustrate how the Kubernetes and OpenShift ecosystems have matured
    into platforms that provide a lot of enterprise-level functionality and flexibility.
    In [Chapter 3](ch03.html#advanced_resource_management), we cover a crucial production
    topic: advanced management of Kubernetes resources while running in production.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了广泛的主题，为您提供了 Kubernetes 和 OpenShift 的广泛基础和坚实介绍。我们涉及了一些对于生产环境中运行至关重要的主题，并且我们将在本书的后续章节中更详细地探讨这些主题。此外，本章还帮助说明了
    Kubernetes 和 OpenShift 生态系统如何成熟为提供大量企业级功能和灵活性的平台。在 [第3章](ch03.html#advanced_resource_management)
    中，我们涵盖了一个关键的生产主题：在生产环境中运行时 Kubernetes 资源的高级管理。
- en: ^([1](ch02.html#ch01fn14-marker)) Lantao Liu and Mike Brown, “Kubernetes Containerd
    Integration Goes GA,” Kubernetes Blog (May 24, 2018), [*https://oreil.ly/SlHmh*](https://oreil.ly/SlHmh).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#ch01fn14-marker)) Lantao Liu 和 Mike Brown，"Kubernetes Containerd
    Integration Goes GA," Kubernetes 博客（2018年5月24日），[*https://oreil.ly/SlHmh*](https://oreil.ly/SlHmh)。
- en: '^([2](ch02.html#ch01fn15-marker)) Brendan Burns et al., “Borg, Omega, and Kubernetes:
    Lessons Learned from Three Container-Management Systems over a Decade,” *ACM Queue*
    14 (2016): 70–93, [*http://bit.ly/2vIrL4S*](http://bit.ly/2vIrL4S).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch02.html#ch01fn15-marker)) Brendan Burns 等人，"Borg、Omega 和 Kubernetes:
    从三种容器管理系统的十年经验中学到的教训," *ACM Queue* 14 (2016): 70–93，[*http://bit.ly/2vIrL4S*](http://bit.ly/2vIrL4S)。'
- en: ^([3](ch02.html#ch01fn16-marker)) Tomas Pizarro Moreno, “Running Non-root Containers
    on OpenShift,” Bitnami Engineering (October 27, 2017), [*https://oreil.ly/pxSGf*](https://oreil.ly/pxSGf).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#ch01fn16-marker)) Tomas Pizarro Moreno，"在 OpenShift 上运行非根容器,"
    Bitnami 工程部（2017年10月27日），[*https://oreil.ly/pxSGf*](https://oreil.ly/pxSGf)。
- en: ^([4](ch02.html#ch01fn17-marker)) The [OpenShift authentication documentation](https://oreil.ly/23ON5)
    provides more detail on supported authentication methods.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#ch01fn17-marker)) [OpenShift 认证文档](https://oreil.ly/23ON5) 提供了更多关于支持的认证方法的详细信息。
- en: ^([5](ch02.html#ch01fn18-marker)) The [documentation on image streams](https://oreil.ly/T7vSF)
    provides more information.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#ch01fn18-marker)) [镜像流文档](https://oreil.ly/T7vSF) 提供了更多信息。
- en: ^([6](ch02.html#ch01fn19-marker)) Maciej Szulik, “How to Simplify Container
    Image Management in Kubernetes with OpenShift Image Streams,” Red Hat OpenShift
    Blog (March 23, 2017), [*https://oreil.ly/JEV4u*](https://oreil.ly/JEV4u).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#ch01fn19-marker)) Maciej Szulik，"如何在 Kubernetes 中使用 OpenShift
    Image Streams 简化容器镜像管理," 红帽 OpenShift 博客（2017年3月23日），[*https://oreil.ly/JEV4u*](https://oreil.ly/JEV4u)。
- en: ^([7](ch02.html#ch01fn20-marker)) Wikipedia provides an [overview of webhooks](https://oreil.ly/PLH43).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#ch01fn20-marker)) Wikipedia 提供了 [Webhooks 概述](https://oreil.ly/PLH43)。
