- en: Chapter 11\. Using Stored Routines, Triggers, and Scheduled Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 11.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, the term <q>stored program</q> refers collectively to stored routines,
    triggers, and events, and <q>stored routine</q> refers collectively to stored
    functions and procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses stored programs, which come in several varieties:'
  prefs: []
  type: TYPE_NORMAL
- en: Stored functions and procedures
  prefs: []
  type: TYPE_NORMAL
- en: A stored function or procedure object encapsulates the code for performing an
    operation, enabling you to invoke the object easily by name rather than repeat
    all its code each time it’s needed. A stored function performs a calculation and
    returns a value that can be used in expressions just like a built-in function
    such as `RAND()`, `NOW()`, or `LEFT()`. A stored procedure performs operations
    for which no return value is needed. Procedures are invoked with the `CALL` statement,
    not used in expressions. A procedure might update rows in a table or produce a
    result set that is sent to the client program.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs: []
  type: TYPE_NORMAL
- en: A trigger is an object that activates when a table is modified by an `INSERT`,
    `UPDATE`, or `DELETE` statement. For example, you can check values before they
    are inserted into a table, or specify that any row deleted from a table should
    be logged to another table that serves as a journal of data changes. Triggers
    automate these actions.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled events
  prefs: []
  type: TYPE_NORMAL
- en: An event is an object that executes SQL statements at a scheduled time or times.
    Think of a scheduled event as something like a Unix *cron* job that runs within
    MySQL. For example, events can help you perform administrative tasks such as deleting
    old table rows periodically or creating nightly summaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stored programs are database objects that are user-defined but stored on the
    server side for later execution. This differs from sending an SQL statement from
    the client to the server for immediate execution. Each object also has the property
    that it is defined in terms of other SQL statements to be executed when the object
    is invoked. The object body is a single SQL statement, but that statement can
    use compound-statement syntax (a `BEGIN` … `END` block) that contains multiple
    statements. Thus, the body can range from very simple to extremely complex. The
    following stored procedure is a trivial routine that does nothing but display
    the current MySQL version, using a body that consists of a single `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'More complex operations use a `BEGIN` … `END` compound statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `BEGIN` … `END` block contains multiple statements, but is itself
    considered to constitute a single statement. Compound statements enable you to
    declare local variables and to use conditional logic and looping constructs. These
    capabilities provide considerably more flexibility for algorithmic expression
    than when you write inline expressions in noncompound statements such as `SELECT`
    or `UPDATE`.
  prefs: []
  type: TYPE_NORMAL
- en: Each statement within a compound statement must be terminated by a `;` character.
    That requirement causes a problem if you use the *mysql* client to define an object
    that uses compound statements because *mysql* itself interprets `;` to determine
    statement boundaries. The solution is to redefine *mysql*’s statement delimiter
    while you define a compound-statement object. [Recipe 11.1](#nch-routines-routines-compound-statement)
    covers how to do this; be sure to read that recipe before proceeding to those
    that follow it.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter illustrates stored routines, triggers, and events by example, but
    due to space limitations does not otherwise go into much detail about their extensive
    syntax. For complete syntax descriptions, see the *MySQL Reference Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts for the examples shown in this chapter are located in the *routines*,
    *triggers*, and *events* directories of the `recipes` distribution. Scripts to
    create example tables are located in the *tables* directory.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the stored programs shown in this chapter, others can be found
    elsewhere in this book. See, for example, [Recipe 7.6](ch07.xhtml#nch-strings-strings-lettercase-changing),
    [Recipe 8.3](ch08.xhtml#nch-dates-dates-format), [Recipe 16.8](ch16.xhtml#nch-multi-multi-fill-hole),
    and [Recipe 24.2](ch24.xhtml#nch-security-account-management).
  prefs: []
  type: TYPE_NORMAL
- en: 'Stored programs used here are created and invoked under the assumption that
    `cookbook` is the default database. To invoke a program from another database,
    qualify its name with the database name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, create a database specifically for your stored programs, create
    them in that database, and always invoke them qualified with that name. Remember
    to grant users who will use them the `EXECUTE` privilege for that database.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Creating Compound-Statement Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define a stored program, but its body contains instances of the
    `;` statement terminator. The *mysql* client program uses the same terminator
    by default, so *mysql* misinterprets the definition and produces an error.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redefine the *mysql* statement terminator with the `delimiter` command.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each stored program is an object with a body that must be a single SQL statement.
    However, these objects often perform complex operations that require several statements.
    To handle this, write the statements within a `BEGIN` … `END` block that forms
    a compound statement. That is, the block is itself a single statement but can
    contain multiple statements, each terminated by a `;` character. The `BEGIN` …
    `END` block can contain statements such as `SELECT` or `INSERT`, but compound
    statements also permit conditional statements such as `IF` or `CASE`, looping
    constructs such as `WHILE` or `REPEAT`, or other `BEGIN` … `END` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compound-statement syntax provides flexibility, but if you define compound-statement
    objects within the *mysql* client, you quickly encounter a problem: each statement
    within a compound statement must be terminated by a `;` character, but *mysql*
    itself interprets `;` to figure out where statements end so that it can send them
    one at a time to the server to be executed. Consequently, *mysql* stops reading
    the compound statement when it sees the first `;` character, which is too early.
    To handle this, tell *mysql* to recognize a different statement delimiter so that
    it ignores `;` characters within the object body. Terminate the object itself
    with the new delimiter, which *mysql* recognizes and then sends the entire object
    definition to the server. You can restore the *mysql* delimiter to its original
    value after defining the compound-statement object.'
  prefs: []
  type: TYPE_NORMAL
- en: The following example uses a stored function to illustrate how to change the
    delimiter, but the principles apply to defining any type of stored program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to create a stored function that calculates and returns
    the average size in bytes of mail messages listed in the `mail` table. The function
    can be defined like this, where the body consists of a single SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RETURNS` `FLOAT` clause indicates the type of the function’s return value,
    and `READS` `SQL` `DATA` indicates that the function reads but does not modify
    data. The function body follows those clauses: a single `RETURN` statement that
    executes a subquery and returns the resulting value to the caller. (Every stored
    function must have at least one `RETURN` statement.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *mysql*, you can enter that statement as shown and there is no problem.
    The definition requires just the single terminator at the end and none internally,
    so no ambiguity arises. But suppose instead that you want the function to take
    an argument naming a user that it interprets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the argument is `NULL`, the function returns the average size for all messages
    (as before).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the argument is non-`NULL`, the function returns the average size for messages
    sent by that user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To accomplish this, the function has a more complex body that uses a `BEGIN`
    … `END` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to define the function within *mysql* by entering that definition
    as just shown, *mysql* improperly interprets the first semicolon in the function
    body as ending the definition. Instead, use the `delimiter` command to change
    the *mysql* delimiter, then restore the delimiter to its default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the stored function, invoke it the same way as a built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 11.2 Using Stored Functions to Simplify Calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A particular calculation to produce a value must be performed frequently by
    different applications, but you don’t want to write the expression for it each
    time it’s needed. Or a calculation is difficult to perform inline within an expression
    because it requires conditional or looping logic. Or, if a calculation logic changes,
    you do not want to perform changes in each applications that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a stored function to have these details defined in the single place and
    make the calculation easy to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stored functions enable you to simplify your applications. Write the code that
    produces a calculation result once in a function definition, then simply invoke
    the function whenever you need to perform the calculation. Stored functions also
    enable you to use more complex algorithmic constructs than are available when
    you write a calculation inline within an expression. This section illustrates
    how stored functions can be useful in these ways. (Granted, the example is not
    *that* complex, but the principles used here apply to writing much more elaborate
    functions.)
  prefs: []
  type: TYPE_NORMAL
- en: Different states in the US charge different rates for sales tax. If you sell
    goods to people from different states, you must charge tax using the rate appropriate
    for customer state of residence. To handle tax computations, use a table that
    lists the sales tax rate for each state, and a stored function that looks up the
    tax rate given a state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the `sales_tax_rate` table, use the *sales_tax_rate.sql* script in
    the *tables* directory of the `recipes` distribution. The table has two columns:
    `state` (a two-letter abbreviation), and `tax_rate` (a `DECIMAL` value rather
    than a `FLOAT`, to preserve accuracy).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the rate-lookup function, `sales_tax_rate()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that the tax rates for Vermont and New York are 1 and 9 percent, respectively.
    Try the function to check whether the tax rate is returned correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take sales from a location not listed in the table, the function cannot
    determine the rate for it. In this case, the function assumes a tax rate of 0
    percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The function handles states not listed using a `CONTINUE` handler for `NOT`
    `FOUND`, which executes if a “No Data” condition occurs: if there is no row for
    the given `state_param` value, the `SELECT` statement fails to find a sales tax
    rate, the `CONTINUE` handler sets the rate to 0, and continues execution with
    the next statement after the `SELECT`. (This handler is an example of stored routine
    logic not available in inline expressions. [“Handling Errors Within Stored Programs”](#nch-routines-routines-handlers)
    discusses handlers further.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute sales tax for a purchase, multiply the purchase price by the tax
    rate. For example, for Vermont and New York, tax on a $150 purchase is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or write another function that computes the tax for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 11.3 Using Stored Procedures to Produce Multiple Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to produce multiple values for an operation, but a stored function
    can only return a single value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a stored procedure that has `OUT` or `INOUT` parameters, and pass user-defined
    variables for those parameters when you invoke the procedure. A procedure does
    not <q>return</q> a value the way a function does, but it can assign values to
    those parameters so that the user-defined variables have the desired values when
    the procedure returns.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike stored function parameters, which are input values only, a stored procedure
    parameter can be any of three types:'
  prefs: []
  type: TYPE_NORMAL
- en: An `IN` parameter is for input only. This is the default if you specify no type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `INOUT` parameter is used to pass a value in, and can also pass a value out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OUT` parameter is used to pass a value out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, to produce multiple values from an operation, you can use `INOUT` or `OUT`
    parameters. The following example illustrates this, using an `IN` parameter for
    input, and passing back three values via `OUT` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 11.1](#nch-routines-routines-compound-statement) shows an `avg_mail_size()`
    function that returns the average mail message size for a given sender. The function
    returns a single value. To produce additional information, such as the number
    of messages and total message size, a function will not work. You could write
    three separate functions, but that is cumbersome. Instead, use a single procedure
    that retrieves multiple values about a given mail sender. The following procedure,
    `mail_sender_stats()`, runs a query on the `mail` table to retrieve mail-sending
    statistics about a given username, which is the input value. The procedure determines
    how many messages that user sent, and the total and average sizes of the messages
    in bytes, which it returns through three `OUT` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the procedure, pass a string containing the username, and three user-defined
    variables to receive the `OUT` values. After the procedure returns, access the
    variable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This routine passes back calculation results. It’s also common to use `OUT`
    parameters for diagnostic purposes such as status or error indicators.
  prefs: []
  type: TYPE_NORMAL
- en: If you call `mail_sender_stats()` from within a stored program, you can pass
    variables to it using routine parameters or program local variables, not just
    user-defined variables.
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 Using Triggers to Log Changes to a Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a table that maintains current values of items that you track (such
    as auctions being bid on), but you’d also like to maintain a journal (history)
    of changes to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use triggers to <q>catch</q> table changes and write them to a separate log
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that you conduct online auctions, and that you maintain information
    about each currently active auction in a table that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `auction` table contains information about the currently active auctions
    (items being bid on and the current bid for each auction). When an auction begins,
    insert a row into the table. For each bid on an item, update its `bid` column
    so that as the auction proceeds, the `ts` column updates to reflect the most recent
    bid time. When the auction ends, the `bid` value is the final price and the row
    can be removed from the table.
  prefs: []
  type: TYPE_NORMAL
- en: To maintain a journal that shows all changes to auctions as they progress from
    creation to removal, set up another table that serves to record a history of changes
    to the auctions. This strategy can be implemented with triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain a history of how each auction progresses, use an `auction_log`
    table with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auction_log` table differs from the `auction` table in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains an `action` column to indicate for each row what kind of change
    was made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `id` column has a nonunique index (rather than a primary key, which requires
    unique values). This permits multiple rows per `id` value because a given auction
    can generate many rows in the log table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure that changes to the `auction` table are logged to the `auction_log`
    table, create a set of triggers. The triggers write information to the `auction_log`
    table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For inserts, log a row-creation operation showing the values in the new row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For updates, log a row-update operation showing the new values in the updated
    row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For deletes, log a row-removal operation showing the values in the deleted row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this application, `AFTER` triggers are used because they activate only
    after successful changes to the `auction` table. (`BEFORE` triggers might activate
    even if the row-change operation fails for some reason.) The trigger definitions
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `INSERT` and `UPDATE` triggers use `NEW.`*`col_name`* to access the new
    values being stored in rows. The `DELETE` trigger uses `OLD.`*`col_name`* to access
    the existing values from the deleted row. The `INSERT` and `UPDATE` triggers use
    `NOW()` to get the row-modification times; the `ts` column is initialized automatically
    to the current date and time, but `NEW.ts` will not contain that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that an auction is created with an initial bid of five dollars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SELECT` statement fetches the auction ID value to use for subsequent actions
    on the auction. Then the item receives three more bids before the auction ends
    and is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, no trace of the auction remains in the `auction` table, but
    the `auction_log` table contains a complete history of what occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With the strategy just outlined, the `auction` table remains relatively small,
    and you can always find information about auction histories as necessary by looking
    in the `auction_log` table.
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 Using Events to Schedule Database Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to set up a database operation that runs periodically without user
    intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides an event scheduler that enables you to set up database operations
    that run at times that you define. Create an event that executes according to
    a schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes what you must do to use events, beginning with a simple
    event that writes a row to a table at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with a table to hold the mark rows. It contains a `TIMESTAMP` column
    (which MySQL will initialize automatically) and a column to store a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our logging event will write a string to a new row. To set it up, use a `CREATE`
    `EVENT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `mark_insert` event causes the message `'-- MARK --'` to be logged to the
    `mark_log` table every five minutes. Use a different interval for more or less
    frequent logging.
  prefs: []
  type: TYPE_NORMAL
- en: This event is simple and its body contains only a single SQL statement. For
    an event body that executes multiple statements, use `BEGIN` … `END` compound-statement
    syntax. In that case, if you use *mysql* to create the event, change the statement
    delimiter while you define the event, as discussed in [Recipe 11.1](#nch-routines-routines-compound-statement).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should wait a few minutes and then select the contents of
    the `mark_log` table to verify that new rows are being written on schedule. However,
    if this is the first event that you’ve set up, you might find that the table remains
    empty no matter how long you wait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If that’s the case, very likely the event scheduler isn’t running (which was
    its default state until version 8.0). Check the scheduler status by examining
    the value of the `event_scheduler` system variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the scheduler interactively if it’s not running, execute the following
    statement (which requires the `SYSTEM_VARIABLES_ADMIN` or, before version 8.0,
    `SUPER` privilege):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That statement enables the scheduler, but only until the server shuts down.
    To start the scheduler each time the server starts, enable the system variable
    in your *my.cnf* option file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use `SET PERSIST` statement to store the modified value of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When the event scheduler is enabled, the `mark_insert` event eventually creates
    many rows in the table. There are several ways that you can affect event execution
    to prevent the table from growing forever:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drop the event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the simplest way to stop an event from occurring. But if you want it
    to resume later, you must re-create it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Disable event execution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That leaves the event in place but causes it not to run until you reactivate
    it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let the event continue to run, but set up another event that <q>expires</q>
    old `mark_log` rows. This second event need not run so frequently (perhaps once
    a day). Its body should remove rows older than a given threshold. The following
    definition creates an event that deletes rows that are more than two days old:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you adopt this strategy, you have cooperating events: one event that adds
    rows to the `mark_log` table, and another that removes them. They act together
    to maintain a log that contains recent rows but does not become too large.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 11.6 Writing Helper Routines for Executing Dynamic SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prepared SQL statements enable you to construct and execute SQL statements
    on the fly, but you want to run them in one step instead of executing three commands:
    `PREPARE`, `EXECUTE` and `DEALLOCATE PREPARE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a helper procedure that handles the drudgery.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a prepared SQL statement involves three steps: preparation, execution,
    and deallocation. For example, if the `@tbl_name` and `@val` variables hold a
    table name and a value to insert into the table, you can create the table and
    insert the value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To ease the burden of going through those steps for each dynamically created
    statement, use a helper routine that, given a statement string, prepares, executes,
    and deallocates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exec_stmt()` routine enables the same statements to be executed much more
    simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`exec_stmt()` uses an intermediary user-defined variable, `@_stmt_str`, because
    `PREPARE` accepts a statement only when specified using either a literal string
    or a user-defined variable. A statement stored in a routine parameter does not
    work. (Avoid using `@_stmt_str` for your own purposes, at least if you expect
    its value to persist across `exec_stmt()` invocations.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how about making it safer to construct statement strings that incorporate
    values that might come from external sources, such as web-form input or command-line
    arguments? Such information cannot be trusted and should be treated as a potential
    SQL injection attack vector:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QUOTE()` function is available for quoting data values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no corresponding function for identifiers, but it’s easy to write
    one that doubles internal backticks and adds a backtick at the beginning and end:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Revising the preceding example to ensure the safety of data values and identifiers,
    we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A constraint on use of `exec_stmt()` is that not all SQL statements are eligible
    for execution as prepared statements. See the *MySQL Reference Manual* for the
    limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 Detecting <q>No More Rows</q> Conditions Using Condition Handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to detect <q>no more rows</q> conditions and gracefully handle them
    instead of interrupting the stored program execution.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common use of condition handlers is to detect <q>no more rows</q> conditions.
    To process a query result one row at a time, use a cursor-based fetch loop in
    conjunction with a condition handler that catches the end-of-data condition. The
    technique has these essential elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A cursor associated with a `SELECT` statement that reads rows. Open the cursor
    to start reading, and close it to stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A condition handler that activates when the cursor reaches the end of the result
    set and raises an end-of-data condition (`NOT` `FOUND`). We used a similar handler
    in [Recipe 11.2](#nch-routines-routines-encapsulation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable that indicates loop termination. Initialize the variable to `FALSE`,
    then set it to `TRUE` within the condition handler when the end-of-data condition
    occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A loop that uses the cursor to fetch each row and exits when the loop-termination
    variable becomes `TRUE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example implements a fetch loop that processes the _ch `states`
    table row by row to calculate the total US population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-routines-routines-end-of-data_done_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Variable `done` is used as a flag that checked when the procedure decides if
    it needs to continue executing or stop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-routines-routines-end-of-data_query_co)'
  prefs: []
  type: TYPE_NORMAL
- en: The cursor for the query that fetching each state population.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-routines-routines-end-of-data_ch_co)'
  prefs: []
  type: TYPE_NORMAL
- en: When MySQL encounters not found error it stops execution. To prevent this we
    declared a `CONTINUE` handler that sets value of the variable `done` to value
    `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-routines-routines-end-of-data_fetch_co)'
  prefs: []
  type: TYPE_NORMAL
- en: We fetch each state population into variable `state_pop`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_nch-routines-routines-end-of-data_leave_co)'
  prefs: []
  type: TYPE_NORMAL
- en: If variable `done` is not true we continue the loop, otherwise leaving it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_nch-routines-routines-end-of-data_total_co)'
  prefs: []
  type: TYPE_NORMAL
- en: We add value of the variable `state_pop` to the variable `total_pop` that represents
    population of the United States.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_nch-routines-routines-end-of-data_result_co)'
  prefs: []
  type: TYPE_NORMAL
- en: After leaving the loop we print value of the variable `total_pop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this example is mostly for the illustration because in any real application
    you’d use an aggregate function to calculate the total. But that also gives us
    an independent check on whether the fetch loop calculates the correct value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`NOT` `FOUND` handlers are also useful for checking whether `SELECT` … `INTO`
    *`var_name`* statements return any results. [Recipe 11.2](#nch-routines-routines-encapsulation)
    shows an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.8 Catching and Ignoring Errors with Condition Handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to ignore benign errors or prevent errors from nonexistent users.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a condition handler to catch and handle the error you want to ignore.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you consider an error benign, you can use a handler to ignore it. For example,
    many `DROP` statements in MySQL have an `IF` `EXISTS` clause to suppress errors
    if objects to be dropped do not exist. But some `DROP` statements have no such
    clause and thus no way to suppress errors. `DROP` `INDEX` is one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent errors from occurring for nonexistent users, invoke `DROP` `INDEX`
    within a stored procedure that catches code 1091 and ignores it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If the index does not exist, `drop_index()` writes a message within the condition
    handler, but no error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To ignore the error completely, write the handler using an empty `BEGIN` …
    `END` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Another approach is to generate a warning, as demonstrated in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 11.9 Raising Errors and Warnings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to raise error for statements, valid for MySQL but not valid for the
    application you are working on.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To produce your own errors within a stored program when you detect something
    awry, use the `SIGNAL` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows some examples, and [Recipe 11.11](#nch-routines-preprocess-reject)
    demonstrates use of `SIGNAL` within a trigger to reject bad data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that an application performs a division operation for which you expect
    that the divisor will never be zero, and that you want to produce an error otherwise.
    You might expect that since version 5.7.4 SQL Mode `ERROR_FOR_DIVISION_BY_ZERO`
    is enabled by default you will get this behavior automatically. But that works
    only within the context of data-modification operations such as `INSERT`. In other
    contexts, division by zero produces only a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure a divide-by-zero error in any context, write a function that performs
    the division but checks the divisor first and uses `SIGNAL` to raise an error
    if the <q>can’t happen</q> condition occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the function in a nonmodification context to verify that it produces an
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `SIGNAL` statement specifies a SQLSTATE value plus an optional `SET` clause
    you can use to assign values to error attributes. `MYSQL_ERRNO` corresponds to
    the MySQL-specific error code, and `MESSAGE_TEXT` is a string of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGNAL` can also raise warning conditions, not just errors. The following
    routine, `drop_user_warn()`, is similar to the `drop_user()` routine shown earlier,
    but instead of printing a message for nonexistent users, it generates a warning
    that can be displayed with `SHOW` `WARNINGS`. SQLSTATE value `01000` and error
    1642 indicate a user-defined unhandled exception, which the routine signals along
    with an appropriate message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Give it a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 11.10 Logging Errors by Accessing the Diagnostic Area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to log all errors that your stored routine hits.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access the diagnostic area using the *GET DIAGNOSTICS*statement. Then, save
    the error information into variables, and use them to log errors..
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may not only gracefully handle errors inside the stored routine but also
    log them, so you can examine them and fix your application to prevent similar
    ones in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Table `movies_actors_link` is used in the recipe [Recipe 16.6](ch16.xhtml#nch-multi-multi-many-to-many)
    to demonstrate many-to-many relationship. It contains `id` of the movies and movie
    actors that are stored in tables `movies` and `movies_actors`. Both columns are
    defined with the property `NOT NULL`. Each combination of `movie_id` and `actor_id`
    should be unique. While [Recipe 16.6](ch16.xhtml#nch-multi-multi-many-to-many)
    does not define foreign keys ([“Using Foreign Keys to Enforce Referential Integrity
    and Prevent Mismatches”](ch16.xhtml#nch-multi-multi-fks)) we may define them,
    so MySQL will reject values that do not have corresponding entries in the referenced
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When we execute a statement in the *mysql* client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, MySQL provides access to the diagnostic area, so you can store
    values from it in the user-defined variables. Use command *GET DIAGNOSTICS* to
    access the diagnostic area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Clause `CONDITION` specifies the condition number. Our query returned only one
    condition, therefore we used number 1\. If a query returns multiple conditions
    diagnostic area would contain data for each of conditions. It could happen, for
    example, if a query produces multiple warnings.
  prefs: []
  type: TYPE_NORMAL
- en: To access data, retrieved by the *GET DIAGNOSTICS*, simply select values of
    the user-defined variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To record all such errors that users make when insert data into the table `movies_actors_link`
    create a procedure that takes two arguments: `movie_id` and `actor_id` and store
    error information in the log table.'
  prefs: []
  type: TYPE_NORMAL
- en: First create the table that will store information about errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then define the procedure that will insert a row into the table `movies_actors_link`
    and in case of an error will log details into the table `movies_actors_log`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-routines-routines-diagnostic-area-gd_declare_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare variables that will store error number, SQLSTATE and the error message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-routines-routines-diagnostic-area-gd_handler_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `CONTINUE HANDLER` for `SQLEXCEPTION`, so the procedure will first
    log the error, then continue executing.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-routines-routines-diagnostic-area-gd_store_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Store diagnostic information in the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-routines-routines-diagnostic-area-gd_log_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Log details about the error into the table `movies_actors_log`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_nch-routines-routines-diagnostic-area-gd_resignal_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Use command *RESIGNAL* to raise the error for the client that called the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_nch-routines-routines-diagnostic-area-gd_insert_co)'
  prefs: []
  type: TYPE_NORMAL
- en: The *INSERT* into the table `movies_actors_link` that will either succeeds or
    raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: To test the procedure call it few times with different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As expected, because we used `RESIGNAL`, the procedure failed with errors. Still
    all the errors were logged into the table `movies_actors_log` together with the
    values that we tried and failed to insert and a timestamp when such a try happened.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about diagnostic area, see [GET DIAGNOSTICS Statement](https://dev.mysql.com/doc/refman/8.0/en/get-diagnostics.html).
  prefs: []
  type: TYPE_NORMAL
- en: 11.11 Using Triggers to Preprocess or Reject Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are conditions you want to check for data entered into a table, but you
    don’t want to write the validation logic for every `INSERT`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Centralize the input-testing logic into a `BEFORE` `INSERT` trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use triggers to perform several types of input checks:'
  prefs: []
  type: TYPE_NORMAL
- en: Reject bad data by raising a signal. This gives you access to stored program
    logic for more latitude in checking values than is possible with static constraints
    such as `NOT` `NULL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocess values and modify them, if you won’t want to reject them outright.
    For example, map out-of-range values to be in range or sanitize values to put
    them in canonical form, if you permit entry of close variants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that you have a table of contact information such as name, state of
    residence, email address, and website URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For entry of new rows, you want to enforce constraints or perform preprocessing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: State of residence values are two-letter US state codes, valid only if present
    in the `states` table. (In this case, you could declare the column as an `ENUM`
    with 50 members, so it’s more likely you’d use this lookup-table technique with
    columns for which the set of valid values is arbitrarily large or changes over
    time.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email address values must contain an `@` character to be valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For website URLs, strip any leading `http://` or `https://` to save space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle these requirements, create a `BEFORE` `INSERT` trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To also handle updates, define a `BEFORE` `UPDATE` trigger with the same body
    as `bi_contact_info`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the trigger by executing some `INSERT` statements to verify that it accepts
    valid values, rejects bad ones, and trims URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
