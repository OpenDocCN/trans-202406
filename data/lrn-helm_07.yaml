- en: Chapter 7\. Chart Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No package manager is complete without a way to share and distribute the packages
    themselves. Organizations and vendors must have a way to publish packages for
    end users to download and consume. Likewise, end users must have a common way
    to fetch packages from a variety of sources.
  prefs: []
  type: TYPE_NORMAL
- en: Helm enables package distribution though a system called chart repositories.
    Chart repositories are simple HTTP(S) web services from which users can discover
    and download available charts. Conceptually, chart repositories are similar in
    design to Debian package repositories, Fedora package databases, or the Comprehensive
    Perl Archive Network (CPAN).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first dive deep into the internals of a chart repository.
    We will discuss the repository index and how to update it with new chart versions.
    After that, we will show how to set up a chart repository from scratch, how to
    secure one, and also show a real-world example of how to host a public chart repository
    using GitHub Pages for open source projects. After this, we will walk through
    the various `helm repo` commands and how to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the chapter, we will cover the next generation of chart repositories
    using Helm’s experimental Open Container Initiative (OCI) support. This bleeding-edge
    functionality added in Helm 3 allows users to store Helm charts in container registries
    alongside their container images.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will briefly describe some of the projects in the Helm ecosystem
    related to chart repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The Repository Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All chart repositories contain a special repository index file called *index.yaml*,
    which lists all available charts and their respective download locations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See [Appendix B](app02.xhtml#appendix_b_chart_respoitory_api) for more details
    describing the format of *index.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a very basic *index.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note the `entries` section, which lists all charts and chart versions. This
    *index.yaml* example lists a just single chart, *superapp*, with a single version,
    0.1.0.
  prefs: []
  type: TYPE_NORMAL
- en: An Example of a Chart Repository Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, chart repositories list many charts and all their available versions.
    This allows users to download a specific version of the chart they wish to install.
    The following is a more real-world example of a chart repository index, containing
    multiple charts and chart versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example shows two available charts: *cert-manager* and *tor-proxy*.
    There are a total of three available chart versions: *cert-manager* v0.14.1, *cert-manager*
    v0.14.2 (latest), and *tor-proxy* 0.1.1 (latest). The latest versions of each
    chart in the repo are displayed when running a `helm search`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically chart archives (*.tgz* files) themselves are served from the same
    location as the repository index, but the index may also link to remote locations
    on entirely different domains. Here is a snippet from an *index.yaml* referencing
    chart archives located on a separate domain (note the absolute URL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_chart_repositories_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute chart URL
  prefs: []
  type: TYPE_NORMAL
- en: Other fields found in each entry include the metadata for a chart as described
    in *Chart.yaml*, such as `description`, as well as an added digest field containing
    the Secure Hash Algorithm (SHA-256) checksum of the chart archive. In [Chapter 4](ch04.xhtml#building_a_chart)
    we covered chart metadata and *Chart.yaml* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, at the top level is a `generated` field describing when the index
    was created (in RFC 3339 format), as well as an `apiVersion` describing the API
    version of the index. At the time of writing, there is currently only one API
    version for chart repositories. This field should always be `v1`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The repository index can be generated by a custom program, or typed out manually.
    Helm also provides built-in functionality to generate the repository index for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an empty directory, *charts/*, which will serve as the root of
    our chart repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a repository index inside the *charts/* directory, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a file at *charts/index.yaml*. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that the `entries` are empty. This is expected because we do not
    yet have any charts in the *charts/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a sample chart, and package it into the *charts/* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s try generating the index again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we see our chart listed in the `entries` section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to an Existing Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some scenarios (continuous integration/continuous deployment [CI/CD], for
    example), you may only have access to an existing *index.yaml* file and a newly
    packaged chart archive. Helm provides a mechanism for building upon the contents
    of an existing index with the `--merge` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s simulate this scenario. Create a new directory called *workspace/*, which
    will represent a new working directory in a CI/CD pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the existing index file into the *workspace/* directory with a new name,
    such as *index-old.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In a real-world scenario, you might source the existing index file from some
    remote location (e.g., Amazon S3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next let’s create another Helm chart and package it into the *workspace/* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command, which will create a new *index.yaml* file based
    on the combination of the existing entries found in *index-old.yaml*, as well
    as any *.tgz* files in the *workspace/* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, move the files from the *workspace/* directory into the *charts/*
    directory, overwriting the old index file with the new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version of the index file should now contain entries for both charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method is useful in environments where you do not necessarily have access
    to a directory containing all of the chart archives.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, however, that if this merge occurs on multiple systems at the
    same time, you may run into a race condition where one or more charts goes missing
    from the index. This can be mitigated by ensuring that this process is only performed
    synchronously (e.g., a single CI job responsible for creating *index.yaml* for
    the repository). Another way to address this problem is to use a dynamic web server
    that is responsible for generating the contents of *index.yaml*. The *ChartMuseum*
    project, which is described later in this chapter in [“Related Projects”](#related_projects),
    is one such example of a dynamic chart repository server you can use for this
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Chart Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the benefits of chart repositories is that they can be entirely static—meaning
    you can place the files behind a simple web server such as Apache or Nginx and
    serve them as is. You can even use object storage providers, such as Amazon S3\.
    No significant computation needs to occur on the server side when a client requests
    *index.yaml*, for example. The static web server just opens the file as it exists
    on the filesystem and sends the raw contents back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Chart Repository with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of this example, we will use Python’s built-in static web server
    to start up a local test repository. Note that almost all programming languages
    have some support in their standard libraries to start a web server and serve
    static files. Python is chosen simply because it comes preinstalled on most Unix-based
    systems, and because it provides an easy one-line command to start a static web
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the instructions in the previous section ([“Generating an Index”](#generating_an_index))
    to create the *charts/* directory, containing the files *index.yaml*, *superapp-0.1.0.tgz*,
    and *duperapp-0.1.0.tgz*. Run one of the following commands to start a local web
    server at *[*http://localhost:8080*](http://localhost:8080)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Python 3 (try this first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Python 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Python 2 version of this command listens on all interfaces (`0.0.0.0`) versus
    just the loopback interface (`127.0.0.1`). Depending on your system, this will
    allow other devices on your network to connect. Be mindful of which files are
    present in the *charts/* directory before running this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in another terminal window, try fetching *index.yaml* using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s verify that we can fetch chart archives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the `curl` commands succeed, your chart repository is ready to be used with
    Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Securing a Chart Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, you may wish to limit access to a chart repository or maintain
    an audit trail of which users are accessing which resources. Helm has built-in
    support to allow users to authenticate themselves against chart repositories protected
    by either basic auth or mTLS.
  prefs: []
  type: TYPE_NORMAL
- en: Basic auth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chart repositories can be protected by basic access authentication, or *basic
    auth*. This requires that users provide a valid username/password combination
    to access resources on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic auth can be implemented by a server by first checking the `Authorization`
    header prior to processing a request. An incoming basic auth header resembles
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_chart_repositories_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The opaque string here is the Base64 encoding of *`username`* + “:” + *`password`*.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The contents of the `Authorization` header are *not* encrypted, so you are strongly
    encouraged to also use HTTPS when supplying basic auth credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding a repository for the first time, you can supply a username and
    password combination on the command line, which will instruct Helm to use basic
    auth when making requests against this repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Client certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most client-server communication over HTTPS allows the client to verify the
    identity of the server based on the SSL certificate provided by the server. With
    mutual TLS authentication (mTLS), servers can also verify the identity of the
    client based on a separate SSL certificate presented by the client during the
    TLS handshake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple Nginx server configuration enabling mTLS for a chart repository,
    assuming static files (i.e., *index.yaml*, *.tgz* files) are located in the directory
    */chartrepo* on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_chart_repositories_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Server’s SSL certificate
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_chart_repositories_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Server’s private key
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_chart_repositories_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Certificate authority (CA) for client authentication—only requests from clients
    with a certificate signed by this CA will be accepted
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in obtaining a client certificate is to generate a new private
    key and certificate signing request (CSR):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When prompted for a “Common Name” when generating the CSR, you must enter a
    value. Use something that identifies the client (e.g., “francis”). Other fields
    can technically be left blank, although you are encouraged to fill them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, using the certificate authority configured on the server (`client-ca.pem`)
    and the associated private key (`client-ca.key`), generate a new client certificate
    from the CSR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use this certificate to authenticate by specifying the `--cert-file`
    and `--key-file` options upon adding a new chart repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case that your server is using a self-signed certificate, you can also
    specify the `--ca-file` option pointing to a trusted certificate or certificate
    bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The paths used for `--cert-file`, `--key-file`, and `--ca-file` are all stored
    in the Helm cache tied to the repository. It is important not to move these files;
    otherwise, future requests to the repository will fail due to missing files needed
    for the client to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on mTLS, please see Internet Engineering Task Force (IETF)
    RFC 8446, “The Transport Layer Security (TLS) Protocol Version 1.3.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Real-World Example: Using GitHub Pages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub has a free, static hosting solution called GitHub Pages. If you don’t
    mind making your charts public to the world, GitHub Pages is a great option for
    hosting a chart repository as you incur zero cost.
  prefs: []
  type: TYPE_NORMAL
- en: What’s even better is that GitHub Pages allows you to use a custom domain name
    that points to your GitHub Pages site. In this section we will show how to easily
    set up a public Helm chart repository using GitHub Pages.
  prefs: []
  type: TYPE_NORMAL
- en: There are some limitations on GitHub Pages (such as bandwidth), so before using
    this method, enumerate the performance requirements for your chart repository
    compared to GitHub’s documentation of GitHub Pages’ features.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Git repo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to create a brand-new Git repo on GitHub dedicated to your
    chart repository. You could technically host the chart repo alongside other content,
    but for the sake of simplicity, we will use a dedicated Git repo. [Figure 7-1](#chapter_7_githubpages1)
    shows how to set up a new repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![GitHub Pages](Images/lehe_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Creating a new public repository in GitHub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once you’re logged in to GitHub, click the top right of the screen and select
    “New repository.” Name the Git repo whatever you want. We will use the name *mycharts*
    for this example. Make sure to select the option for marking the repository as
    “Public,” which is a prerequisite for using GitHub Pages. Select the box for “Initialize
    this repository with a README,” which will allow us to clone the repo immediately.
    Feel free to select a license such as “MIT License” to indicate that the source
    code in this repo is free to use and repurpose. Finally, click “Create repository.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s important to note in this context the difference between a Helm repo (or
    chart repository) and a Git repo hosted on GitHub, which is used for version control.
  prefs: []
  type: TYPE_NORMAL
- en: Enable GitHub Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigate to the Settings panel on the repository. In the main settings, scroll
    down to the section titled GitHub Pages (see [Figure 7-2](#chapter_7_githubpages2)).
    For the Source option, select “main branch.” This will cause GitHub to redeploy
    your GitHub Pages site every time you make a new commit to the main branch. Click
    Save.
  prefs: []
  type: TYPE_NORMAL
- en: '![GitHub Pages](Images/lehe_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Enabling GitHub Pages on your repository
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Optional: Use a custom domain'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sites on GitHub Pages, by default, are hosted as a subdomain on the `github.io`
    domain. For example, the URL to your site would resemble something like *https://`yourusername`.github.io/mycharts/*.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a custom domain name to use, in your registrar’s web console (or
    alternatively, in the console for the service you have set up to use for your
    authoritative nameservers), create a new DNS record pointing to *`yourusername`.github.io*.
    If using the root domain, use an `ALIAS` record type; otherwise, for subdomains,
    use a `CNAME` record type.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to your repository settings in GitHub. As in [Figure 7-3](#chapter_7_githubpages3),
    in the “Custom domain” input, enter your domain that you set up a DNS record for.
  prefs: []
  type: TYPE_NORMAL
- en: '![GitHub Pages, 500](Images/lehe_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Using a custom domain for GitHub Pages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It may take up to an hour for GitHub to generate a TLS certificate for your
    domain. Once it is ready, you should see some text displayed in the settings such
    as “Your site is published at https://example.com.” Once you see this, make sure
    to enable the Enforce HTTPS option so that your site is only ever accessed over
    HTTPS versus just plain HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Adding chart repository files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Locate the clone URL for your repo in the GitHub UI (typically on the right
    side of the screen). Clone your new GitHub repository to your local system so
    that we can add some files to turn it into a real chart repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the directory of your Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s create a chart called *pineapple* in a new *src/* directory, package
    it into an archive in the root of the repo, and create an *index.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that’s done, let’s commit and push all these new files back to GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Go back to GitHub in the browser. There is a small delay between the time you
    push a change and those changes becoming avaiable on your GitHub Pages site. Click
    the Environments item in the right sidebar. This will tell you the last time your
    site was deployed. If you see a reference to the commit you just pushed (`9bba19d`
    in the preceding example), your GitHub Pages site is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using your GitHub Pages site as a chart repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have pushed an *index.yaml* file up to your Git repo, and the site
    is live with the latest commit, you can use it exactly as you would any other
    chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add your GitHub Pages chart repository to your local repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you’re using a custom domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using Chart Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a working chart repository (see previous section), you can then
    leverage it using the Helm CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Several commands are available under the top-level `helm repo` subcommand for
    working with chart repositories. This section will focus on how to use each of
    these commands effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The very first step in using a chart repository is to assign a unique name to
    it (such as `mycharts`) and add it to a list of repositories known by Helm. When
    you first add a repository, Helm fetches *index.yaml* from the URL provided and
    stores it locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `helm repo add` command to add your repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running the Python example, check out the logs for your chart repository
    and you should see the incoming request for `GET /index.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Downloading Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To download a chart directly from a repository, use the `helm pull` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Helm will automatically find the latest version based on Semantic Versioning.
    You can also specify a version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a new chart archive (*.tgz* file) in your workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This archive can be then be installed directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also install charts directly from added repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Listing Repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s oftentimes helpful to know which chart repositories have already been added
    on your system. Knowing this may help you decide whether you want to use one of
    them to download charts or to remove one of them from the system completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `helm repo list` command to list all chart repositories added to your
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can also leverage the `--output` / `-o` option to get this in machine-readable
    format, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the list as YAML by adding `-o yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the list as JSON by adding `-o json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Updating Repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once new chart versions are released, repository owners add the *.tgz* package
    to the repo storage and update *index.yaml* with a new entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fetch the latest version of the repository index, use the `helm
    repo update` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running the Python example, once again, you should notice an incoming
    request for `GET /index.yaml` in the output logs from your chart repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not the repository index has changed contents (we haven’t added any
    more charts to `myrepo`), the file is fetched and downloaded into the cache, overwriting
    the previously saved version.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to remove a repository, you can use `helm repo remove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will remove all references to this repository stored in the Helm cache.
  prefs: []
  type: TYPE_NORMAL
- en: Experimental OCI Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Helm’s OCI support](https://oreil.ly/eH4KE) is still considered highly experimental.
    While development in this area is still active, the syntax described in this section
    may soon become outdated.'
  prefs: []
  type: TYPE_NORMAL
- en: The chart repository system was designed to be easy to use. In most cases, this
    system has proven to be sufficient—enabling organizations around the globe to
    share and distribute their Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chart repositories do, however, present a few key challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: They have no concept of namespaces; all charts for a repo are listed in a single
    index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have no fine-grained access control; you either have access to all charts
    in the repo or none of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chart packages with different names but the exact same raw contents are stored
    twice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The repository index can become extremely large, causing Helm to consume a lot
    of memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than trying to add features to address all of these issues with the current
    chart repository model, it made much more sense to build the next generation of
    chart repositories on top of registries that conform to the *OCI Distribution
    Specification*.
  prefs: []
  type: TYPE_NORMAL
- en: 'OCI stands for the *Open Container Initiative*. Taken from the website at [*https://opencontainers.org*](https://opencontainers.org),
    OCI is defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An open governance structure for the express purpose of creating open industry
    standards around container formats and runtimes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of the standards defined by OCI is the *distribution specification*. This
    spec describes an HTTP API used for distributing container images. Interestingly
    enough, this API is general-purpose and can apply to all sorts of things that
    *aren’t* container images—things such as Helm charts!
  prefs: []
  type: TYPE_NORMAL
- en: Starting in Helm 3.0.0, experimental support was added to push and pull charts
    to and from OCI-based container registries.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling OCI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, Helm’s OCI support is still considered experimental.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, set the following in your environment to enable OCI support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Running a Local Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker Distribution project (also known as the Docker registry) was the
    original implementation of Docker’s Registry v2 API. It supports Helm charts out
    of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have `docker` installed, you can easily run a local registry in a container
    on port 5000 with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To tail the logs for you registry, run the following (press Ctrl-C to exit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop your registry, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The Docker registry has [several configuration options](https://oreil.ly/CBb0F)
    related to authentication, storage, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to configure basic auth with a single username-password combo,
    first create a *.htpasswd* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then start the registry, mounting the *.htpasswd* file and setting the `REGISTRY_AUTH`
    environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For more information about Docker Distribution, visit the [project GitHub page](https://oreil.ly/Q8Omf).
  prefs: []
  type: TYPE_NORMAL
- en: Logging In to a Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to authenticate against a registry, use the `helm registry login`
    command (you will be prompted to manually enter a password):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This makes a simple `GET` request to the path `/v2/` on the registry using the
    credentials to determine if they are valid. If they are, the credentials will
    be stored in a Helm config file. If you have any Docker credential stores enabled
    (such as `osxkeychain` on macOS), the username and password will be stored there
    securely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The example of running a local registry at `localhost:5000` uses no authentication.
    If you haven’t enabled authentication on your registry, any combination of login
    credentials will be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Out of a Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to remove credentials for a given registry from your system, use the
    `helm registry logout` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Storing a Chart in the Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to uploading a chart to a registry, you must first save it into the cache.
    This converts a chart from its normal state into content-addressable blobs and
    also gives it a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `helm chart save` to store a chart in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the tag used on the chart reference is based upon the chart’s version
    in *Chart.yaml* (`2.7.0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a custom tag, such as `stable`, by specifying it after a colon
    (`:`) on the chart reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Listing Charts in the Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `helm` `chart` `list` to display all charts currently stored in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Exporting a Chart from the Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to extract the source files of a chart once it is in the cache,
    it must first be exported to a local directory. Use the `helm chart export` command
    to export the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The name of the chart will be used to determine the output path (e.g., `mychart/`).
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a Chart to the Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pushing (a.k.a. uploading) a chart to the registry allows for it to be used
    by others. Once you are already logged in to the registry and the chart you want
    to push has been saved to the cache, use the `helm chart push` command to push
    a chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Pulling a Chart from the Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once charts have been pushed to a registry, other users can then pull (a.k.a.
    download) them. Pulling charts from a registry places them into the local cache.
    To pull an existing chart from a registry, use the `helm chart pull` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Removing a Chart from the Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove a chart from the local cache, use the `helm chart remove` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Related Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm’s chart repository system has spawned a collection of open source tools
    to further enhance this experience. The following subsections cover some of the
    projects related to chart repositories.
  prefs: []
  type: TYPE_NORMAL
- en: ChartMuseum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Project homepage: [*https://github.com/helm/chartmuseum*](https://github.com/helm/chartmuseum)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*ChartMuseum* is a simple chart repository web server. Configure it to point
    to a storage location containing chart packages and it will dynamically generate
    *index.yaml*. It also exposes an HTTP API for uploading, querying, and deleting
    chart packages from storage. Additionally, it has a number of other configuration
    settings for auth, multitenancy, and caching that make it a popular choice for
    users hosting private or internal chart repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: Harbor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Project homepage: [*https://github.com/goharbor/harbor*](https://github.com/goharbor/harbor)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Harbor* is a full-featured registry with added security and management features.
    It provides a UI for Helm charts and leverages ChartMuseum on the backend as a
    multitenant chart respository. It also provides support for Helm’s experimental
    OCI feature set.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Helm, *Harbor* is a graduated, top-level CNCF project.
  prefs: []
  type: TYPE_NORMAL
- en: Chart Releaser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Project homepage: [*https://github.com/helm/chart-releaser*](https://github.com/helm/chart-releaser)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chart Releaser*, or `cr`, is a command-line tool that leverages GitHub releases
    for hosting chart packages. It has the ability to detect charts in a Git repo,
    package them, and upload each of them as artifacts to GitHub releases named after
    the unique chart version.'
  prefs: []
  type: TYPE_NORMAL
- en: Once charts have been uploaded using `cr`, the tool can also be used to generate
    an *index.yaml* file based on the contents of GitHub releases and associated artifacts.
    This repository index can then be hosted statically, on GitHub Pages or elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: S3 Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Project homepage: [*https://github.com/hypnoglow/helm-s3*](https://github.com/hypnoglow/helm-s3)*'
  prefs: []
  type: TYPE_NORMAL
- en: The S3 plugin is a Helm plugin that allows you to use a private Amazon S3 bucket
    as a chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: GCS Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Project homepage: [*https://github.com/hayorov/helm-gcs*](https://github.com/hayorov/helm-gcs)*'
  prefs: []
  type: TYPE_NORMAL
- en: The GCS plugin is a Helm plugin that allows you to use a private Google Cloud
    Storage bucket as a chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: Git Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Project homepage: [*https://github.com/aslafy-z/helm-git*](https://github.com/aslafy-z/helm-git)*'
  prefs: []
  type: TYPE_NORMAL
- en: The Git plugin is a Helm plugin that allows you to use a Git repository containing
    chart source files as a chart repository. It supports subpaths, custom references,
    and both HTTPS and SSH Git URLs.
  prefs: []
  type: TYPE_NORMAL
