- en: Chapter 4\. Querying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter looks at querying in detail. The main areas covered are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can query for ranges, set inclusion, inequalities, and more by using `$`
    conditionals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries return a database cursor, which lazily returns batches of documents
    as you need them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of metaoperations you can perform on a cursor, including skipping
    a certain number of results, limiting the number of results returned, and sorting
    results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to find
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `find` method is used to perform queries in MongoDB. Querying returns a
    subset of documents in a collection, from no documents at all to the entire collection.
    Which documents get returned is determined by the first argument to `find`, which
    is a document specifying the query criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty query document (i.e., `{}`) matches everything in the collection.
    If `find` isn’t given a query document, it defaults to `{}`. For example, the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: matches every document in the collection *c* (and returns these documents in
    batches).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we start adding key/value pairs to the query document, we begin restricting
    our search. This works in a straightforward way for most types: numbers match
    numbers, booleans match booleans, and strings match strings. Querying for a simple
    type is as easy as specifying the value that you are looking for. For example,
    to find all documents where the value for `"age"` is `27`, we can add that key/value
    pair to the query document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a string we want to match, such as a `"username"` key with the value
    `"joe"`, we use that key/value pair instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple conditions can be strung together by adding more key/value pairs to
    the query document, which gets interpreted as “*`condition1`* AND *`condition2`*
    AND … AND *`conditionN`*.” For instance, to get all users who are 27-year-olds
    with the username “joe,” we can query for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Specifying Which Keys to Return
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you do not need all of the key/value pairs in a document returned.
    If this is the case, you can pass a second argument to `find` (or `findOne`) specifying
    the keys you want. This reduces both the amount of data sent over the wire and
    the time and memory used to decode documents on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a user collection and you are interested only in the
    `"username"` and `"email"` keys, you could return just those keys with the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous output, the `"_id"` key is returned by default,
    even if it isn’t specifically requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use this second parameter to exclude specific key/value pairs
    from the results of a query. For instance, you may have documents with a variety
    of keys, and the only thing you know is that you never want to return the `"fatal_weakness"`
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also prevent `"_id"` from being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some restrictions on queries. The value of a query document must
    be a constant as far as the database is concerned. (It can be a normal variable
    in your own code.) That is, it cannot refer to the value of another key in the
    document. For example, if we were keeping inventory and we had both `"in_stock"`
    and `"num_sold"` keys, we couldn’t compare their values by querying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are ways to do this (see [“$where Queries”](#sect1_d1e4429)), but you
    will usually get better performance by restructuring your document slightly, such
    that a “normal” query will suffice. In this example, we could instead use the
    keys `"initial_stock"` and `"in_stock"`. Then, every time someone buys an item,
    we decrement the value of the `"in_stock"` key by one. Finally, we can do a simple
    query to check which items are out of stock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Query Criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queries can go beyond the exact matching described in the previous section;
    they can match more complex criteria, such as ranges, OR-clauses, and negation.
  prefs: []
  type: TYPE_NORMAL
- en: Query Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`"$lt"`, `"$lte"`, `"$gt"`, and `"$gte"` are all comparison operators, corresponding
    to <, <=, >, and >=, respectively. They can be combined to look for a range of
    values. For example, to look for users who are between the ages of 18 and 30,
    we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This would find all documents where the `"age"` field was greater than or equal
    to `18` AND less than or equal to `30`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These types of range queries are often useful for dates. For example, to find
    people who registered before January 1, 2007, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Depending on how you create and store dates, an exact match might be less useful,
    since dates are stored with millisecond precision. Often you want a whole day,
    week, or month, making a range query necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To query for documents where a key’s value is not equal to a certain value,
    you must use another conditional operator, `"$ne"`, which stands for “not equal.”
    If you want to find all users who do not have the username “joe,” you can query
    for them using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`"$ne"` can be used with any type.'
  prefs: []
  type: TYPE_NORMAL
- en: OR Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to do an OR query in MongoDB. `"$in"` can be used to query
    for a variety of values for a single key. `"$or"` is more general; it can be used
    to query for any of the given values across multiple keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have more than one possible value to match for a single key, use an
    array of criteria with `"$in"`. For instance, suppose we’re running a raffle and
    the winning ticket numbers are 725, 542, and 390\. To find all three of these
    documents, we can construct the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`"$in"` is very flexible and allows you to specify criteria of different types
    as well as values. For example, if we are gradually migrating our schema to use
    usernames instead of user ID numbers, we can query for either by using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This matches documents with a `"user_id"` equal to `12345` and documents with
    a `"user_id"` equal to `"joe"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `"$in"` is given an array with a single value, it behaves the same as directly
    matching the value. For instance, `{ticket_no : {$in : [725]}}` matches the same
    documents as `{ticket_no : 725}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of `"$in"` is `"$nin"`, which returns documents that don’t match
    any of the criteria in the array. If we want to return all of the people who didn’t
    win anything in the raffle, we can query for them with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This query returns everyone who did not have tickets with those numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '`"$in"` gives you an OR query for a single key, but what if we need to find
    documents where `"ticket_no"` is `725` or `"winner"` is `true`? For this type
    of query, we’ll need to use the `"$or"` conditional. `"$or"` takes an array of
    possible criteria. In the raffle case, using `"$or"` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`"$or"` can contain other conditionals. If, for example, we want to match any
    of the three `"ticket_no"` values or the `"winner"` key, we can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With a normal AND-type query, you want to narrow down your results as far as
    possible in as few arguments as possible. OR-type queries are the opposite: they
    are most efficient if the first arguments match as many documents as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: While `"$or"` will always work, use `"$in"` whenever possible as the query optimizer
    handles it more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: $not
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`"$not"` is a metaconditional: it can be applied on top of any other criteria.
    As an example, let’s consider the modulus operator, `"$mod"`. `"$mod"` queries
    for keys whose values, when divided by the first value given, have a remainder
    of the second value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous query returns users with `"id_num"`s of `1`, `6`, `11`, `16`,
    and so on. If we want, instead, to return users with `"id_num"`s of `2`, `3`,
    `4`, `5`, `7`, `8`, `9`, `10`, `12`, etc., we can use `"$not"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`"$not"` can be particularly useful in conjunction with regular expressions
    to find all documents that don’t match a given pattern (regular expression usage
    is described in the section [“Regular Expressions”](#sect2_d1e4085)).'
  prefs: []
  type: TYPE_NORMAL
- en: Type-Specific Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in [Chapter 2](ch02.xhtml#chapter-2), MongoDB has a wide variety
    of types that can be used in a document. Some of these types have special behavior
    when querying.
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`null` behaves a bit strangely. It does match itself, so if we have a collection
    with the following documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'we can query for documents whose `"y"` key is `null` in the expected way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `null` also matches “does not exist.” Thus, querying for a key with
    the value `null` will return all documents lacking that key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we only want to find keys whose value is `null`, we can check that the key
    is `null` and exists using the `"$exists"` conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`"$regex"` provides regular expression capabilities for pattern matching strings
    in queries. Regular expressions are useful for flexible string matching. For example,
    if we want to find all users with the name “Joe” or “joe,” we can use a regular
    expression to do case-insensitive matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular expression flags (e.g., `i`) are allowed but not required. If we want
    to match not only various capitalizations of “joe,” but also “joey,” we can continue
    to improve our regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB uses the Perl Compatible Regular Expression (PCRE) library to match
    regular expressions; any regular expression syntax allowed by PCRE is allowed
    in MongoDB. It is a good idea to check your syntax with the JavaScript shell before
    using it in a query to make sure it matches what you think it matches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: MongoDB can leverage an index for queries on prefix regular expressions (e.g.,
    `/^joey/`). Indexes *cannot* be used for case-insensitive searches (`/^joey/i`).
    A regular expression is a “prefix expression” when it starts with either a caret
    (`^`) or a left anchor (`\A`). If the regular expression uses a case-sensitive
    query, then if an index exists for the field, the matches can be conducted against
    values in the index. If it also is a prefix expression, then the search can be
    limited to the values within the range created by that prefix from the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions can also match themselves. Very few people insert regular
    expressions into the database, but if you insert one, you can match it with itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Querying Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Querying for elements of an array is designed to behave the way querying for
    scalars does. For example, if the array is a list of fruits, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'the following query will successfully match the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can query for it in much the same way as we would if we had a document that
    looked like the (illegal) document `{"fruit" : "apple", "fruit" : "banana", "fruit"
    : "peach"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: “$all”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to match arrays by more than one element, you can use `"$all"`.
    This allows you to match a list of elements. For example, suppose we create a
    collection with three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can find all documents with both `"apple"` and `"banana"` elements
    by querying with `"$all"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Order does not matter. Notice `"banana"` comes before `"apple"` in the second
    result. Using a one-element array with `"$all"` is equivalent to not using `"$all"`.
    For instance, `{fruit : {$all : [''apple'']}` will match the same documents as
    `{fruit : ''apple''}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also query by exact match using the entire array. However, exact match
    will not match a document if any elements are missing or superfluous. For example,
    this will match the first of our three documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'But this will not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'and neither will this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to query for a specific element of an array, you can specify an
    index using the syntax *`key`*.*`index`*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Arrays are always 0-indexed, so this would match the third array element against
    the string `"peach"`.
  prefs: []
  type: TYPE_NORMAL
- en: “$size”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A useful conditional for querying arrays is `"$size"`, which allows you to
    query for arrays of a given size. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One common query is to get a range of sizes. `"$size"` cannot be combined with
    another `$` conditional (in this example, `"$gt"`), but this query can be accomplished
    by adding a `"size"` key to the document. Then, every time you add an element
    to the array, increment the value of `"size"`. If the original update looked like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'it can simply be changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Incrementing is extremely fast, so any performance penalty is negligible. Storing
    documents like this allows you to do queries such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this technique doesn’t work as well with the `"$addToSet"` operator.
  prefs: []
  type: TYPE_NORMAL
- en: “$slice”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, the optional second argument to `find`
    specifies the keys to be returned. The special `"$slice"` operator can be used
    to return a subset of elements for an array key.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we had a blog post document and we wanted to return the
    first 10 comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we wanted the last 10 comments, we could use `−10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`"$slice"` can also return pages in the middle of the results by taking an
    offset and the number of elements to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This would skip the first 23 elements and return the 24th through 33rd. If there
    were fewer than 33 elements in the array, it would return as many as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless otherwise specified, all keys in a document are returned when `"$slice"`
    is used. This is unlike the other key specifiers, which suppress unmentioned keys
    from being returned. For instance, if we had a blog post document that looked
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and we did a `"$slice"` to get the last comment, we’d get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Both `"title"` and `"content"` are still returned, even though they weren’t
    explicitly included in the key specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a matching array element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`"$slice"` is helpful when you know the index of the element, but sometimes
    you want whichever array element matched your criteria. You can return the matching
    element with the `$` operator. Given the previous blog example, you could get
    Bob’s comment back with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this only returns the first match for each document: if Bob had left
    multiple comments on this post, only the first one in the `"comments"` array would
    be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Array and range query interactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scalars (nonarray elements) in documents must match each clause of a query’s
    criteria. For example, if you queried for `{"x" : {"$gt" : 10, "$lt" : 20}}`,
    `"x"` would have to be both greater than 10 and less than 20\. However, if a document’s
    `"x"` field is an array, the document matches if there is an element of `"x"`
    that matches each part of the criteria *but each query clause can match a different
    array element*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to understand this behavior is to see an example. Suppose we have
    the following documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to find all documents where `"x"` is between 10 and 20, we might
    naively structure a query as `db.test.find({"x" : {"$gt" : 10, "$lt" : 20}})`
    and expect to get back one document: `{"x" : 15}`. However, running this, we get
    two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Neither 5 nor 25 is between 10 and 20, but the document is returned because
    25 matches the first clause (it is greater than 10) and 5 matches the second clause
    (it is less than 20).
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes range queries against arrays essentially useless: a range will match
    any multielement array. There are a couple of ways to get the expected behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can use `"$elemMatch"` to force MongoDB to compare both clauses
    with a single array element. However, the catch is that `"$elemMatch"` won’t match
    nonarray elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The document `{"x" : 15}` no longer matches the query, because the `"x"` field
    is not an array. That said, you should have a good reason for mixing array and
    scalar values in a field. Many uses cases do not require mixing. For those, `"$elemMatch"`
    provides a good solution for range queries on array elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an index over the field that you’re querying on (see [Chapter 5](ch05.xhtml#chapter_d1e5128)),
    you can use `min` and `max` to limit the index range traversed by the query to
    your `"$gt"` and `"$lt"` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now this will only traverse the index from 10 to 20, missing the 5 and 25 entries.
    You can only use `min` and `max` when you have an index on the field you are querying
    for, though, and you must pass all fields of the index to `min` and `max`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `min` and `max` when querying for ranges over documents that may include
    arrays is generally a good idea. The index bounds for a `"$gt"`/`"$lt"` query
    over an array is inefficient. It basically accepts any value, so it will search
    every index entry, not just those in the range.
  prefs: []
  type: TYPE_NORMAL
- en: Querying on Embedded Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of querying for an embedded document: querying for the whole
    document or querying for its individual key/value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying for an entire embedded document works identically to a normal query.
    For example, if we have a document that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'we can query for someone named Joe Schmoe with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a query for a full subdocument must exactly match the subdocument.
    If Joe decides to add a middle name field, suddenly this query won’t work anymore;
    it doesn’t match the entire embedded document! This type of query is also order-sensitive:
    `{"last" : "Schmoe", "first" : "Joe"}` would not be a match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If possible, it’s usually a good idea to query for just a specific key or keys
    of an embedded document. Then, if your schema changes, all of your queries won’t
    suddenly break because they’re no longer exact matches. You can query for embedded
    keys using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, if Joe adds more keys, this query will still match his first and last names.
  prefs: []
  type: TYPE_NORMAL
- en: This dot notation is the main difference between query documents and other document
    types. Query documents can contain dots, which mean “reach into an embedded document.”
    Dot notation is also the reason that documents to be inserted cannot contain the
    `.` character. Oftentimes people run into this limitation when trying to save
    URLs as keys. One way to get around it is to always perform a global replace before
    inserting or after retrieving, substituting a character that isn’t legal in URLs
    for the dot character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Embedded document matches can get a little tricky as the document structure
    gets more complicated. For example, suppose we are storing blog posts and we want
    to find comments by Joe that were scored at least a 5\. We could model the post
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can’t query using `db.blog.find({"comments" : {"author" : "joe", "score"
    : {"$gte" : 5}}})`. Embedded document matches have to match the whole document,
    and this doesn’t match the `"comment"` key. It also wouldn’t work to do `db.blog.find({"comments.author"
    : "joe", "comments.score" : {"$gte" : 5}})`, because the author criterion could
    match a different comment than the score criterion. That is, it would return the
    document shown above: it would match `"author" : "joe"` in the first comment and
    `"score" : 6` in the second comment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To correctly group criteria without needing to specify every key, use `"$elemMatch"`.
    This vaguely named conditional allows you to partially specify criteria to match
    a single embedded document in an array. The correct query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`"$elemMatch"` allows you to “group” your criteria. As such, it’s only needed
    when you have more than one key you want to match on in an embedded document.'
  prefs: []
  type: TYPE_NORMAL
- en: $where Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Key/value pairs are a fairly expressive way to query, but there are some queries
    that they cannot represent. For queries that cannot be done any other way, there
    are `"$where"` clauses, which allow you to execute arbitrary JavaScript as part
    of your query. This allows you to do (almost) anything within a query. For security,
    use of `"$where"` clauses should be highly restricted or eliminated. End users
    should never be allowed to execute arbitrary `"$where"` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common case for using `"$where"` is to compare the values for two
    keys in a document. For instance, suppose we have documents that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We’d like to return documents where any two of the fields are equal. For example,
    in the second document, `"spinach"` and `"watermelon"` have the same value, so
    we’d like that document returned. It’s unlikely MongoDB will ever have a `$` conditional
    for this, so we can use a `"$where"` clause to do it with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If the function returns `true`, the document will be part of the result set;
    if it returns `false`, it won’t be.
  prefs: []
  type: TYPE_NORMAL
- en: '`"$where"` queries should not be used unless strictly necessary: they are much
    slower than regular queries. Each document has to be converted from BSON to a
    JavaScript object and then run through the `"$where"` expression. Indexes cannot
    be used to satisfy a `"$where"` either. Hence, you should use `"$where"` only
    when there is no other way of doing the query. You can cut down on the penalty
    by using other query filters in combination with `"$where"`. If possible, an index
    will be used to filter based on the non-`$where` clauses; the `"$where"` expression
    will be used only to fine-tune the results. MongoDB 3.6 added the `$expr` operator
    which allows the use of aggregation expressions with the MongoDB query language.
    It is faster than `$where` as it does not execute JavaScript and is recommended
    as a replacement to this operator where possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Another way of doing complex queries is to use one of the aggregation tools,
    which are covered in [Chapter 7](ch07.xhtml#chapter_d1e6036).
  prefs: []
  type: TYPE_NORMAL
- en: Cursors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The database returns results from `find` using a *cursor*. The client-side implementations
    of cursors generally allow you to control a great deal about the eventual output
    of a query. You can limit the number of results, skip over some number of results,
    sort results by any combination of keys in any direction, and perform a number
    of other powerful operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a cursor with the shell, put some documents into a collection, do
    a query on them, and assign the results to a local variable (variables defined
    with `"var"` are local). Here, we create a very simple collection and query it,
    storing the results in the `cursor` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of doing this is that you can look at one result at a time. If
    you store the results in a global variable or no variable at all, the MongoDB
    shell will automatically iterate through and display the first couple of documents.
    This is what we’ve been seeing up until this point, and it is often the behavior
    you want for seeing what’s in a collection but not doing actual programming with
    the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate through the results, you can use the `next` method on the cursor.
    You can use `hasNext` to check whether there is another result. A typical loop
    through result looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`cursor.hasNext()` checks that the next result exists, and `cursor.next()`
    fetches it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cursor` class also implements JavaScript’s iterator interface, so you
    can use it in a `forEach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call `find`, the shell does not query the database immediately. It
    waits until you start requesting results to send the query, which allows you to
    chain additional options onto a query before it is performed. Almost every method
    on a `cursor` object returns the cursor itself, so that you can chain options
    in any order. For instance, all of the following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the query has not been executed yet. All of these functions
    merely build the query. Now, suppose we call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the query will be sent to the server. The shell fetches the first
    100 results or first 4 MB of results (whichever is smaller) at once so that the
    next calls to `next` or `hasNext` will not have to make trips to the server. After
    the client has run through the first set of results, the shell will again contact
    the database and ask for more results with a `getMore` request. `getMore` requests
    basically contain an identifier for the cursor and ask the database if there are
    any more results, returning the next batch if there are. This process continues
    until the cursor is exhausted and all results have been returned.
  prefs: []
  type: TYPE_NORMAL
- en: Limits, Skips, and Sorts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common query options are limiting the number of results returned, skipping
    a number of results, and sorting. All these options must be added before a query
    is sent to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a limit, chain the `limit` function onto your call to `find`. For example,
    to only return three results, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If there are fewer than three documents matching your query in the collection,
    only the number of matching documents will be returned; `limit` sets an upper
    limit, not a lower limit.
  prefs: []
  type: TYPE_NORMAL
- en: '`skip` works similarly to `limit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This will skip the first three matching documents and return the rest of the
    matches. If there are fewer than three documents in your collection, it will not
    return any documents.
  prefs: []
  type: TYPE_NORMAL
- en: '`sort` takes an object: a set of key/value pairs where the keys are key names
    and the values are the sort directions. The sort direction can be `1` (ascending)
    or `−1` (descending). If multiple keys are given, the results will be sorted in
    that order. For instance, to sort the results by `"username"` ascending and `"age"`
    descending, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'These three methods can be combined. This is often handy for pagination. For
    example, suppose that you are running an online store and someone searches for
    *mp3*. If you want 50 results per page sorted by price from high to low, you can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If that person clicks Next Page to see more results, you can simply add a skip
    to the query, which will skip over the first 50 matches (which the user already
    saw on page 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: However, large skips are not very performant; there are suggestions for how
    to avoid them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongoDB has a hierarchy as to how types compare. Sometimes you will have a
    single key with multiple types: for instance, integers and booleans, or strings
    and nulls. If you do a sort on a key with a mix of types, there is a predefined
    order that they will be sorted in. From least to greatest value, this ordering
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Numbers (integers, longs, doubles, decimals)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object/document
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Binary data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object ID
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Timestamp
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regular expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximum value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoiding Large Skips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `skip` for a small number of documents is fine. But for a large number
    of results, `skip` can be slow, since it has to find and then discard all the
    skipped results. Most databases keep more metadata in the index to help with skips,
    but MongoDB does not yet support this, so large skips should be avoided. Often
    you can calculate the results of the next query based on the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Paginating results without skip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to do pagination is to return the first page of results using
    `limit` and then return each subsequent page as an offset from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'However, depending on your query, you can usually find a way to paginate without
    skips. For example, suppose we want to display documents in descending order based
    on `"date"`. We can get the first page of results with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, assuming the date is unique, we can use the `"date"` value of the last
    document as the criterion for fetching the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now the query does not need to include a skip.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a random document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One fairly common problem is how to get a random document from a collection.
    The naive (and slow) solution is to count the number of documents and then do
    a `find`, skipping a random number of documents between zero and the size of the
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually highly inefficient to get a random element this way: you have
    to do a count (which can be expensive if you are using criteria), and skipping
    large numbers of elements can be time-consuming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes a little forethought, but if you know you’ll be looking up a random
    element in a collection, there’s a much more efficient way to do so. The trick
    is to add an extra random key to each document when it is inserted. For instance,
    if we’re using the shell, we could use the `Math.random()` function (which creates
    a random number between 0 and 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we want to find a random document from the collection, we can calculate
    a random number and use that as a query criterion, instead of using `skip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a slight chance that `random` will be greater than any of the `"random"`
    values in the collection, and no results will be returned. We can guard against
    this by simply returning a document in the other direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If there aren’t any documents in the collection, this technique will end up
    returning `null`, which makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique can be used with arbitrarily complex queries; just make sure
    to have an index that includes the random key. For example, if we want to find
    a random plumber in California, we can create an index on `"profession"`, `"state"`,
    and `"random"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to quickly find a random result (see [Chapter 5](ch05.xhtml#chapter_d1e5128)
    for more information on indexing).
  prefs: []
  type: TYPE_NORMAL
- en: Immortal Cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two sides to a cursor: the client-facing cursor and the database
    cursor that the client-side one represents. We have been talking about the client-side
    one up until now, but we are going to take a brief look at what’s happening on
    the server.'
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, a cursor takes up memory and resources. Once a cursor runs
    out of results or the client sends a message telling it to die, the database can
    free the resources it was using. Freeing these resources lets the database use
    them for other things, which is good, so we want to make sure that cursors can
    be freed quickly (within reason).
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of conditions that can cause the death (and subsequent cleanup)
    of a cursor. First, when a cursor finishes iterating through the matching results,
    it will clean itself up. Another way is that, when a cursor goes out of scope
    on the client side, the drivers send the database a special message to let it
    know that it can kill that cursor. Finally, even if the user hasn’t iterated through
    all the results and the cursor is still in scope, after 10 minutes of inactivity,
    a database cursor will automatically “die.” This way, if a client crashes or is
    buggy, MongoDB will not be left with thousands of open cursors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This “death by timeout” is usually the desired behavior: very few applications
    expect their users to sit around for minutes at a time waiting for results. However,
    sometimes you might know that you need a cursor to last for a long time. In that
    case, many drivers have implemented a function called `immortal`, or a similar
    mechanism, which tells the database not to time out the cursor. If you turn off
    a cursor’s timeout, you must iterate through all of its results or kill it to
    make sure it gets closed. Otherwise, it will sit around in the database hogging
    resources until the server is restarted.'
  prefs: []
  type: TYPE_NORMAL
