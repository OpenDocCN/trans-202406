- en: Chapter 2\. Simple Persistence with the Web Storage API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web Storage API persists simple data locally, in the user’s browser. You
    can retrieve this data later, even after closing and reopening the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This API has a `Storage` interface that provides data access and persistence.
    You don’t create instances of `Storage` directly; there are two global instances:
    `window.localStorage` and `window.sessionStorage`. The only difference between
    these is how long they retain the data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sessionStorage` data is associated with a specific browser session. It retains
    the data if the page is reloaded, but closing the browser completely loses the
    data. Different tabs for the same origin do not share the same persisted data.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `localStorage` shares the same storage space across all tabs
    and sessions for the same origin. The browser retains this data even after you
    close the browser. In general, session storage is a good choice if you want to
    store something ephemeral or sensitive that you want to be destroyed once the
    browser is closed.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, storage space is specific to a given origin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Setting Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web Storage can only store string values. Each value has a key that you can
    use to look it up. The API is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getItem(key)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the string bound to a key, or `null` if the key doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '`setItem(key, value)`'
  prefs: []
  type: TYPE_NORMAL
- en: Stores a string value under the given key. If the key already exists, you’ll
    overwrite it.
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes all stored data for the current origin.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web Storage can be really useful, but it does have a few disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Data storage limitations
  prefs: []
  type: TYPE_NORMAL
- en: Web Storage can only store string data. You can store simple objects, but not
    directly—you’ll need to convert them to a JavaScript Object Notation (JSON) string
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Size limitations
  prefs: []
  type: TYPE_NORMAL
- en: Each origin has a limited amount of space available for storage. In most browsers
    this is 5 megabytes. If an origin’s storage becomes full, the browser will throw
    an exception if you attempt to add more data.
  prefs: []
  type: TYPE_NORMAL
- en: Security concerns
  prefs: []
  type: TYPE_NORMAL
- en: Even though the browser stores each origin’s data separately, it’s still vulnerable
    to cross-site scripting (XSS) attacks. An attacker can inject code via an XSS
    attack that steals locally persisted data. Be mindful of what sensitive data you
    store here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The recipes in this chapter all use *local* storage, but they all apply to *session*
    storage as well, since both objects implement the same `Storage` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Web Storage Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check if local storage is available before using it to avoid crashing
    your app. You also want to handle the situation where local storage is available
    but blocked by user settings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check the global `window` object for the `localStorage` property to verify that
    the browser supports local storage. If the check passes, local storage is available
    (see [Example 2-1](#code_checkLocalStorage)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Checking if local storage is available
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function in [Example 2-1](#code_checkLocalStorage) handles both cases:
    if local storage is supported at all, and if it exists and is not blocked by user
    settings.'
  prefs: []
  type: TYPE_NORMAL
- en: It checks to see if the `window.localStorage` property is not `undefined`. If
    this check passes, this means the browser supports local storage. If the user
    has *blocked* local storage, just the act of referencing the `window.localStorage`
    property throws an exception with a message saying access is denied.
  prefs: []
  type: TYPE_NORMAL
- en: By surrounding the property check with a `try`/`catch` block, you can also handle
    this case. When catching the exception, it considers local storage not available
    and returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting String Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to persist a string value to local storage and read it back later.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `localStorage.getItem` and `localStorage.setItem` to read and write the
    data. [Example 2-2](#example2-2) shows how we can use local storage to remember
    the value of a color picker.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Persisting data to local storage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the page first loads, local storage is checked for a previously saved color.
    If you call `getItem` with a key that doesn’t exist, it returns `null`. The return
    value is only set in the color picker if it is not null or empty.
  prefs: []
  type: TYPE_NORMAL
- en: When the color picker’s value changes, the event handler saves the new value
    to local storage. If there’s already a saved color, this overwrites it.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting Simple Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a JavaScript object, such as a user profile, that you want to persist
    to local storage. You can’t do this directly because local storage only supports
    string values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `JSON.stringify` to convert the object to a JSON string before saving it.
    When loading the value later, use `JSON.parse` to turn it back into an object,
    as shown in [Example 2-3](#example2-3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Using `JSON.parse` and `JSON.stringify`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing the profile object directly to `localStorage.setItem` won’t have the
    desired effect, as shown in [Example 2-4](#example2-4).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Attempting to persist an array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The saved value is `[object Object]`. This is the result of calling `toString`
    on the profile object.
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.stringify` takes an object and returns a JSON string representing the
    object. Passing the user profile object to `JSON.stringify` results in this JSON
    string (whitespace added for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This approach works for objects like the user profile, but the [JSON specification](https://www.json.org)
    limits what can be serialized to a string. Generally speaking, these are objects,
    arrays, strings, numbers, booleans, and `null`. Other values, like class instances
    or functions, can’t be serialized in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting Complex Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to persist an object that can’t be directly serialized to a JSON string,
    to local storage. For example, the user profile object might have a `Date` object
    in it specifying when it was last updated.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `replacer` and `reviver` functions with `JSON.stringify` and `JSON.parse`
    to provide custom serialization for the complex data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following profile object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you serialize this object with `JSON.stringify`, the resulting string has
    the `lastUpdated` date as an ISO date string (see [Example 2-5](#example2-5)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Attempting to serialize an object with a `Date` object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting JSON string looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now you have a JSON string that you can save to local storage. However, if you
    call `JSON.parse` with this JSON string, the resulting object differs slightly
    from the original. The `lastUpdated` property is still a string, not a `Date`,
    because `JSON.parse` doesn’t know that this should be a `Date` object.
  prefs: []
  type: TYPE_NORMAL
- en: To handle these situations, `JSON.stringify` and `JSON.parse` accept special
    functions called `replacer` and `reviver`, respectively. These functions provide
    custom logic to convert nonprimitive values to and from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing with a replacer function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `replacer` argument to `JSON.stringify` can work in several different ways.
    MDN has some comprehensive [documentation on the `replacer` function](https://oreil.ly/H56TM).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `replacer` function takes two arguments: `key` and `value` (see [Example 2-6](#example2-6)).
    `JSON.stringify` first calls this function with an empty string as the key, and
    the object being stringified as the value. You can transform the `lastUpdated`
    field here to a serializable representation of the `Date` object by calling `getTime()`,
    which gives the date as the number of milliseconds since the epoch (midnight UTC
    on January 1, 1970).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. The `replacer` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can pass this `replacer` function to `JSON.stringify` to serialize the object
    to JSON, as shown in [Example 2-7](#example2-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Stringifying with the `replacer`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The number in the `lastUpdated` property is the timestamp for June 2, 2025.
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing with the reviver function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later, when you pass this JSON string to `JSON.parse`, the `lastUpdated` property
    remains as a number (the timestamp). You can use a `reviver` function to transform
    this serialized number value back into a `Date` object.
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.parse` calls the `reviver` function for each property in the JSON string.
    For each key, the value returned from the function is the value that is set in
    the final object (see [Example 2-8](#example2-8)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. The `reviver` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To use the `reviver`, pass it as the second argument to `JSON.parse`, as shown
    in [Example 2-9](#example2-9).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. Parsing with the `reviver`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns an object that is equal to the user profile object we started
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this reliable method to convert this object to and from JSON, keeping the
    `Date` property intact, you can persist these values in local storage.
  prefs: []
  type: TYPE_NORMAL
- en: The approach shown here is just one way to work with a `replacer` function.
    Instead of a `replacer` function, you could also define a `toJSON` function on
    the object being stringified. Combined with a factory function, no `replacer`
    function is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Using a factory that adds a `toJSON` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Calling `JSON.stringify` with the object in [Example 2-10](#factoryToJSON) returns
    the same JSON string as before, with `lastUpdated` properly converted to a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There isn’t any mechanism like this for parsing a string back to an object with
    `JSON.parse`. If you use the `toJSON` approach shown here, you’ll still need to
    write a `reviver` function to properly deserialize a user profile string.
  prefs: []
  type: TYPE_NORMAL
- en: Since functions can’t be serialized, the resulting JSON string won’t have a
    `toJSON` property. Whatever method you choose, the resulting JSON is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for Storage Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to receive a notification when another tab on the same origin makes
    changes to local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Listen for the `storage` event on the `window` object. This event fires when
    other tabs or sessions in the same browser, on the same origin, make changes to
    any data in local storage (see [Example 2-11](#example2-11)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. Listening for storage changes from another tab
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Consider the persistent color picker from [“Persisting String Data”](#recipe_persistStringData).
    If the user has multiple tabs open and changes the color in another tab, you can
    get notified and update the local in-memory copy of the data to keep everything
    in sync.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `storage` event is *not* triggered on the tab or page that made the storage
    change. It’s meant to listen for changes that *other* pages have made to local
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: A `storage` event specifies which key was changed and what the new value is.
    It also includes the old value, in case you need it for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main use case for the `storage` event is to keep multiple sessions in sync
    with each other in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `storage` event is only triggered for other tabs and sessions in the same
    browser on the same device.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don’t listen for the `storage` event, all sessions on the same origin
    still share the same local storage data. If you call `localStorage.getItem` at
    any point, you’ll still get the latest value. The `storage` event just provides
    a real-time notification when such a change happens so the app can update the
    local data.
  prefs: []
  type: TYPE_NORMAL
- en: Finding All Known Keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know all the keys that are currently in local storage for the current
    origin.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `length` property with the `key` function to build a list of all the
    known keys. `Storage` objects don’t have a function to return the list of keys
    directly, but you can build such a list by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `length` property returns the number of keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `key` function, given an index, returns the key at that index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can combine these with a `for` loop to build an array of all the keys, as
    shown [Example 2-12](#buildListKeys).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. Building a list of keys
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can combine the `length` property and the `key` function to perform other
    types of queries, too. This could be, for example, a function that takes an array
    of keys and returns an object containing just those key/value pairs (see [Example 2-13](#example2-13)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13\. Querying for a subset of key/value pairs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ordering of the keys, as referenced with the `key` function, may not be
    the same across different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to remove some, or all, data from local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `removeItem` and `clear` methods as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: To remove a particular key/value pair from local storage, call `localStorage.remove​I⁠tem`
    with the key (see [Example 2-14](#example2-14)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. Removing an item from local storage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Call `localStorage.clear` to remove *all* data from local storage for the current
    origin, as shown in [Example 2-15](#example2-15).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. Removing all items from local storage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Browsers limit the amount of data that you can store in Web Storage. Typically,
    the limit is about 5 MB. To avoid running out of space and throwing an error,
    you should remove items once they are no longer needed. Depending on what you’re
    using Web Storage for, you can also provide a way for your users to clear stored
    data. Consider an emoji picker that stores recently selected emojis in local storage.
    You might add a Clear Recents button that removes these items.
  prefs: []
  type: TYPE_NORMAL
