- en: Chapter 8\. Maintaining System Health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining system health is a broad topic that includes preventative maintenance,
    housekeeping, patching, security tasks, user maintenance, and monitoring and mitigating
    various types of sprawl. Maintaining the health of your systems is an active task,
    not a passive one.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring can help. Automating periodic cleanup of certain areas can help.
    Automating updates can help, but you must actively watch logs, check space and
    sprawl, and take care of user maintenance tasks. Many of these tasks require eyes
    on screens and hands on keyboards. Far fewer system administrators would be required
    if you could automate every aspect of system health maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers both automated and manual system health maintenance tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Your System Clutter-Free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Housekeeping is something that no one loves to do. It’s tedious, time-consuming,
    and can anger users to the point of reporting your behavior to management, which
    is never a good thing. As long as you comply with corporate policy and don’t apply
    any of your own, you’ll have material to refer your angry users to. The rules
    for decluttering a system are the same for any maintenance you do: have a good
    backup available if you remove a critical file or directory by accident. The following
    sections detail how to keep your systems clutter-free.'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning the /tmp Directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The */tmp* directory is a shared directory. It’s shared with all users, applications,
    and system processes. Anyone may write to this directory, which is bad for administrators
    because having unlimited access to a system directory can have fatal consequences.
    If the original administrator didn’t create the */tmp* directory as a separate
    filesystem with access to limited space, users or applications can potentially
    fill up all of the space. The */tmp* directory should never be a part of the same
    partition as */* for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: The */tmp* directory is tricky from a housekeeping perspective for sysadmins
    because there are no restrictions on users, applications, or the system. Because
    any user may write to it, they might expect that it’s extra, available free space
    where they can store downloads and other files. To make this directory a less
    desirable location to store files, you should create a `cron` job to run every
    night, after backups, to remove any nonsystem files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In many enterprises, automated scripts remove user-created files from the */tmp*
    directory every night, and most exclude */tmp* directories from backups.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the */tmp* dilemma if you don’t want to create a separate filesystem
    and mount it on */tmp* is to enable *tmp.mount*. This service creates a temporary
    filesystem (tmpfs) and mounts it as */tmp*. One of the features is that it’s volatile
    storage (RAM) and filling it up won’t cause stability issues on your system.
  prefs: []
  type: TYPE_NORMAL
- en: To enable *tmp.mount* on your system, complete the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check your */tmp* directory mount point to see if you need to configure
    *tmp.mount*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, my */tmp* has the flaw of being a subdirectory of the */* filesystem.
    Enable *tmp.mount* and then start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the */tmp* directory is no longer a subdirectory of */*. Enabling *tmp.mount*
    makes this configuration persistent, which means it is a permanent change and
    will be automatically created each time the system is booted.
  prefs: []
  type: TYPE_NORMAL
- en: The next section deals with keeping the */home* directory usable for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Making /home a Livable Space for Everyone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The */home* directory is a shared directory because it contains all users’
    home directories, except for the root user. For example, suppose you have users
    `tux`, `penguin`, and `gentoo` on your system. Their home directories will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On systems where the */home* directory is on the same filesystem as the */*
    directory, there is a potential that users can fill up */* and cause system problems,
    much the same as filling up */tmp*, as discussed in the previous section. Because
    of the nature of files contained in */home*, you can’t create and mount a volatile
    filesystem for it. The */home* directory must be a permanently mounted filesystem,
    preferably not part of */*. If it is part of */*, there are two approaches to
    correct it. The first entails the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Shrinking an existing LVM filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a partition and filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting that filesystem as */home*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second approach involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing a new disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting that new partition as */home*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the demonstration in this chapter, I’ll use the second approach of installing
    a new disk for */home*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to complete this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or install a new disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new partition on the disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the filesystem on the new partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the new partition on */mnt*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or move all files from */home* to */mnt*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all files from */home*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unmount the new partition from */mnt*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the new partition on */home*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an entry for */home* in */etc/fstab*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I added a 1 GB disk to my VM to demonstrate these steps. The following sections
    explain how to complete each step in this process.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new partition on the disk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Identify the new disk by listing all disk block devices on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sdc` (*/dev/sdc*) device is the new disk. It is the 1 GB disk I added
    to the virtual machine. To create a new partition on the disk, use the `fdisk`
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'List the `sdc` block device to verify that the partition */dev/sdc1* exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The */dev/sdc1* partition exists and is ready to have a filesystem created on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Create the filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the */home* directory, format it as the `ext4` filesystem type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that you correctly created the `ext4` filesystem on */dev/sdc1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Mount the new partition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use the new partition, you must mount it. I use */mnt* as the temporary
    mount point to copy files from */home* to the new partition I will eventually
    mount as */home*. If I mount */dev/sdc1* onto */home* now, I can’t copy the files
    because mounting on */home* hides its files from view. Mounting a device onto
    a nonempty directory hides its contents and makes its files inaccessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Copy files from /home to /mnt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Copy all files from the */home* directory to preserve all (`-a`) permissions,
    links, and timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remove all files from /home
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The reason that I remove all files from the original */home* directory is that
    it releases disk space back to the */* filesystem, which is one of the reasons
    why we’re going through this exercise. The following command removes all directories
    under */home* without removing the */home* directory. There’s no need to remove
    */home*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Unmount /dev/sdc1 from /mnt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unmount */dev/sdc1* from */mnt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Mount the new partition on /home
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mount the new partition onto the */home* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The true test of this exercise is to log in as a user and check if everything
    works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Create the /etc/fstab entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The */home* directory won’t mount automatically after a system reboot because
    */home* is on a different partition that is not listed in */etc/fstab*. You must
    create an */etc/fstab* entry for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'My */etc/fstab* entry for */dev/sdc1* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This */etc/fstab* entry makes the mount persistent.
  prefs: []
  type: TYPE_NORMAL
- en: The next section deals with archiving and removing “stale” and duplicated files
    from shared directories.
  prefs: []
  type: TYPE_NORMAL
- en: Decluttering Shared Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping shared directories free of clutter is difficult. It might be impossible,
    but there are some things you can do to confront the issue using system tools
    and some planning. This section explores some utilities that can simplify decluttering
    and housekeeping.
  prefs: []
  type: TYPE_NORMAL
- en: Deduplicating Files with fdupes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`fdupes` is a popular deduplication utility. `fdupes` finds duplicate files
    in a given set of directories. The [`fdupes` man page](https://oreil.ly/XERaf)
    describes the command’s function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Searches the given path for duplicate files. Such files are found by comparing
    file sizes and MD5 signatures, followed by a byte-by-byte comparison.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can install `fdupes` from your distribution’s repositories, but it’s better
    to grab the patched version from a GitHub repository using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This patched version has more options such as the one you’re most likely to
    use as a system administrator in a production environment. When you use `fdupes`
    on a directory, you can just look at the duplicates, delete the duplicates (not
    recommended), or remove the duplicates but provide soft links to one of the files
    (recommended). This solution presents a problem only if the original file no longer
    exists. But providing a soft link to one of the files is far less invasive than
    removing the duplicates, which may result in tickets, phone calls, and reprimands.
    Examples [8-1](#list_duplicate_files_and_their_sizes) through [8-3](#provide_links_to_one_of_the_files)
    illustrate how to use `fdupe``s` to find duplicates, generate a report, and then
    only provide links to one of the files.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. List duplicate files and their sizes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `-r` option is recursive, which means check the specified directory and
    all its subdirectories. The `-S` option means to report the file sizes.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 8-2](#generate_a_duplicate_file_report_using), the `-m` option tells
    `fdupes` to print a report of any duplicates found.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. Generate a duplicate file report using the `-m` option
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 8-3](#provide_links_to_one_of_the_files), `fdupes` replaces duplicate
    files with hard links using the `-L` option. Only the first found file in each
    group of duplicates remains intact.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. Provide links to one of the files
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the selective delete option, `-d`, you’re prompted for which file(s)
    you want to keep. Again, deleting files is highly discouraged. Proceed at your
    own risk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This option removes files except for the one(s) you preserve and does not create
    links. Check the online help and man pages for `fdupes` for other options.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling /home File Sprawl with Quotas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some system administrators and users find that using quotas is a harsh solution
    to dealing with file sprawl. I find it a good solution that works well in various
    situations to help deal with users who chronically use up more than their fair
    share of disk space. You can implement quotas on any directory, but you certainly
    want to consider it for shared directories and */home*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to install `quota`, if your system doesn’t have it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `quota` system, you’ll need to have an `xfs` filesystem handy and
    mounted. Mine, for example, is */home*. Create an entry in */etc/fstab* for the
    `xfs` filesystem. Here is the */etc/fstab* entry for */home* where I want to enforce
    quotas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create two new empty files on */home*: *quota.group* and *quota.user*.
    These two files must exist in any directory that’s configured for quotas, which
    are used by the `quota` system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enable quotas  with the `quotaon` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The system is now ready to apply quotas to users’ accounts. The following command
    sets a very low `quota` value for demonstration purposes. The soft limit is 50
    MB, and the hard limit is 80 MB. You receive a warning when you exceed the soft
    limit, but the `quota` system prevents you from exceeding the hard limit. You
    can also limit the number of inodes (file metadata structures) that a user may
    consume. The inode limit is a bit harsher because a user might generate thousands
    of tiny text files that only amount to a few megabytes, but it limits the number
    of files users can create. There are hard and soft limits for inodes as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of what the user sees when they exceed a quota. 
    The `head` command creates a 51 MB file to illustrate how quotas truncate files
    that exceed a set quota limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can see that when the user reached their hard limit, the system truncated
    the files they attempted to create (*fillit1.txt*). If no quota had been placed
    on the user, they would have had two 51 MB files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quotas prevent users from consuming more than a given amount of space on a
    filesystem or directory. Still, they should only be enforced on users who violate
    company policy or egregiously store personal files on company systems. You can
    easily remove a quota limit from a user’s account by setting all limits to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now there are no warnings (or truncations) about exceeding limits. The `djones`
    account no longer has quota limits imposed on it.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a good introduction to quotas, what they can do for you as an administrator,
    and how they can keep your users in check with their space usage. The next topic
    to explore is patching, an essential task for any administrator wanting to keep
    their system running smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Patching Your Way to a Healthy System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Patching, to the new system administrator, might sound like you’re putting
    duct tape on a system to hold it together temporarily while you locate the real
    fix for a problem. Patching is an essential task and perhaps is a misnomer for
    what it is: updating system utilities, daemons, and applications with fixes supplied
    by developers. A software patch fixes a specific problem. A good example is applying
    a patch to the SSH daemon to resolve new vulnerabilities that can render a system
    susceptible to attack and compromise.'
  prefs: []
  type: TYPE_NORMAL
- en: Patching isn’t always security-focused. Often, patches fix a stability problem,
    plug a memory leak, or repair a broken feature. Remember that patching a Linux
    system rarely means that you’ll have to initiate a reboot, but if you update a
    service, you’ll want to restart that service unless the patching process takes
    care of that for you. If the patching process restarts a service, a message will
    appear on the screen informing you of the restart. To be safe, I often reboot
    after a major patch event to ensure that the system and its services receive a
    restart. A *major* patch event includes multiple fixes and often a kernel update.
    If you are inside your maintenance window and have updated several services, the
    kernel, or other critical system software, I suggest you reboot the system.
  prefs: []
  type: TYPE_NORMAL
- en: Some system administrators automate their patching by setting up a `cron` job
    to periodically check for and install patches. That scenario works, but you should
    have a test system or two that you manually update to see what’s to be updated,
    how the system reacts to those updates, and how the system responds after a reboot.
    You don’t want or need any surprises from a bad patch session.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how to patch two types of Linux systems—a Red Hat–based system
    and a Debian-based system.
  prefs: []
  type: TYPE_NORMAL
- en: Patching a Red Hat Enterprise Linux–Based System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To initiate patches on a Red Hat Enterprise Linux–based system, use `yum` or
    `dnf`. For this demonstration, I use `yum`, but `dnf` is the preferred command
    for versions 8 and above of Red Hat Enterprise Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the truncated listing above, it’s been a while since I last
    updated this system (287 packages require upgrading). I included the parts I want
    you to see, such as a new kernel update and the new OpenSSH server (SSHD), to
    demonstrate that I will reboot this system after the updates. I prefer to install
    manually by not providing the `-y` option so that I can view everything that needs
    an upgrade before I proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The default behavior for YUM/DNF updates is not installing them. You receive
    the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The updates will not install if you press the Enter key because the `N` is the
    default response. You must explicitly approve the installation by answering with
    a `y` here.
  prefs: []
  type: TYPE_NORMAL
- en: It’s generally OK to proceed with updates on production systems if you’ve installed
    and verified them on test systems first. Installing patches not verified on test
    systems might cause stability problems or application/library conflicts, especially
    if you run older versions of some programs.
  prefs: []
  type: TYPE_NORMAL
- en: Patching a Debian-Based Linux System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Patching a Debian-based system is similar to patching a Red Hat Enterprise
    Linux–based system with a couple of subtle differences. The first difference is
    that you use the `apt` command to install updates to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The other difference is in the approval procedure. Notice the `Do you want to
    continue? [Y/n]` prompt. The `Y` is capitalized, which means that if you press
    the Enter key, the updates will install in your system. Remember that when updating
    a Red Hat Enterprise Linux–based system, if you press the Enter key, the updates
    don’t install. But also note that `apt` doesn’t have an automatic approval option
    (`-y`) like `yum` or `dnf`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`unattended-upgrades` is a package you can install that will allow you to update
    your Debian-based system automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, you should always install updates and upgrades on test systems
    first. If you set up automated updates, this is more difficult to do unless you
    create a clever schedule for updating your systems similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Test systems
  prefs: []
  type: TYPE_NORMAL
- en: Manual updates every Tuesday
  prefs: []
  type: TYPE_NORMAL
- en: Development systems
  prefs: []
  type: TYPE_NORMAL
- en: Manual updates every other Thursday
  prefs: []
  type: TYPE_NORMAL
- en: Production systems
  prefs: []
  type: TYPE_NORMAL
- en: Monthly updates last Sunday of the month
  prefs: []
  type: TYPE_NORMAL
- en: This schedule, or similar, allows you to check automated updates before installing
    them to your production systems. If you have an automation or enterprise management
    tool that allows you to suspend `cron` jobs in case of a problem, you can better
    control your automated patching. If you don’t have such a tool and have more than
    a handful of systems to manage, I suggest you explore an automation tool such
    as Ansible to deliver new configuration files, scripts, and so on to your systems.
  prefs: []
  type: TYPE_NORMAL
- en: An automation system also helps when applying zero-day or other emergency patches
    to your systems. Patching, like backups, needs your close attention. Keeping your
    systems running smoothly and securely by regularly applying the latest patches
    is vital to your system administrator duties.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Your Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While regular patching should be part of an overall security plan, there are
    some basic security settings unrelated to the topic of patching that I will cover
    in this section. Again, an automated system such as Ansible can help greatly in
    saving time and effort in maintaining the security of dozens, hundreds, or thousands
    of systems.
  prefs: []
  type: TYPE_NORMAL
- en: Not all systems can be treated equally when applying security measures. For
    example, your DMZ (internet-facing) systems, database systems, web servers, application
    servers, and file storage systems each (as a group) need different security settings.
    You can rarely apply a single security policy covering every type of system. A
    few general security measures apply to every system regardless of function, but
    to state that you’re going to set up a single, generic security plan is unrealistic.
    You must apply security configurations to each system type to focus on specific
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: For example, can you think of particular security settings that apply to web
    servers but not file servers? In the case of a web server, you’ll need to implement
    certificates to secure your web communications. You should concentrate on securing
    shared directories and user accounts on a file server. Are you going to allow
    Samba shares on your file servers? Are you going to allow uploads onto your web
    servers? How you and your users interact with a system dictates its security concerns,
    not the fact that it’s a generic Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#linux_service_security_guidelines) shows some example security
    guidelines for your Linux systems with specific purposes and workloads.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Linux service security guidelines
  prefs: []
  type: TYPE_NORMAL
- en: '| Purpose/workload | Examples | Security measure |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| All servers | Miscellaneous services | SSH, */etc/hosts.allow* and */etc/hosts.deny*
    restrictions, firewall, SELinux |'
  prefs: []
  type: TYPE_TB
- en: '| Web server | Apache, NGINX, IHS, others | TLS, certificates, HTTPS |'
  prefs: []
  type: TYPE_TB
- en: '| Database server | MySQL, PostgreSQL, others | Tunnel over SSH, restrict connections
    to localhost |'
  prefs: []
  type: TYPE_TB
- en: '| File server | Samba shares, NFS shares, SSH | Active Directory integration
    for Samba, two-factor authentication |'
  prefs: []
  type: TYPE_TB
- en: '| Application server | Tomcat, WebSphere, others | HTTPS, TLS, certificates
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mail server | SMTP, IMAP, POP-3 protocols | Use secured protocols and mail
    services |'
  prefs: []
  type: TYPE_TB
- en: As you can see in [Table 8-1](#linux_service_security_guidelines), there are
    certain security features that you should implement on every system regardless
    of purpose unless there’s some vendor-related reason that you shouldn’t. You should
    lock down every system and be as restrictive as possible while maintaining functionality
    and accessibility for your users.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining User and Group Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'User account maintenance goes beyond adding and removing accounts. It also
    includes developing an account naming convention, creating policies that set standards
    for how long to disable accounts before they’re removed, how long to retain a
    user’s home directory after they’ve left the group or the company, retiring of
    group accounts, and the retiring or reusing of user and group IDs. All of these
    activities prevent user account sprawl. Here are some examples of account sprawl:'
  prefs: []
  type: TYPE_NORMAL
- en: Disabled accounts left on systems past policy limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home directories left on systems past policy limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active, terminated user accounts left on systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group accounts with no members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabled or removed accounts that remain in */etc/sudoers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active temporary accounts left on systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active service accounts with shells or passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Up a Naming Convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the easiest methods of circumventing account sprawl is to create a user
    account naming convention. A naming convention prevents sprawl by setting a standard
    by which you and your team create user accounts. For example, you now have a working
    system if you set your naming convention as the first initial and the first seven
    characters of the last name. The exception is when two or more people have the
    same first and last names. In these cases, you’d opt for using the first initial
    of the first name, a middle initial, and the first six characters of the last
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-2](#standard_account_naming_convention) shows examples of the standard
    naming convention.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Standard account naming convention
  prefs: []
  type: TYPE_NORMAL
- en: '| First name | Last name | Username |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| José | Alvarez | `jalvarez` |'
  prefs: []
  type: TYPE_TB
- en: '| Paula | Anderson | `panderso` |'
  prefs: []
  type: TYPE_TB
- en: '| Vivek | Kundra | `vkundra` |'
  prefs: []
  type: TYPE_TB
- en: '| Sylvia | Goldstein | `sgoldste` |'
  prefs: []
  type: TYPE_TB
- en: '[Table 8-3](#repeated_name_exceptions) shows examples of repeated name exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. Repeated name exceptions
  prefs: []
  type: TYPE_NORMAL
- en: '| First name | Last name | Username |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| José | Alvarez | `jalvarez` |'
  prefs: []
  type: TYPE_TB
- en: '| José | Alvarez | `jqalvare` |'
  prefs: []
  type: TYPE_TB
- en: '| Paula | Anderson | `panderso` |'
  prefs: []
  type: TYPE_TB
- en: '| Paula | Anderson | `pmanders` |'
  prefs: []
  type: TYPE_TB
- en: If your users have no middle names, then you can work backward from the end
    of the alphabet, as shown in [Table 8-4](#account_name_workarounds_for_users_with).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-4\. Account name workarounds for users without middle names
  prefs: []
  type: TYPE_NORMAL
- en: '| First name | Last name | Username |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Paula | Anderson | `panderso` |'
  prefs: []
  type: TYPE_TB
- en: '| Paula | Anderson | `pzanders` |'
  prefs: []
  type: TYPE_TB
- en: '| Paula | Anderson | `pyanders` |'
  prefs: []
  type: TYPE_TB
- en: '| Paula | Anderson | `pxanders` |'
  prefs: []
  type: TYPE_TB
- en: You can certainly develop your own naming convention, but I’ve seen this one
    work at other enterprises, so it’s worth a mention here. I’ve also seen other
    companies use a number system to avoid duplicate usernames. For example, if you
    have two users named Vivek Kundra, the first one created on a system is created
    as `vkundra` and the second Vivek Kundra is `vkundra2`.
  prefs: []
  type: TYPE_NORMAL
- en: The whole point of a naming convention is to develop a system and then stick
    to it. Having a naming convention prevents administrators from creating random
    user accounts that could duplicate other accounts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you create a user account for Sylvia Goldstein as `sgoldste`
    and another system administrator creates an account as `sylviag`. You now have
    a security problem because you have a single user with two accounts on the same
    system, plus the problem of user account sprawl.
  prefs: []
  type: TYPE_NORMAL
- en: User account sprawl is not a minor issue. Suppose Sylvia logs in and uses both
    accounts to create files, install software, and possibly create dependencies for
    groups she’s a member of. Now the problem is far more complex than simply moving
    files from one account to another, changing user and group ownership, and removing
    the lesser-used account from the system.
  prefs: []
  type: TYPE_NORMAL
- en: If the system administrators had a naming convention, the second administrator
    might not have created the second account. Next, I discuss creating an account
    retention policy, another method to prevent account sprawl.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Account Retention Policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An account retention policy is a good security practice and housekeeping practice.
    Nothing flags security scans like active accounts that no one has accessed in
    more than 90 days. Some highly secure environments will force a password change
    every 45 days, disable accounts after 90 days of inactivity, and remove accounts
    that remain inactive for six months. This type of aggressive account retention
    policy won’t fit every environment, but it certainly protects and challenges users
    of sensitive systems to maintain their accounts or let them go.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not suggesting that you adopt a policy as strict as this one. Still, you
    should have some type of retention policy in place that you provide to your users
    as part of an overall security and employment education program.
  prefs: []
  type: TYPE_NORMAL
- en: Your account retention policy should be a written policy as well as a system-level
    policy. A system-level policy means that you must configure system-wide settings
    for inactive account lockout and removal.
  prefs: []
  type: TYPE_NORMAL
- en: Changing inactive account status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To work toward a system solution, audit the default value for the number of
    days after a password expires that the system disables the account, also known
    as the `INACTIVE` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `-1` means there’s no default inactive value set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the inactive value according to your company’s security policy. If you
    have no security policy addressing this value, set it to `15` days. Some sysadmins
    set this value to `30`. The purpose of this setting is to disable inactive accounts
    and protect system security:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the system-wide default inactive value to `15` days. If users receive
    the message that they need to update their password, they have 15 days before
    the system disables the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user attempts to log into a system and fails, you can check their account
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This user is in good standing. Perhaps they attempted to log into a host other
    than the one they intended or typed in an incorrect password. However, another
    user, `asmith`, contacted you complaining that they couldn’t log into the same
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'User `asmith` is locked out of the system. You will have to unlock their account
    before they can log in again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The user may log in again. Next, I will demonstrate how to take account protection
    further with the `chage` command.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting user accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `chage` command has several options for further protecting your user accounts
    by forcing regular password changes, setting a minimum password change duration,
    and so on. This section shows how to alter those settings to protect your users
    and systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three parameters that I change for all users on the systems that
    I manage: `Inactive days`, `Minimum number of days between password changes`,
    and `Maximum number of days between password changes`. I change them according
    to company policy, if one exists. Otherwise, I change them to my “defaults”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This sets the user’s password to expire every 90 days. If they don’t change
    it, their account will be disabled 15 days after the change password date. If
    they change their password when prompted, they won’t be able to change it again
    until one day later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can only change one user at a time using the `chage` command. This can
    become cumbersome if you have more than a few users on a few servers. A scripted
    version that covers all users is far more efficient. I’ve provided my script as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Retiring Group Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Group accounts that remain on the system once they’re empty and inactive are
    a common source of account sprawl but easily remedied. The `groupmems` command
    can save you a lot of time and frustration by answering who, if anyone, is a member
    of a specific group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `groupmems` command options used in the example are `-g` for the group name
    and `-l` for list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are no group members, the command displays no output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'On this system, the engineering group should be retired (removed from the system
    because it’s empty). But before removing the group, you must find out if the engineering
    group left any files they own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should transfer the files to another user or change ownership to root to
    secure them and then remove the empty group account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You have successfully removed the engineering account. You can re-create it
    in the future if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Now that I’ve covered sprawl, I will discuss monitoring your system’s health.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring System Health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System monitoring doesn’t explicitly fall under the sprawl umbrella but is part
    of maintaining system health. There are dozens of commercial monitoring tools
    that you can purchase, but `sysstat` is a free one native to Linux. It’s easy
    to install, and on Red Hat–based systems, it self-configures and begins collecting
    data immediately. On Debian-based systems, you must enable `sysstat` to collect
    data manually.
  prefs: []
  type: TYPE_NORMAL
- en: To enable `sysstat`’s System Activity Report (`sar`) utility to begin collecting
    data, edit the */etc/default/sysstat* file and change the line that reads `ENABLED="false"`
    to `ENABLED="true"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then restart the `sysstat` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Give the system some time to begin generating activity reports. You’ll learn
    how to generate activity reports later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `sysstat` package contains new binaries for checking performance and formatting
    system statistics information. [Table 8-5](#binaries_in_the_sysstat_package) lists
    the binaries and their functions. I copied the descriptions of each binary from
    their respective man pages.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-5\. Binaries in the `sysstat` package
  prefs: []
  type: TYPE_NORMAL
- en: '| Binary | Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cifsiostat` | CIFS statistics | The `cifsiostat` command displays statistics
    about read and write operations on CIFS filesystems. |'
  prefs: []
  type: TYPE_TB
- en: '| `iostat` | CPU and device I/O statistics | The `iostat` command is used for
    monitoring system input/output device loading by observing the time the devices
    are active in relation to their average transfer rates. |'
  prefs: []
  type: TYPE_TB
- en: '| `mpstat` | Processor-related statistics | The `mpstat` command writes to
    standard output activities for each available processor, processor 0 being the
    first one. |'
  prefs: []
  type: TYPE_TB
- en: '| `pidstat` | Task statistics | The `pidstat` command monitors individual tasks
    currently managed by the Linux kernel. |'
  prefs: []
  type: TYPE_TB
- en: '| `sadf` | `sar` data formatting | The `sadf` command is used for displaying
    the contents of data files created by the `sar` command. But unlike `sar`, `sadf`
    can write its data in many different formats (CSV, XML, etc.). |'
  prefs: []
  type: TYPE_TB
- en: '| `sar` | System activity reporter | The `sar` command writes to standard output
    the contents of selected cumulative activity counters in the operating system.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tapestat` | Tape statistics | The `tapestat` command is used for monitoring
    the activity of tape drives connected to a system. |'
  prefs: []
  type: TYPE_TB
- en: 'If you’re familiar with the `vmstat` command, which isn’t part of `sysstat`,
    you know how the other “stat” commands work. For example, `vmstat`, on every Linux
    system, requires that you provide a time delay interval between snapshots in seconds
    and a specific number (count) of snapshots, with `5` being the typical value used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The first run of the `vmstat` command gives averages since the last reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This `vmstat` command ran every five seconds with five snapshots. The other
    “stat” commands work the same way. You provide a delay and a count. The following
    is an `iostat` command example with two snapshots and a five-second delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Gathering System Activity Reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sar` command is comprehensive and versatile in its collection, reporting,
    and saving of system activity information. You can use it like the “stat” commands
    by supplying an interval and a count, issuing an option such as `-b` to display
    I/O statistics, or combining the two to display your selected performance counter
    at a specific interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll begin with an example of using `sar` with a switch. Staying with the `-b`
    example, here is a partial report of I/O statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the report, data display begins at midnight, which is why
    I had to truncate it. The following is an example of I/O statistical data using
    `-b` with a count of five and a time delay of five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can issue `sar` with a count and an interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default output from the `sar` command is CPU statistics. To display other
    statistics, you must use a switch, such as `-b` for I/O data.
  prefs: []
  type: TYPE_NORMAL
- en: The next section demonstrates how to run system activity reports and save `sar`
    data into files.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting System Activity Reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Displaying `sar` data enables you to see snapshots and performance from the
    last 24 hours, but what if you want to capture that data to a file (the system
    activity report) in a specific format such as CSV or XML? The `sadf` command is
    available to you for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: To help distinguish between the `sadf` and `sar` options, remember that `sadf`
    options are first in the command, and then `sar` options follow the double hyphen.
    Refer to the man pages for all available options for both commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'My favorite `sadf` command uses the `-d` switch to create a comma-separated
    file that’s perfect for ingesting into a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The system activity logs reside in */var/log/sa* and have filenames of “sa”
    immediately followed by a number representing the day of the month. For a system
    activity log for the tenth of the month, the datafile is *sa10*. You can specify
    an activity log datafile from another date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`sysstat` logs reside in */var/log/sa* on some Linux distributions, but on
    others those logs reside in */var/log/sysstat*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--` option tells the `sadf` command that the options that follow it are
    `sar` command options and not `sadf` options. In the command `sadf -d /var/log/sa/sa10
    -- -d`, the `-d` option following the `--` will display `sar` device information.
    Perhaps a less confusing example is to display network information from the `sar`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `-n` is the `sar` option for network activity. `DEV` means the network device,
    such as `lo` (loopback), `eth0`, `enp0s3`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve only scratched the surface of system health, and this chapter could be
    an entire book. Health monitoring is extremely vital in maintaining SLAs for your
    customers. Keeping track of system health is an essential system administrator
    task that affects capacity and performance, security, and standard system housekeeping.
    It’s so important that some large enterprises dedicate entire teams to it.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.xhtml#monitoring_your_system), I cover nonhealth system
    monitoring and network inventory systems.
  prefs: []
  type: TYPE_NORMAL
