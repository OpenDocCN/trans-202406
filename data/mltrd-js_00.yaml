- en: Foreword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The book you’re holding now is a fun one. It’s a JavaScript book that opens
    with examples written in C, talks about multithreading with an explicitly single-threaded
    programming language, provides great examples of how and when to intentionally
    block the event loop after experts have been telling you for years to never do
    so, and closes with an excellent list of reasons and caveats about why you might
    not actually want to use the mechanisms the book describes. More importantly,
    it’s a book that I would consider essential reading for any JavaScript developer
    no matter where your code is expected to be deployed and run.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I’ve worked with companies to help them build more efficient and more
    performant Node.js and JavaScript applications, I’ve often had to step back and
    take the time first to discuss many of the common misconceptions developers have
    about the programming language. For instance, I once had an engineer with a long
    history in Java and .NET development argue that creating a new promise in JavaScript
    was a lot like creating a new thread in Java (it’s not), and that promises allow
    JavaScript to run in parallel (they don’t). In a separate conversation someone
    had created a Node.js application that was spawning over a thousand simultaneous
    worker threads and wasn’t sure why they weren’t seeing an expected improvement
    in performance while testing on a machine that had only eight logical CPU cores.
    The lesson from these conversations is clear: multithreading, concurrency, and
    parallelism are still very unfamiliar and difficult topics for a very large percentage
    of JavaScript developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with these misconceptions is what led directly to me (working with my
    colleague and fellow Node.js Technical Steering Committee member, Matteo Collina)
    developing the Broken Promises workshop in which we would lay out the foundations
    of asynchronous programming in JavaScript—teaching engineering teams how to reason
    more effectively about the order in which their code would execute and the timing
    of various events. It also led directly to the development of the Piscina open
    source project (with fellow Node.js core contributor Anna Henningsen), which provides
    a best-practice implementation of a worker pool model on top of Node.js worker
    threads. But those only help with part of the challenge.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, Bryan and Thomas expertly lay out the foundations of multithreaded
    development in general, and deftly illustrate how the various JavaScript runtimes
    like web browsers and Node.js enable parallel computing with a programming language
    that includes no built-in mechanisms to enable it. Because the responsibility
    for providing multithreading support has fallen on the runtimes, and because there
    are so many differences between those runtimes, browsers and platforms like Node.js
    implement multithreading in different ways. Although they share similar APIs,
    a worker thread in Node.js is really not the same thing as a web worker in a web
    browser. Support for shared workers, web workers, and service workers is nearly
    universal across browsers, and worker threads have been in Node.js for several
    years now, but they are all still a relatively new concept for JavaScript developers.
    No matter where your JavaScript runs, this book will provide important insight
    and information. Most importantly, however, the authors take the time to explain
    exactly why you should care at all about multithreading in your JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: James Snell,
  prefs: []
  type: TYPE_NORMAL
- en: Node.js Technical Steering Committee Member
  prefs: []
  type: TYPE_NORMAL
