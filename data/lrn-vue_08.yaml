- en: Chapter 8\. Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have learned the fundamentals of Vue components and
    different approaches to composing a Vue component. We proceeded to create reusable
    component logic as standalone composable using Composition API. We also learned
    about more advanced concepts of rendering and custom plugin creation.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore a different aspect of building a Vue application,
    routing, by introducing you to the concept of a routing system with Vue Router,
    the official routing management library for the Vue application, and its core
    API. We then learn how to configure the app’s routes, pass and handle data between
    the application’s paths using router guards, and build dynamic and nested routes
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: What is Routing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When users navigate around the web, they enter a Uniform Resource Locator (URL)
    in the browser’s address bar. A URL is the address of a resource within the web.
    It contains many parts, which we can divide into the following significant sections
    ([Figure 8-1](#figure_c07_01_url)):'
  prefs: []
  type: TYPE_NORMAL
- en: Location
  prefs: []
  type: TYPE_NORMAL
- en: Includes the protocol, the application’s domain name (or IP address of the web
    server), and the port used to access the requested resource.
  prefs: []
  type: TYPE_NORMAL
- en: Path
  prefs: []
  type: TYPE_NORMAL
- en: The path to the requested resource. In web development, we use it to determine
    the page component to render on the browser side based on a predefined path pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  prefs: []
  type: TYPE_NORMAL
- en: A set of key-value pairs for passing additional information to the server, separated
    by an `&` symbol. We mainly use query parameters to pass data between pages.
  prefs: []
  type: TYPE_NORMAL
- en: Anchor
  prefs: []
  type: TYPE_NORMAL
- en: Any text after the `#` symbol. We use anchors to navigate to a specific element
    on the same page, often with matched `id` value with the matched id or a time-lapse
    for a media element.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram shows the one-way data flow between components](assets/lvue_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. URL structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Upon receiving the URL from the user, the browser then communicates with the
    server based on the received URL, which returns the requested resource, if any.
    The resource can be a static file, such as an image or a video, or a dynamic page,
    such as a web page or a web application.
  prefs: []
  type: TYPE_NORMAL
- en: With single-page applications (SPAs), we perform the routing mechanism on the
    browser side instead, thus allowing smooth page navigation without refreshing
    the browser. As a URL is a page’s address, we use a routing system to connect
    its path pattern to a specific component representing it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend frameworks like Vue provide the layout for building components for
    an SPA but not the routing services. To create a complete user navigation experience,
    we must design and develop the application’s routing ourselves, including solving
    the SPA’s issues such as history keeping and bookmarking.
  prefs: []
  type: TYPE_NORMAL
- en: Or we can use Vue Router as our primary engine for routing.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the official routing service for Vue applications, Vue Router offers a control
    mechanism for handling page navigation in a Vue application. We use Vue Router
    to set up our application’s routing systems, including configuring the mapping
    between components and pages, delivering a good user experience on the client
    side for the SPA’s flow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The official Vue Router documentation is available at the [Vue Router website](https://oreil.ly/AwUZo),
    containing information on installation, APIs, and primary use cases for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Since Vue Router is a standalone package from the Vue framework, we need to
    perform additional steps to have it installed and ready to use in our application,
    which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most straightforward way to install Vue Router for a new Vue project using
    Vite is to choose `Yes` when being asked to install Vue Router during the setup
    (see [“Create a New Vue Application”](ch01.html#chapter_01_newVueApp)). Vite then
    will take care of installing the Vue Router package and scaffold your project
    with related files and folders ([Figure 8-2](#figure_c07_01)), as in the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `router` folder with one file, `index.ts`, containing the routes configurations
    for the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `views` folder has two sample Vue components, `AboutView` and `HomeView`.
    Each component is the view for the related URL paths, which we will discuss shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A diagram shows the one-way data flow between components](assets/lvue_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Project structure after scaffolding with Vite with Vue Router enabled
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vite will also inject some code into the `main.ts` file to initialize Vue Router.
    Hence, the created app will enable the primary router enabled and make it ready
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to fully understand how Vue Router works, we will skip the scaffolding
    option and add Vue Router to our existing project manually by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this book, we use Vue Router 4.1.6, the latest version at the time of writing.
    You can replace the version number after `@` with the latest version from the
    [Vue Router NPM page](https://oreil.ly/h6Q0V).
  prefs: []
  type: TYPE_NORMAL
- en: For Vue 3 projects, you should use version 4 and above.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the Vue Router’s capabilities, we will build an SPA representing
    a pizza ordering system. The application header will have the following page links:
    Home, About, Pizzas, Contact, and Login (see [Figure 8-3](#figure_c07_02)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the layout of the Pizza House application''s header](assets/lvue_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Pizza House application with navigation header
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Each application link leads to a page represented by a Vue component. For each
    application page, we create a placeholder component and keep it under the `views`
    folder. Our Pizza House codebase now contains the following view components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HomeView`'
  prefs: []
  type: TYPE_NORMAL
- en: Our application’s home page contains a welcome message and a list of pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: '`AboutView`'
  prefs: []
  type: TYPE_NORMAL
- en: The about page, which will contain a short description of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`PizzasView`'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a list of pizzas for ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '`ContactView`'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a contact form.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginView`'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the login form for the user.
  prefs: []
  type: TYPE_NORMAL
- en: We need to map these components to the appropriate page links, demonstrated
    in [Table 8-1](#table_chap07_01).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Table of the available routes with their corresponding components
    and page URLs in Pizza House
  prefs: []
  type: TYPE_NORMAL
- en: '| Page link | Component | Route path pattern |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000* | HomeView | `/` |'
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/about* | AboutView | `/about` |'
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/pizzas* | PizzasView | `/pizzas` |'
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/contact* | Contact | `/contact` |'
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/login* | LoginView | `/login` |'
  prefs: []
  type: TYPE_TB
- en: '[Table 8-1](#table_chap07_01) also shows the corresponding route patterns for
    each page link. We will use these patterns to define the routes in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The port `4000` for `localhost` is the local port number for the development
    server by Vite. It can change depending on your Vite configuration and the available
    ports when you run your project locally.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A route is a path pattern in response to a page URL. We define a route in Vue
    Router based on a configuration object using the interface `RouteRecordRaw`. This
    configuration object contains the following properties described in [Table 8-2](#table_chap07_02).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Properties for a route configuration object
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Type | Description | Required? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | `string` | The pattern to check against the browser’s location (browser
    URL) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `component` | `Component` | The component to render when the browser’s location
    matches the route’s path pattern | No |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | `string` | The name of the route. We can use it to avoid hard-coded
    URLs in the code. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `components` | `{ [name: string]: Component }` | A collection of components
    to render based on the matched route’s name | No |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect` | `string` or `Location` or `Function` | The redirect path | No
    |'
  prefs: []
  type: TYPE_TB
- en: '| `props` | `boolean` or `Object` or `Function` | The props to pass to the
    component | No |'
  prefs: []
  type: TYPE_TB
- en: '| `alias` | `string` or `Array<string>` | The alias path | No |'
  prefs: []
  type: TYPE_TB
- en: '| `children` | `Array<RouteConfig>` | The child routes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `before``Enter` | `Function` | The navigation guard callback | No |'
  prefs: []
  type: TYPE_TB
- en: '| `meta` | `any` | The route’s metadata. We can use this for passing additional
    information not visible on the URL. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `sensitive` | `Boolean` | Whether the route should be case sensitive. By
    default, all routes are case insensitive; for example, `/pizzas` and `/Pizzas`
    are the same route. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `strict` | `Boolean` | Whether we should allow trailing slash (like `/about/`
    or `/about`) | No |'
  prefs: []
  type: TYPE_TB
- en: 'We often don’t use all the available fields to define a route. For instance,
    take the default application path (`/`). It’s sufficient to define the following
    `home` route object with the `path` property set to `/` and the `component` property
    set to `HomeView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Vue Router in the previous code maps the default entry URL (such as *https://localhost:4000*)
    to the `/` case unless `strict` mode is enabled. If there is no indicator after
    the slash `/`, Vue Router will render the `HomeView` component as the default
    view. This behavior applies in both cases: when a user visits *https://localhost:4000*,
    or *https://localhost:4000/*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can proceed to configure our app’s `routes` as an array of `RouteRecordRaw`
    configuration objects in the `index.ts` file under the `router` folder, as in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using Named Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the named route with the `name` property. I recommend using
    this approach in your application, making the code more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: That’s straightforward enough. We have defined the necessary routes for our
    Pizza House. But we need more than this for our route system to work. We must
    create a router instance from the given routes and plug it into our Vue application
    on initialization. We will do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Router Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create the router instance using the `createRouter` method from the
    `vue-router` package. This method takes a configuration object of type `RouterOptions`
    as an argument, with the following main properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`history`'
  prefs: []
  type: TYPE_NORMAL
- en: The history mode object can be hash-based or web-based (HTML history mode).
    The web-based method utilizes the HTML5 history API to make the URL readable,
    allowing us to navigate without reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes`'
  prefs: []
  type: TYPE_NORMAL
- en: The array of routes to use in the router instance.
  prefs: []
  type: TYPE_NORMAL
- en: '`linkActiveClass`'
  prefs: []
  type: TYPE_NORMAL
- en: The class name for the active link. By default, it is `router-link-active`.
  prefs: []
  type: TYPE_NORMAL
- en: '`linkExactActiveClass`'
  prefs: []
  type: TYPE_NORMAL
- en: The class name for the active link. By default, it is `router-link-exact-active`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other less common properties for the `RouterOptions` interface are available
    at the [RouterOptions documentation](https://oreil.ly/pcSqw).
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `createWebHistory` method from the `vue-route` package to create
    a web-based `history` object. This method takes a string that represents the base
    URL as its optional argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, passing the base URL as a static string is not a good practice. We
    want to keep the base URL configurable and isolated for different environments
    like development and production. For this purpose, Vite exposes the environment
    object `import.meta.env`, which contains a `BASE_URL` property. You can set the
    value for `BASE_URL` in a dedicated environment file, often denoted by the `.env`
    prefix, or through the command line when running the Vite server. Vite then extracts
    the relevant value for `BASE_URL` and injects it into the `import.meta.env` object,
    and we can use it in our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using BASE_URL from the Environment File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don’t have to set the `BASE_URL` value in the `.env` file for development.
    Vite will map it to the local server URL automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern hosting platforms, such as Netlify, will set the `BASE_URL` value
    for you during deployment, often to your application’s domain name.
  prefs: []
  type: TYPE_NORMAL
- en: We have created the router instance from the given `routes` and the desired
    `history` mode. Our next step is to plug this instance into our Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging the Router Instance Into the Vue Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `main.ts` file where we initialize the application instance `app`, we
    will import the created `router` instance and pass it as the argument to the `app.use()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our application now has a routing system for the navigation between pages. However,
    if you run the application now, you will see that the `AboutView` component is
    still not rendered when navigating to the `/about` path. We must modify our `App.vue`
    component to display the suitable component that binds to the route’s path in
    its configurations. Let’s do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Current Page with the RouterView Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To dynamically generate the desired view for a particular URL path, Vue Router
    provides `RouterView` (or `router-view`) as the placeholder component. During
    running, Vue Router will replace it with the element that matches the current
    URL pattern based on the configuration provided. We can use this component in
    our `App.vue` component to render the current page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When running the application, the default home page is now the `HomeView` ([Figure 8-4](#home-view)).
    When navigating to `/about` using the browser’s location bar, you will see that
    the `AboutView` component is rendered ([Figure 8-5](#about-view)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Home View](assets/lvue_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. Application displays the HomeView component for the `"/"` path
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![About View](assets/lvue_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. Application displays the AboutView component for the `"/about"`
    path
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since `RouterView` is a Vue component, we can pass props, attributes, and event
    listeners to it. `RouterView` will then pass them to the rendered view to handle.
    For instance, we can add a class using the `RouterView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The rendered component—`AboutView`, for example—will then receive the `class`
    as the primary container element (see [Figure 8-6](#figure_ch7_03)), and we can
    use it for CSS styling accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![RouterView class](assets/lvue_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. `AboutView` receives the `class` attribute from the `RouterView`
    component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At this point, we have seen how to set up the routes for our application and
    render the current page using the `RouterView` component. However, navigating
    by manually setting the URL path on the browser’s address bar does not seem to
    be very convenient for users. To enhance the user experience for our app, we can
    compose a header with navigation links using the `a` element and the full path.
    Or we can use the built-in `RouterLink` component to build the links to our routes,
    which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Build a Navigation Bar with the RouterLink Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vue Router provides the `RouterLink` (or `router-link`) component to generate
    an interactive and navigable element from a set of given props, such as `to`,
    for a specific route’s path. The route path can be a string that has the same
    value as `path` in the route configuration, as in the following example for the
    link to navigate to the about page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can pass an object representing the route’s location object,
    including the `name` and the `params` for the route parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this component renders an anchor element (`a`) with an `href` and
    classes for the active link, such as `router-link-active` and `router-link-exact-active`.
    We can change the default element to any other element using the Boolean `custom`
    prop and `v-slot`, usually another interactive element such as `button`, as in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code will render a `button` element instead of the default `a` element,
    binding with the `navigate` function to navigate the given route when clicking.
  prefs: []
  type: TYPE_NORMAL
- en: Using `custom` Prop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use the `custom` prop, you must bind the `navigate` function as a click
    handler or the `href` link to the custom element. Otherwise, the navigation will
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: Also, no class names such as `router-link-active` or `router-link-exact-active`
    will be added to the custom element when in action.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build our navigation bar, `NavBar`, using `RouterLink` as shown in [Example 8-1](#NavBar_component).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. `NavBar` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add some CSS styles to the navigation bar and the active link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using activeClass and exactActiveClass Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the `activeClass` and `exactActiveClass` props of `RouterLink` to
    customize the class names for the active link instead of using the default ones.
  prefs: []
  type: TYPE_NORMAL
- en: Once we add `NavBar` to the `App` component, we will see the navigation bar
    at the top of the page ([Figure 8-7](#figure_ch7_04)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the navigation bar with Home link active and underlined](assets/lvue_0807.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7\. Navigation bar of the application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now our users can navigate between pages using the navigation bar. However,
    we still need to handle the data flow between the pages. In the upcoming sections,
    we will see how to pass data between routes with route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Data Between Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To pass data between routes, we can use the `query` field in the router object
    passed to `to`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `query` field is an object that contains the query parameters we want to
    pass to the route. Vue Router will translate it into a complete `href` path with
    query parameters, starting with `?` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access the query parameters in the route component, `PizzasView`,
    using the `useRoute()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code will render the following page, where the browser’s URL is *http://localhost:4000/pizzas?id=1*
    ([Figure 8-8](#figure_ch7_05)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Pizzas page with the query parameter](assets/lvue_0808.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8\. Pizzas page with the query parameter
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also pass the query parameters in the browser’s address bar, and the
    router instance will decouple it from the `route.query` object accordingly. This
    mechanism is handy in many scenarios. Take our `PizzasView` page, for instance.
    This page displays a list of pizzas taken from a `usePizzas` hook, using the `PizzaCard`
    component as shown in [Example 8-2](#pizza_view_component).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. `PizzasView` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now we want to add a search feature, where the user can search for a pizza by
    its title using a query params `search` and get the filtered list of pizzas. We
    can add a `useSearch` hook, which receives the value of `route.query.search` as
    its initial value and returns the filtered list of pizzas as well as the reactive
    `search` value, as shown in [Example 8-3](#useSearch_hook).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. Implementing `useSearch` hook
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use the `useSearch` hook in the `PizzasView` component and change the
    iteration to be over `searchResults` instead of `pizzas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now when you go to `/pizzas?search=hawaii`, the list will show only the pizza
    with the title `Hawaii` ([Figure 8-9](#figure_ch7_06)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Pizzas page with the search query parameter](assets/lvue_0809.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9\. Pizzas page with the search term from query parameter
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'How about allowing the user to search while on the page and then syncing the
    updated search term with the query parameter? For that, we need to perform the
    following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an input field to the `template` and bind it to the `search` variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the `router` instance using the `useRouter()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `watch` function to watch for changes in the `search` value and update
    the query parameter using `router.replace`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When you type in the search field, the router instance will update the URL with
    the new query value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use Vue 2.x and below or Options API (without `setup()`), you can access
    the `router` and `route` instances using `this.$router` and `this.$route`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have learned how to retrieve the query params with the `route`
    instance. Using the `route` instance in every component that needs to access the
    query params can be tedious. Instead, we can decouple the query params using props,
    which we will learn next.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling Route Parameters Using Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the route configuration object, we can define the static props to pass to
    the view component as an object with static values or a function that returns
    the props. For example, in the following code, we change our `pizzas` route configuration
    to pass the `searchTerm` prop, whose value is from `route.query.search`, to the
    `PizzaView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `PizzasView` component, we can remove the use of `useRoute` and access
    the `searchTerm` prop using the `props` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of the application stays the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `props: true` to pass the `route.params` object to the view
    component as props, without caring about any specific props. When the route changes,
    we can combine this approach with navigation guards to perform side effects for
    the route’s parameters. More about navigation guards in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Navigation Guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigation guards are functions to help us control the navigation flow better.
    We can also use them to perform side effects when the route changes or before
    the navigation happens. There are three types of navigation guards and hooks:
    global, component-level, and route-level.'
  prefs: []
  type: TYPE_NORMAL
- en: Global Navigation Guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For every router instance, Vue Router exposes a set of global-level navigation
    guards, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`router.beforeEach`'
  prefs: []
  type: TYPE_NORMAL
- en: Called *before* every navigation
  prefs: []
  type: TYPE_NORMAL
- en: '`router.beforeResolve`'
  prefs: []
  type: TYPE_NORMAL
- en: Called *after* Vue Router has resolved all async components in the route and
    all in-component guards (if any), but *before* confirming the navigation
  prefs: []
  type: TYPE_NORMAL
- en: '`router.afterEach`'
  prefs: []
  type: TYPE_NORMAL
- en: Called *after* confirming the navigation and *before* the next update of the
    DOM and the navigation
  prefs: []
  type: TYPE_NORMAL
- en: 'The global guards help perform validation before navigating to a specific route.
    For example, we can use the `router.beforeEach` to check if the user is authenticated
    before navigating to the `/pizzas` route. If not, we can redirect the user to
    the `/login` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `to` is the destination route object to navigate to, `from` is
    the current route object, and `next` is a function to call to resolve the hook/guard.
    We need to trigger `next()` at the end, either without any argument to continue
    to the original destination or with a new route object as its argument to redirect
    the user to a different route. Otherwise, Vue Router will block the navigation
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alternatively, we can use the `router.beforeResolve` to perform the same validation.
    The critical difference between `router.before``Each` and `router.beforeResolve`
    is that Vue Router triggers the latter after resolving all in-component guards.
    However, invoking the callback after settling everything will be less valuable
    when you want to avoid loading the suitable async component before confirming
    the navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the `router.afterEach`? We can use this hook to perform actions like
    saving some page’s data as cache, tracking page analytics, or authenticating our
    user when navigating away from the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While the global guards help perform side effects and control the redirecting
    of the whole application, in some cases we only want to achieve side effects for
    a specific route. In this case, using route-level guards is a good option.
  prefs: []
  type: TYPE_NORMAL
- en: Route-Level Navigation Guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For every route, we can define a callback for the `beforeEnter` guard, which
    Vue Router triggers when entering a path from a different one. Take our `/pizzas`
    route, for instance. Instead of mapping the `props` field with a function, we
    can achieve mapping the search query as a prop to the view by manually setting
    the `to.params.``searchTerm` field to `to.query.search` before entering the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have set `props: true` in the pizzas route. The UI will still
    display the same list of pizzas as before ([Figure 8-10](#figure_07_pizzaslist)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Pizzas list page.](assets/lvue_0810.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10\. Pizzas list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can manually modify the `to.query.searchTerm` within this guard. However,
    the changes won’t reflect on the URL path in the browser’s address bar. If we
    want to update the URL path, we can use the `next` function to redirect the user
    to a new route object with the desired query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Passing an Array of Callbacks to beforeEnter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`beforeEnter` also accepts an array of callbacks, which Vue Router triggers
    in sequence. Hence we can perform multiple side effects for a specific route before
    entering it.'
  prefs: []
  type: TYPE_NORMAL
- en: Like other global guards, the `beforeEnter` guard is handy when you want to
    perform authentication to specific routes, additional modification to the route
    parameters before passing them to the view component, etc. Next, we will learn
    how to leverage the component-level guards to perform side effects for a specific
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Component-Level Router Guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Vue 3.x on, Vue Router also provides composable guards at the component
    level to help control the flow of route leaving and updating, as `onBeforeRouteLeave`
    and `onBeforeRouteUpdate`. While Vue Router triggers `onBeforeRouteLeave` when
    the user navigates away from the current path view, it invokes `onBeforeRouteUpdate`
    when the user navigates to the same path view but with different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `onBeforeRouteLeave` to display a message to confirm the user’s
    navigation away from the Contact page with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now when you are on the Contact page and try to navigate to another page, you
    will see a confirmation popup asking you to confirm your navigation, as in [Figure 8-11](#figure_07_alert).
    Clicking on the Cancel button will prevent navigation, and clicking the OK button
    will continue the navigation.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the confirmation popup.](assets/lvue_0811.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11\. Confirmation popup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use Options API for your components, `beforeRouteLeave` and `beforeRouteUpdate`
    guards would be available on the options object to achieve the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `beforeRouteEnter` hook, which the router triggers before Vue
    initialize the view component. This guard is similar to the `setup()` hook; hence,
    Vue Router’s API has no equivalent composable.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored the available navigation guards in different levels of a routing
    system and their order of execution, shown in [Figure 8-12](#figure_07_guardflow).
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of the navigation guard flow.](assets/lvue_0812.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12\. Order of triggering navigation guards and their equivalent composable
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding the navigation flow and the order of execution of the guards is
    crucial to building a robust routing system. Next, we will learn how to create
    nested routes for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Nesting Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have built a basic one-level routing system for our application.
    In reality, most routing systems are more complex. Sometimes, we want to create
    subpages for a specific page, such as a Frequently Asked Questions (FAQs) page,
    and a Form page for the Contact page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The default UI for the `/contact` page will be the `ContactView` page, and the
    user can navigate to the Form page by clicking on a link presented on this page.
    In this case, we need to create nested routes for the `/contact` page using the
    `children` field of the route configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: 'First create the `ContactFaqView` and `ContactFormView` components, so the
    router can render them when matched, and then modify our `/contact` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also stub the placeholder component `RouterView` inside the `ContactView`
    to render the nested routes. As an example, let’s add the following code to the
    `ContactView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now this Contact component will render `ContactFaqView` when the user navigates
    to *http://localhost:4000/contact/faq* ([Figure 8-13](#figure_07_contactfaq_nested))
    and `ContactFormView` when the user navigates to *http://localhost:4000/contact/form*,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Contact page with FAQ view rendered inside when navigating
    to http://localhost:4000/contact/faq](assets/lvue_0813.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13\. Example output when navigating to http://localhost:4000/contact/faq
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This approach proves beneficial when we want to create a specific UI layout
    for a page containing nested views with nested routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how to create a nested route within a parent layout. However,
    in some cases we want to make a nested way without a parent layout, so we must
    declare the default path for the parent’s route as its nested route object. For
    example, instead of claiming the parent `/contact` route’s `name` and `component`,
    we can move it to the nested path with an empty path pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This way, when the user navigates to *http://localhost:4000/contact/faq*, only
    the `Contact``FaqView` component will be rendered as a separate page, without
    the content of the `ContactView` ([Figure 8-14](#figure_07_contactfaq)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Contact page with FAQ view rendered inside when navigating
    to http://localhost:4000/contact/faq](assets/lvue_0814.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-14\. Example output when navigating to http://localhost:4000/contact/faq
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see in the screenshot, the Contact link is still active in the navigation
    bar. This behavior happens because the link element of the Contact page still
    has the class `router-link-active`, but not `router-link-exact-active`. We can
    fix this styling issue by defining CSS rules for only the exact active link instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested routes is very common in real-world applications; in fact, our
    `routes` array is already nested children for the router instance of the application.
    Declaring nested routes is a great way to organize routing structure and create
    dynamic routes, which we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Dynamic Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most beneficial features of Vue Router is the ability to set up dynamic
    routes with routing parameters (routing params), which are variables extracted
    from a URL path. Routing params come in handy when we have a dynamic data-driven
    route structure. Each route shares a typical pattern and differs only by a unique
    identifier, such as a user or product id.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revise our routes for the Pizza House and add a dynamic path for displaying
    one pizza at a time. One option is to define a new route, `/pizza`, and pass the
    pizza’s id as its query parameter as `/pizza?id=my-pizza-id` as we learned in
    [“Passing Data Between Routes”](#passing_data_between_routes). The better option,
    however, is to modify the `/pizzas` route and add a new nested route to it with
    the path pattern `:id`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By using `:id`, Vue Router will match any path that has a similar format, like
    */pizzas/1234-pizza-id*, and save the extracted id (like `1234-pizza-id`) as the
    `route.params.id` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we learned about the `props` field in the route configuration object,
    we can set its value to `true`, enabling the automatic mapping of route parameters
    to the `PizzaView`’s props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the bound `PizzaView` component, we declare `id` as the component’s props
    with `defineProps()` and retrieve the pizza’s details from the `pizzas` array
    using the `useRoute` hook and this `id` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can display the details of `pizza` in the `PizzaView` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now when you navigate to `/pizzas/1`, with `1` as the id of an existing pizza
    in the list, the `PizzaView` component will display the pizza’s details, as shown
    in [Figure 8-15](#figure_07_pizza_details).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying the pizza details page of pizza with id 1](assets/lvue_0815.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15\. Pizza details page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Fetching Data from the Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, you should avoid fetching data again from the server, such as `pizzas`
    in the `PizzaView` component. Instead, you should use data store management such
    as Pinia ([Chapter 9](ch09.html#unique_chapter_id_08)) to store fetched `pizzas`
    and retrieve them from the store whenever needed.
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have explored how to create nested and dynamic routes and decoupled
    the route’s parameters into props. In the next section, we will learn how to implement
    custom back and forward buttons for our application with Vue Router.
  prefs: []
  type: TYPE_NORMAL
- en: Going Back and Forward with the Router Instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a custom back button is a common feature in web applications in
    addition to using the native browser’s back button. We can use the `router.back()`
    method to navigate to the previous page in the history stack, where `router` is
    the app’s router instance received from `useRouter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To move forward in the history stack, we can use the `router.forward()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using router.go() To Navigate to a Specific Page in the History Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use the `router.go()` method, which accepts an argument as the
    number of steps in the history stack to go back or forward. For instance, `router.go(-2)`
    will navigate to the page two steps back, while `router.go(2)` will jump two steps
    forward (if they exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have explored the basics of Vue Router and created a basic routing system
    for our application with all the pages we need. But there is one thing we need
    to handle: if you try to navigate a path that doesn’t exist, you will see a blank
    page. This scenario happens because Vue Router can’t find a matched component
    to render when the user tries to navigate to a path that doesn’t exist. This will
    be our next topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling Unknown Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most scenarios, we can’t control all the paths users will try to navigate
    while using our application. For instance, a user may attempt to access *https://localhost:4000/pineapples*,
    for which we haven’t defined a route. We can display a 404 page to the user in
    such cases by using the regular expressions (regex) pattern `/:pathMatch(.**)**`
    as `path` in a new `error` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Vue Router will match the unfound paths against the pattern `/:pathMatch(.**)**`
    accordingly and then store the matched path value in the `pathMatch` parameter
    of the route location object.
  prefs: []
  type: TYPE_NORMAL
- en: Using Regex to Match Unknown Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can replace `pathMatch` with any other name you want. Its purpose is to
    let Vue Router knows where to store the matched path value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ErrorView` component, we can display a message to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now when we try to visit *https://localhost:4000/pineapples* or any unknown
    path, we will see the 404 page rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can use the `useRoute()` method of the `vue-router` package
    to access the current route location and display its path’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code will display the path of the current route, which is, in this case,
    `/pineapples` ([Figure 8-16](#figure_07_error)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the 404 page](assets/lvue_0816.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-16\. The 404 page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the `redirect` property in the route configuration
    to redirect users to a specific route, such as the home page, when they visit
    an unknown path. For example, we can rewrite our `error` route as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When we visit an unknown path, the router instance will automatically redirect
    us to the home page, and we no longer need an `ErrorView` component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored how we can build a routing system for our
    Vue application using different APIs provided by Vue Router in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Moving between routes requires the data flow to be consistent, like handling
    data flow between components that aren’t in a direct parent-children relationship.
    To solve this challenge, we need an efficient data management system for our application.
    The next chapter introduces Pinia, the official data management library for Vue,
    and how we can build an efficient, reusable data management system using Pinia
    APIs.
  prefs: []
  type: TYPE_NORMAL
