- en: Chapter 8\. Periodic Job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Periodic Job* pattern extends the *Batch Job* pattern by adding a time
    dimension and allowing the execution of a unit of work to be triggered by a temporal
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of distributed systems and microservices, there is a clear tendency
    toward real-time and event-driven application interactions using HTTP and lightweight
    messaging. However, regardless of the latest trends in software development, job
    scheduling has a long history, and it is still relevant. Periodic jobs are commonly
    used for automating system maintenance or administrative tasks. They are also
    relevant to business applications requiring specific tasks to be performed periodically.
    Typical examples here are business-to-business integration through file transfer,
    application integration through database polling, sending newsletter emails, and
    cleaning up and archiving old files.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional way of handling periodic jobs for system maintenance purposes
    has been to use specialized scheduling software or cron. However, specialized
    software can be expensive for simple use cases, and cron jobs running on a single
    server are difficult to maintain and represent a single point of failure. That
    is why, very often, developers tend to implement solutions that can handle both
    the scheduling aspect and the business logic that needs to be performed. For example,
    in the Java world, libraries such as Quartz, Spring Batch, and custom implementations
    with the `ScheduledThreadPoolExecutor` class can run temporal tasks. But similar
    to cron, the main difficulty with this approach is making the scheduling capability
    resilient and highly available, which leads to high resource consumption. Also,
    with this approach, the time-based job scheduler is part of the application, and
    to make the scheduler highly available, the whole application must be highly available.
    Typically, that involves running multiple instances of the application and at
    the same time ensuring that only a single instance is active and schedules jobs—which
    involves leader election and other distributed systems challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, a simple service that has to copy a few files once a day may end
    up requiring multiple nodes, a distributed leader election mechanism, and more.
    Kubernetes CronJob implementation solves all that by allowing scheduling of Job
    resources using the well-known cron format and letting developers focus only on
    implementing the work to be performed rather than the temporal scheduling aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7, “Batch Job”](ch07.html#BatchJob), we saw the use cases and the
    capabilities of Kubernetes Jobs. All of that applies to this chapter as well since
    the CronJob primitive builds on top of a Job. A CronJob instance is similar to
    one line of a Unix crontab (cron table) and manages the temporal aspects of a
    Job. It allows the execution of a Job periodically at a specified point in time.
    See [Example 8-1](#ex-cron-job) for a sample definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. A CronJob resource
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_periodic_job_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Cron specification for running every three minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_periodic_job_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Job template that uses the same specification as a regular Job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the Job spec, a CronJob has additional fields to define its temporal
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.spec.schedule`'
  prefs: []
  type: TYPE_NORMAL
- en: Crontab entry for specifying the Job’s schedule (e.g., `0 * * * *` for running
    every hour). You can also use shortcuts like `@daily` or `@hourly`. Please refer
    to the [CronJob documentation](https://oreil.ly/Qc3TA) for all available options.
  prefs: []
  type: TYPE_NORMAL
- en: '`.spec.startingDeadlineSeconds`'
  prefs: []
  type: TYPE_NORMAL
- en: Deadline (in seconds) for starting the Job if it misses its scheduled time.
    In some use cases, a task is valid only if it executed within a certain timeframe,
    and it is useless when executed late. For example, if a Job is not executed in
    the desired time because of a lack of compute resources or other missing dependencies,
    it might be better to skip an execution because the data it is supposed to process
    is already obsolete. Don’t use a deadline fewer than 10 seconds since Kubernetes
    will check the Job status only every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '`.spec.concurrencyPolicy`'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies how to manage concurrent executions of Jobs created by the same CronJob.
    The default behavior `Allow` creates new Job instances even if the previous Jobs
    have not completed yet. If that is not the desired behavior, it is possible to
    skip the next run if the current one has not completed yet with `Forbid` or to
    cancel the currently running Job and start a new one with `Replace`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.spec.suspend`'
  prefs: []
  type: TYPE_NORMAL
- en: Field suspending all subsequent executions without affecting already-started
    executions. Note that this is different from a Job’s `.spec.suspend` as the start
    of new Jobs will be suspended, not the Jobs themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '`.spec.successfulJobsHistoryLimit` and `.spec.failedJobsHistoryLimit`'
  prefs: []
  type: TYPE_NORMAL
- en: Fields specifying how many completed and failed Jobs should be kept for auditing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: CronJob is a very specialized primitive, and it applies only when a unit of
    work has a temporal dimension. Even if CronJob is not a general-purpose primitive,
    it is an excellent example of how Kubernetes capabilities build on top of one
    another and support noncloud native use cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, a CronJob is a pretty simple primitive that adds clustered,
    cron-like behavior to the existing Job definition. But when it is combined with
    other primitives such as Pods, container resource isolation, and other Kubernetes
    features such as those described in [Chapter 6, “Automated Placement”](ch06.html#AutomatedPlacement),
    or [Chapter 4, “Health Probe”](ch04.html#HealthProbe), it ends up being a very
    powerful job-scheduling system. This enables developers to focus solely on the
    problem domain and implement a containerized application that is responsible only
    for the business logic to be performed. The scheduling is performed outside the
    application, as part of the platform with all of its added benefits, such as high
    availability, resiliency, capacity, and policy-driven Pod placement. Of course,
    similar to the Job implementation, when implementing a CronJob container, your
    application has to consider all corner and failure cases of duplicate runs, no
    runs, parallel runs, or cancellations.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Periodic Job Example](https://oreil.ly/yINcj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CronJob](https://oreil.ly/9096p)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cron](https://oreil.ly/ZPavq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crontab Specification](https://oreil.ly/Oi3b5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cron Expression Generator](https://oreil.ly/xYymj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
