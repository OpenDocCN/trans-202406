- en: Chapter 18\. Resource Requirements, Limits, and Quotas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 18 章\. 资源需求、限制和配额
- en: Workload executed in Pods will consume a certain amount of resources (e.g.,
    CPU and memory). You should define resource requirements for those applications.
    On a container level, you can define a minimum amount of resources needed to run
    the application, as well as the maximum amount of resources the application is
    allowed to consume. Application developers should determine the right-sizing with
    load tests or at runtime by monitoring the resource consumption.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 中执行的工作负载将消耗一定量的资源（例如 CPU 和内存）。您应该为这些应用程序定义资源需求。在容器级别，可以定义运行应用程序所需的最小资源量，以及应用程序允许消耗的最大资源量。应用程序开发人员应通过负载测试或在运行时通过监控资源消耗来确定合适的资源大小。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注释
- en: Kubernetes measures CPU resources in millicores and memory resources in bytes.
    That’s why you might see resources defined as 600m or 100Mi. For a deep dive on
    those resource units, it’s worth cross-referencing the section [“Resource units
    in Kubernetes”](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)
    in the official documentation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用毫核 CPU 和字节内存来衡量资源。这就是为什么您可能会看到资源定义为 600m 或 100Mi。深入了解这些资源单位，值得参考官方文档中关于
    [“Kubernetes 中的资源单位”](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)
    的部分。
- en: Kubernetes  administrators  can  put  measures  in  place  to  enforce  the
     use  of  available resource capacity. We’ll discuss two Kubernetes primitives
    in this realm, the ResourceQuota and the LimitRange. The ResourceQuota defines
    aggregate resource constraints on a namespace level. A LimitRange is a policy
    that constrains or defaults the resource allocations for a single object of a
    specific type (such as for a Pod or a PersistentVolumeClaim).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 管理员可以采取措施来强制使用可用资源容量。我们将讨论两个 Kubernetes 原语，ResourceQuota 和 LimitRange。ResourceQuota
    在命名空间级别定义聚合资源约束。LimitRange 是一种策略，用于约束或为特定类型的单个对象（如 Pod 或 PersistentVolumeClaim）的资源分配设置默认值。
- en: Working with Resource Requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理资源需求
- en: It’s recommended practice that you specify resource requests and limits for
    every container. Determining those resource expectations is not always easy, specifically
    for applications that haven’t been exercised in a production environment yet.
    Load testing the application early during the development cycle can help with
    analyzing the resource needs. Further adjustments can be made by monitoring the
    application’s resource consumption after deploying it to the cluster.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的最佳实践是为每个容器指定资源请求和限制。确定这些资源期望并不总是容易，特别是对于尚未在生产环境中运行的应用程序。在开发周期早期对应用程序进行负载测试可以帮助分析资源需求。将应用程序部署到集群后，可以通过监控应用程序的资源消耗进一步进行调整。
- en: Defining Container Resource Requests
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义容器资源请求
- en: One metric that comes into play for workload scheduling is the *resource request*
    defined by the containers in a Pod. Commonly used resources that can be specified
    are CPU and memory. The scheduler ensures that the node’s resource capacity can
    fulfill the resource requirements of the Pod. More specifically, the scheduler
    determines the sum of resource requests per resource type across all containers
    defined in the Pod and compares them with the node’s available resources.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用于工作负载调度的一个指标是 Pod 中容器定义的 *资源请求*。常用的可指定资源包括 CPU 和内存。调度器确保节点的资源容量能够满足 Pod 的资源需求。具体而言，调度器确定
    Pod 中所有容器定义的每种资源类型的资源请求总和，并将其与节点的可用资源进行比较。
- en: Each container in a Pod can define its own resource requests. [Table 18-1](#options_resource_requests)
    describes the available options including an example value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Pod 中的每个容器都可以定义自己的资源请求。[表 18-1](#options_resource_requests)描述了可用的选项，包括一个示例值。
- en: Table 18-1\. Options for resource requests
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-1\. 资源请求选项
- en: '| YAML attribute | Description | Example value |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| YAML 属性 | 描述 | 示例值 |'
- en: '| --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `spec.containers[].resources.requests.cpu` | CPU resource type | `500m` (five
    hundred millicpu) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.cpu` | CPU 资源类型 | `500m`（五百毫 CPU） |'
- en: '| `spec.containers[].resources.requests.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.memory` | 内存资源类型 | `64Mi`（2^26 字节）
    |'
- en: '| `spec.containers[].resources.requests.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.hugepages-<size>` | 大页资源类型 | `hugepages-2Mi:
    60Mi` |'
- en: '| `spec.containers[].resources.requests.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.ephemeral-storage` | 临时存储资源类型 | `4Gi`
    |'
- en: To clarify the uses of these resource requests, we’ll look at an example definition.
    The Pod YAML manifest shown in [Example 18-1](#setting_container_resource_requests)
    defines two containers, each with its own resource requests. Any node that is
    allowed to run the Pod needs to be able to support a minimum memory capacity of
    320Mi and 1250m CPU, the sum of resources across both containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清这些资源请求的用途，我们将看一个示例定义。在 [示例 18-1](#setting_container_resource_requests) 中显示的
    Pod YAML 清单定义了两个容器，每个容器都有自己的资源请求。允许运行该 Pod 的任何节点需要能够支持至少 320Mi 的内存容量和 1250m 的
    CPU，这是两个容器资源的总和。
- en: Example 18-1\. Setting container resource requests
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-1\. 设置容器资源请求
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It’s certainly possible that a Pod cannot be scheduled due to insufficient resources
    available on the nodes. In those cases, the event log of the Pod will indicate
    this situation with the reasons `PodExceedsFreeCPU` or `PodExceedsFreeMemory`.
    For more information on how to troubleshoot and resolve this situation, see the
    relevant [section in the documentation](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#troubleshooting).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点上的资源不足以安排 Pod 时，Pod 的事件日志将使用 `PodExceedsFreeCPU` 或 `PodExceedsFreeMemory`
    的原因指示此情况。有关如何排查和解决此情况的详细信息，请参阅相关 [文档部分](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#troubleshooting)。
- en: Defining Container Resource Limits
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义容器资源限制
- en: Another metric you can set for a container is the *resource limits*. Resource
    limits ensure that the container cannot consume more than the allotted resource
    amounts. For example, you could express that the application running in the container
    should be constrained to 1000m of CPU and 512Mi of memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个您可以为容器设置的度量是 *资源限制*。资源限制确保容器不能消耗超过分配的资源量。例如，您可以表达在容器中运行的应用程序应受到 1000m CPU
    和 512Mi 内存的限制。
- en: Depending on the container runtime used by the cluster, exceeding any of the
    allowed resource limits results in a termination of the application process running
    in the container or results in the system preventing the allocation of resources
    beyond the limits. For an in-depth discussion on how resource limits are treated
    by the container runtime Docker Engine, see the [documentation](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#how-pods-with-resource-limits-are-run).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据集群使用的容器运行时，超过允许的任何资源限制都会导致终止在容器中运行的应用程序进程或导致系统阻止超出限制的资源分配。有关容器运行时 Docker Engine
    如何处理资源限制的深入讨论，请参阅 [文档](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#how-pods-with-resource-limits-are-run)。
- en: '[Table 18-2](#options_resource_limits) describes the available options including
    an example value.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 18-2](#options_resource_limits) 描述了可用选项，包括示例值。'
- en: Table 18-2\. Options for resource limits
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-2\. 资源限制选项
- en: '| YAML attribute | Description | Example value |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| YAML 属性 | 描述 | 示例值 |'
- en: '| --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `spec.containers[].resources.limits.cpu` | CPU resource type | `500m` (500
    millicpu) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.cpu` | CPU 资源类型 | `500m` (500 毫核) |'
- en: '| `spec.containers[].resources.limits.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.memory` | 内存资源类型 | `64Mi` (2^26 字节) |'
- en: '| `spec.containers[].resources.limits.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.hugepages-<size>` | 大页资源类型 | `hugepages-2Mi:
    60Mi` |'
- en: '| `spec.containers[].resources.limits.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.ephemeral-storage` | 临时存储资源类型 | `4Gi`
    |'
- en: '[Example 18-2](#setting_container_resource_limits) shows the definition of
    limits in action. Here, the container named `business-app` cannot use more than
    512Mi of memory. The container named `ambassador` defines a limit of 128Mi of
    memory.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-2](#setting_container_resource_limits) 展示了限制定义的实际操作。在这里，名为 `business-app`
    的容器不能使用超过 512Mi 的内存。名为 `ambassador` 的容器定义了 128Mi 内存的限制。'
- en: Example 18-2\. Setting container resource limits
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-2\. 设置容器资源限制
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Defining Container Resource Requests and Limits
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义容器资源请求和限制
- en: To provide Kubernetes with the full picture of your application’s resource expectations,
    you must specify resource requests and limits for every container. [Example 18-3](#settings_container_resource_requests_limits)
    combines resource requests and limits in a single YAML manifest.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 Kubernetes 提供你的应用程序资源期望的全貌，你必须为每个容器指定资源请求和限制。[示例 18-3](#settings_container_resource_requests_limits)
    将资源请求和限制结合在单个 YAML 清单中。
- en: Example 18-3\. Setting container resource requests and limits
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-3\. 设置容器资源请求和限制
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Assigning static container resource requirements is an approximation process.
    You want maximizing an efficient utilization of resources in your Kubernetes cluster.
    Unfortunately, the Kubernetes documentation does not offer a lot of guidance on
    best practices. The blog post [“For the Love of God, Stop Using CPU Limits on
    Kubernetes”](https://home.robusta.dev/blog/stop-using-cpu-limits) provides the
    following guidance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 分配静态容器资源需求是一个近似的过程。你希望在你的 Kubernetes 集群中最大化资源的有效利用。不幸的是，Kubernetes 文档并没有提供很多关于最佳实践的指导。博客文章
    [“**停止在 Kubernetes 上使用 CPU 限制**”](https://home.robusta.dev/blog/stop-using-cpu-limits)
    提供了以下建议：
- en: Always define memory requests.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是定义内存请求。
- en: Always define memory limits.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是定义内存限制。
- en: Always set your memory requests equal to your limit.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是将内存请求设置为与限制相等。
- en: Always define CPU requests.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是定义 CPU 请求。
- en: Do not use CPU limits.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 CPU 限制。
- en: After launching your application to production, you still need to monitor your
    application resource consumption patterns. Review resource consumption at runtime
    and keep track of actual scheduling behavior and potential undesired behaviors
    once the application receives load. Finding a happy medium can be frustrating.
    Projects like [Goldilocks](https://www.fairwinds.com/blog/introducing-goldilocks-a-tool-for-recommending-resource-requests)
    and [KRR](https://github.com/robusta-dev/krr) emerged to provide recommendations
    and guidance on appropriately determining resource requests. Other options, like
    the [container resize policies](https://kubernetes.io/docs/tasks/configure-pod-container/resize-container-resources/#container-resize-policies)
    introduced in Kubernetes 1.27, allow for more fine-grained control over how containers’
    CPU and memory resources are resized automatically at runtime.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在将你的应用程序投入生产后，仍然需要监控应用程序的资源消耗模式。在运行时审查资源消耗，并跟踪实际的调度行为以及应用程序接收负载后可能出现的不良行为。找到一个合适的平衡可能会令人沮丧。类似
    [Goldilocks](https://www.fairwinds.com/blog/introducing-goldilocks-a-tool-for-recommending-resource-requests)
    和 [KRR](https://github.com/robusta-dev/krr) 的项目出现，提供了关于适当确定资源请求的建议和指导。其他选择，如 Kubernetes
    1.27 中引入的 [容器调整策略](https://kubernetes.io/docs/tasks/configure-pod-container/resize-container-resources/#container-resize-policies)，允许更精细地控制容器的
    CPU 和内存资源在运行时如何自动调整大小。
- en: Working with Resource Quotas
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Resource Quotas
- en: 'The Kubernetes primitive ResourceQuota establishes the usable, maximum amount
    of resources per namespace. Once put in place, the Kubernetes scheduler will take
    care of enforcing those rules. The following list should give you an idea of the
    rules that can be defined:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的原始 ResourceQuota 定义了每个命名空间可用的资源的最大数量。一旦生效，Kubernetes 调度器将负责强制执行这些规则。下面的列表应该让你对可以定义的规则有一个了解：
- en: Setting an upper limit for the number of objects that can be created for a specific
    type (e.g., a maximum of three Pods).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置特定类型可以创建的对象数量的上限（例如，最多三个 Pod）。
- en: Limiting the total sum of compute resources (e.g., 3Gi of RAM).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制计算资源的总和（例如，3Gi RAM）。
- en: Expecting a Quality of Service (QoS) class for a Pod (e.g., `BestEffort` to
    indicate that the Pod must not make any memory or CPU limits or requests).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望 Pod 的服务质量（QoS）类别（例如，`BestEffort` 表示 Pod 不应设置任何内存或 CPU 的限制或请求）。
- en: Creating ResourceQuotas
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ResourceQuotas
- en: 'Creating a ResourceQuota object is usually a task that a Kubernetes administrator
    would take on, but it’s relatively easy to define and create such an object. First,
    create the namespace the quota should apply to:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ResourceQuota 对象通常是 Kubernetes 管理员的任务，但定义和创建这样的对象相对简单。首先，创建应用此配额的命名空间：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, define the ResourceQuota in YAML. To demonstrate the functionality of
    a ResourceQuota, add constraints to the namespace, as shown in [Example 18-4](#resource_quota).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 YAML 中定义 ResourceQuota。为了展示 ResourceQuota 的功能性，向命名空间添加约束，如 [示例 18-4](#resource_quota)
    所示。
- en: Example 18-4\. Defining hard resource limits with a ResourceQuota
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-4\. 使用 ResourceQuota 定义硬资源限制
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_resource_requirements__limits__and_quotas_CO1-1)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_resource_requirements__limits__and_quotas_CO1-1)'
- en: Limit the number of Pods to 2.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将Pod的数量限制为2个。
- en: '[![2](Images/2.png)](#co_resource_requirements__limits__and_quotas_CO1-2)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_resource_requirements__limits__and_quotas_CO1-2)'
- en: Define the minimum resources requested across all Pods in a non-terminal state
    to 1 CPU and 1024Mi of RAM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 定义处于非终端状态的所有Pod的最小资源请求为1个CPU和1024Mi RAM。
- en: '[![3](Images/3.png)](#co_resource_requirements__limits__and_quotas_CO1-4)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_resource_requirements__limits__and_quotas_CO1-4)'
- en: Define the maximum resources used by all Pods in a non-terminal state to 4 CPUs
    and 4096Mi of RAM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 定义处于非终端状态的所有Pod使用的最大资源为4个CPU和4096Mi RAM。
- en: 'You’re ready to create a ResourceQuota for the namespace:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您已准备好为命名空间创建 ResourceQuota：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rendering ResourceQuota Details
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染 ResourceQuota 详情
- en: 'You can render a table overview of used resources vs. hard limits using the
    `kubectl describe` command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl describe`命令渲染已使用资源与硬限制的表格概述：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Hard column lists the same values you provided with the ResourceQuota definition.
    Those values won’t change also long as you don’t modify the object’s specification.
    Under the Used column, you can find the actual aggregate resource consumption
    within the namespace. At this time, all values are 0 given that no Pods have been
    created yet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬限制列出了与ResourceQuota定义提供的相同值。只要您不修改对象的规范，这些值不会改变。在已使用列下，您可以找到命名空间内的实际聚合资源消耗。目前，所有值均为0，因为尚未创建任何Pod。
- en: Exploring a ResourceQuota’s Runtime Behavior
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 ResourceQuota 的运行时行为
- en: With the quota rules in place for the namespace `team-awesome`, we’ll want to
    see its enforcement in action. We’ll start by creating more than the maximum number
    of Pods, which is two. To test this, we can create Pods with any definition we
    like. For example, we use a bare-bones definition that runs the image `nginx:1.25.3`
    in the container, as shown in [Example 18-5](#pod_without_resource_requirements).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间`team-awesome`中实施了配额规则后，我们希望看到其执行情况。我们将从创建超过最大Pod数目的实验开始，这个数目是两个。为了测试这一点，我们可以创建任何我们喜欢的定义Pod。例如，我们可以使用一个最基本的定义，该定义在容器中运行图像`nginx:1.25.3`，如示例[18-5](#pod_without_resource_requirements)所示。
- en: Example 18-5\. A Pod without resource requirements
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-5\. 没有资源需求的Pod
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From that YAML definition stored in *nginx-pod.yaml*, let’s create a Pod and
    see what happens. In fact, Kubernetes will reject the creation of the object with
    the following error message:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据存储在 *nginx-pod.yaml* 中的YAML定义，让我们创建一个Pod并看看会发生什么。实际上，Kubernetes将拒绝创建对象，并显示以下错误信息：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because we defined minimum and maximum resource quotas for objects in the namespace,
    we have to ensure that Pod objects actually define resource requests and limits.
    Modify the initial definition by updating the instruction under `resources`, as
    shown in [Example 18-6](#pod_with_resource_requirements).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在命名空间中为对象定义了最小和最大资源配额，所以我们必须确保Pod对象实际上定义了资源请求和限制。通过更新`resources`指令来修改初始定义，如示例[18-6](#pod_with_resource_requirements)所示。
- en: Example 18-6\. A Pod with resource requirements
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-6\. 具有资源需求的Pod
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should be able to create two uniquely named Pods—`nginx1` and `nginx2`—with
    that manifest; the combined resource requirements still fit with the boundaries
    defined in the ResourceQuota:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够创建两个具有唯一名称的Pod——`nginx1`和`nginx2`——使用该清单；合并后的资源需求仍符合ResourceQuota中定义的边界：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You may be able to imagine what would happen if we tried to create another
    Pod with the definition of `nginx1` and `nginx2`. It will fail for two reasons.
    The first reason is that we’re not allowed to create a third Pod in the namespace,
    as the maximum number is set to two. The second reason is that we’d exceed the
    allotted maximum for `requests.cpu` and `requests.memory`. The following error
    message provides us with this information:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们尝试使用`nginx1`和`nginx2`的定义创建另一个Pod，你或许能够想象出会发生什么。它会因为两个原因而失败。第一个原因是我们不被允许在命名空间中创建第三个Pod，因为最大数目被设置为两个。第二个原因是我们将超出`requests.cpu`和`requests.memory`的最大分配限制。以下错误信息提供了这些信息：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Working with Limit Ranges
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用限制范围
- en: In the previous section, you learned how a resource quota can restrict the consumption
    of resources within a specific namespace in aggregate. For individual Pod objects,
    the resource quota cannot set any constraints. That’s where the limit range comes
    in. The enforcement of LimitRange rules happens during the [admission control
    phase](ch17.xhtml#admission_control_phase) when processing an API request.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您了解了资源配额如何限制特定命名空间中资源的总体消耗。对于单个Pod对象，资源配额无法设置任何约束。这就是LimitRange的作用。在处理API请求时，LimitRange规则的执行发生在[准入控制阶段](ch17.xhtml#admission_control_phase)。
- en: 'The LimitRange is a Kubernetes primitive that constrains or defaults the resource
    allocations for specific object types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: LimitRange是Kubernetes的一个原语，用于约束或默认特定对象类型的资源分配：
- en: Enforces minimum and maximum compute resources usage per Pod or container in
    a namespace
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间中强制Pod或容器的最小和最大计算资源使用
- en: Enforces minimum and maximum storage request per PersistentVolumeClaim in a
    namespace
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间中强制每个PersistentVolumeClaim的最小和最大存储请求
- en: Enforces a ratio between request and limit for a resource in a namespace
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制在命名空间中资源请求和限制之间设置比率
- en: Sets default requests/limits for compute resources in a namespace and automatically
    injects them into containers at runtime
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间中为计算资源设置默认请求/限制，并在运行时自动注入到容器中
- en: Defining more than one LimitRange in a namespace
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命名空间中定义多个LimitRange
- en: It is best to create only a single LimitRange object per namespace. Default
    resource requests and limits specified by multiple LimitRange objects in the same
    namespace causes non-deterministic selection of those rules. Only one of the default
    definitions will win, but you can’t predict which one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最好每个命名空间只创建一个LimitRange对象。在同一命名空间中由多个LimitRange对象指定的默认资源请求和限制会导致这些规则的非确定性选择。只有一个默认定义会生效，但无法预测哪一个会生效。
- en: Creating LimitRanges
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LimitRange
- en: The LimitRange offers a list of configurable constraint attributes. All are
    described in great detail in the Kubernetes API documentation for a [LimitRangeSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#limitrangeitem-v1-core).
    [Example 18-7](#limit_range) shows a YAML manifest for a LimitRange that uses
    some of the constraint attributes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: LimitRange提供了一系列可配置的约束属性列表。所有这些属性在Kubernetes API文档中的[LimitRangeSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#limitrangeitem-v1-core)中都有详细描述。[示例 18-7](#limit_range)展示了使用某些约束属性的LimitRange的YAML清单。
- en: Example 18-7\. A limit range defining multiple constraint criteria
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例18-7。定义多个约束条件的LimitRange
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_resource_requirements__limits__and_quotas_CO2-1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_resource_requirements__limits__and_quotas_CO2-1)'
- en: The context to apply the constraints to. In this case, to a container running
    in a Pod.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应用约束的上下文。在这种情况下，应用到运行在Pod中的容器。
- en: '[![2](Images/2.png)](#co_resource_requirements__limits__and_quotas_CO2-2)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_resource_requirements__limits__and_quotas_CO2-2)'
- en: The default CPU resource request value assigned to a container if not provided.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供，分配给容器的默认CPU资源请求值。
- en: '[![3](Images/3.png)](#co_resource_requirements__limits__and_quotas_CO2-3)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_resource_requirements__limits__and_quotas_CO2-3)'
- en: The default CPU resource limit value assigned to a container if not provided.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供，分配给容器的默认CPU资源限制值。
- en: '[![4](Images/4.png)](#co_resource_requirements__limits__and_quotas_CO2-4)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_resource_requirements__limits__and_quotas_CO2-4)'
- en: The minimum and maximum CPU resource request and limit value assignable to a
    container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可分配给容器的最小和最大CPU资源请求和限制值。
- en: 'As usual, we can create an object from the manifest with the `kubectl create`
    or `kubectl apply` command. The definition of the LimitRange has been stored in
    the file *cpu-resource-constraint-limitrange.yaml*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以使用`kubectl create`或`kubectl apply`命令从清单中创建对象。LimitRange的定义已存储在文件*cpu-resource-constraint-limitrange.yaml*中：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The constraints will be applied automatically when creating new objects. Changing
    the constraints for an existing LimitRange object won’t have any effect on already
    running Pods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新对象时，约束将自动应用。更改现有LimitRange对象的约束对已运行的Pods没有影响。
- en: Rendering LimitRange Details
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染LimitRange详细信息
- en: 'Live LimitRange objects can be inspected using the `kubectl describe` command.
    The following command renders the details of the LimitRange object named `cpu-resource-constraint`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl describe`命令可以查看实时的LimitRange对象。以下命令呈现了名为`cpu-resource-constraint`的LimitRange对象的详细信息：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output of the command renders each limit constraint on a single line. Any
    constraint attribute that has not been set explicitly by the object will show
    a dash character (`-`) as the assigned value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出将每个限制约束渲染为单独的行。任何对象未显式设置的约束属性将显示破折号 (`-`) 作为分配的值。
- en: Exploring a LimitRange’s Runtime Behavior
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 LimitRange 的运行行为
- en: 'Let’s demonstrate what effect the LimitRange has on the creation of Pods. We
    will walk through two different use cases:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示 LimitRange 对 Pod 创建的影响。我们将讨论两种不同的使用情况：
- en: Automatically setting resource requirements if they have not been provided by
    the Pod definition.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Pod 定义没有提供资源要求，则自动设置资源要求。
- en: Preventing the creation of a Pod if the declared resource requirements are forbidden
    by the LimitRange.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果声明的资源要求被 LimitRange 禁止，则阻止创建 Pod。
- en: Setting default resource requirements
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置默认资源要求
- en: The LimitRange defines a default CPU resource request of 200m and a default
    CPU resource limit of 200m. That means if a Pod is about to be created, and it
    doesn’t define a CPU resource request and limit, the LimitRange will automatically
    assign the default values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: LimitRange 定义了默认的 CPU 资源请求为 200m，CPU 资源限制为 200m。这意味着如果要创建一个 Pod，并且它没有定义 CPU
    资源请求和限制，LimitRange 将自动分配默认值。
- en: '[Example 18-8](#pod_no_resource_requirements) shows a Pod definition without
    resource requirements.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-8](#pod_no_resource_requirements) 展示了一个没有资源要求的 Pod 定义。'
- en: Example 18-8\. A Pod defining no resource requirements
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-8\. 定义无资源要求的 Pod
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Creating the object from the contents stored in the file *nginx-without-resource-requirements.yaml*
    will work as expected:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 根据存储在文件 *nginx-without-resource-requirements.yaml* 中的内容创建对象将按预期工作：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Pod object will be mutated in two ways. First, the default resource requirements
    set by the LimitRange are applied. Second, an annotation with the key `kubernetes.io/limit-ranger`
    will be added that provides meta information on what has been changed. You can
    find both pieces of information in the output of the `describe` command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 对象将以两种方式被修改。首先，LimitRange 设置的默认资源要求将被应用。其次，将添加一个键为 `kubernetes.io/limit-ranger`
    的注释，提供关于已更改内容的元信息。您可以在 `describe` 命令的输出中找到这两个信息：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Enforcing resource requirements
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制资源要求
- en: The LimitRange can enforce resource limits as well. For the LimitRange object
    we created earlier, the minimum amount of CPU was set to 100m, and the maximum
    amount of CPU was set to 2\. To see the enforcement behavior in action, we’ll
    create a new Pod as shown in [Example 18-9](#pod_with_resource_requirements2).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: LimitRange 也可以强制资源限制。对于我们之前创建的 LimitRange 对象，CPU 的最小值设置为 100m，最大值设置为 2\. 为了查看执行行为，我们将创建一个新的
    Pod，如 [示例 18-9](#pod_with_resource_requirements2) 中所示。
- en: Example 18-9\. A Pod defining CPU resource requests and limits
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-9\. 定义 CPU 资源请求和限制的 Pod
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The resource requirements of this Pod do not follow the constraints expected
    by the LimitRange object. The CPU resource request is less than 100m, and the
    CPU resource limit is higher than 2\. As a result, the object won’t be created
    and an appropriate error message will be rendered:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Pod 的资源要求不符合 LimitRange 对象期望的约束。CPU 资源请求少于 100m，CPU 资源限制高于 2\. 因此，对象将不会被创建，并将显示适当的错误消息：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The error message provides some guidance on expected resource definitions. Unfortunately,
    the message doesn’t point to the name of the LimitRange object enforcing those
    expectations. Proactively check if a LimitRange object has been created for the
    namespace and what parameters have been set using `kubectl get limitranges`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息提供了关于预期资源定义的一些指导。不幸的是，消息没有指出实施这些期望的 LimitRange 对象的名称。请主动检查命名空间中是否已创建 LimitRange
    对象，并使用 `kubectl get limitranges` 命令查看设置的参数。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Resource requests are one of the many factors that the kube-scheduler algorithm
    considers when making decisions on which node a Pod can be scheduled. A container
    can specify requests using `spec.containers[].resources.requests`. The scheduler
    chooses a node based on its available hardware capacity. The resource limits ensure
    that the container cannot consume more than the allotted resource amounts. Limits
    can be defined for a container using the attribute `spec.con⁠tainers[].resources.limits`.
    Should an application consume more than the allowed amount of resources (e.g.,
    due to a memory leak in the implementation), the container runtime will likely
    terminate the application process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 资源请求是 kube-scheduler 算法在决定 Pod 可以被调度到哪个节点时考虑的众多因素之一。一个容器可以使用 `spec.containers[].resources.requests`
    来指定请求。调度程序根据节点的可用硬件容量选择节点。资源限制确保容器不能消耗超过分配的资源量。可以使用属性 `spec.con⁠tainers[].resources.limits`
    为容器定义限制。如果应用程序因为实现中的内存泄漏等原因消耗超过允许的资源量，容器运行时很可能会终止应用程序进程。
- en: A resource quota defines the computing resources (e.g., CPU, RAM, and ephemeral
    storage) available to a namespace to prevent unbounded consumption by Pods running
    it. Accordingly, Pods have to work within those resource boundaries by declaring
    their minimum and maximum resource expectations. You can also limit the number
    of resource types (like Pods, Secrets, or ConfigMaps) that are allowed to be created.
    The Kubernetes scheduler will enforce those boundaries upon a request for object
    creation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 资源配额定义了一个命名空间中可用的计算资源（例如 CPU、RAM 和临时存储），以防止运行其中的 Pod 消耗无限资源。因此，Pod 必须在这些资源边界内工作，声明它们的最小和最大资源期望。您还可以限制允许创建的资源类型的数量（例如
    Pods、Secrets 或 ConfigMaps）。Kubernetes 调度程序将在请求对象创建时强制执行这些边界。
- en: The limit range is different from the ResourceQuota in that it defines resource
    constraints for a single object of a specific type. It can also help with governance
    for objects by specifying resource default values that should be applied automatically
    should the API create request not provide the information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 限制范围不同于 ResourceQuota，它为特定类型的单个对象定义资源约束。它还可以通过指定资源默认值来帮助对象的治理，这些值应在 API 创建请求未提供信息时自动应用。
- en: Exam Essentials
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考试要点
- en: Experience the effects of resource requirements on scheduling and autoscaling
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 体验资源需求对调度和自动扩展的影响
- en: A container defined by a Pod can specify resource requests and limits. Work
    through scenarios where you define those requirements individually and together
    for single- and multi-container Pods. Upon creation of the Pod, you should be
    able to see the effects on scheduling the object on a node. Furthermore, practice
    how to identify the available resource capacity of a node.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Pod 定义的容器可以指定资源请求和限制。通过定义单个和多个容器 Pod 的这些要求，解决场景。在创建 Pod 时，您应该能够看到将对象调度到节点的影响。此外，练习如何识别节点的可用资源容量。
- en: Understand the purpose and runtime effects of resource quotas
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 理解资源配额的目的和运行时效果
- en: A ResourceQuota defines the resource boundaries for objects living within a
    namespace. The most commonly used boundaries apply to computing resources. Practice
    defining them and understand their effect on the creation of Pods. It’s important
    to know the command for listing the hard requirements of a ResourceQuota and the
    resources currently in use. You will find that a ResourceQuota offers other options.
    Discover them in more detail for a broader exposure to the topic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ResourceQuota 定义了命名空间中对象的资源边界。最常用的边界适用于计算资源。练习定义它们并了解它们对 Pod 创建的影响。了解列出 ResourceQuota
    的硬性要求和当前正在使用的资源的命令非常重要。您会发现 ResourceQuota 提供了其他选项。详细了解这些选项，以更广泛地了解这个主题。
- en: Understand the purpose and runtime effects of limit ranges
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 理解限制范围的目的和运行时效果
- en: A LimitRange can specify resource constraints and defaults of specific primitives.
    Should you run into a situation where you receive an error message upon creation
    of an object, check if a limit range object enforces those constraints. Unfortunately,
    the error message does not point out the object that enforces it so you may have
    to proactively list LimitRange objects to identify the constraints.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: LimitRange 可以指定特定基元的资源约束和默认值。如果在创建对象时遇到错误消息，请检查是否有限制范围对象强制执行这些约束。不幸的是，错误消息没有指出强制执行它的对象，因此您可能需要主动列出
    LimitRange 对象以识别约束。
- en: Sample Exercises
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例练习
- en: Solutions to these exercises are available in [Appendix A](app01_split_014.xhtml#appendix_a_resource_requirements_limits_quotas).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的解决方案在[附录 A](app01_split_014.xhtml#appendix_a_resource_requirements_limits_quotas)中可用。
- en: You have been tasked with creating a Pod for running an application in a container.
    During application development, you ran a load test for figuring out the minimum
    amount of resources needed and the maximum amount of resources the application
    is allowed to grow to. Define those resource requests and limits for the Pod.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被要求创建一个 Pod 以在容器中运行应用程序。在应用程序开发期间，你运行了负载测试，以确定所需的最小资源量和应用程序允许增长到的最大资源量。定义该
    Pod 的资源请求和限制。
- en: Define a Pod named `hello-world` running the container image `bmuschko/nodejs-hello-world:1.0.0`.
    The container exposes the port 3000.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个名为`hello-world`的 Pod，运行容器镜像`bmuschko/nodejs-hello-world:1.0.0`。容器公开端口3000。
- en: Add a Volume of type `emptyDir` and mount it in the container path `/var/log`.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加一个类型为`emptyDir`的卷，并将其挂载到容器路径`/var/log`。
- en: 'For the container, specify the following minimum number of resources:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于容器，指定以下最小资源数量：
- en: 'CPU: 100m'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU：100m
- en: 'Memory: 500Mi'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：500Mi
- en: 'Ephemeral storage: 1Gi'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时存储：1Gi
- en: 'For the container, specify the following maximum number of resources:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于容器，指定以下最大资源数量：
- en: 'Memory: 500Mi'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：500Mi
- en: 'Ephemeral storage: 2Gi'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时存储：2Gi
- en: Create the Pod from the YAML manifest. Inspect the Pod details. Which node does
    the Pod run on?
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 YAML 清单创建 Pod。检查 Pod 的详细信息。Pod 运行在哪个节点上？
- en: In this exercise, you will create a resource quota with specific CPU and memory
    limits for a new namespace. Pods created in the namespace will have to adhere
    to those limits.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此练习中，你将为新名称空间创建一个具有特定 CPU 和内存限制的资源配额。在名称空间中创建的 Pod 将必须遵守这些限制。
- en: 'Create a ResourceQuota named `app` under the namespace `rq-demo` using the
    following YAML definition in the file *resourcequota.yaml*:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下 YAML 定义在文件 *resourcequota.yaml* 中，在名称空间 `rq-demo` 下创建一个名为 `app` 的 ResourceQuota：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create a new Pod that exceeds the limits of the resource quota requirements,
    e.g., by defining 1Gi of memory but stays below the CPU, e.g., 0.5\. Write down
    the error message.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个超出资源配额要求限制的新 Pod，例如定义了1Gi的内存但保持低于CPU，例如0.5。记录下错误消息。
- en: Change the request limits to fulfill the requirements to ensure that the Pod
    can be created successfully. Write down the output of the command that renders
    the used amount of resources for the namespace.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更改请求限制以满足要求，以确保成功创建 Pod。记录下命令的输出，显示名称空间中使用的资源量。
- en: A LimitRange can restrict resource consumption for Pods in a namespace, and
    assign default computing resources if no resource requirements have been defined.
    You will practice the effects of a LimitRange on the creation of a Pod in different
    scenarios.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LimitRange 可以限制名称空间中 Pod 的资源消耗，并在未定义资源需求时分配默认的计算资源。你将练习 LimitRange 在不同场景下对 Pod
    创建的影响。
- en: Navigate to the directory *app-a/ch18/limitrange* of the checked-out GitHub
    repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    Inspect the YAML manifest definition in the file *setup.yaml*. Create the objects
    from the YAML manifest file.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转到 GitHub 仓库 *bmuschko/ckad-study-guide* 中的目录 *app-a/ch18/limitrange*。检查文件 *setup.yaml*
    中 YAML 清单的定义。从 YAML 清单文件创建对象。
- en: Create a new Pod named `pod-without-resource-requirements` in the namespace
    `d92` that uses the container image `nginx:1.23.4-alpine` without any resource
    requirements. Inspect the Pod details. What resource definitions do you expect
    to be assigned?
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在名称空间`d92`中创建一个名为`pod-without-resource-requirements`的新 Pod，使用容器镜像`nginx:1.23.4-alpine`，没有任何资源要求。检查
    Pod 的详细信息。你期望分配哪些资源定义？
- en: Create a new Pod named `pod-with-more-cpu-resource-requirements` in the namespace
    `d92` that uses the container image `nginx:1.23.4-alpine` with a CPU resource
    request of 400m and limits of 1.5\. What runtime behavior do you expect to see?
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在名称空间`d92`中创建一个名为`pod-with-more-cpu-resource-requirements`的新 Pod，使用容器镜像`nginx:1.23.4-alpine`，CPU
    资源请求为400m，限制为1.5。你期望看到什么运行时行为？
- en: Create a new Pod named `pod-with-less-cpu-resource-requirements` in the namespace
    `d92` that uses the container image `nginx:1.23.4-alpine` with a CPU resource
    request of 350m and limits of 400m. What runtime behavior do you expect to see?
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在名称空间`d92`中创建一个名为`pod-with-less-cpu-resource-requirements`的新 Pod，使用容器镜像`nginx:1.23.4-alpine`，CPU
    资源请求为350m，限制为400m。你期望看到什么运行时行为？
