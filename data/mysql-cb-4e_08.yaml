- en: Chapter 8\. Working with Dates and Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 8.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL has several data types for representing dates and times, and many functions
    for operating on them. MySQL stores dates and times in specific formats, and it’s
    important to understand them to avoid surprises in results from manipulating temporal
    data. This chapter covers the following aspects of working with date and time
    values in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a temporal data type
  prefs: []
  type: TYPE_NORMAL
- en: MySQL provides several temporal data types to choose from when you create tables.
    Knowing their properties enables you to choose them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying dates and times
  prefs: []
  type: TYPE_NORMAL
- en: MySQL displays temporal values using specific formats by default. You can produce
    other formats by using the appropriate functions.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the client time zone
  prefs: []
  type: TYPE_NORMAL
- en: The server interprets `TIMESTAMP` and `DATETIME`values in the client’s current
    time zone, not its own. Clients in different time zones should set their zone
    so that the server can properly interpret `TIMESTAMP` values for them.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the current date and time
  prefs: []
  type: TYPE_NORMAL
- en: MySQL provides functions that return the date and time. These are useful for
    applications that must know these values or need to calculate other temporal values
    in relation to them.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking row modification times
  prefs: []
  type: TYPE_NORMAL
- en: The `TIMESTAMP` and `DATETIME` data types have special properties that enable
    you to record row-creation and last-modification times automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking dates and times into component values, creating dates and times from
    component values
  prefs: []
  type: TYPE_NORMAL
- en: You can split date and time values when you need only a component, such as the
    month part of a date or the hour part of a time. Conversely, you can combine component
    values to synthesize dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between dates or times and basic units
  prefs: []
  type: TYPE_NORMAL
- en: Some temporal calculations such as date arithmetic operations are more easily
    performed using the number of days or seconds represented by a date or time value
    than by using the value itself. MySQL can perform conversions between date and
    time values and more basic units such as days or seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time arithmetic
  prefs: []
  type: TYPE_NORMAL
- en: You can add or subtract temporal values to produce other temporal values or
    calculate intervals between values. Applications include age determination, relative
    date computation, and date shifting.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting data based on temporal constraints
  prefs: []
  type: TYPE_NORMAL
- en: The calculations discussed in the preceding sections to produce output values
    can also be used in `WHERE` clauses to specify how to select rows using temporal
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers several MySQL functions for operating on date and time values,
    but there are many others. To familiarize yourself with the full set, consult
    the [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html).
    The variety of functions available to you means that it’s often possible to perform
    a given temporal calculation more than one way. We sometimes illustrate alternative
    methods for achieving a given result, and many of the problems addressed in this
    chapter can be solved in ways other than shown here. We invite you to experiment
    to find other solutions. You may find a method that’s more efficient or that you
    find more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts that implement recipes discussed in this chapter are located in the
    *dates* directory of the `recipes` source distribution. Scripts that create tables
    used here are located in the *tables* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Choosing a Temporal Data Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to store temporal data but aren’t sure which is the most appropriate
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choose the data type according to the characteristics of the information to
    be stored and how you need to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To choose a temporal data type, consider questions such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need times only, dates only, or combined date and time values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What range of values do you require?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want automatic initialization of the column to the current date and time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL provides `DATE` and `TIME` data types for representing date and time
    values separately, and `DATETIME` and `TIMESTAMP` types for combined date-and-time
    values. These values have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DATE` values have *`YYYY-MM-DD`* format, where *`YY`*, *`MM`*, and *`DD`*
    represent the year, month, and day parts of the date. The supported range for
    `DATE` values is `1000-01-01` to `9999-12-31`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME` values have *`hh:mm:ss`* format, where *`hh`*, *`mm`*, and *`ss`* are
    the hours, minutes, and seconds parts of the time. `TIME` values often can be
    thought of as time-of-day values, but MySQL actually treats them as elapsed time.
    Thus, they may be greater than `23:59:59` or even negative. (The actual range
    of a `TIME` column is `-838:59:59` to `838:59:59`.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATETIME` and `TIMESTAMP` are combined date-and-time values in *`YYYY-MM-DD`*
    *`hh:mm:ss`* format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DATETIME` and `TIMESTAMP` data types are similar in many respects, but
    watch out for these differences:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DATETIME` has a supported range of `1000-01-01 00:00:00` to `9999-12-31 23:59:59`,
    whereas `TIMESTAMP` values are valid only from the year 1970 partially through
    2038.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMESTAMP` and `DATETIME` have special auto-initialization and auto-update
    properties (see [Recipe 8.8](#nch-dates-dates-automatic)), but for `DATETIME`
    they are not available before MySQL 5.6.5.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a client inserts a `TIMESTAMP` value, the server converts it from the time
    zone associated with the client session to UTC and stores the UTC value. When
    the client retrieves a `TIMESTAMP` value, the server performs the reverse operation
    to convert the UTC value back to the client session time zone. A client in a time
    zone different from the server can configure its session so that this conversion
    is appropriate for its own time zone (see [Recipe 8.4](#nch-dates-dates-client-time-zone)).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Types that include a time part can have a fractional seconds part for subsecond
    resolution (see [Recipe 8.2](#nch-dates-fractional-seconds)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the examples in this chapter draw on the following tables, which contain
    columns representing time, date, and date-and-time values. (The `time_val` table
    has two columns for use in time interval calculation examples.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is a good idea to create the `time_val`, `date_val`, and `datetime_val` tables
    right now before reading further. (Use the appropriate scripts in the *tables*
    directory of the `recipes` distribution.)
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Using Fractional Seconds Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application requires subsecond resolution of time values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Specify fractional seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of MySQL 5.6.4, fractional seconds are supported for temporal types that
    include a time part: `DATETIME`, `TIME`, and `TIMESTAMP`. For applications that
    require subsecond resolution of time values, this enables you to specify fractional
    seconds precision down to the microsecond level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default is to have no fractional seconds part, so to include it for temporal
    types that support this capability, specify it explicitly in the column declaration:
    include `(`*`fsp`*`)` after the data type name in a column definition. *`fsp`*
    can be from 0 to 6 to indicate the number of fractional digits. 0 means <q>none</q>
    (resolution to seconds), 6 means resolution to microseconds. For example, to create
    a `TIME` column with two fractional digits (resolution to hundredths of a second),
    use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A precision timing is crucial for specific events such as races. One of the
    most popular and time-sensitive event is Formula 1 races worldwide. Time tracking
    for the fastest motorsport requires detailed timekeeping and technology. In short,
    the necessary time to be tracked is within ten thousand of a second by using multiple
    transponders.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. FORMULA 1 ROLEX TURKISH GRAND PRIX 2021 - RACE RESULT
  prefs: []
  type: TYPE_NORMAL
- en: '| Driver | Car | Time |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Max Verstappen | RED BULL RACING HONDA | `1:17.301` |'
  prefs: []
  type: TYPE_TB
- en: '| Valtteri Bottas | MERCEDES | `1:17.725` |'
  prefs: []
  type: TYPE_TB
- en: '| Lewis Hamilton | MERCEDES | `1:17.810` |'
  prefs: []
  type: TYPE_TB
- en: 'Temporal functions that return current time or date-and-time values also support
    fractional seconds. The default without an argument is no fractional part. Otherwise,
    the argument specifies the desired resolution. Permitted values are 0 to 6, the
    same as when declaring temporal columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order to better demonstrate we will take example of having Formula 1 race
    standings from one of the latest races held in Turkey ([Table 8-1](#nch-dates-fractional-seconds-formula1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to get proper listing of this time gaps between the driver performance
    we will use a CTE. We will be discussing CTEs (Common Table Expressions) in [Recipe
    10.18](ch10.xhtml#nch-sum-sum-with). Here is the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 8.3 Changing MySQL’s Date Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to change the ISO format that MySQL uses for representing date values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can’t. However, you can rewrite non-ISO input values into ISO format when
    storing dates, and you can rewrite ISO values to other formats for display with
    the `DATE_FORMAT()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *`YYYY-MM-DD`* format that MySQL uses for `DATE` values follows the ISO
    8601 standard for representing dates. Because the year, month, and day parts have
    a fixed length and appear left to right in date strings, this format has the useful
    property that dates sort naturally into the proper temporal order. [Recipe 9.5](ch09.xhtml#nch-sort-sort-date)
    and [Recipe 10.15](ch10.xhtml#nch-sum-sum-date) discuss ordering and grouping
    techniques for date-based values.
  prefs: []
  type: TYPE_NORMAL
- en: ISO format, although common, is not used by all database systems, which can
    cause problems if you move data between different systems. Moreover, people commonly
    like to represent dates in other formats such as *`MM/DD/YY`* or *`DD-MM-YYYY`*.
    This too can be a source of trouble, due to mismatches between human expectations
    of how dates should look and how MySQL actually represents them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A question frequently asked by newcomers to MySQL is, <q>How do I tell MySQL
    to store dates in a specific format such as *`MM/DD/YYYY`*?</q> That’s the wrong
    question. Instead, ask, <q>If I have a date in a specific format, how can I store
    it in MySQL’s supported format, and vice versa?</q> MySQL always stores dates
    in ISO format, a fact with implications both for data entry (input) and for displaying
    query results (output):'
  prefs: []
  type: TYPE_NORMAL
- en: For data-entry purposes, to store values that are not in ISO format, you normally
    must rewrite them first. If you don’t want to rewrite them, you can store them
    as strings (for example, in a `CHAR` column). But then you can’t operate on them
    as dates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.xhtml#nch-xfer) covers the topic of date rewriting for data
    entry, and [Chapter 14](ch14.xhtml#nch-format) discusses checking dates to verify
    that they’re valid. In some cases, if your values are close to ISO format, rewriting
    may not be necessary. For example, MySQL interprets the string values `87-1-7`
    and `1987-1-7` and the numbers `870107` and `19870107` as the date `1987-01-07`
    when storing them into a `DATE` column.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For display purposes, you can rewrite dates to non-ISO formats. The `DATE_FORMAT()`
    function provides a lot of flexibility for changing date values into other formats
    (see later in this section). You can also use functions such as `YEAR()` to extract
    parts of dates for display (see [Recipe 8.9](#nch-dates-dates-decomp)). For additional
    discussion, see [Recipe 14.17](ch14.xhtml#nch-format-format-date-export).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way to rewrite non-ISO values for date entry is to use the `STR_TO_DATE()`
    function, which takes a string representing a temporal value and a format string
    that specifies the <q>syntax</q> of the value. Within the formatting string, use
    special sequences of the form `%`*`c`*, where *`c`* specifies which part of the
    date to expect. For example, `%Y`, `%M`, and `%d` signify the four-digit year,
    the month name, and the two-digit day of the month. To insert the value `May`
    `13,` `2007` into a `DATE` column, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For date display, MySQL uses ISO format (*`YYYY-MM-DD`*) unless you tell it
    otherwise. To display dates or times in other formats, use the `DATE_FORMAT()`
    or `TIME_FORMAT()` function to rewrite them. If you require a more specialized
    format those functions cannot provide, write a stored function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DATE_FORMAT()` function takes two arguments: a `DATE`, `DATETIME`, or
    `TIMESTAMP` value, and a string describing how to display the value. The format
    string uses the same kind of specifiers as `STR_TO_DATE()`. The following statement
    shows the values in the `date_val` table, both as MySQL displays them by default
    and as reformatted with `DATE_FORMAT()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `DATE_FORMAT()` produces long column headings, it’s often useful to
    provide an alias (see [Recipe 5.2](ch05.xhtml#nch-select-select-column-alias))
    to make a heading more concise or meaningful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html).
    provides a complete list of format sequences to use with `DATE_FORMAT()`, `TIME_FORMAT()`,
    and `STR_TO_DATE()`. The [Table 8-2](#nch-dates-dates-format-syntax) shows some
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Format sequences to use with date and time formatting functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Sequence | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Four-digit year |'
  prefs: []
  type: TYPE_TB
- en: '| `%y` | Two-digit year |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Complete month name |'
  prefs: []
  type: TYPE_TB
- en: '| `%b` | Month name, initial three letters |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Two-digit month of year (01..12) |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | Month of year (1..12) |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Two-digit day of month (01..31) |'
  prefs: []
  type: TYPE_TB
- en: '| `%e` | Day of month (1..31) |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | Weekday name (Sunday..Saturday) |'
  prefs: []
  type: TYPE_TB
- en: '| `%r` | 12-hour time with AM or PM suffix |'
  prefs: []
  type: TYPE_TB
- en: '| `%T` | 24-hour time |'
  prefs: []
  type: TYPE_TB
- en: '| `%H` | Two-digit hour |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` | Two-digit minute |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | Two-digit second |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Six-digit microsecond |'
  prefs: []
  type: TYPE_TB
- en: '| `%%` | Literal `%` |'
  prefs: []
  type: TYPE_TB
- en: 'The time-related format sequences shown in the table are useful only when you
    pass `DATE_FORMAT()` a value that has both date and time parts (a `DATETIME` or
    `TIMESTAMP`). The following statement displays `DATETIME` values from the `datetime_val`
    table using formats that include the time of day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`TIME_FORMAT()` is similar to `DATE_FORMAT()`. It works with `TIME`, `DATETIME`,
    or `TIMESTAMP` values, but understands only time-related specifiers in the format
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DATE_FORMAT()` or `TIME_FORMAT()` cannot produce the results that you want,
    write a stored function that does. Suppose that you want to convert 24-hour `TIME`
    values to 12-hour format but with a suffix of `a.m.` or `p.m.` rather than `AM`
    or `PM`. The following function accomplishes that task. It uses `TIME_FORMAT()`
    to do most of the work, then strips the suffix supplied by `%r` and replaces it
    with the desired suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For more information about writing stored functions, see [Chapter 11](ch11.xhtml#nch-routines).
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Setting the Client Time Zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a client application that connects from a time zone different from
    the server. Consequently, when it stores `TIMESTAMP` values, they don’t have the
    correct UTC values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client should set the `time_zone` system variable after connecting to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Time zone settings have an important effect on `TIMESTAMP` values:'
  prefs: []
  type: TYPE_NORMAL
- en: When the MySQL server starts, it examines its operating environment to determine
    its time zone. (To use a different value, start the server with the `--default-time-zone`
    option.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each client that connects, the server interprets `TIMESTAMP` values with
    respect to the time zone associated with the client session. When a client inserts
    a `TIMESTAMP` value, the server converts it from the client time zone to UTC and
    stores the UTC value. (Internally, the server stores a `TIMESTAMP` value as the
    number of seconds since `1970-01-01` `00:00:00` UTC.) When the client retrieves
    a `TIMESTAMP` value, the server performs the reverse operation to convert the
    UTC value back to the client time zone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default session time zone for each client when it connects is the server
    time zone. If all clients are in the same time zone as the server, nothing special
    need be done for proper `TIMESTAMP` time zone conversion to occur. But if a client
    is in a time zone different from the server and it inserts `TIMESTAMP` values
    without making the proper time zone correction, the UTC values won’t be correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that the server and client C1 are in the same time zone, and client
    C1 issues these statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, client C1 sees the same value that it stored. A different client, C2,
    will also see the same value if it retrieves it, but if client C2 is in a different
    time zone, that value isn’t correct for its zone. Conversely, if client C2 stores
    a value, that value when returned by client C1 won’t be correct for the client
    C1 time zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with this problem so that `TIMESTAMP` conversions use the proper time
    zone, a client should set its time zone explicitly by setting the session value
    of the `time_zone` system variable. Suppose that the server has a global time
    zone of six hours ahead of UTC. Each client initially is assigned that same value
    as its session time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When client C2 connects, it sees the same `TIMESTAMP` value as client C1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But that value is incorrect if client C2 is only four hours ahead of UTC. C2
    should set its time zone after connecting so that retrieved `TIMESTAMP` values
    are properly adjusted for its own session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To see the `System Timezone` check global variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The client time zone also affects the values displayed from functions that return
    the current date and time (see [Recipe 8.7](#nch-dates-dates-current)).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To convert individual date-and-time values from one time zone to another, use
    the `CONVERT_TZ()` function (see [Recipe 8.6](#nch-dates-dates-time-zone-convert)).
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Setting the Server Time Zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a localized application to serve customers, but you want to have a
    global time zone setting.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server should set the `time_zone` system variable to `SYSTEM` at the server.
    This setting should point to `UTC` value. Accordingly system timezone `system_time_zone`
    value should be set to `UTC`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL Server maintains several time zone settings:'
  prefs: []
  type: TYPE_NORMAL
- en: The server system time zone. When MySQL starts it attempts to determine `system_time_zone`
    variable. In order to explicitly set the system time zone for MySQL set the `TZ`
    environment variable before starting `mysqld`. Alternatively start the `mysqld_safe`
    with its `--timezone` option. The values for these variables are permissible by
    your operating system settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server current time zone is set by the global `time_zone` value. It’s generally
    set to `SYSTEM` on modern Linux operating systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may choose to set the global timezone variable using `SET GLOBAL` This will
    not change the `@@session.time_zone` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The string indicating the `time_zone` value offset from UTC (Universal Coordinated
    Time). Prior to MySQL 8.0.19, this value had to be in the range ''-12:59’ to ''+13:00'',
    inclusive; beginning with MySQL 8.0.19, the permitted range is ''-13:59’ to ''+14:00'',
    inclusive. Populated time zones are not permitted unless they are pre-loaded to
    MySQL tables hence you can not use names like `UTC`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For instructions on Populating the Timezone Tables see [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html#time-zone-installation).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `system_time_zone` variable is set when the server inherits a time zone
    setting from the machine defaults. Unlike the `time_zone` variable this is not
    dynamic to set after the server starts. As of MySQL 8.0.26 if the server host
    time zone changes such as during daylight saving time `system_time_zone` will
    reflect the change. If a change happens during execution of a query the previous
    value will be cached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 8.6 Shifting Temporal Values Between Time Zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a date-and-time value, but need to know what it would be in a different
    time zone. For example, you’re having a teleconference with people in different
    parts of the world and you must tell them the meeting time in their local time
    zones.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `CONVERT_TZ()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CONVERT_TZ()` function converts temporal values between time zones. It
    takes three arguments: a date-and-time value and two time zone indicators. The
    function interprets the date-and-time value as a value in the first time zone
    and returns the value shifted into the second time zone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we live in Chicago, Illinois in the US, and that we have a meeting
    with people in several other parts of the world. The [Table 8-3](#nch-dates-dates-time-zone-convert-meeting)
    shows the location of each meeting participant and the time zone name for each:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. Meeting participants
  prefs: []
  type: TYPE_NORMAL
- en: '| Location | Time zone name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Chicago, Illinois, US | `US/Central` |'
  prefs: []
  type: TYPE_TB
- en: '| Istanbul, Turkey | `Europe/Istanbul` |'
  prefs: []
  type: TYPE_TB
- en: '| London, United Kingdom | `Europe/London` |'
  prefs: []
  type: TYPE_TB
- en: '| Edmonton, Alberta, Canada | `America/Edmonton` |'
  prefs: []
  type: TYPE_TB
- en: '| Brisbane, Australia | `Australia/Brisbane` |'
  prefs: []
  type: TYPE_TB
- en: 'If the meeting is to take place at 8 AM local time for us on November 28, 2021,
    what time will that be for the other participants? The following statement uses
    `CONVERT_TZ()` to calculate the local times for each time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let’s hope the Brisbane participant doesn’t mind being up after midnight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example uses time zone names, so it requires that you have the
    time zone tables in the `mysql` database initialized with support for named time
    zones. (See the [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html)
    for information about setting up the time zone tables.) If you can’t use named
    time zones, specify them in terms of their numeric relationship to UTC. (This
    can be a little trickier; you might need to account for daylight saving time.)
    The corresponding statement with numeric time zones looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 8.7 Determining the Current Date or Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know what today’s date isand/or what time it is.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `CURDATE()`, `CURTIME()`, or `NOW()` functions to obtain values expressed
    in the client session time zone. Use `UTC_DATE()`, `UTC_TIME()`, or `UTC_TIMESTAMP()`
    for values in UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications must know the current date or time, such as those that write
    timestamped log records. This kind of information is also useful for date calculations
    performed in relation to the current date, such as finding the first (or last)
    day of the month, or determining the date for Wednesday of next week.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CURDATE()` and `CURTIME()` functions return the current date and time
    separately, and `NOW()` returns both as a combined date-and-time value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`CURRENT_DATE`, `CURRENT_TIME`, and `CURRENT_TIMESTAMP` are synonyms for `CURDATE()`,
    `CURTIME()`, and `NOW()`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding functions return values in the client session time zone (see [Recipe
    8.4](#nch-dates-dates-client-time-zone)). For values in UTC time, use the `UTC_DATE()`,
    `UTC_TIME()`, or `UTC_TIMESTAMP()` functions instead.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the current date and time for an arbitrary time zone, pass the
    value of the appropriate UTC function to `CONVERT_TZ()` (see [Recipe 8.6](#nch-dates-dates-time-zone-convert)).
  prefs: []
  type: TYPE_NORMAL
- en: To obtain subparts of these values, such as the current day of the month or
    current hour of the day, use the decomposition techniques discussed in [Recipe
    8.9](#nch-dates-dates-decomp).
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Using TIMESTAMP or DATETIME to Track Row-Modification Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to record row-creation time or last modification time automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the auto-initialization and auto-update properties of the `TIMESTAMP` and
    `DATETIME` data types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL supports `TIMESTAMP` and `DATETIME` data types that store date-and-time
    values. [Recipe 8.1](#nch-dates-dates-types) covers the range of values for these
    types. This recipe focuses on special column attributes that enable you to track
    row-creation and -update times automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: A `TIMESTAMP` or `DATETIME` column declared with the `DEFAULT` `CURRENT_TIMESTAMP`
    attribute initializes automatically for new rows. Simply omit the column from
    `INSERT` statements and MySQL sets it to the row-creation time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TIMESTAMP` or `DATETIME` column declared with the `ON` `UPDATE` `CURRENT_TIMESTAMP`
    attribute automatically updates to the current date and time when you change any
    other column in the row from its current value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These special properties make the `TIMESTAMP` and `DATETIME` data types particularly
    suited for applications that require recording the times at which rows are inserted
    or updated. The following discussion shows how to take advantage of these properties
    using `TIMESTAMP` columns. With some differences to be noted later, the discussion
    also applies to `DATETIME` columns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default `SQL_MODE` does not allow `NULL` values unless relaxed. Also `NO_ZERO_DATE`
    deprecated as of MySQL 8.0 should be used in conjunction with `STRICT MODE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example table looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TIMESTAMP` columns have these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ts_both` auto-initializes and auto-updates. This is useful for tracking the
    time of any change to a row, for both inserts and updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts_create` auto-initializes only. This is useful when you want a column to
    be set to the time at which a row is created, but remain constant thereafter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts_update` auto-updates only. It is set to the column default (or value you
    specify explicitly) at row-creation time and it auto-updates for changes to the
    row thereafter. The use cases for this are more limited—for example, to track
    row-creation and last-modification times separately (using `ts_update` in conjunction
    with `ts_create`), rather than together in a single column like `ts_both`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see how the table works, insert some rows into the table (a few seconds
    apart so the timestamps differ), then select its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first two `INSERT` statements shows that you can set the auto-initialize
    columns to the current date and time by omitting them from the `INSERT` statement
    entirely. The third insert shows that you can set a `TIMESTAMP` column to the
    current date and time by setting it explicitly to `NULL`, even one that does not
    auto-initialize. This `NULL`-assignment behavior is not specific to `INSERT` statements;
    it works for `UPDATE` as well. You can disable this special handling of `NULL`
    assignments, as we’ll cover later in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see auto-updating in action, issue a statement that changes one row’s `val`
    column and check its effect on the table’s contents. The result shows that the
    auto-update columns are updated (in the modified row only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you modify multiple rows, updates occur for the auto-update columns in each
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'An `UPDATE` statement that doesn’t actually change any value in a row doesn’t
    modify auto-update columns. To see this, set every row’s `val` column to its current
    value, then review the table contents to see that auto-update columns retain their
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As stated previously, automatic `TIMESTAMP` properties also apply to `DATETIME`,
    with some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first `TIMESTAMP` column in a table, if neither of the `DEFAULT` or
    `ON` `UPDATE` attributes are specified, the column is implicitly defined with
    both. For `DATETIME`, automatic properties never apply implicitly; only those
    specified explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to set `NULL` to `TIMESTAMP` anymore. To assign the current
    timestamp, set the column to `CURRENT_TIMESTAMP` or a synonym such as `NOW()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To determine for any given `TIMESTAMP` column what happens when `NULL` is assigned
    to it, use `SHOW` `CREATE` `TABLE` to see the column definition. If the definition
    includes the `NULL` attribute, assigning `NULL` stores `NULL`. If the definition
    includes the `NOT` `NULL` attribute, you can specify `NULL` as the value to be
    assigned, but you cannot *store* `NULL` because MySQL stores the current date
    and time instead.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simulate `TIMESTAMP` auto-initialization and auto-update properties for other
    temporal types, you can use triggers (see [Chapter 11](ch11.xhtml#nch-routines)).
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 Extracting Parts of Dates or Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to obtain just a part of a date or a time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Invoke a function specifically intended for extracting part of a temporal value,
    such as `MONTH()` or `MINUTE()`. This is usually the fastest method for component
    extraction if you need only a single component of a value. Alternatively, use
    a formatting function such as `DATE_FORMAT()` or `TIME_FORMAT()` with a format
    string that includes a specifier for the part of the value you want to obtain.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following discussion shows different ways to extract parts of temporal values.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing dates or times using component-extraction functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL includes many functions for extracting date and time subparts. For example,
    `DATE()` and `TIME()` extract the date and time components of temporal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The [Table 8-4](#nch-dates-dates-decomp-extract) shows some several component-extraction
    functions; consult the [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)
    for a complete list. The date-related functions work with `DATE`, `DATETIME`,
    or `TIMESTAMP` values. The time-related functions work with `TIME`, `DATETIME`,
    or `TIMESTAMP` values:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-4\. Component-extraction functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Return value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `YEAR()` | Year of date |'
  prefs: []
  type: TYPE_TB
- en: '| `MONTH()` | Month number (1..12) |'
  prefs: []
  type: TYPE_TB
- en: '| `MONTHNAME()` | Month name (January..December) |'
  prefs: []
  type: TYPE_TB
- en: '| `DAYOFMONTH()` | Day of month (1..31) |'
  prefs: []
  type: TYPE_TB
- en: '| `DAYNAME()` | Day name (Sunday..Saturday) |'
  prefs: []
  type: TYPE_TB
- en: '| `DAYOFWEEK()` | Day of week (1..7 for Sunday..Saturday) |'
  prefs: []
  type: TYPE_TB
- en: '| `WEEKDAY()` | Day of week (0..6 for Monday..Sunday) |'
  prefs: []
  type: TYPE_TB
- en: '| `DAYOFYEAR()` | Day of year (1..366) |'
  prefs: []
  type: TYPE_TB
- en: '| `HOUR()` | Hour of time (0..23) |'
  prefs: []
  type: TYPE_TB
- en: '| `MINUTE()` | Minute of time (0..59) |'
  prefs: []
  type: TYPE_TB
- en: '| `SECOND()` | Second of time (0..59) |'
  prefs: []
  type: TYPE_TB
- en: '| `MICROSECOND()` | Microsecond of time (0..59) |'
  prefs: []
  type: TYPE_TB
- en: '| `EXTRACT()` | Varies |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions such as `YEAR()` or `DAYOFMONTH()` extract values that have an obvious
    correspondence to a substring of the temporal value to which you apply them. Other
    component-extraction functions provide access to values that have no such correspondence.
    One is the day-of-year value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Another is the day of the week, which is available by name or number:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DAYNAME()` returns the complete day name. There is a `DATE_FORMAT(d, ''%a'')`
    function for returning the three-character name abbreviation, that you can get
    it easily by passing the full name to `DATE_FORMAT()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the day of the week as a number, use `DAYOFWEEK()` or `WEEKDAY()`, but
    pay attention to the range of values each function returns. `DAYOFWEEK()` returns
    values from 1 to 7, corresponding to Sunday through Saturday. `WEEKDAY()` returns
    values from 0 to 6, corresponding to Monday through Sunday:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`EXTRACT()` is another function for obtaining individual parts of temporal
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The keyword indicating what to extract from the value should be a unit specifier
    such as `YEAR`, `MONTH`, `DAY`, `HOUR`, `MINUTE`, or `SECOND`. Unit specifiers
    are singular, not plural. (Check the [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)
    for the full list.)
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing dates or times using formatting functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `DATE_FORMAT()` and `TIME_FORMAT()` functions reformat date and time values.
    By specifying appropriate format strings, you can extract individual parts of
    temporal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Formatting functions are advantageous when you want to extract more than one
    part of a value, or display extracted values in a format different from the default.
    For example, to extract the entire date or time from `DATETIME` values, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To present a date in other than *`YYYY-MM-DD`* format or a time without the
    seconds part, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 8.10 Synthesizing Dates or Times from Component Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to combine the parts of a date or time to produce a complete date or
    time value. Or you want to replace parts of a date to produce another date.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have several options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `MAKETIME()` to construct a `TIME` value from hour, minute, and second parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `DATE_FORMAT()` or `TIME_FORMAT()` to combine parts of the existing value
    with parts you want to replace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pull out the parts that you need with component-extraction functions and recombine
    the parts with `CONCAT()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reverse of splitting a date or time value into components is synthesizing
    a temporal value from its constituent parts. Techniques for date and time synthesis
    include using composition functions, formatting functions, and string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MAKETIME()` function takes component hour, minute, and second values as
    arguments and combines them to produce a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Date synthesis often is performed beginning with a given date, then keeping
    parts that you want to use and replacing the rest. For example, to produce the
    first day of the month in which a date falls, use `DATE_FORMAT()` to extract the
    year and month parts from the date, combining them with a day part of `01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`TIME_FORMAT()` can be used similarly. The following example produces time
    values that have the seconds part set to `00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to construct temporal values is to use date-part extraction functions
    in conjunction with `CONCAT()`. However, this method often is messier than the
    `DATE_FORMAT()` technique just discussed, and it sometimes yields slightly different
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the month values in some of these dates have only a single digit.
    To ensure that the month has two digits—as required for ISO format—use `LPAD()`
    to add a leading zero as necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[Recipe 8.18](#nch-dates-dates-canonize) shows other ways to solve the problem
    of producing ISO dates from not-quite-ISO dates.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TIME` values can be produced from hours, minutes, and seconds values using
    methods analogous to those for creating `DATE` values. For example, to change
    a `TIME` value so that its seconds part is `00`, extract the hour and minute parts,
    and then recombine them with `CONCAT()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce a combined date-and-time value from separate date and time values,
    simply concatenate them separated by a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 8.11 Converting Between Temporal Values and Basic Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert a temporal value such as a time or date to basic units such
    as seconds or days. This is often useful or necessary for performing temporal
    arithmetic operations (see [Recipe 8.12](#nch-dates-dates-calc-difference) and
    [Recipe 8.13](#nch-dates-dates-calc-sum)).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conversion method depends on the type of value to be converted:'
  prefs: []
  type: TYPE_NORMAL
- en: To convert between time values and seconds, use the `TIME_TO_SEC()` and `SEC_TO_TIME()`
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert between date values and days, use the `TO_DAYS()` and `FROM_DAYS()`
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert between date-and-time values and seconds, use the `UNIX_TIMESTAMP()`
    and `FROM_UNIXTIME()` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following discussion shows how to convert several types of temporal values
    to basic units and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between times and seconds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TIME` values are specialized representations of a simpler unit (seconds).
    To convert from one to the other, use the `TIME_TO_SEC()` and `SEC_TO_TIME()`
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TIME_TO_SEC()` converts a `TIME` value to the equivalent number of seconds,
    and `SEC_TO_TIME()` does the opposite. The following statement demonstrates a
    simple conversion in both directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To express time values as minutes, hours, or days, perform the appropriate
    divisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Use `FLOOR()` on the division results if you prefer integer values that have
    no fractional part.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass `TIME_TO_SEC()` a date-and-time value, it extracts the time part
    and discards the date. This provides another means of extracting times from `DATETIME`
    (or `TIMESTAMP`) values, in addition to those already discussed in [Recipe 8.9](#nch-dates-dates-decomp):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Converting between dates and days
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a date but want a value in days, or vice versa, use the `TO_DAYS()`
    and `FROM_DAYS()` functions. Date-and-time values also can be converted to days
    if you can suffer loss of the time part since the year 0.
  prefs: []
  type: TYPE_NORMAL
- en: '`TO_DAYS()` converts a date to the corresponding number of days, and `FROM_DAYS()`
    does the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When using `TO_DAYS()`, it’s best to stick to the advice of the [MySQL Reference
    Manual](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)
    and avoid `DATE` values that occur before the beginning of the Gregorian calendar
    (1582). Changes in the lengths of calendar years and months prior to that date
    make it difficult to speak meaningfully of what the value of <q>day 0</q> might
    be. This differs from `TIME_TO_SEC()`, where the correspondence between a `TIME`
    value and the resulting seconds value is obvious and has a meaningful reference
    point of 0 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass `TO_DAYS()` a date-and-time value, it extracts the date part and
    discards the time. This provides another means of extracting dates from `DATETIME`
    (or `TIMESTAMP`) values, in addition to those already discussed in [Recipe 8.9](#nch-dates-dates-decomp):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Converting between date-and-time values and seconds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For `DATETIME` or `TIMESTAMP` values that lie within the range of the `TIMESTAMP`
    data type (from the beginning of 1970 partially through 2038), the `UNIX_TIMESTAMP()`
    and `FROM_UNIXTIME()` functions convert to and from the number of seconds elapsed
    since the beginning of 1970\. The conversion to seconds offers higher precision
    for date-and-time values than a conversion to days, at the cost of a more limited
    range of values for which the conversion may be performed (`TIME_TO_SEC()` is
    unsuitable for this because it discards the date):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a relationship between <q>UNIX</q> in the function names and the fact
    that the applicable range of values begins with 1970: the <q>Unix epoch</q> begins
    at `1970-01-01` `00:00:00` UTC. The epoch is time zero, or the reference point
    for measuring time in Unix systems. That being so, you may find it curious that
    the preceding example shows a `UNIX_TIMESTAMP()` value of `21600` for the first
    value in the `datetime_val` table. Why isn’t it `0`? The apparent discrepancy
    is due to the fact that the MySQL server interprets the `UNIX_TIMESTAMP()` argument
    as a value in the client’s local time zone and converts it to UTC (see [Recipe
    8.4](#nch-dates-dates-client-time-zone)). Our server is in the US Central time
    zone, six hours (21,600 seconds) west of UTC. The `DATETIME` interpreted based
    on the time zone and the numbers would not change with a timestamp. Change the
    session time zone to `''+00:00''` for UTC time and run the query again to observe
    a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`UNIX_TIMESTAMP()` can convert `DATE` values to seconds, too. It treats such
    values as having an implicit time-of-day part of `00:00:00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 8.12 Calculating Intervals Between Dates or Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know how long it is between two dates or times; that is, the interval
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To calculate an interval, use one of the temporal-difference functions, or convert
    your values to basic units and take the difference. The permitted functions depend
    on the types of the values for which you want to know the interval.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following discussion shows several ways to perform interval calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating intervals with temporal-difference functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To calculate an interval in days between two date values, use the `DATEDIFF()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`DATEDIFF()` also works with date-and-time values, but ignores the time part.
    This makes it suitable for producing day intervals for `DATE`, `DATETIME`, or
    `TIMESTAMP` values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate an interval between `TIME` values as another `TIME` value, use
    the `TIMEDIFF()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`TIMEDIFF()` also works for date-and-time values. That is, it accepts either
    time or date-and-time values, but the types of the arguments must match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A time interval expressed as a `TIME` value can be broken down into components
    using the techniques shown in [Recipe 8.9](#nch-dates-dates-decomp). For example,
    to express a time interval in terms of its constituent hours, minutes, and seconds
    values, calculate time interval subparts using the `HOUR()`, `MINUTE()`, and `SECOND()`
    functions. (Don’t forget that if your intervals may be negative, you must take
    that into account.) The following SQL statement shows how to determine the components
    of the interval between the `t1` and `t2` columns of the `time_val` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you work with date or date-and-time values, the `TIMESTAMPDIFF()` function
    provides another way to calculate intervals. It enables you to specify the units
    in which intervals should be expressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*`unit`* is the interval unit and *`val1`* and *`val2`* are the values between
    which to calculate the interval. With `TIMESTAMPDIFF()`, you can express an interval
    in many different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Permitted *`unit`* specifiers are `MICROSECOND`, `SECOND`, `MINUTE`, `HOUR`,
    `DAY`, `WEEK`, `MONTH`, `QUARTER`, or `YEAR`. Note that each is singular, not
    plural.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware of these properties of `TIMESTAMPDIFF()`:'
  prefs: []
  type: TYPE_NORMAL
- en: Its value is negative if the first temporal value is greater than the second,
    which is opposite the order of the arguments for `DATEDIFF()` and `TIMEDIFF()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite the `TIMESTAMP` in its name, `TIMESTAMPDIFF()` arguments are not limited
    to the range of the `TIMESTAMP` data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time interval calculation using basic units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To calculate intervals in seconds between pairs of time values, convert them
    to seconds with `TIME_TO_SEC()` and take the difference. To express the resulting
    interval as a `TIME` value, pass it to `SEC_TO_TIME()`. The following statement
    calculates the intervals between the `t1` and `t2` columns of the `time_val` table,
    expressing each interval both in seconds and as a `TIME` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Date or date-and-time interval calculation using basic units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you calculate an interval between dates by converting both dates to a
    common unit in relation to a given reference point and take the difference, the
    range of your values determines which conversions are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DATE`, `DATETIME`, or `TIMESTAMP` values dating back to `1970-01-01` `00:00:00`
    UTC—the Unix epoch—can be converted to seconds elapsed since the epoch. With dates
    in that range, you can calculate intervals to an accuracy of one second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Older dates from the beginning of the Gregorian calendar (1582) on can be converted
    to day values and used to compute intervals in days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dates that begin earlier than either of these reference points present more
    of a problem. In such cases, you may find that your programming language offers
    computations that are not available or are difficult to perform in SQL. If so,
    consider processing date values directly from within your API language. For example,
    the Date::Calc and Date::Manip modules are available from CPAN for use in Perl
    scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To calculate an interval in days between date or date-and-time values, convert
    them to days with `TO_DAYS()` and take the difference. For an interval in weeks,
    do the same thing and divide the result by seven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You cannot convert days to months or years by simple division because those
    units vary in length. To yield date intervals expressed in those units, use `TIMESTAMPDIFF()`,
    discussed earlier in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'For date-and-time values occurring within the `TIMESTAMP` range from 1970 partially
    through 2038, you can determine intervals to a resolution in seconds using the
    `UNIX_TIMESTAMP()` function. For intervals in other units, seconds are easily
    converted to minutes, hours, days, or weeks, as this expression shows for dates
    that lie two weeks apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Use `FLOOR()` on the division results if you prefer integer values that have
    no fractional part.
  prefs: []
  type: TYPE_NORMAL
- en: 'For values that occur outside the `TIMESTAMP` range, this interval calculation
    method is more general (but messier):'
  prefs: []
  type: TYPE_NORMAL
- en: Take the difference in days between the date parts of the values and multiply
    by 24 × 60 × 60 to convert to seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the result by the difference in seconds between the time parts of the
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example, using two date-and-time values that lie slightly less than
    three days apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 8.13 Adding Date or Time Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add temporal values. For example, you want to add a given number
    of seconds to a time or determine what the date will be three weeks from today.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add date or time values, you have several options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use one of the temporal-addition functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `+` `INTERVAL` or `-` `INTERVAL` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the values to basic units, and take the sum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The applicable functions or operators depend on the types of the values.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following discussion shows several ways to add temporal values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding temporal values using temporal-addition functions or operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a time to a time or date-and-time value, use the `ADDTIME()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a time to a date or date-and-time value, use the `TIMESTAMP()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL also provides `DATE_ADD()` and `DATE_SUB()` functions for adding intervals
    to dates and subtracting intervals from dates. Each function takes a date (or
    date-and-time) value `d` and an interval, expressed using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `+` `INTERVAL` and `-` `INTERVAL` operators are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '*`unit`* is the interval unit and *`val`* is an expression indicating the number
    of units. Some common unit specifiers are `SECOND`, `MINUTE`, `HOUR`, `DAY`, `MONTH`,
    and `YEAR`. Note that each is singular, not plural. (Check the [MySQL Reference
    Manual](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)
    for the full list.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `DATE_ADD()` or `DATE_SUB()` to perform date arithmetic operations such
    as these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determine the date three days from today:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the date a week ago:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For questions where you need to know both the date and the time, begin with
    a `DATETIME` or `TIMESTAMP` value. To answer the question, <q>What time will it
    be in 60 hours?</q> do this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some interval specifiers have both date and time parts. The following adds
    14.5 hours to the current date and time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, adding 3 days and 4 hours produces this result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DATE_ADD()` and `DATE_SUB()` are interchangeable because one is the same as
    the other with the sign of the interval value flipped. These two expressions are
    equivalent for any date value `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `+` `INTERVAL` or `-` `INTERVAL` operator to perform date
    interval addition or subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`TIMESTAMPADD()` is an alternative function for adding intervals to date or
    date-and-time values. Its arguments are similar to those for `DATE_ADD()`, and
    the following equivalence holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Adding temporal values using basic units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to add intervals to date or date-and-time values is to perform temporal
    <q>shifting</q> via functions that convert to and from basic units. For background
    information about the applicable functions, see [Recipe 8.11](#nch-dates-dates-basic-units).
  prefs: []
  type: TYPE_NORMAL
- en: Adding time values using basic units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding times with basic units is similar to calculating intervals between times,
    except that you compute a sum rather than a difference. To add an interval value
    in seconds to a `TIME` value, convert the `TIME` to seconds so that both values
    are represented in the same units, add the values and convert the result back
    to a `TIME`. For example, two hours is 7,200 seconds (2 × 60 × 60), so the following
    statement adds two hours to each `t1` value in the `time_val` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If the interval itself is expressed as a `TIME`, it too should be converted
    to seconds before adding the values together. The following example calculates
    the sum of the two `TIME` values in each row of the `time_val` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to recognize that MySQL `TIME` values represent elapsed time,
    not time of day, so they don’t reset to 0 after reaching 24 hours. You can see
    this in the first and third output rows from the previous statement. To produce
    time-of-day values, enforce a 24-hour wraparound using a modulo operation before
    converting the seconds value back to a `TIME` value. The number of seconds in
    a day is 24 × 60 × 60, or 86,400\. To convert any seconds value `s` to lie within
    a 24-hour range, use the `MOD()` function or the `%` modulo operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The three expressions are equivalent. Applying the first of them to the time
    calculations from the preceding example produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The permitted range of a `TIME` column is `-838:59:59` to `838:59:59` (that
    is, `-3020399` to `3020399` seconds). However, the range of `TIME` *expressions*
    can be greater, so when you add time values, you can easily produce a result that
    lies outside this range and cannot be stored as is into a `TIME` column.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively you can use `TIMESTAMPDIFF()` function to go outside of the `TIMEDIFF()`
    function limits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Adding to date or date-and-time values using basic units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Date or date-and-time values converted to basic units can be shifted to produce
    other dates. For example, to shift a date forward or backward a week (seven days),
    use `TO_DAYS()` and `FROM_DAYS()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`TO_DAYS()` also can convert date-and-time values to days, if you don’t mind
    having it chop off the time part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To preserve the time, you can use `UNIX_TIMESTAMP()` and `FROM_UNIXTIME()`
    instead, if the initial and resulting values both lie in the permitted range for
    `TIMESTAMP` values (from 1970 partially through 2038). The following statement
    shifts a `DATETIME` value forward and backward by an hour (3,600 seconds):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 8.14 Calculating Ages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know how old someone is.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a date-arithmetic problem. It amounts to computing the interval between
    dates, but with a twist. For an age in years, it’s necessary to account for the
    relative placement of the start and end dates within the calendar year. For an
    age in months, it’s also necessary to account for the placement of the months
    and the days within the month.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Age determination is a type of date-interval calculation. However, you cannot
    simply compute a difference in days and divide by 365 because leap years throw
    off the calculation. (It is 365 days from 1995-03-01 to 1996-02-29, but that is
    not a year in age terms.) Dividing by 365.25 is slightly more accurate, but still
    not correct for all dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate ages, use the `TIMESTAMPDIFF()` function. Pass it a birth date,
    a current date, and the unit in which you want the age expressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`TIMESTAMPDIFF()` handles the calculations necessary to adjust for differing
    month and year lengths and relative positions of the dates within the calendar
    year. Suppose that a `sibling` table lists the birth dates of Ilayda and her sister
    Lara.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `TIMESTAMPDIFF()`, you can answer questions such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: How old are the Alkin’s children today, in years, months and days?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How old was Ilayda when Lara was born, in years and months?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For further information about date calculation using these functions, consult
    the [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/date-calculations.html).
  prefs: []
  type: TYPE_NORMAL
- en: 8.15 Finding the First Day, Last Day, or Length of a Month
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a date, you want to determine the date for the first or last day of the
    month in which the date occurs, or the first or last day for the month *`n`* months
    away. A related problem is to determine the number of days in a month.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To determine the date for the first day in a month, use date shifting (an application
    of date arithmetic). To determine the date for the last day, use the `LAST_DAY()`
    function. To determine the number of days in a month, find the date for its last
    day and use it as the argument to `DAYOFMONTH()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you have a reference date and want to reach a target date that doesn’t
    have a fixed relationship to the reference date. For example, the first or last
    days of the current month aren’t a fixed number of days from the current date.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the first day of the month for a given date, shift the date back by
    one fewer days than its `DAYOFMONTH()` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In the general case, to find the first of the month for any month *`n`* months
    away from a given date, calculate the first of the month for the date and shift
    the result by *`n`* months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to find the first day of the previous and following months relative
    to a given date, *`n`* is `-1` and `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s easier to find the last day of the month for a given date because there
    is a function for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'For the general case, to find the last of the month for any month *`n`* months
    away from a given date, shift the date by that many months first, then pass it
    to `LAST_DAY()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to find the last day of the previous and following months relative
    to a given date, *`n`* is `-1` and `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the length of a month in days, determine the date of its last day with
    `LAST_DAY()`, then use `DAYOFMONTH()` to extract the day-of-month component from
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 8.16 Finding the Day of the Week for a Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the day of the week on which a date falls.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `DAYNAME()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To determine the name of the day of the week for a given date, use `DAYNAME()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '`DAYNAME()` is often useful in conjunction with other date-related techniques.
    For example, to determine the day of the week for the first of the month, use
    the first-of-month expression from [Recipe 8.15](#nch-dates-dates-day-firstlast)
    as the argument to `DAYNAME()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 8.17 Finding Dates for Any Weekday of a Given Week
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to compute the date of some weekday for the week in which a given date
    lies. Suppose that you want to know the date of the Tuesday that falls in the
    same week as `2014-07-09`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an application of date shifting. Figure out the number of days between
    the starting weekday of the given date and the desired day, and shift the date
    by that many days.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section and the next describe how to convert one date to another when the
    target date is specified in terms of days of the week. To solve such problems,
    you need to know day-of-week values. Suppose you begin with a target date of `2014-07-09`.
    To determine the date for Tuesday of the week in which that date lies, the calculation
    depends on what weekday it is. If it’s a Monday, you add a day to produce `2014-07-10`,
    but if it’s a Wednesday, you subtract a day to produce `2014-07-08`.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL provides two functions that are useful here. `DAYOFWEEK()` treats Sunday
    as the first day of the week and returns 1 through 7 for Sunday through Saturday.
    `WEEKDAY()` treats Monday as the first day of the week and returns 0 through 6
    for Monday through Sunday. (The examples shown here use `DAYOFWEEK()`.) Another
    kind of day-of-week operation involves determining the name of the day. `DAYNAME()`
    can be used for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculations that determine one day of the week from another depend on the
    day you start from as well as the day you want to reach. I find it easiest to
    shift the reference date first to a known point relative to the beginning of the
    week, and then shift forward:'
  prefs: []
  type: TYPE_NORMAL
- en: Shift the reference date back by its `DAYOFWEEK()` value, which always produces
    the date for the Saturday preceding the week.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shift the Saturday date by one day to reach the Sunday date, by two days to
    reach the Monday date, and so forth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In SQL, those operations can be expressed as follows for a date `d`, where
    *`n`* is 1 through 7 to produce the dates for Sunday through Saturday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'That expression splits the <q>shift back to Saturday</q> and <q>shift forward</q>
    phases into separate operations, but because the intervals for both `DATE_SUB()`
    and `DATE_ADD()` are in days, the expression can be simplified into a single `DATE_ADD()`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this formula to the dates in our `date_val` table, using an *`n`*
    of 1 for Sunday and 7 for Saturday to find the first and last days of the week,
    yields this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: To determine the date of some weekday in a week relative to that of the target
    date, modify the preceding procedure a bit. First, determine the date of the desired
    weekday in the week containing the target date and then shift the result into
    the desired week.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating the date for a day of the week in some other week is a problem
    that breaks down into a day-within-week shift (using the formula just given) plus
    a week shift. These operations can be done in either order because the amount
    of shift within the week is the same whether or not you shift the reference date
    into a different week first. For example, to calculate Wednesday of a week by
    the preceding formula, *`n`* is 4\. To compute the date for Wednesday two weeks
    ago, you can perform the day-within-week shift first, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can perform the week shift first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Some applications need to determine dates such as the *`n`*-th instance of particular
    weekdays. For example, to administer a payroll for which paydays are the second
    and fourth Thursdays of each month, you must know what those dates are. One way
    to do this for any given month is to begin with the first-of-month date and shift
    it forward. It’s easy enough to shift the date to the Thursday in that week; the
    trick is to figure out how many weeks forward to shift the result to reach the
    second and fourth Thursdays. If the first of the month occurs on any day from
    Sunday through Thursday, you shift forward one week to reach the second Thursday.
    If the first of the month occurs on Friday or later, you shift forward by two
    weeks. The fourth Thursday is, of course, two weeks after that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Perl code implements this logic to find all paydays in the year
    2021\. It runs a loop that constructs the first-of-month date for the months of
    the year. For each month, it issues a statement that determines the dates of the
    second and fourth Thursdays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 8.18 Canonizing Not-Quite-ISO Date Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a date that is in a format that’s close to, but not exactly in, ISO
    format, and you want to convert it into an ISO format date..
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Canonize the date by passing it to a function that always returns an ISO-format
    date result.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Recipe 8.10](#nch-dates-dates-synth), we ran into the problem that synthesizing
    dates with `CONCAT()` may produce values that are not quite in ISO format. For
    example, the following statement produces first-of-month values in which the month
    part may have only a single digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[Recipe 8.10](#nch-dates-dates-synth) shows a technique using `LPAD()` for
    making sure the month values have two digits. Another way to standardize a close-to-ISO
    date is to use it in an expression that produces an ISO date result. For a date
    `d`, any of the following expressions will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Using those expressions with the non-ISO results from the `CONCAT()` operation
    yields ISO format in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 8.19 Selecting Rows Based on Temporal Characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to select rows based on temporal conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a date or time condition in the `WHERE` clause. This may be based on direct
    comparison of column values with known values. Or it may be necessary to apply
    a function to column values to convert them to a more appropriate form for testing,
    such as using `MONTH()` to test the month part of a date.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the preceding date-based techniques were illustrated by example statements
    that produce date or time values as output. To place date-based restrictions on
    the rows selected by a statement, use the same techniques in a `WHERE` clause.
    For example, you can select rows by looking for values that occur before or after
    a given date, within a date range, or that match particular month or day values.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing dates to one another
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following statements find rows from the `date_val` table that occur either
    before 1900 or during the 1900s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'When you don’t know the exact date needed for a comparison in a `WHERE` clause,
    you can often calculate it using an expression. For example, to perform an <q>on
    this day in history</q> statement to search for rows in a table named `history`
    to find events occurring exactly 50 years ago, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: You see this kind of thing in newspapers that run columns showing what the news
    events were in times past. (In essence, the statement identifies those events
    that have reached their *`n`*-th anniversary.) To retrieve events that occurred
    <q>on this day</q> for any year rather than <q>on this date</q> for a specific
    year, the statement is a bit different. In that case, you need to find rows that
    match the current calendar day, ignoring the year. That topic is discussed in
    [“Comparing dates to calendar days”](#dates_to_calendar).
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculated dates are useful for range testing as well. For example, to find
    dates that occur later than 20 years ago, use `DATE_SUB()` to calculate the cutoff
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the expression in the `WHERE` clause isolates the date column `d`
    on one side of the comparison operator. This is usually a good idea; if the column
    is indexed, placing it alone on one side of a comparison enables MySQL to process
    the statement more efficiently. To illustrate, the preceding `WHERE` clause can
    be written in a way that’s logically equivalent but much less efficient for MySQL
    to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `d` column is used within an expression. That means *every* row must
    be retrieved so that the expression can be evaluated and tested, which makes any
    index on the column useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it’s not so obvious how to rewrite a comparison to isolate a date
    column on one side. For example, the following `WHERE` clause uses only part of
    the date column in the comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'To rewrite the first comparison, eliminate the `YEAR()` call, and replace its
    right side with a complete date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Rewriting the second comparison is a little trickier. You can eliminate the
    `YEAR()` call on the left side, just as with the first expression, but you can’t
    just add `-01-01` to the year on the right side. That produces the following result,
    which is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'That fails because dates from `1991-01-02` to `1991-12-31` fail the test, but
    should pass. To rewrite the second comparison correctly, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Another use for calculated dates occurs frequently in applications that create
    rows that have a limited lifetime. Such applications must be able to determine
    which rows to delete when performing an expiration operation. You can approach
    this problem a couple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store a date in each row indicating when it was created. (Do this by making
    the column a `TIMESTAMP` or by setting it to `NOW()`; see [Recipe 8.8](#nch-dates-dates-automatic)
    for details.) To perform an expiration operation later, determine which rows have
    a creation date that is too old by comparing that date to the current date. For
    example, the statement to expire rows that were created more than *`n`* days ago
    might look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store an explicit expiration date in each row by calculating the expiration
    date with `DATE_ADD()` when the row is created. For a row that should expire in
    *`n`* days, do this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To perform the expiration operation in this case, compare the expiration dates
    to the current date to see which have been reached:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comparing times to one another
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comparisons involving times are similar to those involving dates. For example,
    to find times in the `t1` column that occurred from 9 AM to 2 PM, use an expression
    like one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: For an indexed `TIME` column, the first method is more efficient. The second
    method has the property that it works not only for `TIME` columns, but for `DATETIME`
    and `TIMESTAMP` columns as well.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing dates to calendar days
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To answer questions about particular days of the year, use calendar-day testing.
    The following examples illustrate how to do this in the context of looking for
    birthdays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Who has a birthday today? This requires matching a particular calendar day,
    so you extract the month and day but ignore the year when performing comparisons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This kind of statement commonly is applied to biographical data to find lists
    of actors, politicians, musicians, and so forth, who were born on a particular
    day of the year.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s tempting to use `DAYOFYEAR()` to solve <q>on this day</q> problems because
    it results in simpler statements. But `DAYOFYEAR()` doesn’t work properly for
    leap years. The presence of February 29 throws off the values for days from March
    through December.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Who has a birthday this month? In this case, it’s necessary to check only the
    month:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Who has a birthday next month? The trick here is that you can’t just add one
    to the current month to get the month number that qualifying dates must match.
    That gives you 13 for dates in December. To make sure that you get 1 (January),
    use either of the following techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
