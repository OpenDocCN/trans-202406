- en: Chapter 6\. String Template Literal Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript’s type system, every value is also a type. We call them literal
    types, and in union with other literal types, you can define a type that is very
    clear about which values it can accept. Let’s take subsets of `string` as an example.
    You can define exactly which strings should be part of your set and rule out a
    ton of errors. The other end of the spectrum would be the entire set of strings
    again.
  prefs: []
  type: TYPE_NORMAL
- en: But what if there is something between? What if we can define types that check
    if certain string patterns are available, and let the rest be more flexible? *String
    template literal types* do exactly that. They allow us to define types where certain
    parts of a string are predefined; the rest is open and flexible for a variety
    of uses.
  prefs: []
  type: TYPE_NORMAL
- en: But even more, in conjunction with conditional types, it’s possible to split
    strings into bits and pieces and reuse the same bits for new types. This is an
    incredibly powerful tool, especially if you think about how much code in JavaScript
    relies on patterns within strings.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at a variety of use cases for *string template literal
    types*. From following simple string patterns to extracting parameters and types
    based on format strings, you will see the enabling power of parsing strings as
    types.
  prefs: []
  type: TYPE_NORMAL
- en: But we keep it real. Everything you see here comes from real-world examples.
    What you can accomplish with string template literal types seems endless. People
    push the usage of string template literal types to the extreme by writing [spell
    checkers](https://oreil.ly/63z2Y) or implementing [SQL parsers](https://oreil.ly/foSvx);
    there seems to be no limit to what you can do with this mind-blowing feature.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Defining a Custom Event System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are creating a custom event system and want to make sure every event name
    follows a convention and starts with `"on"`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use string template literal types to describe string patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s common in JavaScript event systems to have some sort of prefix that indicates
    a particular string is an event. Usually, event or event handler strings start
    with `on`, but depending on the implementation, this can be different.
  prefs: []
  type: TYPE_NORMAL
- en: You want to create your own event system and want to honor this convention.
    With TypeScript’s string types it is possible to either accept all possible strings
    or subset to a union type of string literal types. While one is too broad, the
    other one is not flexible enough for our needs. We don’t want to define every
    possible event name up front; we want to adhere to a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, a type called *string template literal type* or just *template literal
    type* is exactly what we are looking for. Template literal types allow us to define
    string literals but leave certain parts flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a type that accepts all strings that start with `on` could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Syntactically, template literal types borrow from JavaScript’s *template strings*.
    They start and end with a backtick, followed by any string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the specific syntax `${}` allows adding JavaScript expressions, like
    variables, function calls, and the like to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Template literal types in TypeScript are very similar. Instead of JavaScript
    expressions, they allow us to add a set of values in the form of types. A type
    defining the string representation of all available heading elements in HTML could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Levels` is a subset of `number`, and `Headings` reads as “starts with H, followed
    by a value compatible with `Levels`.” You can’t put every type in here, only ones
    that have a string representation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to `EventName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defined like this, `EventName` reads like “starts with `"on"`, followed by any
    string.” This includes the empty string. Let’s use `EventName` to create a simple
    event system. In the first step, we only want to collect callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we define a `Callback` type that is a function type with one parameter:
    an `EventObject`. The `EventObject` is a generic type that contains the value
    with the event information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we need a type to store all registered event callbacks, `Events`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `EventName` as index access as it is a valid subtype of `string`. Each
    index points to an array of callbacks. With our types defined, we set up an `EventSystem`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The constructor creates a new events storage, and `defineEventHandler` takes
    an `Ev⁠en⁠t​Na⁠me` and `Callback` and stores them in said events storage. Also,
    `trigger` takes an `Ev⁠ent​Na⁠me` and, if callbacks are registered, executes every
    registered callback with an `Ev⁠ent​Obj⁠ect`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is done. We now have type safety when defining events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In [Recipe 6.2](#ch06_string_manipulation_types) we will look at how we can
    use string manipulation types and key remapping to enhance our system.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Creating Event Callbacks with String Manipulation Types and Key Remapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to provide a `watch` function that takes any object and adds watcher
    functions for each property, allowing you to define event callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *key remapping* to create new string property keys. Use *string manipulation
    types* to have proper camel casing for watcher functions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our event system from [Recipe 6.1](#ch06_custom_events) is taking shape. We
    are able to register event handlers and trigger events. Now we want to add watch
    functionality. The idea is to extend valid objects with methods for registering
    callbacks that are executed every time a property changes. For example, when we
    define a `person` object, we should be able to listen to `onAgeChanged` and `onNameChanged`
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So for each property, there will be a method that starts with `on`, ends with
    `Changed`, and accepts callback functions with event object parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the new event handler methods, we create a helper type called `Wa⁠tch⁠ed​Ob⁠jec⁠t<T>`,
    where we add bespoke methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a lot to unpack. Let’s go through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a *mapped type* by iterating over all keys from `T`. Since we care
    only about `string` property keys, we use the intersection `string & keyof T`
    to get rid of potential symbols or numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we *remap* this key to a new string, defined by a *string template literal
    type*. It starts with `on`, then takes the key `K` from our mapping process, and
    appends `Changed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The property key points to a function that accepts a callback. The callback
    itself has an event object as an argument, and by correctly substituting its generics,
    we can make sure this event object contains the original type of our watched object.
    This means when we call `onAgeChanged`, the event object will actually contain
    a `number`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is already fantastic but lacks significant detail. When we use `WatchedObject`
    on `person` like that, all generated event handler methods lack an uppercase character
    after `on`. To solve this, we can use one of the built-in *string manipulation
    types* to capitalize string types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to `Capitalize`, `Lowercase`, `Uppercase`, and `Uncapitalize` are also
    available. If we hover over `WatchedObject<typeof person>`, we can see what the
    generated type looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With our types set up, we start with the implementation. First, we create two
    helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We need both helper functions to mimic TypeScript’s behavior of remapping and
    manipulating strings. `capitalize` changes the first letter of a string to its
    uppercase equivalent, and `handlerName` adds a prefix and suffix to it. With `handlerName`
    we need a little type assertion to signal TypeScript that the type has changed.
    With the many ways we can transform strings in JavaScript, TypeScript can’t figure
    out that this will result in a capitalized version.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we implement the `watch` functionality in the event system. We create
    a generic function that accepts any object and returns an object that contains
    both the original properties and the watcher properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully implement triggering of event handlers on property change,
    we use `Proxy` objects to intercept `get` and `set` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` calls we want to intercept are whenever we access the properties
    of `WatchedObject<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: They start with `on` and end with `Changed`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that’s the case, we return a function that accepts callbacks. The function
    itself adds callbacks to the event storage via `defineEventHandler`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all other cases we do regular property access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, every time we set a value of the original object, we want to trigger stored
    events. This is why we modify all `set` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the value. We need to update the object anyway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `trigger` function to execute all registered callbacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that we need a couple of type assertions to nudge TypeScript in
    the right direction. We are creating new objects, after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s it! Try the example from the beginning to see your event system
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: String template literal types along with string manipulation types and key remapping
    allow us to create types for new objects on the fly. These powerful tools make
    the use of advanced JavaScript object creation more robust.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Writing a Formatter Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create typings for a function that takes a format string and substitutes
    placeholders with actual values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a conditional type that infers the placeholder name from a string template
    literal type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your application has a way of defining format strings by defining placeholders
    with curly braces. A second parameter takes an object with substitutions, so for
    each placeholder defined in the format string, there is one property key with
    the respective value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create typings for this function, where we make sure that your users
    don’t forget to add the required properties. As a first step, we define the function
    interface with some very broad types. The format string is of type `string`, and
    the formatting parameters are in a `Record` of `string` keys and literally any
    value. We focus on the types first; the function body’s implementation comes later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a next step, we want to lock function arguments to concrete values or literal
    types by adding generics. We change the type of `fmtString` to be of a generic
    type `T`, which is a subtype of `string`. This allows us to still pass strings
    to the function, but the moment we pass a literal string, we can analyze the literal
    type and look for patterns (see [Recipe 4.3](ch04.html#ch04_no_any) for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we locked in `T`, we can pass it as a type parameter to a generic
    type `FormatKeys`. This is a conditional type that will scan our format string
    for curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check if the format string:'
  prefs: []
  type: TYPE_NORMAL
- en: Starts with a string; this can also be an empty string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains a `{`, followed by any string, followed by a `}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is followed again by any string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This effectively means that we check if there is exactly one placeholder in
    the format string. If so, we return the entire format string, and if not, we return
    `never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`FormatKeys` can tell us if the strings we pass in are format strings or not,
    but we are actually much more interested in a specific part of the format string:
    the piece between the curly braces. Using TypeScript’s `infer` keyword, we can
    tell TypeScript that, if the format string matches this pattern, then grab whatever
    literal type you find between the curly braces and put it in a type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That way, we can extract substrings and reuse them for our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! We extracted the first placeholder name. Now on to the rest. Since
    there might be placeholders following, we take everything *after* the first placeholder
    and store it in a type variable called `Rest`. This condition will be always true,
    because either `Rest` is the empty string or it contains an actual string that
    we can analyze again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We take the `Rest` and in the `true` branch call `FormatKeys<Rest>` in a union
    type of `Key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a *recursive conditional type*. The result will be a union of placeholders,
    which we can use as keys for the formatting object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s time to wire up `FormatKeys`. Since we already locked in `T`, we can
    pass it as an argument to `FormatKeys`, which we can use as an argument for `Record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, our typings are all ready. On to the implementation! The implementation
    is beautifully inverted to how we defined our types. We go over all keys from
    `params` and replace all occurrences within curly braces with the respective value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice two particular typings:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to annotate `ret` with `string`. `fmtString` is with `T`, a subtype
    of `string`; thus `ret` would also be `T`. This would mean we couldn’t change
    values because the type of `T` would change. Annotating it to a broader `string`
    type helps us modify `ret`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to assert that the object key `k` is actually a key of `params`.
    This is an unfortunate workaround that is due to some fail-safe mechanisms of
    TypeScript. Read more on this topic in [Recipe 9.1](ch09.html#ch09_working_with_object_keys).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the information from [Recipe 9.1](ch09.html#ch09_working_with_object_keys),
    we can redefine `format` to get rid of some type assertions to reach our final
    version of the `format` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Being able to split strings and extract property keys is extremely powerful.
    TypeScript developers all over the world use this pattern to strengthen types,
    for example, for web servers like [Express](https://expressjs.com). We will see
    more examples of how we can use this tool to get better types.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Extracting Format Parameter Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to extend the formatting function from [Recipe 6.3](#ch06_formatter_function)
    with the ability to define types for your placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a nested conditional type and look up types with a type map.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s extend the example from the previous lesson. We now want to not only
    know all placeholders but also be able to define a certain set of types with the
    placeholders. Types should be optional, be indicated with a colon after the placeholder
    name, and be one of JavaScript’s primitive types. We expect to get type errors
    when we pass in a value that is of the wrong type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For reference, let’s look at the original implementation from [Recipe 6.3](#ch06_formatter_function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve this, we need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the type of `params` from `Record<FormatKeys<T>, any>` to an actual object
    type that has proper types associated with each property key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the string template literal type within `FormatKeys` to be able to extract
    primitive JavaScript types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the first step, we introduce a new type called `FormatObj<T>`. It works
    just as `FormatKeys` did, but instead of simply returning string keys, it maps
    out the same keys to a new object type. This requires us to chain the recursion
    using intersection types instead of a union type (we add more properties with
    each recursion) and to change the breaking condition from `never` to `{}`. If
    we did an intersection with `never`, the entire return type becomes `never`. This
    way, we don’t add any new properties to the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`FormatObj<T>` works the same way as `Record<FormatKeys<T>, any>`. We still
    didn’t extract any placeholder type, but we made it easy to set the type for each
    placeholder now that we are in control of the entire object type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, we change the parsing condition in `FormatObj<T>` to also look
    out for colon delimiters. If we find a `:` character, we infer the subsequent
    string literal type in `Type` and use it as the type for the mapped-out key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are very close; there’s just one caveat. We infer a *string* literal type.
    This means that if we, for example, parse `{age:number}`, the type of `age` would
    be the literal string `"number"`. We need to convert this string to an actual
    type. We could do another conditional type or use a map type as a lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That way, we can simply check which type is associated with which key and have
    a fantastic fallback for all other strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s wire `MapFormatType` up to `FormatObj<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are almost there! The problem now is that we expect every placeholder to
    also define a type. We want to make types optional. But our parsing condition
    explicitly asks for `:` delimiters, so every placeholder that doesn’t define a
    type doesn’t produce a property, either.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to do the check for types *after* we check for placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The type reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if there is a placeholder available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a placeholder is available, check if there is a type annotation. If so, map
    the key to a format type; otherwise, map the original key to `any`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In all other cases, return the empty object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that’s it. There is one fail-safe guard that we can add. Instead of allowing
    `any` type for placeholders without a type definition, we can at least expect
    that the type implements `toString()`. This ensures we always get a string representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, let’s apply the new type to `format` and change the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We help ourselves with a regular expression to replace names with potential
    type annotations. There is no need to check types within the function. TypeScript
    should be enough to help in this case.
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve seen is that conditional types in combination with string template
    literal types and other tools like recursion and type lookups allow us to specify
    complex relationships with a couple of lines of code. Our types get better, our
    code gets more robust, and it’s a joy for developers to use APIs like this.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Dealing with Recursion Limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You craft an elaborate string template literal type that converts any string
    to a valid property key. With your setup of helper types, you run into recursion
    limits.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the accumulation technique to enable tail-call optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript’s string template literal types in combination with conditional types
    allow you to create new string types on the fly, which can serve as property keys
    or check your program for valid strings.
  prefs: []
  type: TYPE_NORMAL
- en: They work using recursion, which means that just like a function, you can call
    the same type over and over again, up to a certain limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this type `Trim<T>` removes whitespaces at the start and end of
    your string type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It checks if there’s a whitespace at the beginning, infers the rest, and does
    the same check over again. Once all whitespaces at the beginning are gone, the
    same checks happen for whitespaces at the end. Once all whitespaces at the beginning
    and end are gone, it is finished and hops into the last branch—returning the remaining
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Calling the type over and over is recursion, and writing it like that works
    reasonably well. TypeScript can see from the type that the recursive calls stand
    on their own, and it can evaluate them as tail-call optimized, which means it
    can evaluate the next step of the recursion within the same call stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to know more about the call stack in JavaScript, Thomas Hunter’s
    book [*Distributed Systems with Node.js*](https://learning.oreilly.com/library/view/distributed-systems-with/9781492077282)
    (O’Reilly) gives a great introduction.
  prefs: []
  type: TYPE_NORMAL
- en: We want to use TypeScript’s feature to recursively call conditional types to
    create a valid string identifier out of any string, by removing whitespace and
    invalid characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we write a helper type similar to `Trim<T>` that gets rid of any whitespace
    it finds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It checks if there is a whitespace, infers the strings in front of the whitespace
    and after the whitespace (which can be empty strings), and calls the same type
    again with a newly formed string type. It also uncapitalizes the first inference
    and capitalizes the second inference to create a camel-case-like string identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'It does so until all whitespaces are gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to check if the remaining characters are valid. We again use
    recursion to take a string of valid characters, split them into single string
    types with only one character, and create a capitalized and uncapitalized version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We shave off the first character we find, capitalize it, uncapitalize it, and
    do the same with the rest until no more strings are left. Note that this recursion
    can’t be tail-call optimized, as we put the recursive call in a union type with
    the results from each recursion step. Here we would reach a recursion limit when
    we hit 50 characters (a hard limit from the TypeScript compiler). With basic characters,
    we are fine!
  prefs: []
  type: TYPE_NORMAL
- en: But we hit the first limits when we are doing the next step, the creation of
    the `Identifier`. Here we check for valid characters. First, we call the `RemoveWhiteSpace<T>`
    type, which allows us to get rid of whitespaces and camel-cases the rest. Then
    we check the result against valid characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in `StringSplit<T>`, we shave off the first character but do another
    type-check within inference. We see if the character we just shaved off is one
    of the valid characters. Then we get the rest. We combine the same string again
    but do a recursive check with the remaining string. If the first character isn’t
    valid, then we call `Cr⁠ea⁠te​Id⁠en⁠ti⁠fie⁠r<T>` with the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: And here we hit the first recursion limit. TypeScript warns us—with an error—that
    this type instantiation is possibly infinite and excessively deep. It seems that
    if we use the recursive call within a string template literal type, this might
    result in call stack errors and blow up. So TypeScript breaks. It can’t do tail-call
    optimization here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`CreateIdentifier<T>` might still produce correct results, even though TypeScript
    errors when you write your type. Those are hard-to-spot bugs because they might
    hit you when you don’t expect them. Be sure to not let TypeScript produce any
    results when errors happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one way to work around it. To activate tail-call optimization, the
    recursive call needs to stand alone. We can achieve this by using the so-called
    *accumulator technique*. Here, we pass a second type parameter called `Acc`, which
    is of a type `string` and is instantiated with the empty string. We use this as
    an accumulator where we store the intermediate result, passing it over and over
    again to the next call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the recursive call is standing on its own again, and the result is
    the second parameter. When we are done with recursive calls, the recursion-breaking
    branch, we return the accumulator, as it is our finished result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There might be more clever ways to produce identifiers from any string, but
    note that the same thing can hit you deep down in any elaborate conditional type
    where you use recursion. The accumulator technique is a good way to mitigate problems
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Using Template Literals as Discriminants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You model requests to a backend as a state machine, going from *pending* to
    either *error* or *success*. Those states should work for different backend requests,
    but the underlying types should be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use string template literals as discriminants for a discriminated union.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way you fetch data from a backend always follows the same structure. You
    do a request, and it’s pending to be either fulfilled and return some data—success—or
    rejected and return with an error. For example, to log in a user, all possible
    states can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When we fetch a user’s order, we have the same states available. The only difference
    is in the success payload and in the names of each state, which are tailored to
    the type of request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When we deal with a global state handling mechanism, such as [Redux](https://redux.js.org),
    we want to differentiate by using identifiers like this. We still want to narrow
    it to the respective state types!
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript allows you to create discriminated union types where the discriminant
    is a string template literal type. So we can sum up all possible backend requests
    using the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This already gives us an edge. We know that the state property of each union
    type member needs to start with an uppercase string, followed by an underscore
    and the respective state as a string. And we can narrow it to the subtypes just
    as we are used to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the entire set of strings as the first part of the discriminant might
    be a bit too much. We can subset to a variety of known requests and use string
    manipulation types to get the right subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s how to get rid of typos! Even better, let’s say we store all data in
    a global state object of type `Data`. We can derive all possible `BackendRequest`
    types from here. By using `keyof Data`, we get the string keys that make up the
    `BackendRequest` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This already works well for `Pending` and `Err`, but in the `Success` case we
    want to have the actual data type associated with `"user"` or `"order"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first option would be to use index access to get the correct types for the
    `data` property from `Data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`NonNullable<T>` gets rid of `null` and `undefined` in a union type. With the
    compiler flag `strictNullChecks` on, both `null` and `undefined` are excluded
    from all types. This means you need to manually add them if you have nullish states
    and manually exclude them when you want to make sure that they don’t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this would mean that `data` can be both `User` or `Order` for all backend
    requests, and more if we add new ones. To avoid breaking the connection between
    the identifier and its associated data type, we map through all `RequestConstants`,
    create state objects, and then use index access of `RequestConstants` again to
    produce a union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`Success` is now equal to the manually created union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
