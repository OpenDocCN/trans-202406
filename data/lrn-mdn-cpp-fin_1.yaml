- en: Chapter 2\. Some Mechanics of C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just about any programming language will have some form of an array structure
    for storing collections of like types. In C++, there are a handful of options
    for this purpose, but it is the Standard Library `vector` container that is by
    far the most-used type. In this chapter, we will see how a `vector` can conveniently
    represent a vector of real numbers in the mathematical sense. We will also go
    through the basics of creating and using a `vector` and its key member functions,
    as it will tie in well with iterative statements, such as counted loops and `while`
    statements, also to be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures, include both iterative statements and conditional. Conditional
    branching in C++ can be implemented in `if` statements, similar to other languages,
    as well as in what are called `switch` statements. A good complementary topic
    related to the `switch` statement is that of enumerated types (enums), particularly
    the more modern *enum classes* that were added in C++11\. Enum classes are also
    well-suited for facilitating data input to and output from financial models.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will wrap up with a summary of aliases that can be used in C++,
    and why they are important. This includes type aliases that can add clarity to
    the code, in place of longer and sometimes more cryptic templated types. References
    and pointers allow you to access and modify objects without the overhead of object
    copy, although pointers have wider-ranging uses as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vector` container in the C++ Standard Library is the go-to choice for storing
    and managing an indexed array of like types. It is particularly useful for managing
    vectors of real numbers that are ubiquitous in quantitative work, with `double`
    types representing the numerical values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Historical Note**: A `vector` is more specifically part of what is called
    the Standard Template Library (STL). The STL was developed independently of Bjarne
    Stroupstrup’s early efforts in the 1980’s and 90’s to design and produce C++,
    by researcher Alexander Stepanov. The history behind acceptance the STL and its
    acceptance into the C++ Standard is a very interesting one [[see Kalb/Azman]],
    but the upshot is the STL – based on generic programming – was accepted into the
    theretofore object-oriented focused C++ for its first ISO standard release in
    1998.'
  prefs: []
  type: TYPE_NORMAL
- en: Being a generic container, `std::vector` can hold elements of a common arbitrary
    type, ranging from plain old data (POD) types such as `double` and `int`, to objects
    of user-defined and library classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The type to be held is indicated inside the angle brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The angle brackets indicate the *template parameter*. Templates are the means
    by which C++ implements generic programming. This topic will be discussed in further
    detail in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and Accessing Elements of a `vector`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An STL `vector` essentially encapsulates and manages a dynamic array, meaning
    that elements can be appended to it or removed from it after it is constructed.
    The `vector` also supports random access, meaning an element can be accessed,
    and moreover modified, by the index of the element. Like everything else in C++,
    a `vector` is zero-indexed, meaning that the index of its first position is index
    0, and its last position is index *n* - 1, if it holds *n* elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `vector` and Using its Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following instruction will create a vector holding three real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `vector` can be populated element by element as shown here. Note that indexing
    starts with zero rather than one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The index is indicated by square brackets. We can also change the values by
    simply reassigning an element to a new value; viz,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to initialize vectors using *uniform initialization* introduced
    in C++11\. Also known *as braced initialization*, use of the assignment operator
    is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The addition of uniform initialization to C++11 has had a significant impact
    on the language, beyond simply initializing a vector. It has some interesting
    and convenient properties that will be discussed in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: Member Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As `vector` is a class, it holds a number of public member functions, including
    three: `at`, `size`, and `push_back`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `at` Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `at` function essentially performs the same roles as the square bracket
    operator, namely access of an element for a given index, or to modify the element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The difference between using the square bracket operator and the `at` function
    is the latter performs bound checking. Two examples are
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to access an element that exceeds the maximum index; eg,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Attempting to use a negative index value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In each case, an exception will be thrown that can be used in error handling.
    Otherwise, you can just think of `at` and `[.]` as the same.
  prefs: []
  type: TYPE_NORMAL
- en: The `size` Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The name of this member function makes it fairly obvious what it does: it returns
    the number of elements held by a `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You may notice this is the first time we have used the `auto` keyword. What
    this does is automatically deduce the type returned from the `size` function.
    We will see in future cases how useful `auto` can be, but here, it helps us get
    around the fact that the maximum size of a `std::vector` container will vary depending
    upon compiler settings and the platform you are using. The type will be some form
    of an unsigned (non-negative) integer, of which there are multiple sizes.
  prefs: []
  type: TYPE_NORMAL
- en: So as to not get into the weeds here, we don’t need to be concerned with the
    specific unsigned type here, so we can mostly just use `auto` for the return type
    of the `size` member function.
  prefs: []
  type: TYPE_NORMAL
- en: The `push_back` Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function will append elements to a `vector`; that is, new elements are
    “pushed onto the back” of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can append a new element to the `vector v` above, say 47.44:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `v` contains four values: 10.6, 58.63, 0.84, 47.44, with `v[3]` (fourth
    element, using 0-indexing) equal to the new value.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also append values to an empty vector. At the outset, we defined
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we append a value,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`x` now contains the value 3.08 in its index 0 position and contains one element.
    This can be repeated arbitrarily many times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To close the discussion on `push_back`, there is one potential gotcha to be
    aware of,
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we create a `vector` of integers with three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector <int> ints(3);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, each element will hold the default value of an `int` type: 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we then apply the `push_back` function to append, say, 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ints.push_back(5);`'
  prefs: []
  type: TYPE_NORMAL
- en: this value will be appended as a *new element* following the third zero; ie,
    the vector now contains four elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`0 0 0 5`'
  prefs: []
  type: TYPE_NORMAL
- en: To put a value into any of the first three positions, you will need to use the
    index explicitly; eg
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Concluding Remarks on STL `vector`s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples above, we only used plain old numerical types `double` and `int`.
    Vectors of real numbers are of course fundamental for computational work, but
    keep in mind an STL `vector` is generic, in that it can hold elements of any valid
    type, including objects rather than just numerical data types, as we shall see
    in more advanced contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as mentioned earlier, in real-world production level programming, inputs
    are taken from function arguments that come from market and product data, and
    user input, not hard-coded values as seen in the previous examples. One might
    find vectors set with fixed numerical values in test functions, but they should
    be avoided in production code.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Library contains additional STL containers, plus a large set of
    STL *algorithms*that are now a core component of modern C++ programming. These
    will be discussed in greater detail in Chapter 7, and becoming familiar with the
    basics of the `vector` container now will make this material more accessible when
    we get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to reiterate, prefer using an STL `vector` over a dynamic C-style array
    using `new` and `delete`. There is no performance benefit to using the latter,
    and memory management is all encapsulated inside the `vector` class, freeing the
    developer from risks due to memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Enum Constants and Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Enumerated constants*, more commonly called enums for short, map text to integers.
    Prior to C++11, enums were a great means of making it clearer for us mere mortals
    to comprehend integer codes by representing them in (contiguous) words. It was
    also far more efficient for the machine to process integers rather than bulkier
    `std::string` objects that take up more memory. And finally, errors caused by
    typos in quoted characters and stray strings could be avoided.'
  prefs: []
  type: TYPE_NORMAL
- en: The C++11 Standard improved on this further with *enum classes*. These remove
    ambiguities that can occur with overlapping integer values when using regular
    enum constants, while preserving the advantages.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the motivation for preferring the more modern enum classes over
    integer-based enums. In the next section we will see how they can be used to our
    advantage in conditional statements. Later on, they will prove useful in making
    data input and output with financial models more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Enum Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enums allow us to pass around identifiers, classifications, indicators etc in
    text representation, while behind the scenes, the compiler recognizes them as
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can create an enum called `OptionType` that will indicate
    the types of option deals that are allowed in a simple trading system, eg European,
    American, Bermudan, and Asian. The `enum` type is declared; then, inside the braces,
    the allowable types are defined, separated by commas. By default, each will be
    assigned an integer value starting at zero and incremented by one (remember that
    indexing in C++ is zero-based). The closing brace must be followed by a semicolon.
    In code, we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then verify that in place of each option type, its corresponding integer
    value is given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the output, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, we can see how the program treats the text representations as integers.
    Note that these text labels are *not* enclosed in quotation marks, as they ultimately
    represent integer types, not strings.
  prefs: []
  type: TYPE_NORMAL
- en: Potential Conflicts with Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed at the outset, for any `enum` type, the default integer assignments
    start at zero and then are incremented by one for each type member. Therefore,
    it is possible that two enumerated constants from two different types could be
    numerically equal. For example, suppose we define two different `enum` types,
    called `Football` and `Baseball`, representing the defensive positions in each
    sport. By default, the baseball positions start with 0 for the pitcher and are
    incremented by one for each in the list. The same goes for the football positions,
    starting with defensive tackle. The integer constants are provided in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could compare `Defensive_End` and `First_Baseman`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our result would be nonsense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is because both positions map to an integer value of 2.
  prefs: []
  type: TYPE_NORMAL
- en: A quick fix, and one that was often employed prior to C++11, would be to reindex
    each set of enums; eg,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we compare `Defensive_End` and `First_Baseman`, they will no longer
    be equal, because 202 ≠ 102\. Still, in large code bases there might be hundreds
    of enum definitions, so it would not be out of the question for an overlap to
    slip in and cause errors. Enum classes, introduced in C++11, eliminate this risk.
  prefs: []
  type: TYPE_NORMAL
- en: Enum Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A new and more robust way to avoid `enum` overlaps was introduced in C++11
    that eliminates the integer representation altogether. The other benefits of enums,
    such as avoiding cryptic numerical codes and larger string objects, still remain,
    but the conflicts are avoided by using what is called an *enum class*. As an example,
    we can define bond and futures contract categories within enum classes, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we no longer need to manually set integer values to avoid conflicts
    as we did with regular enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to compare members of two different enum classes -- such as a `Bond`
    and a `Futures_Contract` position, will now result in a compiler error. For example,
    the following will not even compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This works to our advantage, as it is much better to catch an error at compile
    time rather than runtime. Modern best practices now maintain that we should prefer
    using enum classes rather than enumerated constants [[refer to ISO Guidelines]].
  prefs: []
  type: TYPE_NORMAL
- en: Control Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Control structures consist of two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional branching, such as `if` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterative controls that repeat a set of commands in a loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C++, the code that pertains to a given condition or sequence is contained
    in a block defined by braces. Similar to a function, variables declared within
    a block will go out of scope when the block terminates. These structures can also
    be nested within one another.
  prefs: []
  type: TYPE_NORMAL
- en: It was assumed in the previous section on enums and enum classes that you are
    familiar with the basics of `if` conditions, but here you can read through a more
    comprehensive review of conditional and iterative constructs that will be utilized
    heavily from here on out. Both depend on logical operators determining a true
    or false condition, so before launching into our tour of control structures, a
    quick review of logical operators and Boolean types are in order.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ boolean type, represented represented by `bool`, can store a value of
    either `true` or `false`. Behind the scenes, a `bool` type has a size of one byte
    and may store only `1` for `true`, or `0` for `false`. Note that `true` and `false`
    are not placed in quotations, as ;ole enums they are not character types. They
    represent fixed integer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ operators for equality and inequalities will return a `bool` type based
    on whether the result is true or false. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<, >` Strict inequality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=, >=` Inclusive inequality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`==` Equality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` Not equals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*And* and *Or* operations are represented by `&&` and `||` respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples will follow in the next section on conditional branching.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Branching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ supports both the usual `if` based logic found in most other languages,
    and `switch`/`case` statements that offer a cleaner alternative to multiple `else
    if` conditions in special cases.
  prefs: []
  type: TYPE_NORMAL
- en: '`if` and Related Conditions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The usual conditional branching statements
  prefs: []
  type: TYPE_NORMAL
- en: '`if (condition) then (action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (condition) then (action), else (default action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (condition 1) then (action 1),`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else if (condition 2) then (action 2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`...`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else if (condition n) then (action n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else (default action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: are represented by the following C++ syntax. Each condition, whether it be `if`,
    `else if`, or `else`, the code that gets executed for a `true` condition is contained
    within a separate body, indicated by open and closed braces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In conditional statements containing `else if`, it is a best practice to include
    a default `else` block at the end. Without it, code may build without any complaints
    from the compiler and run just fine, but its execution could very easily result
    in unexpected behavior that can cause major headaches in larger and more realistic
    code bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing the inequality operators introduced above, we can then write some
    simple examples with all three variations on the `if` statement theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Due to the nature of floating point numerical representation and arithmetic,
    one should never test for exact equality between two `double` types, nor should
    floating point types be compared identically to zero. These cases will be covered
    later in a separate context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operators for logical AND and OR can also be used within conditional arguments.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the last `else if` condition, we put the AND condition inside round
    brackets, as OR takes precedence over AND. [[cppreference.com](https://en.cppreference.com/w/cpp/language/operator_precedence)]
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can assign logical conditions to `bool` variables, and used within
    `if` conditions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that a boolean variable can be negated simply by preceding it with the
    `!` operator, as shown in the first `else if` condition above.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A common trap is to mistakenly use `=` to test equality instead of `==`. The
    former is the assignment operator and will cause unexpected behavior in this case.
    Be sure to use `==` when testing for equality.
  prefs: []
  type: TYPE_NORMAL
- en: Ternary `if` Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is also a convenient one-line shortcut for short and sweet `if-else`
    combinations. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*type* `var = ` *logical condition* `? var_val_true`(if `true`) : `var_val_false`(if
    `false`);'
  prefs: []
  type: TYPE_NORMAL
- en: In English, this means if _*logical condition*_ is `true`, assign the value
    `var` to `var_val_true`; otherwise, assign it to `var_val_false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A code example should make this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, in this example, `result` would be assigned the value of sin(3.14), or approximately
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch`/`case` Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also known as just a `switch` statement, this control sequence allows us to
    eliminate some of the clutter that comes with multiple `else if` clauses, but
    for the particular case of branching on the *state* of a single integer type,
    or alternatively, either an enum that maps to an integer, or an enum class member.
  prefs: []
  type: TYPE_NORMAL
- en: For each possible `case`, the command that follows the matching state is executed.
    As with the `else` condition above, a `default` action should be provided at the
    end to catch cases that do not fall into any of the given categories, or handle
    the error if no other possibilities are admissible.
  prefs: []
  type: TYPE_NORMAL
- en: As a first example, consider a case where we pretend an integer condition represents
    a type of option, and in place of each `cout`, the action would be to call a corresponding
    pricing model. This will render our code more readable and maintainable than using
    multiple `else if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After each case, the `break` statement instructs the program to exit the `switch`
    statement once the corresponding code for a particular state is executed. So if
    `x` is `1`, a lattice model would be called to price an American option, and then
    control would pass out of the body of the `switch` statement rather than checking
    if `x` is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also cases where one might want to drop down to the next step if
    the same action is desired for multiple states. For example, in (American) football,
    if a drive stalls, the offense punts the ball on fourth down and no points are
    scored. If the team scores, however, it might have kicked a field goal for three
    points, or scored a touchdown with three possible outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Miss the extra point(s) -- Result is six points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kick the extra point -- Result is seven points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score a two-point conversion -- Result is eight points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No matter how a team scores, it kicks the ball off to their opponent, so for
    cases 3, 6, 7, and 8, we just drop down through each case until we hit the kickoff.
    This quasi-Bayesian logic could then be implemented with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'An obvious pre-C++11 alternative for the `switch` on option pricing `case`s
    would be to substitute in the corresponding enums for the integer codes, thus
    making the logic even easier to understand for human consumption (`cout` messages
    remain the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'However, modern ISO Guidelines now favor using enum classes, for the reasons
    demonstrated above with integer conflicts. So, we just substitute the `Options_Contract`
    enum class into the preceding example to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Iterative Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++, there are two built-in language features that enable looping logic
    and iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` and `do...while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops (including range-based `for` loops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These iterative commands will execute a repeated block of code over a set of
    values or objects based on a fixed count, while a logical condition is true, or
    over a range of elements held by a `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: '`while` and `do...while` Loops'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The essential workflow behind a `while` loop is to repeat a block of code *while*
    a logical expression is `true` (or alternatively, whilst `false`). The following
    simple example demonstrates a simple `while` loop, where the incremented value
    of an integer is output to the screen while its value remains strictly less than
    some fixed maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Our logical condition is for `i` to be strictly less than the value `max`. As
    long as this condition holds, the value of `i` will be incremented
  prefs: []
  type: TYPE_NORMAL
- en: 'A `do...while` loop is similar, except that by placing the `while` condition
    at the end, it guarantees that at least one iteration of the loop will be executed.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that even if `max` had been set to zero or less, there would still be one
    trip through the `do...while` loop, as the maximum condition is not checked until
    the end. This is the distinction that separates it from the simpler `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: In time, we will see looping examples that involve more interesting mathematics
    and financial applications.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This construct is another form of iteration over a countable range. The form
    that is employed in C++ can be summarized in the following pseudocode example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The syntax here is important, namely the semicolons separating the three expressions
    in the `for` argument. Breaking this down into parts a, b, and c, we would have
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Each of these parts is typically dependent on some form of a counter, such as
    an `int i` counter as seen in the `while` statement; however, we now move this
    index into the argument of the `for` statement, which allows us to remove the
    increment from the body of the loop. The (a) part determines the starting value
    of the counter, (b) indicates where to stop, and (c) enforces how the counter
    is increased or decreased.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could rewrite the `while` example above using a `for` loop
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The results will be exactly the same as the those in the `while` loop examples.
  prefs: []
  type: TYPE_NORMAL
- en: There technically is a difference between the pre- and post- increment operator
    that can affect other uses, but either `++i` with `i++` in the `for` will work
    identically. It is generally preferred to use `++i`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is also legal to have a `for` loop where a decrement (`--`) is used to decrease
    the index value down to some minimum value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`break` and `continue`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In iterative loops, it is sometimes necessary to break out of a loop before
    a maximum or minimum index value is attained, or before the specified logical
    condition would otherwise terminate the iteration. A prime example in computational
    finance is barrier option pricing using Monte Carlo simulation. The simulation
    paths will typically have the same number of time steps; however, in the case
    of an up-and-out barrier option, for example, we would need to break out of the
    loop if the underlying asset price rose above the barrier level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is accomplished by applying the same `break` command as used in `switch`
    statements. A simple example is shown here, which also demonstrates nesting an
    `if` condition inside a `for` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once `i` is incremented to 11, the `if` statement is true, so the `break` command
    is called, causing the program control to exit the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `continue` keyword that can be used to continue the process
    of the loop, but since this is the default behavior of a loop anyway, its usefulness
    is limited.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to nesting `if` conditions inside loops, it is also possible to
    nest iterative blocks inside other blocks, whether they be `for` or `while` loop.
    In quantitative programming, it is easy to find oneself writing double and sometimes
    even triple nested loops when implementing common numerical routines and financial
    models. This type of coding, however, can become complex and error prone in a
    hurry, so one needs to take special precautions, as well as consider alternatives
    we will take up later.
  prefs: []
  type: TYPE_NORMAL
- en: Range-Based `for` Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to C++11, iterating through a `vector` would involve using the index as
    the counter, up to the number its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Range-based `for` loops, introduced in C++11, make this more functional and
    elegant. Instead of explicitly using the `vector` index, a range-based for loop
    simply says “for every element `elem` in `v`, do something with it”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As a trivial example, calculate the sum of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And we are done. No worries about making a mistake with the index, there is
    less to type, and the code more obviously expresses what it is doing. The ISO
    Guidelines in fact tell us to prefer using range-based `for` loops with `vector`
    objects, as well as other STL containers that will be discussed in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliasing can take on several forms, the first being one of convenience, namely
    *type aliasing*, where commonly used parameterized type names can be assigned
    to a shorter and more descriptive alias names.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, *reference aliases* help to avoid copies of objects being created
    when they are passed into functions, often resulting in significant speedup at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '*Pointers* can also be considered as aliases, particularly useful for representing
    an active object in class design (the `this` pointer in Chapter 4). Pointers (and
    now smart pointers) can also be used for allocating memory that persists, but
    this is a separate and deeper discussion that will be deferred until Chapter 6.'
  prefs: []
  type: TYPE_NORMAL
- en: Both references and pointers can help facilitate the *object-oriented programming*
    concepts of *inheritance* and *composition* that will be presented in subsequent
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Type Aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::vector<double>` objects are ubiquitous in quantitative code for fairly
    obvious reasons. Because it is used so much, it is common to assign a type alias
    to it, such as `RealVector`. This better expresses what it is mathematically,
    plus we don’t need to bother with as much typing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using modern C++, we can define the alias `RealVector` by simply defining it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could just write, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As long as the alias is defined before it is used in the code, then it’s fair
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C++11, this application of the `using` command did not exist, so type
    aliasing was accomplished by using the `typedef` command; eg,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is also valid C++ and is still found in many modern code bases, but the
    `using` form is preferable per the modern ISO Guidelines. The detailed reason
    for this is outside the scope of this book, but the upshot is `using` can be used
    to define aliases of generic templated types (eg, not just `double` parameters
    as above), while `typedef` cannot.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A reference, put simply, provides an alias for a *variable*, rather than a
    type. Once a reference is defined, then accessing or modifying it is exactly the
    same as using the original variable. A reference is created by placing an ampersand
    between the type name and the reference name before assigning it to the original
    variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, both `original` and `ref` would return 15 if accessed in a function
    or assigned to another variable. However, reassigning `original` to 12 would also
    mean `ref` now returns 12\. Similarly, reassigning `ref` would change the value
    held by `original`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that a reference must be assigned at the same time it
    is declared. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: would be nonsense as there is nothing to which it refers, and the code would
    fail to compile. Also, once a reference is defined, it cannot be reassigned to
    another variable for the remainder of its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Using a reference for a plain old numerical type is trivial, but they become
    important when passing large objects into a function, so as to avoid object copy
    that can decimate a program’s runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a `std::vector` containing 2000 option contract objects? By
    passing it as a reference into a function, the original object itself can be accessed
    without copying it.
  prefs: []
  type: TYPE_NORMAL
- en: There is one caveat, however. Remember that if a reference is modified, so is
    the original variable to which it refers. For this reason, one can just make the
    reference argument `const`. Then, any attempt to modify the reference will be
    prevented by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are two functions that take in a `std::vector<int>` object
    as a reference argument. The first one returns the sum of the elements, so there
    is no modification of the elements attempted. The second one, however, attempts
    to reset each element to twice its value and then sum the elements. This will
    result in a compiler error – much better than a runtime error – and prevent the
    operations from ever being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is also possible to pass a function argument as non-`const` reference, with
    the intent to modify it in place. In this case, one would typically make the return
    type `void`, instead of returning a modified variable. This is rarely justified
    anymore in modern C++ due to *return value optimization* (*RVO*). With RVO, objects
    by default are returned “in place” rather than as copies from functions. This
    is now a requirement for compilers per the ISO standards, beginning with C++11.
  prefs: []
  type: TYPE_NORMAL
- en: One final point about references relates to managed languages such as Java and
    C#, in that the default behavior is to pass objects by non-constant reference.
    In C++ the default is to pass by value; hence, one must specifically instruct
    the compiler to expect a function argument as a reference with the `&`. This is
    an adjustment that a programmer needs to make if switching between C++ and a managed
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *pointer* in C++ shares some similarities with a reference, in that it can
    also be an alias to another variable, but rather than being permanently tied to
    a variable throughout its lifetime, a pointer *points* to a memory address containing
    the variable’s contents, and it can be redirected to another memory address containing
    another variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This unfortunately can be confusing, as a memory address of a variable is also
    indicated by the `&` operator, in addition to another operator `*` that is used
    to declare a pointer. A simple example illustrates this. First, declare and assign
    an integer variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare a pointer to an integer, using the `*` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This says to create a variable that will be a *pointer to an* `int` *type*,
    but don’t point to anything specific yet; this comes in the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `&` operator in this case means *the address of* `x`. `xp` now points at
    the memory address that contains the contents of `x`, namely 42\. Note that this
    usage of `&` has a different meaning than declaring a reference.
  prefs: []
  type: TYPE_NORMAL
- en: We can now access the contents of this memory address by *dereferencing* `xp`
    by applying the `*` operator. If we put
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: the output would be 42, just as if we had applied `std::cout` to the variable
    `x`. Note the `*` operator is used in a different context here, accessing the
    contents of memory rather than declaring a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: We can also means we can change the value of `x`. For example, putting
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: then both `*xp` and `x` will return the value 25, rather than 42.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to *reassign* the pointer `xp` to a different memory address;
    this is not possible to do with a reference. Suppose we have a different integer
    variable `y` and we reassign `xp` to point to the address of `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, `*xp` will return 106 rather than 25, but `x` is still equal to 25.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`xp`, as opposed to `*xp`, will return the hexadecimal value that represents
    the address of the first byte in memory containing the contents of `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to references, pointers can be used with objects. If we have a class
    `SomeClass` with a member function, say `some_fcn`, then we can define a pointer
    to a `SomeClass` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As it’s obvious that `ptr_sc` will point to a `SomeClass` object, we can use
    the `auto` keyword without obscuring its context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose also that `SomeClass` has a member function `some_fcn`. This function
    can be invoked by dereferencing `ptr_sc` and then calling it in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'More common, however, is to use the indirection operator, indicated by an arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is all we will need to know about pointers for now. More specifically,
    these examples take place in stack memory, and they are automatically deleted
    when the function or control block in which they are defined terminates. More
    advanced usage will be presented later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pointers can also point to memory allocated in heap memory, which allows the
    value or object to persist in memory outside the scope of a function or control
    block. This becomes relevant in certain situations related to object-oriented
    programming and requires and extra care. Moreover, C++11 introduced smart pointers
    into the Standard Library. These topics will be presented in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Function and Operator Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key feature of C++, as well as other modern programming languages, is implementing
    different versions of the same function name, distinguished by different sets
    of input arguments. This is known as *function overloading*. A related feature
    that is very convenient to us as quantitative programmers is *operator overloading*,
    where we can define an operation for specific types, such as vector multiplication.
    Operator overloading is not supported in as many languages as function overloading;
    for example, it exists in C++ and C#, but it is not an option in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Function Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate function overloading, let’s look at an example of two versions
    of a `sum` function, one of which returns a `double` type, while the other returns
    a `vector<double>`. The first version is trivial, just summing two real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The second version, however, will take in two `std::vector<double>` objects
    and return a vector containing the sum of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the two functions perform two distinct tasks, and have different
    return types, based on the types of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloaded functions can also be distinguished based on the *number of arguments*
    of the same type, as well as return the same type. For example (trivially), we
    could define a `sum` function that takes in three real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we put in our `main()` function the following,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: the respective overloaded functions will be called.
  prefs: []
  type: TYPE_NORMAL
- en: Operator Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ provides the standard mathematical operators for integer and floating type
    numerical values. The Standard Library also provides the `+` operator for `std::string`
    types, which will concatenate them. However, there are no operators provided for
    `std::vector`, for example. So, if we want to compute an element-by-element sum
    of two vectors, or calculate a dot product, we’re on our own.
  prefs: []
  type: TYPE_NORMAL
- en: We could just use the `sum` overload for two vectors as shown above for vector
    addition, and write a new function called `dot_product` for vector multiplication.
    However, C++ provides us with a more naturally mathematical approach, namely *operator*
    *overloading*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a vector sum, the addition operator replaces the `sum` overload as shown
    below. The body of the function remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for the dot product, which returns a scalar (`double`), overload
    the `*` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Then, for two vectors `x` and `y`, say
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'the overloaded operators would perform vector addition and multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: For `double` types, the compiler knows to apply the language-provided operators
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For simultaneous iteration over two `vector` objects, at this stage we need
    to revert to an indexed `for` loop. There are more elegant ways to do this that
    avoid the index but require additional background that will be presented in Chapter
    7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the error condition where `x.size() != y.size()`, for now we are simply
    returning an empty vector for the vector sum, and 0 for the dot product. Exceptions
    would be more appropriate for production code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As for other examples, if we were to write a `Matrix` class, we would also want
    to overload operators `+`, `-`, and `*`. For a `Date` class, we could define `-`
    to return the number of days between two dates. Operator overloading is thus very
    convenient for mathematical and financial programming. We will utilize it in various
    contexts going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a fairly lengthy list of topics, starting with the
    `std::vector` container class in the Standard Template Library (STL). `std::vector`
    is ubiquitous in quantitative programming, for (good) reasons that will be covered
    in Chapter 7, along with STL iterators and algorithms that can make C++ code more
    elegant, reliable, and efficient. At this point, however, the goal is to be familiar
    with `std::vector` as a dynamic array of real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aliases come in three different varieties: type aliases (`using`), references,
    and pointers. `using` saves us from having to type out long type names, such as
    `RealVector` in place of the oft-used `std::vector<double>`. References in C++
    are mostly used in passing `const` reference objects as function arguments, avoiding
    object copying that can degrade performance, while preventing the object from
    being modified inside the function. Pointers have several important applications
    beyond being mere aliases that will be presented in due course, along with smart
    pointers that were added to the Standard Library beginning with C++11.'
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading is a natural fit for mathematical programming, and operator
    overloading even more so for objects such as matrices and vectors that are ubiquitous
    in quantitative programming. This is another topic that will be extended in object-oriented
    programming in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] CppReference: `https://en.cppreference.com/w/cpp/language/operator_precedence]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Stroustrup 4E (not directly referenced)'
  prefs: []
  type: TYPE_NORMAL
