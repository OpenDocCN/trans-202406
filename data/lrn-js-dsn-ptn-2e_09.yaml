- en: Chapter 9\. Asynchronous Programming Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous JavaScript programming allows you to execute long-running tasks
    in the background while allowing the browser to respond to events and run other
    code to handle these events. Asynchronous programming is relatively new in JavaScript,
    and the syntax to support it was not available when the first edition of this
    book was published.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript concepts such as `promise`, `async`, and `await` make your code tidier
    and easy to read without blocking the main thread. `async` functions were introduced
    as part of ES7 in 2016 and are now supported on all browsers. Let’s look at some
    patterns that use these features to structure our application flows.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, synchronous code is executed in a blocking manner, meaning that
    the code is executed serially, one statement at a time. The following code can
    run only after the execution of the current statement has been completed. When
    you call a synchronous function, the code inside that function will execute from
    start to finish before the control returns to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, asynchronous code is executed in a nonblocking manner, meaning
    that the JavaScript engine can switch to execute this code in the background while
    the currently running code is waiting on something. When you call an asynchronous
    function, the code inside the function will execute in the background, and the
    control returns to the caller immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of synchronous code in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example of asynchronous code in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can generally use asynchronous code to perform long-running operations without
    blocking the rest of your code. Asynchronous code is suitable when making network
    requests, reading or writing to a database, or doing any other type of I/O (input/output)
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Language features such as `async`, `await`, and `promise` make writing asynchronous
    code in JavaScript easier. They allow you to write asynchronous code in a way
    that looks and behaves like synchronous code, making it easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s briefly look at the differences between callbacks, promises, and `async`/`await`
    before diving into each in more depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, the `makeRequest` function uses a callback to return
    the result of the network request. The caller passes a `callback` function to
    `makeRequest`, which is called back with either the result(`data`) or an `error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second example, the `makeRequest` function returns a `promise` that
    resolves with the result of the network request or rejects with an error. The
    caller can use the `then` and `catch` methods on the returned promise to handle
    the result of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the third example, the `makeRequest` function is declared with the `async`
    keyword, which allows it to use the `await` keyword to wait for the result of
    the network request. The caller can use the `try` and `catch` keywords to handle
    any errors that may occur during the execution of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callback functions in JavaScript can be passed to another function as an argument
    and executed after some asynchronous operation is completed. Callbacks were commonly
    used to handle the results of asynchronous operations, such as network requests
    or user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main disadvantages of using callbacks is that they can lead to what
    is known as “callback hell”—a situation where nested callbacks become challenging
    to read and maintain. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `makeRequest1` function makes a network request and then
    calls the `callback` function with the result of the request. The `callback` function
    then makes a second network request using the `makeRequest2` function, which calls
    another `callback` function with its result. This pattern continues for the third
    network request.
  prefs: []
  type: TYPE_NORMAL
- en: Promise Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Promises are a more modern approach to handling asynchronous operations in
    JavaScript. A promise is an object that represents the result of an asynchronous
    operation. It can be in three states: pending, fulfilled, or rejected. A promise
    is like a contract that can be settled if it is fulfilled or rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a promise using the `Promise` constructor, which takes a function
    as an argument. The function receives two arguments: `resolve` and `reject`. The
    `resolve` function is called when the asynchronous operation is completed successfully,
    and the `reject` function is called if the operation fails.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how you can use promises to make network requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `makeRequest` function returns a `promise` representing
    the network request’s result. The `fetch` method is used inside the function to
    make the HTTP request. If the request succeeds, the promise is fulfilled with
    the data from the response. If it fails, the promise is rejected with the error.
    The caller can use the `then` and `catch` methods on the returned promise to handle
    the result of the request.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of using promises over callbacks is that they provide
    a more structured and readable approach to handling asynchronous operations. This
    allows you to avoid “callback hell” and write code that is easier to understand
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections provide additional examples that will be relevant to
    help you understand the different promise design patterns that you can use in
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Promise Chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to chain multiple promises together to create more
    complex `async` logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Promise Error Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses the `catch` method to handle errors that may occur during
    the execution of a promise chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Promise Parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to run multiple promises concurrently using the `Promise.all`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Promise Sequential Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to run promises in sequence using the `Promise.resolve`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Promise Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses a cache to store the results of promise function calls, allowing
    you to avoid making duplicate requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we’ll demonstrate how to use the `memoizedMakeRequest` function
    to avoid making duplicate requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the button is clicked, the `memoizedMakeRequest` function will be
    called. If the requested URL is already in the cache, the cached data will be
    returned. Otherwise, a new request will be made, and the result will be cached
    for future requests.
  prefs: []
  type: TYPE_NORMAL
- en: Promise Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses promises and functional programming techniques to create
    a pipeline of `async` transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Promise Retry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to retry a promise if it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Promise Decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses a higher-order function to create a decorator that can be
    applied to promises to add additional behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Promise Race
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to run multiple promises concurrently and return the
    result of the first one to settle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: async/await Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`async`/`await` is a language feature that allows a programmer to write asynchronous
    code as if it were synchronous. It is built on top of promises, and it makes working
    with asynchronous code easier and cleaner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you might use `async`/`await` to make an asynchronous
    HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `makeRequest` function is asynchronous because it uses
    the `async` keyword. Inside the function, the `await` keyword is used to pause
    the execution of the function until the `fetch` call resolves. If the call succeeds,
    the data is logged to the console. If it fails, the error is caught and logged
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at some other patterns using `async`.
  prefs: []
  type: TYPE_NORMAL
- en: async Function Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern involves composing multiple `async` functions together to create
    more complex `async` logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: async Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to use the `for-await-of` loop to iterate over an `async`
    iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: async Error Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses `try-catch` blocks to handle errors that may occur during
    the execution of an `async` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: async Parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to run multiple `async` tasks concurrently using the
    `Promise.all` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: async Sequential Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to run `async` tasks in sequence using the `Promise.resolve`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: async Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses a cache to store the results of `async` function calls, allowing
    you to avoid making duplicate requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: async Event Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to use `async` functions to handle events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: async/await Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses `async`/`await` and functional programming techniques to
    create a pipeline of `async` transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: async Retry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern allows you to retry an `async` operation if it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: async/await Decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern uses a higher-order function to create a decorator that can be
    applied to `async` functions to add additional behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Additional Practical Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the patterns discussed in the previous sections, let’s take a
    look at some practical examples of using `async`/`await` in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Making an HTTP Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Reading a File from the Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Writing to a File on the Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Executing Multiple async Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Executing Multiple async Operations in Sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Caching the Result of an async Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Handling Events with async/await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Retrying an async Operation on Failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating an async/await Decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered an extensive set of patterns and examples that can be useful
    when writing asynchronous code for executing long-running tasks in the background.
    We saw how `callback` functions made way for promises and `async`/`await` to execute
    one or many `async` tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at another angle of application architecture
    patterns. We will look at how the patterns for modular development have evolved
    over time.
  prefs: []
  type: TYPE_NORMAL
