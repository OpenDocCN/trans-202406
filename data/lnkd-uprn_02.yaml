- en: Chapter 2\. Intro to Linkerd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The year 2015 was a very good one for cloud native computing: it brought us
    the first Kubernetes release, the creation of the Cloud Native Computing Foundation
    (CNCF), and the creation of Linkerd. Linkerd was one of the first five projects
    donated to the CNCF, and it was the project that coined the term “service mesh.”'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn more about Linkerd, where it comes from, what
    makes it special, and how it works. We’ll keep the history lesson short, useful,
    and interesting, but if you want to get right to the important information, feel
    free to skip ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Where Does Linkerd Come From?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linkerd project was created in 2015 at Buoyant, Inc., by former Twitter
    engineers William Morgan and Oliver Gould. The first public release of Linkerd
    was in February 2016\. You can see a brief summary of its history in [Figure 2-1](#linkerd-timeline).
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0201](assets/luar_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. A brief timeline of Linkerd
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linkerd1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That first version of Linkerd, now called “Linkerd1,” was written mostly in
    Scala and was largely based on the Finagle RPC library created at Twitter. It
    was a multiplatform mesh that supported several different container schedulers
    and offered a number of powerful features. However, using Finagle required Linkerd1
    to run on the Java Virtual Machine (JVM), and ultimately the JVM’s performance
    was simply too high a cost to bear.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd1 is at its end of life. Going forward, when we talk about “Linkerd,”
    we’ll be referring to modern Linkerd—Linkerd2.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2018, the Linkerd project left the Scala world behind with a ground-up rewrite
    based on hard-won experience from Linkerd1 use in the real world. The project
    dropped support for other container orchestration engines and moved to exclusively
    supporting Kubernetes, with most of the code written in Go. Additionally, the
    developers chose to write a small, fast, purpose-built Rust proxy (creatively
    called `linkerd2-proxy`) to manage application communications, rather than adopting
    the Envoy proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd and Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the Linkerd2 rewrite started, the Rust programming language had been gaining
    attention for its memory safety, which enables developers to write code that avoids
    many of the memory management vulnerabilities inherent to C and C++, while still
    compiling to native code for high performance. The downside was that Rust’s networking
    support was sometimes lacking features needed by Linkerd2; in many cases, the
    Linkerd2 developers ended up adding these features to Rust crates like `hyper`
    and `tokio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The driver behind the decisions to focus on Kubernetes and to create a purpose-built
    proxy was *operational simplicity*: the idea that a project should be able to
    deliver functionality and performance while still being simple to learn and use.
    This concept has had a tremendous impact on the Linkerd project as a whole, and
    it continues to be a major focus of Linkerd’s development.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s worth repeating that `linkerd2-proxy` is *not* a general-purpose proxy;
    it was purpose-built for use in Linkerd. It’s extremely fast and lightweight,
    and as a user of Linkerd, you should almost never need to interact with it directly—it
    is very much meant to be invisible in normal use, and most Linkerd users never
    need to tune or debug `linkerd2-proxy`. (In fact, the maintainers of Linkerd like
    to joke that the only `linkerd2-proxy` experts on the planet are…the Linkerd maintainers.)
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd control plane, introduced in the next section, will be your main
    interface when working with Linkerd.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Linkerd is written to be Kubernetes-native, all of its control surface
    is exposed in Kubernetes objects. You will manage, configure, and troubleshoot
    Linkerd via the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other service meshes, Linkerd is broken into two main components: the
    *data plane*, which is the part of the mesh that handles application data directly
    (primarily composed of the proxies), and the *control plane*, which manages the
    data plane. This architecture is shown in [Figure 2-2](#linkerd-architecture).'
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd works by taking advantage of the Kubernetes concept of sidecars, which
    allows every application container to be paired with a dedicated proxy that handles
    all network traffic. The proxies—the data plane of the mesh—implement the advanced
    functionality of the mesh itself, mediating and measuring all the traffic passing
    through them.
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0202](assets/luar_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Linkerd’s internal architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kubernetes Sidecar Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes didn’t have a formal sidecar container type until the adoption of
    [KEP-753](https://oreil.ly/ShohB) in Kubernetes 1.28\. The sidecar *concept* predates
    KEP-753 by many years, though.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd does support KEP-753 sidecar containers as of Linkerd `edge-23.11.4`,
    if you’re running Kubernetes 1.28 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd also supports the concept of *extensions*, extra microservices that
    run as part of the control plane to implement optional functionality (either in
    the cluster or in the Linkerd CLI). Some extensions (such as the Viz and Multicluster
    extensions) are bundled with the official Linkerd build; though they must be installed
    into the cluster separately, you don’t need any extra tools to do so. Others (such
    as the SMI extension) must be obtained separately before you can install them;
    the documentation for the extension should tell you how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: mTLS and Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linkerd relies heavily on Transport Layer Security (TLS), illustrated in [Figure 2-3](#tls-architecture-diagram-1),
    for networking security—nearly all of the communications shown in [Figure 2-2](#linkerd-architecture)
    are protected using TLS.
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0203](assets/luar_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. TLS architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TLS is the technology that’s underpinned data security and privacy on the Internet
    for the last quarter century by allowing secure communication over an insecure
    network, even if the parties communicating have never done so before. It is a
    *huge* topic, easily worth a book on its own. We’ll talk more about it in [Chapter 7](ch07.html#LUAR_mtls_and_certs),
    but at the architectural level, it’s important to understand that Linkerd uses
    TLS to encrypt communications within the cluster, and also as the foundation of
    identity within the mesh (specifically using *mutual TLS*, or *mTLS*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In TLS, encryption and identity both rely on *keypairs*. A keypair consists
    of a *public key* and a *private key*, where:'
  prefs: []
  type: TYPE_NORMAL
- en: The *private* key must be known only to the single entity that the keypair identifies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *public* key must be known to everyone who needs to communicate with that
    entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keypair allows an entity (say, a workload in the Linkerd mesh) to use the
    private key to attest to its identity; other entities can use the public key to
    verify that claim.
  prefs: []
  type: TYPE_NORMAL
- en: An important note about keypairs is that they need to have a limited lifetime,
    so every so often we need a way to replace the keys in use for any given entity.
    This is called *rotating* the keys.
  prefs: []
  type: TYPE_NORMAL
- en: Certifying Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since it’s very tedious to try to keep track of public and private keys separately
    all the time, TLS uses keys that are bundled up in *X.509 certificates* (mostly
    just called certificates), which give us a standard format to save the keys and
    a standard way to allow using one certificate to attest that another is valid.
    This is called *issuing* a certificate or *signing* a certificate. Organizations
    that support the process of issuing certificates are called *certifying authorities*
    or *CAs*. There are companies that treat being a CA as a core part of their business
    (such as Let’s Encrypt, Venafi, and most cloud providers) as well as software
    that permits establishing CAs within our own organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Using certificates to issue other certificates naturally creates a hierarchy
    of certificates that form a chain of trust from a single root, as shown in [Figure 2-4](#certificate-hierarchy-diagram-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0204](assets/luar_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. The certificate trust hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linkerd—like everything else that uses TLS—requires a properly configured hierarchy
    of certificates in order to function. We’ll discuss this in more detail in Chapters
    [3](ch03.html#LUAR_deploying_linkerd) and [7](ch07.html#LUAR_mtls_and_certs).
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd Control Plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of this writing, the core Linkerd control plane is composed of three primary
    components, as shown in [Figure 2-5](#linkerd-control-plane-architecture): the
    *proxy injector*, the *identity controller*, and the *destination controller*.
    We will discuss these components in more detail in [Chapter 15](ch15.html#LUAR_troubleshooting).
    Fundamentally, they are responsible for allowing you to add individual applications
    to your service mesh and enabling the core security, reliability, and observability
    features that Linkerd provides. In order to provide these functions, these components
    interact directly with Linkerd’s TLS certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0205](assets/luar_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. The Linkerd control plane
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linkerd Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 2-5](#linkerd-control-plane-architecture) shows some extension deployments
    running off to the side. Linkerd extensions have no special privileges; in particular,
    the only way they can interact with the control plane or the proxy is via published
    APIs. This allows them to be written by anyone.'
  prefs: []
  type: TYPE_NORMAL
- en: Several extensions are maintained by the Linkerd maintainers to supply functionality
    that many users want, but that isn’t *required* by every Linkerd installation;
    these include Linkerd Viz, Linkerd Multicluster, Linkerd Jaeger, Linkerd CNI,
    and Linkerd SMI.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd Viz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linkerd Viz extension provides the Linkerd dashboard and its associated
    components, as shown in [Figure 2-6](#linkerd-viz-architecture). It also provides
    some additional CLI options that are useful when troubleshooting applications
    in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0206](assets/luar_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. The Linkerd Viz extension
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Viz is made up of the components described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Web component of Linkerd Viz provides the dashboard GUI used by many Linkerd
    operators. You don’t actually need the GUI—everything it shows is accessible from
    the command line—but it is very commonly used, and it can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd Viz Dashboard Is Unauthenticated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linkerd Viz dashboard doesn’t do user authentication—there are simply too
    many auth systems in use for it to be feasible. If you choose to expose Linkerd
    Viz to the network, you’ll need to use an API gateway or the like to protect access
    to Linkerd Viz according to your own policies. The dashboard can’t change anything
    in your cluster, but it does expose an awful lot of information.
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose to leave the dashboard *inaccessible* from outside the cluster,
    and simply use the `linkerd viz dashboard` CLI command to bring up the dashboard
    in a web browser, via a port forward.
  prefs: []
  type: TYPE_NORMAL
- en: Tap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tap allows Linkerd to surface the metadata about individual requests flowing
    between your applications. Tap data is useful for debugging application issues
    in live environments, since it permits watching request and response data in real
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Tap Doesn’t Show Request Bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tap can only show *metadata*: paths, headers, etc. It cannot show request *bodies*.
    In a great many cases, of course, the metadata is all that’s needed to understand
    what’s going on in an application.'
  prefs: []
  type: TYPE_NORMAL
- en: For access to request bodies, you’ll need to incorporate application-level request
    logging. Even in this situation, though, Tap can help narrow down the microservices
    and request IDs of interest when examining more detailed logs.
  prefs: []
  type: TYPE_NORMAL
- en: Tap injector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For Linkerd Viz to surface metadata about requests, the metadata must be collected
    from the individual proxies in the system. The Tap injector modifies the proxy
    injector so that new proxies will allow this metadata collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the proxy injector can’t affect any proxy that’s already running!
    Any workloads started before the extension was installed will need to be restarted
    to provide Tap data to Linkerd Viz.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The metrics API is involved in collecting metrics for the Linkerd dashboard.
    It provides the underlying summary data for the Linkerd dashboard as well as the
    Linkerd CLI. Like all dashboard components, it is not involved in providing information
    to the Linkerd proxies.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus and Grafana
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linkerd’s Viz extension ships with a Prometheus instance. If you choose to install
    Grafana (as described in the [Linkerd documentation](https://oreil.ly/FB_XN)),
    Linkerd publishes several open source Grafana dashboards as well.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t actually need Linkerd Viz to use Prometheus and Grafana. The Linkerd
    proxy supports Prometheus natively, so you can install Prometheus and configure
    it to scrape the proxies directly if you like. Linkerd Viz is simpler, though.
  prefs: []
  type: TYPE_NORMAL
- en: Always Use Your Own Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, installing Linkerd Viz will install an internal Prometheus instance.
    *Do not use this Prometheus in production*, as it does not have persistent storage
    configured; instead, see the [Linkerd documentation](https://oreil.ly/hI6eF) and
    [Example 10-9](ch10.html#EX12-production-prometheus) for information about using
    an external Prometheus instance.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd Multicluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linkerd Multicluster extension provides users the ability to connect clusters
    together over any public or private networks, as shown in [Figure 2-7](#linkerd-multicluster-architecture).
    The Multicluster extension connects clusters via a special gateway that allows
    all traffic to appear as if it originates locally in the cluster. This allows
    users to avoid configuring any special networking settings when connecting clusters.
    We’ll dive deeper into multicluster connections in [Chapter 12](ch12.html#LUAR_multicluster).
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0207](assets/luar_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Linkerd multicluster architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linkerd Jaeger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linkerd Jaeger extension allows Linkerd to participate in distributed tracing,
    as embodied by [the Jaeger project](https://oreil.ly/Dly9D). Specifically, it
    allows Linkerd to emit and forward distributed tracing spans, so that you can
    see proxy activity in the distributed trace. As shown in [Figure 2-8](#linkerd-jaeger-architecture),
    Linkerd Jaeger provides a collector, which forwards spans to a Jaeger instance,
    and an injector, which modifies the proxy injector so that new proxies will send
    data to the collector. As with Linkerd Viz, you’ll need to restart any workloads
    that were running before you installed Linkerd Jaeger!
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that while Linkerd can aid your application-based
    tracing by providing details on how the proxies are contributing to your distributed
    application’s flow, it cannot add tracing instrumentation to your application.
    In order to take advantage of distributed tracing with Linkerd, your application
    must first be configured to propagate tracing headers and create and emit its
    own spans.
  prefs: []
  type: TYPE_NORMAL
- en: Always Use Your Own Jaeger Instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Linkerd Jaeger will install an internal Jaeger instance. Do not
    use this Jaeger instance in production, as it does not provide persistent storage;
    instead, see the [Linkerd documentation](https://oreil.ly/QgDXC) for information
    about using an external Jaeger instance.
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0208](assets/luar_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Linkerd Jaeger architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linkerd CNI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a Linkerd proxy starts running, it needs to reconfigure the kernel’s network
    layer so that the proxy can intercept and mediate network communication for the
    application. There are two possible ways for Linkerd to do this: the Linkerd *init
    container* or the Linkerd *Container Network Interface (CNI) plugin*.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss this in much greater detail in [Chapter 13](ch13.html#LUAR_cni_vs_init_containers),
    but it’s worth noting here that the CNI plugin works in conjunction with the Kubernetes
    CNI to reconfigure the network stack in environments where using the init container
    isn’t possible or isn’t desirable. If you do plan to use the CNI, you must install
    the Linkerd CNI plugin before installing any other Linkerd components. This is
    the only extension that can and must be installed before Linkerd’s core control
    plane.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd SMI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Service Mesh Interface (SMI) was a project out of the CNCF that aimed to
    provide a standard, cross-platform API to control the behavior of a service mesh.
    The Linkerd SMI extension allows Linkerd to do traffic splitting using the SMI
    TrafficSplit custom resource definition (CRD).^([1](ch02.html#id606))
  prefs: []
  type: TYPE_NORMAL
- en: SMI saw somewhat mixed adoption overall, and as of October 2023 the SMI project
    was archived, with many of its concepts and goals used to inform [the GAMMA initiative
    within Gateway API](https://oreil.ly/J1BOK), which Linkerd supports as of version
    2.14.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linkerd got started in 2015 and grew into its modern form, based on Rust and
    Go and driven by the concept of operational simplicity, in 2018\. That focus on
    operational simplicity remains today and is borne out by Linkerd’s architecture,
    with a small, purpose-built Rust data plane proxy, a Go control plane that focuses
    on critical functionality, and a set of extensions for optional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#id606-marker)) There were other SMI CRDs, but other than TrafficSplit,
    they duplicate functionality that Linkerd already had APIs for.
  prefs: []
  type: TYPE_NORMAL
