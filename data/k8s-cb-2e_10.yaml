- en: Chapter 10\. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running applications in Kubernetes comes with a shared responsibility between
    developers and ops folks to ensure that attack vectors are minimized, least-privileges
    principles are followed, and access to resources is clearly defined. In this chapter,
    we will present recipes that you can, and should, use to make sure your cluster
    and apps run securely. The recipes in this chapter cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The role and usage of service accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a pod’s security context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.1 Providing a Unique Identity for an Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to grant an application access to restricted resources at a fine-grained
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a service account with specific secret access and reference it within
    a pod specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create a dedicated namespace for this and the following recipe called
    `sec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new service account called `myappsa` in that namespace and take
    a closer look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reference this service account in a pod manifest, which we’re calling
    *serviceaccountpod.yaml*, as shown next. Notice that we are also placing this
    pod in the `sec` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The service account’s API credentials will be automounted at */var/run/secrets/kubernetes.io/serviceaccount/token*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, the `myappsa` service account token has been mounted in the expected
    place in the pod and can be used going forward.
  prefs: []
  type: TYPE_NORMAL
- en: While a service account on its own is not super useful, it forms the basis for
    fine-grained access control; see [Recipe 10.2](#rbac_intro) for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Being able to identify an entity is the prerequisite for authentication and
    authorization. From the API server’s point of view, there are two sorts of entities:
    human users and applications. While user identity (management) is outside of the
    scope of Kubernetes, there is a first-class resource representing the identity
    of an app: the service account.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, the authentication of an app is captured by the token available
    in a file at the location */var/run/secrets/kubernetes.io/serviceaccount/token*,
    which is mounted automatically through a secret. The service accounts are namespaced
    resources and are represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing the service accounts in a certain namespace gives you something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice the service account called `default` here. This is created automatically;
    if you don’t set the service account for a pod explicitly, as was done in the
    solution, it will be assigned the `default` service account in its namespace.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Managing Service Accounts”](https://oreil.ly/FsNK7) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Configure Service Accounts for Pods”](https://oreil.ly/mNP_M) in the Kubernetes
    documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Pull an Image from a Private Registry”](https://oreil.ly/Fg06V) in the Kubernetes
    documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.2 Listing and Viewing Access Control Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to learn what actions you’re allowed to do—​for example, updating a
    deployment or listing secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following solution assumes you’re using RBAC as the [authorization mode](https://oreil.ly/K7y65).
    RBAC is the default mode for access control on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if a certain action on a resource is allowed for a specific user,
    use `kubectl auth can-i`. For example, you can execute this command to check if
    the service account called `system:serviceaccount:sec:myappsa` that you created
    in the previous recipe is allowed to list pods in the namespace `sec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign roles to a service account using Kubernetes’s built-in RBAC
    system. For example, you can give the service account permission to view all resources
    in a given namespace by assigning it the predefined `view` cluster role for that
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run the same `can-i` command, you’ll see that the service account
    now has permission to read pods in the `sec` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For this recipe to work on Minikube, depending on the version you are running,
    you may need to add the parameter `--extra-config=apiserver.authorization-mode=Node,RBAC`
    when starting your Minikube cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the roles available in a namespace, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the predefined roles, which you can use directly for users
    and service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further explore a certain role and understand what actions are allowed,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the default roles defined in the `kube-system` namespace, you
    can define your own; see [Recipe 10.3](#access_control).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see in [Figure 10-1](#rbac-concept), there are a couple of moving
    parts when dealing with RBAC authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: An entity—​that is, a group, user, or service account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A resource, such as a pod, service, or secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A role, which defines rules for actions on a resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A role binding, which applies a role to an entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![RBAC Concept](assets/kcb2_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. The RBAC concept
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The actions on a resource that a role uses in its rules are the so-called verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`, `list`, `watch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`/`patch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concerning the roles, we differentiate between two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Cluster-wide
  prefs: []
  type: TYPE_NORMAL
- en: Cluster roles and their respective cluster role bindings. Note that you can
    also attach cluster roles to regular role bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace-wide
  prefs: []
  type: TYPE_NORMAL
- en: Roles and role bindings.
  prefs: []
  type: TYPE_NORMAL
- en: In [Recipe 10.3](#access_control), we will further discuss how you can create
    your own rules and apply them to users and resources.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Authorization Overview”](https://oreil.ly/57NdL) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Using RBAC Authorization”](https://oreil.ly/n0i0c) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.3 Controlling Access to Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a given user or application, you want to allow or deny a certain action,
    such as viewing secrets or updating a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume you want to restrict an app to be able to view only pods—that is,
    list pods and get details about pods.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll work in a namespace called `sec`, so start by creating that namespace
    with `kubectl create namespace sec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then create a pod definition in a YAML manifest, *pod-with-sa.yaml*, using
    a dedicated service account, `myappsa` (see [Recipe 10.1](#service_accounts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define a role—let’s call it `podreader` in the manifest *pod-reader.yaml*—that
    defines the allowed actions on resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, you need to apply the role `podreader` to the service account
    `myappsa`, using a role binding in *pod-reader-binding.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating the respective resources, you can use the YAML manifests directly
    (assuming the service account has already been created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than creating manifests for the role and the role binding, you can use
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is a case of namespaced access control setup, since you’re using
    roles and role bindings. For cluster-wide access control, you would use the corresponding
    `create clusterrole` and `create clusterrolebinding` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it’s not obvious whether you should use a role or a cluster role
    and/or role binding, so here are a few rules of thumb you might find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to restrict access to a namespaced resource (like a service or pod)
    in a certain namespace, use a role and a role binding (as we did in this recipe).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to reuse a role in a couple of namespaces, use a cluster role with
    a role binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to restrict access to cluster-wide resources such as nodes or to
    namespaced resources across all namespaces, use a cluster role with a cluster
    role binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kubernetes documentation on using RBAC authorization](https://oreil.ly/n0i0c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.4 Securing Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define the security context for an app on the pod level. For example,
    you want to run the app as a nonprivileged process.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enforce policies on the pod level in Kubernetes, use the `securityContext`
    field in a pod specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume you want an app running as a non-root user. For this, you would
    use the security context on the container level as shown in the following manifest,
    *securedpod.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the pod and check the user under which the container runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As expected, it’s running as the user with ID `5000`. Note that you can also
    use the `securityContext` field on the pod level rather than on specific containers.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more powerful method to enforce policies on the pod level is to use pod security
    admission. See [“Pod Security Admission”](https://oreil.ly/ujeV4) in the Kubernetes
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Configure a Security Context for a Pod or Container”](https://oreil.ly/ENH8N)
    in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
