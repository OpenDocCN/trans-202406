- en: Chapter 10\. Containers at Scale
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：规模化容器
- en: A major strength of containers is their ability to abstract away the underlying
    hardware and operating system so that your application is not constrained to any
    particular host or environment. It facilitates scaling a stateless application
    not just horizontally within your data center but also across cloud providers
    without many of the traditional barriers you would encounter. True to the shipping
    container metaphor, a container on one cloud looks like a container on another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的一个主要优势是其能够将底层硬件和操作系统抽象化，使得您的应用程序不受限于任何特定主机或环境。这有助于在您的数据中心内水平扩展无状态应用程序，也可以跨多个云提供商进行扩展，而无需遇到许多传统障碍。与运输容器的隐喻一致，在一个云上的容器看起来像在另一个云上的容器一样。
- en: Many organizations find turnkey cloud deployments of Linux containers appealing
    because they can gain many of the immediate benefits of a scalable container-based
    platform without needing to completely build something in-house. Even though this
    is true, the barrier is actually pretty low for building your own platform in
    the cloud or in your own data center, and we’ll cover some options for doing that
    shortly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织发现 Linux 容器的即插即用云部署吸引人，因为他们可以获得可扩展容器平台的许多即时好处，而无需完全自行构建。尽管如此，构建自己的云平台或数据中心的门槛实际上相当低，我们将很快介绍一些可选方案。
- en: 'The major public cloud providers have all worked to support Linux containers
    natively in their offerings. Some of the largest efforts to support Linux containers
    in the public cloud include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的公共云提供商都致力于原生支持 Linux 容器在其服务中的运行。一些最大的努力包括以下内容：
- en: '[Amazon Elastic Container Service](https://aws.amazon.com/ecs)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[亚马逊弹性容器服务](https://aws.amazon.com/ecs)'
- en: '[Google Cloud Run](https://cloud.google.com/run)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google Cloud Run](https://cloud.google.com/run)'
- en: '[Azure Container Apps](https://azure.microsoft.com/en-us/services/container-apps)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Azure 容器应用](https://azure.microsoft.com/en-us/services/container-apps)'
- en: 'Many of the same companies also have robust hosted Kubernetes offerings like
    these:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多相同的公司还拥有强大的托管 Kubernetes 服务，比如这些：
- en: '[Amazon Elastic Kubernetes Service](https://aws.amazon.com/eks)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[亚马逊弹性 Kubernetes 服务](https://aws.amazon.com/eks)'
- en: '[Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine)'
- en: '[Azure Kubernetes Service](https://azure.microsoft.com/en-us/services/kubernetes-service)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Azure Kubernetes 服务](https://azure.microsoft.com/en-us/services/kubernetes-service)'
- en: It’s trivial to install Docker on a Linux instance in one of the public clouds.
    But getting Docker onto the server is usually just one step in creating a full
    production environment. You could do this completely on your own, or you could
    use the many tools available from the major cloud providers, Docker, Inc., and
    the broader container community. Much of the tooling will work equally well in
    either a public cloud or your own data center.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共云中的 Linux 实例上安装 Docker 很简单。但将 Docker 部署到服务器通常只是创建完整生产环境的第一步。您可以完全自行操作，或者使用来自主要云服务提供商、Docker
    公司以及更广泛的容器社区的许多工具。大部分工具在公共云或您自己的数据中心中同样有效。
- en: In the realm of schedulers and more complex tooling systems, we have plenty
    of choices for systems that replicate much of the functionality you would get
    from a public cloud provider. Even if you run in a public cloud, there are some
    compelling reasons why you might choose to run your own Linux container environment
    rather than use one of the off-the-shelf offerings.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在调度器和更复杂的工具系统领域，我们有很多选择可以复制大部分来自公共云提供商的功能。即使在公共云中运行，有一些令人信服的理由可以选择在自己的 Linux
    容器环境中运行，而不是使用现成的服务。
- en: In this chapter, we’ll cover some options for running Linux containers at scale,
    first going through the much simpler Docker Swarm mode and then diving into some
    more advanced tools like Kubernetes and some of the larger cloud offerings. All
    of these examples should give you a view of how you can leverage Docker to provide
    an incredibly flexible platform for your application workloads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些运行 Linux 容器的选择，首先是更简单的 Docker Swarm 模式，然后深入一些更高级的工具，比如 Kubernetes
    以及一些较大的云服务提供商。所有这些示例都应该让您了解如何利用 Docker 为应用程序工作负载提供极其灵活的平台。
- en: Docker Swarm Mode
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Swarm 模式
- en: After building the container runtime in the form of the Docker engine, the engineers
    at Docker turned to the problems of orchestrating a fleet of individual Docker
    hosts and effectively packing those hosts full of containers. The first tool that
    evolved from this work was called Docker Swarm. As we explained early on, and
    rather confusingly, there are now two things called “Swarm,” both of which come
    from Docker, Inc.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Docker 引擎形式的容器运行时之后，Docker 的工程师们开始解决编排一组独立的 Docker 主机并有效地装载这些主机的容器的问题。从这项工作中演变出来的第一个工具被称为
    Docker Swarm。正如我们之前解释的那样，有些令人困惑的是，现在有两个被称为“Swarm”的东西，都来自 Docker 公司。
- en: The original standalone Docker Swarm is now commonly referred to as [Docker
    Swarm (classic)](https://github.com/docker-archive/classicswarm), but there is
    a second “Swarm” implementation that is more specifically called [Swarm mode](https://docs.docker.com/engine/swarm).
    Instead of being a separate product, this is built into the Docker client. The
    built-in Swarm mode is a lot more capable than the original Docker Swarm and is
    intended to replace it entirely. Swarm mode has the major advantage of not requiring
    you to install anything separately. You already have this clustering capability
    on any of your systems that are running Docker! This is the Docker Swarm implementation
    that we’ll focus on here. Hopefully, now that you know that there have been two
    different Docker Swarm implementations, you won’t get confused by contradictory
    information on the internet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的独立 Docker Swarm 现在通常被称为[Docker Swarm（经典版）](https://github.com/docker-archive/classicswarm)，但是有第二个“Swarm”实现，更具体地称为[Swarm
    模式](https://docs.docker.com/engine/swarm)。这不是一个独立的产品，而是内置在 Docker 客户端中的功能。内置的
    Swarm 模式比原始的 Docker Swarm 能力更强大，意图完全替代它。Swarm 模式的主要优势是不需要您单独安装任何东西。您已经在运行 Docker
    的系统中具备了这种集群功能！这是我们将在这里关注的 Docker Swarm 实现。希望现在您知道有两个不同的 Docker Swarm 实现，您不会被互联网上的矛盾信息所困扰了。
- en: The idea behind Docker Swarm mode is to present a single interface to the `docker`
    client tool but have that interface be backed by a whole cluster rather than a
    single Docker daemon. Swarm is primarily aimed at managing clustered computing
    resources via the Docker tools. It has grown a lot since its first release and
    now contains several scheduler plug-ins with different strategies for assigning
    containers to hosts, and it comes with some basic service discovery built in.
    But it remains only one building block of a more complex solution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 模式背后的理念是向 `docker` 客户端工具呈现一个统一的界面，但这个界面由整个集群支持，而不是单个 Docker 守护程序。Swarm
    主要用于通过 Docker 工具管理集群计算资源。自首次发布以来，它已经有了很大的发展，现在包含多个调度器插件，具有不同的容器分配策略，并且内置了一些基本的服务发现功能。但它仍然只是更复杂解决方案中的一个构建模块。
- en: Swarm clusters can contain one or more managers that act as the central management
    hub for your Docker cluster. It is best to set up an odd number of managers. Only
    one manager will act as the cluster leader at a time. As you add more nodes to
    Swarm, you are merging them into a single, cohesive cluster that can be easily
    controlled with the Docker tooling.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm 集群可以包含一个或多个管理器，它们充当 Docker 集群的中央管理中心。最好设置一个奇数数量的管理器。每次只有一个管理器会充当集群的领导者。当您向
    Swarm 添加更多节点时，您将它们合并成一个统一的集群，可以轻松使用 Docker 工具进行控制。
- en: Let’s get a Swarm cluster up and running. To start, you will need three or more
    Linux servers that can talk to each other over the network. Each of these servers
    should be running recent releases of Docker Community Edition from the official
    Docker software repositories.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个 Swarm 集群。首先，您需要三个或更多可以在网络上相互通信的 Linux 服务器。每个服务器都应该运行来自官方 Docker 软件仓库的最新版本的
    Docker Community Edition。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Refer to [Chapter 3](ch03.html#installing_docker) for details on installing
    the `docker-ce` packages on Linux.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第 3 章](ch03.html#installing_docker)获取关于在 Linux 上安装 `docker-ce` 包的详细信息。
- en: 'For this example, we will use three Ubuntu servers running `docker-ce`. The
    very first thing you’ll need to do is `ssh` to the server that you want to use
    as the Swarm manager, and then run the `swarm init` command using the IP address
    for your Swarm manager:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们将使用三台运行 `docker-ce` 的 Ubuntu 服务器。您需要做的第一件事就是 `ssh` 到您想要用作 Swarm 管理器的服务器上，然后使用
    Swarm 管理器的 IP 地址运行 `swarm init` 命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Warning
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: There are steps that you must take to secure a Docker Swarm mode cluster, which
    we are not covering here. Before you run Docker Swarm mode on any long-lived systems,
    make sure that you understand the options and have taken proper steps to secure
    the environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些步骤是你必须采取的，以便安全地配置Docker Swarm模式集群，这里我们不涉及。在任何长期运行的系统上运行Docker Swarm模式之前，确保你了解选项并采取了适当的措施来保护环境。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In many of this chapter’s examples, you must use the correct IP addresses for
    your manager and worker nodes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的许多示例中，你必须使用正确的IP地址来管理和工作节点。
- en: 'This step will initialize the Swarm manager and give you the token that is
    required for nodes that want to join the cluster. Make note of this token somewhere
    safe, like a password manager. Don’t worry too much if you lose this token; you
    can always get it again by running the following command on the manager:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤将初始化Swarm管理器，并为想要加入集群的节点提供所需的令牌。请将此令牌保存在安全的地方，比如密码管理器中。如果你丢失了这个令牌，也不用太担心；你总可以通过在管理器上运行以下命令再次获取它：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can inspect your progress so far by running your local `docker` client
    pointed at the new manager node’s IP address:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行本地的`docker`客户端，指向新管理节点的IP地址，来检查到目前为止的进展：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also list all of the nodes that are currently in the cluster with the
    following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下命令列出当前集群中的所有节点：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, you can add the two additional servers as workers to the Swarm
    cluster. This is what you’d do in production if you were going to scale up, and
    Swarm makes this pretty easy:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以将这两个额外的服务器添加为Swarm集群的工作节点。如果你要扩展生产环境，Swarm使这变得非常简单：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Adding additional managers is important and can be done as easily as adding
    the workers. You just need to pass in the manager join token instead of the worker
    join token. You can get this token by running `docker swarm join-token manager`
    on any of the active nodes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 添加额外的管理节点很重要，操作与添加工作节点一样简单。你只需传入管理节点加入令牌，而不是工作节点加入令牌。你可以通过在任何活动节点上运行`docker
    swarm join-token manager`来获取此令牌。
- en: 'If you rerun `docker node ls`, you should now see that you have a total of
    three nodes in your cluster, and only one of them is marked as the `Leader`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行`docker node ls`，你现在应该会看到你的集群中总共有三个节点，只有一个节点被标记为`Leader`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is all that’s required to get a Swarm cluster up and running in Swarm mode
    ([Figure 10-1](#figure10-1))!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在Swarm模式下启动和运行Swarm集群所需的全部步骤（[图10-1](#figure10-1)）！
- en: '![Simple Docker Swarm Cluster](assets/dur3_1001.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![简单的Docker Swarm集群](assets/dur3_1001.png)'
- en: Figure 10-1\. Simple Docker Swarm mode cluster
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1\. 简单的Docker Swarm模式集群
- en: 'The next thing you should do is create a network for your services to use.
    There is a default network called `ingress` in Swarm, but it is very easy to create
    additional ones for better isolation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你应该创建一个网络供你的服务使用。Swarm中有一个名为`ingress`的默认网络，但为了更好的隔离，创建额外的网络非常简单：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Up to this point, we’ve just been getting the underlying pieces running, and
    so far we haven’t deployed any real business logic. So let’s launch your first
    service into the cluster. You can do that with a command like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是启动了基本组件，到目前为止我们还没有部署任何实际的业务逻辑。现在让我们将第一个服务部署到集群中。你可以使用如下命令：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The service we’re launching with starts containers that host the [*Quantum game*](https://github.com/stared/quantum-game).
    This is a browser-based puzzle game that uses real quantum mechanics. We hope
    that this is a more interesting example than another Hello World!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动的服务会启动容器，托管[*量子游戏*](https://github.com/stared/quantum-game)。这是一款基于浏览器的解谜游戏，使用真实的量子力学。我们希望这个例子比另一个Hello
    World更有趣！
- en: Warning
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Although we’re using the `latest` tag in many of these examples, you shouldn’t
    ever use this tag in production. It is convenient for this book since we can easily
    push out updates to the code, but this tag floats and cannot be pinned to a specific
    release over a long period. That means if you use `latest`, then your deployments
    are not repeatable! It can also easily lead to a situation where you don’t have
    the same version of an application running on all the servers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在许多示例中我们使用了`latest`标签，但在生产环境中你永远不应该使用这个标签。对于本书来说，使用这个标签非常方便，因为我们可以轻松地更新代码，但这个标签是不稳定的，无法在长时间内固定在特定版本上。这意味着如果你使用`latest`，你的部署将无法重复！它还可能导致一个情况，即在所有服务器上运行的应用程序版本不同。
- en: 'Let’s see where those containers ended up by running `docker service ps` against
    the service name you created:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行`docker service ps`命令来查看那些容器最终在哪里。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Swarm mode uses a routing mesh between the nodes to automatically route traffic
    to a container that can serve the request. When you specify a published port in
    the `docker service create` command, the mesh makes it possible to hit this port
    on any of your three nodes and will route you to the web application. Notice that
    we said any of the *three* nodes even though you only have two instances running.
    Traditionally, you would have also had to set up a separate reverse proxy layer
    to accomplish this, but its batteries are included with Swarm mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm 模式在节点之间使用路由网格自动将流量路由到能够处理请求的容器上。当您在`docker service create`命令中指定一个发布端口时，网格使得可以在三个节点的任何一个上命中这个端口，并将您路由到Web应用程序。请注意，尽管您只运行了两个实例，但我们说的是任何*三*个节点都可以。传统上，您可能还需要设置一个单独的反向代理层来完成这一点，但在Swarm模式中它已经包含在内了。
- en: 'To prove it, you can test the service now by pointing a web browser to the
    IP address of any of your nodes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，您现在可以通过将Web浏览器指向任何一个节点的IP地址来测试服务：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If everything is working as expected, you should see the first puzzle board
    for [the *Quantum Game*](https://quantumgame.io):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，您应该会看到[《量子游戏》](https://quantumgame.io)的第一个拼图板：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This gives us a summary view of the most commonly needed information, but sometimes
    that’s not enough. Docker maintains a lot of other metadata about services, just
    like it does for containers. We can get detailed information about a service with
    `service inspect`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了最常需要的信息的摘要视图，但有时这还不够。就像Docker为容器保留了很多其他元数据一样，它也为服务保留了很多其他详细信息。我们可以使用`service
    inspect`来获取关于服务的详细信息：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is a lot of info here, so let’s point out some of the more important things.
    First, we can see that this is a replicated service with two replicas, just like
    we saw in the `service ls` command. We can also see that Docker is health-checking
    the service at 5-second intervals. Running an update to the service will use the
    `stop-first` method, which means it will take our service first to *N*−1 and then
    spin up a new instance to take us back to *N*. You might want to always run in
    *N*+1 mode so that you are never down a node during updates in production. You
    can change that with the `--update-order=start-first` option to the `service update`
    command. It will exhibit the same behavior in a rollback scenario, and we can
    likewise change that with `--rollback-order=start-first`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多信息，所以让我们指出一些更重要的事情。首先，我们可以看到这是一个具有两个副本的复制服务，就像我们在`service ls`命令中看到的一样。我们还可以看到Docker每隔5秒对服务进行健康检查。运行对服务的更新将使用`stop-first`方法，这意味着它将首先将我们的服务减少到*N*−1，然后启动一个新实例将我们带回*N*。您可能希望始终在*N*+1模式下运行，以便在生产环境中进行更新时不会出现节点宕机。您可以使用`service
    update`命令的`--update-order=start-first`选项来更改这一点。在回滚场景中，它将表现出相同的行为，我们可以使用`--rollback-order=start-first`来同样更改。
- en: 'In a real-world scenario, we not only need to be able to launch our service,
    but we also need to be able to scale it up and down. It would be a shame if we
    had to redeploy it to do that, not to mention it could introduce any number of
    additional issues. Luckily, Swarm mode makes it easy to scale our services with
    a single command. To double the number of instances you have running from two
    to four, you can simply run this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，我们不仅需要能够启动我们的服务，还需要能够对其进行扩展和缩减。如果我们不得不重新部署来完成这些操作，那将是一件很糟糕的事情，更不用说可能会引入任意数量的其他问题了。幸运的是，Swarm模式使得通过一个简单的命令就能轻松扩展我们的服务变得很容易。要将运行的实例数量从两个增加到四个，您只需运行以下命令：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We used `--detach=false` in the previous command so that it was easier to see
    what was happening.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个命令中使用了`--detach=false`，这样更容易看到正在发生的事情。
- en: We can now use `service ps` to show us that Swarm did what we asked. This is
    the same command we ran earlier, but now we should have more copies running! But
    wait, didn’t we ask for more copies than we have nodes?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`service ps`来显示Swarm已经按我们的要求执行了操作。这是我们之前运行的同一个命令，但现在我们应该有更多的副本在运行了！但等等，我们不是要求比节点数更多的副本吗？
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You’ll notice that you have two services running on the same host. Did you expect
    that? This may not be ideal for host resiliency, but by default Swarm will prioritize
    ensuring that you have the number of instances that you requested over spreading
    individual containers across hosts when possible. If you don’t have enough nodes,
    you will get multiple copies on each node. In a real-world scenario, you need
    to think carefully about placement and scaling. You might not be able to get away
    with running multiple copies on the same host when you lose a whole node. Would
    your application still serve users at that reduced scale?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到您在同一台主机上运行了两个服务。您是否预期到了这一点？这对于主机的弹性可能不是理想的选择，但默认情况下，Swarm会优先确保您获得您请求的实例数量，而不是在可能的情况下跨主机分布单个容器。如果节点不足，您将在每个节点上获取多个副本。在实际情况下，当您失去整个节点时，您需要仔细考虑放置和扩展。您的应用程序在减少规模时是否仍然为用户服务？
- en: 'When you need to deploy a new release of your software, you will want to use
    the `docker service update` command. There are a lot of options for this command,
    but here’s one example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要部署软件的新版本时，您将希望使用`docker service update`命令。此命令有很多选项，但以下是一个示例：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running this command will cause Swarm to update your service one container at
    a time, pausing in between each update. Once this is done, you should be able
    to open up the service’s URL in a new private or incognito browsing session (to
    sidestep the browser’s local cache) and see that the game background is now green
    instead of blue.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将导致Swarm逐个更新您的服务容器，在每次更新之间暂停。完成后，您应该能够在新的私人或无痕浏览会话中打开服务的URL（以避开浏览器的本地缓存），并看到游戏背景现在是绿色而不是蓝色。
- en: 'Great, you have now successfully applied an update, but what if something were
    to go wrong? We might need to deploy a previous release to get back to working
    order. You could now roll back to the previous version, with the correct blue
    background, by using the `service rollback` command, which we discussed in passing
    a little bit earlier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，您现在已成功应用了更新，但如果出现问题怎么办？我们可能需要部署先前的版本以恢复工作正常。现在，您可以使用我们之前稍作提到的`service rollback`命令，回滚到先前的版本，正确的蓝色背景如下：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That’s about as nice a rollback mechanism as you could ask for a stateless service.
    You don’t have to keep track of the previous version; Docker does that for you.
    All you need to do is tell it to roll back and it pulls the previous metadata
    out of its internal storage and performs the rollback. Just like during deployment,
    Docker can health-check your containers to make sure the rollback is working correctly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无状态服务来说，这几乎是一个理想的回滚机制。您无需跟踪先前的版本；Docker会为您做这些事情。您只需告诉它回滚，它就会从其内部存储中提取先前的元数据并执行回滚。就像在部署期间一样，Docker可以健康检查您的容器，以确保回滚操作正常工作。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This rollback mechanism will always go back to the last deployed version, so
    if you run it multiple times in a row, it will just flip between two versions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此回滚机制将始终返回到上次部署的版本，因此如果连续多次运行它，它将在两个版本之间切换。
- en: 'Building on `docker service` is a command called `docker stack`, which enables
    you to deploy a specially designed *docker-compose.yaml* file to a Docker Swarm
    mode or Kubernetes cluster. If you go back and check out the Git repo that we
    used in [Chapter 8](ch08.html#docker_compose), we can deploy a modified version
    of that container stack into our current Swarm mode cluster:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`docker service`构建的命令称为`docker stack`，它使您能够将特别设计的*docker-compose.yaml*文件部署到Docker
    Swarm模式或Kubernetes集群中。如果您返回并检查我们在[第8章](ch08.html#docker_compose)中使用的Git存储库，我们可以将该容器堆栈的修改版本部署到当前的Swarm模式集群中：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside that repository is a directory called *stack* that contains a modified
    version of the *docker-compose.yaml* file that we used earlier:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在该存储库内部有一个名为*stack*的目录，其中包含我们之前使用过的*docker-compose.yaml*文件的修改版本：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you wanted to spin up this setup in the Swarm mode cluster, you could run
    the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在Swarm模式集群中启动此设置，可以运行以下命令：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now you can list what stacks are in the cluster and see what services were
    added by the stack:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以列出集群中的堆栈，并查看堆栈添加了哪些服务：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This stack is for basic demonstration purposes and has not been well tested
    for this use case; however, it should give you an idea of how you could assemble
    something similar.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个stack是为基本演示目的而设计的，并没有经过对此用例的充分测试；不过，它应该能让您了解如何组装类似的东西。
- en: You may notice that it takes a while for all the containers to come up and that
    Hubot will continue to restart. This is expected since Rocket.Chat has not been
    configured yet. The Rocket.Chat setup is covered in [Chapter 8](ch08.html#docker_compose).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，所有容器启动需要一些时间，并且 Hubot 将继续重启。这是预期的，因为 Rocket.Chat 还没有配置好。有关 Rocket.Chat
    的设置详见 [第 8 章](ch08.html#docker_compose)。
- en: At this point, you could point your web browser at port 3000 on one of the Swarm
    nodes (e.g., *http://172.17.4.1:3000/* in these examples), and you should see
    the initial setup page for Rocket.Chat.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以将你的网页浏览器指向 Swarm 节点上的 3000 端口（例如，在这些示例中为 *http://172.17.4.1:3000/*），你应该能看到
    Rocket.Chat 的初始设置页面。
- en: 'You can see all the containers that are managed by the stack, with `docker
    stack ps`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看由堆栈管理的所有容器，使用`docker stack ps`：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you are done, you can go ahead and tear down the stack like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成后，可以执行以下命令来销毁这个堆栈：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to immediately spin everything back up, you might get some unexpected
    errors. Just waiting a few moments should fix things while the cluster finishes
    tearing down the old network for the stack, etc.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图立即重新启动所有服务，可能会遇到一些意外错误。只需稍等片刻，等集群完成对旧网络的拆除，问题就会解决。
- en: So, what happens if one of your servers is experiencing an issue and you need
    to take it offline? In this case, you can easily drain all the services off of
    a single node by using the `--availability` option to the `docker node update`
    command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你的其中一台服务器遇到问题需要下线怎么办？在这种情况下，你可以使用`docker node update`命令的`--availability`选项轻松地将单个节点上的所有服务排空。
- en: 'Let’s take a look at the nodes that you have in the cluster again:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看集群中的节点：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s also check where our containers are currently running:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查一下我们的容器目前在哪里运行：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In the previous command, we used a filter so that the output showed only the
    currently running processes. By default, Docker will also show you the previous
    containers that were running in a tree format so that you can see things like
    updates and rollbacks in the output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了一个过滤器，以便输出仅显示当前运行的进程。默认情况下，Docker 还会以树形格式显示先前运行的容器，以便您可以在输出中看到更新和回滚等情况。
- en: 'If you have determined that the server at 172.17.4.3 needs downtime, you could
    drain the tasks of that node and move them to another host by modifying the `availability`
    state to `drain` in Swarm:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定 172.17.4.3 上的服务器需要停机，你可以通过修改 Swarm 中的`availability`状态为`drain`来排空该节点的任务，并将它们迁移到另一台主机：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we inspect the node, we can see that the availability is now set to `drain`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查节点，可以看到可用性现在已设置为`drain`：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You might be wondering what effect that has on the service. We told one of
    the nodes to stop running copies of the service, and they either have to go away
    or migrate somewhere else. What did it do? We can look at the details of our service
    again and see that all the running containers on that host have been moved to
    a different node:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这对服务有什么影响。我们告诉其中一个节点停止运行服务的副本，它们要么消失了，要么迁移到其他地方。它做了什么呢？我们可以再次查看服务的详细信息，看到该主机上的所有运行容器已经移动到另一个节点：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point, it is safe to bring down the node and do whatever work is required
    to make it healthy again. When you are ready to add the node back into the Swarm
    cluster, you can do so by running the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，安全地关闭节点并进行所需的任何工作，使其恢复健康。当你准备好将节点重新添加到 Swarm 集群时，可以运行以下命令：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ll spare you from reinspecting the node at the moment, but you can always
    rerun the `node inspect` command if you want to see what this looks like.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不再检查节点，但如果你想看看这是什么样子，随时可以重新运行`node inspect`命令。
- en: Warning
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When you add a node back to the cluster, containers will not automatically balance!
    However, a new deployment or update should result in the containers being evenly
    spread across the nodes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将节点重新添加到集群时，容器不会自动平衡！不过，新的部署或更新应该会导致容器均匀分布在节点上。
- en: 'Once you are done, you can remove your service and network with the following
    commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成后，可以使用以下命令删除你的服务和网络：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And then verify that they are both indeed completely gone:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后验证它们确实完全消失了：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That’s all for now! At this point, you can safely tear down all of the servers
    that were a part of your Swarm cluster if you no longer need them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前就这些了！此时，如果你不再需要，可以安全地关闭所有作为 Swarm 集群一部分的服务器。
- en: That was kind of a whirlwind tour, but it covers the basics of using Swarm mode
    in Docker Engine and should help get you started building your own Docker clusters
    wherever you might decide to use them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一场风暴之旅，但它涵盖了在Docker Engine中使用Swarm模式的基础知识，并应该帮助你开始构建自己的Docker集群，无论你决定在哪里使用它们。
- en: Kubernetes
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Now let’s take some time to look at Kubernetes. Since its release to the public
    during [DockerCon](https://events.docker.com/events/dockercon) 2014, Kubernetes
    has grown rapidly and is now probably the most widely adopted of the container
    platforms. It is not the oldest or most mature product today—that distinction
    goes to Mesos, which first launched in 2009 before containers were in widespread
    use—but Kubernetes was purpose-built for containerized workloads, has a great
    mix of functionality that is ever evolving, and also enjoys a very strong community
    that includes many early Docker and Linux container adopters. This mix has helped
    significantly increase its popularity over the years. At DockerCon EU 2017, Docker,
    Inc., announced that Kubernetes support will be coming to the Docker Engine tooling
    itself. Docker Desktop is capable of spinning up a single-node Kubernetes cluster,
    and the client can deploy container stacks for development purposes. This provides
    a nice bridge for developers who use Docker locally but deploy to Kubernetes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们花些时间来了解一下Kubernetes。自从2014年[DockerCon](https://events.docker.com/events/dockercon)期间向公众发布以来，Kubernetes迅速发展，现在可能是最广泛采用的容器平台之一。它虽然不是今天最古老或最成熟的产品——这一荣誉归Mesos，它在2009年首次推出，当时容器尚未广泛使用——但Kubernetes是专为容器化工作负载而构建的，具有丰富的功能组合，功能不断发展，并且拥有一个非常强大的社区，包括许多早期的Docker和Linux容器采用者。这种组合在多年来显著增加了其受欢迎程度。在2017年的DockerCon
    EU上，Docker, Inc.宣布Kubernetes支持将会整合到Docker Engine工具本身。Docker Desktop能够快速部署单节点Kubernetes集群，并且客户端可以为开发目的部署容器堆栈。这为那些在本地使用Docker但要部署到Kubernetes的开发人员提供了一个很好的桥梁。
- en: Like Linux itself, Kubernetes is available in several distributions, both free
    and commercial. There is a wide variety of distributions that are available and
    supported to varying degrees. Kubernetes widespread adoption means that it now
    has some pretty nice tooling for local development installations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像Linux本身一样，Kubernetes有几种发行版，包括免费和商业版本。现在有各种各样的发行版可用，并且受到不同程度的支持。Kubernetes的广泛采用意味着现在它有一些非常好的本地开发安装工具。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The Kubernetes coverage in this book is intended to provide some basic guidance
    on how you can integrate your Linux container workflow with Kubernetes, but we
    do not go into a lot of detail about the Kubernetes ecosystem here. We highly
    recommend reading [*Kubernetes: Up & Running*, by Brendan Burns et al. (O’Reilly)](https://www.oreilly.com/library/view/kubernetes-up-and/9781098110192),
    or any of the other great materials out there to familiarize yourself with all
    the relevant concepts and terminology.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '本书中关于Kubernetes的覆盖旨在提供一些关于如何将你的Linux容器工作流与Kubernetes集成的基本指导，但我们在这里不会详细介绍Kubernetes生态系统。我们强烈推荐阅读[*Kubernetes:
    Up & Running*, 作者是Brendan Burns等人（O’Reilly）](https://www.oreilly.com/library/view/kubernetes-up-and/9781098110192)，或者其他一些优秀的资料，以熟悉所有相关的概念和术语。'
- en: Minikube
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Minikube
- en: Minikube was one of the original tools for managing a local Kubernetes installation
    and is the first one that we will be focusing on here. Most of the concepts that
    you’ll learn while working with Minikube can be applied to any Kubernetes implementation,
    including the options that we’ll discuss after Minikube, so it’s a great place
    to start.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube是最早用于管理本地Kubernetes安装的工具之一，也是我们将在这里重点介绍的第一个工具。在使用Minikube时学到的大部分概念可以应用于任何Kubernetes实现，包括我们将在Minikube之后讨论的选项，因此这是一个很好的起点。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There are many other options for running a local Kubernetes cluster. We are
    starting with `minikube` because the container or VM that it spins up is a pretty
    standard single-node Kubernetes install. In addition to the tools that we will
    be discussing in this section, we highly recommend exploring [k3s](https://k3s.io),
    [k3d](https://k3d.io), [k0s](https://k0sproject.io), and [microk8s](https://microk8s.io)
    as well.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本地Kubernetes集群的其他选项有很多。我们从`minikube`开始，因为它所生成的容器或虚拟机是一个标准的单节点Kubernetes安装。除了本节中将讨论的工具之外，我们强烈推荐探索[k3s](https://k3s.io)、[k3d](https://k3d.io)、[k0s](https://k0sproject.io)和[microk8s](https://microk8s.io)。
- en: What Is Minikube?
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是Minikube？
- en: 'Minikube is a whole distribution of Kubernetes for a single instance. It manages
    a container or VM on your computer that presents a working Kubernetes installation
    and allows you to use all the same tooling that you would use in a production
    system. In scope, it’s a little bit like Docker Compose: it will let you stand
    up a whole stack locally. It goes one step further than Compose, though, in that
    it has all the production APIs. As a result, if you run Kubernetes in production,
    you can have an environment on your desktop that is reasonably close in function,
    if not in scale, to what you are running in production.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube是Kubernetes的一个完整分发版本，用于单个实例。它管理你计算机上的一个容器或虚拟机，提供一个可用的Kubernetes安装，并允许你使用与生产系统相同的所有工具。从范围上讲，它有点像Docker
    Compose：它允许你在本地启动一个完整的堆栈。不过，它比Compose更进一步，因为它具有所有的生产API。因此，如果你在生产中运行Kubernetes，你可以在你的桌面上拥有一个在功能上相对接近，虽然不是在规模上相同的环境。
- en: Minikube is fairly unique in that all of the distribution is controlled from
    a single binary you download and run locally. It will automatically detect which
    containerization or VM manager you have locally and will set up and run a container
    or VM with all of the necessary Kubernetes services in it. That means getting
    started with it is pretty simple.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube相当独特，因为所有的分发都受一个单独的二进制文件控制，你下载并在本地运行它。它会自动检测你本地的容器化或虚拟机管理器，并设置和运行一个包含所有必要Kubernetes服务的容器或虚拟机。这意味着开始使用它非常简单。
- en: So let’s install it!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们安装它！
- en: Installing Minikube
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Minikube
- en: Most of the installation is the same across all platforms because once you have
    the tools installed, they will be your gateway to the VM running your Kubernetes
    installation. To get started, just skip to the section that applies to your operating
    system. Once you have the tool up and running, you can follow the shared documentation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数安装在所有平台上都是相同的，因为一旦你安装了工具，它们将是你访问运行Kubernetes安装的虚拟机的入口。要开始，请直接跳转到适用于你操作系统的部分。一旦你启动并运行了工具，你就可以按照共享的文档进行操作了。
- en: 'We need two tools to use Minikube effectively: `minikube` and `kubectl`. For
    our simple installation, we’re going to leverage the fact that both of these commands
    are static binaries with no outside dependencies, which makes them easy to install.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效使用Minikube，我们需要两个工具：`minikube` 和 `kubectl`。对于我们简单的安装过程，我们将利用这两个命令都是静态二进制文件且没有外部依赖的事实，这使得它们易于安装。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are several other ways to install Minikube. We’re going to show you what
    we think is the simplest path on each platform. If you have strong preferences
    about how to install these applications, feel free to use your preferred approach.
    On Windows, for example, you might prefer to use the [Chocolatey package manager](https://chocolatey.org),
    or the [Snap package system](https://snapcraft.io) on Linux.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Minikube还有几种其他方法。我们将展示在每个平台上我们认为是最简单的路径。如果你对如何安装这些应用程序有强烈的偏好，请随意使用你喜欢的方法。例如，在Windows上，你可能更喜欢使用[Chocolatey包管理器](https://chocolatey.org)，或者在Linux上使用[Snap包系统](https://snapcraft.io)。
- en: macOS
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: 'Just as in [Chapter 3](ch03.html#installing_docker), you will need to have
    Homebrew installed on your system. If you don’t, go back to [Chapter 3](ch03.html#installing_docker)
    and make sure you have it set up. Once you do, it’s trivial to install the `minikube`
    client:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第三章](ch03.html#installing_docker)中一样，你需要在你的系统上安装Homebrew。如果没有，请回到[第三章](ch03.html#installing_docker)并确保你已经设置好了。一旦你做到了，安装`minikube`客户端就非常简单：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will cause Homebrew to download and install Minikube. It will look something
    like this depending, on your configuration:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致Homebrew下载并安装Minikube。根据你的配置，它会看起来像这样：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That’s it! Let’s test to make sure it’s in your path:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是了！让我们测试一下，确保它在你的路径中：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Homebrew on *arm64* systems install into */opt/homebrew/bin* instead of */usr/local/bin*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在*arm64*系统上，Homebrew安装到*/opt/homebrew/bin*而不是*/usr/local/bin*。
- en: If you don’t get a response, you will need to make sure you have */usr/local/bin*
    and */opt/homebrew/bin* in your `PATH` environment variable. Assuming that passes,
    you now have the `minikube` tool installed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有得到响应，你需要确保你的`PATH`环境变量中包含*/usr/local/bin*和*/opt/homebrew/bin*。假设通过了，现在你已经安装了`minikube`工具。
- en: '`kubectl` should have been automatically installed since it is a dependency
    of `minikube`, but you can also do it explicitly with `brew` as well. Generally,
    the version of `kubectl` in Homebrew will match the current release of `minikube`,
    so using `brew install` should help prevent mismatches:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`应该已经自动安装了，因为它是`minikube`的一个依赖项，但你也可以使用`brew`显式地安装它。通常情况下，Homebrew中的`kubectl`版本将与当前`minikube`的发布版本匹配，因此使用`brew
    install`应该有助于避免不匹配：'
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll test that the same way we tested `minikube`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像测试`minikube`一样测试它：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’re good to go!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪！
- en: Windows
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: As with installing Docker Desktop on Windows, you may want to install Hyper-V
    or another supported virtualization platform to run a Kubernetes VM. To install
    `minikube`, you simply download the binary and put it in a place you have in your
    `PATH` so that you can execute it on the command line. You can download the [most
    recent release of `minikube` from GitHub](https://github.com/kubernetes/minikube/releases/latest).
    You’ll want to rename the Windows executable that you download to *minikube.exe*;
    otherwise, you’ll be doing a lot more typing than you probably want!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与在Windows上安装Docker Desktop一样，你可能想要安装Hyper-V或另一个支持的虚拟化平台来运行Kubernetes VM。要安装`minikube`，你只需下载二进制文件并将其放置在你的`PATH`中的一个位置，以便你可以在命令行上执行它。你可以从GitHub上下载[minikube的最新发布版本](https://github.com/kubernetes/minikube/releases/latest)。你会想要将你下载的Windows可执行文件重命名为*minikube.exe*，否则你可能需要进行比你想象中更多的输入！
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can find more details about the Windows install process and that binary
    executable from the [Minikube install documentaton](https://minikube.sigs.k8s.io/docs/start).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Minikube安装文档](https://minikube.sigs.k8s.io/docs/start)中找到有关Windows安装过程和该二进制可执行文件的更多详细信息。
- en: 'You then need to get the latest Kubernetes CLI tool, `kubectl`, to interact
    with your distribution. Unfortunately, there is not a */latest* path for downloading
    that. So, to make sure you have the latest version, you need to [get the latest
    version](https://storage.googleapis.com/kubernetes-release/release/stable.txt)
    from the website and then plug it into a URL, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要获取最新的Kubernetes CLI工具`kubectl`来与你的分发版交互。不幸的是，没有一个*/latest*路径用于下载它。因此，为了确保你有最新版本，你需要从网站上[获取最新版本](https://storage.googleapis.com/kubernetes-release/release/stable.txt)，然后将其插入到URL中，就像这样：
- en: '*https://storage.googleapis.com/kubernetes-release/release/<VERSION>/bin/windows/amd64/kubectl.exe*.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*https://storage.googleapis.com/kubernetes-release/release/<VERSION>/bin/windows/amd64/kubectl.exe*.'
- en: Once you’ve downloaded that, you again need to make sure it’s accessible from
    your `PATH` to make the rest of our exploration easier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，你需要确保它可以从你的`PATH`中访问，以便于后续的探索工作。
- en: Linux
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: 'On Linux, you will want to have Docker installed and should consider installing
    either KVM (Linux’s Kernel-based Virtual Machine) or VirtualBox so that `minikube`
    can create and manage a Kubernetes VM for you. Because `minikube` is just a single
    binary, once you have it installed, there is no need to install any additional
    packages. And, because `minikube` is a statically linked binary, it should pretty
    much work on any distribution you want to run it on. Although we could do all
    the installation in a one-liner, we are going to break it up into a few steps
    to make it easier to understand and troubleshoot. Note that at the time of this
    writing, the binary is hosted on *googleapis*, which usually maintains very stable
    URLs. So, here we go:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，你需要安装Docker，并考虑安装KVM（Linux的基于内核的虚拟机）或VirtualBox，这样`minikube`就可以为你创建和管理一个Kubernetes虚拟机。因为`minikube`只是一个单一的二进制文件，一旦安装了它，就不需要安装任何其他包。而且，由于`minikube`是一个静态链接的二进制文件，它应该可以在你想要运行它的任何发行版上工作。尽管我们可以将所有安装工作放在一行中进行，但我们将其分解成几个步骤，以便更容易理解和排查故障。请注意，在撰写本文时，二进制文件托管在*googleapis*上，通常会保持非常稳定的URL。所以，我们开始吧：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You’ll need to make sure that */usr/local/bin* is in your path. Now that we
    have `minikube`, we also need to fetch `kubectl`, which we can do like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保*/usr/local/bin*在你的路径中。既然我们已经有了`minikube`，我们还需要获取`kubectl`，我们可以这样做：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One of the URLs in the example has been continued on the following line so that
    it fits in the margins. You may find that you need to reassemble the URL and remove
    the backslashes for the command to work properly in your environment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的一个URL已经延续到下一行，以适应页面的边界。你可能需要重新组装URL并删除反斜杠，以使命令在你的环境中正常工作。
- en: That’s it for installation—we’re ready to go.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成，我们已经准备好了。
- en: Running Kubernetes
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行Kubernetes
- en: Now that we have the `minikube` tool, we can use it to bootstrap our Kubernetes
    cluster. This is normally pretty straightforward. You usually don’t need to do
    any configuration beforehand. In this example, you will see that `minikube` decided
    to use the *docker driver*, although there are others that could be selected.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`minikube`工具，可以用它来启动我们的 Kubernetes 集群。这通常相当简单。通常情况下，您不需要事先进行任何配置。在这个例子中，您会看到`minikube`决定使用*docker
    driver*，尽管还有其他可以选择的驱动程序。
- en: 'To start `minikube`, go ahead and run the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`minikube`，请继续运行以下命令：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So what did we just do? Minikube packs a lot into that one command. In this
    case, we launched a single Linux container that is providing us a functioning
    Kubernetes installation on our local system. If we had used one of the virtualization
    drivers with `minikube`, then we would have created a complete VM running Kubernetes
    instead on a single container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们刚刚做了什么？Minikube 在一个命令中包含了很多内容。在这种情况下，我们启动了一个单独的 Linux 容器，在我们的本地系统上提供了一个功能齐全的
    Kubernetes 安装。如果我们使用了`minikube`的虚拟化驱动程序之一，那么我们将在单个容器上创建一个运行 Kubernetes 的完整虚拟机，而不是一个完整的
    VM。
- en: 'It then runs all of the necessary components of Kubernetes inside Linux containers
    on the host. You can easily explore the `minikube` container or VM to see what
    you got:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它随后在主机上的 Linux 容器内运行 Kubernetes 的所有必要组件。您可以轻松探索`minikube`容器或VM，看看您得到了什么：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On your Kubernetes cluster, you probably won’t be using SSH to get into the
    command line that often. But we want to see what’s installed and get a handle
    on the fact that when we run `minikube`, we’re controlling an environment that
    is running many processes. Let’s take a look at what is running on the Docker
    instance on our Kubernetes cluster:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Kubernetes 集群上，您可能不经常使用 SSH 进入命令行。但是我们想要查看安装了什么，并了解到当我们运行`minikube`时，我们正在控制运行许多进程的环境。让我们看看在我们的
    Kubernetes 集群上 Docker 实例上正在运行什么：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We won’t dive too much into what each component is, but by now you should hopefully
    see how the mechanism works. Also, it’s pretty easy to upgrade the components
    since they are just containers, are versioned, and can be pulled from an upstream
    container repository.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨每个组件是什么，但是现在您应该可以看到机制是如何工作的了。此外，由于这些组件只是容器，具有版本控制，并且可以从上游容器存储库中拉取，因此升级这些组件也非常容易。
- en: 'Go ahead and exit the shell that you have on the Minikube system:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续退出您在 Minikube 系统上的 shell：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: minikube commands
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: minikube 命令
- en: In the interest of space and time, we won’t go through all of the commands for
    `minikube`. We encourage you to run it without any options, take a look at the
    output, and play around with what’s available. That being said, let’s take a quick
    look at some of the most interesting commands. We’ll cover a few more later in
    the course of installing an application stack, but here’s a quick survey.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 出于空间和时间的考虑，我们不会列出所有`minikube`命令。我们鼓励您在不使用任何选项的情况下运行它，查看输出并尝试使用可用的功能。话虽如此，让我们快速浏览一些最有趣的命令。在安装应用程序堆栈的过程中，我们稍后会涵盖更多内容，但是这里有一个快速概述。
- en: 'To see what was going on inside the system, earlier we used `minikube ssh`,
    which is great for debugging or inspecting the system directly. Without directly
    accessing the Minikube system, we can always check on the cluster status using
    another `minikube` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看系统内部发生了什么，我们之前使用了`minikube ssh`，这对于直接调试或检查系统非常有用。如果没有直接访问 Minikube 系统，我们始终可以使用另一个`minikube`命令检查集群状态：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This shows us that everything is looking good. Two other useful commands include:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示我们的一切看起来都很好。另外两个有用的命令包括：
- en: '| Command | Action |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Command | Action |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `minikube ip` | Retrieve the IP address of the Minikube VM. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `minikube ip` | 检索 Minikube VM 的 IP 地址。 |'
- en: '| `minikube update-check` | Check your version of Minikube against the most
    recent release. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `minikube update-check` | 检查您的 Minikube 版本是否与最新版本兼容。 |'
- en: To apply an upgrade, you can simply use the same mechanism you used to install
    it originally.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用升级，您只需使用与最初安装相同的机制。
- en: Critically, the `minikube status` command also shows us that the `kubeconfig`
    is properly configured. We will need this so that `kubectl` knows how to connect
    to our cluster.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 至关重要的是，`minikube status`命令还向我们显示`kubeconfig`已正确配置。我们将需要它来让`kubectl`知道如何连接到我们的集群。
- en: We started the Kubernetes cluster with `minikube start`. As you might expect,
    following the style of Docker CLI arguments, `minikube stop` will stop all the
    Kubernetes components and the Linux container or VM. To completely clean up your
    environment, you can also delete the cluster by running `minikube delete`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`minikube start`启动了Kubernetes集群。正如您所期望的那样，遵循Docker CLI参数的风格，`minikube stop`将停止所有Kubernetes组件和Linux容器或虚拟机。要完全清理您的环境，您也可以通过运行`minikube
    delete`来删除集群。
- en: Kubernetes Dashboard
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes仪表板
- en: Now that we have Minikube up and running, we don’t just have the command-line
    tools to interact with; we have a whole Kubernetes Dashboard installed that we
    can explore. We can reach it via the `minikube dashboard` command. Go ahead and
    run that—it should launch your web browser pointed to the correct IP address and
    port of the Kubernetes Dashboard! There is a lot of stuff on the dashboard, and
    we’re not able to cover it all, but feel free to click around and explore. Depending
    on your previous exposure to Kubernetes, some of the terms in the dashboard’s
    sidebar will be familiar to you, but many of them may be completely foreign. If
    you don’t have a computer in front of you, [Figure 10-2](#figure10-2) shows a
    screenshot of what an empty Minikube installation looks like from the Service
    link in the dashboard sideboard.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动并运行了Minikube，我们不仅可以使用命令行工具进行交互，还安装了一个完整的Kubernetes仪表板供我们探索。我们可以通过`minikube
    dashboard`命令访问它。请继续运行它——它应该会在您的Web浏览器中打开指向Kubernetes仪表板的正确IP地址和端口！仪表板上有很多内容，我们无法覆盖所有内容，但请随意点击并探索。根据您之前对Kubernetes的接触经验，仪表板侧边栏中的一些术语可能对您来说很熟悉，但其中许多可能完全陌生。如果您没有电脑在身边，[图 10-2](#figure10-2)显示了在仪表板侧栏的服务链接中看到的空Minikube安装的屏幕截图。
- en: '![Kubernetes Dashboard](assets/dur3_1002.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes仪表板](assets/dur3_1002.png)'
- en: Figure 10-2\. Kubernetes Dashboard (example)
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. Kubernetes仪表板（示例）
- en: If you explore the Nodes link under Cluster in the left sidebar, you should
    see a single node in the cluster, named `minikube`. This is the container or VM
    that we started, and the dashboard, like the other components, is hosted in one
    of the containers we saw when we connected to the Minikube system earlier. We’ll
    take another look at the dashboard when we’ve deployed something into our cluster.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在左侧边栏的集群下面的Nodes链接中探索，您应该会看到集群中的单个节点，名为`minikube`。这是我们启动的容器或虚拟机，而仪表板，就像其他组件一样，是托管在我们之前连接到Minikube系统时看到的其中一个容器中的。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Kubernetes exposes almost everything that you see on the dashboard with the
    `kubectl` command as well, which makes it very scriptable with shell scripts.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes通过`kubectl`命令暴露了几乎所有在仪表板上看到的内容，这使得它非常适合使用shell脚本进行脚本化。
- en: For example, running `kubectl get services` or `kubectl get nodes` should show
    you the same information that you can see on the dashboard.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行`kubectl get services`或`kubectl get nodes`应该会显示与您在仪表板上看到的相同的信息。
- en: While clicking around, you may notice that Kubernetes itself shows up as a component
    inside the system, just like your applications will.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览时，您可能会注意到Kubernetes本身显示为系统中的一个组件，就像您的应用程序一样。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to type Ctrl-C to exit the `minikube dashboard` process and return
    to your terminal prompt.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要键入Ctrl-C来退出`minikube dashboard`进程并返回到您的终端提示符。
- en: Kubernetes containers and pods
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes容器和Pod
- en: Now that we have a Kubernetes cluster up and running, and you’ve seen how easy
    that is to do locally, we need to pause to talk about a concept that Kubernetes
    adds on top of the container abstraction. Kubernetes came out of the experiences
    that Google had running its massive platform. Google encountered most of the situations
    you might see in a production platform and had to work out concepts to make it
    easier to understand and solve the kinds of problems you run into when managing
    a large installation. In doing so, Google created a complex set of new abstractions.
    Kubernetes embraces many of these and thus has a whole vocabulary unto itself.
    We won’t try to get into all of these, but it’s important to understand the most
    central of these new abstractions—​a concept that sits a layer above the container
    and is known as a *pod*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搭建并运行了一个 Kubernetes 集群，并且您已经看到在本地执行此操作有多么简单，我们需要停下来讨论 Kubernetes 在容器抽象之上增加的一个概念。Kubernetes
    出自 Google 运行其庞大平台的经验。Google 遇到了几乎所有可能出现在生产平台中的情况，并且不得不解决管理大规模安装时遇到的各种问题。在这个过程中，Google
    创建了一套复杂的新抽象概念。Kubernetes 采纳了其中许多概念，因此有着自己的完整术语表。我们不打算深入所有这些内容，但理解其中最核心的新抽象概念至关重要——这个概念位于容器之上的层次，被称为
    *pod*。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The term *pod* came about because the Docker mascot is Moby, the whale, and
    a group of whales is called a *pod*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pod* 这个术语的来源是因为 Docker 的吉祥物是鲸鱼 Moby，而鲸鱼的群体被称为 *pod*。'
- en: In Kubernetes parlance, a pod is one or more containers sharing the same cgroups
    and namespaces. You can also isolate the containers themselves from one another
    inside the same pod using cgroups and namespaces. A pod is intended to encapsulate
    all of the processes or applications that need to be deployed together to create
    a functioning unit, which the scheduler can then manage. All of the containers
    in the pod can talk to one another on `localhost`, which eliminates any need to
    discover one another. So why not just deploy a big container with all the applications
    inside it? The advantage of a pod over a massive container is that you can still
    resource-limit the individual application separately and leverage the large library
    of public Linux containers to construct your application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 的术语中，一个 **pod** 是一个或多个共享相同 cgroups 和命名空间的容器。您还可以使用 cgroups 和命名空间将同一
    pod 内的容器彼此隔离。Pod 的目的是封装所有需要一起部署以创建一个功能单元的进程或应用程序，调度器随后可以管理这些单元。Pod 中的所有容器可以在 `localhost`
    上彼此通信，这消除了彼此发现的任何需求。那么，为什么不只部署一个包含所有应用程序的大容器呢？与大容器相比，Pod 的优势在于您仍然可以单独限制每个应用程序的资源，并利用公共
    Linux 容器库来构建您的应用程序。
- en: Additionally, Kubernetes administrators often leverage the pod abstraction to
    have a container run on pod startup to make sure things are configured properly
    for the others, to maintain a shared resource, or to announce the application
    to others, for example. This allows you to make finer-grained containers than
    you might if you have to group things into the same container. Another nice part
    of the pod abstraction is the ability to share mounted volumes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，Kubernetes 管理员经常利用 pod 抽象，在 pod 启动时让一个容器运行，以确保其他容器的配置正确，维护共享资源或向其他人通告应用程序等。这使您可以比将所有内容组合到同一个容器中更精细地管理容器。Pod
    抽象的另一个好处是能够共享挂载卷。
- en: 'Pods have a life span much like a Linux container. They are essentially ephemeral
    and can be redeployed to new hosts according to the lifecycle of the application
    or the host it runs on. Containers in a pod even share the same IP address when
    facing the outside world, which means they look like a single entity from the
    network level. Just as you would run only one instance of an application per container,
    you generally run one instance of a given container inside a pod. The easiest
    way to think about pods is that they are a group of Linux containers that work
    together as if they were one container, for most purposes. If you need only one
    container, then you still get a pod deployed by Kubernetes, but that pod contains
    only one container. The nice thing about this is that there is only one abstraction
    as far as the Kubernetes scheduler is concerned: the pod. Containers are managed
    by some of the runtime pieces that construct the pod and also by the configuration
    that you use to define them.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: pod 的生命周期很像 Linux 容器。它们基本上是暂时的，并且根据应用程序或其运行的主机的生命周期可以重新部署到新主机上。在面向外部世界时，pod
    中的容器甚至共享相同的 IP 地址，这意味着它们在网络级别看起来像一个单一实体。就像你每个容器只运行一个应用程序实例一样，你通常在一个 pod 内运行给定容器的一个实例。想要简单理解
    pod 的最简单方法是，它们是一组 Linux 容器，它们一起工作，就像它们是一个容器一样，多数情况下。如果只需要一个容器，那么你仍然会得到一个由 Kubernetes
    部署的 pod，但该 pod 只包含一个容器。这样做的好处是，从 Kubernetes 调度程序的角度来看，只有一个抽象：pod。容器由构建 pod 的运行时组件以及你用来定义它们的配置管理。
- en: One critical difference between a pod and a container is that you don’t construct
    pods in a build step. They are a runtime abstraction that is defined in a JSON
    or YAML manifest and lives only inside Kubernetes. So you build your Linux containers
    and send them to a registry, then define and deploy your pods using Kubernetes.
    In reality, you don’t usually directly describe a pod either; the tools generate
    it for you through the concept of a deployment. But the pod is the unit of execution
    and scheduling in a Kubernetes cluster. There is a lot more to it, but that’s
    the basic concept, and it’s probably easiest to understand with a simple example.
    The pod abstraction is more complicated than thinking of your system in terms
    of individual containers, but it can be pretty powerful.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: pod 和容器之间的一个关键区别是，你不会在构建步骤中构建 pod。它们是一个运行时的抽象，在 JSON 或 YAML 清单中定义，并且仅存在于 Kubernetes
    内部。因此，你构建你的 Linux 容器并将它们发送到注册表，然后使用 Kubernetes 定义和部署你的 pods。实际上，你通常也不会直接描述一个 pod；工具会通过部署的概念为你生成它。但是
    pod 是 Kubernetes 集群中执行和调度的单位。这其中还有很多内容，但这是基本概念，通过一个简单的例子可能更容易理解。pod 的抽象比以个别容器的形式思考你的系统更复杂，但它确实非常强大。
- en: Let’s deploy something
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让我们部署一些东西
- en: When working with pods in Kubernetes, we usually manage them through the abstraction
    of a *deployment*. A deployment is just a pod definition with some additional
    information, including health monitoring and replication configuration. It contains
    the definition of the pod and a little metadata about it. So let’s look at a basic
    deployment and get it running.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Kubernetes 中处理 pod 时，我们通常通过*部署*的抽象来管理它们。部署只是一个 pod 定义，带有一些额外的信息，包括健康监控和复制配置。它包含了
    pod 的定义以及一些关于它的元数据。所以让我们看一个基本的部署，并让它运行起来。
- en: The simplest thing we can deploy on Kubernetes is a pod that contains just one
    container. We are going to use the [`httpbin`](https://httpbin.org) application
    to explore the basics of deployment on Kubernetes, and we’ll call our deployment
    `hello-minikube`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上可以部署的最简单的东西是一个只包含一个容器的 pod。我们将使用[`httpbin`](https://httpbin.org)
    应用程序来探索 Kubernetes 上部署的基础知识，并将我们的部署命名为 `hello-minikube`。
- en: 'We’ve used the `minikube` command, but to get things done on Kubernetes itself,
    we now need to leverage the `kubectl` command we installed earlier:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾使用过 `minikube` 命令，但要在 Kubernetes 上完成任务，我们现在需要利用之前安装的 `kubectl` 命令：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To see what that did for us, we can use the `kubectl get all` command to list
    the most important objects that are now in our cluster:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它对我们的影响，我们可以使用 `kubectl get all` 命令来列出现在我们集群中最重要的对象：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With that one command, Kubernetes created a deployment, a ReplicaSet to manage
    scaling, and a pod. We want to ensure that our pod shows a `STATUS` of `Running`.
    If yours isn’t, just wait and run the command a couple more times until you see
    the status change. The `service/kubernetes` entry is a running service that represents
    Kubernetes itself. But where is our service? We can’t get to it yet. It’s essentially
    in the same state a Linux container would be if you didn’t tell it to expose any
    ports. So we need to tell Kubernetes to do that for us:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，Kubernetes 创建了一个部署，一个 ReplicaSet 来管理扩展，以及一个 pod。我们希望确保我们的 pod 显示 `STATUS`
    为 `Running`。如果你的 pod 没有运行，请耐心等待并运行几次命令，直到看到状态变化。`service/kubernetes` 条目是代表 Kubernetes
    本身的正在运行的服务。但是我们的服务在哪里？我们还不能到达它。实质上，它处于 Linux 容器的相同状态，如果你没有告诉它暴露任何端口的话。因此，我们需要告诉
    Kubernetes 为我们做这件事：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This has now created a service we can reach and interact with. A *service*
    is a wrapper for one or more deployments of an application and can tell us how
    to contact the application. In this case, we get a `NodePort`, which exposes a
    port on every node in the cluster that will be routed to the underlying pods.
    Let’s get Kubernetes to tell us how to get to it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这已经创建了一个我们可以访问和交互的服务。*服务* 是一个应用程序的一个或多个部署的包装器，并可以告诉我们如何联系该应用程序。在这种情况下，我们得到一个
    `NodePort`，它在集群中的每个节点上暴露一个端口，可以路由到底层的 pods。让我们让 Kubernetes 告诉我们如何到达它：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You might think you could now connect to *http://10.105.184.177:8080* to get
    to our service. But those addresses are not reachable from your host system because
    of the container or VM in which Minikube is running. So we need to get `minikube`
    to tell us where to find the service:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为现在可以连接到 *http://10.105.184.177:8080* 来访问我们的服务。但是由于 Minikube 运行的容器或虚拟机的原因，这些地址无法从您的主机系统访问。因此，我们需要让
    `minikube` 告诉我们在哪里找到这个服务：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'In some configurations, you may see a message like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些配置中，您可能会看到这样的消息：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This indicates that transparently wiring the networking from your host to the
    Kubernetes services is not possible at the moment, and you will need to leave
    the command running while you explore your application. You can use a local web
    browser or open up another terminal to run commands like `curl`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明从主机到 Kubernetes 服务的网络透明地连线目前不可能，而且在探索应用程序时，您需要保持命令的运行。您可以使用本地的 Web 浏览器或打开另一个终端来运行诸如
    `curl` 的命令。
- en: When you are done, you can type Ctrl-C in the original terminal session to kill
    the `minikube service` command.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成时，您可以在原始终端会话中键入 Ctrl-C 来终止 `minikube service` 命令。
- en: 'The nice thing about this command, like many of the other Kubernetes commands,
    is that it is scriptable and command-line friendly under normal circumstances.
    If we want to open it with `curl` on the command line, we can often just include
    the `minikube` command call in our request:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的好处，像许多其他 Kubernetes 命令一样，在正常情况下它是可脚本化和命令行友好的。如果我们想要在命令行上用 `curl` 打开它，通常只需在我们的请求中包含
    `minikube` 命令调用即可：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`httpbin` is a simple HTTP request and response API that can be used to test
    and confirm HTTP services. Not the world’s most exciting application, but you
    can see that we are able to contact our service and get a response back from it
    via `curl`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpbin` 是一个简单的 HTTP 请求和响应 API，可用于测试和确认 HTTP 服务。虽然不是世界上最令人兴奋的应用程序，但可以看到我们能够通过
    `curl` 联系到我们的服务并从中获取响应。'
- en: 'This is the simplest use case. We didn’t configure much and relied on Kubernetes
    to do the right thing using its defaults. In the next step, we’ll take a look
    at something more complicated. But first, let’s shut down our new service and
    deployment. It takes two commands to do that: one to remove the service and the
    other to delete it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的用例。我们没有进行太多配置，依赖 Kubernetes 使用其默认设置。在下一步中，我们将查看更复杂的内容。但首先，让我们关闭我们的新服务和部署。这需要两个命令：一个用于移除服务，另一个用于删除它：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Deploying a realistic stack
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署一个现实的堆栈
- en: Let’s now deploy something that looks more like a production stack. We’ll deploy
    an application that can fetch PDF documents from an S3 bucket, cache them on disk
    locally, and rasterize individual pages to PNG images on request, using the cached
    document. To run this application, we’ll want to write our cache files somewhere
    other than inside the container. We want to have them go somewhere a little more
    permanent and stable. And this time we want to make things repeatable so that
    we’re not deploying our application through a series of CLI commands that we need
    to remember and hopefully get right each time. Kubernetes, much like Docker Compose,
    lets us define our stack in one or more YAML files that contain all of the definitions
    we care about in one place. This is what you want in a production environment
    and is similar to what you’ve seen for the other production tools.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们部署一个更接近生产环境的东西。我们将部署一个应用程序，该应用程序可以从 S3 存储桶中获取 PDF 文档，在本地磁盘上缓存它们，并根据请求将单个页面转换为
    PNG 图像，使用缓存的文档。为了运行这个应用程序，我们希望将缓存文件写入容器之外的某个地方。我们希望它们放在一个更加永久和稳定的地方。这一次，我们希望能够重复操作，这样我们就不需要通过一系列需要记住并希望每次都能正确执行的命令来部署我们的应用程序。Kubernetes，与
    Docker Compose 类似，让我们能够在一个或多个 YAML 文件中定义我们的堆栈，这些文件包含我们关心的所有定义。这是您在生产环境中所需的，并且类似于您在其他生产工具中看到的内容。
- en: 'The service we’ll now create will be called `lazyraster` (as in “rasterize
    on demand”), and each time you see that in the YAML definition, you’ll know we’re
    referring to our application. Our persistent volume will be called `cache-data`.
    Again, Kubernetes has a huge vocabulary that we can’t entirely address here, but
    to make it clear what we’re looking at, we need to introduce two more concepts:
    `PersistentVolume` and `PersistentVolumeClaim`. A `PersistentVolume` is a physical
    resource that we provision inside the cluster. Kubernetes has support for many
    kinds of volumes, from local storage on a node to [Amazon Elastic Block Store
    (Amazon EBS) volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEBS.html)
    on AWS and similar on other cloud providers. It also supports [Network File System
    (NFS)](https://en.wikipedia.org/wiki/Network_File_System) and other more modern
    network filesystems. A `PersistentVolume` stores data with a lifecycle that is
    independent of our application or deployments. This lets us store data that persists
    between application deployments. For our cache, that’s what we’ll use. A `PersistentVolumeClaim`
    is a link between the physical resource of the `PersistentVolume` and the application
    that needs to consume it. We can set a policy on the claim that allows either
    a single read/write claim or many read claims. For our application we just want
    a single read/write claim to our `cache-data` `PersistentVolume`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建的服务将被称为`lazyraster`（即“按需光栅化”），每当您在 YAML 定义中看到它时，您将知道我们指的是我们的应用程序。我们的持久卷将被称为`cache-data`。同样，Kubernetes
    拥有一个我们无法完全涵盖的庞大词汇表，但为了清楚地说明我们正在查看的内容，我们需要介绍另外两个概念：`PersistentVolume` 和 `PersistentVolumeClaim`。`PersistentVolume`
    是我们在集群内部署的物理资源。Kubernetes 支持多种类型的卷，从节点上的本地存储到 AWS 上的 [Amazon Elastic Block Store
    (Amazon EBS) volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEBS.html)
    和其他云提供商上的类似卷，还支持 [Network File System (NFS)](https://en.wikipedia.org/wiki/Network_File_System)
    和其他更现代的网络文件系统。`PersistentVolume` 存储具有与我们的应用程序或部署独立的生命周期的数据。这使我们能够存储在应用程序部署之间持续存在的数据。对于我们的缓存来说，这就是我们将要使用的内容。`PersistentVolumeClaim`
    是 `PersistentVolume` 物理资源与需要使用它的应用程序之间的链接。我们可以在索赔上设置策略，允许单个读/写索赔或多个读取索赔。对于我们的应用程序，我们只需要一个单个的读/写索赔到我们的
    `cache-data` `PersistentVolume`。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you want more detail about some of the concepts we’ve talked about here,
    the Kubernetes project maintains a [glossary](https://kubernetes.io/docs/reference/glossary/?fundamental=true)
    of all the terms involved in operating Kubernetes. This can be very helpful. Each
    entry in the glossary is also linked to much more in-depth detail on other pages.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解我们在这里谈论的一些概念的更多细节，Kubernetes 项目维护了一个术语表，其中包含操作 Kubernetes 所涉及的所有术语的 [词汇表](https://kubernetes.io/docs/reference/glossary/?fundamental=true)。这可能非常有帮助。术语表中的每个条目也链接到其他页面上更详细的详细信息。
- en: 'You can check out the file we will be using in this section by running the
    following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令查看本节中将要使用的文件：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The URL in the example has been continued on the following line so that it fits
    in the margins. You may find that you need to reassemble the URL and remove the
    backslashes for the command to work properly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的 URL 已经延续到下一行，以适应页边距。您可能需要重新组装 URL 并删除反斜杠，以使命令正常工作。
- en: We will start by looking at the manifest YAML file, called *lazyraster-service.yaml*.
    The full manifest contains multiple YAML documents separated by `---`. We will
    discuss each section individually here.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从名为 *lazyraster-service.yaml* 的清单 YAML 文件开始。完整清单包含多个由 `---` 分隔的 YAML 文档。我们将在此单独讨论每个部分。
- en: Service definition
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务定义
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first section defines our `Service`. The second and third sections, which
    we’ll see in a moment, respectively define our `PersistentVolumeClaim` and then
    our actual `Deployment`. We’ve told Kubernetes that our service will be called
    `lazyraster` and that it will be exposed on port 8000, which maps to the actual
    8000 in our container. We’ve exposed that with the `NodePort` mechanism, which
    simply makes sure that our application is exposed on the same port on each host,
    much like the `--publish` flag to `docker container run`. This is helpful with
    `minikube` since we’ll run only one instance, and the `NodePort` type makes it
    easy for us to access it from our computer just like we did earlier. As with many
    parts of Kubernetes, there are several options other than `NodePort`, and you
    can probably find a mechanism that’s ideal for your production environment. `NodePort`
    is good for `minikube`, but it might work well for more statically configured
    load balancers as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分定义了我们的 `Service`。稍后我们将看到的第二部分和第三部分分别定义了我们的 `PersistentVolumeClaim` 和实际的
    `Deployment`。我们告诉 Kubernetes 我们的服务将被称为 `lazyraster`，并且将暴露在端口 8000 上，这映射到容器中的实际
    8000 端口。我们用 `NodePort` 机制暴露了这一点，它简单地确保我们的应用在每个主机上的同一端口上暴露，类似于 `docker container
    run` 的 `--publish` 标志。这在 `minikube` 中非常有帮助，因为我们将只运行一个实例，而 `NodePort` 类型使我们可以像之前一样从我们的计算机访问它变得容易。与
    Kubernetes 的许多部分一样，除了 `NodePort` 外还有几个选项，您可能会找到适合生产环境的理想机制。`NodePort` 对于 `minikube`
    来说很好，但对于更静态配置的负载均衡器也可能很有效。
- en: 'So, back to our `Service` definition. The `Service` is going to be connected
    to the `Deployment` via the `selector`, which we apply in the `spec` section.
    Kubernetes widely uses labels as a way to reason about similar components and
    to help tie them all together. Labels are key/value pairs that are arbitrarily
    defined and that can then be queried to identify pieces of your system. Here the
    `selector` tells Kubernetes to look for `Deployments` with the label `app: lazyraster`.
    Notice that we also apply the same label to the `Service` itself. That’s helpful
    if we want to identify all the components together later, but it’s the `selector`
    section that ties the `Deployment` to our `Service`. So we now have a `Service`,
    but it doesn’t do anything yet. We need more definitions to make Kubernetes do
    what we want.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '回到我们的 `Service` 定义。`Service` 将通过 `selector` 与 `Deployment` 连接，我们在 `spec` 部分中应用它。Kubernetes
    广泛使用标签作为推理类似组件和帮助将它们全部绑在一起的方式。标签是任意定义的键值对，然后可以查询以识别系统中的部件。这里的 `selector` 告诉 Kubernetes
    查找具有标签 `app: lazyraster` 的 `Deployment`。注意，我们也将相同的标签应用于 `Service` 本身。如果以后我们想要识别所有组件，这非常有帮助，但是
    `selector` 部分将 `Deployment` 与我们的 `Service` 绑定在一起。所以现在我们有了一个 `Service`，但它还没有做任何事情。我们需要更多的定义来使
    Kubernetes 做我们想要的事情。'
- en: PersistentVolumeClaim definition
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久卷声明定义
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next section defines our `PersistentVolumeClaim` and likewise the `PersistentVolume`
    that backs it. A `PersistentVolumeClaim` is a way to name a volume and claim that
    you have a token to access that particular volume in a particular way. Notice,
    though, that we didn’t define the `PersistentVolume` here. That’s because Kubernetes
    is doing that work for us using what it calls *Dynamic Volume Provisioning*. In
    our case, the use is pretty simple: we want a read/write claim to a volume, and
    we’ll let Kubernetes put that in a volume container for us. But you can imagine
    a scenario where an application is going to be deployed into a cloud provider
    and where dynamic provisioning would truly come into its own. In that scenario,
    we don’t want to have to make separate calls to have our volume created in the
    cloud for us. We want Kubernetes to handle that. That’s what Dynamic Volume Provisioning
    is all about. Here, it will just create a container for us to hold our persistent
    data, and mount it into our pod when we stake our claim. We don’t do a lot in
    this section except name it, ask for 100 MB of data, and tell Kubernetes it’s
    a read/write mount-once-only volume.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分定义了我们的`PersistentVolumeClaim`，同样也定义了支持它的`PersistentVolume`。`PersistentVolumeClaim`是一种命名卷并声明您有权以特定方式访问该特定卷的方式。请注意，我们这里没有定义`PersistentVolume`。这是因为
    Kubernetes 正在为我们做这项工作，使用它所谓的*动态卷分配*。在我们的情况下，使用非常简单：我们想要对一个卷进行读/写声明，让 Kubernetes
    为我们把它放在一个卷容器中。但是，您可以想象一种情况，即应用程序将部署到云提供商中，并且动态分配将真正发挥其作用。在这种情况下，我们不希望必须单独调用以使我们的卷在云中为我们创建。我们希望
    Kubernetes 处理这些事务。这就是动态卷分配的全部内容。在这里，它只是为我们创建一个容器来保存我们的持久数据，并在我们声明要求时将其挂载到我们的 pod
    中。在这一部分，我们没有做太多事情，除了命名它，要求100 MB的数据，并告诉 Kubernetes 它是一个只读/写的一次性挂载卷。
- en: Note
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There’s a large number of possible volume providers in Kubernetes. Which ones
    are available to you is in part determined by which provider or cloud service
    you are running on. You should take a look and see which ones make the most sense
    for you when you are preparing to head into production.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中有许多可能的卷提供程序。哪些提供程序适合您部分取决于您正在运行的提供程序或云服务。当您准备投入生产时，您应该看一看，看看哪些选项对您最有意义。
- en: Deployment definition
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署定义
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Deployment` creates the pods for us and uses the Linux container for our
    application. We define some metadata about the application, including its name
    and one label, just like we did for the other definitions. We also apply another
    `selector` here to find the other resources we’re tied to. In the `strategy` section,
    we say we want to have a `RollingUpdate`, which is a strategy that causes our
    pods to be cycled through one by one during deployment. We could also pick `Recreate`,
    which would simply destroy all existing pods and then create new ones afterward.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deployment`为我们创建了 pod，并使用 Linux 容器来运行我们的应用程序。我们为应用程序定义了一些元数据，包括其名称和一个标签，就像我们为其他定义所做的那样。我们还在这里应用了另一个`selector`来查找我们绑定的其他资源。在`strategy`部分，我们说我们希望进行`RollingUpdate`，这是一种策略，它导致我们的
    pod 在部署过程中一个接一个地被循环。我们还可以选择`Recreate`，它将简单地销毁所有现有的 pod，然后在之后创建新的 pod。'
- en: In the `template` section, we define how to stamp out copies of this deployment.
    The container definition includes the Docker image name, the ports to map, volumes
    to mount, and some environment variables that the `lazyraster` application needs.
    The very last part of the `spec` asks to have our `PersistentVolumeClaim` named
    `cache-data-claim`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`template`部分，我们定义了如何生成此部署的副本。容器定义包括 Docker 镜像名称、要映射的端口、要挂载的卷以及`lazyraster`应用程序需要的一些环境变量。`spec`的最后一部分要求我们有一个名为`cache-data-claim`的`PersistentVolumeClaim`。
- en: And that’s it for the application definition. Now let’s stand it up!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序定义就是这样了。现在让我们启动它吧！
- en: Note
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are many more options and a rich set of directives you can specify here
    to tell Kubernetes how to handle your application. We’ve walked through a couple
    of simple options, but we encourage you to explore the Kubernetes documentation
    to learn more.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有许多更多的选项和丰富的指令集，您可以在这里指定，告诉 Kubernetes 如何处理您的应用程序。我们已经介绍了一些简单的选项，但我们鼓励您探索
    Kubernetes 文档以了解更多信息。
- en: Deploying the application
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: 'Before we continue, let’s see what’s in our Kubernetes cluster by using the
    `kubectl` command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们使用`kubectl`命令来查看我们的 Kubernetes 集群中有什么：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have only one thing defined at the moment, a service called `service/kubernetes`.
    A naming convention used widely in Kubernetes is to preface the type of object
    with the object `Kind`, which is sometimes shortened to a two- or three-letter
    abbreviation. Sometimes you will see `service` represented as `svc`. If you are
    curious, you can see all of the resources and their short names by running the
    command `kubectl api-resources`. So let’s go ahead and get our service, deployment,
    and volume into the cluster!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只定义了一个名为`service/kubernetes`的服务。在Kubernetes中广泛使用的命名约定是使用对象`Kind`的类型作为对象的前缀，有时会缩写为两个或三个字母的缩写。有时你会看到`service`表示为`svc`。如果你好奇的话，可以通过运行命令`kubectl
    api-resources`来查看所有资源及其简称。所以让我们继续将我们的服务、部署和卷放入集群中吧！
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'That output looks like what we expected: we have a service, a persistent volume
    claim, and a deployment. So let’s see what’s in the cluster now:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 那个输出看起来像我们预期的：我们有一个服务、一个持久卷索赔和一个部署。所以现在让我们看看集群中有什么：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can see that a bunch more happened behind the scenes. And also, where is
    our volume or persistent volume claim? We have to ask for that separately:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到幕后发生了更多的事情。还有，我们的卷或持久卷索赔在哪里？我们必须单独请求它：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Tip
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`kubectl get all` does nothing of the sort. It would be more aptly named `get
    all-of-the-most-common-resources`, but there are several other resources you can
    fetch. The Kubernetes project hosts a handy [cheat sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet)
    to make this more discoverable.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get all`并不做任何这样的事情。更恰当地说，它应该被命名为`get all-of-the-most-common-resources`，但你可以获取几个其他资源。Kubernetes项目提供了一个方便的[速查表](https://kubernetes.io/docs/reference/kubectl/cheatsheet)，以使其更易于发现。'
- en: So what about that `replicaset.apps` that appeared in the `get all` output?
    That is a ReplicaSet. A ReplicaSet is a piece of Kubernetes that is responsible
    for making sure that our application is running the right number of instances
    all the time and that they are healthy. We don’t normally have to worry about
    what happens inside the ReplicaSet because the deployment we created manages it
    for us. You can manage the ReplicaSet yourself if need be, but most of the time
    you won’t need to or want to.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`get all`输出中出现的`replicaset.apps`是什么呢？那是一个ReplicaSet。ReplicaSet是Kubernetes的一部分，负责确保我们的应用始终运行正确数量的实例，并保持它们的健康状态。通常我们不需要担心ReplicaSet内部发生的事情，因为我们创建的部署会为我们管理它。如果需要的话，你可以自己管理ReplicaSet，但大多数情况下你不需要或者不想这样做。
- en: 'We didn’t tell `kubectl` any specific number of instances, so we got one. And
    we can see that both the desired and current states match. We’ll take a look at
    that in a moment. But first, let’s connect to our application and see what we’ve
    got:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有告诉`kubectl`要多少个实例，所以我们得到了一个。我们可以看到期望状态和当前状态都匹配。我们稍后再看看这个。但首先，让我们连接到我们的应用程序，看看我们有什么：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You will probably get a different IP address and port back. That’s fine! This
    is very dynamic stuff. And that’s why we use the `minikube` command to manage
    it for us.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到一个不同的IP地址和端口。没关系！这是非常动态的东西。这就是为什么我们使用`minikube`命令来为我们管理它。
- en: 'Also, remember that `minikube` will warn you if you need to keep the `service`
    command running while you explore the `lazyraster` service. So grab the address
    that came back, open your web browser, and paste it into the URL bar like this:
    *http://<192.168.99.100:32185>/documents/docker-up-and-running-public/sample.pdf?page=1*.
    You’ll need to substitute the IP and port into the URL to make it work for you.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得`minikube`会在你探索`lazyraster`服务时警告你需要保持`service`命令运行。所以获取返回的地址，打开你的网页浏览器，并将其粘贴到URL栏中，像这样：*http://<192.168.99.100:32185>/documents/docker-up-and-running-public/sample.pdf?page=1*。你需要将IP和端口替换到URL中以使其对你有效。
- en: 'You’ll need to be connected to the internet because the `lazyraster` application
    is going to go out to the internet, fetch a PDF from a public S3 bucket, and then
    render the first page from the document as a PNG in a process called *rasterization*.
    If everything worked, you should see a copy of the front cover of an earlier edition
    of this book! This particular PDF has two pages, so feel free to try changing
    the argument to `?page=2`. If you do that, you may notice it renders *much* faster
    than the first page. That’s because the application is using our persistent volume
    to cache the data. You can also specify `width=2048` or ask for a JPEG instead
    of a PNG with `imageType=image/jpeg`. You could rasterize the front page as a
    very large JPEG, like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要连接到互联网，因为 `lazyraster` 应用程序将会访问互联网，从公共 S3 存储桶获取一个 PDF 文档，然后进行所谓的 *光栅化* 过程，将文档的第一页渲染为
    PNG 图像。如果一切正常，您应该能看到这本书早期版本的封面的副本！这本特定的 PDF 有两页，因此您可以尝试将参数更改为 `?page=2`。如果这样做，您可能会注意到渲染速度比第一页要快得多。这是因为应用程序正在使用我们的持久卷缓存数据。您还可以指定
    `width=2048`，或者请求 JPEG 格式而不是 PNG 格式。您可以像这样将封面渲染为一个非常大的 JPEG：
- en: '*http://<192.168.99.100:32185>/documents/docker-up-and-running-public/sample.pdf?page=1&imageType=image/jpeg&width=2048*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*http://<192.168.99.100:32185>/documents/docker-up-and-running-public/sample.pdf?page=1&imageType=image/jpeg&width=2048*'
- en: If you have a public S3 bucket with other PDFs in it, you can simply substitute
    the bucket name for `docker-up-and-running-public` in the URL to hit your bucket
    instead. If you want to play with the application some more, check out [the *Nitro*/*lazyraster*
    repo on GitHub](https://github.com/Nitro/lazyraster).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个公共 S3 存储桶，并且其中还有其他 PDF 文档，您可以简单地在 URL 中将存储桶名称替换为 `docker-up-and-running-public`，以访问您的存储桶。如果您想进一步测试这个应用程序，请查看
    [GitHub 上 *Nitro*/*lazyraster* 仓库](https://github.com/Nitro/lazyraster)。
- en: Scaling up
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展操作
- en: In real life you don’t just deploy applications; you operate them as well. One
    of the huge advantages of scheduled workloads is the ability to scale them up
    and down at will, within the resource constraints available to the system. In
    our case, we only have one Minikube node, but we can still scale up our service
    to better handle load and provide more reliability during deployments. Kubernetes,
    as you might imagine, allows scaling up and down quite easily. For our service,
    we will need only one command to do it. Then we’ll take another look at the `kubectl`
    output and also at the Kubernetes Dashboard we introduced earlier so we can prove
    that the service scaled.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，您不仅仅部署应用程序；还要运行它们。定时工作负载的一个巨大优势是能够根据系统可用的资源约束随意扩展或缩减它们。在我们的情况下，我们只有一个
    Minikube 节点，但是我们仍然可以扩展我们的服务，以更好地处理负载并在部署期间提供更多可靠性。您可以想象，Kubernetes 允许轻松地扩展和缩减。对于我们的服务，我们只需一个命令即可完成。然后我们将再次查看
    `kubectl` 输出以及我们之前介绍的 Kubernetes 仪表板，以证明服务已扩展。
- en: 'In Kubernetes, the thing we will scale is not the service; it’s the deployment.
    Here’s what that looks like:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，我们要扩展的不是服务，而是部署。这是其样子：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Great, that did something! But what did we get?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，这次有反应了！但我们得到了什么呢？
- en: '[PRE65]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We now have two instances of our application running. Let’s see what we got
    in the logs:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个应用程序实例在运行。让我们看看日志内容：
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We asked for logs for the deployment, but Kubernetes tells us two pods are running,
    so it simply picked one of them to show us the logs from. We can see the replica
    starting up. If we want to specify a particular instance to look at, we can ask
    for the logs for that pod with something like `kubectl logs pod/lazyraster-644cb5c66c-zsjxd`,
    using the output from `kubectl get pods` to find the pod in question.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求部署的日志，但 Kubernetes 告诉我们有两个 Pod 正在运行，所以它只是选择其中一个来显示日志。我们可以看到复制正在启动。如果我们想指定一个特定的实例来查看，我们可以使用
    `kubectl get pods` 的输出来找到那个 Pod，并使用类似 `kubectl logs pod/lazyraster-644cb5c66c-zsjxd`
    的命令获取该 Pod 的日志。
- en: We now have a couple of copies of our application running. What does that look
    like on the Kubernetes Dashboard? Let’s navigate there with `minikube dashboard`.
    Once we’re there, we’ll select “Workloads - Deployments” from the left sidebar
    and then click on the `lazyraster` deployment, which should display a screen that
    looks like [Figure 10-3](#figure10-3).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有几个应用程序副本在运行。这在 Kubernetes 仪表板上是什么样子？让我们通过 `minikube dashboard` 导航到那里。一旦到达那里，我们将从左侧边栏选择“工作负载
    - 部署”，然后点击 `lazyraster` 部署，这将显示一个看起来像 [Figure 10-3](#figure10-3) 的屏幕。
- en: '![Lazyraster Service Dashboard](assets/dur3_1003.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Lazyraster 服务仪表板](assets/dur3_1003.png)'
- en: Figure 10-3\. `lazyraster` service dashboard (example)
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-3\. `lazyraster` 服务仪表板（示例）
- en: We encourage you to click around some more in the Kubernetes Dashboard to see
    what else is presented. With the concepts you’ve picked up here, a lot should
    be clearer now, and you can probably figure out some more on your own. Likewise,
    `kubectl` has a lot of other options available as well, many of which you’ll need
    in a real production system. The [cheat sheet we discussed earlier](https://kubernetes.io/docs/reference/kubectl/cheatsheet)
    is a real lifesaver here!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你在 Kubernetes 仪表板中多点击几下，看看还有什么其他信息。有了你在这里学到的概念，很多事情现在应该更清晰了，你可能还可以自行探索更多。同样，`kubectl`
    还有许多其他可用选项，其中许多在真实生产系统中可能会用到。我们之前讨论的[速查表](https://kubernetes.io/docs/reference/kubectl/cheatsheet)在这里确实是一个救命稻草！
- en: As always, you can type Ctrl-C at any time to exit the running `minikube dashboard`
    command.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，你可以随时键入 Ctrl-C 退出运行中的 `minikube dashboard` 命令。
- en: kubectl API
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kubectl API
- en: 'We haven’t shown you an API yet, and, as we’ve discussed with Docker, it can
    be really useful to have a simple API to interact with for scripting, programming,
    and other general operational needs. You can write programs to talk directly to
    the Kubernetes API, but for local development and other simple use cases, you
    can use `kubectl` as a nice proxy to Kubernetes, and it presents a clean API that
    is accessible with `curl` and JSON command-line tools. Here’s an example of what
    you can do:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有向你展示 API，正如我们之前与 Docker 讨论的那样，拥有一个简单的 API 以供脚本编写、编程和其他一般操作需求非常有用。你可以编写程序直接与
    Kubernetes API 交互，但对于本地开发和其他简单用例，你可以使用 `kubectl` 作为 Kubernetes 的一个良好代理，并提供了一个可以通过
    `curl` 和 JSON 命令行工具访问的清晰 API。以下是一个你可以做的示例：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We’ve now got `kubectl` itself serving up a web API on the local system! You’ll
    need to read more about what’s possible, but let’s get it to show us the individual
    instances of the `lazyraster` application. We can do that by opening the following
    URL in a browser or by using `curl` in another terminal window: *http://localhost:8001/api/v1/namespaces/default/endpoints/lazyraster*.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让 `kubectl` 本身在本地系统上提供了一个 Web API！你需要进一步了解可能性，但让我们让它显示 `lazyraster` 应用程序的各个实例。我们可以通过在浏览器中打开以下
    URL 或在另一个终端窗口中使用 `curl` 来实现：*http://localhost:8001/api/v1/namespaces/default/endpoints/lazyraster*。
- en: 'There is a lot of output here, but the part we care about is the `subsets`
    section:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里输出很多，但我们关心的部分是 `subsets` 部分：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: What’s interesting here is that we can see that both instances are running on
    the Minikube host and that they have different IP addresses. If we were building
    a cloud-native application that needed to know where the other instances of the
    application were running, this would be a good way to do that.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的地方在于我们可以看到两个实例都在 Minikube 主机上运行，并且它们具有不同的 IP 地址。如果我们正在构建一个需要知道应用程序的其他实例运行位置的云原生应用程序，这将是一个很好的方法。
- en: 'You can type Ctrl-C at any time to exit the running `kubectl proxy` processes,
    and then you can remove the deployment and all of its components by running the
    following command. It may take Kubernetes a minute or so to delete everything
    and return you to the terminal prompt:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时键入 Ctrl-C 退出运行中的 `kubectl proxy` 进程，然后可以通过运行以下命令来删除部署及其所有组件。Kubernetes
    可能需要一两分钟来删除所有内容并返回到终端提示符：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And then finally, you can go ahead and remove your Minikube cluster if you
    are done with everything in it for now:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你目前已经完成了 Minikube 集群中的所有工作，你可以继续删除它：
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Tip
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Kubernetes is a really big system, with great community involvement. We’ve just
    shown you the tip of the iceberg with Minikube, but if you are interested, there
    are many other Kubernetes distributions and tools to explore.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个非常庞大的系统，有着广泛的社区参与。我们仅仅展示了 Minikube 的冰山一角，但如果你感兴趣，还有许多其他 Kubernetes
    发行版和工具可以探索。
- en: Docker Desktop-Integrated Kubernetes
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Desktop-集成 Kubernetes
- en: Docker Desktop comes with support for an integrated single-node Kubernetes cluster
    that can be run by simply enabling an option in the application preferences.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop 自带对一个集成的单节点 Kubernetes 集群的支持，可以通过在应用程序首选项中简单启用选项来运行。
- en: The integrated Kubernetes cluster is not easily configurable, but it does provide
    a very accessible option for those who simply need to verify some basic functionality
    against a current Kubernetes installation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 集成的 Kubernetes 集群不易配置，但对于那些只需验证当前 Kubernetes 安装的基本功能的用户来说，它提供了一个非常便捷的选项。
- en: To enable Docker Desktop’s built-in Kubernetes functionality, launch Docker
    Desktop and then open up Preferences from the Docker whale icon in your task/menu
    bar. Then select the Kubernetes tab, click Enable Kubernetes, and finally click
    the “Apply & Restart” button to make the required changes to the VM. The first
    time you do this, Docker will utilize the [`kubeadm`](https://kubernetes.io/docs/reference/setup-tools/kubeadm)
    command to set up the Kubernetes cluster.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Docker Desktop内置的Kubernetes功能，请启动Docker Desktop，然后从任务栏/菜单栏中的Docker鲸鱼图标打开首选项。然后选择Kubernetes选项卡，点击启用Kubernetes，最后点击“应用并重启”按钮以对VM进行所需的更改。第一次这样做时，Docker将利用[`kubeadm`](https://kubernetes.io/docs/reference/setup-tools/kubeadm)命令来设置Kubernetes集群。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in a bit more information about how the Docker Desktop-integrated
    Kubernetes is set up, Docker has a good [blog post](https://www.docker.com/blog/how-kubernetes-works-under-the-hood-with-docker-desktop)
    that covers some of these details.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Docker Desktop集成的Kubernetes如何设置感兴趣，Docker有一篇很好的[博文](https://www.docker.com/blog/how-kubernetes-works-under-the-hood-with-docker-desktop)，详细介绍了其中一些细节。
- en: This will create a new `kubectl` context called `docker-desktop` and should
    automatically switch you to this context.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`docker-desktop`的新`kubectl`上下文，并应自动切换到该上下文。
- en: 'You can confirm which context you are currently set to by running the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来确认当前设置的上下文：
- en: '[PRE71]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If you need to change the current context, you can do so like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更改当前的上下文，可以像这样操作：
- en: '[PRE72]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And finally, if you want to completely unset the current context, you can use
    this command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想完全取消当前上下文，可以使用以下命令：
- en: '[PRE73]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Once this cluster is running, you can interact with it just like any other Kubernetes
    cluster via the `kubectl` command. Whenever you shut down Docker Desktop, this
    will also shut down the Kubernetes cluster.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个集群运行起来，你可以通过`kubectl`命令与它交互，就像任何其他Kubernetes集群一样。每当你关闭Docker Desktop时，这也会关闭Kubernetes集群。
- en: If you want to completely disable this Kubernetes cluster, go back into the
    Preferences panel, select the Kubernetes tab, and un-check Enable Kubernetes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想完全禁用这个Kubernetes集群，回到首选项面板，选择Kubernetes选项卡，并取消选择启用Kubernetes。
- en: Kind
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: The final option that we are going to discuss here is `kind`, a very simple
    but useful tool that allows you to manage a Kubernetes cluster made up of one
    or more Linux containers running in Docker. The tool name, `kind`, is an acronym
    that means “Kubernetes in Docker” but also refers to the fact that object types
    in Kubernetes are identified in the API by a field called `Kind`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要讨论的选项是`kind`，这是一个非常简单但非常有用的工具，允许你管理一个由一个或多个在Docker中运行的Linux容器组成的Kubernetes集群。工具名称`kind`是一个首字母缩略词，意思是“Kubernetes
    in Docker”，但也指的是Kubernetes中的对象类型在API中由一个名为`Kind`的字段标识。
- en: Note
  id: totrans-325
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You will find that searching for this tool on the web can be a bit difficult,
    but you can always find the tool and documentation on its primary [website](https://kind.sigs.k8s.io).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现在网络上搜索这个工具可能有点困难，但你总是可以在其主要[网站](https://kind.sigs.k8s.io)上找到该工具和文档。
- en: '`kind` provides a nice middle ground between the simplistic Kubernetes cluster
    that is embedded into the Docker VM and the `minikube` VM, which can be overly
    complex at times. `kind` is distributed as a single binary and can be installed
    with your favorite package manager or by simply navigating to the [`kind` project
    releases page](https://github.com/kubernetes-sigs/kind/releases) and downloading
    the most recent release for your system. If you manually download the binary,
    make sure that you rename the binary to `kind`, copy it to a directory in your
    path, and then ensure that it has the correct permissions so that users can run
    it.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`提供了一个很好的折中方案，介于嵌入到Docker VM中的简单化Kubernetes集群和有时过于复杂的`minikube` VM之间。`kind`作为一个单一的二进制文件分发，并可以通过你喜欢的包管理器安装，或者简单地访问[`kind`项目发布页面](https://github.com/kubernetes-sigs/kind/releases)，下载最新的适合你系统的版本。如果你手动下载二进制文件，请确保将其重命名为`kind`，复制到路径中的某个目录，并确保它具有正确的权限，以便用户可以运行它。'
- en: 'Once `kind` is installed, you can try to create your first cluster with it
    by running the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`kind`安装完成，你可以通过运行以下命令尝试用它创建你的第一个集群：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: By default, this command will spin up a single Docker container that represents
    a one-node Kubernetes cluster, using the most current stable Kubernetes release
    that `kind` currently supports.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个命令将启动一个表示单节点Kubernetes集群的单个Docker容器，使用`kind`当前支持的最新稳定Kubernetes版本。
- en: '`kind` has already set the Kubernetes current context to point at the cluster,
    so we can start running `kubectl` commands immediately:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`已将Kubernetes当前上下文设置为指向集群，因此我们可以立即开始运行`kubectl`命令：'
- en: '[PRE75]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can see a redacted version of the information used by `kubectl` to connect
    to the Kubernetes server by running the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，您可以查看`kubectl`连接到Kubernetes服务器时使用的信息的摘要版本：
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`kind` has some [advanced features](https://kind.sigs.k8s.io/docs/user/quick-start/#advanced)
    that can generally be controlled by passing in a configuration file with the `--config`
    argument when spinning up the cluster.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`具有一些[高级功能](https://kind.sigs.k8s.io/docs/user/quick-start/#advanced)，通常可以通过在启动集群时使用`--config`参数传入配置文件来控制。'
- en: 'You may find some of the follwing features useful:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现以下某些功能很有用：
- en: Changing the version of Kubernetes that is used
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改正在使用的Kubernetes版本
- en: Spinning up multiple worker nodes
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动多个工作节点
- en: Spinning up multiple control plane nodes for HA testing
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动多个控制平面节点进行高可用性测试
- en: Mapping ports between Docker and the local host system
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射Docker与本地主机系统之间的端口
- en: Enabling and disabling [Kubernetes feature gates](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用和禁用[Kubernetes功能开关](https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates)
- en: Exporting control plane component logs with `kind export logs`
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kind export logs`导出控制平面组件日志
- en: And more
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多内容
- en: Tip
  id: totrans-345
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: One thing to remember when using `kind` is that Kubernetes is running inside
    one or more containers, which are potentially running inside a Linux VM when you
    are using something like Docker Desktop. This may mean that you need to set up
    some additional port forwarding when you spin up the cluster. This can be done
    using the `extraPortMappings` setting in the `kind` config.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`kind`时需要记住的一件事情是，Kubernetes正在一个或多个容器内运行，当您使用类似Docker Desktop的东西时，这些容器可能运行在Linux虚拟机内。这可能意味着在启动集群时需要设置一些额外的端口转发。这可以通过`kind`配置中的`extraPortMappings`设置来完成。
- en: 'At this point, you can go ahead and delete the cluster by running the following
    command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以通过运行以下命令删除集群：
- en: '[PRE78]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Amazon ECS and Fargate
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon ECS和Fargate
- en: 'One of the most popular cloud providers is Amazon via their AWS offerings.
    Support for running containers natively has existed in [AWS Elastic Beanstalk](https://amzn.to/2wNa1rL)
    since mid-2014\. But that service assigns only a single container to an Amazon
    instance, which means that it’s not ideal for short-lived or lightweight containers.
    Amazon Elastic Compute Cloud (Amazon EC2) itself is a great platform for hosting
    your own Docker environment, though, and because Docker is powerful, you don’t
    necessarily need much on top of your instances to make this a productive environment
    to work in. But Amazon has spent a lot of engineering time building a service
    that treats containers as first-class citizens: the Amazon Elastic Container Service
    (Amazon ECS). In the last few years, Amazon has built upon this support with products
    like the Elastic Kubernetes Services (EKS) and AWS Fargate.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的云提供商之一是亚马逊，通过他们的AWS提供的服务。自2014年中期以来，[AWS Elastic Beanstalk](https://amzn.to/2wNa1rL)就支持原生运行容器。但是该服务仅将单个容器分配给亚马逊实例，这意味着对于短暂或轻量级容器并非理想选择。然而，亚马逊的Elastic
    Compute Cloud (Amazon EC2)本身是托管自己的Docker环境的绝佳平台，由于Docker功能强大，您不一定需要在实例之上添加太多内容来提高工作效率。但是，亚马逊花费了大量工程时间建立了一项服务，将容器视为一等公民：Amazon
    Elastic Container Service (Amazon ECS)。近年来，亚马逊通过Elastic Kubernetes Services (EKS)和AWS
    Fargate等产品进一步增强了对此支持。
- en: Note
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Fargate is simply a marketing label Amazon uses for the feature of ECS that
    makes it possible for AWS to automatically manage all the nodes in your container
    cluster so that you can focus on deploying your service.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Fargate只是亚马逊用于ECS功能的一个市场标签，使AWS能够自动管理容器集群中的所有节点，从而让您专注于部署服务。
- en: The ECS is a set of tools that coordinates several AWS components. With ECS,
    you have a choice of whether or not you will run the Fargate tooling on top. If
    you do, then you don’t need to handle as much of the work. If you don’t, then
    in addition to the cluster nodes to handle your workload, you will also need to
    add one or more EC2 instances to the cluster running Docker and Amazon’s special
    ECS agent. If you run Fargate, then the cluster is automatically managed for you.
    In either case, you spin up the cluster and then push your containers into it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ECS 是一组工具，协调多个 AWS 组件。使用 ECS，您可以选择是否在其上运行 Fargate 工具。如果选择运行 Fargate，则无需处理太多工作。如果不运行
    Fargate，则除了集群节点处理工作负载外，还需要向运行 Docker 和 Amazon 特殊 ECS 代理的集群添加一个或多个 EC2 实例。无论哪种情况，您都会启动集群，然后将容器推送到其中。
- en: The [Amazon ECS agent](https://github.com/aws/amazon-ecs-agent) we just mentioned
    works with the ECS service to coordinate your cluster and schedule containers
    to your hosts. You will only be directly exposed to this when you manage a traditional
    non-Fargate ECS cluster.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚提到的[Amazon ECS 代理](https://github.com/aws/amazon-ecs-agent)与 ECS 服务配合工作，协调您的集群并将容器调度到您的主机上。当您管理传统的非
    Fargate ECS 集群时，您将直接接触到这一点。
- en: Core AWS Setup
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心 AWS 设置
- en: The rest of this section assumes that you have access to an AWS account and
    some familiarity with the service. You can learn about pricing and create a new
    account at [*https://aws.amazon.com/free*](https://aws.amazon.com/free). Amazon
    offers a free service tier, which may be enough for you to experiment with if
    you don’t already have a paid account. After you have your AWS account set up,
    you will need at least one administrative user, a key pair, an Amazon virtual
    private cloud (AWS VPC), and a default security group in your environment. If
    you do not already have these set up, follow the directions in the [Amazon documentation](https://amzn.to/2FcPDSL).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分假设您可以访问 AWS 账户并对服务有一些熟悉。您可以在[*https://aws.amazon.com/free*](https://aws.amazon.com/free)了解定价并创建新账户。Amazon
    提供免费服务层，如果您尚未拥有付费账户，则可能足够您进行实验。设置完 AWS 账户后，您将需要至少一个管理用户、一个密钥对、一个 Amazon 虚拟私有云（AWS
    VPC）和环境中的默认安全组。如果您尚未设置这些内容，请按照[Amazon 文档](https://amzn.to/2FcPDSL)中的说明进行操作。
- en: IAM Role Setup
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IAM 角色设置
- en: 'Amazon’s Identity and Access Management (Amazon IAM) roles are used to control
    what actions a user can take within your cloud environment. We need to make sure
    we can grant access to the right actions before moving on with the ECS. To work
    with the ECS, you must create a role called `ecsInstanceRole` that has the `AmazonEC2ContainerServiceRole`
    managed role attached to it. The easiest way to do this is by logging in to the
    [AWS console](https://console.aws.amazon.com) and navigating to [Identity and
    Access Management](https://console.aws.amazon.com/iam/home):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon 的身份和访问管理（Amazon IAM）角色用于控制用户在您的云环境中可以执行的操作。在继续使用 ECS 之前，我们需要确保可以授予访问正确操作的权限。要使用
    ECS，您必须创建一个名为`ecsInstanceRole`的角色，并附加`AmazonEC2ContainerServiceRole`托管角色。最简单的方法是登录到[AWS控制台](https://console.aws.amazon.com)，然后导航到[身份和访问管理](https://console.aws.amazon.com/iam/home)：
- en: Tip
  id: totrans-359
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Check to ensure that you don’t already have the proper role. If it already exists,
    then you should double-check that it is set up properly, as these directions have
    changed a bit over the years.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 检查确保您尚未具有适当的角色。如果已存在，则应再次检查其是否已正确设置，因为这些方向在多年间已有所更改。
- en: In the left sidebar, click Roles.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧边栏中，点击角色。
- en: Then, click the “Create role” button.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“创建角色”按钮。
- en: Under AWS Service, select Elastic Container Service.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS服务下，选择弹性容器服务。
- en: Under “Select your use case,” select Elastic Container Service.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选择您的用例”下，选择弹性容器服务。
- en: 'Click Next: Permissions.'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步：权限”。
- en: 'Click Next: Review.'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步：审核”。
- en: In Role Name, type **`ecsInstanceRole`**.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色名称中，键入**`ecsInstanceRole`**。
- en: Click “Create role.”
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建角色”。
- en: If you are interested in storing container configuration in an S3 object storage
    bucket, take a look at the Amazon ECS container agent configuration [documentation](https://amzn.to/2PNapOL).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣将容器配置存储在 S3 对象存储桶中，请查看Amazon ECS容器代理配置[文档](https://amzn.to/2PNapOL)。
- en: AWS CLI Setup
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS CLI 设置
- en: Amazon supplies command-line tools that make it easy to work with their API-driven
    infrastructure. You will need to install a very recent version of the AWS CLI
    tools. Amazon has [detailed documentation](https://amzn.to/1PCpPNA) that covers
    the installation of their tools, but the basic steps are as follows.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon 提供了命令行工具，使得与其基于 API 的基础设施工作变得容易。您需要安装最新版本的 AWS CLI 工具。Amazon 提供了[详细文档](https://amzn.to/1PCpPNA)来覆盖其工具的安装，但基本步骤如下。
- en: Installation
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: Here we’ll cover the native installation on a few different OSes, but be aware
    that you can also run the [AWS CLI via a Docker container](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-docker.html#cliv2-docker-install)!
    You can feel free to skip to the one you care about. If you’re curious or just
    like installation instructions, by all means, read them all!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将涵盖在几种不同的操作系统上的本地安装，但请注意，您也可以通过[Docker 容器](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-docker.html#cliv2-docker-install)来运行
    AWS CLI！您可以随意跳到您关心的部分。如果您好奇或者只是喜欢安装说明，请务必将它们全部阅读！
- en: macOS
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: macOS
- en: 'In [Chapter 3](ch03.html#installing_docker), we discussed installing Homebrew.
    If you previously did this, you can install the AWS CLI using the following commands:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.html#installing_docker)中，我们讨论了安装 Homebrew。如果您之前已经这样做了，您可以使用以下命令安装
    AWS CLI：
- en: '[PRE79]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Windows
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Windows
- en: 'Amazon provides a standard MSI installer for Windows, which can be downloaded
    from Amazon S3 for your architecture:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon 为 Windows 提供了一个标准的 MSI 安装程序，可从 Amazon S3 下载适合您体系结构的版本：
- en: '[32-bit Windows](https://s3.amazonaws.com/aws-cli/AWSCLI32.msi)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[32-bit Windows](https://s3.amazonaws.com/aws-cli/AWSCLI32.msi)'
- en: '[64-bit Windows](https://s3.amazonaws.com/aws-cli/AWSCLI64.msi)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[64-bit Windows](https://s3.amazonaws.com/aws-cli/AWSCLI64.msi)'
- en: Other
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 其他
- en: 'The Amazon CLI tools are written in Python. So on most platforms, you can install
    the tools with the Python `pip` package manager by running the following from
    a shell:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon CLI 工具是用 Python 编写的。因此，在大多数平台上，您可以通过 Python 的`pip`软件包管理器运行以下命令来安装这些工具：
- en: '[PRE80]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Some platforms won’t have `pip` installed by default. In that case, you can
    use the `easy_install` package manager, like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台默认情况下不会安装`pip`。在这种情况下，您可以使用`easy_install`软件包管理器，如下所示：
- en: '[PRE81]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Configuration
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'Quickly verify that your AWS CLI version is at least 1.7.0 with the following
    command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 快速验证您的 AWS CLI 版本至少为 1.7.0，运行以下命令：
- en: '[PRE82]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To configure the AWS CLI tool, ensure that you have access to your AWS access
    key ID and AWS secret access key, and then run the `configure` command. You will
    be prompted for your authentication information and some preferred defaults:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 AWS CLI 工具，请确保您可以访问您的 AWS 访问密钥 ID 和 AWS 秘密访问密钥，然后运行`configure`命令。系统会提示您输入身份验证信息和一些首选默认值：
- en: '[PRE83]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'At this point, it’s a really good idea to test that the CLI tools are working
    correctly before proceeding. You can easily do that by running the following command
    to list the IAM users in your account:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，测试 CLI 工具是否正常工作是一个非常好的主意。您可以通过运行以下命令轻松实现，列出您帐户中的 IAM 用户：
- en: '[PRE84]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Assuming everything went according to plan and you chose JSON as your default
    output format, you should get something like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切按计划进行，并且您选择了 JSON 作为默认输出格式，您应该会得到类似这样的输出：
- en: '[PRE85]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Container Instances
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器实例
- en: The first thing you need to do after installing the required tools is to create
    at least a single cluster that your Docker hosts will register with when they
    are brought online.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需工具后，首先要做的事情是创建至少一个集群，以便您的 Docker 主机在上线时可以注册到该集群中。
- en: Note
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The default cluster is imaginatively named *default*. If you keep this name,
    you do not need to specify `--cluster-name` in many of the commands that follow.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 默认集群被形象地命名为*default*。如果您保留此名称，您在接下来的许多命令中不需要指定`--cluster-name`。
- en: 'The first thing you need to do is create a cluster in the container service.
    You will then launch your tasks in the cluster once it’s up and running. For these
    examples, you should start by creating a cluster called `fargate-testing`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需工具后，首先要做的事情是在容器服务中创建一个集群。一旦集群启动运行，您将在集群中启动您的任务。针对这些示例，您应该首先创建一个名为`fargate-testing`的集群：
- en: '[PRE86]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Before AWS Fargate was released, you were required to create AWS EC2 instances
    running `docker` and the `ecs-agent`, and add them to your cluster. You can still
    use this approach if you want (`EC2 launch type`), but Fargate makes it much easier
    to run a dynamic cluster that can scale fluidly with your workload.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS Fargate发布之前，您需要创建运行`docker`和`ecs-agent`的AWS EC2实例，并将它们添加到您的集群中。如果您愿意，您仍然可以使用这种方法（`EC2
    launch type`），但是Fargate可以更轻松地运行动态集群，可以根据工作负载流畅地进行扩展。
- en: Tasks
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: Now that our container cluster is set up, we need to start putting it to work.
    To do this, we need to create at least one task definition. The Amazon ECS defines
    the term *task definition* as a list of containers grouped together.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的容器集群已经设置好，我们需要开始让它工作。为此，我们需要创建至少一个任务定义。Amazon ECS将术语*任务定义*定义为一组组合在一起的容器列表。
- en: 'To create your first task definition, open up your favorite editor, copy in
    the following JSON, and then save it as *webgame-task.json* in your current directory,
    as shown here:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建您的第一个任务定义，请打开您喜欢的编辑器，复制以下JSON，并将其保存为*webgame-task.json*，如下所示：
- en: '[PRE88]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Tip
  id: totrans-407
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can also check out these files and a few others by running the following:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过运行以下内容查看这些文件及其他几个文件：
- en: '[PRE89]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The URL has been continued on the following line so that it fits in the margins.
    You may find that you need to reassemble the URL and remove the backslashes for
    the command to work properly.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: URL已经继续到下一行，以适应页面边缘。您可能需要重新组合URL并删除反斜杠，以使命令正常工作。
- en: In this task definition, we are saying that we want to create a task family
    called `fargate-game` running a single container called `web-game` that is based
    on the [*Quantum* web game](https://github.com/stared/quantum-game). As you may
    have seen in an earlier chapter, this Docker image launches a browser-based puzzle
    game that uses real quantum mechanics.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务定义中，我们表示我们要创建一个名为`fargate-game`的任务系列，运行一个名为`web-game`的单个容器，该容器基于[*Quantum*
    web game](https://github.com/stared/quantum-game)。
- en: Tip
  id: totrans-412
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Fargate limits some of the options that you can set in this configuration, including
    `networkMode` and the `cpu` and `memory` settings. You can find out more about
    the options in the task definition from the official [AWS documentation](https://amzn.to/2PkliGR).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Fargate限制了您可以在此配置中设置的一些选项，包括`networkMode`以及`cpu`和`memory`设置。您可以从官方[AWS文档](https://amzn.to/2PkliGR)中了解有关任务定义选项的更多信息。
- en: In this task definition, we define some constraints on memory and CPU usage
    for the container, in addition to telling Amazon whether this container is essential
    to the task. The `essential` flag is useful when you have multiple containers
    defined in a task, and not all of them are required for the task to be successful.
    If `essential` is true and the container fails to start, then all the containers
    defined in the task will be killed and the task will be marked as failed. We can
    also use the task definition to define almost all of the typical variables and
    settings that would be included in a *Dockerfile* or on the `docker container
    run` command line.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务定义中，我们定义了一些有关容器内存和CPU使用的约束，除此之外，还告诉Amazon此容器是否对任务至关重要。当您在任务中定义了多个容器且并非所有容器都是成功任务的必需部分时，`essential`标志就非常有用。如果`essential`为true并且容器无法启动，则任务中定义的所有容器都将被终止，并且任务将被标记为失败。我们还可以使用任务定义来定义几乎所有包含在*Dockerfile*或`docker
    container run`命令行中的典型变量和设置。
- en: 'To upload this task definition to Amazon, you will need to run a command similar
    to what is shown here:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此任务定义上传到Amazon，您需要运行类似于以下内容的命令：
- en: '[PRE90]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can then list all of our task definitions by running the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过运行以下内容列出所有我们的任务定义：
- en: '[PRE92]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now you are ready to create your first task in your cluster. You do so by running
    a command like the one shown next. The `count` argument in the command allows
    you to define how many copies of this task you want to be deployed into your cluster.
    For this job, one is enough.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过运行接下来显示的命令来创建您集群中的第一个任务。命令中的`count`参数允许您定义要部署到集群中的此任务的副本数量。对于此工作，一个副本就足够了。
- en: 'You will need to modify the following command to reference a valid subnet ID
    and security-group ID from your AWS VPC. You should be able to find these in the
    [AWS console](https://console.aws.amazon.com/vpc/home) or by using the AWS CLI
    commands `aws ec2 describe-subnets` and `aws ec2 describe-security-groups`. You
    can also tell AWS to assign your tasks a public IP address by using a network
    configuration similar to this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要修改以下命令以引用来自您的 AWS VPC 的有效子网 ID 和安全组 ID。 您可以在 [AWS 控制台](https://console.aws.amazon.com/vpc/home)
    或使用 AWS CLI 命令 `aws ec2 describe-subnets` 和 `aws ec2 describe-security-groups`
    中找到这些信息。 您还可以告知 AWS 使用类似以下的网络配置为您的任务分配公共 IP 地址：
- en: '[PRE94]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Assigning a public IP address may be required if you are using public subnets:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用公共子网，则可能需要分配公共 IP 地址：
- en: '[PRE95]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Tip
  id: totrans-427
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Fargate and the `awsvpc` network require that you have a service-linked role
    for ECS. In the preceding output, you should see a line that ends like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Fargate 和 `awsvpc` 网络要求您为 ECS 拥有服务链接角色。 在先前的输出中，您应该看到以此结束的一行：
- en: '[PRE97]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Most of the time this will be autogenerated for you, but you can create it
    manually using the following command:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这将为您自动生成，但您可以使用以下命令手动创建它：
- en: '[PRE98]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You can now list all of the services in your cluster with the following command:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下命令列出集群中的所有服务：
- en: '[PRE99]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To retrieve all the details about your service, run the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索有关服务的所有详细信息，请运行以下命令：
- en: '[PRE101]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This output will tell you a lot about all the tasks in your service. In this
    case, we have a single task running at the moment.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出将向您展示有关服务中所有任务的大量信息。 在本例中，我们目前只运行一个单一任务。
- en: Note
  id: totrans-439
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `task-definition` value is a name followed by a number (`fargate-game:1`).
    The number is the revision. If you edit your task and re-register it with the
    `aws ecs register-task-definition` command, you will get a new revision, which
    means that you will want to reference that new revision in various commands, like
    `aws ecs update-service`. If you don’t change that number, you will continue to
    launch containers using the older JSON. This versioning makes it very easy to
    roll back changes and test new revisions without impacting all future instances.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`task-definition` 值是一个名称，后跟一个数字（`fargate-game:1`）。 数字是修订版。 如果您编辑任务并使用 `aws
    ecs register-task-definition` 命令重新注册它，您将获得一个新的修订版，这意味着您将希望在各种命令中引用该新修订版，例如 `aws
    ecs update-service`。 如果您不更改该数字，则将继续使用较旧的 JSON 启动容器。 这种版本控制使得回滚更改和测试新修订版而不影响所有未来实例变得非常容易。'
- en: 'If you want to see what individual tasks are running in your cluster, you can
    run the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查看集群中正在运行的各个任务，可以运行以下命令：
- en: '[PRE103]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Since you only have a single task in your cluster at the moment, this list is
    very small.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您目前的集群只有一个单一任务，因此此列表非常小。
- en: 'To get more details about the individual task, you can run the following command
    after substituting the task ID with the correct one from your cluster:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关单个任务的更多详细信息，您可以在从您的集群中正确替换任务 ID 后运行以下命令：
- en: '[PRE105]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If you notice that the `lastStatus` key is displaying a value of `PENDING`,
    this most likely means that your service is still starting up. You can describe
    the task again to ensure that it has completed transitioning into a `RUNNING`
    state. After verifying that the `lastStatus` key is set to `RUNNING`, you should
    be able to test your container.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注意到 `lastStatus` 键显示值为 `PENDING`，这很可能意味着您的服务仍在启动中。 您可以再次描述任务以确保其已完成过渡到 `RUNNING`
    状态。 验证 `lastStatus` 键已设置为 `RUNNING` 后，您应该能够测试您的容器。
- en: Tip
  id: totrans-449
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Depending on the network setup, your task may not be able to download the image.
    If you see an error like this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 根据网络设置不同，您的任务可能无法下载映像。 如果您看到此类错误：
- en: '`"stoppedReason": "CannotPullContainerError: inspect image has been retried
    5 time(s): failed to resolve ref \"docker.io/spkane/quantum-game:latest\": failed
    to do request: Head [*https://registry-1.docker.io/v2/spkane/quantum-game/manifests/latest*](https://registry-1.docker.io/v2/spkane/quantum-game/manifests/latest):
    dial tcp 54.83.42.45:443: i/o timeout"`'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`"stoppedReason": "CannotPullContainerError: inspect image has been retried
    5 time(s): failed to resolve ref \"docker.io/spkane/quantum-game:latest\": failed
    to do request: Head [*https://registry-1.docker.io/v2/spkane/quantum-game/manifests/latest*](https://registry-1.docker.io/v2/spkane/quantum-game/manifests/latest):
    dial tcp 54.83.42.45:443: i/o timeout"`'
- en: then you should read through this [troubleshooting guide](https://oreil.ly/FYo9Z).^([1](ch10.html#idm46803129919408))
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该阅读此 [故障排除指南](https://oreil.ly/FYo9Z).^([1](ch10.html#idm46803129919408))
- en: Testing the Task
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试任务
- en: You will need a modern web browser installed on your system to connect to the
    container and test the web game.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装一个现代网络浏览器，以连接到容器并测试网络游戏。
- en: In the previous output, you’ll notice that the `privateIPv4Address` for the
    example task was listed as `172.31.42.184`. Yours will be different.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的输出中，您会注意到示例任务的`privateIPv4Address`列为`172.31.42.184`。您的地址可能会有所不同。
- en: Tip
  id: totrans-456
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need more information about the network setup for your task and the EC2
    instance that it is running on, you can grab the `networkInterfaceId` from the
    `aws ecs describe-tasks` output and then append that to the `aws ec2 describe-network-interfaces
    --network-interface-ids` command to get everything you should need, including
    the `PublicIp` value if you configured your service for that.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要关于任务的网络设置和它正在运行的 EC2 实例的更多信息，您可以从`aws ecs describe-tasks`输出中获取`networkInterfaceId`，然后将其附加到`aws
    ec2 describe-network-interfaces --network-interface-ids`命令，以获取您所需的所有信息，包括如果您为该服务配置了`PublicIp`值。
- en: Ensure that you are connected to a network that can reach either the public
    or private IP address of your host, then launch your web browser and navigate
    to port 8080 on that IP address.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您连接到可以访问主机的公共或私有 IP 地址的网络，然后启动您的网络浏览器并导航到该 IP 地址的端口 8080。
- en: 'In the example, this private URL would look like this:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，这个私有 URL 将如下所示：
- en: '[PRE107]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If everything is working as expected, you should be greeted by the *Quantum
    Game* puzzle board.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您将会看到*Quantum Game*的谜题板。
- en: The official version of the game can be found at [*https://quantumgame.io*](https://quantumgame.io).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的官方版本可以在[*https://quantumgame.io*](https://quantumgame.io)找到。
- en: Note
  id: totrans-463
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We completely understand if you get distracted at this point and stop reading
    for a few hours to try to solve some puzzles and learn a little bit of quantum
    mechanics at the same time. The book won’t notice! Put it down, play the puzzles,
    and pick it back up later.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这一点上分心并停止阅读几个小时来解决一些谜题并同时学习一些量子力学，我们完全理解。书本不会介意！放下它，玩些谜题，稍后再拾起。
- en: Stopping the Task
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止任务
- en: 'Right, so we have a running task. Now let’s take a look at stopping it. To
    do that, you need to know the task ID. One way to obtain this is by relisting
    all the tasks running in your cluster:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对了，我们有一个正在运行的任务。现在让我们来看看如何停止它。要做到这一点，您需要知道任务 ID。获取任务 ID 的一种方法是重新列出在您的集群中运行的所有任务：
- en: '[PRE108]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'You can also obtain it from the service information:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从服务信息中获取它：
- en: '[PRE110]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Finally, we can stop the task by running the following command with the correct
    task ID:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过运行以下带有正确任务 ID 的命令来停止任务：
- en: '[PRE112]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If you describe the task again using the same task ID, you should now see that
    the `lastStatus` key is set to `STOPPED`:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次使用相同的任务 ID 描述任务，则现在应该看到`lastStatus`键设置为`STOPPED`：
- en: '[PRE114]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Listing all the tasks in our cluster should return an empty set:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 列出我们集群中的所有任务应该返回一个空集：
- en: '[PRE116]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: At this point, you could start creating more complicated tasks that tie multiple
    containers together and rely on the ECS and Fargate tooling to spin up hosts and
    deploy the tasks into your cluster as needed.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以开始创建更复杂的任务，将多个容器联系在一起，并依赖 ECS 和 Fargate 工具来根据需要启动主机并将任务部署到您的集群中。
- en: 'If you want to tear down the rest of the ECS environment, you can run the following
    commands:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要拆除其余的 ECS 环境，可以运行以下命令：
- en: '[PRE118]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Wrap-Up
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve certainly presented you with a lot of options! It’s unlikely
    that you’ll ever need to use all of these, since many of them overlap. However,
    each one has a unique perspective on exactly what a production system should look
    like and what problems are the most important to solve. After exploring all of
    these tools, you should have a pretty good idea of the wide range of options you
    can choose from to build your production Linux container environment.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们确实向您展示了许多选项！您可能永远不会需要使用所有这些选项，因为其中许多选项重叠。但是，每个选项都对应着关于生产系统应该如何构建以及哪些问题最重要的独特视角。在探索所有这些工具之后，您应该对可以选择的各种选项来构建生产
    Linux 容器环境有一个相当不错的理解。
- en: Underlying all of these tools is Docker’s highly portable image format for Linux
    containers and its ability to abstract away so much of the underlying Linux system,
    which makes it easy to move your applications fluidly between your data center
    and as many cloud providers as you want. Now you just have to choose which approach
    will work best for you and your organization and then implement it.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具的基础是 Docker 的高度可移植的 Linux 容器镜像格式，以及它可以将底层 Linux 系统的许多内容抽象化，这使得您可以轻松地在数据中心和任意多个云提供商之间流畅地迁移应用程序。现在，您只需选择最适合您和您的组织的方法，然后实施它。
- en: In the meantime, let’s jump into the next chapter and explore some of the most
    technical topics in the Docker ecosystem, including security, networking, and
    storage.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们跳到下一章，探索 Docker 生态系统中一些最技术性的主题，包括安全性、网络和存储。
- en: '^([1](ch10.html#idm46803129919408-marker)) Full URL: [*https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_cannot_pull_image.html*](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_cannot_pull_image.html)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#idm46803129919408-marker)) 完整网址：[*https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_cannot_pull_image.html*](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_cannot_pull_image.html)
