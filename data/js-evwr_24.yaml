- en: Chapter 23\. GraphQL and React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the Andy Warhol Museum in Pittsburgh, Pennsylvania, there is a permanent
    installation called “Silver Clouds.” The installation is a sparse room with a
    dozen or so rectangular foil balloons, each filled with a mix of helium and regular
    air. The result is that the balloons will stay suspended longer than balloons
    filled with atmospheric air, but don’t float to the ceiling like helium balloons.
    Patrons of the museum walk through the museum, playfully batting the balloons
    to keep them afloat.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our application is much like the room of “clouds.” It’s enjoyable
    to playfully click the icons and navigate around the app shell, but in the end
    it is a mostly empty room (no offense to Mr. Warhol). In this chapter, we’ll begin
    to fill our application by first exploring how we can display content with React
    Native’s list views. We’ll then make use of [Apollo Client](https://www.apollographql.com/docs/react)
    to connect to our data API. Once we’ve connected, we’ll write GraphQL queries,
    which will display data on an app screen.
  prefs: []
  type: TYPE_NORMAL
- en: Running Our API Locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of our mobile application will require access to a local instance
    of our API. If you’ve been following along with the book, you may already have
    the Notedly API and its database up and running on your machine. If not, I’ve
    added instructions in the book’s [Appendix A](app01.html#appendix-api) on how
    to get a copy of the API up and running along with some sample data. If you already
    have the API running, but would like some additional data to work with, run **`npm
    run seed`** from the root of the API project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating List and Scrollable Content Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lists are everywhere. In life we keep to-do lists, grocery lists, and guest
    lists. In applications, lists are one of the most common UI patterns: lists of
    social media posts, lists of articles, lists of songs, lists of movies, and so
    on. The list (see what I did there?) goes on and on. It may come as no surprise,
    then, that React Native makes creating scrollable lists of content a straightforward
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: The two types of lists on React Native are `FlatList` and `SectionList`. A `FlatList`
    is useful for a large number of items in a single scrollable list. React Native
    does some helpful things behind the scenes, such as rendering only the items that
    are initially viewable to improve performance. A `SectionList` is much like a
    `FlatList`, except that it allows groups of list items to have a header. Think
    of contacts in a contact list, often grouped alphabetically beneath an alphanumeric
    header.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we’ll be using a `FlatList` to display a list of notes, through
    which a user can scroll and tap a preview to read the full note. To achieve this,
    let’s create a new component named `NoteFeed`, which we can use to display the
    list of notes. For now we’ll use some stand-in data, but we’ll connect it to our
    API soon.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let’s create a new component at *src/components/NoteFeed.js*. We’ll
    start by importing our dependencies and adding an array of temporary data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write our component code, which will contain a `FlatList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code you can see that `FlatList` receives three properties
    that simplify the process of iterating over the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`'
  prefs: []
  type: TYPE_NORMAL
- en: This property points to the array of data that the list will contain.
  prefs: []
  type: TYPE_NORMAL
- en: '`keyExtractor`'
  prefs: []
  type: TYPE_NORMAL
- en: Each item in the list must have a unique `key` value. We are using `keyExtractor`
    to use the unique `id` value as the `key`.
  prefs: []
  type: TYPE_NORMAL
- en: '`renderItem`'
  prefs: []
  type: TYPE_NORMAL
- en: This property defines what should be rendered within the list. For now we are
    passing an individual `item` from our `notes` array and displaying it as `Text`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view our list by updating our *src/screens/feed.js* component to display
    the feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s move back to our *src/components/NoteFeed.js* file and update `renderItem`
    to add some spacing between list items using a styled component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you preview our app, you’ll see a scrollable list of data. Finally, we can
    add a separator between our list items. Rather than adding a bottom border via
    CSS, React Native enables us to pass an `ItemSeparatorComponent` property to our
    `FlatList`. This gives us fine-grained control to place any type of component
    as a separator between list elements. It also avoids placing a separator in unwanted
    places, such as after the last item in the list. For our purposes we’ll add a
    simple border, created as a styled component `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than rendering and styling our note’s content directly in our `FlatList`,
    let’s isolate it within its own component. To do so we’ll introduce a new type
    of view called `ScrollView`. The functionality of a `ScrollView` is precisely
    what you’d expect: rather than conforming to the size of the screen, a `ScrollView`
    will overflow the content, allowing the user to scroll.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new component at *src/components/Note.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll update our *src/components/NoteFeed.js* component to make use
    of our new `Note` component by importing it and using it within our `FeedView`.
    The final component code will be as follows ([Figure 23-1](#flatlist_demo)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![A screenshot of the app with a list of data](assets/jsev_2301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-1\. Using FlatList we can display a list of data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With this we’ve laid out a simple `FlatList`. Now let’s make it possible to
    route from a list item to an individual route.
  prefs: []
  type: TYPE_NORMAL
- en: Making a List Routable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very common pattern in mobile applications is to tap an item in a list to
    view more information or expanded functionality. If you recall from the previous
    chapter, our feed screen sits atop the note screen in our navigation stack. In
    React Native we can use the `TouchableOpacity` as a wrapper for making any view
    respond to user touches. This means that we can wrap the content of our `FeedView`
    in `TouchableOpacity` and route the user on press, the same way that we previously
    did with a button. Let’s go ahead and update our *src/components/NoteFeed.js*
    component to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must update our `react-native` import to include `TouchableOpacity`
    in *src/components/NoteFeed.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update our component to use `TouchableOpacity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also need to update our *feed.js* screen component to pass the navigation
    properties to the feed. In *src/screens/feed.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can easily navigate to our generic note screen. Let’s customize
    that screen so that it displays the ID of the note. You may have noticed that
    in our `NoteFeed` component navigation, we’re passing an `id` property. In *screens/note.js*
    we can read the value of that property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’re able to navigate from our list view to a detail page. Next, let’s
    take a look at how we can integrate data from our API into our application.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL with Apollo Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we are ready to read and display data within our application.
    We’ll be accessing the GraphQL API that we created in the first portion of the
    book. Conveniently, we’ll be making use of Apollo Client, the same GraphQL client
    library from the web portion of the book. Apollo Client offers a number of helpful
    features to simplify working with GraphQL within JavaScript UI applications. Apollo’s
    client features include fetching data from a remote API, local caching, GraphQL
    syntax handling, local state management, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started we’ll first need to set up our configuration file. We’ll store
    our environment variables in a file called *config.js*. There are several ways
    to manage environment and configuration variables in React Native, but I’ve found
    this style of configuration file to be the most straightforward and effective.
    To get started, I’ve included a *config-example.js* file, which you can copy and
    edit with our app values. In your terminal application, from the root of the project
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From here we can update any `dev` or `prod` environment variables. In our case
    that will only be a production `API_URI` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will now be able to access these two values, based on Expo’s environment,
    using the `getEnvVars` function. We won’t dive into the rest of the configuration
    file, but it is well commented if you are interested in exploring this setup further.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here we can connect our client to our API. In our *src/Main.js* file we
    will set up Apollo by using the Apollo Client library. If you worked through the
    web portion of the book, this will look very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this, there won’t be a visible change in our application, but we are now
    connected to our API. Next, let’s look at how we can query data from that API.
  prefs: []
  type: TYPE_NORMAL
- en: Writing GraphQL Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’re connected to our API, let’s query some of the data. We’ll start
    by querying for all of the notes in our database, to be displayed in our `NoteFeed`
    list. We’ll then query for individual notes to be displayed in our `Note` detail
    view.
  prefs: []
  type: TYPE_NORMAL
- en: The note Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll be using the bulk `note` API query rather than the paginated `noteFeed`
    query for simplicity and to reduce repetition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a `Query` component works exactly the same way as in a React web application.
    In *src/screens/feed.js*, we import the `useQuery` and GraphQL Language (`gql`)
    libraries like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we compose our query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update our component to call the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All together, our *src/screens/feed.js* file is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With our query written, we can update the *src/components/NoteFeed.js* component
    to use the data passed to it via `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this change, with Expo running, we will see the data from our local API
    displayed in a list, as shown in [Figure 23-2](#data_feedview).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the API data present in the application''s feed view](assets/jsev_2302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-2\. Our API data displaying in our feed view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Right now, tapping a note preview in the list will still display a generic
    note page. Let’s resolve that by making a `note` query in the *src/screens/note.js*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s update out *src/components/Note* component file to display the
    note contents. We’ll add two new dependencies, `react-native-markdown-renderer`
    and `date-fns`, to parse the Markdown and dates from our API in a more user-friendly
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With these changes, we’ll see a list of notes in the application’s feed view.
    Tapping a note preview will take us to the full, scrollable content of the note
    (see [Figure 23-3](#api_data_nav)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshots of the feed list and the note detail screen](assets/jsev_2303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-3\. With our GraphQL queries written, we can navigate between screens
    to view note previews and full notes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adding a Loading Indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently when data is loading in our application, it flashes the word “Loading”
    on the screen. This may be effective at conveying the message, but is also a pretty
    jarring user experience. React Native supplies us with a built-in `ActivityIndicator`,
    which displays an operating system–appropriate loading spinner. Let’s write a
    simple component that we can use as a loading indicator across our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file at *src/components/Loading.js* and compose a simple component
    that displays the activity indicator in the center of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can replace the “Loading” text in our GraphQL query components. In both
    *src/screens/feed.js* and *src/screens/note.js*, first import the `Loading` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in both files, update the Apollo loading state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this, our application will now display a spinning activity indicator when
    our API data is loading (see [Figure 23-4](#rn_loading)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the application in a loading state](assets/jsev_2304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-4\. Using ActivityIndicator, we can add an operating system–appropriate
    loading spinner
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we first looked at how we can integrate list views into a React
    Native application, making use of common application UI patterns. From there we
    configured Apollo Client and integrated the data from our API into the application.
    With this, we already have everything we need to build many common types of applications,
    such as a news app or integrating a blog feed from a website. In the next chapter,
    we’ll add authentication to our app and display user-specific queries.
  prefs: []
  type: TYPE_NORMAL
