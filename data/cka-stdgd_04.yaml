- en: Chapter 4\. Scheduling and Tooling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章\. 调度和工具
- en: The scheduling portion of the CKA focuses on the effects of defining resource
    boundaries when evaluated by the Kubernetes scheduler. The default runtime behavior
    of the scheduler can also be modified by defining node affinity rules, as well
    as taints and tolerations. Of those concepts, you are expected only to understand
    the nuances of resource boundaries and their effect on the scheduler in different
    scenarios. Finally, this domain of the curriculum mentions high-level knowledge
    of manifest management and templating tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CKA考试的调度部分关注的是在由Kubernetes调度程序评估时定义资源边界的影响。调度程序的默认运行行为也可以通过定义节点亲和规则以及污点和容忍度来修改。在这些概念中，你只需理解资源边界的细微差别及其在不同场景中对调度程序的影响。最后，该课程领域提到了清单管理和模板工具的高级知识。
- en: 'At a high level, this chapter covers the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，本章涵盖以下概念：
- en: Resource boundaries for Pods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod的资源边界
- en: Imperative and declarative manifest management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式和声明式清单管理
- en: Common templating tools like Kustomize, `yq`, and Helm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Kustomize、`yq`和Helm这样的常见模板工具
- en: Understanding How Resource Limits Affect Pod Scheduling
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解资源限制如何影响Pod调度
- en: A Kubernetes cluster can consist of multiple nodes. Depending on a variety of
    rules (e.g., [node selectors](https://oreil.ly/m5eep), [node affinity](https://oreil.ly/9Gf7E),
    [taints and tolerations](https://oreil.ly/2SkeO)), the Kubernetes scheduler decides
    which node to pick for running the workload. The CKA exam doesn’t ask you to understand
    the scheduling concepts mentioned previously, but it would be helpful to have
    a rough idea how they work on a high level.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群可以由多个节点组成。根据各种规则（例如，[节点选择器](https://oreil.ly/m5eep)、[节点亲和性](https://oreil.ly/9Gf7E)、[污点和容忍度](https://oreil.ly/2SkeO)），Kubernetes调度程序决定选择哪个节点来运行工作负载。CKA考试并不要求你理解前述调度概念，但对它们的工作原理有个大致了解会有所帮助。
- en: One metric that comes into play for workload scheduling is the resource *request*
    defined by the containers in a Pod. Commonly used resources that can be specified
    are CPU and memory. The scheduler ensures that the node’s resource capacity can
    fulfill the resource requirements of the Pod. More specifically, the scheduler
    determines the sum of resource requests per type across all containers defined
    in the Pod and compares them with the node’s available resources. [Figure 4-1](#pod_scheduling)
    illustrates the scheduling process based on the resource requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作负载调度中起作用的一个度量标准是由Pod中的容器定义的资源*请求*。常用的可以指定的资源包括CPU和内存。调度程序确保节点的资源容量可以满足Pod的资源需求。具体来说，调度程序计算Pod中所有容器定义的每种资源类型的资源请求总和，并将其与节点的可用资源进行比较。[图 4-1](#pod_scheduling)说明了基于资源请求的调度过程。
- en: '![ckas 0401](Images/ckas_0401.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![ckas 0401](Images/ckas_0401.png)'
- en: Figure 4-1\. Pod scheduling based on resource requests
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1\. 基于资源请求的Pod调度
- en: Defining Container Resource Requests
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义容器资源请求
- en: Each container in a Pod can define its own resource requests. [Table 4-1](#options_resource_requests)
    describes the available options including an example value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod中的每个容器都可以定义自己的资源请求。[表 4-1](#options_resource_requests)描述了包括示例值在内的可用选项。
- en: Table 4-1\. Options for resource requests
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表格4-1\. 资源请求选项
- en: '| YAML Attribute | Description | Example Value |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| YAML属性 | 描述 | 示例值 |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `spec.containers[].resources.requests.cpu` | CPU resource type | `500m` (five
    hundred millicpu) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.cpu` | CPU资源类型 | `500m`（五百毫CPU）|'
- en: '| `spec.containers[].resources.requests.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.memory` | 内存资源类型 | `64Mi`（2^26字节）|'
- en: '| `spec.containers[].resources.requests.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.hugepages-<size>` | 大页面资源类型 | `hugepages-2Mi:
    60Mi` |'
- en: '| `spec.containers[].resources.requests.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.requests.ephemeral-storage` | 临时存储资源类型 | `4Gi`
    |'
- en: Kubernetes uses resource units for resource types that deviate from standard
    resource units like megabytes and gigabytes. Explaining all intricacies of those
    units goes beyond the scope this book, but you can read up on the details in the
    [documentation](https://oreil.ly/bweuT).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用资源单元来管理那些不同于标准资源单位如兆字节和千兆字节的资源类型。解释所有这些单位的复杂性超出了本书的范围，但你可以在[文档](https://oreil.ly/bweuT)中详细阅读相关细节。
- en: To make the use of those resource requests transparent, we’ll take a look at
    an example definition. The Pod YAML manifest shown in [Example 4-1](#setting_container_resource_requests)
    defines two containers, each with their own resource requests. Any node that is
    allowed to run the Pod needs to be able to support a minimum memory capacity of
    320Mi and 1250m CPU, the sum of resources across both containers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些资源请求的使用透明化，我们将查看一个定义示例。在[示例 4-1](#setting_container_resource_requests)中显示的
    Pod YAML 文件定义了两个容器，每个容器都有自己的资源请求。任何可以运行 Pod 的节点都需要支持至少320Mi内存容量和1250m CPU，这是两个容器中所有资源的总和。
- en: Example 4-1\. Setting container resource requests
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 设置容器资源请求
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this scenario, we are dealing with a Minikube Kubernetes cluster consisting
    of three nodes, one control plane node, and two worker nodes. The following command
    lists all nodes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景中，我们正在处理一个 Minikube Kubernetes 集群，包括三个节点，一个控制平面节点和两个工作节点。以下命令列出所有节点：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the next step, we’ll create the Pod from the YAML manifest. The scheduler
    places the Pod on the node named `minikube-m03`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将根据 YAML 文件创建 Pod。调度器会将 Pod 放置在名为`minikube-m03`的节点上：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Upon further inspection of the node, you can inspect its maximum capacity,
    how much of this capacity is allocatable, and the memory requests of the Pods
    scheduled on the node. The following command lists the information and condenses
    the output to the relevant bits and pieces:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步检查节点时，您可以查看其最大容量、可分配容量以及节点上调度的 Pod 的内存请求。以下命令列出了相关信息，并将输出压缩为相关的片段：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s certainly possible that a Pod cannot be scheduled due to insufficient resources
    available on the nodes. In those cases, the event log of the Pod will indicate
    this situation with the reasons `PodExceedsFreeCPU` or `PodExceedsFreeMemory`.
    For more information on how to troubleshoot and resolve this situation, see the
    relevant [section in the documentation](https://oreil.ly/ZzK0B).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可能由于节点上可用资源不足而无法调度 Pod。在这些情况下，Pod 的事件日志将以`PodExceedsFreeCPU`或`PodExceedsFreeMemory`的原因指示此情况。有关如何排查和解决此情况的更多信息，请参阅相关[文档部分](https://oreil.ly/ZzK0B)。
- en: Defining Container Resource Limits
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义容器资源限制
- en: Another metric you can set for a container are its resource *limits*. Resource
    limits ensure that the container cannot consume more than the allotted resource
    amounts. For example, you could express that the application running in the container
    should be constrained to 1000m of CPU and 512Mi of memory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以为容器设置的度量标准是其资源*限制*。资源限制确保容器不会消耗超过分配的资源量。例如，您可以表达运行在容器中的应用程序应被限制在1000m的CPU和512Mi的内存。
- en: Depending on the container runtime used by the cluster, exceeding any of the
    allowed resource limits results in a termination of the application process running
    in the container or results in the system preventing the allocation of resources
    beyond the limits altogether. For an in-depth discussion on how resource limits
    are treated by the container runtime Docker, see the [documentation](https://oreil.ly/szUaM).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据集群使用的容器运行时，超出任何允许的资源限制会导致终止容器中运行的应用程序进程，或者系统会完全阻止分配超出限制的资源。关于 Docker 容器运行时如何处理资源限制的深入讨论，请参阅[文档](https://oreil.ly/szUaM)。
- en: '[Table 4-2](#options_resource_limits) describes the available options including
    an example value.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](#options_resource_limits)描述了包括示例值在内的可用选项。'
- en: Table 4-2\. Options for resource limits
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2\. 资源限制选项
- en: '| YAML Attribute | Description | Example Value |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| YAML 属性 | 描述 | 示例值 |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `spec.containers[].resources.limits.cpu` | CPU resource type | `500m` (500
    millicpu) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.cpu` | CPU 资源类型 | `500m` (500 毫CPU) |'
- en: '| `spec.containers[].resources.limits.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.memory` | 内存资源类型 | `64Mi` (2^26 字节) |'
- en: '| `spec.containers[].resources.limits.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.hugepages-<size>` | 大页面资源类型 | `hugepages-2Mi:
    60Mi` |'
- en: '| `spec.containers[].resources.limits.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `spec.containers[].resources.limits.ephemeral-storage` | 临时存储资源类型 | `4Gi`
    |'
- en: '[Example 4-2](#setting_container_resource_limits) shows the definition of limits
    in action. Here, the container named `business-app` cannot use more than 512Mi
    of memory and 2000m of CPU. The container named `ambassador` defines a limit of
    128Mi of memory and 500m of CPU.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-2](#setting_container_resource_limits) 展示了限制定义的实际应用。在这里，名为 `business-app`
    的容器不能使用超过 512Mi 的内存和 2000m 的 CPU。名为 `ambassador` 的容器定义了 128Mi 的内存和 500m 的 CPU
    的限制。'
- en: Example 4-2\. Setting container resource limits
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 设置容器资源限制
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Assume that the Pod was scheduled on the node `minikube-m03`. Describing the
    node’s details reveals that the CPU and memory limits took effect. But there’s
    more. Kubernetes automatically assigns the same amount of resources for the requests
    if you only define the limits:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Pod 被调度到节点 `minikube-m03` 上。描述节点的详细信息显示了 CPU 和内存限制已生效。但还有更多。如果只定义了限制，Kubernetes
    会自动为请求分配相同数量的资源：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Defining Container Resource Requests and Limits
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器资源请求和限制的定义
- en: It’s recommended practice that you specify resource requests and limits for
    every container. Determining those resource expectations is not always easy, specifically
    for applications that haven’t been exercised in a production environment yet.
    Load testing the application early on during the development cycle can help with
    analyzing the resource needs. Further adjustments can be made by monitoring the
    application’s resource consumption after deploying it to the cluster. [Example 4-3](#settings_container_resource_requests_limits)
    combines resource requests and limits in a single YAML manifest.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 建议为每个容器指定资源请求和限制。确定这些资源期望并不总是容易，特别是对于尚未在生产环境中使用过的应用程序。在开发周期的早期阶段进行负载测试可以帮助分析资源需求。将应用程序部署到集群后，通过监控应用程序的资源消耗可以进行进一步调整。[示例 4-3](#settings_container_resource_requests_limits)
    在单个 YAML 清单中结合了资源请求和限制。
- en: Example 4-3\. Setting container resource requests and limits
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 设置容器资源请求和限制
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a result, you can see the different settings for resource requests and limits:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到不同的资源请求和限制的设置：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Managing Objects
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象
- en: Kubernetes objects can be created, modified, and deleted by using imperative
    `kubectl` commands or by running a `kubectl` command against a configuration file
    declaring the desired state of an object, a so-called manifest. The primary definition
    language of a manifest is YAML, though you can opt for JSON, which is the less
    widely adopted format among the Kubernetes community. It’s recommended that development
    teams commit and push those configuration files to version control repositories
    as it will help with tracking and auditing changes over time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令式的 `kubectl` 命令或者针对声明了对象期望状态的配置文件（称为清单）运行 `kubectl` 命令可以创建、修改和删除 Kubernetes
    对象。清单的主要定义语言是 YAML，尽管您也可以选择 JSON，后者在 Kubernetes 社区中采用较少。建议开发团队将这些配置文件提交并推送到版本控制存储库，以便随时间跟踪和审计变更。
- en: Modeling an application in Kubernetes often requires a set of supporting objects,
    each of which can have their own manifest. For example, you may want to create
    a Deployment that runs the application on five Pods, a ConfigMap to inject configuration
    data as environment variables, and a Service for exposing network access.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中建模应用程序通常需要一组支持对象，每个对象可以有自己的清单。例如，您可能希望创建一个部署，将应用程序运行在五个 Pod 上，一个
    ConfigMap 以将配置数据注入为环境变量，以及一个 Service 用于公开网络访问。
- en: This section primarily focuses on the declarative object management support
    with the help of manifests. For a deeper discussion on the imperative support,
    see the relevant portions in the [documentation](https://oreil.ly/Slw0h). Furthermore,
    we’ll touch on tools like Kustomize and Helm to give you an impression of their
    benefits, capabilities, and workflows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要关注声明式对象管理的支持，借助清单来实现。要深入讨论命令式支持，请参阅[文档](https://oreil.ly/Slw0h)中相关部分。此外，我们将涉及类似
    Kustomize 和 Helm 的工具，以让您了解它们的优势、功能和工作流程。
- en: Declarative Object Management Using Configuration Files
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置文件进行声明式对象管理
- en: Declarative object management requires one or several configuration files in
    the format of YAML or JSON describing the desired state of an object. You create,
    update, and delete objects with this approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式对象管理需要一个或多个配置文件，格式可以是 YAML 或 JSON，描述对象的期望状态。您可以通过这种方法创建、更新和删除对象。
- en: Creating objects
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对象
- en: To create new objects, run the `apply` command by pointing to a file, a directory
    of files, or a file referenced by an HTTP(S) URL using the `-f` option. If one
    or many of the objects already exist, the command will synchronize the changes
    made to the configuration with the live object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新对象，请使用`apply`命令，指向一个文件、文件目录或通过HTTP(S) URL引用的文件，并使用`-f`选项。如果一个或多个对象已经存在，则命令将会同步配置所做的更改与实时对象。
- en: 'To demonstrate the functionality, we’ll assume the following directories and
    configuration files. The following commands create objects from a single file,
    from all files within a directory, and from all files in a directory recursively:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示功能，我们假设以下目录和配置文件。以下命令从单个文件创建对象，从目录中的所有文件创建对象，以及递归目录中的所有文件创建对象：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Creating an object from a single file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个文件创建对象：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Creating objects from multiple files within a directory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录中的多个文件创建对象：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Creating objects from a recursive directory tree containing files:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含文件的递归目录树创建对象：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating objects from a file referenced by an HTTP(S) URL:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从通过HTTP(S) URL引用的文件创建对象：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `apply` command keeps track of the changes by adding or modifying the annotation
    with the key `kubectl.kubernetes.io/last-applied-configuration`. You can find
    an example of the annotation in the output of the `get pod` command here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`命令通过添加或修改带有键`kubectl.kubernetes.io/last-applied-configuration`的注释来跟踪更改。您可以在此处`get
    pod`命令的输出中找到注释的示例：'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Updating objects
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新对象
- en: Updating an existing object is done with the same `apply` command. All you need
    to do is to change the configuration file and then run the command against it.
    [Example 4-4](#modified_configuration_file_deployment) modifies the existing configuration
    of a Deployment in the file `nginx-deployment.yaml`. We added a new label with
    the key `team` and changed the number of replicas from 3 to 5.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有对象使用相同的`apply`命令完成。您只需更改配置文件，然后运行该命令。[示例 4-4](#modified_configuration_file_deployment)修改了文件`nginx-deployment.yaml`中部署的现有配置。我们添加了一个新标签，键为`team`，并将副本数从3修改为5。
- en: Example 4-4\. Modified configuration file for a Deployment
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 修改后的部署配置文件
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following command applies the changed configuration file. As a result,
    the number of Pods controlled by the underlying ReplicaSet is 5\. The Deployment’s
    annotation `kubectl.kubernetes.io/last-applied-configuration` reflects the latest
    change to the configuration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令应用了更改后的配置文件。结果，由底层副本集控制的Pod数量为5。部署的注释`kubectl.kubernetes.io/last-applied-configuration`反映了配置的最新更改：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deleting objects
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除对象
- en: 'While there is a way to delete objects using the `apply` command by providing
    the options `--prune -l <labels>`, it is recommended to delete an object using
    the `delete` command and point it to the configuration file. The following command
    deletes a Deployment and the objects it controls (ReplicaSet and Pods):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用`apply`命令删除对象，提供选项`--prune -l <labels>`，但建议使用`delete`命令删除对象，并指向配置文件。以下命令删除一个部署及其控制的对象（副本集和Pod）：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Declarative Object Management Using Kustomize
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kustomize进行声明式对象管理
- en: 'Kustomize is a tool introduced with Kubernetes 1.14 that aims to make manifest
    management more convenient. It supports three different use cases:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize是一个引入于Kubernetes 1.14的工具，旨在使清单管理更加方便。它支持三种不同的使用场景：
- en: Generating manifests from other sources. For example, creating a ConfigMap and
    populating its key-value pairs from a properties file.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他来源生成清单。例如，创建一个ConfigMap，并从属性文件填充其键值对。
- en: Adding common configuration across multiple manifests. For example, adding a
    namespace and a set of labels for a Deployment and a Service.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加多个清单中的通用配置。例如，为部署和服务添加命名空间和一组标签。
- en: Composing and customizing a collection of manifests. For example, setting resource
    boundaries for multiple Deployments.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和自定义一组清单。例如，为多个部署设置资源边界。
- en: The central file needed for Kustomize to work is the *kustomization file*. The
    standardized name for the file is `kustomization.yaml` and cannot be changed.
    A kustomization file defines the processing rules Kustomize works upon.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize正常工作所需的中心文件是*kustomization文件*。该文件的标准名称为`kustomization.yaml`，不可更改。一个kustomization文件定义了Kustomize处理的处理规则。
- en: 'Kustomize is fully integrated with `kubectl` and can be executed in two modes:
    rendering the processing output on the console or creating the objects. Both modes
    can operate on a directory, tarball, Git archive, or URL as long as they contain
    the kustomization file and referenced resource files:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize与`kubectl`完全集成，可以以两种模式执行：在控制台上呈现处理输出或创建对象。只要它们包含kustomization文件和引用的资源文件，这两种模式都可以操作目录、tarball、Git存档或URL：
- en: Rendering the produced output
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现生成的输出
- en: 'The first mode uses the `kustomize` subcommand to render the produced result
    on the console but does not create the objects. This command works similar to
    the dry-run option you might know from the `run` command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种模式使用`kustomize`子命令在控制台上呈现生成的结果，但不创建对象。此命令类似于您可能从`run`命令中了解的干运行选项：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating the objects
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'The second mode uses the `apply` command in conjunction with the `-k` command-line
    option to apply the resources processed by Kustomize, as explained in the previous
    section:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式使用`apply`命令与`-k`命令行选项结合使用，以应用Kustomize处理的资源，如前一节所述：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The following sections demonstrate each of the use cases by a single example.
    For a full coverage on all possible scenarios, refer to the [documentation](https://oreil.ly/JUHXj)
    or the [Kustomize GitHub repository](https://oreil.ly/4MirA).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分通过单个示例演示了每个用例。要全面覆盖所有可能的场景，请参阅[文档](https://oreil.ly/JUHXj)或[Kustomize GitHub存储库](https://oreil.ly/4MirA)。
- en: Composing Manifests
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合清单
- en: 'One of the core functionalities of Kustomize is to create a composed manifest
    from other manifests. Combining multiple manifests into a single one may not seem
    that useful by itself, but many of the other features described later will build
    upon this capability. Say you wanted to compose a manifest from a Deployment and
    a Service resource file. All you need to do is to place the resource files into
    the same folder as the kustomization file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize的核心功能之一是从其他清单创建组合清单。将多个清单合并为一个可能看起来并不那么有用，但稍后描述的许多其他功能将基于这种能力构建。假设您想要从一个部署和一个服务资源文件中组合清单。您所需做的就是将资源文件放入与kustomization文件相同的文件夹中：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The kustomization file lists the resources in the `resources` section, as shown
    in [Example 4-5](#kustomization_file_combining).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: kustomization文件在`resources`部分列出了资源，如[示例 4-5](#kustomization_file_combining)所示。
- en: Example 4-5\. A kustomization file combining two manifests
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 结合两个清单的kustomization文件
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a result, the `kustomize` subcommand renders the combined manifest containing
    all of the resources separated by three hyphens (`---`) to denote the different
    object definitions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`kustomize`子命令呈现了包含所有资源的组合清单，这些资源由三个连字符（`---`）分隔以表示不同的对象定义：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Generating manifests from other sources
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从其他来源生成清单
- en: Earlier in this chapter, we learned that ConfigMaps and Secrets can be created
    by pointing them to a file containing the actual configuration data for it. Kustomize
    can help with the process by mapping the relationship between the YAML manifest
    of those configuration objects and their data. Furthermore, we’ll want to inject
    the created ConfigMap and Secret in a Pod as environment variables. In this section,
    you will learn how to achieve this with the help of Kustomize.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们了解到ConfigMaps和Secrets可以通过将它们指向包含实际配置数据的文件来创建。Kustomize可以通过映射这些配置对象的YAML清单与它们的数据之间的关系来帮助处理这个过程。此外，我们还希望将创建的ConfigMap和Secret作为环境变量注入到Pod中。在本节中，您将学习如何借助Kustomize实现此目标。
- en: 'The following file and directory structure contains the manifest file for the
    Pod and the configuration data files we need for the ConfigMap and Secret. The
    mandatory kustomization file lives on the root level of the directory tree:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的文件和目录结构包含了Pod的清单文件以及我们需要用于ConfigMap和Secret的配置数据文件。强制的kustomization文件位于目录树的根级别：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In `kustomization.yaml`, you can define that the ConfigMap and Secret object
    should be generated with the given name. The name of the ConfigMap is supposed
    to be `db-config`, and the name of the Secret is going to be `db-creds`. Both
    of the generator attributes, `configMapGenerator` and `secretGenerator`, reference
    an input file used to feed in the configuration data. Any additional resources
    can be spelled out with the `resources` attribute. [Example 4-6](#kustomization_file_configmap_secret)
    shows the contents of the kustomization file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kustomization.yaml`中，您可以定义应以给定名称生成ConfigMap和Secret对象。ConfigMap的名称应为`db-config`，Secret的名称将为`db-creds`。`configMapGenerator`和`secretGenerator`的两个生成器属性引用用于输入配置数据的输入文件。可以使用`resources`属性明确指定任何其他资源。[示例 4-6](#kustomization_file_configmap_secret)显示了kustomization文件的内容。
- en: Example 4-6\. A kustomization file using a ConfigMap and Secret generator
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 使用ConfigMap和Secret生成器的kustomization文件
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Kustomize generates ConfigMaps and Secrets by appending a suffix to the name.
    You can see this behavior when creating the objects using the `apply` command.
    The ConfigMap and Secret can be referenced by name in the Pod manifest:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize通过向名称添加后缀来生成ConfigMaps和Secrets。使用`apply`命令创建对象时可以看到此行为。Pod清单中可以按名称引用ConfigMap和Secret：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This naming strategy can be configured with the attribute `generatorOptions`
    in the kustomization file. See the [documentation](https://oreil.ly/M7tlD) for
    more information.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在kustomization文件中使用属性`generatorOptions`配置此命名策略。有关更多信息，请参阅[文档](https://oreil.ly/M7tlD)。
- en: 'Let’s also try the `kustomize` subcommand. Instead of creating the objects,
    the command renders the processed output on the console:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试`kustomize`子命令。该命令不会创建对象，而是在控制台上呈现处理后的输出：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Adding common configuration across multiple manifests
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个清单文件中添加常见配置
- en: Application developers usually work on an application stack set comprised of
    multiple manifests. For example, an application stack could consist of a frontend
    microservice, a backend microservice, and a database. It’s common practice to
    use the same, cross-cutting configuration for each of the manifests. Kustomize
    offers a range of supported fields (e.g., namespace, labels, or annotations).
    Refer to the [documentation](https://oreil.ly/OyNbh) to learn about all supported
    fields.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发人员通常在由多个清单组成的应用程序堆栈集上工作。例如，应用程序堆栈可以由前端微服务、后端微服务和数据库组成。通常的做法是为每个清单使用相同的交叉配置（如命名空间、标签或注释）。Kustomize提供了一系列支持的字段（例如命名空间、标签或注释）。请参阅[文档](https://oreil.ly/OyNbh)以了解所有支持的字段。
- en: 'For the next example, we’ll assume that a Deployment and a Service live in
    the same namespace and use a common set of labels. The namespace is called `persistence`
    and the label is the key-value pair `team: helix`. [Example 4-7](#kustomization_file_common_fields)
    illustrates how to set those common fields in the kustomization file.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '对于下一个示例，我们假设一个Deployment和一个Service位于同一个命名空间，并使用共同的一组标签。命名空间称为`persistence`，标签是键值对`team:
    helix`。[示例 4-7](#kustomization_file_common_fields)展示了如何在kustomization文件中设置这些共同字段。'
- en: Example 4-7\. A kustomization file using a common field
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. 使用共同字段的kustomization文件
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To create the referenced objects in the kustomization file, run the `apply`
    command. Make sure to create the `persistence` namespace beforehand:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在kustomization文件中创建引用的对象，请运行`apply`命令。确保预先创建`persistence`命名空间：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The YAML representation of the processed files looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 处理后的文件的YAML表示如下：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Customizing a collection of manifests
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制一组清单文件
- en: Kustomize can merge the contents of a YAML manifest with a code snippet from
    another YAML manifest. Typical use cases include adding security context configuration
    to a Pod definition or setting resource boundaries for a Deployment. The kustomization
    file allows for specifying different patch strategies like `patchesStrategicMerge`
    and `patchesJson6902`. For a deeper discussion on the differences between patch
    strategies, refer to the documentation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize可以将一个YAML清单文件的内容与另一个YAML清单文件中的代码片段合并。典型用例包括向Pod定义中添加安全上下文配置或为Deployment设置资源边界。kustomization文件允许指定不同的补丁策略，如`patchesStrategicMerge`和`patchesJson6902`。有关补丁策略之间差异的更深入讨论，请参阅文档。
- en: '[Example 4-8](#kustomization_file_patch) shows the contents of a kustomization
    file that patches a Deployment definition in the file `nginx-deployment.yaml`
    with the contents of the file `security-context.yaml`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-8](#kustomization_file_patch)显示了一个kustomization文件的内容，该文件用文件`nginx-deployment.yaml`中的Deployment定义修补文件`security-context.yaml`的内容。'
- en: Example 4-8\. A kustomization file defining a patch
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 定义补丁的 Kustomization 文件
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The patch file shown in [Example 4-9](#path_yaml_manifest) defines a security
    context on the container-level for the Pod template of the Deployment. At runtime,
    the patch strategy tries to find the container named `nginx` and enhances the
    additional configuration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-9](#path_yaml_manifest)中显示的补丁文件为 Deployment 的 Pod 模板定义了安全上下文。在运行时，补丁策略尝试查找名为`nginx`的容器并增强额外的配置。
- en: Example 4-9\. The patch YAML manifest
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 补丁 YAML 清单
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is a patched Deployment definition, as shown in the output of the
    `kustomize` subcommand shown next. The patch mechanism can be applied to other
    files that require a uniform security context definition:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个已打补丁的部署定义，如下一个展示的`kustomize`子命令的输出所示。补丁机制可以应用于其他需要统一安全上下文定义的文件：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Common Templating Tools
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见模板工具
- en: As demonstrated in the previous section, Kustomize offers templating functionality.
    The Kubernetes ecosystem offers other solutions to the problem that we will discuss
    here. We will touch on the YAML processor `yq` and the templating engine Helm.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所示，Kustomize 提供了模板功能。Kubernetes 生态系统提供了其他解决此问题的解决方案，我们将在这里讨论。我们将涉及 YAML
    处理器`yq`和模板引擎 Helm。
- en: Using the YAML Processor yq
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 YAML 处理器 yq
- en: The tool `yq` is used to read, modify, and enhance the contents of a YAML file.
    This section will demonstrate all three use cases. For a detailed list of usage
    example, see the [GitHub repository](https://oreil.ly/ORZDV). During the CKA exam,
    you may be asked to apply those techniques though you are not expected to understand
    all intricacies of the tools at hand. The version of `yq` used to describe the
    functionality below is 4.2.1.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 工具`yq`用于读取、修改和增强 YAML 文件的内容。本节将演示这三种用法。有关详细使用示例列表，请参阅[GitHub 仓库](https://oreil.ly/ORZDV)。在
    CKA 考试期间，您可能会被要求应用这些技术，尽管不必深入理解所用工具的所有复杂性。下文描述的`yq`版本是 4.2.1。
- en: Reading values
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取值
- en: Reading values from an existing YAML file requires the use of a YAML path expression.
    A path expression allows you to deeply navigate the YAML structure and extract
    the value of an attribute you are searching for. [Example 4-10](#yaml_manifest_pod)
    shows the YAML manifest of a Pod that defines two environment variables.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有 YAML 文件中读取值需要使用 YAML 路径表达式。路径表达式允许您深入导航 YAML 结构并提取您正在查找的属性的值。[示例 4-10](#yaml_manifest_pod)显示了定义两个环境变量的
    Pod 的 YAML 清单。
- en: Example 4-10\. The YAML manifest of a Pod
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. Pod 的 YAML 清单
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To read a value, use the command `eval` or the short form `e`, provide the
    YAML path expression, and point it to the source file. The following two commands
    read the Pod’s name and the value of the second environment variable defined by
    a single container. Notice that the path expression needs to start with a mandatory
    dot character (`.`) to denote the root node of the YAML structure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取一个值，使用命令`eval`或简写`e`，提供 YAML 路径表达式，并将其指向源文件。以下两个命令读取 Pod 的名称和单个容器定义的第二个环境变量的值。注意，路径表达式需要以必需的点字符（`.`）开头，表示
    YAML 结构的根节点：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Modifying values
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改值
- en: 'Modifying an existing value is as easy as using the same command and adding
    the `-i` flag. The assignment of the new value to an attribute happens by assigning
    it to the path expression. The following command changes the second environment
    variable of the Pod YAML file to the value 1.6.0:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有值与使用相同的命令并添加`-i`标志一样简单。通过将新值分配给路径表达式来将新值分配给属性。以下命令将 Pod YAML 文件的第二个环境变量更改为值
    1.6.0：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Merging YAML files
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并 YAML 文件
- en: Similar to Kustomize, `yq` can merge multiple YAML files. Kustomize is definitely
    more powerful and convenient to use; however, `yq` can come in handy for smaller
    projects. Say you wanted to merge the sidecar container definition shown in [Example 4-11](#yaml_manifest_container)
    into the Pod YAML file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kustomize 类似，`yq`可以合并多个 YAML 文件。Kustomize 显然更强大且更方便使用；但是，对于较小的项目，`yq`可能会派上用场。比如，您希望将[示例 4-11](#yaml_manifest_container)中显示的
    sidecar 容器定义合并到 Pod 的 YAML 文件中。
- en: Example 4-11\. The YAML manifest of a container definition
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-11\. 容器定义的 YAML 清单
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The command to achieve this is `eval-all`. We won’t go into details given the
    multitude of configuration options for this command. For a deep dive, check the
    `yq` user manual on the [“Multiply (Merge)” operation](https://oreil.ly/2I6ir).
    The following command appends the sidecar container to the existing container
    array of the Pod manifest:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此操作的命令是 `eval-all`。鉴于此命令的多种配置选项，我们不会深入讨论。如需详细了解，请查阅 [“Multiply (Merge)” operation](https://oreil.ly/2I6ir)
    在 `yq` 用户手册中的介绍。以下命令将在现有容器数组的 Pod 清单中附加 sidecar 容器：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using Helm
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Helm
- en: '[Helm](https://helm.sh) is a templating engine and package manager for a set
    of Kubernetes manifests. At runtime, it replaces placeholders in YAML template
    files with actual, end-user defined values. The artifact produced by the Helm
    executable is a so-called *chart file* bundling the manifests that comprise the
    API resources of an application. This chart file can be uploaded to a package
    manager to be used during the deployment process. The Helm ecosystem offers a
    wide range of reusable charts for common use cases on a [central chart repository](https://oreil.ly/1OLIi)
    (e.g., for running Grafana or PostgreSQL).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[Helm](https://helm.sh) 是一个用于 Kubernetes 清单的模板引擎和包管理器。在运行时，它将 YAML 模板文件中的占位符替换为实际的、用户定义的值。由
    Helm 可执行文件生成的产物称为 *chart 文件*，打包了组成应用程序的 API 资源的清单。这个 chart 文件可以上传到包管理器，在部署过程中使用。Helm
    生态系统在[中央图表库](https://oreil.ly/1OLIi)中提供了大量可重用的图表，例如运行 Grafana 或 PostgreSQL。'
- en: Due to the wealth of functionality available to Helm, we’ll discuss only the
    very basics. The CKA exam does not expect you be a Helm expert; rather, it wants
    to be familiar with the benefits and concepts. For more detailed information on
    Helm, see the [user documentation](https://helm.sh/docs). The version of Helm
    used to describe the functionality here is 3.7.0.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Helm 提供了丰富的功能，我们仅讨论最基础的部分。CKA 考试不要求您成为 Helm 的专家，而是希望您熟悉其优势和概念。有关 Helm 的更详细信息，请参阅[用户文档](https://helm.sh/docs)。本文描述的
    Helm 版本为 3.7.0。
- en: Standard Chart Structure
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准图表结构
- en: 'A chart needs to follow a predefined directory structure. You can choose any
    name for the root directory. Within the directory, two files need to exist: `Chart.yaml`
    and `values.yaml`. The file `Chart.yaml` describes the meta information of the
    chart (e.g., name and version). The file `values.yaml` contains the key-value
    pairs used at runtime to replace the placeholders in the YAML manifests. Any template
    file meant to be packaged into the chart archive file needs to be put in the `templates`
    directory. Files located in the `template` directory do not have to follow any
    naming conventions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图表需要遵循预定义的目录结构。您可以为根目录选择任何名称。在该目录中，必须存在两个文件：`Chart.yaml` 和 `values.yaml`。文件
    `Chart.yaml` 描述了图表的元信息（例如名称和版本）。文件 `values.yaml` 包含了运行时用于替换 YAML 清单中占位符的键值对。任何打包到图表归档文件中的模板文件都需要放在
    `templates` 目录中。位于 `templates` 目录中的文件不需要遵循任何命名约定。
- en: 'The following directory structure shows an example chart. The `templates` directory
    contains a file for a Pod and a Service:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下目录结构展示了一个图表示例。`templates` 目录包含一个 Pod 和一个 Service 的文件：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The chart file
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图表文件
- en: The file `Chart.yaml` describes the chart on a high level. Mandatory attributes
    include the chart’s API version, the name, and the version. Additionally, optional
    attributes can be provided. For a full list of attributes, see the relevant [documentation](https://oreil.ly/VUrm1).
    [Example 4-12](#basic_helm_chart_file) shows the bare minimum of a chart file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `Chart.yaml` 在高层次描述了图表。必填属性包括图表的 API 版本、名称和版本。此外，还可以提供可选属性。有关属性的完整列表，请参阅相关的[文档](https://oreil.ly/VUrm1)。[示例 4-12](#basic_helm_chart_file)
    显示了图表文件的最基本内容。
- en: Example 4-12\. A basic Helm chart file
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. 一个基本的 Helm 图表文件
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The values file
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值文件
- en: The file `values.yaml` defines key-value pairs to be used to replace placeholders
    in the YAML template files. [Example 4-13](#helm_values_file) specifies four key-value
    pairs. Be aware that the file can be empty if you don’t want to replace values
    at runtime.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `values.yaml` 定义了用于替换 YAML 模板文件中占位符的键值对。[示例 4-13](#helm_values_file) 指定了四组键值对。请注意，如果您不希望在运行时替换值，该文件可以为空。
- en: Example 4-13\. A Helm values file
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-13\. 一个 Helm values 文件
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The template files
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板文件
- en: Template files need to live in the `templates` directory. A template file is
    a regular YAML manifest that can (optionally) define placeholders with the help
    of double curly braces (`{{ }}`). To reference a value from the `values.yaml`
    file, use the expression `{{ .Values.<key> }}`. For example, to replace the value
    of the key `db_host` at runtime, use the expression `{{ .Values.db_host }}`. [Example 4-14](#yaml_template_manifest_pod)
    defines a Pod as a template while defining three placeholders that reference values
    from `values.yaml`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文件需要存放在 `templates` 目录中。模板文件是一个常规的YAML清单，可以（可选地）使用双大括号(`{{ }}`)定义占位符。要从 `values.yaml`
    文件中引用值，请使用表达式 `{{ .Values.<key> }}`。例如，要在运行时替换 `db_host` 键的值，请使用表达式 `{{ .Values.db_host
    }}`。 [示例 4-14](#yaml_template_manifest_pod) 定义了一个Pod作为模板，同时定义了三个引用 `values.yaml`
    中值的占位符。
- en: Example 4-14\. The YAML template manifest of a Pod
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. Pod的YAML模板清单
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Executing Helm commands
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行Helm命令
- en: 'The Helm executable comes with a wide range of commands. Let’s demonstrate
    some of them. The `template` command renders the chart templates locally and displays
    results on the console. You can see the operation in action in the following output.
    All placeholders have been replaced by their actual values sourced from the `values.yaml`
    file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Helm可执行文件配备广泛的命令。我们来演示其中一些。 `template` 命令在本地渲染图表模板并在控制台显示结果。您可以在以下输出中看到操作的实际效果。所有占位符都已由
    `values.yaml` 文件中的实际值替换：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you are happy with the result, you’ll want to bundle the template files
    into a chart archive file. The chart archive file is a compressed TAR file with
    the file ending `.tgz`. The `package` command evaluates the metadata information
    from `Chart.yaml` to derive the chart archive filename:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您满意结果，您将希望将模板文件打包成图表存档文件。图表存档文件是一个以 `.tgz` 结尾的压缩TAR文件。 `package` 命令评估 `Chart.yaml`
    中的元数据信息以导出图表存档文件名：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For a full list of commands and typical workflows, refer to the Helm [documentation
    page](https://oreil.ly/Jz6eD).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解所有命令和典型工作流程的完整列表，请参阅Helm [文档页面](https://oreil.ly/Jz6eD)。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Resource boundaries are one of the many factors that the kube-scheduler algorithm
    considers when making decisions on which node a Pod can be scheduled. A container
    can specify resource requests and limits. The scheduler chooses a node based on
    its available hardware capacity.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 资源边界是 kube-scheduler 算法在决定可以将Pod调度到哪个节点时考虑的众多因素之一。容器可以指定资源请求和限制。调度程序根据其可用的硬件容量选择节点。
- en: Declarative manifest management is the preferred way of creating, modifying,
    and deleting objects in real-world, cloud-native projects. The underlying YAML
    manifest is meant to be checked into version control and automatically tracks
    the changes made to a object including its timestamp for a corresponding commit
    hash. The `kubectl apply` and `delete` command can perform those operations for
    one or many YAML manifests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式清单管理是在实际的云原生项目中创建、修改和删除对象的首选方法。底层的YAML清单应存入版本控制，并自动跟踪对对象所做的更改，包括其相应提交哈希的时间戳。
    `kubectl apply` 和 `delete` 命令可以对一个或多个YAML清单执行这些操作。
- en: Additional tools emerged for more convenient manifest management. Kustomize
    is fully integrated with the `kubectl` tool chain. It helps with the generation,
    composition, and customization of manifests. Tools with templating capabilities
    like `yq` and Helm can further ease various workflows for managing application
    stacks represented by a set of manifests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了更多方便的清单管理工具。Kustomize与 `kubectl` 工具链完全集成。它帮助生成、组合和定制清单。具有模板功能的工具如 `yq` 和
    Helm 可进一步简化管理应用程序堆栈的各种工作流程所需的清单。
- en: Exam Essentials
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考试要点
- en: Understand the effects of resource boundaries on scheduling
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 理解资源边界对调度的影响
- en: A container defined by a Pod can specify resource requests and limits. Work
    through scenarios where you define those boundaries individually and together
    for single- and multi-container Pods. Upon creation of the Pod, you should be
    able to see the effects on scheduling the object on a node. Furthermore, practice
    how to identify the available resource capacity of a node.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由Pod定义的容器可以指定资源请求和限制。通过定义单容器和多容器Pod的边界，分析能看到在节点上调度对象的效果。此外，练习如何识别节点的可用资源容量。
- en: Manage objects using the imperative and declarative approach
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令式和声明式方法管理对象
- en: YAML manifests are essential for expressing the desired state of an object.
    You will need to understand how to create, update, and delete objects using the
    `kubectl apply` command. The command can point to a single manifest file or a
    directory containing multiple manifest files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 清单对于表达对象的期望状态至关重要。您需要了解如何使用`kubectl apply`命令创建、更新和删除对象。该命令可以指向单个清单文件或包含多个清单文件的目录。
- en: Have a high-level understanding of common templating tools
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对常见模板化工具有高级别的理解
- en: Kustomize, `yg`, and Helm are established tools for managing YAML manifests.
    Their templating functionality supports complex scenarios like composing and merging
    multiple manifests. For the exam, take a practical look at the tools, their functionality,
    and the problems they solve.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize、`yg`和 Helm 是管理 YAML 清单的成熟工具。它们的模板功能支持像合成和合并多个清单这样的复杂场景。在考试中，深入了解这些工具、它们的功能以及它们解决的问题。
- en: Sample Exercises
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例练习
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的解决方案可以在[附录](app01.xhtml#appendix-a)中找到。
- en: Write a manifest for a new Pod named `ingress-controller` with a single container
    that uses the image `bitnami/nginx-ingress-controller:1.0.0`. For the container,
    set the resource request to 256Mi for memory and 1 CPU. Set the resource limits
    to 1024Mi for memory and 2.5 CPU.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为名为`ingress-controller`的新 Pod 编写清单，其中包含一个使用镜像`bitnami/nginx-ingress-controller:1.0.0`的容器。对于容器，将内存请求设置为256Mi，CPU
    设置为1。将内存限制设置为1024Mi，CPU 设置为2.5。
- en: Using the manifest, schedule the Pod on a cluster with three nodes. Once created,
    identify the node that runs the Pod. Write the node name to the file `node.txt`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用清单，在三个节点的集群上安排 Pod 的调度。创建后，确定运行 Pod 的节点。将节点名称写入文件`node.txt`。
- en: 'Create the directory named `manifests`. Within the directory, create two files:
    `pod.yaml` and `configmap.yaml`. The `pod.yaml` file should define a Pod named
    `nginx` with the image `nginx:1.21.1`. The `configmap.yaml` file defines a ConfigMap
    named `logs-config` with the key-value pair `dir=/etc/logs/traffic.log`. Create
    both objects with a single, declarative command.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`manifests`的目录。在目录中创建两个文件：`pod.yaml`和`configmap.yaml`。`pod.yaml`文件应定义一个名为`nginx`的
    Pod，使用的镜像是`nginx:1.21.1`。`configmap.yaml`文件定义了一个名为`logs-config`的 ConfigMap，具有键值对`dir=/etc/logs/traffic.log`。使用单个声明性命令创建这两个对象。
- en: Modify the ConfigMap manifest by changing the value of the key `dir` to `/etc/logs/traffic-log.txt`.
    Apply the changes. Delete both objects with a single declarative command.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 ConfigMap 清单，将键`dir`的值更改为`/etc/logs/traffic-log.txt`。应用更改。使用单个声明性命令删除两个对象。
- en: Use Kustomize to set a common namespace `t012` for the resource file `pod.yaml`.
    The file `pod.yaml` defines the Pod named `nginx` with the image `nginx:1.21.1`
    without a namespace. Run the Kustomize command that renders the transformed manifest
    on the console.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Kustomize 为资源文件`pod.yaml`设置一个常见命名空间`t012`。文件`pod.yaml`定义了名为`nginx`的 Pod，使用的镜像是`nginx:1.21.1`，没有命名空间。运行
    Kustomize 命令，在控制台上呈现转换后的清单。
