- en: Chapter 11\. Configuring and Tuning the Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL installation process (see [Chapter 1](ch01.xhtml#CH1_INSTALL)) provides
    everything necessary to install the MySQL process and start using it. However,
    it is required for production systems to do some fine-tuning, adjusting MySQL
    parameters and the operating system to optimize MySQL Server’s performance. This
    chapter will cover the recommended best practices for different installations
    and show you the parameters that need to be adjusted based on the expected or
    current workload. As you’ll see, it is not necessary to memorize all the MySQL
    parameters. Based on the [*Pareto principle*](https://oreil.ly/1d58s), which states
    that, for many events, roughly 80% of the effects come from 20% of the causes,
    we will concentrate on the MySQL and operating system parameters that are responsible
    for most of the performance issues. There are some advanced topics in this chapter
    related to computer architecture (such as NUMA); the intent here is to introduce
    you to a few components that can affect MySQL performance that you will need to
    interact with sooner or later in your career.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL Server Daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since 2015, the majority of Linux distributions have adopted `systemd`. Because
    of that, Linux operating systems do not use the `mysqld_safe` process to start
    MySQL anymore. `mysqld_safe` is called an *angel process*, because it adds some
    safety features, such as restarting the server when an error occurs and logging
    runtime information to the MySQL error log. For operating systems that use `systemd`
    (controlled and configured with the `systemctl` command), these functionalities
    have been incorporated into `systemd` and the `mysqld` process.
  prefs: []
  type: TYPE_NORMAL
- en: '`mysqld` is the core process of MySQL Server. It is a single multithreaded
    program that does most of the work in the server. It does not spawn additional
    processes—we’re talking about a single process with multiple threads, making MySQL
    a *multithreaded process*.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at some of those terms. A *program* is code that is
    designed to accomplish a specific objective. There are many types of programs,
    including ones to assist parts of the operating system and others that are designed
    for user needs, such as web browsing.
  prefs: []
  type: TYPE_NORMAL
- en: A *process* is what we call a program that has been loaded into memory along
    with all the resources it needs to operate. The operating system allocates memory
    and other resources for it.
  prefs: []
  type: TYPE_NORMAL
- en: A *thread* is the unit of execution within a process. A process can have just
    one thread or many threads. In single-threaded processes, the process contains
    one thread, so only one command is executed at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Because modern CPUs have multiple cores, they can execute multiple threads at
    the same time, so multithreaded processes are widespread nowadays. It’s important
    to be aware of this concept to understand some of the proposed settings in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, MySQL is single-process software that spawns multiple threads for
    various purposes, such as serving user activities and executing background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Server Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL Server has many variables that allow tuning its operation. For example,
    MySQL Server 8.0.25 has an impressive *588* server variables!
  prefs: []
  type: TYPE_NORMAL
- en: Each system variable has a default value. Also, we can adjust most system variables
    dynamically (or “on the fly”); however, a few of them are static, which means
    that we need to change the *my.cnf* file and restart the MySQL process so they
    can take effect (as discussed in [Chapter 9](ch09.xhtml#CH9_OPTIONS_FILE)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The system variables can have two different scopes: `SESSION` and `GLOBAL`.
    That is, a system variable can have a global value that affects server operation
    as a whole, like the `innodb_log_file_size`, or a session value that affects only
    a specific session, like the `sql_mode`.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking Server Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Databases are not static entities; on the contrary, their workload is dynamic
    and changes over time, with a tendency to growth. This organic behavior requires
    constant monitoring, analysis, and adjustment. The command to show the MySQL settings
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you use the `GLOBAL` modifier, the statement displays global system variable
    values. When you use `SESSION`, it displays the system variable values that affect
    the current connection. Observe that different connections can have different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: If no modifier is present, the default is `SESSION`.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many aspects to optimize in a database. If the database runs on *bare
    metal* (a physical host), we can control hardware and operating system resources.
    When we move to virtualized machines, we have reduced control over these resources
    because we can’t control what happens with the underlying host. The last option
    is managed databases in the cloud, like those provided by Amazon Relational Database
    Service (RDS), where only a few database settings are available. There’s a trade-off
    between being able to perform fine-grained tuning to extract the most performance
    and the comfort of having most of the tasks automated (at the cost of a few extra
    dollars).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by reviewing some settings at the operating system level. After
    that, we will check out the MySQL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several operating system settings that can affect the performance
    of MySQL. We’ll run through some of the most important ones here.
  prefs: []
  type: TYPE_NORMAL
- en: The swappiness setting and swap usage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `swappiness` parameter controls the behavior of the Linux operating system
    in the swap area. Swapping is the process of transferring data between memory
    and the disk. This can have a significant effect on performance, because disk
    access (even with NVMe disks) is at least an order of magnitude slower than memory
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default setting (`60`) encourages the server to swap. You will want your
    MySQL server to keep swapping to a minimum for performance reasons. The recommended
    value is `1`, which means do not swap until it is absolutely necessary for the
    OS to be functional. To adjust this parameter, execute the following command as
    root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is a nonpersistent change; the setting will revert to its original
    value when you reboot the OS. To make this change persistent after an operating
    system reboot, adjust the setting in *sysctl.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get information on swap space usage using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you want more detailed information, you can run the following snippet
    in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The difference between setting `vm.swappiness` to `1` and `0` is negligible.
    We chose the value of `1` because in some kernels there is a bug that can lead
    the Out of Memory (OOM) Killer to terminate MySQL when it’s set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: I/O scheduler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The I/O scheduler is an algorithm the kernel uses to commit reads and writes
    to disk. By default, most Linux installs use the Completely Fair Queuing (`cfq`)
    scheduler. This works well for many general use cases, but offers few latency
    guarantees. Two other schedulers are `deadline` and `noop`. The `deadline` scheduler
    excels at latency-sensitive use cases (like databases), and `noop` is closer to
    no scheduling at all. For bare-metal installations, either `deadline` or `noop`
    (the performance difference between them is imperceptible) will be better than
    `cfq`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are running MySQL in a VM (which has its own I/O scheduler), it is best
    to use `noop` and let the virtualization layer take care of the I/O scheduling
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, verify which algorithm is currently in use by Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To change it dynamically, run this command as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In  order  to  make  this  change  persistent,  you  need  to  edit  the  GRUB 
    configuration file (usually */etc/sysconfig/grub*) and add the `elevator` option
    to `GRUB_CMDLINE_LINUX_DEFAULT`. For example, you would replace this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is essential to take extra care when editing the GRUB config. Errors or incorrect
    settings can make the server unusable and require installing the operating system
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are cases where the I/O scheduler has a value of `none`—most notably in
    AWS VM instance types where EBS volumes are exposed as NVMe block devices. This
    is because the setting has no use in modern PCIe/NVMe devices, which have a substantial
    internal queue and bypass the I/O scheduler altogether. The `none` setting is
    optimal in such disks.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems and mount options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Choosing the filesystem appropriate for your database is an important decision
    due to the many options available and the trade-offs involved. It is worth mentioning
    two important ones that are frequently used: *XFS* and *ext4*.'
  prefs: []
  type: TYPE_NORMAL
- en: XFS is a high-performance journaling filesystem designed for high scalability.
    It provides near-native I/O performance even when the filesystem spans multiple
    storage devices. XFS has features that make it suitable for very large filesystems,
    supporting files up to 8 EiB in size. Other features include fast recovery, fast
    transactions, delayed allocation for reduced fragmentation, and near-raw I/O performance
    with direct I/O.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [make filesystem XFS command](https://oreil.ly/IJ9em) (`mkfs.xfs`) has
    several options to configure the filesystem. However, the default options for
    `mkfs.xfs` are good for optimal speed, so the default command to create the filesystem
    will provide good performance while ensuring data integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding the filesystem mount options, the defaults again should fit most
    cases. You may see a performance increase on some filesystems by adding the `noatime`
    mount option to the */etc/fstab* file. For XFS filesystems, the default `atime`
    behavior is `relatime`, which has almost no overhead compared to `noatime` and
    still maintains sane `atime` values. If you create an XFS filesystem on a logical
    unit number (LUN) that has a battery-backed, nonvolatile cache, you can further
    increase the filesystem’s performance by disabling the write barrier with the
    mount option `nobarrier`. These settings help you avoid flushing data more often
    than necessary. If a backup battery unit (BBU) is not present, however, or you
    are unsure about it, leave barriers on; otherwise, you may jeopardize data consistency.
    The example below shows two imaginary mountpoints with these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The other popular option is ext4, developed as the successor to ext3 with added
    performance improvements. It is a solid option that will fit most workloads. We
    should note here that it supports files up to 16 TB in size, a smaller limit than
    XFS. This is something you should consider if excessive tablespace size/growth
    is a requirement. Regarding mount options, the same considerations apply. We recommend
    the defaults for a robust filesystem without risks to data consistency. However,
    if an enterprise storage controller with a BBU cache is present, the following
    mount options will provide the best performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Transparent Huge Pages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The operating system manages memory in blocks known as *pages*. A page has
    a size of 4,096 bytes (or 4 KB); 1 MB of memory is equal to 256 pages, 1 GB of
    memory is equivalent to 256,000 pages, etc. CPUs have a built-in memory management
    unit that contains a list of these pages, with each page referenced through a
    *page table entry*. It is common to see servers nowadays with hundreds or terabytes
    of memory. There are two ways to enable the system to manage large amounts of
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: Increase the number of page table entries in the hardware memory management
    unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the page size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first method is expensive since the hardware memory management unit in a
    modern processor only supports hundreds or thousands of page table entries. Besides,
    hardware and memory management algorithms that work well with thousands of pages
    (megabytes of memory) may have problems performing well with millions (or even
    billions) of pages. To address the scalability issue, operating systems started
    using huge pages. Simply put, huge pages are blocks of memory that can come in
    sizes of 2 MB, 4 MB, 1 GB size, etc. Using huge page memory increases the CPU
    cache hits against the transaction lookaside buffer (TLB).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run `cpuid` to verify the processor cache and TLB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Transparent Huge Pages (THP), as the name suggests, is intended to bring huge
    page support automatically to applications without requiring custom configuration.
  prefs: []
  type: TYPE_NORMAL
- en: For MySQL in particular, using THP is not recommended, for a couple of reasons.
    First, MySQL databases use small memory pages (16 KB), and using THP can cause
    excessive I/O because MySQL believes it is accessing 16 KB while THP is scanning
    a page larger than that. Also, the huge pages tend to become fragmented and impact
    performance. There have also been some cases reported over the years where using
    THP can result in memory leaking, eventually crashing MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable THP for RHEL/CentOS 6 and RHEL/CentOS 7, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that this change will survive a server restart, you’ll have to add
    the flag `transparent_hugepage=never` to your kernel options (*/etc/sysconfig/grub*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Back up the existing GRUB2 configuration file (*/boot/grub2/grub.cfg*), and
    then rebuild it. On BIOS-based machines, you can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If THP is still not disabled, it may be necessary to disable the `tuned` services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable THP for Ubuntu 20.04 (Focal Fossa), we recommend you use the `sysfsutils`
    package. To install it, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then append the following lines to the */etc/sysfs.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Reboot the server and check if the settings are in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: jemalloc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MySQL Server uses dynamic memory allocation, so a good memory allocator is important
    for proper CPU and RAM resource utilization. An efficient memory allocator should
    improve scalability, increase throughput, and keep the memory footprint under
    control.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention a characteristic of InnoDB here. InnoDB creates a
    read view for every transaction and allocates memory for this structure from the
    `heap` area. The problem is that MySQL deallocates the heap on each commit, and
    thus the read view memory is reallocated on the next transaction, leading to memory
    fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: '`jemalloc` is a memory allocator that emphasizes fragmentation avoidance and
    scalable concurrency support.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `jemalloc` (with THP disabled), you have less memory fragmentation and
    more efficient resource management of the available server memory. You can install
    the `jemalloc` package from the [`jemalloc` repository](https://oreil.ly/NZMtb)
    or the Percona *yum* or *apt* repository. We prefer to use the Percona repository
    because we consider it simpler to install and manage. We describe the steps to
    install the *yum* repository in [“Installing Percona Server 8.0”](ch01.xhtml#PERCONA-YUM-REPO-INSTALL)
    and the *apt* repository in [“Installing Percona Server 8”](ch01.xhtml#INSTALL-APT-PERCONA-REPO).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the repo, you run the install command for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In CentOS, if the server has the Extra Packages for Enterprise Linux (EPEL)
    repository installed, it is possible to install `jemalloc` from this repo with
    `yum`. To install the EPEL package, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Ubuntu 20.04, then you need to execute the following steps
    to enable `jemalloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `jemalloc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dpkg` command will show the location of the `jemalloc` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the default configuration of the service with the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: which will create the */etc/systemd/system/mysql.service.d/override.conf* file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following configuration to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the MySQL service to enable the `jemalloc` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify if it worked, with the `mysqld` process running, execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see similar output to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using CentOS/RHEL, you need to execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `jemalloc` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `rpm -ql` command will show the library location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the default configuration of the service with the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: which will create the */etc/systemd/system/mysqld.service.d/override.conf* file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following configuration to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the MySQL service to enable the `jemalloc` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify if it worked, with the `mysqld` process running, execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see similar output to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: CPU governor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most effective ways to reduce the power consumption and heat output
    on your system is to use CPUfreq. CPUfreq, also referred to as CPU frequency scaling
    or CPU speed scaling, allows the processor’s clock speed to be adjusted on the
    fly. This feature enables the system to run at a reduced clock speed to save power.
    The rules for shifting frequencies—whether and when to shift to a faster or slower
    clock speed—are defined by the CPUfreq *governor*. The governor defines the power
    characteristics of the system CPU, which in turn affects CPU performance. Each
    governor has its own unique behavior, purpose, and suitability in terms of workload.
    However, for MySQL databases, we recommend using the maximum performance setting
    to achieve the best throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'For CentOS, you can view which CPU governor is currently being used by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enable performance mode by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu, we recommend installing the `linux-tools-common` package so you
    have access to the `cpupower` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve installed it, you can change the governor to performance mode with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: MySQL best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at MySQL Server settings. This section proposes recommended values
    for the main MySQL parameters that have a direct impact on performance. You’ll
    see that it’s not necessary to change the default values for the majority of the
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer pool size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `innodb_buffer_pool_size` parameter controls the size in bytes of the InnoDB
    buffer pool, the memory area where InnoDB caches table and index data. There’s
    no question that for tuning InnoDB, this is the most important parameter. The
    typical rule of thumb is to set it to around 70% of the total available RAM for
    a MySQL dedicated server.
  prefs: []
  type: TYPE_NORMAL
- en: However, the larger the server is, the more likely it is that this will end
    up wasting RAM. For a server with 512 GB of RAM, for example, this would leave
    153 GB of RAM for the operating system, which is more than it needs.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s a better rule of thumb? Set the `innodb_buffer_pool_size` as large
    as possible, without causing swapping when the system is running the production
    workload. This will require some tuning.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MySQL 5.7 and later this is a dynamic parameter, so you can change it on
    the fly without the need to restart the database. For example, to set it to 1
    GB, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the change persistent across restarts, you’ll need to add this parameter
    to *my.cnf*, under the `[mysqld]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The innodb_buffer_pool_instances parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the more obscure MySQL parameters is `innodb_buffer_pool_instances`.
    This parameter defines the number of instances that InnoDB will split the buffer
    pool into. For systems with buffer pools in the multigigabyte range, dividing
    the buffer pool into separate instances can improve concurrency by reducing contention
    as different threads read and write to cached pages.
  prefs: []
  type: TYPE_NORMAL
- en: However, in our experience, setting a high value for this parameter may also
    introduce additional overhead. The reason is that each buffer pool instance manages
    its own free list, flush list, LRU list, and all other data structures connected
    to a buffer pool, and is protected by its own buffer pool mutex.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you run benchmarks that prove performance gains, we suggest using the
    default value (`8`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `innodb_buffer_pool_instances` parameter was deprecated in MariaDB 10.5.1
    and removed in MariaDB 10.6\. According to MariaDB architect Marko Makela, this
    is because the original reasons for splitting the buffer pool have mostly gone
    away nowadays. You can find more details in the [MariaDB Jira ticket](https://oreil.ly/HOCNA).
  prefs: []
  type: TYPE_NORMAL
- en: Redo log size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The redo log is a structure used during crash recovery to correct data written
    by incomplete transactions. The main goal is to guarantee the durability (D) property
    of ACID transactions by providing redo recovery for committed transactions. Because
    the redo file logs all data written to MySQL even before the commit, having the
    right redo log size is fundamental for MySQL to run smoothly without struggling.
    An undersized redo log can even lead to errors in operations!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the kind of error you might see if using a small redo
    log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case MySQL was using the default value for the `innodb_log_file_size`
    parameter, which is 48 MB. To estimate the optimal redo log size, there is a formula
    that we can use in the majority of cases. Take a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The log sequence number is the total number of bytes written to the redo log.
    Using the `SLEEP()` command, we can calculate the delta for that period. Then,
    using the following formula, we can reach an estimated value for the amount of
    space needed to hold an hour or so of logs (a good rule of thumb):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We usually round up, so the final number will be 56 MB. This is the value that
    needs to be added to *my.cnf* under the `[mysqld]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The sync_binlog parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The binary log is a set of log files that contain information about data modifications
    made to a MySQL server instance. They are different from the redo files and have
    other uses. For example, they are used to create replicas and InnoDB Clusters,
    and are helpful for performing PITR.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the MySQL server synchronizes its binary log to disk (using `fdatasync()`)
    before transactions are committed. The advantage is that in the event of a power
    failure or operating system crash, transactions that are missing from the binary
    log are only in a prepared state; this allows the automatic recovery routine to
    roll back the transactions, guaranteeing that no transaction is lost from the
    binary log. However, the default value (`sync_binlog = 1`) brings a penalty in
    performance. As this is a dynamic option, you can change it while the server is
    running with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For the change to persist after a restart, add the parameter to your *my.cnf*
    file under the `[mysqld]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most of the time, using `sync_binlog=0` will provide good performance (when
    binary logs are enabled). However, the performance variance can be significant
    because MySQL will rely on the OS flushing to flush the binary logs. Depending
    on the workload, using `sync_binlog=1000` or higher will provide better performance
    than `sync_binlog=1` and less variance than `sync_binlog=0`.
  prefs: []
  type: TYPE_NORMAL
- en: The binlog_expire_logs_seconds and expire_logs_days parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To avoid MySQL filling the entire disk with binary logs, you can adjust the
    settings of the parameters `binlog_expire_logs_seconds` and `expire_logs_days`.
    `expire_logs_days` specifies the number of days before automatic removal of binary
    log files. However, this parameter is deprecated in MySQL 8.0, and you should
    expect it to be removed in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, a better option is to use `binlog_expire_logs_seconds`, which
    sets the binary log expiration period in seconds. The default value for this parameter
    is `2592000` (30 days). MySQL can automatically remove the binary log files after
    this expiration period ends, either at startup or the next time the binary log
    is flushed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to flush the binary log manually, you can execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The innodb_flush_log_at_trx_commit parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`innodb_flush_log_at_trx_commit` controls the balance between strict ACID compliance
    for commit operations and the higher performance possible when commit-related
    I/O operations are rearranged and done in batches. It is a delicate option, and
    many prefer to use the default value (`innodb_flush_log_at_trx_commit=1`) in the
    source servers, while for replicas they use a value of `0` or `2`. The value `2`
    instructs InnoDB to write to the log files after each transaction commit, but
    to flush them to disk only once per second. This means you can lose up to a second
    of updates if the OS crashes, which, with modern hardware that supports up to
    one million inserts per second, is not negligible. The value `0` is even worse:
    logs are written and flushed to disk just once per second, so you may lose up
    to a second’s worth of transactions even if the `mysqld` process crashes.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many operating systems, and some disk hardware, “fool” the flush-to-disk operation.
    They may tell `mysqld` that the flush has taken place, even though it has not.
    In this case, the durability of transactions is not guaranteed even with the recommended
    settings, and in the worst case, a power outage can corrupt InnoDB data. Using
    a battery-backed disk cache in the SCSI disk controller or in the disk itself
    speeds up file flushes and makes the operation safer. You can also disable the
    caching of disk writes in hardware caches if the battery is not working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The innodb_thread_concurrency parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`innodb_thread_concurrency` is set to `0` by default, which means that an infinite
    number (up to the hardware limit) of threads can be opened and executed inside
    MySQL. The usual recommendation is to leave this parameter with its default value
    and only change it to solve contention problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your workload is consistently heavy or has occasional spikes, you can set
    the value of `innodb_thread_concurrency` using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Because MySQL does not use multiple cores to execute a single query (it is a
    1:1 relation), each core will run one query per single unit of time. Based on
    our experience, because modern CPUs are fast in general, setting the maximum number
    of executing threads to double the CPUs available is a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Once the number of executing threads reaches this limit, additional threads
    sleep for a number of microseconds, set by the configuration parameter `innodb_​​thread_sleep_delay`,
    before being placed into the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '`innodb_thread_concurrency` is a dynamic variable, and we can change it at
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the change persistent, you’ll also need to add this to *my.cnf*, under
    the `[mysqld]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can validate that MySQL applied the setting with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The MySQL 8.0.14 [release notes](https://oreil.ly/EqPrG) state: “As of MySQL
    8.0.14, InnoDB supports parallel clustered index reads, which can improve `CHECK
    TABLE` performance.” Parallel clustered index reads also work for a simple `COUNT(*)`
    (without a `WHERE` condition). You can control the number of parallel threads
    with the `innodb_parallel_read_threads` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: This feature is currently limited and available only for queries without a `WHERE`
    condition (full scans). However, it is a great start for MySQL and opens the road
    to real parallel query execution.
  prefs: []
  type: TYPE_NORMAL
- en: NUMA architecture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Non-uniform memory access (NUMA) is a shared memory architecture that describes
    the placement of main memory modules relative to processors in a multiprocessor
    system. In the NUMA shared memory architecture, each processor has its own local
    memory module, leading to a distinct performance advantage because the memory
    and the processor are physically closer. At the same time, it can also access
    any memory module belonging to another processor using a shared bus (or some other
    type of interconnect), as shown in [Figure 11-1](#FIG-NUMA).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A nice alternative that can show memory usage across NUMA nodes is the `numastat`
    command. You can get a more detailed memory usage per node by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to visualize this is by specific process. For example, to check
    the memory usage in NUMA nodes of the mysqld process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![lm2e 1101](Images/lm2e_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. NUMA architecture overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following command shows an example of the available nodes on a server that
    has NUMA enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, node 0 has more free memory than node 1\. There is an issue with
    this that causes the OS to swap even with memory available, as explained in the
    excellent article [“The MySQL *Swap Insanity* Problem and the Effects of the NUMA
    Architecture”](https://oreil.ly/lBRSk) by Jeremy Cole.
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL 5.7 the `innodb_buffer_pool_populate` and `numa_interleave` parameters
    were removed, and their functions are now controlled by the `innodb_numa_interleave`
    parameter. When we enable it, we balance memory allocation across nodes in a NUMA
    system, avoiding the swap insanity problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This parameter is not dynamic, so to enable it we need to add it to the *my.cnf*
    file, under the `[mysqld]` section, and restart MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
