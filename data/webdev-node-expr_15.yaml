- en: Chapter 15\. REST APIs and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we saw some REST API examples in [Chapter 8](ch08.xhtml#ch_form_handling),
    our paradigm so far has mostly been “process the data on the server side and send
    formatted HTML to the client.” Increasingly, this is not the default mode of operation
    for web applications. Instead, most modern web applications are single-page applications
    (SPAs) that receive all of their HTML and CSS in one static bundle and then rely
    on receiving unstructured data as JSON and manipulating HTML directly. Similarly,
    the importance of posting forms to communicate changes to the server is giving
    way to communicating directly using HTTP requests to an API.
  prefs: []
  type: TYPE_NORMAL
- en: So it’s time to turn our attention to using Express to provide API endpoints
    instead of preformatted HTML. This will serve us well in [Chapter 16](ch16.xhtml#ch_single_page_applications),
    when we demonstrate how our API could be used to dynamically render an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll strip down our application to providing a “coming soon”
    HTML interface: we’ll fill that in in [Chapter 16](ch16.xhtml#ch_single_page_applications).
    Instead, we’ll focus on an API that will provide access to our vacation database
    and provide API support for registering “out of season” listeners.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Web service* is a general term that means any application programming interface
    (API) that’s accessible over HTTP. The idea of web services has been around for
    quite some time, but until recently, the technologies that enabled them were stuffy,
    Byzantine, and overcomplicated. There are still systems that use those technologies
    (such as SOAP and WSDL), and there are Node packages that will help you interface
    with these systems. We won’t be covering those, though. Instead, we will be focused
    on providing so-called RESTful services, which are much more straightforward to
    interface with.'
  prefs: []
  type: TYPE_NORMAL
- en: The acronym *REST* stands for *representational state transfer*, and the grammatically
    troubling *RESTful* is used as an adjective to describe a web service that satisfies
    the principles of REST. The formal description of REST is complicated and steeped
    in computer science formality, but the basics are that REST is a stateless connection
    between a client and a server. The formal definition of REST also specifies that
    the service can be cached and that services can be layered (that is, when you
    use a REST API, there may be other REST APIs beneath it).
  prefs: []
  type: TYPE_NORMAL
- en: From a practical standpoint, the constraints of HTTP actually make it difficult
    to create an API that’s not RESTful; you’d have to go out of your way to establish
    state, for example. So our work is mostly cut out for us.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vital to providing an API is having a common language to speak in. Part of
    the communication is dictated for us: we must use HTTP methods to communicate
    with the server. But past that, we are free to use whatever data language we choose.
    Traditionally, XML has been a popular choice, and it remains an important markup
    language. While XML is not particularly complicated, Douglas Crockford saw that
    there was room for something more lightweight, and JavaScript Object Notation
    (JSON) was born. In addition to being JavaScript-friendly (though it is by no
    means proprietary; it is an easy format for any language to parse), it also has
    the advantage of being generally easier to write by hand than XML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer JSON over XML for most applications: there’s better JavaScript support,
    and it’s a simpler, more compact format. I recommend focusing on JSON and providing
    XML only if existing systems require XML to communicate with your app.'
  prefs: []
  type: TYPE_NORMAL
- en: Our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll plan our API before we start implementing it. In addition to listing vacations
    and subscribing to “in-season” notifications, we’ll add a “delete vacation” endpoint.
    Since this is a public API, we won’t actually delete the vacation. We’ll simply
    mark it as “delete requested” so an administrator can review. For example, you
    might use this unsecured endpoint to allow vendors to request the removal of vacations
    from the site, which could then later be reviewed by an administrator. Here are
    our API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/vacations`'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves vacations
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/vacation/:sku`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a vacation by its SKU
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /api/vacation/:sku/notify-when-in-season`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes `email` as a querystring parameter and adds a notification listener for
    the specified vacation
  prefs: []
  type: TYPE_NORMAL
- en: '`DELETE /api/vacation/:sku`'
  prefs: []
  type: TYPE_NORMAL
- en: Requests the deletion of a vacation; takes `email` (the person requesting the
    deletion) and `notes` as querystring parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Example 15-1\.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are many HTTP verbs available. `GET` and `POST` are the most common, followed
    by `DELETE` and `PUT`. It has become a standard to use `POST` for *creating* something,
    and `PUT` for *updating* (or modifying) something. The English meaning of these
    words doesn’t support this distinction in any way, so you may want to consider
    using the path to distinguish between these two operations to avoid confusion.
    If you want more information about HTTP verbs, I recommend starting with this
    [Tamas Piros article](http://bit.ly/32L4QWt).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways we could have described our API. Here, we’ve chosen to
    use combinations of HTTP methods and paths to distinguish our API calls, and a
    mix of querystring and body parameters for passing data. As an alternative, we
    could have had different paths (such as */api/vacations/delete*) with the same
    method.^([1](ch15.xhtml#idm45053580950936)) We could also have passed data in
    a consistent way. For example, we might have chosen to pass all the necessary
    information for retrieving parameters in the URL instead of using a querystring:
    `DEL /api/vacation/:id/:email/:notes`. To avoid excessively long URLs, I recommend
    using the request body to pass large blocks of data (for example, the deletion
    request notes).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a popular and well-respected convention for JSON APIs, creatively named
    JSON:API. It’s a bit verbose and repetitive for my taste, but I also believe that
    an imperfect standard is better than no standard at all. While we’re not using
    JSON:API for this book, you will learn everything you need to adopt the conventions
    laid down by JSON:API. See the [JSON:API home page](https://jsonapi.org) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: API Error Reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error reporting in HTTP APIs is usually achieved through HTTP status codes.
    If the request returns 200 (OK), the client knows the request was successful.
    If the request returns 500 (Internal Server Error), the request failed. In most
    applications, however, not everything can (or should be) categorized coarsely
    into “success” or “failure.” For example, what if you request something by an
    ID but that ID doesn’t exist? This does not represent a server error. The client
    has asked for something that doesn’t exist. In general, errors can be grouped
    into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Catastrophic errors
  prefs: []
  type: TYPE_NORMAL
- en: Errors that result in an unstable or unknown state for the server. Usually,
    this is the result of an unhandled exception. The only safe way to recover from
    a catastrophic error is to restart the server. Ideally, any pending requests would
    receive a 500 response code, but if the failure is severe enough, the server may
    not be able to respond at all, and the request will time out.
  prefs: []
  type: TYPE_NORMAL
- en: Recoverable server errors
  prefs: []
  type: TYPE_NORMAL
- en: Recoverable errors do not require a server restart, or any other heroic action.
    The error is a result of an unexpected error condition on the server (for example,
    a database connection being unavailable). The problem may be transient or permanent.
    A 500 response code is appropriate in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Client errors
  prefs: []
  type: TYPE_NORMAL
- en: 'Client errors are a result of the client making the mistake—usually missing
    or invalid parameters. It isn’t appropriate to use a 500 response code. After
    all, the server has not failed. Everything is working normally; the client just
    isn’t using the API correctly. You have a couple of options here: you could respond
    with a status code of 200 and describe the error in the response body, or you
    could additionally try to describe the error with an appropriate HTTP status code.
    I recommend the latter approach. The most useful response codes in this case are
    404 (Not Found), 400 (Bad Request), and 401 (Unauthorized). Additionally, the
    response body should contain an explanation of the specifics of the error. If
    you want to go above and beyond, the error message would even contain a link to
    documentation. Note that if the user requests a list of things and there’s nothing
    to return, this is not an error condition. It’s appropriate to simply return an
    empty list.'
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we’ll be using a combination of HTTP response codes and
    error messages in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’re publishing an API, you’ll likely want to make the API available to
    others. This will result in a *cross-site HTTP request*. Cross-site HTTP requests
    have been the subject of many attacks and have therefore been restricted by the
    *same-origin policy*, which restricts where scripts can be loaded from. Specifically,
    the protocol, domain, and port must match. This makes it impossible for your API
    to be used by another site, which is where cross-origin resource sharing (CORS)
    comes in. CORS allows you to lift this restriction on a case-by-case basis, even
    allowing you to list which domains specifically are allowed to access the script.
    CORS is implemented through the `Access-Control-Allow-Origin` header. The easiest
    way to implement it in an Express application is to use the `cors` package (`npm
    install cors`). To enable CORS for your application, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the same-origin API is there for a reason (to prevent attacks), I recommend
    applying CORS only where necessary. In our case, we want to expose our entire
    API (but only the API), so we’re going to restrict CORS to paths starting with
    */api*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See the [package documentation](https://github.com/expressjs/cors) for information
    about more advanced use of CORS.
  prefs: []
  type: TYPE_NORMAL
- en: Our Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we use HTTP verbs other than `GET`, it can be a hassle to test our API,
    since browsers only know how to issue `GET` requests (and `POST` requests for
    forms). There are ways around this, such as the excellent application [Postman](https://www.getpostman.com).
    However, whether or not you use such a utility, it’s good to have automated tests.
    Before we write tests for our API, we need a way to actually *call* a REST API.
    For that, we’ll be using a Node package called `node-fetch`, which replicates
    the browser’s *fetch* API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll put the tests for the API calls we’re going to implement in *tests/api/api.test.js*
    (*ch15/test/api/api.test.js* in the companion repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our test suite starts off with a helper function `_fetch`, which handles some
    common housekeeping. It will JSON encode the body if it isn’t already, add the
    appropriate headers, and throw an appropriate error if the response status code
    isn’t in the 200s.
  prefs: []
  type: TYPE_NORMAL
- en: We have a single test for each of our API endpoints. I’m not suggesting that
    these tests are robust or complete; even with this simple API, we could (and should)
    have several tests for each endpoint. What we have here is more of a starting
    point that illustrates techniques for testing an API.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of important characteristics of these tests that deserve
    mention. One is that we are relying on the API being already started and running
    on port 3000\. A more robust test suite would find an open port, start the API
    on that port as part of its setup, and stop it when all the tests have run. Second,
    this test relies on data already being present in our API. For example, the first
    test expects there to be at least one vacation, and for that vacation to have
    a name and a price. In a real application, you may not be able to make these assumptions
    (for example, you may start with no data, and you may want to test for allowable
    missing data). Again, a more robust testing framework would have a way of setting
    and resetting the initial data in the API so you could start from a known state
    every time. For example, you might have scripts that set up and seed a test database,
    attach the API to it, and tear it down for every test run. As we saw in [Chapter 5](ch05.xhtml#ch_qa),
    testing is a large and complicated topic, and we can only scratch the surface
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The first test covers our `GET /api/vacations` endpoint. It fetches all of the
    vacations, validates that there is at least one, and checks the first one to see
    if it has a name and a price. We could also conceivably test other data properties.
    I’ll leave it as a reader’s exercise to think about which properties are most
    important to test.
  prefs: []
  type: TYPE_NORMAL
- en: The second test covers our `GET /api/vacation/:sku` endpoint. Since we don’t
    have consistent test data, we start by fetching all of the vacations and getting
    the SKU from the first one so we can test this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Our last two tests cover our `POST /api/vacation/:sku/notify-when-in-season`
    and `DELETE /api/vacation/:sku` endpoints. Unfortunately, with our current API
    and testing framework, we can do very little to verify that these endpoints are
    doing what they are supposed to, so we default to invoking them and trusting the
    API is doing the right thing when it doesn’t return an error. If we wanted to
    make these tests more robust, we would have to either add endpoints that allow
    us to verify the actions (for example, an endpoint that determined if a given
    email was registered for a specific vacation) or somehow give the tests “backdoor”
    access to our database.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the tests now, they will time out and fail…because we haven’t implemented
    our API or even started our server. So let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Using Express to Provide an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express is quite capable of providing an API. There are various npm modules
    available that provide helpful functionality (see `connect-rest` and `json-api`,
    for example), but I find that Express is perfectly capable out of the box, and
    we’ll be sticking with a pure Express implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by creating the handlers in *lib/handlers.js* (we could create
    a separate file, such as *lib/api.js*, but let’s keep things simple for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we hook up the API in *meadowlark.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Nothing here should be particularly surprising by now. Note that we’re using
    our database abstraction layer, so it doesn’t matter if we use our MongoDB implementation
    or our PostgreSQL implementation (though you will find minor inconsequential extra
    fields depending on the implementation, which we could remove if necessary).
  prefs: []
  type: TYPE_NORMAL
- en: I am leaving `requestDeleteVacationsApi` as a reader’s exercise, mainly because
    this functionality could be implemented so many different ways. The simplest approach
    would be to just modify our vacation schema to have “delete requested” fields
    that just get updated with the email and notes when the API is called. A more
    sophisticated approach would be to have a separate table, like a moderation queue,
    that records the deletion requests separately, referencing the vacation in question,
    which would better lend itself to administrator use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you set up Jest correctly in [Chapter 5](ch05.xhtml#ch_qa), you should
    just be able to run `npm test`, and the API tests will be picked up (Jest will
    look for any file that ends in `.test.js`). You’ll see we have three passing tests
    and one failing one: the incomplete `DELETE /api/vacation/:sku`.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope this chapter has left you asking, “That’s it?” At this point, you’re
    probably realizing that the primary function of Express is to respond to HTTP
    requests. What the requests are for—and how they respond—is entirely up to you.
    Do they need to respond with HTML? CSS? Plain text? JSON? All easy to do with
    Express. You could even respond with binary file types. For example, it would
    not be hard to dynamically construct and return images. In this sense, an API
    is just another one of the many ways Express can respond.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll put this API to use by building a single-page application,
    and replicate what we’ve done in previous chapters in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch15.xhtml#idm45053580950936-marker)) If your client can’t use different
    HTTP methods, see [this module](http://bit.ly/2O7nr9E), which allows you to “fake”
    different HTTP methods.
  prefs: []
  type: TYPE_NORMAL
