- en: Chapter 12\. Maintenance and Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will find recipes that deal with both app-level and cluster-level
    maintenance. We cover various aspects of troubleshooting, from debugging pods
    and containers to testing service connectivity, interpreting a resource’s status,
    and maintaining nodes. Last but not least, we look at how to deal with etcd, the
    Kubernetes control-plane storage component. This chapter is relevant for both
    cluster admins and app developers.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 Enabling Autocomplete for kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is cumbersome to type full commands and arguments for the `kubectl` CLI,
    so you want an autocomplete function for it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable autocompletion for `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the bash shell, you can enable `kubectl` autocompletion in your current
    shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this to your *~/.bashrc* file so that autocomplete loads in all of your
    shell sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that autocompletion for bash depends on [bash-completion](https://oreil.ly/AdlLN)
    being installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the zsh shell, you can enable `kubectl` autocompletion with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And you can add this same command to your *~/.zshrc* file for autocomplete to
    load in all your shell sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For autocompletion to work in zsh, you may need to have these commands at the
    start of your *~/.zshrc* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For other operating systems and shells, please check the [documentation](https://oreil.ly/G3das).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another popular improvement to the `kubectl` developer experience is to define
    an alias to shorten `kubectl` to just the letter `k`. This can be achieved by
    executing the following commands or adding them to your shell start-up script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can simply type commands like `k apply -f myobject.yaml`. This combined
    with autocompletion makes life a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Overview of `kubectl`](https://oreil.ly/mu6PZ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`kubectl` Cheat Sheet](https://oreil.ly/Yrk3C)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2 Removing a Pod from a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a well-defined service (see [Recipe 5.1](ch05.html#simple_service))
    backed by several pods. But one of the pods is causing problems (e.g., crashing
    or not responding), and you want to take it out of the list of endpoints to examine
    it at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relabel the pod using the `--overwrite` option—​this will allow you to change
    the value of the `run` label on the pod. By overwriting this label, you can ensure
    that it will not be selected by the service selector ([Recipe 5.1](ch05.html#simple_service))
    and will be removed from the list of endpoints. At the same time, the replica
    set watching over your pods will see that a pod has disappeared and will start
    a new replica.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, start with a straightforward deployment generated with
    `kubectl run` (see [Recipe 4.5](ch04.html#deployments)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you list the pods and show the label with key `app`, you’ll see four pods
    with the value `nginx` (`app=nginx` is the label that is automatically generated
    by the `kubectl create deployment` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then expose this deployment with a service and check the endpoints,
    which correspond to the IP addresses of each pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s imagine that the first pod in the list is causing problems, even though
    its status is *Running*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving the first pod out of the service pool via relabeling is done with a
    single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To find the IP address of a pod, you can use a Go template to format the pod
    information and show only its IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a new pod appear with the label `app=nginx`, and you will see
    that your nonworking pod still exists but no longer appears in the list of service
    endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 12.3 Accessing a ClusterIP Service Outside the Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have an internal service that is causing you trouble, and you want to test
    that it is working well locally without exposing the service externally.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a local proxy to the Kubernetes API server with `kubectl proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that you have created a deployment and a service as described
    in [Recipe 12.2](#relabel). You should see an `nginx` service when you list the
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This service is not reachable outside the Kubernetes cluster. However, you can
    run a proxy in a separate terminal and then reach it on *localhost*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by running the proxy in a separate terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can specify the port that you want the proxy to run on with the `--port`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your original terminal, you can then use your browser or `curl` to access
    the application exposed by your service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the specific path to the service; it contains a `/proxy` part. Without
    this, you get the JSON object representing the service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that you can now also access the entire Kubernetes API over *localhost*
    using `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe demonstrates an approach that is suitable for debugging and should
    not be used for regular access to services in production. Rather, use the secure
    [Recipe 5.5](ch05.html#ingress) for production scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Understanding and Parsing Resource Statuses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to watch an object, such as a pod, and react to changes in the object’s
    status. Sometimes these state changes trigger events in CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `kubectl get $KIND/$NAME -o json` and parse the JSON output using one of
    the two methods described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have the JSON query utility `jq` [installed](https://oreil.ly/qopuJ),
    you can use it to parse the resource status. Let’s assume you have a pod called
    `jump`. You can do this to find out what [Quality of Service (QoS) class](https://oreil.ly/3CcxH)
    the pod is in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `--raw-output` argument for `jq` will show the raw value and that
    `.status.qosClass` is the expression that matches the respective subfield.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another status query could be around events or state transitions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, these queries are not limited to pods—​you can apply this technique
    to any resource. For example, you can query the revisions of a deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can list all the endpoints that make up a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve seen `jq` in action, let’s move on to a method that doesn’t
    require external tooling—​that is, the built-in feature of using Go templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go programming language defines templates in a package called `text/template`
    that can be used for any kind of text or data transformation, and `kubectl` has
    built-in support for it. For example, to list all the container images used in
    the current namespace, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may also want to take a look at JSONPath as an alternative way to parse
    the JSON produced by `kubectl`. It provides a syntax that can be considered more
    readable and easier to reason about. Examples can be found in the [Kubernetes
    documentation](https://oreil.ly/muOnq).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The `jq` manual](https://oreil.ly/Z7rul)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[jqplay](https://jqplay.org) to try out queries without installing `jq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Go `template` package](https://oreil.ly/qfQAO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5 Debugging Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a situation where a pod is either not getting to or remaining in the
    running state as expected or fails altogether after some time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To systematically discover and fix the cause of the problem, enter an [OODA
    loop](https://oreil.ly/alw1o):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Observe*. What do you see in the container logs? What events have occurred?
    How is the network connectivity?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Orient*. Formulate a set of plausible hypotheses—​stay as open-minded as possible
    and don’t jump to conclusions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Decide*. Pick one of the hypotheses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Act*. Test the hypothesis. If it’s confirmed, you’re done; otherwise, go back
    to step 1 and continue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s take a look at a concrete example where a pod fails. Create a manifest
    called *unhappy-pod.yaml* with this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you launch that deployment and look at the pod it creates, you’ll
    see it’s unhappy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see at the bottom of the description, in the `Events` section, Kubernetes
    considers this pod as not ready to serve traffic because “Back-off restarting
    failed…​.”
  prefs: []
  type: TYPE_NORMAL
- en: Another way to observe this is by using the Kubernetes dashboard to view the
    deployment ([Figure 12-1](#unhappy-deployment-screenshot)), as well as the supervised
    replica set and the pod ([Figure 12-2](#unhappy-pod-events-screenshot)). With
    Minikube you can easily open the dashboard by running the command `minikube dashboard`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen Shot Of Deployment In Error State](assets/kcb2_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Deployment in error state
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Screen Shot Of Pod In Error State](assets/kcb2_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Pod in error state
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An issue, be it a pod failing or a node behaving strangely, can have many different
    causes. Here are some things you’ll want to check before suspecting software bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the manifest correct? Check with a tool such as [Kubeconform](https://oreil.ly/q_e39).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you able to run the container locally outside of Kubernetes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can Kubernetes reach the container registry and actually pull the container
    image?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the nodes talk to each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the nodes reach the control plane?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is DNS available in the cluster?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there sufficient resources available on the nodes, such as CPU, memory,
    and disk space?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you restrict the container or the namespace’s resource usage?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the events in the object description saying?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Debug Pods”](https://oreil.ly/nuThZ) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Debug Running Pods”](https://oreil.ly/61xce) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Debug Services”](https://oreil.ly/XrF29) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Troubleshooting Clusters”](https://oreil.ly/LD9oN) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 Influencing a Pod’s Start-up Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For your pod to function properly, it depends on some other service being available.
    You want to influence the pod’s start-up behavior so that it starts only once
    the pods it depends on are available.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use [init containers](https://oreil.ly/NWpRM) to influence the start-up behavior
    of a pod.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want to launch an NGINX web server that depends on a backend service
    to serve content. You therefore want to make sure that the NGINX pod starts up
    only once the backend service is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the backend service the web server depends on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can use the following manifest, *nginx-init-container.yaml*, to launch
    the NGINX instance and make sure it starts up only when the `backend` deployment
    is ready to accept connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can launch the `nginx` deployment and verify whether the init container
    has done its job by looking at the logs of the pod it is supervising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the command in the init container indeed worked as planned.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Init containers are useful to prevent your application from crash looping while
    it is waiting for a service to become available. For example, if you are deploying
    an application that needs to connect to a database server, you can configure an
    init container that checks and waits for the database server to become ready before
    your application attempts a connection with it.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to keep in mind that Kubernetes can technically kill
    a pod at any time, even after it was started successfully. Therefore, it is also
    important that you build resiliency into your application such that it can survive
    failures in other dependent services.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7 Getting a Detailed Snapshot of the Cluster State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get a detailed snapshot of the overall cluster state for orientation,
    auditing, or troubleshooting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `kubectl cluster-info dump` command. For example, to create a dump
    of the cluster state in a subdirectory *cluster-state-2023-04-13*, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 12.8 Adding Kubernetes Worker Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to add a worker node to your Kubernetes cluster, for instance because
    you want to increase the capacity of your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Provision a new machine in whatever way your environment requires (for example,
    in a bare-metal environment you might need to physically install a new server
    in a rack, in a public cloud setting you need to create a new VM, etc.), and then
    install, as daemons, the three components that make up a Kubernetes worker node:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubelet`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the node manager and supervisor for all pods, no matter if they’re
    controlled by the API server or running locally, such as static pods. Note that
    the `kubelet` is the final arbiter of what pods can or cannot run on a given node,
    and it takes care of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reporting node and pod statuses to the API server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Periodically executing liveness probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting the pod volumes and downloading secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the container runtime (see the following)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container runtime
  prefs: []
  type: TYPE_NORMAL
- en: This is responsible for downloading container images and running containers.
    Kubernetes requires the use of a runtime that conforms to the [Container Runtime
    Interface (CRI)](https://oreil.ly/6hmkR), like [cri-o](http://cri-o.io), [Docker
    Engine](https://docs.docker.com/engine), or [containerd](https://containerd.io).
  prefs: []
  type: TYPE_NORMAL
- en: '`kube-proxy`'
  prefs: []
  type: TYPE_NORMAL
- en: This process dynamically configures iptables rules on the node to enable the
    Kubernetes service abstraction (redirecting the VIP to the endpoints, one or more
    pods representing the service).
  prefs: []
  type: TYPE_NORMAL
- en: The actual installation of the components depends heavily on your environment
    and the installation method used (cloud, `kubeadm`, etc.). For a list of available
    options, see the [`kubelet` reference](https://oreil.ly/8XBRS) and [`kube-proxy`
    reference](https://oreil.ly/mED8e).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Worker nodes, unlike other Kubernetes resources such as deployments or services,
    are not directly created by the Kubernetes control plane but only managed by it.
    That means when Kubernetes creates a node, it actually only creates an object
    that *represents* the worker node. It validates the node by health checks based
    on the node’s `metadata.name` field, and if the node is valid—​that is, all necessary
    components are running—​it is considered part of the cluster; otherwise, it will
    be ignored for any cluster activity until it becomes valid.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Nodes”](https://oreil.ly/MQ4ZV) in the Kubernetes cluster architecture concepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Communication Between Nodes and the Control Plane”](https://oreil.ly/ePukq)
    in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Create Static Pods”](https://oreil.ly/_OKBq) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.9 Draining Kubernetes Nodes for Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to carry out maintenance on a node—​for example, to apply a security
    patch or upgrade the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `kubectl drain` command. For example, list nodes with `kubectl get
    nodes`, and then to do maintenance on node `123-worker`, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When you are ready to put the node back into service, use `kubectl uncordon
    123-worker`, which will make the node schedulable again.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `kubectl drain` command first marks the specified node as unschedulable
    to prevent new pods from arriving (essentially a `kubectl cordon`). Then it evicts
    the pods if the API server supports [eviction](https://oreil.ly/xXLII). Otherwise,
    it will use `kubectl delete` to delete the pods. The Kubernetes docs have a concise
    sequence diagram of the steps, reproduced in [Figure 12-3](#drain-node).
  prefs: []
  type: TYPE_NORMAL
- en: '![Node drain sequence diagram](assets/kcb2_1203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3\. Node drain sequence diagram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `kubectl drain` command evicts or deletes all pods except mirror pods (which
    cannot be deleted through the API server). For pods supervised by a `DaemonSet`,
    `drain` will not proceed without using `--ignore-daemonsets`, and regardless it
    will not delete any `DaemonSet`-managed pods—​those pods would be immediately
    replaced by the `DaemonSet` controller, which ignores unschedulable markings.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`drain` waits for graceful termination, so you should not operate on this node
    until the `kubectl drain` command has completed. Note that `kubectl drain $NODE
    --force` will also evict pods not managed by a `ReplicationController`, `ReplicaSet`,
    `Job`, `DaemonSet`, or `StatefulSet`.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Safely Drain a Node”](https://oreil.ly/upbMl) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl drain` [reference docs](https://oreil.ly/YP6zg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
