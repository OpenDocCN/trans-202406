- en: Chapter 5\. Helm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 Helm
- en: 'In [Chapter 4](ch04.xhtml#ch_Kustomize), you learned about Kustomize, a simple
    yet powerful tool to manage Kubernetes resources. But another popular tool aims
    to simplify the Kubernetes resources management too: Helm.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第四章](ch04.xhtml#ch_Kustomize)中，您已经了解了 Kustomize，这是一个简单而强大的工具，用于管理 Kubernetes
    资源。但是另一个流行的工具也旨在简化 Kubernetes 资源的管理：Helm。
- en: Helm works similarly to Kustomize, but it’s a template solution and acts more
    like a package manager, producing artifacts that are versionable, sharable, or
    deployable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 的工作方式类似于 Kustomize，但它是一个模板解决方案，更像是一个包管理器，生成的构件可以进行版本控制、共享或部署。
- en: In this chapter, we’ll introduce Helm, a package manager for Kubernetes that
    helps install and manage Kubernetes applications using the Go template language
    in YAML files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Helm，这是一个 Kubernetes 的包管理工具，它使用 YAML 文件中的 Go 模板语言来帮助安装和管理 Kubernetes
    应用程序。
- en: The first step is to create a Helm project and deploy it to a Kubernetes cluster
    (see Recipes [5.1](#recipe_5_1) and [5.2](#recipe_5_2)). After the first deployment,
    the application is updated with a new container image, a new configuration value,
    or any other field, such as the replica number (see [Recipe 5.3](#recipe_5_3)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个 Helm 项目并将其部署到 Kubernetes 集群（参见配方[5.1](#recipe_5_1)和[5.2](#recipe_5_2)）。在第一次部署之后，可以通过一个新的容器镜像、一个新的配置值或任何其他字段（例如副本数）来更新应用程序（参见[配方
    5.3](#recipe_5_3)）。
- en: One of the differences between Kustomize and Helm is the concept of a Chart.
    A Chart is a packaged artifact that can be shared and contains multiple elements
    like dependencies on other Charts (see Recipes [5.4](#recipe_5_4), [5.5](#recipe_5_5),
    and [5.6](#recipe_5_6)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 和 Helm 之间的一个区别是 Chart 的概念。Chart 是一个打包的构件，可以共享，并包含多个元素，如对其他 Chart 的依赖关系（参见配方[5.4](#recipe_5_4)、[5.5](#recipe_5_5)和[5.6](#recipe_5_6)）。
- en: Application configuration values are properties usually mapped as a Kubernetes
    `ConfigMap`. Any change (and its consequent update on the cluster) on a `ConfigMap`
    doesn’t trigger a rolling update of the application, which means that the application
    will run with the previous version until you manually restart it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置值通常映射为 Kubernetes 的 `ConfigMap` 属性。对 `ConfigMap` 的任何更改（及其在集群上的后续更新）不会触发应用程序的滚动更新，这意味着应用程序会继续以前一个版本运行，直到您手动重新启动它。
- en: Helm provides some functions to automatically execute a rolling update when
    the `ConfigMap` of an application changes (see [Recipe 5.7](#recipe_5_7)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了一些功能，可以在应用程序的 `ConfigMap` 更改时自动执行滚动更新（参见[配方 5.7](#recipe_5_7)）。
- en: 5.1 Creating a Helm Project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 创建一个 Helm 项目
- en: Problem
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a simple Helm project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个简单的 Helm 项目。
- en: Solution
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the [Helm](https://helm.sh) CLI tool to create a new project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Helm](https://helm.sh) CLI 工具创建一个新项目。
- en: In contrast to Kustomize, which can be used either within the `kubectl` command
    or as a standalone CLI tool, Helm needs to be downloaded and installed in your
    local machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kustomize 相反，Kustomize 可以在 `kubectl` 命令中使用，也可以作为一个独立的 CLI 工具使用，但 Helm 需要在本地机器上下载并安装。
- en: 'Helm is a packager for Kubernetes that bundles related manifest files and packages
    them into a single logical deployment unit: a Chart. Thus simplified, for many
    engineers, Helm makes it easy to start using Kubernetes with real applications.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是一个 Kubernetes 的打包工具，它将相关的清单文件打包成一个单一的逻辑部署单元：一个 Chart。因此，对于许多工程师来说，Helm
    简化了使用真实应用程序的 Kubernetes 的过程。
- en: Helm Charts are useful for addressing the installation complexities and simple
    upgrades of applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Helm Charts 对于解决应用程序的安装复杂性和简单的升级非常有用。
- en: For this book, we use Helm 3.7.2, which you can download from [GitHub](https://oreil.ly/AWfiO)
    and install in your PATH directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们使用的是 Helm 3.7.2 版本，您可以从[GitHub](https://oreil.ly/AWfiO)下载并安装到您的 PATH 目录中。
- en: 'Open a terminal and run the following commands to create a Helm Chart directory
    layout:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并运行以下命令，创建一个 Helm Chart 目录布局：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then create three files: one that defines the Chart, another representing the
    deployment template using the Go template language and template functions from
    the Sprig library, and finally a file containing the default values for the Chart.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建三个文件：一个定义 Chart 的文件，另一个代表使用 Sprig 库的 Go 模板语言的部署模板，最后一个文件包含 Chart 的默认值。
- en: 'A *Chart.yaml* file declares the Chart with information such as version or
    name. Create the file in the root directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chart.yaml* 文件声明了 Chart 的信息，如版本或名称。在根目录下创建该文件：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_helm_CO1-1)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO1-1)'
- en: Version of the Chart. This is updated when something in the Chart definition
    is changed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的版本。当Chart定义中的内容发生更改时更新。
- en: '[![2](assets/2.png)](#co_helm_CO1-2)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO1-2)'
- en: Version of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的版本。
- en: Let’s create a *deployment.yaml* and a *service.yaml* template file to deploy
    the application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个*deployment.yaml*和一个*service.yaml*模板文件来部署应用程序。
- en: 'The *deployment.yaml* file templatizes the deployment’s name, the application
    version, the replica count, the container image and tag, the pull policy, the
    security context, and the port:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*deployment.yaml*文件模板化了部署的名称、应用程序版本、副本计数、容器镜像和标签、拉取策略、安全上下文以及端口：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_helm_CO2-1)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO2-1)'
- en: Sets the name from the *Chart.yaml* file
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从*Chart.yaml*文件设置名称
- en: '[![2](assets/2.png)](#co_helm_CO2-2)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO2-2)'
- en: Conditionally sets the version based on the presence of the `appVersion` in
    the *Chart.yaml* file
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*Chart.yaml*文件中是否存在`appVersion`来有条件地设置版本
- en: '[![3](assets/3.png)](#co_helm_CO2-3)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO2-3)'
- en: Sets the `appVersion` value but quoting the property
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`appVersion`值，但引用该属性
- en: '[![4](assets/4.png)](#co_helm_CO2-4)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_helm_CO2-4)'
- en: Placeholder for the `replicaCount` property
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`replicaCount`属性的占位符'
- en: '[![5](assets/5.png)](#co_helm_CO2-5)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_helm_CO2-5)'
- en: Placeholder for the container image
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的占位符
- en: '[![6](assets/6.png)](#co_helm_CO2-6)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_helm_CO2-6)'
- en: Placeholder for the image tag if present and if not, defaults to the *Chart.yaml*
    property
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，则为镜像标签的占位符，否则默认为*Chart.yaml*属性
- en: '[![7](assets/7.png)](#co_helm_CO2-7)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_helm_CO2-7)'
- en: Sets the `securityContext` value as a YAML object and not as a string, indenting
    it 14 spaces
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将`securityContext`值设置为YAML对象，而不是字符串，并将其缩进14个空格
- en: 'The *service.yaml* file templatizes the service name and the container port:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*service.yaml*文件模板化了服务名称和容器端口：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *values.yaml* file contains the default values for the Chart. These values
    can be overridden at runtime, but they provide good initial values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*values.yaml*文件包含Chart的默认值。这些值可以在运行时被覆盖，但它们提供了良好的初始值。'
- en: 'Create the file in the root directory with some default values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在根目录中创建文件，并使用一些默认值：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_helm_CO3-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO3-1)'
- en: Defines the `image` section
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`image`部分
- en: '[![2](assets/2.png)](#co_helm_CO3-2)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO3-2)'
- en: Sets the `repository` property
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`repository`属性
- en: '[![3](assets/3.png)](#co_helm_CO3-3)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO3-3)'
- en: Empty `securityContext`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 空的`securityContext`
- en: Built-in properties are capitalized; for this reason, properties defined in
    the *Chart.yaml* file start with an uppercase letter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 内置属性采用大写；因此，在*Chart.yaml*文件中定义的属性以大写字母开头。
- en: 'Since the `toYaml` function is used for the `securityContext` value, the expected
    value for the `securityContext` property in *values.yaml* should be a YAML object.
    For example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`toYaml`函数用于`securityContext`值，因此*values.yaml*文件中`securityContext`属性的预期值应为YAML对象。例如：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The relationship between all elements is shown in [Figure 5-1](#fig-511).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元素之间的关系显示在[图 5-1](#fig-511)中。
- en: '![Relationship between Helm elements](assets/gocb_0501.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Helm元素之间的关系](assets/gocb_0501.png)'
- en: Figure 5-1\. Relationship between Helm elements
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. Helm元素之间的关系
- en: 'At this point the Helm directory layout is created and should be similar to
    this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，Helm目录布局已创建，并应类似于以下内容：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_helm_CO4-1)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO4-1)'
- en: The *Chart.yaml* file is the Chart descriptor and contains metadata related
    to the Chart.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chart.yaml*文件是Chart描述符，包含与Chart相关的元数据。'
- en: '[![2](assets/2.png)](#co_helm_CO4-2)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO4-2)'
- en: The *templates* directory contains all template files used for installing a
    Chart.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*templates*目录包含用于安装Chart的所有模板文件。'
- en: '[![3](assets/3.png)](#co_helm_CO4-3)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO4-3)'
- en: These files are Helm template files used to deploy the application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是用于部署应用程序的Helm模板文件。
- en: '[![4](assets/4.png)](#co_helm_CO4-4)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_helm_CO4-4)'
- en: The *values.yaml* file contains the default values for a Chart.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*values.yaml*文件包含Chart的默认值。'
- en: 'To render the Helm Chart locally to YAML, run the following command in a terminal
    window:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Helm Chart本地渲染为YAML，请在终端窗口中运行以下命令：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_helm_CO5-1)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO5-1)'
- en: Name is injected from *Chart.yaml*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 名称从*Chart.yaml*中注入
- en: '[![2](assets/2.png)](#co_helm_CO5-2)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO5-2)'
- en: Port is set in *values.yaml*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 端口在*values.yaml*中设置
- en: '[![3](assets/3.png)](#co_helm_CO5-3)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO5-3)'
- en: Version is taken from Chart version
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 版本取自Chart版本
- en: '[![4](assets/4.png)](#co_helm_CO5-4)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_helm_CO5-4)'
- en: Concatenates content from two attributes
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个属性的内容连接起来
- en: '[![5](assets/5.png)](#co_helm_CO5-5)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_helm_CO5-5)'
- en: Empty security context
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 空安全上下文
- en: 'You can override any default value by using the `--set` parameter in Helm.
    Let’s override the `replicaCount` value from one (defined in *values.yaml*) to
    three:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Helm中使用`--set`参数来覆盖任何默认值。让我们将`replicaCount`值从*values.yaml*中的1覆盖为3：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And the `replicas` value is updated:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 并更新`replicas`值：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Helm is a package manager for Kubernetes, and as such, it helps you with the
    task of versioning, sharing, and upgrading Kubernetes applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes的包管理器，帮助您进行版本控制、共享和升级Kubernetes应用程序等任务。
- en: Let’s see how to install the Helm Chart to a Kubernetes cluster and upgrade
    the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将Helm Chart安装到Kubernetes集群并升级应用程序。
- en: 'With Minikube up and running, execute the following command in a terminal window,
    and run the `install` command to deploy the application to the cluster:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当Minikube处于运行状态时，在终端窗口中执行以下命令，并运行`install`命令将应用程序部署到集群中：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Chart is installed in the running Kubernetes instance:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Chart已安装在运行的Kubernetes实例中：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Get the list of current deployed pods, Deployments, and Services to validate
    that the Helm Chart is deployed in the Kubernetes cluster:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前部署的Pods、Deployments和Services的列表，以验证Helm Chart是否已部署在Kubernetes集群中：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, it’s possible to get history information about the deployed Helm Chart
    using the `history` command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用`history`命令获取有关部署的Helm Chart的历史信息：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To uninstall a Chart from the cluster, run `uninstall` command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集群中卸载Chart，请运行`uninstall`命令：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Helm is a package manager that lets you share the Chart (package) to other Charts
    as a dependency. For example, you can have a Chart defining the deployment of
    the application and another Chart as a dependency setting a database deployment.
    In this way, the installation process installs the application and the database
    Chart automatically.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是一个包管理器，允许您将Chart（包）作为依赖项共享给其他Chart。例如，您可以有一个定义应用程序部署的Chart，另一个Chart作为设置数据库部署的依赖项。这样，安装过程会自动安装应用程序和数据库Chart。
- en: We’ll learn about the packaging process and adding dependencies in a later section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中学习打包过程和添加依赖项。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the `helm create <name>` command to let the Helm tool skaffold the
    project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`helm create <name>`命令让Helm工具为项目进行自动化构建。
- en: See Also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Helm](https://helm.sh)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Helm](https://helm.sh)'
- en: '[Go template package](https://oreil.ly/vYI40)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Go模板包](https://oreil.ly/vYI40)'
- en: '[Sprig Function Documentation](https://oreil.ly/ngC2v)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sprig函数文档](https://oreil.ly/ngC2v)'
- en: 5.2 Reusing Statements Between Templates
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 在模板之间重用语句
- en: Problem
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to reuse template statements across several files.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在多个文件中重用模板语句。
- en: Solution
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use *_helpers.tpl* to define reusable statements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*_helpers.tpl*来定义可重用的语句。
- en: We deployed a simple application to Kubernetes using Helm in the previous recipe.
    This simple application was composed of a Kubernetes Deployment file and a Kubernetes
    Service file where the `selector` field was defined with the same value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们使用Helm将一个简单的应用程序部署到Kubernetes。这个简单的应用程序由一个Kubernetes Deployment文件和一个Kubernetes
    Service文件组成，其中`selector`字段的值相同。
- en: 'As a reminder:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you need to update this field—for example, adding a new label as a selector—you
    would need to update in three places, as shown in the previous snippets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更新此字段，例如添加新的标签作为选择器，您需要更新三个地方，如前面的片段所示。
- en: Helm lets you create a *_helpers.tpl* file in the *templates* directory defining
    statements that can be called in templates to avoid this problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Helm允许您在*templates*目录中创建一个*_helpers.tpl*文件，定义可以在模板中调用的语句，以避免这个问题。
- en: Let’s refactor the previous example to use the *_helpers.tpl* file to define
    the `selectorLabels`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构之前的示例，使用*_helpers.tpl*文件定义`selectorLabels`。
- en: 'Create the *_helpers.tpl* file in the *templates* directory with the following
    content:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在*templates*目录中创建*_helpers.tpl*文件，并添加以下内容：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_helm_CO6-1)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO6-1)'
- en: Defines the statement name
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义语句名称
- en: '[![2](assets/2.png)](#co_helm_CO6-2)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO6-2)'
- en: Defines the logic of the statement
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 定义语句的逻辑
- en: 'Then replace the template placeholders shown in previous snippets with a call
    to the `podman.selectorLabels` helper statement using the `include` keyword:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用`podman.selectorLabels`辅助语句中的`include`关键字替换前面片段中显示的模板占位符：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_helm_CO7-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO7-1)'
- en: Calls `pacman.selectorLabels` with indentation
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩进调用了`pacman.selectorLabels`
- en: '[![2](assets/2.png)](#co_helm_CO7-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO7-2)'
- en: Calls `pacman.selectorLabels` with indentation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩进调用了`pacman.selectorLabels`
- en: 'To render the Helm Chart locally to YAML, run the following command in a terminal
    window:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地将Helm Chart渲染为YAML，请在终端窗口中运行以下命令：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_helm_CO8-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO8-1)'
- en: Selector is updated with value set in *_helpers.tpl*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*_helpers.tpl*中设置的值更新选择器
- en: '[![2](assets/2.png)](#co_helm_CO8-2)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO8-2)'
- en: Selector is updated with value set in *_helpers.tpl*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩进调用了`pacman.selectorLabels`
- en: '[![3](assets/3.png)](#co_helm_CO8-3)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO8-3)'
- en: Selector is updated with value set in *_helpers.tpl*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*_helpers.tpl*中设置的值更新选择器
- en: Discussion
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If you want to update the selector labels, the only change you need to do is
    an update to the *_helpers.tpl* file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要更新选择器标签，您唯一需要做的更改就是更新*_helpers.tpl*文件：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_helm_CO9-1)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO9-1)'
- en: Adds a new attribute
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了新属性
- en: 'To render the Helm Chart locally to YAML, run the following command in a terminal
    window:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地将Helm Chart渲染为YAML，请在终端窗口中运行以下命令：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_helm_CO10-1)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO10-1)'
- en: Label is added
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了标签
- en: '[![2](assets/2.png)](#co_helm_CO10-2)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO10-2)'
- en: Label is added
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了标签
- en: '[![3](assets/3.png)](#co_helm_CO10-3)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO10-3)'
- en: Label is added
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了标签
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Although it’s common to use *__helpers.tpl* as the filename to define functions,
    you can name any file starting with `__`, and Helm will read the functions too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常使用*__helpers.tpl*作为文件名来定义函数，您也可以使用以`__`开头的任何文件名，Helm也会读取其中的函数。
- en: 5.3 Updating a Container Image in Helm
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 在Helm中更新容器镜像
- en: Problem
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to update the container image from a deployment file using Helm and
    upgrade the running instance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您想通过Helm从部署文件中更新容器镜像并升级运行实例。
- en: Solution
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `upgrade` command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`upgrade`命令。
- en: 'With Minikube up and running, deploy version 1.0.0 of the `pacman` application:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minikube正常运行时，部署`pacman`应用程序的1.0.0版本：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the first revision deployed, let’s update the container image to a new
    version and deploy it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了第一个修订版本后，让我们将容器镜像更新为新版本并部署。
- en: 'You can check revision number by running the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令检查修订号：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To update the version, open *values.yaml* and update the `image.tag` field
    to the newer container image tag:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新版本，请打开*values.yaml*并将`image.tag`字段更新为新的容器镜像标签：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_helm_CO11-1)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO11-1)'
- en: Updates to container tag to 1.1.0
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 更新到容器标记为1.1.0
- en: 'Then update the `appVersion` field of the *Chart.yaml* file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新*Chart.yaml*文件的`appVersion`字段：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_helm_CO12-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO12-1)'
- en: Version is updated accordingly
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 版本将相应更新
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can use `appVersion` as the tag instead of having two separate fields. Using
    two fields or one might depend on your use case, versioning strategy, and lifecycle
    of your software.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`appVersion`用作标签，而不是使用两个独立字段。使用两个字段或一个字段可能取决于您的用例、版本策略和软件生命周期。
- en: 'After these changes, upgrade the deployment by running the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些更改后，通过运行以下命令升级部署：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output reflects that a new revision has been deployed:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出反映出已部署新修订版本：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_helm_CO13-1)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO13-1)'
- en: New revision
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 新修订版本
- en: 'The `history` command shows all changes between all versions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`history`命令显示所有版本之间的所有更改：'
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`appVersion` is the application version, so every time you change the application
    version, you should update that field too. On the other side, `version` is the
    Chart version and should be updated when the definition of the Chart (i.e., templates)
    changes, so both fields are independent.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`appVersion`是应用程序版本，因此每次更改应用程序版本时，您也应更新该字段。另一方面，`version`是Chart版本，在Chart定义（即模板）更改时应更新，因此这两个字段是独立的。'
- en: Discussion
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Not only you can install or upgrade a version with Helm, but you can also roll
    back to a previous revision.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅可以使用Helm安装或升级版本，还可以回滚到以前的修订版本。
- en: 'In the terminal window, run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中运行以下命令：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the `history` command reflects this change too:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`history`命令也反映了这一变化：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, Helm offers a way to override values, not only using the `--set` argument
    as shown in [Recipe 5.1](#recipe_5_1), but by providing a YAML file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Helm提供了一种覆盖值的方式，不仅可以使用`--set`参数（如[Recipe 5.1](#recipe_5_1)所示），还可以提供一个YAML文件。
- en: 'Create a new YAML file named *newvalues.yaml* in the root directory with the
    following content:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在根目录创建一个名为*newvalues.yaml*的新YAML文件，内容如下：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then run the `template` command, setting the new file as an override of *values.yaml*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行`template`命令，将新文件设置为*values.yaml*的覆盖：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The resulting YAML document is using the values set in *values.yaml* but overriding
    the `images.tag` set in *newvalues.yaml*:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的YAML文档使用*values.yaml*中设置的值，但覆盖了*newvalues.yaml*中设置的`images.tag`：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 5.4 Packaging and Distributing a Helm Chart
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 打包和分发Helm图表
- en: Problem
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to package and distribute a Helm Chart so it can be reused by others.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将Helm图表打包并分发，以便其他人可以重用它。
- en: Solution
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `package` command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`package`命令。
- en: Helm is a package manager for Kubernetes. As we’ve seen in this chapter, the
    basic unit in Helm is a Chart containing the Kubernetes files required to deploy
    the application, the default values for the templates, etc.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是一个用于Kubernetes的包管理器。正如我们在本章中看到的，Helm中的基本单元是一个图表，其中包含部署应用程序所需的Kubernetes文件，模板的默认值等。
- en: But we’ve not yet seen how to package Helm Charts and distribute them to be
    available to other Charts as dependencies or deployed by other users.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有看到如何打包Helm图表并将其分发以供其他图表作为依赖项使用或由其他用户部署。
- en: 'Let’s package the `pacman` Chart into a *.tgz* file. In the *pacman* directory,
    run the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`pacman`图表打包成*.tgz*文件。在*pacman*目录中，运行以下命令：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And you’ll get a message informing you where the archive is stored:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将收到一条消息，告知存档的位置：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A Chart then needs to be published into a Chart repository. A Chart repository
    is an HTTP server with an *index.yaml* file containing metadata information regarding
    Charts and *.tgz* Charts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要将图表发布到图表仓库中。图表仓库是一个HTTP服务器，包含有关图表和*.tgz*图表的元数据信息的*index.yaml*文件。
- en: To publish them, update the *index.yaml* file with the new metadata information,
    and upload the artifact.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布它们，请更新*index.yaml*文件以及上传该工件的新元数据信息。
- en: 'The directory layout of a repository might look like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的目录布局可能如下所示：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The *index.yaml* file with information about each Chart present in the repository
    looks like:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中每个图表的信息在*index.yaml*文件中看起来像这样：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can run `helm repo index` in the root directory, where packaged Charts are
    stored, to generate the index file automatically.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在存储打包图表的根目录中运行`helm repo index`以自动生成索引文件。
- en: Discussion
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In addition to packaging a Helm Chart, Helm can generate a signature file for
    the packaged Chart to verify its correctness later.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打包Helm图表外，Helm还可以为打包的图表生成签名文件，以便以后验证其正确性。
- en: In this way, you can be sure it has not been modified, and it’s the correct
    Chart.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以确保它未被修改，并且是正确的图表。
- en: To sign/verify the package, you need a pair of GPG keys in the machine; we’re
    assuming you already have one pair created.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要签名/验证包，请在计算机上准备一对GPG密钥；我们假设您已经创建了一对。
- en: 'Now you need to call the `package` command but set the `-sign` argument with
    the required parameters to generate a signature file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要调用`package`命令，但要使用必需的参数设置`-sign`参数以生成签名文件：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, two files are created—the packaged Helm Chart (*.tgz*) and the signature
    file (*.tgz.prov*):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，会创建两个文件—打包的Helm图表(*.tgz*)和签名文件(*.tgz.prov*)：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_helm_CO14-1)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO14-1)'
- en: Chart package
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图表包
- en: '[![2](assets/2.png)](#co_helm_CO14-2)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO14-2)'
- en: Signature file
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 签名文件
- en: Note
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to upload both files in the Chart repository.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 记得上传这两个文件到图表仓库中。
- en: 'To verify that a Chart is valid and has not been manipulated, use the `verify`
    command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 若要验证图表是否有效且未被篡改，请使用`verify`命令：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_helm_CO15-1)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO15-1)'
- en: It’s valid
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它是有效的
- en: See Also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[The Chart Repository Guide](https://oreil.ly/pQ2Ab)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图表仓库指南](https://oreil.ly/pQ2Ab)'
- en: '[Helm Provenance and Integrity](https://oreil.ly/1Hql0)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Helm的来源和完整性](https://oreil.ly/1Hql0)'
- en: 5.5 Deploying a Chart from a Repository
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 从仓库部署图表
- en: Problem
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to deploy a Helm Chart stored in Chart repository.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望部署存储在图表仓库中的Helm图表。
- en: Solution
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `repo add` command to add the remote repository and the `install` command
    to deploy it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`repo add`命令添加远程仓库，并使用`install`命令部署它。
- en: Public Helm Chart repositories like [Bitnami](https://oreil.ly/QJzWZ) are available
    for this purpose.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类似[Bitnami](https://oreil.ly/QJzWZ)这样的公共Helm图表仓库可用于此目的。
- en: 'To install Charts from a repository (either public or private), you need to
    register it using its URL:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要从仓库（公共或私有）安装图表，需要使用其 URL 进行注册：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_helm_CO16-1)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO16-1)'
- en: URL of Helm Chart repository where *index.yaml* is placed
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Helm Chart 存放 *index.yaml* 的仓库 URL
- en: 'List the registered repositories:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列出已注册的仓库：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_helm_CO17-1)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO17-1)'
- en: Bitnami repo is registered
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami 仓库已注册
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Run `helm repo update` to get the latest list of Charts for each repo.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `helm repo update` 来获取每个仓库的最新图表列表。
- en: After registering a repository, you might want to find which Charts are available.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注册仓库后，您可能想找到可用的图表。
- en: 'If you want to deploy a PostgreSQL instance in the cluster, use the `search`
    command to search all repositories for a Chart that matches the name:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在集群中部署 PostgreSQL 实例，请使用 `search` 命令搜索所有仓库以匹配名称的图表：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The outputs are the list of Charts that matches the name, the version of the
    Chart and PostgreSQL, and a description. Notice the name of the Chart is composed
    of the repository name and the Chart name, i.e., `bitnami/postgresql`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是与名称匹配的图表列表，Chart 和 PostgreSQL 的版本，以及描述。注意，图表的名称由仓库名称和图表名称组成，即 `bitnami/postgresql`：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To deploy the PostgreSQL Chart, run the `install` command but change the location
    of the Helm Chart from a local directory to the full name of the Chart (`<repo>/<chart>`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署 PostgreSQL 图表，请运行 `install` 命令，但将 Helm 图表的位置从本地目录更改为图表的完整名称（`<repo>/<chart>`）：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](assets/1.png)](#co_helm_CO18-1)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO18-1)'
- en: Sets the name of the deployment
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 设置部署的名称
- en: '[![2](assets/2.png)](#co_helm_CO18-2)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO18-2)'
- en: Overrides default values to the ones set in the command line
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖命令行中设置的默认值
- en: '[![3](assets/3.png)](#co_helm_CO18-3)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO18-3)'
- en: Sets the PostgreSQL Chart stored in the Bitnami repo
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设置存储在 Bitnami 仓库中的 PostgreSQL 图表
- en: 'And a detailed output is shown in the console:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 并在控制台显示详细输出：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Inspect the installation by listing pods, Services, StatefulSets, or Secrets:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出 Pod、Service、StatefulSet 或 Secret 来检查安装情况：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Discussion
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'When a third party creates a Chart, there is no direct access to default values
    or the list of parameters to override. Helm provides a `show` command to check
    these values:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当第三方创建图表时，无法直接访问默认值或要覆盖的参数列表。Helm 提供 `show` 命令来检查这些值：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And shows all the possible values:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 并显示所有可能的值：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 5.6 Deploying a Chart with a Dependency
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 使用依赖项部署图表
- en: Problem
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to deploy a Helm Chart that is a dependency of another Chart.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望部署作为另一个图表依赖项的 Helm Chart。
- en: Solution
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `dependencies` section in the *Chart.yaml* file to register other Charts.
    So far, we’ve seen how to deploy simple services to the cluster, but usually a
    service might have other dependencies like a database, mail server, distributed
    cache, etc.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Chart.yaml* 文件中使用 `dependencies` 部分注册其他图表。到目前为止，我们已经看到如何将简单服务部署到集群中，但通常一个服务可能有其他依赖项，如数据库、邮件服务器、分布式缓存等。
- en: In the previous section, we saw how to deploy a PostgreSQL server in a Kubernetes
    cluster. In this section, we’ll see how to deploy a service composed of a Java
    service returning a list of songs stored in a PostgreSQL database. The application
    is summarized in [Figure 5-2](#fig-561).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到如何在 Kubernetes 集群中部署 PostgreSQL 服务器。在本节中，我们将看到如何部署由返回存储在 PostgreSQL
    数据库中的歌曲列表的 Java 服务组成的服务。该应用程序概述在 [Figure 5-2](#fig-561) 中。
- en: '![Music application overview](assets/gocb_0502.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![音乐应用程序概述](assets/gocb_0502.png)'
- en: Figure 5-2\. Music application overview
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2。音乐应用程序概述
- en: 'Let’s start creating the Chart layout shown in [Recipe 5.1](#recipe_5_1):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建 [Recipe 5.1](#recipe_5_1) 中显示的图表布局：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then create two template files to deploy the music service.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建两个模板文件以部署音乐服务。
- en: 'The *templates/deployment.yaml* file contains the Kubernetes Deployment definition:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*templates/deployment.yaml* 文件包含 Kubernetes Deployment 定义：'
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The *templates/service.yaml* file contains the Kubernetes Service definition:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*templates/service.yaml* 文件包含 Kubernetes Service 定义：'
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After the creation of the templates, it’s time for the Chart metadata *Chart.yaml*
    file. In this case, we need to define the dependencies of this Chart too. Since
    the music service uses a PostgreSQL database, we can add the Chart used in [Recipe
    5.5](#recipe_5_5) as a dependency:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板创建后，现在是时间编写图表元数据 *Chart.yaml* 文件。在这种情况下，我们也需要定义该图表的依赖项。由于音乐服务使用 PostgreSQL
    数据库，我们可以将 [Recipe 5.5](#recipe_5_5) 中使用的图表作为依赖项添加：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[![1](assets/1.png)](#co_helm_CO19-1)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO19-1)'
- en: Dependencies section
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖部分
- en: '[![2](assets/2.png)](#co_helm_CO19-2)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO19-2)'
- en: Name of the Chart to add as dependency
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加为依赖的图表名称
- en: '[![3](assets/3.png)](#co_helm_CO19-3)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_helm_CO19-3)'
- en: Chart version
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图表版本
- en: '[![4](assets/4.png)](#co_helm_CO19-4)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_helm_CO19-4)'
- en: Repository
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库
- en: 'The final file is *Values.yaml* with default configuration values. In this
    case, a new section is added to configure music deployment with PostgreSQL instance
    parameters:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的文件是 *Values.yaml*，包含默认配置值。在这种情况下，添加了一个新的部分来配置使用 PostgreSQL 实例参数的音乐部署：
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[![1](assets/1.png)](#co_helm_CO20-1)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO20-1)'
- en: PostgreSQL section
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 部分
- en: 'With the Chart in place, the next thing to do is download the dependency Chart
    and store it in the *charts* directory. This process is automatically done by
    running the `dependency update` command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有了图表之后，接下来要做的是下载依赖图表并将其存储在 *charts* 目录中。通过运行 `dependency update` 命令可以自动完成这个过程：
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The command output shows that one Chart has been downloaded and saved:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出显示已下载并保存了一个图表：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The directory layout looks like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 目录布局如下所示：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[![1](assets/1.png)](#co_helm_CO21-1)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO21-1)'
- en: PostgreSQL Chart is placed in the correct directory
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 图表已放置在正确的目录中
- en: 'Finally, we deploy the Chart, setting configuration PostgreSQL deployment values
    from the command line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们部署图表，并通过命令行设置 PostgreSQL 部署的配置值：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The installation process shows information about the deployment:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程显示了有关部署的信息：
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inspect the installation by listing pods, Services, StatefulSets, or Secrets:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出 pods、Services、StatefulSets 或 Secrets 来检查安装情况：
- en: '[PRE68]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We can validate the access to the music service by using port forwarding to
    the Kubernetes Service.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用端口转发到 Kubernetes 服务来验证对音乐服务的访问权限。
- en: 'Open a new terminal window and run the following command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并运行以下命令：
- en: '[PRE71]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The terminal is blocked and it’s normal until you stop the `kubectl port-forward`
    process. Thanks to port forwarding, we can access the music service using the
    `localhost` address and port `8080`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 终端被阻塞，直到停止 `kubectl port-forward` 进程。通过端口转发，我们可以使用 `localhost` 地址和端口 `8080`
    访问音乐服务。
- en: 'In another terminal, `curl` the service:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，`curl` 该服务：
- en: '[PRE72]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The request is sent to the music service deployed in Kubernetes and returns
    a list of songs:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求到部署在 Kubernetes 中的音乐服务，并返回一系列歌曲：
- en: '[PRE73]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 5.7 Triggering a Rolling Update Automatically
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 自动触发滚动更新
- en: Problem
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to trigger a rolling update of deployment when a `ConfigMap` object
    is changed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ConfigMap` 对象发生变化时，希望触发部署的滚动更新。
- en: Solution
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `sha256sum` template function to generate a change on the deployment
    file.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sha256sum` 模板函数生成部署文件的变更。
- en: In [Recipe 4.5](ch04.xhtml#recipe_4_5), we saw that Kustomize has a `ConfigMapGenerator`
    that automatically appends a hash to the `ConfigMap` metadata name and modifies
    the deployment file with the new hash when used. Any change on the `ConfigMap`
    triggers a rolling update of the deployment.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Recipe 4.5](ch04.xhtml#recipe_4_5) 中，我们看到 Kustomize 有一个 `ConfigMapGenerator`，在使用时会自动向
    `ConfigMap` 元数据名称附加一个哈希，并在使用时修改部署文件。对 `ConfigMap` 的任何更改都会触发部署的滚动更新。
- en: Helm doesn’t provide a direct way like Kustomize does to update a deployment
    file when the `ConfigMap` changes, but there is a template function to calculate
    a SHA-256 hash of any file and embed the result in the template.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 不像 Kustomize 那样直接提供更新部署文件的方法，但是有一个模板函数可以计算任何文件的 SHA-256 哈希值，并将结果嵌入模板中。
- en: Suppose we’ve got a Node.js application that returns a greeting message. An
    environment variable configures this greeting message, and in the Kubernetes Deployment,
    this variable is injected from a Kubernetes `ConfigMap`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 Node.js 应用程序，返回一个问候消息。一个环境变量配置了这个问候消息，在 Kubernetes 部署中，这个变量是从 Kubernetes
    的 `ConfigMap` 注入的。
- en: '[Figure 5-3](#fig-571) shows an overview of the application.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 5-3](#fig-571) 显示了应用程序的概述。'
- en: '![Greetings application overview](assets/gocb_0503.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![Greetings application overview](assets/gocb_0503.png)'
- en: Figure 5-3\. Greetings application overview
  id: totrans-349
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 问候应用程序概述
- en: Let’s create the Helm Chart for the Greetings application; note that we’re not
    covering the entire process of creating a Chart, but just the essential parts.
    You can refer to [Recipe 5.1](#recipe_5_1) to get started.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为问候应用程序创建 Helm 图表；请注意，我们没有涵盖创建图表的整个过程，只涉及其中的关键部分。您可以参考 [Recipe 5.1](#recipe_5_1)
    开始。
- en: 'Create a deployment template that injects a `ConfigMap` as an environment variable.
    The following listing shows the file:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个部署模板，将 `ConfigMap` 注入为环境变量。以下清单显示了文件：
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[![1](assets/1.png)](#co_helm_CO22-1)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO22-1)'
- en: '`ConfigMap` name'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMap` 名称'
- en: '[![2](assets/2.png)](#co_helm_CO22-2)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO22-2)'
- en: Property key of the `ConfigMap`
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMap` 的属性键'
- en: 'The initial `ConfigMap` file is shown in the following listing:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的 `ConfigMap` 文件显示在以下清单中：
- en: '[PRE75]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[![1](assets/1.png)](#co_helm_CO23-1)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO23-1)'
- en: Sets `ConfigMap` name
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `ConfigMap` 名称
- en: '[![2](assets/2.png)](#co_helm_CO23-2)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_helm_CO23-2)'
- en: Key/value
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值
- en: 'Create a Kubernetes Service template to access the service:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Kubernetes 服务模板以访问服务：
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Update the *values.yaml* file with the template `configmap` parameters:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板 `configmap` 参数更新 *values.yaml* 文件：
- en: '[PRE77]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[![1](assets/1.png)](#co_helm_CO24-1)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO24-1)'
- en: Refers to `ConfigMap` name
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 提到 `ConfigMap` 名称
- en: 'Finally, install the Chart using the `install` command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `install` 命令安装 Chart：
- en: '[PRE78]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When the Chart is deployed, use the `kubectl port-forward` command in one terminal
    to get access to the service:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 Chart 后，在一个终端中使用 `kubectl port-forward` 命令来访问服务：
- en: '[PRE79]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And `curl` the service in another terminal window:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 并在另一个终端窗口中 `curl` 服务：
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[![1](assets/1.png)](#co_helm_CO25-1)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO25-1)'
- en: Configured greeting is used
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的配置问候语
- en: 'Now, let’s update the `ConfigMap` file to a new greeting message:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `ConfigMap` 文件更新为新的问候消息：
- en: '[PRE81]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[![1](assets/1.png)](#co_helm_CO26-1)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO26-1)'
- en: New greeting message
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 新的问候消息
- en: 'Update the `appVersion` field from the *Chart.yaml* file to `1.0.1` and upgrade
    the Chart by running the following command:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 *Chart.yaml* 文件中的 `appVersion` 字段为 `1.0.1`，并通过以下命令升级 Chart：
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Restart the `kubectl port-forward` process and `curl` the service again:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 `kubectl port-forward` 进程并再次 `curl` 服务：
- en: '[PRE83]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[![1](assets/1.png)](#co_helm_CO27-1)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO27-1)'
- en: Greeting message isn’t updated
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 问候消息未更新
- en: 'The `ConfigMap` object is updated during the upgrade, but since there are no
    changes in the `Deployment` object, there is no restart of the pod; hence the
    environment variable is not set to the new value. Listing the pods shows no execution
    of the rolling update:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级期间更新 `ConfigMap` 对象，但由于 `Deployment` 对象没有更改，因此不会重启 Pod；因此环境变量未设置为新值。列出的 Pod
    显示没有执行滚动更新：
- en: '[PRE84]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[![1](assets/1.png)](#co_helm_CO28-1)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO28-1)'
- en: Age value shows no rolling update
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄值显示没有滚动更新
- en: '[Figure 5-4](#fig-572) summarizes the change.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](#fig-572) 总结了变化。'
- en: '![Greetings application with new configuration value](assets/gocb_0504.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![使用新配置值的问候应用](assets/gocb_0504.png)'
- en: Figure 5-4\. Greetings application with new configuration value
  id: totrans-393
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. 使用新配置值的问候应用
- en: 'Let’s use the `sha256sum` function to calculate an SHA-256 value of the *configmap.yaml*
    file content and set it as a pod annotation, which effectively triggers a rolling
    update as the pod definition has changed:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `sha256sum` 函数计算 *configmap.yaml* 文件内容的 SHA-256 值，并将其设置为 Pod 注释，从而有效触发滚动更新，因为
    Pod 定义已更改：
- en: '[PRE85]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[![1](assets/1.png)](#co_helm_CO29-1)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO29-1)'
- en: Includes the *configmap.yaml* file, calculates the SHA-256 value, and sets it
    as an annotation
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 包括 *configmap.yaml* 文件，计算 SHA-256 值，并将其设置为注释
- en: 'Update the `ConfigMap` again with a new value:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用新值更新 `ConfigMap`：
- en: '[PRE86]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[![1](assets/1.png)](#co_helm_CO30-1)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO30-1)'
- en: New greeting message
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 新的问候消息
- en: 'Update the `appVersion` field from *Chart.yaml* to `1.0.1` and upgrade the
    Chart by running the following command:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 *Chart.yaml* 中的 `appVersion` 字段为 `1.0.1`，并通过以下命令升级 Chart：
- en: '[PRE87]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Restart the `kubectl port-forward` process and `curl` the service again:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 `kubectl port-forward` 进程并再次 `curl` 服务：
- en: '[PRE88]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[![1](assets/1.png)](#co_helm_CO31-1)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO31-1)'
- en: Greeting message is the new one
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 问候消息是新的
- en: 'List the pods deployed in the cluster again, and you’ll notice that a rolling
    update is happening:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 再次列出集群中部署的 Pod，您将注意到正在进行滚动更新：
- en: '[PRE89]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[![1](assets/1.png)](#co_helm_CO32-1)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO32-1)'
- en: A rolling update is happening
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行滚动更新
- en: 'Describe the pod to validate that the annotation with the SHA-256 value is
    present:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 Pod 以验证是否存在具有 SHA-256 值的注释：
- en: '[PRE90]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output shows all pod parameters. The important one is the `annotations`
    placed at the top of the output showing the `checksum/config` annotation containing
    the calculated SHA-256 value:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示所有 Pod 参数。重要的是输出顶部显示的 `annotations`，其中包含计算的 SHA-256 值的 `checksum/config`
    注释：
- en: '[PRE91]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[![1](assets/1.png)](#co_helm_CO33-1)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_helm_CO33-1)'
- en: Calculated value
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出的数值
- en: '[Figure 5-5](#fig-573) summarizes the elements that changed when the application
    was updated.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-5](#fig-573) 总结了更新应用程序时发生变化的元素。'
- en: '![Final overview of the Greetings application](assets/gocb_0505.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![Greetings 应用程序的最终概述](assets/gocb_0505.png)'
- en: Figure 5-5\. Final overview of the Greetings application
  id: totrans-420
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-5\. Greetings 应用程序的最终概述
- en: 5.8 Final Thoughts
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.8 总结
- en: In the previous chapter, we saw Kustomize; in this chapter, we’ve seen another
    tool to help deploy Kubernetes applications.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了 Kustomize；在本章中，我们看到了另一个帮助部署 Kubernetes 应用程序的工具。
- en: When you need to choose between Kustomize or Helm, you might have questions
    on which one to use.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在 Kustomize 和 Helm 之间进行选择时，你可能会对该使用哪一个有疑问。
- en: In our experience, the best way to proceed is with Kustomize for simple projects,
    where only simple changes might be required between new deployments.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，对于简单项目，其中可能只需要在新部署之间进行简单更改，最佳方法是使用 Kustomize。
- en: If the project is complex with external dependencies, and several deployment
    parameters, then Helm is a better option.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目复杂且具有外部依赖关系以及多个部署参数，则 Helm 是更好的选择。
