- en: Chapter 12\. Secure Remote Access with OpenSSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenSSH is the tool of choice for secure remote administration. It encrypts
    authentication and all traffic during a session, and guarantees the integrity
    of the data transfer. If something happens to alter your packets, SSH will tell
    you. In this chapter you will learn how to set up SSH access to remote hosts,
    manage your SSH encryption keys, configure logins to multiple remote hosts, customize
    your Bash prompt to show when it is an SSH session, and more good things.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH supports a large number of strong encryption algorithms. All of them
    are unencumbered by patents because the OpenSSH team has gone to great lengths
    to ensure that no patented or otherwise encumbered code is inside OpenSSH. [Recipe
    12.16](#rec-list-algorithms) shows how to print lists of all supported algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSH is a suite of remote transfer utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '*sshd*, the OpenSSH server daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ssh*, short for secure shell, though it doesn’t really include a shell, but
    provides a secure channel to the command shell on the remote system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*scp*, secure copy, for encrypted file transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sftp*, Secure File Transfer Protocol, provides file access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ssh-copy-id*, a nice little program for installing your public key to a remote
    SSH server’s *authorized_keys* file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ssh-keyscan*, finds and collects public host keys on a network, saving you
    the trouble of hunting them down manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ssh-keygen*, generates and manages authentication keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ssh-add*, adds your identities to the authentication agent, *ssh-agent*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter you will learn about *ssh*, *sshd*, *ssh-copy-id*, *ssh-keygen*,
    and two useful related utilities: *sshfs* and *ssh-agent*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*sshfs* mounts remote filesystems on your local PC, while *ssh-agent* remembers
    the passphrases on your private SSH keys over multiple SSH logins for automatic
    authentication. *ssh-agent* binds to a single login session, so logging out or
    opening another terminal means starting over. A better utility for automated operations
    is Keychain, which is a frontend to *ssh-agent*. Keychain reuses *ssh-agent* until
    you restart your machine, so you only have to enter your passphrases at startup
    (see [Recipe 12.10](#rec-keychain)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSH supports different types of authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: Password authentication
  prefs: []
  type: TYPE_NORMAL
- en: Uses your Linux login and password to authenticate. This is the simplest and
    the most flexible, because you can log in from any machine. You must be careful
    to not open an SSH session from an untrustworthy computer, like in a library or
    internet cafe. If it is infected with a keylogger, it will capture your credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Public key authentication
  prefs: []
  type: TYPE_NORMAL
- en: Authenticates with your personal SSH public keys, not your system login. This
    is a bit more work to set up because you need to create and distribute your public
    keys, and you can log in only from machines that hold your private key. Some commercial
    services require customers to use some form of public key authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Passphrase-less authentication
  prefs: []
  type: TYPE_NORMAL
- en: Public key authentication without a passphrase. This is useful for automated
    services, like scripts and cron jobs. Anyone who succeeds in thieving the private
    key can easily masquerade as you, so you need to be very protective of a passphrase-less
    private key.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using keys without passphrases is Keychain, which remembers
    your private keys for you (see [Recipe 12.10](#rec-keychain)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different uses for authentication keys: host keys, which authenticate
    computers, and public keys, which authenticate users. SSH keys come in pairs,
    private and public. Transmissions are encrypted with the public key and decrypted
    with the private key, a brilliantly simple scheme. You can safely distribute your
    public keys as much as you want, while you must protect your private key and not
    let anyone else have it.'
  prefs: []
  type: TYPE_NORMAL
- en: Server and client are defined by the direction of the transaction. The server
    has the SSH daemon running and listening for connection requests, and the client
    is anyone logging in to this machine via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 Installing OpenSSH Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to install an OpenSSH server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most Linux distributions install the OpenSSH client by default, but not always
    the server. The different Linux distributions package OpenSSH in different ways,
    so use your package manager to list the packages for your Linux (see the [Appendix](app01.xhtml#appendix)).
    Install the server, then check if it has started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the server is not running and is not enabled. On most Linuxes,
    OpenSSH is not configured to start automatically after installation. This is good
    because you need to configure your server correctly before opening it up to receive
    connection requests. If it is running before you have examined the server configuration,
    stop it, or block its listening port(s) with your firewall.
  prefs: []
  type: TYPE_NORMAL
- en: The next steps are to set up host encryption keys and configure your server.
    See Recipes [12.2](#rec-gen-host-keys) and [12.3](#rec-secure-server-ssh).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember, server and client are not only about hardware, but are defined by
    the direction of the transaction. The server has the SSH daemon running and listening
    for connection requests, and the client is anyone logging in to the server via
    SSH. Any Linux PC can be a server, client, or both.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.xhtml#cha-firewalld)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sshd (8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Appendix](app01.xhtml#appendix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.2 Generating New Host Keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your Linux distribution does not automatically create host keys at installation,
    or you want to replace your existing host keys, or when you clone an installation
    or a virtual machine your clones need their own unique host keys.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *ssh-keygen* command. There are four different types of keys: RSA,
    DSA, ECDSA, and ED25519\. First, delete the old keys, if they exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create all of the new keys at once with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you ever get bored and need something to do, try researching “Which SSH key
    formats should I use?” The arguments are endless. The short answer is use RSA,
    ECDSA, and ED25519, and avoid DSA. Delete your DSA host key and keep the rest.
  prefs: []
  type: TYPE_NORMAL
- en: RSA is the oldest. It is strong and provides the most compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA and ED25519 are newer, very strong, and computationally less expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Some older SSH clients do not support ECDSA and ED25519\. Hopefully you are
    not using such ancient clients, because ECDSA and ED25519 were released with OpenSSH
    6.5 in 2014\. It is extremely important to keep security services updated and
    to not allow unsafe old clients.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ssh-keygen (1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3 Configuring Your OpenSSH Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to configure your OpenSSH server as securely as possible and test it
    safely.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, verify that your server’s private host keys are owned by root, read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That is how they are supposed to look. Then check your public keys, which are
    owned by root, read-write for root, and read-only for everyone else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These are correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at */etc/ssh/sshd_config*. When you change this file, reload
    *sshd* to load your changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Uncomment the options you want to use or change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure *sshd* to check if the file modes and ownership of the user’s files
    and home directory are correct before accepting their login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If file permissions are not correct, this setting will not allow them to log
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your machine has more than one IP address, define which address, or addresses,
    it listens on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You may assign nonstandard ports for *sshd* to listen on. Use only ports above
    1024, and check */etc/services* to find unused ports, then add your new ports
    to */etc/services*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add them to */etc/ssh/sshd_config*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can restrict access to only the specified groups (create these groups in
    */etc/group*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Or deny access with *DenyGroups*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not allow root logins. It is safer to log in as an unprivileged user, and
    then use *sudo* after login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative is to allow root logins only with public key authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can disable password logins for all users, and allow only public key authentication
    (see [Recipe 12.7](#rec-public-key-auth)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can deny specified users, either by username, or user at hostname or IP
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Or allow access with *AllowUsers*. You may use both, and *DenyUsers* is always
    processed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Limit the length of time the server waits for a user to log in and complete
    the connection. The default is 120 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can limit the number of failed connection attempts. The default is 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any port scanner will find your open ports, and attackers will attempt brute
    force password cracking. Attackers still target the default SSH port 22 the most.
    Changing the port won’t reduce this risk very much, but it should reduce the number
    of entries in your log files. When you use alternate port numbers, first look
    in */etc/services* to find unused ports, and then record the ports you use in
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: Public key authentication is very strong and cannot be brute-forced like password
    logins (see [Recipe 12.7](#rec-public-key-auth)). The trade-off is less convenience,
    as you can log in only from machines that have your private key.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 sshd_config*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 12.5](#rec-host-key-auth)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 12.7](#rec-public-key-auth)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.4 Checking Configuration Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everyone makes mistakes, and you want a syntax checker for */etc/ssh/sshd_config*.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And you shall have one. After making your changes, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no syntax errors, it exits silently. If it find mistakes, it tells
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can do this while the SSH daemon is running, so you can correct your mistakes
    before issuing a reload or restart command.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *-t* stands for *test*. It does not affect the SSH daemon, it only checks
    */etc/ssh/sshd_config* for syntax errors, so you can use it anytime.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 5 sshd_config*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5 Setting Up Password Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to set up your OpenSSH client to log in to a remote host using the
    simplest method that it supports.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Password authentication is the simplest way to set up remote SSH access. You
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH server installed and properly configured on the machine you want to
    log in to ([Recipe 12.3](#rec-secure-server-ssh))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSH daemon running on the remote machine, and port 22, or whatever port
    *sshd* uses, not blocked by firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSH client installed on your client machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your own user account on the remote machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host keys on the server (see [Recipe 12.2](#rec-gen-host-keys))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The public host key must be distributed to the clients. The easy way is to
    log in from the client, and let OpenSSH transfer the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now Duchess can work on *server1* just as if she were sitting at *server1*’s
    keyboard. All traffic and authentication are encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: The host key exchange happens only once, the first time you log in. You should
    never be asked again unless the key is replaced with a new key, or you delete
    it from your personal *~/.ssh/known_hosts* file.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*server1*’s public host key is stored in the *~/.ssh/known_hosts* file on the
    client PC. This file can contain any number of host keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is unsafe to log in as root over SSH; it is better to log in as an ordinary
    user, then *su* or *sudo* after login. You can log in as any user that has an
    account on the remote machine, if you know their password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have the same username on both machines, you don’t need to specify
    the user, and can log in like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I make it a habit to always specify the username as cheap insurance against
    mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t get too worked up over *client* and *server*. These are not about hardware.
    The server is whatever machine you are logging in to, and the client is wherever
    you are logging in from. *sshd* does not need to be running on the client.
  prefs: []
  type: TYPE_NORMAL
- en: There is a risk that the host key transmission could be intercepted and a forged
    key substituted, which would allow an attacker access to your systems. You can
    verify the public key fingerprint before typing **`yes`**. Use an old-fashioned
    method like writing it down and comparing, or a newfangled method like taking
    a photo of the host key with your phone for comparison, or using your phone as
    an actual phone and calling someone who has access to the remote machine to read
    the fingerprint to you.
  prefs: []
  type: TYPE_NORMAL
- en: See [Recipe 12.6](#rec-retrieve-fingerprint) to learn how to retrieve a key
    fingerprint.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 12.6](#rec-retrieve-fingerprint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh-keygen*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 sshd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 Retrieving a Key Fingerprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need the fingerprint of a host key so you can verify for the client that
    the key is legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *ssh-keygen* command on the server with the host key you want to query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where old-fashioned methods of communication, like telephone and sneakernet,
    come in handy. Don’t use email, unless you already have encrypted email with its
    own separate encryption and authentication, because unencrypted email is easy
    to intercept and read.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh-keygen*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.7 Using Public Key Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use public key authentication because it is stronger than password
    authentication, and because it does not use your Linux password. You want the
    option of using a single public key to access multiple systems, or creating a
    unique public key for each remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, Linux user, you can have it all. You may create as many SSH keys as you
    want and use them however you wish. This is my favorite incantation for creating
    a new RSA key pair. Of course you will create your own comment and key name. (See
    the Discussion to learn if you need to set a passphrase on your private key.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to copy your nice new key to a remote machine, which in this
    case is the local backup server *server1*. You must already have SSH access to
    the remote machine, for example, via host key authentication, then use the *ssh-copy-id*
    command to transfer your public key to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Try logging in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You may use this new key to access multiple remote hosts, or create a unique
    key for each remote host. Using the same key for multiple machines is easy to
    use, but a pain to change on multiple hosts. If a unique key is compromised or
    lost, you only need to replace it once.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Always use a passphrase on SSH keys created for human users, because anyone
    who gains access to your private keys can masquerade as you if there is no passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: '*ssh-copy-id* is a lovely little utility that ensures your public keys are
    copied into the correct location, which is *~/.ssh/authorized_keys* on the remote
    host, in the correct format and with the correct permissions. It also ensures
    your private key will not be copied by mistake.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*-C* is for adding a comment to your key, which can help you remember what
    the key is for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-f* is the key name, which can be anything you want. Be mindful of your current
    working directory; if you are not in *~/.ssh*, include the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-t* is the key type: *rsa*, *ecdsa*, or *ed25519*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-b* is the bit strength, and only *rsa* takes this option. The default is
    2048, and 4096 is the maximum. More bits equals more processing overhead, but
    it is doubtful you would notice any difference using 4096 bits except on old feeble
    hardware or on very busy servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-i* tells your SSH client which key you want to use. When you have more than
    one key, you must use this. When you have multiple public keys, you may see a
    “Too many authentication failures” error message if you do not specify one key,
    because SSH tries all of them when one is not specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh-keygen*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.8 Managing Multiple Public Keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use different keys for different servers. How do you manage keys
    with different names?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create a new key pair, use the *-f* option of the *ssh-keygen* command
    to give keys unique names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the *-i* option to specify the key you want to use when you log in
    to the remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To manage multiple public keys more easily, create a new file, *~/.ssh.config*.
    This file configures the logins for your various remote hosts, so you log in with
    *ssh foo* instead of a long command string. The following example configures a
    simpler login for Duchess to access *server2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Duchess logs in like this, using the *Host* value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep adding to this file for your other public key logins, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding solution snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Host* line defines the start of each configuration. This is the label you
    use to login, and it can be anything you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HostName* is the remote machine’s hostname, fully qualified domain name, or
    IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*User* is your user on the remote machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IdentityFile* is the full path to your public key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IdentitiesOnly yes* tells *ssh* to use the settings in *~/.ssh/config*, or
    passed on the command line, and not other providers, if there are any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default SSH port number is 22\. When you need to connect to a nonstandard
    port, for example 2022, specify it with *Port*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You may call your keys anything you want. I like to use descriptive names so
    I know what machines they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to always put a passphrase on your personal private keys.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh_config*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.9 Changing a Passphrase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to change the passphrase on one of your private keys.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *-p* option with the *ssh-keygen* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passphrases are not recoverable. If you lose a passphrase, your only option
    is to create a new key with a new passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh_*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh-keygen*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.10 Automatic Passphrase Management with Keychain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want something to remember your private key passphrases for you, and use
    them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Keychain utility was made for this. Install the *keychain* package, then
    copy the lines in the following example into your *.bashrc* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you want access to *server1*, *server2*, and *server3*
    without entering your passphrases every time you log in. Copy these lines, except
    using your own key names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Keychain keeps your private keys available until you shut down, so you must
    enter your passphrases every time you start up your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you boot to a graphical environment, you may not be prompted to enter
    your passphrases. Try opening a terminal, and if you still don’t see a Keychain
    prompt for your passphrases, you must enter a Linux console. Press Ctrl-Alt-F2
    and log in. After logging in, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The leading dot in *. ~/.keychain/$HOSTNAME-sh* is short for *source*, meaning
    use the named file.
  prefs: []
  type: TYPE_NORMAL
- en: '*$HOSTNAME* tells Keychain to look in the user’s environment variables to fetch
    their hostname. You can see this for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Keychain is a manager for both *ssh-agent* and *gpg-agent*, caching your SSH
    and GPG passphrases for as long as your computer is powered on. You can log out
    and log back in, and will have to reenter your passphrases only after a restart.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good alternative is *gnome-keyring*, which runs in graphical environments.
    This provides a graphical interface for viewing and managing SSH and GPG keys,
    and it also includes a password manager. This appears as “Passwords and Keys”
    on most systems. Its has two disadvantage: it’s not suitable to use on headless
    systems, and it does not make passphrases available to cron (see [Recipe 12.11](#rec-keychain-cron).)'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Funtoo Keychain](https://oreil.ly/rljaf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.11 Using Keychain to Make Passphrases Available to Cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to use cron to automate tasks, such as running rsync backups to a remote
    host. But no matter what you try, you get nothing for your troubles but failed
    backups with authentication errors.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure Keychain to manage your private keys for cron jobs, create a script
    for cron to use. The following example is for an rsync backup, and the script
    is named *duchess-backup-server1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Make this script executable with *chmod*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This example adds a line to your crontab to run the script every night at 10:15
    P.M.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example script, the line starting with */usr/bin/rsync* must be all on
    a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Cron runs in its own special limited environment and needs Keychain to provide
    the required keys and environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 crontab*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Funtoo Keychain](https://oreil.ly/rljaf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.12 Tunneling an X Session Securely over SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run graphical applications from the remote host. You know that the
    X Window System has built-in networking abilities, but it sends all traffic in
    cleartext, which is insecure, and you want to do this safely.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tunneling X over SSH requires no additional software. First, use these commands
    to see if your client machine is running the X11 or Wayland protocol. The following
    examples show both results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*loginctl* is part of systemd.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are running Wayland, you cannot tunnel it over SSH because it does not
    have networking support.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your system is using X11, configure X11 forwarding in */etc/ssh/sshd_config*
    on the remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example tunnels X over SSH, using the *-Y* option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run graphical applications, though only one at a time, like the
    game in [Figure 12-1](#fig-x-tunnel-ssh):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![KMahjongg tunneled over SSH](Images/lcb2_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Playing KMahjongg on the remote server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The X server runs with the offset specified in */etc/ssh/sshd.conf*, *X11DisplayOffset
    10*. This avoids colliding with existing X sessions. Your regular local X session
    is :0.0, so your first remote X session is :10.0\. You can see this with your
    own eyes. Run the following commands on your local machine. The first one is at
    your local command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example is at your SSH command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The remote system only needs to be powered on. You don’t need any local users
    to be logged in, and you don’t even need X to be running. X needs to be running
    only on the client PC.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 sshd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 ssh_config*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.13 Opening an SSH Session and Running a Command in One Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a single command to run on the remote machine, and you think it would
    be nice to run it without logging in and running the command, and then logging
    out. After all, is it not true that laziness is a virtue for system administrators?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenSSH can do this. This example shows how to restart Postfix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be asked for a *sudo* password, but you will still save one whole step.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how to open a quick game of GNOME Sudoku, which requires the X Window
    System:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to do this is with public key authentication for the root user,
    so you don’t have to invoke *sudo* ([Recipe 12.7](#rec-public-key-auth)).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 ssh*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.14 Mounting Entire Remote Filesystems with sshfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenSSH is fast and efficient, and even tunneling X applications over OpenSSH
    isn’t too laggy. But you want a faster way to edit a number of remote files without
    running a graphical file manager over SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*sshfs* is the tool for you. *sshfs* is for mounting an entire remote filesystem,
    and then accessing it just like a local filesystem, without the hassles of setting
    up an NFS or Samba server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the *sshfs* package, which should also install FUSE, the Filesystem
    in Userspace. You need a local directory that you have write permissions for as
    your mountpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then mount your chosen remote directory in your local *sshfs* directory. This
    example mounts the home directory for *duchess@server2* in the *sshfs* directory
    at *duchess@pc*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The remote filesystem is just as accessible as your local filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Access these files from the command line or with your graphical file manager,
    just like your local files.
  prefs: []
  type: TYPE_NORMAL
- en: Your command prompt will not change to the remote prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re finished, unmount the remote filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That mounts Duchess’s entire home directory. Specify a subdirectory instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You cannot use the tilde, ~, as a shortcut for */home/user* because *sshfs*
    does not support it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your network connection is not reliable, tell *sshfs* to automatically reconnect
    after an interruption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Users who are new to *sshfs* always ask these questions: why not just run X
    over SSH, or why not just use NFS? The answers are: it is faster than running
    X over SSH, it is easier to set up than NFS, and you may use NFS, Samba, or whatever
    your heart desires.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 sshfs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.15 Customizing the Bash Prompt for SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sure, you know that the prompt changes to display the remote hostname when you’re
    logged in via SSH. But it’s just a plain prompt, and it’s easy to make mistakes,
    so you want a customized, colorful prompt to indicate when you have an active
    SSH login.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Customize the Bash prompt on the remote machines. This example turns the prompt
    purple and adds “ssh” to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy these lines into the *.bashrc* file for the remote account you want to
    log in to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When you log in to this machine, the prompt will look like what’s shown in [Figure 12-2](#fig-ssh-prompt).
  prefs: []
  type: TYPE_NORMAL
- en: '![Customized SSH prompt](Images/lcb2_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. A customized SSH prompt
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Only the prompt is purple, and all the other text will be your normal shell
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Customizing the Bash prompt is practically a book topic in itself. The example
    in this recipe can be edited to suit your preferences. You don’t have to use the
    term “ssh” or name the variable “text”; these can be anything you like. You could
    say “super duper encrypted session” and name your variable “sekkret-squirl” if
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '*[\e[0;31m\]* is the code block that determines the text color. All you have
    to do is change the numbers to change the colors.'
  prefs: []
  type: TYPE_NORMAL
- en: '*[\e[0m\]* turns off the custom colors, so that your commands and command output
    will return to the normal shell colors. Here are the color codes:'
  prefs: []
  type: TYPE_NORMAL
- en: Black 0;30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue 0;34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green 0;32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyan 0;36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red 0;31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purple 0;35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brown 0;33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light Gray 0;37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dark Gray 1;30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light Blue 1;34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light Green 1;32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light Cyan 1;36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light Red 1;31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light Purple 1;35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yellow 1;33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White 1;37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This customization works by checking for the presence of the *SSH_CLIENT* environment
    variable, which is present only when there is an active SSH connection. You can
    see this for yourself on the remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Then Bash knows to use the custom SSH prompt instead of the default prompt.
    When you run this command on a machine without any active SSH sessions, it returns
    an empty line.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 bash*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash Prompt HOWTO, [Chapter 6](https://oreil.ly/QXWmT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.16 Listing Supported Encryption Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have compliance rules to follow and need to know what encryption algorithms
    OpenSSH supports.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenSSH includes a command to query and list all supported algorithms, *ssh
    -Q <query_option>*. List them with the *help* option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example lists the *sig* signature algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following list briefly describes each option:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cipher* lists supported symmetric ciphers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*cipher-auth* lists supported symmetric ciphers that also support authenticated
    encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*compression* lists supported compression types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*mac* lists supported message integrity codes. These protect your message’s
    data integrity and its authenticity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*kex* lists key exchange algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*kex-gss* lists GSSAPI (Generic Security Service Application Program Interface)
    key exchange algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*key* lists key types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*key-cert* lists certificate key types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*key-plain* lists noncertificate key types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*key-sig* lists all key types and signature algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*protocol-version* lists supported SSH protocol versions, which is only version
    2 at the time of writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sig* lists supported signature algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[OpenSSH](https://openssh.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serious Cryptography* by Jean-Philippe Aumasson (No Starch Press)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
