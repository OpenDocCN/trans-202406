- en: Chapter 15\. Extending Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve seen how to install, interact with, and use Kubernetes to deploy
    and manage applications, we focus in this chapter on adapting Kubernetes to your
    needs. For the recipes in this chapter, you will need [Go](https://go.dev) installed
    and access to the Kubernetes source code hosted on [GitHub](https://github.com/kubernetes/kubernetes).
    We show how to compile Kubernetes as a whole, and how to compile specific components
    like the client `kubectl`. We also demonstrate how to use Python to talk to the
    Kubernetes API server and show how to extend Kubernetes with a custom resource
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Compiling from Source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build your own Kubernetes binaries from source instead of downloading
    the official release binaries (see [Recipe 2.9](ch02.html#get_binaries)) or third-party
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clone the Kubernetes Git repository and build from source.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your development machine has Docker Engine installed, you can use the `quick-release`
    target of the root *Makefile*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This Docker-based build requires at least 8 GB of RAM to complete. Ensure that
    your Docker daemon has access to that much memory. On macOS, access the Docker
    for Mac preferences and increase the allocated RAM.
  prefs: []
  type: TYPE_NORMAL
- en: The binaries will be located in the *_output/release-stage* directory, and a
    complete bundle will be in the *_output/release-tars* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you have a [Golang](https://go.dev/doc/install) environment
    properly set up, use the `release` target of the root *Makefile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The binaries will be located in the *_output/bin* directory.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes [developer guides](https://oreil.ly/6CSWo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.2 Compiling a Specific Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build one specific component of Kubernetes from source. For example,
    you only want to build the client `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using `make quick-release` or simply `make`, as shown in [Recipe
    15.1](#compiling_source), use `make kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are targets in the root *Makefile* to build individual components. For
    example, to compile `kubectl`, `kubeadm`, and `kubelet`, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The binaries will be located in the *_output/bin* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To get the complete list of *Makefile* build targets, run `make help`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3 Using a Python Client to Interact with the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a developer, you want to use Python to write scripts that use the Kubernetes
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the Python `kubernetes` module. This [module](https://oreil.ly/OolLt)
    is the official Python client library for Kubernetes. You can install the module
    from source or from the [Python Package Index (PyPi) site](https://pypi.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With a Kubernetes cluster reachable using your default `kubectl` context, you
    are now ready to use this Python module to talk to the Kubernetes API. For example,
    the following Python script lists all the pods and prints their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `config.load_kube_config()` call in this script will load your Kubernetes
    credentials and endpoint from your `kubectl` config file. By default, it will
    load the cluster endpoint and credentials for your current context.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python client is built using the OpenAPI specification of the Kubernetes
    API. It is up to date and autogenerated. All APIs are available through this client.
  prefs: []
  type: TYPE_NORMAL
- en: Each API group corresponds to a specific class, so to call a method on an API
    object that is part of the `/api/v1` API group, you need to instantiate the `CoreV1Api`
    class. To use deployments, you will need to instantiate the `extensionsV1beta1Api`
    class. All methods and corresponding API group instances can be found in the autogenerated
    [*README*](https://oreil.ly/ITREP).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Examples in the project’s repository](https://oreil.ly/6rw3l)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.4 Extending the API Using Custom Resource Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a custom workload and none of the existing resources, such as `Deployment`,
    `Job`, or `StatefulSet`, is a good fit. So, you want to extend the Kubernetes
    API with a new resource that represents your workload while continuing to use
    `kubectl` in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a [custom resource definition (CRD)](https://oreil.ly/d2MmH).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you want to define a custom resource of kind `Function`. This represents
    a short-running `Job`-like kind of resource, akin to what AWS Lambda offers, that
    is a function as a service (FaaS, or sometimes misleadingly called a “serverless
    function”).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For a production-ready FaaS solution running on Kubernetes, see [Chapter 14](ch14.html#ch_serverless).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the CRD in a manifest file called *functions-crd.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let the API server know about your new CRD (it can take several minutes
    to register):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the custom resource `Function` defined and the API server
    knows about it, you can instantiate it using a manifest called *myfaas.yaml* with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And create the `myfaas` resource of kind `Function` as per usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To discover CRDs, simply access the API server. For example, using `kubectl
    proxy`, you can access the API server locally and query the key space (`example.com/v1`
    in our case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see the resource along with the allowed verbs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to get rid of your custom resource instance, simply delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen, it is straightforward to create a CRD. From an end user’s point
    of view, CRDs present a consistent API and are more or less indistinguishable
    from native resources such as pods or jobs. All the usual commands, such as `kubectl
    get` and `kubectl delete`, work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CRD is, however, really less than half of the work necessary to fully
    extend the Kubernetes API. On their own, CRDs only let you store and retrieve
    custom data via the API server in etcd. You need to also write a [custom controller](https://oreil.ly/kYmqw)
    that interprets the custom data expressing the user’s intent, establishes a control
    loop comparing the current state with the declared state, and tries to reconcile
    both.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Extend the Kubernetes API with `CustomResourceDefinitions`"](https://oreil.ly/mz2bH)
    in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Custom Resources”](https://oreil.ly/gp0xn) in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
