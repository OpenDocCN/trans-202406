- en: Chapter 12\. Building and Running TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’ve deployed and run a JavaScript application in production, then you
    know how to run a TypeScript application too—once you compile it to JavaScript,
    the two aren’t so different. This chapter is about productionizing and building
    TypeScript applications, but there isn’t much here that’s unique to TypeScript
    apps—it mostly applies to JavaScript applications too. We’ll divide it up into
    four sections, covering:'
  prefs: []
  type: TYPE_NORMAL
- en: The things you have to do to build any TypeScript application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running TypeScript applications on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running TypeScript applications in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building for and publishing your TypeScript application to NPM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Your TypeScript Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a TypeScript project is straightforward. In this section, we’ll cover
    the core ideas you’ll need to understand in order to build your project for whatever
    environment you plan to run it in.
  prefs: []
  type: TYPE_NORMAL
- en: Project Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I suggest keeping your source TypeScript code in a top-level *src/* folder,
    and compiling it to a top-level *dist/* folder. This folder structure is a popular
    convention, and splitting your source code and generated code into two top-level
    folders can make your life easier down the line, when you’re integrating with
    other tooling. It also makes it easier to exclude generated artifacts from source
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to stick to this convention when you can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you compile a TypeScript program to JavaScript, there are a few different
    artifacts that TSC can generate for you ([Table 12-1](#artifact-tsc-table)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. Artifacts that TSC can generate for you
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | File extension | tsconfig.json flag | Emitted by default? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **JavaScript** | *.js* | `{"emitDeclarationOnly": false}` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **Source maps** | *.js.map* | `{"sourceMap": true}` | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Type declarations** | *.d.ts* | `{"declaration": true}` | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Declaration maps** | *.d.ts.map* | `{"declarationMap": true}` | No |'
  prefs: []
  type: TYPE_TB
- en: The first type of artifact—JavaScript files—should be familiar. TSC compiles
    your TypeScript code to JavaScript that you can then run using a JavaScript platform
    like NodeJS or Chrome. If you run `tsc yourfile.ts`, TSC will typecheck *yourfile.ts*
    and compile it to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of artifact—source maps—is special files that link each piece
    of your generated JavaScript back to the specific line and column of the TypeScript
    file that it was generated from. This is helpful for debugging your code (Chrome
    DevtTools will show your TypeScript code, instead of the generated JavaScript),
    and for mapping lines and columns in JavaScript exception stack traces back to
    TypeScript (tools like those mentioned in [“Error Monitoring”](#error-monitoring-sect)
    do this lookup automatically if you give them your source maps).
  prefs: []
  type: TYPE_NORMAL
- en: The third artifact—type declarations—lets other TypeScript projects take advantage
    of your generated types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, declaration maps are used to speed up compilation times for your TypeScript
    projects. You’ll read more about them in [“Project References”](#improving-compile-times).
    We’ll spend the rest of this chapter talking about how and why to generate these
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Dialing In Your Compile Target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript can be an unusual language to work with: not only does it have a
    quickly evolving specification with a yearly release cycle, but, as a programmer,
    you can’t always control which JavaScript version the platform you’re running
    your program on implements. On top of that, many JavaScript programs are *isomorphic*,
    meaning you can run them on either the server or the client. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: If you run your backend JavaScript program on a server that you control, then
    you can control exactly which JavaScript version it will run on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you then release your backend JavaScript program as an open source project,
    you don’t know which JavaScript version will be supported by your consumers’ JavaScript
    platforms. The best you can do in a NodeJS environment is declare a range of supported
    NodeJS versions, but in a browser environment you’re out of luck.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you run your JavaScript in a browser, you have no idea which browser people
    will use to run it—the latest Chrome, Firefox, or Edge that supports most modern
    JavaScript features, a slightly outdated version of one of those browsers that’s
    missing some bleeding-edge functionality, an antiquated browser like Internet
    Explorer 8, or an embedded browser like the one that runs on the PlayStation 4
    in your garage. The best you can do is define a minimum set of features that people’s
    browsers need to support to run your application, ship polyfills for as many of
    those features as you can, and try to detect when users are on really old browsers
    that your app won’t run on and show them a message saying that they need to upgrade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you release an isomorphic JavaScript library (e.g., a logging library that
    runs on both browser and server), then you have to support both a minimum NodeJS
    version and a swath of browser JavaScript engines and versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not every JavaScript environment supports every JavaScript feature out of the
    box, but you should still try to write code in the latest language version. There
    are two ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Transpile* (i.e., automatically convert) applications from the latest version
    of JavaScript to the oldest JavaScript version that a platform you target supports.
    We do this for language features like `for..of` loops and `async`/`await`, which
    can be automatically converted to `for` loops and `.then` calls, respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Polyfill* (i.e., provide implementations for) any modern features that are
    missing in the JavaScript runtime you’re running on. We do this for features provided
    by the JavaScript standard library (like `Promise`, `Map`, and `Set`) and for
    prototype methods (like `Array.prototype.includes` and `Function.prototype.bind`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TSC has built-in support for transpiling your code to older JavaScript versions,
    but it will not automatically polyfill your code. This is worth reiterating: TSC
    will transpile most JavaScript features for older environments, but it will not
    provide implementations for missing features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TSC gives you three settings to dial in which environments you want to target:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target` sets the JavaScript version you want to transpile to: `es5`, `es2015`,
    etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module` sets the module system you want to target: `es2015` modules, `commonjs`
    modules, `systemjs` modules, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib` tells TypeScript which JavaScript features are available in the environments
    you’re targeting: `es5` features, `es2015` features, the `dom`, etc. It doesn’t
    actually implement these features—that’s what polyfills are for—but it does tell
    TypeScript that the features are available (either natively or via a polyfill).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment you plan to run your application in dictates which JavaScript
    version you should transpile to with `target` and what to set `lib` to. If you’re
    not sure, `es5` is usually a safe default for both. What you set `module` to depends
    on whether you’re targeting a NodeJS or browser environment, and what module loader
    you’re using if the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you need to support an unusual set of platforms, look up which JavaScript
    features your target platforms support natively in Juriy Zaytsev’s (aka Kangax’s)
    [compatibility tables](http://kangax.github.io/compat-table/es5/).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig a little deeper into `target` and `lib`; we’ll leave `module` to the
    sections on [“Running TypeScript on the Server”](#Running-TypeScript-on-the-Server)
    and [“Running TypeScript in the Browser”](#Running-TypeScript-in-the-Browser).
  prefs: []
  type: TYPE_NORMAL
- en: target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TSC’s built-in transpiler supports converting most JavaScript features to older
    JavaScript versions, meaning you can write your code in the latest TypeScript
    version and transpile it down to whatever JavaScript version you need to support.
    Since TypeScript supports the latest JavaScript features (like `async`/`await`,
    which is not yet supported by all major JavaScript platforms at the time of writing),
    you’ll almost always find yourself taking advantage of this built-in transpiler
    to convert your code to something that NodeJS and browsers understand today.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at which specific JavaScript features TSC does and does not
    transpile for older JavaScript versions ([Table 12-2](#tsc-does-transpile) and
    [Table 12-3](#tsc-does-not-transpile)).^([1](ch12.html#idm46304949773272))
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the past, there was a new revision of the JavaScript language released every
    few years, with an incrementing language version (ES1, ES3, ES5, ES6). As of 2015,
    the JavaScript language now has a yearly release cycle, with each language version
    named after the year it’s released in (ES2015, ES2016, and so on). Some JavaScript
    features, however, get TypeScript support before they’re actually slated for a
    specific JavaScript version; we refer to these features as “ESNext” (as in, the
    next revision).
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-2\. TSC does transpile
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ES2015 | `const`, `let`, `for..of` loops, array/object spread (`...`), tagged
    template strings, classes, generators, arrow functions, function default parameters,
    function rest parameters, destructuring declarations/assignments/parameters |'
  prefs: []
  type: TYPE_TB
- en: '| ES2016 | Exponentiation operator (`**`) |'
  prefs: []
  type: TYPE_TB
- en: '| ES2017 | `async` functions, `await`ing promises |'
  prefs: []
  type: TYPE_TB
- en: '| ES2018 | `async` iterators |'
  prefs: []
  type: TYPE_TB
- en: '| ES2019 | Optional parameter in catch clause |'
  prefs: []
  type: TYPE_TB
- en: '| ESNext | Numeric separators (`123_456`) |'
  prefs: []
  type: TYPE_TB
- en: Table 12-3\. TSC does not transpile
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ES5 | Object getters/setters |'
  prefs: []
  type: TYPE_TB
- en: '| ES2015 | Regex `y` and `u` flags |'
  prefs: []
  type: TYPE_TB
- en: '| ES2018 | Regex `s` flag |'
  prefs: []
  type: TYPE_TB
- en: '| ESNext | BigInt (`123n`) |'
  prefs: []
  type: TYPE_TB
- en: 'To set the transpilation target, pop open your *tsconfig.json* and set the
    `target` field to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`es3` for ECMAScript 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`es5` for ECMAScript 5 (this is a good default if you’re not sure what to use)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`es6` or `es2015` for ECMAScript 2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`es2016` for ECMAScript 2016'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`es2017` for ECMAScript 2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`es2018` for ECMAScript 2018'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`esnext` for whatever the most recent ECMAScript revision is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to compile to ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: lib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As I mentioned, there’s one hitch with transpiling your code to older JavaScript
    versions: while most language features can be safely transpiled (`let` to `var`,
    `class` to `function`), you still need to *polyfill* functionality yourself if
    your target environment doesn’t support a newer library feature. Some examples
    are utilities like `Promise` and `Reflect`, and data structures like `Map`, `Set`,
    and `Symbol`. When targeting a bleeding-edge environment like the latest Chrome,
    Firefox, or Edge, you usually won’t need any polyfills; but if you’re targeting
    browsers a few versions back—or most NodeJS environments—you will need to polyfill
    missing features.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, you won’t need to write polyfills yourself. Instead, you can install
    them from a popular polyfill library like [`core-js`](https://www.npmjs.com/package/core-js),
    or add polyfills to your code automatically by running your typechecked TypeScript
    code through Babel with [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you plan to run your application in a browser, be careful not to bloat the
    size of your JavaScript bundle by including every single polyfill regardless of
    whether or not the browser you’re running your code in actually needs it—your
    target platform probably already supports some of the features you’re polyfilling.
    Instead, use a service like [Polyfill.io](https://polyfill.io/v2/docs/) to load
    just those polyfills that your user’s browser needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve added polyfills to your code, it’s time to tell TSC that your environment
    is guaranteed to support the features you polyfilled—enter your *tsconfig.json*’s
    `lib` field. For example, you could use this configuration if you’ve polyfilled
    all ES2015 features plus ES2016’s `Array.prototype.includes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re running your code in the browser, also enable DOM type declarations
    for things like `window`, `document`, and all the other APIs you get when running
    your JavaScript in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For a full list of supported libs run `tsc --help`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Source Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source maps are a way to link your transpiled code back to the source code it
    was generated from. Most developer tools (like Chrome DevTools), error reporting
    and logging frameworks, and build tools know about source maps. Since a typical
    build pipeline can produce code that’s very different from the code you started
    with (for example, your pipeline might compile TypeScript to ES5 JavaScript, tree-shake
    it with Rollup, preevaluate it with Prepack, then minify it with Uglify), using
    source maps throughout your build pipeline can make it a lot easier to debug the
    resulting JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s generally a good idea to use source maps in development, and ship source
    maps to production in both browser and server environments. There’s one caveat,
    though: if you rely on some level of security through obscurity for your browser
    code, don’t ship source maps to browsers in production.'
  prefs: []
  type: TYPE_NORMAL
- en: Project References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your application grows, it will take longer and longer for TSC to typecheck
    and compile your code. This time grows roughly linearly with the size of your
    codebase. When developing locally, slow incremental compile times can seriously
    slow down your development, and make working with TypeScript painful.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, TSC comes with a feature called *project references* that speeds
    up compilation times dramatically, including incremental compile times. For any
    project with a few hundred files or more, project references are a must-have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Split your TypeScript project into multiple projects. A project is simply a
    folder that contains a *tsconfig.json* and some TypeScript code. Try to split
    your code in such a way that code that tends to be updated together lives in the
    same folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In each project folder, create a *tsconfig.json* that includes at least:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The keys here are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`composite`, which tells TSC that this folder is a subproject of a larger TypeScript
    project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`declaration`, which tells TSC to emit *.d.ts* declaration files for this project.
    The way project references work, projects have access to each other’s declaration
    files and emitted JavaScript, but not their source TypeScript files. This creates
    a boundary beyond which TSC won’t try to retypecheck or recompile your code: if
    you update a line of code in your subproject *A*, TSC doesn’t have to retypecheck
    your other subproject *B*; all TSC needs to check for a type error is *B*’s type
    declarations. This is the core behavior that makes project references so efficient
    at rebuilding big projects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`declarationMap`, which tells TSC to build source maps for generated type declarations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`references`, which is an array of subprojects that your subproject depends
    on. Each reference’s `path` should point either to a folder that contains a *tsconfig.json*,
    or directly to a TSC configuration file (if your configuration file isn’t named
    *tsconfig.json*). `prepend` will concatenate the JavaScript and source maps generated
    by the subproject you’re referencing to the JavaScript and source maps generated
    by your subproject. Note that `prepend` is only useful when you’re using `outFile`—if
    you don’t use `outFile`, you can ditch the `prepend`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootDir`, which explicitly specifies that this subproject should be compiled
    relative to the root project (`.`). Alternatively, you can specify an `outDir`
    that’s a subfolder of the root project’s `outDir`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a root *tsconfig.json* that references any subprojects that aren’t yet
    referenced by another subproject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now when you compile your project with TSC, use the `build` flag to tell TSC
    to take project references into account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At the time of writing, project references are a new TypeScript feature with
    some rough edges. When using them, be careful to:'
  prefs: []
  type: TYPE_NORMAL
- en: Rebuild the entire project (with `tsc -b`) after cloning or refetching it, in
    order to regenerate any missing or outdated *.d.ts* files. Alternatively, check
    in your generated *d.ts* files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not use `noEmitOnError: false` with project references—TSC will always hardcode
    the option to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually make sure that a given subproject isn’t prepended by more than one
    other subproject. Otherwise, the doubly prepended subproject will show up twice
    in your compiled output. Note that if you’re just referencing and not prepending,
    you’re good to go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error Monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript warns you about errors at compile time, but you also need a way to
    find out about exceptions that your users experience at runtime, so that you can
    try to prevent them at compile time (or at least fix the bug that caused the runtime
    error). Use an error monitoring tool like [Sentry](https://sentry.io) or [Bugsnag](https://bugsnag.com)
    to report and collate your runtime exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Running TypeScript on the Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run your TypeScript code in a NodeJS environment, just compile your code
    to ES2015 JavaScript (or ES5, if you’re targeting a legacy NodeJS version) with
    your *tsconfig.json*’s module flag set to `commonjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That will compile your ES2015 `import` and `export` calls to `require` and `module.exports`,
    respectively, so your code will run on NodeJS with no further bundling needed.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using source maps (you should be!), you’ll need to feed your source
    maps into your NodeJS process. Just grab the [`source-map-support`](https://www.npmjs.com/package/source-map-support)
    package from NPM, and follow the package’s setup instructions. Most process monitoring,
    logging, and error reporting tools like [PM2](https://www.npmjs.com/package/pm2),
    [Winston](https://www.npmjs.com/package/winston), and [Sentry](https://sentry.io)
    have built-in support for source maps.
  prefs: []
  type: TYPE_NORMAL
- en: Running TypeScript in the Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling TypeScript to run in the browser involves a little more work than
    running TypeScript on the server.
  prefs: []
  type: TYPE_NORMAL
- en: First, pick a module system to compile to. A good rule of thumb is to stick
    to `umd` when publishing a library for others to use (e.g., on NPM) in order to
    maximize compatibility with various module bundlers that people might use in their
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just plan to use your code yourself without publishing it to NPM, which
    format you compile to depends on the module bundler you’re using. Check your bundler’s
    documentation—for example, Webpack and Rollup work best with ES2015 modules, while
    Browserify requires CommonJS modules. Here are a few guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the [SystemJS](https://github.com/systemjs/systemjs) module
    loader, set `module` to `systemjs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re running your code through an ES2015-aware module bundler like [Webpack](https://webpack.js.org)
    or [Rollup](https://github.com/rollup/rollup), set `module` to `es2015` or higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re using an ES2015-aware module bundler and your code uses dynamic imports
    (see [“Dynamic Imports”](ch10.html#dynamic_imports)), set `module` to `esnext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re building a library for other projects to use, and aren’t running your
    code through any additional build steps after `tsc`, maximize compatibility with
    different loaders that people use by setting `module` to `umd`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re bundling your module with a CommonJS bundler like [Browserify](https://github.com/browserify/browserify),
    set `module` to `commonjs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re planning to load your code with [RequireJS](https://requirejs.org)
    or another AMD module loader, set `module` to `amd`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want your top-level exports to be globally available on the `window`
    object (as you might if you’re Mussolini’s great-nephew), set `module` to `none`.
    Note that TSC will try to curb your enthusiasm for inflicting pain on other software
    engineers by compiling to `commonjs` anyway if your code is in module mode (see
    [“Module Mode Versus Script Mode”](ch10.html#module-mode)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, configure your build pipeline to compile all your TypeScript to a single
    JavaScript file (usually called a “bundle”) or a set of JavaScript files. While
    TSC can do this for you for small projects with the `outFile` TSC flag, the flag
    is limited to generating SystemJS and AMD bundles. And since TSC doesn’t support
    build plugins and intelligent code splitting the same way that a dedicated build
    tool like Webpack does, you’ll soon find yourself wanting a more powerful bundler.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why for frontend projects, you should use a more powerful build tool
    from the beginning. There are TypeScript plugins for whatever build tool you might
    be using, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ts-loader`](http://bit.ly/2Gw3uH2) for [Webpack](https://webpack.js.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tsify`](http://bit.ly/2KOaZgw) for [Browserify](http://bit.ly/2IDpfGe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`@babel/preset-typescript`](http://bit.ly/2vc2Sjy) for [Babel](https://babeljs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`gulp-typescript`](http://bit.ly/2vanubN) for [Gulp](https://gulpjs.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`grunt-ts`](http://bit.ly/2PgUXuq) for [Grunt](https://gruntjs.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While a full discussion of optimizing your JavaScript bundle for fast loading
    is outside the scope of this book, some brief advice—not specific to TypeScript—is:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep your code modular, and avoid implicit dependencies in your code (these
    can happen when you assign things to the `window` global, or to other globals),
    so that your build tool can more accurately analyze your project’s dependency
    graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use dynamic imports to lazy-load code that you don’t need for your initial page
    load, so you don’t unnecessarily block your page from rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of your build tool’s automatic code splitting functionality,
    so that you avoid loading too much JavaScript and slowing page load unnecessarily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a strategy for measuring page load time, either synthetically or, ideally,
    with real user data. As your app grows the initial load time can get slower and
    slower; you can only optimize that load time if you have a way to measure it.
    Tools like [New Relic](https://newrelic.com) and [Datadog](https://www.datadoghq.com)
    are invaluable here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your production build as similar as possible to your development build.
    The more the two diverge, the more hard-to-fix bugs you’ll have that only show
    up in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when shipping TypeScript to run in the browser, have a strategy for
    polyfilling missing browser features. This might be a standard set of polyfills
    you ship as part of every bundle, or it might be a dynamic set of polyfills based
    on what features the user’s browser supports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing Your TypeScript Code to NPM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s easy to compile your TypeScript code so that other TypeScript and JavaScript
    projects can use it. There are a few best practices to keep in mind when compiling
    to JavaScript for external use:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate source maps, so you can debug your own code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile to ES5, so that others can easily build and run your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be mindful about which module format you compile to (UMD, CommonJS, ES2015,
    etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate type declarations, so that other TypeScript users have types for your
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by compiling your TypeScript to JavaScript with `tsc`, and generate corresponding
    type declarations. Be sure to configure your *tsconfig.json* to maximize compatibility
    with popular JavaScript environments and build systems (more on that in [“Building
    Your TypeScript Project”](#building)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, blacklist your TypeScript source code from getting published to NPM in
    your *.npmignore*, to avoid bloating the size of your package. And in your *.gitignore*,
    exclude generated artifacts from your Git repository to avoid polluting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you stuck with the recommended project layout and kept your source files
    in *src/* and your generated files in *dist/*, your *.ignore* files will be even
    simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a `"types"` field to your project’s *package.json* to indicate
    that it comes with type declarations (note that this isn’t mandatory, but it is
    a helpful hint to TSC for any consumers that use TypeScript), and add a script
    to build your package before publishing it, to make sure that your package’s JavaScript,
    type declarations, and source maps are always up to date and in sync with the
    TypeScript you compiled them from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Now when you `npm publish` your package to NPM, NPM will automatically
    compile your TypeScript to a format usable by both people that use TypeScript
    (with full type safety) and people that use JavaScript (with some type safety,
    if their code editor supports it).
  prefs: []
  type: TYPE_NORMAL
- en: Triple-Slash Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript comes with a little-known, rarely used, and mostly outdated feature
    called *triple-slash directives*. These directives are specially formatted TypeScript
    comments that serve as instructions to TSC.
  prefs: []
  type: TYPE_NORMAL
- en: 'They come in a few flavors, and in this section, we’ll cover just two of them:
    `types`, for eliding type-only full-module imports, and `amd-module`, for naming
    generated AMD modules. For a full reference, see [Appendix E](app05.html#triple-slash-directives).'
  prefs: []
  type: TYPE_NORMAL
- en: The types Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you import something from a module, depending on what you imported, TypeScript
    won’t always need to generate an `import` or `require` call when you compile your
    code to JavaScript. If you have an `import` statement whose export is only used
    in a type position in your module (i.e., you just imported a type from a module),
    TypeScript won’t generate any JavaScript code for that `import`—think of it as
    only existing at the type level. This feature is called *import elision*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception to the rule is imports used for side effects: if you import an
    entire module (without importing a specific export or a wildcard from that module),
    that import will generate JavaScript code when you compile your TypeScript. You
    might do this, for instance, if you want to make sure that an ambient type defined
    in a script-mode module is available in your program (like we did in [“Safely
    Extending the Prototype”](ch06.html#extending-the-prototype)). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling *app.ts* to JavaScript with `tsc app.ts`, you’ll notice that
    that the `./global` import wasn’t elided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you find yourself writing imports like this, you may want to start by making
    sure that your import really needs to use side effects, and that there isn’t some
    other way to rewrite your code to make it more explicit which value or type you’re
    importing (e.g., `import {MyType} from './global'`—which TypeScript will elide
    for you—instead of `import './global'`). Or, see if you can include your ambient
    type in your *tsconfig.json*’s `types`, `files`, or `include` field and avoid
    the import altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'If neither of those works for your use case, and you want to continue to use
    a full-module import but avoid generating a JavaScript `import` or `require` call
    for that import, use the `types` triple-slash directive. A triple-slash directive
    is three slashes `///` followed by one of a few possible XML tags, each with its
    own set of required attributes. For the `types` directive, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a dependency on an ambient type declaration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a dependency on *@types/jasmine/index.d.ts*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You probably won’t find yourself using this directive often. And if you do,
    you may want to rethink how you’re using types in your project, and consider if
    there’s a way to rely less on ambient types.
  prefs: []
  type: TYPE_NORMAL
- en: The amd-module Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When compiling your TypeScript code to the AMD module format (indicated with
    `{"module": "amd"}` in your *tsconfig.json*), TypeScript will generate anonymous
    AMD modules by default. You can use the AMD triple-slash directive to give your
    emitted modules names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling to the `amd` module format, TSC generates the following JavaScript
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re familiar with the AMD module format, you might have noticed that
    this is an anonymous AMD module. To give your AMD module a name, use the `amd-module`
    triple-slash directive in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_and_running_typescript_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `amd-module` directive, and set a `name` attribute on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_and_running_typescript_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of our code is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recompiling to the AMD module format with TSC, we now get the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When compiling to AMD modules, use the `amd-module` directive to make your code
    easier to bundle and debug (or, switch to a more modern module format like ES2015
    modules if you can).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered everything you need to know to build and run your
    TypeScript application in production, either in the browser or on the server.
    We discussed how to choose a JavaScript version to compile to, which libraries
    to mark as available in your environment (and how to polyfill libraries when they’re
    missing), and how to build and ship source maps with your application to make
    it easier to debug in production and develop locally. We then explored how to
    modularize your TypeScript project to keep compilation times fast. Finally, we
    finished up with how to run your TypeScript application on the server and in the
    browser, how to publish your TypeScript code to NPM for others to use, how import
    elision works, and—for AMD users—how to use triple-slash directives to name your
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch12.html#idm46304949773272-marker)) If you use a language feature that
    TSC doesn’t transpile and your target environment doesn’t support it either, you
    can usually find a Babel plugin to transpile it for you. To find the most up-to-date
    plugin, search for “babel plugin <feature name>” in your favorite search engine.
  prefs: []
  type: TYPE_NORMAL
