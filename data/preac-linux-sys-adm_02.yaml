- en: Chapter 2\. Working with Permissions and Privileged Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For sysadmins, the CLI is home. Typing at the keyboard is standard fare. You’ll
    need to become comfortable with the command line, its idiosyncrasies, and its
    shortcuts—yes, there are command-line shortcuts. There’s a lot to learn about
    Linux at the command line. There are dozens of commands, each with dozens of options.
    Sure, you’ll only use a handful of commands and a limited number of options for
    each command, but you need to know how to find the options you need and how to
    use them when you need to.
  prefs: []
  type: TYPE_NORMAL
- en: The true power of the CLI is in its ease of use. The CLI was the first interface
    that users and programmers had with which to address their operating environments.
    The fact that the CLI is still in use some 50 years later is a testament to its
    power and usefulness to the sysadmin and user alike. This chapter teaches you
    to work at the command line as a regular user and as a root user. You also learn
    to set and modify file permissions and the effects that those permissions have
    on files.
  prefs: []
  type: TYPE_NORMAL
- en: Working as a Regular User
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two user types on a Linux system: regular users and a root, or administrator,
    user. Regular users each receive their own home directory and somewhat limited
    system use. The root user also has a home directory (*/root*). Regular users have
    almost unlimited power in their own home directories to create, modify, remove,
    and manipulate files but have almost no power outside of that single location.
    Many system commands are available to regular users. In contrast, other commands
    are restricted to those granted limited root user access through the `sudo` command
    or direct access to the root user account.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The general and most security-conscious rule is that you should always work
    as a regular user unless some task requires privileged (root user) access, which
    is covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working as the Root User
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The root user is the all-powerful account on any Linux system. The root user
    can create, edit, move, or remove any file on the system. The root user can reboot,
    change runlevels, and shut down the system. There are three methods of becoming
    the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging in as the root user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `su` (substitute user) command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `sudo` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in as Root
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On some Linux distributions, you can directly log in as the root user on a system
    via SSH across the network or interactively at the console. Some Linux distributions
    prevent SSH root logins by default, while others leave it up to the administrators
    to decide. It’s not recommended to SSH to a system and login as root. The primary
    reason is that if you allow across-the-network root access to a system, then it’s
    possible that malicious actors can attempt to brute force a root login. You don’t
    want this to happen. Later in the book, I’ll show you how to prevent SSH root
    logins, if not already disabled, on your distribution.
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn’t directly log in as root at the console because doing so prevents
    system logging from recording who has logged in and become root. Recording who
    uses the root user account is important because when something goes wrong, you
    want to know which administrator performed the actions. This record-keeping’s
    purpose is not to lay blame. Still, it is necessary to meet some regulatory requirements
    and to correct the actions of a system administrator who needs a teachable moment
    or some advanced training. The next two options we discuss are better, safer ways
    to become the root user.
  prefs: []
  type: TYPE_NORMAL
- en: Using the su Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the appropriate methods of becoming the root user is to use the `su`
    (substitute user) command. The caveat with using `su` is that the user must know
    the root user password. If administrative users know the root password, it’s difficult
    to prevent those same administrators from directly logging in as root. Using the
    `su` command to become root is acceptable, but only if the root password changes
    after each use. In larger enterprises, security groups maintain root passwords,
    and system administrators can check out the root password temporarily to perform
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The root user may `su` to any other user account on the system without knowing
    the user’s password. This power allows administrators to log in as, or become,
    any user for troubleshooting purposes because it’s often difficult for users to
    accurately describe problems they’re experiencing. It also prevents a user from
    revealing their password to an administrator, which should force the user to change
    their password.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `su` to another account is a simple procedure. Issue the `su` command and
    the user account you wish to `su` to. For this example, I use the full prompt
    rather than just the `$` to demonstrate the user change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `#` prompt informs you that you are now logged in as the root user. In this
    book, the user prompt is `$` and the root is `#`, to distinguish a standard user’s
    prompt from the root user’s. Any command you issue now is done with root privilege,
    which means that you must be careful because there are no restrictions on the
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The better method of using `su` is using the `su -` command because the `-`
    means that you also want to take on the root user’s full environment rather than
    just the account privilege. The display is much too long to show here, but if
    you issue the `env` command, you’ll see the original user’s environment variables
    rather than root’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `exit` command to return to the original user account, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And now issue the `su` command with the `-` option. You don’t have to specify
    root in this command because the default is root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The root user’s environment variables are now displayed. Using the `su -` command
    is the equivalent of logging into the console as the root user. Any user may `su`
    to any other user account, which requires one to know the other user’s password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the sudo Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best method to obtain root access is to use the “substitute user do” or
    “execute a command as another user” (`sudo`) command. The `sudo` command allows
    an appropriately configured user account to issue individual commands as the root
    user. The `sudo` command must precede each command issued. On first use, the `sudo`
    command requires that the *sudoer* (a user account configured for `sudo` use)
    supply their own password, as shown in the following code listing. Knowledge of
    the root password isn’t required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The warning that the user is not in the *sudoers* file means that the user account,
    bjones, is not configured in the */etc/sudoers* file. In the next section, I demonstrate
    how to set up a user to be a sudoer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `sudo` command, the */etc/sudoers* file, and the sudoer user label are interesting
    because they have their own unique pronunciations. The accepted pronunciation
    for `sudo` is “soodoo” and sudoer is “soodooer.” Some sysadmins pronounce them
    as “soodoe” and “soodoe-ers,” but no one takes issue with either pronunciation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Sudoer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must have root user access to edit the */etc/sudoers* file and to use the
    `visudo` utility, whose only purpose is to edit the */etc/sudoers* file. You shouldn’t
    edit it directly with vi, Emacs, or any other text editor. To edit the */etc/sudoers*
    file, issue the `visudo` command as root with no options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The */etc/sudoers* file is a simple text file describing users, groups, and
    commands that can work with root or other user privileges. You can create a sudoer
    with very restrictive permissions (i.e., to run a single command as root) or permissive:
    run any command as root without entering a password to do so. I prefer to configure
    a mixture of the two by creating sudoers who can run any command as root but must
    supply their password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hundreds of possible configuration scenarios exist for the */etc/sudoers* file
    and sudoers. It’s out of the scope of this book to explore more than what’s given
    here as examples. In this first example, I demonstrate how I set up my user account
    to use `sudo`. My settings require me to enter my password when using `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I copy the root user’s setting and insert my user account in its place. The
    setting takes effect immediately. Setting up a user account to use `sudo` without
    issuing a password is not recommended. Using a password when issuing a command
    is an attempt to make it more difficult to make mistakes while wielding root privilege.
    The same can be said of the `sudo` command itself. The theory is that if an administrator
    has to issue the `sudo` command, they will make fewer mistakes as root because
    it requires them to think specifically about their command action and its results.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Modifying Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section teaches you how to read and modify file permissions. You must learn
    file permissions to set and modify access to files and directories appropriately.
    Knowing file permissions helps troubleshoot when users can’t access a file or
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions are simple but central to Linux security. Their simplicity
    can make them susceptible to neglect and misconfiguration. Frustrated sysadmins
    sometimes loosen permissions to solve a problem but never return to the issue
    or reset the permissions to their proper settings.
  prefs: []
  type: TYPE_NORMAL
- en: Read, Write, and Execute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three Linux file permissions or modes are read (r), write (w), and execute
    (x):'
  prefs: []
  type: TYPE_NORMAL
- en: Read
  prefs: []
  type: TYPE_NORMAL
- en: View a file or list directory contents.
  prefs: []
  type: TYPE_NORMAL
- en: Write
  prefs: []
  type: TYPE_NORMAL
- en: Create and modify a file or copy, move, and create files in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Execute
  prefs: []
  type: TYPE_NORMAL
- en: Execute/run a file or `cd` into a directory.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](ch01.xhtml#getting_started_with_linux), a file’s
    name does not determine whether it’s executable, as is the case for MS Windows
    (*.exe* files, etc.). A Linux file is executable or not based on its permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the rwx designations in permissions is known as *symbolic mode*. The symbolic
    mode is one of two methods of identifying permissions. The other is the numeric
    mode, which assigns values to each of the rwx permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Permission Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the permission modes has its own assigned numerical value. This shortcut
    method makes setting permissions easier for sysadmins.
  prefs: []
  type: TYPE_NORMAL
- en: The read permission has a value of `4`, write has a value of `2`, and execute
    has a value of `1`. Permission values can range from `0` to `7`. A zero permission
    value means no permission. [Table 2-1](#numerical_permission_values) summarizes
    this idea.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Numerical permission values
  prefs: []
  type: TYPE_NORMAL
- en: '| Permission mode | Numerical value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| Write | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| Execute | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| None | `0` |'
  prefs: []
  type: TYPE_TB
- en: In the next section, you will find out how these permissions work together with
    group permissions to create a simple but complete file security system.
  prefs: []
  type: TYPE_NORMAL
- en: Group Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Four file permissions apply to a user’s group: user, group, others, and all.
    The “all” group includes user, group, and others. It is a shorthand method of
    globally assigning permissions to a file or directory. Each group has a shorthand
    designation as well, as shown in [Table 2-2](#group_permissions).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Group permissions
  prefs: []
  type: TYPE_NORMAL
- en: '| Permission group | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| User | `u` |'
  prefs: []
  type: TYPE_TB
- en: '| Group | `g` |'
  prefs: []
  type: TYPE_TB
- en: '| Other | `o` |'
  prefs: []
  type: TYPE_TB
- en: '| All | `a` |'
  prefs: []
  type: TYPE_TB
- en: Users and sysadmins may set permissions on files for each group individually
    or all groups simultaneously. Each Linux file and directory is assigned read,
    write, and execute permissions for each group. The next section ties all of the
    permissions settings together for you.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Permissions into Focus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, I’ll create a simple but complete file security system
    that shows how all the permissions we’ve discussed work together. The examples
    in this section will use the file *file.txt*. If you want to follow along with
    the example, issue the following command to set up your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates an empty file named *file.txt* for you. Next, issue the
    `ls` command with the `-l` (long) option to see file permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-1](#special_character_position_and_usercomm) illustrates the positions
    and their designations (in bold). The first position is for special file types,
    such as directories with a `d` in that position (`dr-xr-xr-w`). Regular files
    have a `-` (`-rw-rw-rw-`) to show that they’re not directories or other special
    files. The next nine positions are user, group, and other permissions locations.
    The first “triad,” or three positions, are for the user, the second for group,
    and the final three are for other users.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/plsa_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Special character position and user, group, and other permission
    locations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 2-2](#numerical_permission_values_and_usercom) shows the numerical
    permissions for each listing and then an explicit label for the user (`u`), group
    (`g`), and other (`o`) triads.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/plsa_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Numerical permission values and user, group, and other (ugo) designations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As shown in [Figure 2-2](#numerical_permission_values_and_usercom), numerical
    permissions are additive for each triad to create a permission profile for a file.
    For example, a file with `-rw-rw-r--` permissions has a numeric permission value
    of `664`. The read permission has a value of `4` added to the value of the write
    permission, which is `2`, which equals `6`. All three possible permissions, `rwx`,
    yield a value of `7`.
  prefs: []
  type: TYPE_NORMAL
- en: If a file has permission equal to `750`, the rwx representation is `-rwxr-x---`.
    This means that others outside the designated user and group have no permission
    for the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *other* group is often referred to as *world*. For example, if permissions
    for a file are `-rw-rw-r--`, this file is referred to as *world readable* rather
    than as *other readable*. Permissions for the “other” group are especially sensitive
    because allowing write or execute permissions to files and directories to others
    (the world) can be a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll learn how to set and change file permissions using multiple methods.
  prefs: []
  type: TYPE_NORMAL
- en: Changing File Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting and changing file permissions or *modes* is a common system administrator
    task. Each file on the filesystem has permissions that allow or deny access to
    users, groups, and others. To change file permissions, you use the `chmod` (change
    mode) command. You can set or modify permissions with the `chmod` command in multiple
    ways. You don’t have to be consistent. You can use `chmod` with either numeric
    designations or the rwx and ugo designations, but you can’t combine the two in
    the same command. I demonstrate several possibilities and practical examples in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some sysadmins find the symbolic (rwx and ugo) method easier to grasp than the
    numeric (0, 1, 2, 4) method. You can use either or both methods, because they
    are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Changing permissions using the symbolic mode method is quite simple. Referring
    to the original *file.txt* file you created in a previous example, view the original
    permissions with the `ls -l` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The current file permissions aren’t adequate. You need to restrict anyone else
    but yourself from even reading this file. How do you do it? You remove the read
    permission from others. Removing is equivalent to subtraction because you are
    subtracting a permission from the current ones given to the file. So, to remove
    read permission from the file, you subtract read from others using the `chmod`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You have removed read permission from the file for others. Now, no one but you
    can read (or write to) this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a shell script and attempt to execute it with `./file.sh` but
    nothing happens, you should check the file’s permissions to see if you’ve added
    the execute permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Permission denied? But I just created the file in my home directory! Checking
    permissions reveals the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The file, *file.sh*, is named with a *.sh* extension. Recall that extensions
    have no effect in Linux and realize that *file.sh* isn’t currently executable
    because it doesn’t have the execute permission. You receive the “Permission denied”
    message when attempting to execute it. To fix the problem, add the execute permission
    for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, *file.sh* is executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can add or subtract multiple permissions from a file and even add and subtract
    permissions within the same command. Here are some examples of each action. The
    first command removes (deletes—`rm file.txt`) the file from any previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add multiple permissions to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To subtract multiple permissions from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add execute permission for all groups and remove read permission for others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be careful to explicitly define which ugo group you want to add or subtract
    permissions for. Simply supplying a `+x` or `-r` defaults to all.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t specify which groups you wish to add permissions or subtract permissions
    for, the default behavior is for the system to assume the intended group is *all*.
    This can be dangerous from a security perspective. Never grant permissions to
    all groups unless that is what you intend to do. In the following example, the
    execute permission is granted to all groups because you didn’t explicitly define
    which group should receive it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To execute an executable file or script that is not in your path, you must provide
    the explicit path to the file. If the file is in your current directory, you must
    tell the shell that it is in your current directory and that you’d like to execute
    it. Use `./script_name.sh` to inform the shell that the file is executable and
    in your current directory. Here, `script_name.sh` is the file you wish to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For clarity and comparison, the examples in this section are duplicates of the
    examples in the previous section. But here we use the numeric mode (rather than
    the symbolic mode) of changing permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file and check its permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the read permission from the other group using the numeric method. First,
    calculate the current permission value of the file and then what you want the
    new value to be. Currently, the file’s permission value is `664`. The desired
    value is `660`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the numeric method, there’s no adding or subtracting of permissions.
    You simply reassign a permission value to the file. The code shown next is a repeat
    of what you did just a page ago and is a symbolic example. You added the execute
    permission to all and subtracted the read permission from others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The numeric equivalent is to reassign the value of the original file (`664`)
    to the new one (`771`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Either method of changing permissions is perfectly acceptable; it doesn’t matter
    which method you use. Like most sysadmins, I use both methods interchangeably.
    It depends more on context and how quickly I want to do something. Changing permissions
    will become automatic to you with some practice and a few mistakes along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default Permissions Explained: umask'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might have noticed that when you create a new file, it’s created with specific
    permissions: `664` or `-rw-rw-r--`. For the root user the default permissions
    for a new file are `644` or `-rw-r--r--`. You might now wonder how this happens.
    A global setting called a `umask` (user file-creation mask) masks or filters certain
    permissions from being given to files by default. The execute permission is never
    given by default, so the `umask` setting does not explicitly mask it. To find
    out your user account’s default `umask` value, use the `umask` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You might now wonder why the `umask` reports four digits; we’ve only worked
    with three so far. The first (leftmost) digit is for special permissions such
    as `setuid`, `setgid`, and `sticky`, which I’ll cover in a later chapter. For
    now, focus only on the rightmost three digits: `002`. These three digits correspond
    to rwx permissions for user, group, and other, respectively. When you create a
    new file, certain permissions are filtered out. In the case of the `002 umask`,
    the write (`w`) permission is filtered out, so new files are created as `-rw-rw-r--`.
    The `2` is for write permission. When a new file is created, the write permission
    is masked from the “other” group and therefore isn’t given to the new file.'
  prefs: []
  type: TYPE_NORMAL
- en: For the root user, the default `umask` on my system is `0022`. The write (`w`)
    permission is masked from both group and other. The reason for a `umask` is security.
    When a regular user creates a file, you don’t want everyone else to be able to
    write to it—you must explicitly grant this permission. For the root user, the
    `umask` prevents the root group and others from writing to files by default. This
    security feature prevents daemons or programs running as root from writing to
    certain sensitive files such as the */etc/passwd* file. Everyone may read the
    file but only the root user may write to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may change your `umask` value by issuing the `umask` command and a new
    value. This temporarily changes the `umask` during your current login session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this change permanent, which you may change later, do the following
    to append the new `umask` to the end of the *.bashrc* file that resides in your
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Every time you log in, your `umask` is set to `006` or `0006` (which are equivalent)
    and yields a more secure `-rw-rw----` new default file permission.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you gained more experience working at the command line, learned
    some new commands, and perhaps more importantly, learned to read and modify file
    permissions. In [Chapter 3](ch03.xhtml#customizing_the_user_experience), you will
    learn some file editing basics and how to modify the user’s default environment.
  prefs: []
  type: TYPE_NORMAL
