- en: 'Chapter 9\. Material Views: *A Material World*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章\. 材料视图：*一个物质世界*
- en: '![image](Images/f0355-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0355-01.png)'
- en: '**Most apps need a slick UI that responds to the user.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**大多数应用程序需要一个响应用户操作的流畅用户界面。**'
- en: You’ve so far learned how to use views such as **text views, buttons and spinners**,
    and applied **Material themes** to make sweeping changes to your app’s look and
    feel. But there’s so much more you can do. Here, you’ll learn how to make your
    UI more responsive with the **coordinator layout**. You’ll create **toolbars**
    that can **collapse or scroll** on a whim. You’ll discover **exciting new views**
    such as **checkboxes**, **radio buttons**, **chips**, and **floating action buttons**.
    Finally, you’ll find out how to display friendly pop-up messages using **toasts**
    and **snackbars**. Read on to find out more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了如何使用文本视图、按钮和下拉框，并使用 Material 主题来对应用程序的外观和感觉进行全面更改。但是，您可以做的远不止这些。在这里，您将学习如何通过协调布局使您的用户界面更具响应性。您将创建可以随意折叠或滚动的工具栏。您将发现新的令人兴奋的视图，如复选框、单选按钮、标签和浮动操作按钮。最后，您将了解如何使用吐司和
    Snackbar 显示友好的弹出消息。继续阅读以了解更多信息。
- en: Material is used throughout Androidville
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material 在整个 Androidville 中被广泛使用。
- en: In the previous chapter you learned how to use toolbars, bottom navigation bars,
    and navigation drawers to help users navigate your app, and styled them using
    a theme from the Material library. As you may recall, Material is a design system
    that helps you build apps with a consistent look and feel across all screens.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您学会了如何使用工具栏、底部导航栏和导航抽屉来帮助用户导航您的应用程序，并使用 Material 库中的主题对它们进行了样式化。正如您所知，Material
    是一个设计系统，帮助您在所有屏幕上构建具有一致外观和感觉的应用程序。
- en: Material isn’t just limited to toolbars, navigation drawers, and bottom navigation
    bars; it styles every view in your app, from buttons to text views.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Material 不仅限于工具栏、导航抽屉和底部导航栏；它还为应用程序中的每个视图（从按钮到文本视图）提供了样式。
- en: 'Here are some more examples of components and features that use Material:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些使用 Material 的组件和功能的示例：
- en: '![Images](Images/star.png) **Scrolling and collapsing toolbars**'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **滚动和折叠工具栏**'
- en: You can make the toolbar scroll off the screen, or collapse, if the user scrolls
    content.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户滚动内容时，您可以使工具栏滚动到屏幕外，或者收起。
- en: '![image](Images/f0356-01.png)'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0356-01.png)'
- en: '![Images](Images/star.png) **Radio buttons, checkboxes, and chips**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **单选按钮、复选框和标签**'
- en: These let the user choose options.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些可以让用户选择选项。
- en: '![image](Images/f0356-02.png)'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0356-02.png)'
- en: '![Images](Images/star.png) **Floating action buttons (FABs)**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **浮动操作按钮（FAB）**'
- en: FABs are special buttons that float above the main screen.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FAB（Floating Action Button）是一种特殊的按钮，浮在主屏幕上方。
- en: '![image](Images/f0356-03.png)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0356-03.png)'
- en: '![Images](Images/star.png) **Snackbars**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/star.png) **Snackbar（消息栏）**'
- en: These are pop-up messages you can interact with.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是您可以与之交互的弹出消息。
- en: '![image](Images/f0356-04.png)'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0356-04.png)'
- en: We’re going to show you how to use these views and features by building a new
    app.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何通过构建一个新应用程序来使用这些视图和功能。
- en: The Bits and Pizzas app
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bits and Pizzas 应用程序
- en: We’re going to build a new app named Bits and Pizzas. We’re going to focus on
    its Create Order screen, which lets the user place an order for a pizza.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建一个名为“Bits and Pizzas”的新应用程序。我们将专注于其“创建订单”屏幕，用户可以在此屏幕上下单订购披萨。
- en: 'The screen looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕看起来像这样：
- en: '![image](Images/f0357-01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0357-01.png)'
- en: The app is comprised of an activity—`MainActivity`—that displays a fragment
    named `OrderFragment`. The fragment defines the Create Order screen’s appearance
    and functionality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序由一个名为`MainActivity`的活动组成，显示一个名为`OrderFragment`的片段。该片段定义了“创建订单”屏幕的外观和功能。
- en: Let’s go through the steps we need to take to build the app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解构建该应用程序所需的步骤。
- en: Here’s what we’ll do
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是我们将要做的事情
- en: 'We’ll build the app by going through the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤构建该应用程序：
- en: '**Add a toolbar that can scroll.**'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个可以滚动的工具栏。**'
- en: We’ll create `OrderFragment`, and add a toolbar to its layout that will scroll
    off the screen when the user scrolls the screen up, and reappear when they scroll
    down.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建`OrderFragment`，并在其布局中添加一个工具栏，当用户向上滚动屏幕时，工具栏将滚动到屏幕外，并在向下滚动时重新出现。
- en: '![image](Images/f0358-01.png)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0358-01.png)'
- en: '**Implement a collapsing toolbar.**'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现可折叠的工具栏。**'
- en: Once we’ve made the toolbar scroll, we’ll add an image to it, and get it to
    collapse and expand when the user scrolls the screen.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成工具栏的滚动后，我们将在其上添加一个图像，并使其在用户滚动屏幕时收缩和展开。
- en: '![image](Images/f0358-02.png)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0358-02.png)'
- en: '**Add views.**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加视图。**'
- en: The user needs to be able to place a pizza order. We’ll enable this by adding
    radio buttons, chips, and a floating action button to `OrderFragment`’s layout.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户需要能够下订单。我们将通过向`OrderFragment`的布局中添加单选按钮、芯片和浮动操作按钮来实现这一点。
- en: '![image](Images/f0358-03.png)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0358-03.png)'
- en: '**Make the FAB respond to clicks.**'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使FAB响应点击。**'
- en: When the user clicks the FAB, we’ll display a pop-up message that gives details
    of her order.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户点击FAB时，我们将显示一个弹出消息，提供订单的详细信息。
- en: '![image](Images/f0358-04.png)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0358-04.png)'
- en: Create the Bits and Pizzas project
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Bits and Pizzas项目
- en: '![image](Images/f0359-01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0359-01.png)'
- en: We’re going to create a new project for the Bits and Pizzas app, so you need
    to create one using the same steps from previous chapters. Choose the Empty Activity
    option, enter a name of “Bits and Pizzas” and a package name of “com.hfad.bitsandpizzas”,
    and accept the default save location. Make sure the language is set to Kotlin
    and the minimum SDK is API 21 so it will run on most Android devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为Bits and Pizzas应用创建一个新项目，您需要使用前几章相同的步骤创建一个。选择“空活动”选项，输入名称“Bits and Pizzas”和包名称“com.hfad.bitsandpizzas”，并接受默认保存位置。确保语言设置为Kotlin，最小SDK为API
    21，以便在大多数Android设备上运行。
- en: Add a Material library dependency to the app build.gradle file
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向应用的build.gradle文件添加Material库依赖项
- en: In this chapter, we’re going to use themes, views, and features from the Material
    library, so we need to make sure that the app’s *build.gradle* file includes it
    as a dependency.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Material库中的主题、视图和特性，因此需要确保应用的*build.gradle*文件包含它作为依赖项。
- en: 'Open the file *BitsandPizzas/app/build.gradle*, and make sure that its `dependencies`
    section includes the following line (in bold):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件*BitsandPizzas/app/build.gradle*，确保其`dependencies`部分包含以下行（用粗体标出）：
- en: '![image](Images/f0359-02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0359-02.png)'
- en: It’s likely that Android Studio has already added this dependency to the file
    for you. If not, you’ll need to add it yourself, and click on the Sync Now option
    that appears at the top of the code editor to sync the change with the rest of
    your project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio可能已经为您添加了此依赖项到文件中。如果没有，您需要自己添加，并点击代码编辑器顶部出现的“立即同步”选项以将更改与项目的其余部分同步。
- en: Now that you’ve made sure that the app includes the Material library, let’s
    go and create `OrderFragment`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经确保应用包含Material库，让我们去创建`OrderFragment`。
- en: Create OrderFragment
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建OrderFragment
- en: '`OrderFragment` is the Bits and Pizzas app’s main screen, and it’s what the
    user will use to place a pizza order.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderFragment`是Bits and Pizzas应用的主屏幕，用户将用它来下订单。'
- en: 'To create the fragment, highlight the *com.hfad.bitsandpizzas* package in the
    *app/src/main/java* folder, then go to File→New→Fragment→Fragment (Blank). Name
    the fragment “OrderFragment” and its layout “fragment_order”, and make sure the
    language is set to Kotlin. Then update the code for *OrderFragment.kt* to match
    the code below:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建片段，请在`app/src/main/java`文件夹中突出显示*com.hfad.bitsandpizzas*包，然后转到 文件→新建→片段→片段（空白）。将片段命名为“OrderFragment”，其布局命名为“fragment_order”，并确保语言设置为Kotlin。然后更新*OrderFragment.kt*的代码以匹配下面的代码：
- en: '![image](Images/f0360-02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0360-02.png)'
- en: 'Then update the code in its layout file *fragment_order.xml* so that it includes
    a frame layout like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新其布局文件*fragment_order.xml*的代码，使其包含如下的帧布局：
- en: '![image](Images/f0360-03.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0360-03.png)'
- en: We’ll update `OrderFragment` through the rest of this chapter. First, let’s
    display it in `MainActivity`’s layout.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其余部分更新`OrderFragment`。首先，让我们在`MainActivity`的布局中显示它。
- en: Display OrderFragment in MainActivity’s layout
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MainActivity的布局中显示OrderFragment
- en: We’ll add `OrderFragment` to `MainActivity`’s layout using a `FragmentContainerView`,
    specifying the name of the fragment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`FragmentContainerView`将`OrderFragment`添加到`MainActivity`的布局中，指定片段的名称。
- en: 'Here’s the code to do this; open *activity_main.xml* and update its code to
    include the changes below:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是要实现此功能的代码；打开*activity_main.xml*并更新其代码以包含以下更改：
- en: '![image](Images/f0361-02.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0361-02.png)'
- en: 'Finally, open *MainActivity.kt* and make sure that its code matches the code
    shown below:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开*MainActivity.kt*，确保其代码与下面显示的代码匹配：
- en: '![image](Images/f0361-03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0361-03.png)'
- en: Now that we’ve got `MainActivity` to display `OrderFragment`, let’s find out
    how to make the app bar respond to scrolls.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让`MainActivity`显示`OrderFragment`，让我们找出如何使应用栏响应滚动。
- en: Replace the default app bar with a toolbar
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用工具栏替换默认应用栏
- en: We’re going to make the Bits and Pizzas app bar respond when the user scrolls.
    For now, we’ll make it scroll off the screen when the user scrolls the screen
    up, and make it reappear when she scrolls down again.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使“Bits and Pizzas”应用栏在用户滚动时做出响应。暂时，当用户向上滚动屏幕时，我们将其滚动出屏幕，并在用户向下滚动时重新显示。
- en: '![image](Images/f0362-01.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0362-01.png)'
- en: To do this, we first need to replace the default app bar with a toolbar. This
    is because the default app bar is fixed to the top of the screen, and can’t be
    made to scroll. A toolbar, however, is much more flexible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要用工具栏替换默认的应用栏。这是因为默认的应用栏固定在屏幕顶部，无法滚动。而工具栏则灵活得多。
- en: 'To do this, we first need to change the app’s theme to one that has no app
    bar. Open the file *themes.xml* in the *app/src/main/res/values* folder, and update
    its code to include the style below in bold:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要将应用的主题更改为没有应用栏的主题。打开位于*app/src/main/res/values*文件夹中的*themes.xml*文件，并更新其代码以包含以下**粗体**样式：
- en: '![image](Images/f0362-02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0362-02.png)'
- en: If your project includes a *themes.xml* file in the *values-night* folder, you’ll
    need to apply the above change to this file as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目在*values-night*文件夹中包含一个*themes.xml*文件，您也需要对该文件应用上述更改。
- en: 'Once you’ve made this change, add a toolbar to `FragmentOrder` by updating
    the *fragment_order.xml* code so it matches the code shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此更改，请通过更新*fragment_order.xml*代码将工具栏添加到`FragmentOrder`。
- en: '![image](Images/f0362-03.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0362-03.png)'
- en: Fragments don’t have a setSupportActionBar() method
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段没有`setSupportActionBar()`方法
- en: Now that we’ve added the toolbar, we need to make it behave like a proper app
    bar that displays the app’s name. As you learned in the previous chapter, this
    is done by calling the activity’s `setSupportActionBar()` method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了工具栏，我们需要使其表现得像一个正常的应用栏，显示应用的名称。如前一章所述，可以通过调用活动的`setSupportActionBar()`方法来实现这一点。
- en: Here, we’ve added the toolbar to a fragment, and **fragments don’t include a**
    `**setSupportActionBar()**` **method**. To get around this, we’ll get a reference
    to the activity that’s displaying the fragment (using `**activity**`), cast it
    to an `AppCompatActivity` to reflect its type, and call its `setSupportActionBar()`
    method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经向片段添加了工具栏，但**片段不包括**`**setSupportActionBar()**` **方法**。为了解决这个问题，我们将获取显示片段的活动的引用（使用`**activity**`），将其强制转换为`AppCompatActivity`以反映其类型，并调用其`setSupportActionBar()`方法。
- en: 'Here’s the code to do this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成此操作的代码：
- en: '![image](Images/f0363-01.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0363-01.png)'
- en: 'Here’s the full code for *OrderFragment.kt*; update your code to include the
    changes (in bold):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是*OrderFragment.kt*的完整代码；请更新您的代码以包含以下更改（用**粗体**标出）：
- en: '![image](Images/f0363-02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0363-02.png)'
- en: We’ve added the toolbar…now what?
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们已经向片段添加了工具栏…接下来怎么做？
- en: 'We’ve now added a toolbar to `OrderFragment`’s layout so that when the app
    runs, the toolbar is displayed at the top of the screen:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向`OrderFragment`的布局中添加了一个工具栏，因此当应用运行时，工具栏将显示在屏幕顶部：
- en: '![image](Images/f0364-02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0364-02.png)'
- en: If we try and scroll the screen, however, the toolbar doesn’t move. To make
    it respond to scrolls, we need to make a few more changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试滚动屏幕，工具栏不会移动。为了使其响应滚动，我们需要进行一些额外的更改。
- en: We want the toolbar to respond to scrolls
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们希望工具栏可以响应滚动
- en: 'To make the toolbar move, we need to add more views to the fragment’s layout.
    The layout needs to follow the following structure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使工具栏移动，我们需要在片段布局中添加更多视图。布局需要遵循以下结构：
- en: '![image](Images/f0364-03.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0364-03.png)'
- en: 'The layout needs to include three things: a **coordinator layout**, an **app
    bar layout,** and a **nested scroll view**. Together, they let the toolbar respond
    when the user scrolls the screen.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 布局需要包括三个组件：一个**协调布局**，一个**应用栏布局**和一个**嵌套滚动视图**。它们共同使得工具栏可以在用户滚动屏幕时响应。
- en: Let’s find out what each one does, starting with the coordinator layout.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从协调布局开始了解每个组件的功能。
- en: The coordinator layout coordinates animations between views
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调布局用于协调不同视图之间的动画
- en: A coordinator layout is like a souped-up frame layout that’s used to coordinate
    animations between different views. It can, for example, coordinate the user scrolling
    the layout’s main content with the toolbar moving off the screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 协调布局就像是一个增强版的帧布局，用于协调不同视图之间的动画。例如，它可以协调用户滚动布局的主内容与工具栏移出屏幕的动作。
- en: 'You add a coordinator layout to your layout code like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样向布局代码中添加协调布局：
- en: '![image](Images/f0365-02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0365-02.png)'
- en: 'You need to include any views whose animations you want to coordinate in the
    coordinator layout. In the Bits and Pizzas app, for example, we want to coordinate
    two things: the user scrolling the layout’s main contents, and the toolbar scrolling
    off the screen. This means the toolbar and the screen’s main contents need to
    be included in the coordinator layout:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在协调布局中包含任何你想要协调动画的视图。例如，在Bits和Pizzas应用中，我们想要协调两件事情：用户滚动布局的主要内容，以及工具栏滚动到屏幕外。这意味着工具栏和屏幕的主要内容需要包含在协调布局中：
- en: '![image](Images/f0365-03.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0365-03.png)'
- en: '**A CoordinatorLayout allows the behavior of one view to affect the behavior
    of another.**'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**CoordinatorLayout允许一个视图的行为影响另一个视图的行为。**'
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The CoordinatorLayout is usually the root element of your layout.**'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**CoordinatorLayout通常是布局的根元素。**'
- en: Now that we know what the coordinator layout does, let’s move on to the app
    bar layout.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道协调布局的作用是什么，让我们继续看看应用栏布局。
- en: The app bar layout enables toolbar animation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用栏布局使工具栏动画化
- en: An app bar layout is a type of vertical linear layout that’s designed to work
    with app bars. It works with the coordinator layout to enable toolbar animation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用栏布局是一种设计用于与应用栏一起工作的垂直线性布局类型。它与协调布局一起工作，实现工具栏动画。
- en: 'You add an app bar layout to your code like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样在代码中添加一个应用栏布局：
- en: '![image](Images/f0366-02.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0366-02.png)'
- en: 'As you can see, the above app bar layout code includes an `android:theme` attribute
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，上面的应用栏布局代码包括一个像这样的`android:theme`属性：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This applies the specified style to the app bar layout and all of its views.
    In this example, it means that the toolbar—and anything else we add to the app
    bar layout—will be styled to use the Material theme’s app bar properties, including
    the color of its background and text.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用指定的样式到应用栏布局及其所有视图。在这个例子中，这意味着工具栏——以及我们添加到应用栏布局的任何其他内容——将使用Material主题的应用栏属性进行样式设置，包括其背景和文本的颜色。
- en: 'Great! Now your toolbar is animated and can respond to scroll events. But that’s
    not the end of the story: you also need to specify how it should respond. Let’s
    see how this is done.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你的工具栏是动画的，并且可以响应滚动事件。但这还不是故事的结束：你还需要指定它应该如何响应。让我们看看如何做到这一点。
- en: Tell the toolbar how to respond to scroll events
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉工具栏如何响应滚动事件
- en: Once you’ve added an app bar layout, you tell the toolbar how to respond to
    scrolls by adding an app:layout_scrollFlags attribute to the toolbar and assigning
    a value to it. The value specifies how the toolbar should respond to scroll events.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了一个应用栏布局，你可以通过向工具栏添加一个`app:layout_scrollFlags`属性并为其分配一个值来告诉工具栏如何响应滚动。该值指定工具栏应如何响应滚动事件。
- en: 'In the Bits and Pizzas app, we want the toolbar to scroll upward off the screen
    when the user scrolls up, and quickly return to its original position when the
    user scrolls down. We can achieve this by setting the toolbar’s `app:layout_scrollFlags`
    attribute to `"scroll|enterAlways"` using code like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bits和Pizzas应用中，当用户向上滚动时，我们希望工具栏向上滚动到屏幕外，并在用户向下滚动时快速返回到原始位置。我们可以通过将工具栏的`app:layout_scrollFlags`属性设置为`"scroll|enterAlways"`来实现这一点，代码如下：
- en: '**The toolbar MUST be inside an app bar layout in order for it to scroll. The
    app bar layout and coordinator layout work together to enable scrolling.**'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**工具栏必须位于应用栏布局内才能滚动。应用栏布局和协调布局共同工作，实现滚动。**'
- en: '![image](Images/f0367-02.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0367-02.png)'
- en: 'The line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'specifies two behaviors: `scroll` and `enterAlways`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了两种行为：`scroll`和`enterAlways`。
- en: The `scroll` value means that the view can scroll off the top of the screen
    when the user scrolls up. Without this value, the toolbar would stay pinned to
    the top of the screen and wouldn’t be able to scroll.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`scroll`值表示当用户向上滚动时，视图可以从屏幕顶部滚动出去。如果没有这个值，工具栏将保持固定在屏幕顶部，无法滚动。'
- en: The `enterAlways` value means that the toolbar quickly scrolls down to its original
    position when the user scrolls down. The toolbar would still scroll down without
    this value, but it would be much slower.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`enterAlways`值表示当用户向下滚动时，工具栏会快速滚动回原始位置。没有这个值，工具栏仍然会向下滚动，但速度会慢得多。'
- en: 'You’re almost there! There’s just one more step you need to do before we can
    get the `OrderFragment` toolbar to scroll: the **nested scroll view**.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经快完成了！在我们能让`OrderFragment`工具栏滚动之前，你只需要做最后一步：**嵌套滚动视图**。
- en: A nested scroll view makes layout content scrollable
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套滚动视图使布局内容可滚动
- en: You now need to add a **nested scroll view** so the layout’s main content can
    scroll. This kind of view works just like a normal scroll view, except that it
    enables *nested* scrolling. This is important, because the coordinator layout
    *only listens for nested scroll events*. If you use a normal scroll view in your
    layout, the toolbar won’t be able to respond when the user scrolls the screen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要添加一个**嵌套滚动视图**，以便布局的主内容可以滚动。这种视图的工作方式就像普通的滚动视图，但它支持*嵌套*滚动。这很重要，因为协调布局*只监听嵌套滚动事件*。如果在你的布局中使用普通的滚动视图，工具栏将无法在用户滚动屏幕时响应。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another view that enables nested scrolling is the recycler view. You’ll learn
    about this view in [Chapter 14](ch14.xhtml#room_databasescolon_room_with_a_view).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个支持嵌套滚动的视图是RecyclerView。你将在[第14章](ch14.xhtml#room_databasescolon_room_with_a_view)学习到关于这个视图的内容。
- en: 'You add a nested scroll view to your layout using code like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用代码向布局中添加一个嵌套滚动视图：
- en: '![image](Images/f0368-02.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0368-02.png)'
- en: In the above example, the nested scroll view includes an extra attribute named
    `app:layout_behavior`, which is set to the built-in `String` value `"@string/appbar_scrolling_view_behavior"`.
    This makes sure that the contents of the nested scroll view are arranged below
    the app bar layout, and move when it scrolls.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，嵌套滚动视图包含了一个额外的属性，名为`app:layout_behavior`，设置为内置的字符串值`"@string/appbar_scrolling_view_behavior"`。这确保了嵌套滚动视图的内容在应用栏布局下方排列，并且随着滚动而移动。
- en: Note that **a nested scroll view can only have one direct child**, which, in
    the example above, is a text view. If you want to add more than one view to a
    nested scroll view, you must first add them to a view group—such as a linear layout—and
    then add the view group to the nested scroll view.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**嵌套滚动视图只能有一个直接子元素**，在上面的示例中是一个文本视图。如果你想要将多个视图添加到嵌套滚动视图中，你必须首先将它们添加到一个视图组中，比如线性布局，然后再将视图组添加到嵌套滚动视图中。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll see an example of this later in the chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章的后面看到一个例子。
- en: That’s everything that we need to know in order to get the Bits and Pizzas toolbar
    to scroll, so let’s go ahead and update `OrderFragment`’s layout.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要知道的关于如何使Bits和Pizzas工具栏滚动的全部内容，所以让我们继续更新`OrderFragment`的布局。
- en: The full code for fragment_order.xml
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fragment_order.xml 的完整代码
- en: 'Here’s the full code for *fragment_order.xml*; update the code to include the
    changes below (in bold):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是*fragment_order.xml*的完整代码；请更新代码以包含以下更改（用粗体标出）：
- en: '![image](Images/f0369-02.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0369-02.png)'
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: '![image](Images/f0370-01.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0370-01.png)'
- en: When we run the app, `OrderFragment` is displayed in `MainActivity`’s layout.
    A toolbar is displayed at the top of the screen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用时，`OrderFragment`显示在`MainActivity`的布局中。屏幕顶部显示了一个工具栏。
- en: When we scroll the screen up, the toolbar scrolls upward off the top of the
    screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向上滚动屏幕时，工具栏向上滚动并离开屏幕顶部。
- en: '![image](Images/f0370-02.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0370-02.png)'
- en: When we scroll the main content down, the toolbar reappears.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向下滚动主内容时，工具栏重新出现。
- en: '![image](Images/f0370-03.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0370-03.png)'
- en: Congratulations! You’ve now learned how to create a toolbar that responds to
    scrolls.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经学会了如何创建一个能够响应滚动的工具栏。
- en: After the following exercise, we’re going to learn how to turn the scrolling
    toolbar into one that collapses and expands as the user scrolls the screen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习之后，我们将学习如何将滚动工具栏转换为随着用户滚动屏幕而展开和折叠的工具栏。
- en: BE the Layout
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BE the Layout
- en: '![image](Images/common04.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common04.png)'
- en: '**Below is the layout file for a fragment named MyFragment. Your job is to
    play like you’re the layout, and change the code so that when the user scrolls
    the screen up, the toolbar scrolls off the screen, and when they scroll down,
    it quickly reappears.**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下是名为MyFragment的片段的布局文件。你的任务是像是布局一样，并更改代码，使得当用户向上滚动屏幕时，工具栏从屏幕上滚动出去，当他们向下滚动时，它迅速重新出现。**'
- en: '![image](Images/f0371-01.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0371-01.png)'
- en: BE the Layout Solution
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BE the Layout Solution
- en: '![image](Images/common04.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common04.png)'
- en: '**Below is the layout file for a fragment named MyFragment. Your job is to
    play like you’re the layout, and change the code so that when the user scrolls
    the screen up, the toolbar scrolls off the screen, and when they scroll down,
    it quickly reappears.**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下是名为MyFragment的片段的布局文件。你的任务是像是布局一样，并更改代码，使得当用户向上滚动屏幕时，工具栏从屏幕上滚动出去，当他们向下滚动时，它迅速重新出现。**'
- en: '![image](Images/f0372-01.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0372-01.png)'
- en: Let’s create a collapsing toolbar
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们创建一个折叠式工具栏
- en: '![image](Images/f0373-01.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0373-01.png)'
- en: 'Now that you know how to make a toolbar scroll off the screen, let’s replace
    it with a slightly different type of toolbar: a **collapsing toolbar**.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使工具栏滚动到屏幕之外后，让我们用一个稍微不同的工具栏替换它：一个**可折叠工具栏**。
- en: 'A collapsing toolbar is a toolbar that starts off large, shrinks when the user
    scrolls the screen up, and expands again when the user scrolls the screen back
    down. You can even add an image to it, which disappears when the toolbar reaches
    its minimum height, and becomes visible again as the toolbar expands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可折叠工具栏是一种工具栏，初始时较大，在用户向上滚动屏幕时会收缩，并在用户向下滚动屏幕时再次扩展。你甚至可以向其添加一个图像，当工具栏达到最小高度时图像消失，并在工具栏扩展时再次可见：
- en: '![image](Images/f0373-02.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0373-02.png)'
- en: Over the next few pages, we’re going to find out how to turn a simple toolbar
    into a collapsing toolbar by adding one to `OrderFragment`’s layout. We’ll start
    with a plain collapsing toolbar first, and then create one that includes an image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来几页，我们将学习如何通过在`OrderFragment`的布局中添加一个简单的工具栏来将普通工具栏转换为可折叠工具栏。我们将首先创建一个简单的可折叠工具栏，然后创建一个包含图像的工具栏。
- en: Let’s get started.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: How to create a plain collapsing toolbar
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建简单的可折叠工具栏
- en: 'It’s relatively straightforward to turn a scrolling toolbar into a collapsing
    toolbar. You simply wrap the toolbar in a **collapsing toolbar layout**, and tweak
    the toolbar attributes. The basic code structure looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将滚动工具栏转换为可折叠工具栏相对简单。你只需将工具栏包裹在**可折叠工具栏布局**中，并调整工具栏的属性。基本的代码结构如下：
- en: '![image](Images/f0374-02.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0374-02.png)'
- en: 'As you can see, the collapsing toolbar layout is defined using the `<...CollapsingToolbarLayout>`
    element, part of the *com.google.android.material* library. You specify its maximum
    height using its `layout_height` attribute, and the line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可折叠工具栏布局使用`<...CollapsingToolbarLayout>`元素定义，它是*com.google.android.material*库的一部分。你可以使用其`layout_height`属性指定其最大高度，而以下这行：
- en: '![image](Images/f0374-03.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0374-03.png)'
- en: tells it to collapse when the user scrolls up until it has nothing left to collapse,
    and expand when the user scrolls down until it reaches its full height.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉它在用户向上滚动时折叠，直到没有更多内容可折叠，当用户向下滚动时扩展至其全高度。
- en: 'We also need to make sure that when the toolbar collapses, anything that’s
    displayed on the toolbar—like the Up button and any menu items—stay on the screen.
    This is achieved by adding the following attribute to the `Toolbar` element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保当工具栏折叠时，显示在工具栏上的任何内容，如返回按钮和任何菜单项都保持在屏幕上显示。通过向`Toolbar`元素添加以下属性实现：
- en: '![image](Images/f0374-04.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0374-04.png)'
- en: How to add an image to a collapsing toolbar
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将图像添加到可折叠工具栏
- en: 'Once you’ve created a plain collapsing toolbar, you can add an image to it
    by adding an <`ImageView>` to the collapsing toolbar layout, specifying the image
    you want to use. The code follows this structure:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建简单的可折叠工具栏后，你可以通过向可折叠工具栏布局添加一个<`ImageView>`，指定要使用的图像来添加图像。代码遵循以下结构：
- en: '![image](Images/f0375-02.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0375-02.png)'
- en: 'The line:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面这行：
- en: '[PRE2]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'which has been added to the `<...CollapsingToolbarLayout>` gives the toolbar
    a plain background color when it’s collapsed. We’ve also added a parallax animation
    to the image using this line:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`<...CollapsingToolbarLayout>`的这一行使工具栏在折叠时具有纯色背景。我们还使用以下代码为图像添加了视差动画：
- en: '[PRE3]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This attribute is optional: it makes the image scroll at a different rate to
    the rest of the toolbar.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性是可选的：它使图像的滚动速度与工具栏的其余部分不同步。
- en: Now that you’ve learned about collapsing toolbars, let’s add one to `OrderFragment`’s
    layout.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了可折叠工具栏，让我们将一个添加到`OrderFragment`的布局中。
- en: Add a restaurant image drawable
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加餐厅图像资源
- en: We want `OrderFragment`’s collapsing toolbar to include a restaurant image,
    so let’s start by adding it to the project.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`OrderFragment`的可折叠工具栏包含一个餐厅图像，因此让我们首先将其添加到项目中。
- en: Make sure that your project includes a folder named *app/src/main/res/drawable*,
    then download the file *restaurant.webp* from *tinyurl.com/hfad3*, and add it
    to the *drawable* folder. This includes the image in your project as a drawable
    resource.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的项目中包含名为*app/src/main/res/drawable*的文件夹，然后从*tinyurl.com/hfad3*下载*restaurant.webp*文件，并将其添加到*drawable*文件夹中。这将把图像作为可绘制资源添加到你的项目中。
- en: Next, let’s add the collapsing toolbar.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加可折叠工具栏。
- en: '![image](Images/f0376-02.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0376-02.png)'
- en: The full code for fragment_order.xml
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fragment_order.xml的完整代码
- en: 'The code below adds a collapsing toolbar to `OrderFragment`’s layout. Update
    your code for *fragment_order.xml* to include the changes (in bold):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将折叠工具栏添加到`OrderFragment`的布局中。更新你的*fragment_order.xml*代码以包含以下更改（**加粗部分**）：
- en: '![image](Images/f0376-03.png)![image](Images/f0377-02.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0376-03.png)![image](Images/f0377-02.png)'
- en: Those are all the changes that we need to create the collapsing toolbar. Let’s
    take the app for a test drive, and see what it looks like.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要创建折叠工具栏的所有更改。让我们来测试这个应用程序，看看它的样子。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: '![image](Images/f0378-01.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0378-01.png)'
- en: When we run the app, `OrderFragment` is displayed. It includes a collapsing
    toolbar with an image.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，显示`OrderFragment`。它包括一个带有图像的折叠工具栏。
- en: When we scroll up, the toolbar collapses, the image fades, and the toolbar’s
    background changes to the app’s primary color. When we scroll down, the toolbar
    expands, and the image reappears.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向上滚动时，工具栏会折叠，图像会淡化，工具栏的背景会变成应用程序的主要颜色。当我们向下滚动时，工具栏会展开，图像会重新出现。
- en: '![image](Images/f0378-02.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0378-02.png)'
- en: Layout Magnets
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局磁铁
- en: '![image](Images/common02.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common02.png)'
- en: Someone arranged some magnets on the fridge door to show how to structure a
    layout file that implements a collapsing toolbar with an image. Unfortunately,
    the magnets fell off when a large pterodactyl flew by in search of food.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有人在冰箱门上摆放了一些磁铁，以展示如何结构化实现带有图像的折叠工具栏的布局文件。不幸的是，当一只大翼龙飞过寻找食物时，磁铁掉了下来。
- en: See if you can put the magnets back in the right order.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能不能把磁铁按正确的顺序放回去。
- en: '![image](Images/f0379-01.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0379-01.png)'
- en: '![Images](Images/arr.png) **Answers in [“Layout Magnets Solution”](#layout_magnets_solution-id00147).**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在[“Layout Magnets Solution”](#layout_magnets_solution-id00147)中。**'
- en: We need to build OrderFragment’s main content
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要构建OrderFragment的主要内容
- en: 'Now that we’ve added a collapsing toolbar to `OrderFragment`’s layout, we need
    to add some more views. These will let the user choose which type of pizza she
    wants to order, add any extra options such as parmesan or chili oil, and display
    a message when she clicks a button. The screen needs to look something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`OrderFragment`的布局中添加了一个折叠工具栏，我们需要添加一些更多的视图。这些将允许用户选择她想要订购的比萨类型，添加任何额外的选项，如帕尔马干酪或辣椒油，并在她点击按钮时显示一条消息。屏幕需要看起来像这样：
- en: '![image](Images/f0380-01.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0380-01.png)'
- en: As you can see, `OrderFragment`’s layout includes some extra views that we haven’t
    yet learned how to use. Before we build the layout, let’s find out more about
    these views.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`OrderFragment`的布局包括一些我们还没有学会如何使用的额外视图。在构建布局之前，让我们更多地了解这些视图。
- en: Choose a pizza type using a radio button
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单选按钮选择比萨类型
- en: '![image](Images/f0381-01.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0381-01.png)'
- en: The first view we’ll use is a group of **radio buttons** so that the user can
    choose which type of pizza she wants. Radio buttons let you display multiple options
    from which you make a single choice, so they’re a good choice for this situation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第一个视图是一组**单选按钮**，以便用户可以选择她想要的比萨类型。单选按钮允许您从多个选项中进行选择，因此它们是这种情况下的一个很好的选择。
- en: 'You add radio buttons to a layout using two elements: `<RadioButton>` and `<RadioGroup>`.
    You use the `<RadioButton>` element to define each radio button, and you group
    them by putting them inside a `<RadioGroup>` element. Placing the radio buttons
    in a radio group in this way means that only a single radio button can be selected
    at a time.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两个元素将单选按钮添加到布局中：`<RadioButton>`和`<RadioGroup>`。使用`<RadioButton>`元素定义每个单选按钮，通过将它们放置在`<RadioGroup>`元素内进行分组。以这种方式在单选按钮中放置单选按钮意味着一次只能选择一个单选按钮。
- en: '![image](Images/f0381-02.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0381-02.png)'
- en: 'In the Bits and Pizzas app, we want to display radio buttons for the Diavolo
    and Funghi buttons. The code looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bits and Pizzas应用程序中，我们希望为Diavolo和Funghi按钮显示单选按钮。代码如下所示：
- en: '![image](Images/f0381-03.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0381-03.png)'
- en: 'Once you’ve defined the radio group and radio buttons, you can write Kotlin
    code to find out which radio button has been selected using the radio group’s
    `checkedRadioButtonId` property. Its value is the ID of the selected radio button,
    or -1 if no radio button has been selected:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了单选按钮组和单选按钮，你可以编写Kotlin代码来查找哪个单选按钮已被选中，使用单选按钮组的`checkedRadioButtonId`属性。其值是所选单选按钮的ID，如果没有选中单选按钮则为-1：
- en: '![image](Images/f0381-04.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0381-04.png)'
- en: '**RadioGroup is a subclass of LinearLayout, so you can use the same attributes
    with a radio group as you can with a linear layout.**'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**RadioGroup 是 LinearLayout 的子类，因此您可以像线性布局一样使用相同的属性与单选组。**'
- en: Radio buttons are a type of compound button
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单选按钮是一种复合按钮
- en: 'Behind the scenes, radio buttons inherit from a class named `CompoundButton`:
    a subclass of `Button`. A compound button is a button that has two states: checked
    and unchecked, or on and off.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，单选按钮继承自名为 `CompoundButton` 的类：`Button` 的子类。复合按钮是具有两种状态的按钮：选中和未选中，或者开和关。
- en: Android includes other types of compound button (in addition to radio buttons),
    such as **checkboxes**, **switches,** and **toggle buttons**. These views are
    useful if you want to offer the user yes/no choices, such as “Do you want chili
    oil?” or “Would you like extra parmesan?”
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Android 包含其他类型的复合按钮（除了单选按钮），例如**复选框**、**开关**和**切换按钮**。如果您希望向用户提供是/否选择，比如“是否要辣椒油？”或“您是否想要额外的帕尔玛干酪？”，这些视图就非常有用。
- en: '![image](Images/f0382-01.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0382-01.png)'
- en: 'You add checkboxes, switches, and toggle buttons to your layout using code
    like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码向您的布局中添加复选框、开关和切换按钮：
- en: '![image](Images/f0382-02.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0382-02.png)'
- en: 'You can then use each view’s `isChecked` property in your Kotlin code to find
    out if it has been selected, as in the example code here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在 Kotlin 代码中使用每个视图的 `isChecked` 属性来查找它是否已被选中，就像这里的示例代码一样：
- en: '![image](Images/f0382-03.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0382-03.png)'
- en: A chip is a type of flexible compound button
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 芯片是一种灵活的复合按钮类型
- en: 'So far, you’ve seen how to use different types of compound buttons such as
    radio buttons, checkboxes and switches. A more flexible type of compound button
    is a **chip**. This is a material view that’s available so long as you’re using
    a theme from the Material library, for example `Theme.MaterialComponents.DayNight.NoActionBar`.
    It’s used for making yes/no choices like other types of compound button, but it
    has other uses too: it can also be used for user input, filtering data and performing
    actions.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了如何使用不同类型的复合按钮，例如单选按钮、复选框和开关。更灵活的一种复合按钮是**芯片**。这是一种材料视图，在使用来自 Material
    库的主题时可用，例如 `Theme.MaterialComponents.DayNight.NoActionBar`。它用于像其他类型的复合按钮一样进行是/否选择，但它还有其他用途：还可以用于用户输入、数据过滤和执行操作。
- en: '![image](Images/f0383-02.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0383-02.png)'
- en: In the Bits and Pizzas app, we’re going to use chips to let the user say whether
    she wants extra parmesan or chili oil on her pizza.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bits and Pizzas 应用程序中，我们将使用芯片来让用户选择是否想要在她的比萨上加入额外的帕尔玛干酪或辣椒油。
- en: 'You add a chip to your layout using code like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码将芯片添加到您的布局中：
- en: '![image](Images/f0383-03.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0383-03.png)'
- en: 'The key part of the chip code is the `style` attribute, because this controls
    the chip’s appearance. The code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片代码的关键部分是 `style` 属性，因为它控制芯片的外观。代码：
- en: '[PRE4]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: in the above example styles the chip as a Choice so that its color changes when
    its selected. Other options are Entry (which lets you use chips for data input),
    Filter (which is used for chips that filter content), and Action (which acts like
    a button).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，样式将芯片设为选择项，因此在选择时其颜色会发生变化。其他选项包括输入（允许您使用芯片进行数据输入）、过滤器（用于过滤内容的芯片）和操作（类似按钮的芯片）。
- en: 'Here’s what the Entry, Filter, and Action chips look like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输入、过滤器和操作芯片的样子：
- en: '![image](Images/f0383-04.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0383-04.png)'
- en: As well as adding single chips to your layout, you can group several chips together.
    Let’s find out how this is done.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将单个芯片添加到布局中，您还可以将多个芯片组合在一起。让我们看看如何做到这一点。
- en: Add multiple chips to a chip group
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个芯片添加到芯片组中
- en: '![image](Images/f0384-01.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0384-01.png)'
- en: If you want your layout to include multiple chips that are grouped together,
    you can add them to a **chip group**. A chip group is a type of view group that’s
    designed to neatly arrange multiple chips.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望布局包含多个分组在一起的芯片，您可以将它们添加到**芯片组**中。芯片组是一种类型的视图组，专门设计用于整齐地排列多个芯片。
- en: 'In the Bits and Pizzas app, we want to use two chips: one for parmesan and
    another for chili oil. We’ll therefore group them in a chip group using code like
    this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bits and Pizzas 应用程序中，我们希望使用两个芯片：一个用于帕尔玛干酪，另一个用于辣椒油。因此，我们将它们组合在一个芯片组中，使用以下代码：
- en: '![image](Images/f0384-02.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0384-02.png)'
- en: Use isChecked to find out if a chip is checked
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 isChecked 来查找芯片是否被选中
- en: 'Once you’ve added chips to your layout, you can find out if a chip has been
    selected using each chip’s `isChecked` property, just as you can with other types
    of compound button such as switches, toggle buttons, and checkboxes. The following
    code, for example, checks whether the *parmesan* chip has been selected:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您向布局添加了标签，就可以使用每个标签的`isChecked`属性查找是否已选择标签，就像您可以使用其他类型的复合按钮（如开关、切换按钮和复选框）一样。例如，以下代码检查是否已选择*parmesan*标签：
- en: '[PRE5]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A FAB is a floating action button
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAB是一个浮动操作按钮
- en: 'There’s one final view we need to learn about before we can complete `OrderFragment`’s
    layout: a **FAB**.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`OrderFragment`的布局之前，我们需要了解一个**FAB**。
- en: A FAB—or **floating action button**—is a circular button that floats above the
    user interface. It’s used to draw attention to common or important actions, and
    just like a normal button, you can make a FAB respond to clicks by assigning an
    `OnClickListener` to it in your Kotlin code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: FAB或**浮动操作按钮**是一个在用户界面上方漂浮的圆形按钮。它用于吸引注意力以执行常见或重要操作，就像普通按钮一样，您可以通过在Kotlin代码中为其分配`OnClickListener`来使FAB响应点击。
- en: '![image](Images/f0385-02.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0385-02.png)'
- en: 'You add a FAB to your layout using code like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码向布局中添加一个FAB：
- en: '![image](Images/f0385-03.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0385-03.png)'
- en: The above code uses the `layout_gravity` attribute to anchor a FAB to the bottom-end
    corner of the device screen with a margin of 16dp.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用`layout_gravity`属性将FAB锚定在设备屏幕的底端角，间距为16dp。
- en: 'The line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码：
- en: '[PRE6]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: adds an icon to the FAB. In the above example, it displays one of Android’s
    built-in icons named *ic_menu_send*, but you can use any kind of drawable so long
    as it fits on the FAB.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 向FAB添加图标。在上面的示例中，它显示了一个名为*ic_menu_send*的Android内置图标，但只要它适合FAB，您可以使用任何类型的可绘制对象。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you add a src attribute to a FAB, the code editor lets you browse Android’s
    built-in icons. If you don’t like any of them, you can find lots more here: [https://material.io/resources/icons](https://material.io/resources/icons)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向FAB添加src属性时，代码编辑器会让您浏览Android的内置图标。如果您不喜欢任何图标，您可以在这里找到更多：[https://material.io/resources/icons](https://material.io/resources/icons)
- en: You usually use a FAB inside a coordinator layout so that you can coordinate
    movement between the different views in your layout. Let’s look at an example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常在协调布局中使用FAB，以便您可以协调布局中不同视图之间的移动。让我们看一个例子。
- en: You can anchor a FAB to a collapsing toolbar
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您可以将FAB锚定到折叠工具栏
- en: 'FABs are often positioned at the bottom-end corner of the screen, but you can
    also anchor one to another view such as a collapsing toolbar. When you do this,
    the FAB moves with the collapsing toolbar as it collapses and expands:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: FAB通常位于屏幕底端角，但您还可以将其锚定到另一个视图，如折叠工具栏。这样做时，FAB随着折叠工具栏的展开和折叠而移动：
- en: '![image](Images/f0386-02.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0386-02.png)'
- en: 'The layout code for this is shown below. As you can see, it uses the FAB’s
    `app:layout_anchor` and `app:layout_anchorGravity` attributes to anchor the FAB
    to the bottom end of the collapsing toolbar:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了此布局代码。正如您所见，它使用了FAB的`app:layout_anchor`和`app:layout_anchorGravity`属性，将FAB锚定在折叠工具栏的底部末端：
- en: '![image](Images/f0386-03.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0386-03.png)'
- en: Now that you’ve learned about radio buttons, chips, FABs, and other views, let’s
    build the main content for `OrderFragment`’s layout.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了单选按钮、标签、FAB等视图，让我们构建`OrderFragment`布局的主内容。
- en: We need to build OrderFragment’s layout
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要构建OrderFragment的布局
- en: 'We need to add views to `OrderFragment`’s layout so that the user can order
    a pizza type, and request any extras. The layout needs to look like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向`OrderFragment`的布局中添加视图，以便用户可以订购比萨类型，并请求任何额外内容。布局需要看起来像这样：
- en: '![image](Images/f0387-02.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0387-02.png)'
- en: You’re already familiar with all the code that’s needed to create this layout,
    so let’s go and update *fragment_order.xml*. We’ll show you the full code over
    the next few pages.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉创建此布局所需的所有代码，现在让我们来更新*fragment_order.xml*。我们将在接下来的几页中展示完整的代码。
- en: The full code for fragment_order.xml
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fragment_order.xml的完整代码
- en: 'Here’s the complete code for `OrderFragment`’s layout. Update the code for
    file *fragment_order.xml* so that it includes the changes below (in bold):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`OrderFragment`的完整布局代码。更新文件*fragment_order.xml*的代码以包括以下更改（用粗体标记）：
- en: '![image](Images/f0388-02.png)![image](Images/f0389-02.png)![image](Images/f0390-02.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0388-02.png)![image](Images/f0389-02.png)![image](Images/f0390-02.png)'
- en: That’s all the layout code we need, so let’s take the app for a test drive and
    see what it looks like.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所需的所有布局代码，让我们进行应用程序的测试驱动，看看它的外观。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) Test Drive'
- en: '![image](Images/f0391-01.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0391-01.png)'
- en: When we run the app, `OrderFragment` is displayed in `MainActivity`. It includes
    a collapsing toolbar as before, but this time the main content features text views,
    radio buttons, chips, and a FAB.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，`OrderFragment`将显示在`MainActivity`中。与以前一样，它包括一个折叠的工具栏，但这次主要内容包含文本视图、单选按钮、标签和FAB。
- en: When we scroll the device screen, the main content scrolls upward and the toolbar
    collapses. The FAB remains fixed in the bottom-end corner of the screen.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们滚动设备屏幕时，主要内容向上滚动，工具栏会折叠。FAB保持固定在屏幕的右下角。
- en: '![image](Images/f0391-02.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0391-02.png)'
- en: Let’s make the FAB respond to clicks
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们让FAB响应点击
- en: '![image](Images/f0392-01.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0392-01.png)'
- en: We’ve now built `OrderFragment`’s layout, but when the user clicks on the FAB,
    nothing happens. Let’s update the fragment’s Kotlin code so that the FAB responds
    to clicks.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了`OrderFragment`的布局，但是当用户点击FAB时什么都不会发生。让我们更新片段的Kotlin代码，使FAB响应点击。
- en: 'We’ll make the FAB do two things:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让FAB执行两项任务：
- en: '**Display a message if no pizza has been chosen.**'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果尚未选择比萨，请显示一条消息。**'
- en: We need the user to select which type of pizza she wants. If she clicks the
    FAB *without* choosing one, we’ll display a pop-up message (called a **toast**)
    telling them to choose a pizza.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要用户选择她想要的比萨种类。如果她在未选择任何选项的情况下点击FAB，我们将显示一个名为**toast**的弹出消息提示她选择比萨。
- en: '![image](Images/f0392-02.png)'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0392-02.png)'
- en: '**Display their order in a separate message.**'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在单独的消息中显示它们的顺序。**'
- en: If the user has selected a type of pizza, we’ll display a message telling them
    what she has ordered. We’ll use a different type of pop-up message for this called
    a **snackbar**.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果用户已选择比萨种类，我们将显示一条消息告诉她她已下单。我们将使用一种名为**snackbar**的不同类型的弹出消息。
- en: Note
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the real world, you’d want the app to place the pizza order when the user
    clicks on the FAB. Here, we just want to make the FAB do something (and it’s a
    good excuse for teaching you about pop-up messages).
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在现实世界中，您可能希望在用户点击FAB时下订单。在这里，我们只是想让FAB做一些事情（同时也是教授您弹出消息的好借口）。
- en: '![image](Images/f0392-04.png)'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0392-04.png)'
- en: Let’s begin by making the FAB respond to clicks.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始让FAB响应点击。
- en: Add an OnClickListener to the FAB
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给FAB添加OnClickListener
- en: '![image](Images/f0393-01.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0393-01.png)'
- en: 'As we said earlier, you make a FAB respond to clicks in the same way that you
    make any other type of button respond to clicks: by attaching an `OnClickListener`
    to the FAB.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，你可以让FAB响应点击，方法与其他任何类型的按钮相同：将`OnClickListener`附加到FAB上。
- en: 'Here’s the code to add an `OnClickListener` to the FAB in `OrderFragment`;
    as you can see, it looks the same as the code you’ve used with plain old normal
    buttons:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`OrderFragment`中为FAB添加`OnClickListener`的代码；如你所见，它与你用于普通按钮的代码看起来一样：
- en: '![image](Images/f0393-02.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0393-02.png)'
- en: Next, let’s get the `OnClickListener` to display a message if the user hasn’t
    selected a type of pizza.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们获取`OnClickListener`，如果用户尚未选择比萨种类，则显示一条消息。
- en: Find out if a pizza type has been selected
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看用户是否已选择比萨种类
- en: We can find out whether the user has selected a pizza type using the `checkedRadioButtonId`
    property of the `pizzas_group` radio group. The property’s value is the ID of
    the selected radio button if one has been selected, and -1 if the user hasn’t
    made a choice.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pizzas_group`单选组的`checkedRadioButtonId`属性来查看用户是否已选择比萨种类。该属性的值是所选单选按钮的ID（如果已选择），如果用户尚未做出选择，则为-1。
- en: 'Here’s the code to check whether the user has clicked the FAB without choosing
    which type of pizza she wants:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用来检查用户是否在未选择她想要的比萨种类的情况下点击FAB的代码：
- en: '![image](Images/f0393-03.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0393-03.png)'
- en: If the user hasn’t selected a type of pizza, we want to display a message in
    a pop-up message called a **toast**. Let’s find out how to do this.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未选择比萨种类，我们希望在名为**toast**的弹出消息中显示一条消息。让我们找出如何做到这一点。
- en: A toast is a simple pop-up message
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个toast是一个简单的弹出消息
- en: 'If the user clicks on the FAB without first choosing a pizza type, we’re going
    to display a toast on the device screen. A toast is a simple pop-up message that
    gives the user information, and automatically disappears when it times out:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在未选择披萨类型的情况下点击了 FAB，我们将在设备屏幕上显示一个 toast。Toast 是一种简单的弹出消息，向用户提供信息，并在超时时自动消失：
- en: '![image](Images/f0394-02.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0394-02.png)'
- en: 'You create a toast by calling `Toast.makeText()`. The `makeText` method takes
    three parameters: a `Context` (usually `this` or `activity`, depending on whether
    you’re calling the toast from an activity or a fragment), a `CharSequence!` that’s
    the message you want to display, and a duration. You then call the toast’s `show()`
    method to display it.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Toast.makeText()` 来创建一个 toast。`makeText` 方法接受三个参数：`Context`（通常是 `this` 或
    `activity`，取决于您是从活动还是片段调用 toast），要显示的消息 `CharSequence!`，以及持续时间。然后调用 toast 的 `show()`
    方法来显示它。
- en: 'Here’s some example code that displays a message in a toast that appears on
    screen for a short duration:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些示例代码，用于在屏幕上显示一个短暂出现的 toast 消息：
- en: '![image](Images/f0394-03.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0394-03.png)'
- en: Add a toast to the FAB OnClickListener
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 toast 添加到 FAB 的 OnClickListener
- en: 'We want to display a toast when the user clicks on the FAB without choosing
    a pizza type. The code to do this is shown below:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在未选择披萨类型的情况下点击 FAB，我们将显示一个 toast。以下是实现此功能的代码：
- en: '![image](Images/f0394-04.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0394-04.png)'
- en: That’s everything we need to do if the user hasn’t selected a pizza type. Next,
    let’s write the code to display their order.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未选择披萨类型，这是我们需要做的所有事情。接下来，让我们编写代码来显示他们的订单。
- en: Display the pizza order in a snackbar
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 snackbar 中显示披萨订单
- en: If the user has chosen a pizza type, we’re going to display their order in a
    pop-up message called a **snackbar** when she clicks on the FAB. A snackbar is
    like a toast, except that it’s more interactive. You can swipe a snackbar away,
    for example, or make it do something if it’s clicked.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已选择了披萨类型，当她点击 FAB 时，我们将在一个称为**snackbar**的弹出消息中显示他们的订单。Snackbar 类似于 toast，但更具交互性。例如，您可以滑动
    snackbar 将其移除，或者在点击时执行某些操作。
- en: 'You create a snackbar by calling `Snackbar.make()`. The `make` method takes
    three parameters: the `View` that triggered the snackbar (in this case a FAB),
    a `CharSequence!` that’s the text you want to display, and a duration. You then
    display the snackbar by calling its `show()` method.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Snackbar.make()` 来创建一个 snackbar。`make` 方法接受三个参数：触发 snackbar 的 `View`（在本例中是
    FAB），要显示的文本 `CharSequence!`，以及持续时间。然后调用 `show()` 方法显示 snackbar。
- en: '![image](Images/f0395-02.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0395-02.png)'
- en: 'Here’s some example snackbar code that displays a message on the screen for
    a short time:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些示例 snackbar 代码，用于在屏幕上显示短时间的消息：
- en: '![image](Images/f0395-03.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0395-03.png)'
- en: In the above code, we’ve used `LENGTH_SHORT` to show the snackbar for a short
    period of time. Other options are `LENGTH_LONG` (which shows it for a long duration)
    and `LENGTH_INDEFINITE` (which shows it indefinitely).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了 `LENGTH_SHORT` 来短暂显示 snackbar。其他选项包括 `LENGTH_LONG`（长时间显示）和 `LENGTH_INDEFINITE`（无限期显示）。
- en: Snackbars can have actions
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snackbars 可以包含操作
- en: 'If you want, you can add an action to the snackbar so that the user can, say,
    undo an action she’s just performed. You do this by calling the snackbar’s `setAction()`
    method before calling `show()`. `setAction` takes two parameters: the text that
    should appear for the action, and a lambda that runs when the user clicks on the
    action.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望，您可以在 snackbar 中添加一个操作，以便用户可以撤消刚刚执行的操作。在调用 `show()` 之前，通过调用 snackbar 的 `setAction()`
    方法来实现这一点。`setAction` 接受两个参数：操作的文本以及用户点击操作时运行的 lambda 表达式。
- en: 'Here’s an example of some snackbar code that includes an action:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含操作的 snackbar 代码示例：
- en: '![image](Images/f0395-04.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0395-04.png)'
- en: 'Snackbars are usually displayed at the bottom of the screen, but you can override
    this using the snackbar’s `setAnchorView()` method. This anchors the snackbar
    to a particular view so that the snackbar appears above it. This is useful if,
    for example, you want the snackbar to appear above a bottom navigation bar:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Snackbars 通常显示在屏幕底部，但您可以使用 snackbar 的 `setAnchorView()` 方法覆盖此设置。这将 snackbar
    锚定到特定视图，使其显示在该视图上方。例如，如果您希望 snackbar 出现在底部导航栏上方，这将非常有用：
- en: '![image](Images/f0395-05.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0395-05.png)'
- en: The snackbar code for the pizza order
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于披萨订单的 snackbar 代码
- en: Now that you know how to create a snackbar, let’s write the code to display
    the user’s pizza order. We’ll show a snackbar that displays the pizza type the
    user has selected, along with any extras such as parmesan or chili oil.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建 Snackbar 了，让我们写代码来显示用户的披萨订单。我们将显示一个 Snackbar，显示用户选择的披萨类型，以及如帕尔马干酪或辣椒油等任何额外内容。
- en: '![image](Images/f0396-01.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0396-01.png)'
- en: 'Here’s the code to display the snackbar:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示 Snackbar 的代码：
- en: '![image](Images/f0396-02.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0396-02.png)'
- en: That’s all the Kotlin code we need for the Bits and Pizzas app. Let’s look at
    the full code for *OrderFragment.kt* and take the app for a test drive.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Bits 和 Pizzas 应用所需的所有 Kotlin 代码。让我们看看完整的 *OrderFragment.kt* 代码，并测试一下这个应用。
- en: The full code for OrderFragment.kt
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的 *OrderFragment.kt* 代码如下
- en: 'Here’s the full code for *OrderFragment.kt*; update the code to include the
    changes below (in bold):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *OrderFragment.kt* 的完整代码；更新代码以包含以下更改（以粗体显示）：
- en: '![image](Images/f0397-02.png)![image](Images/f0398-01.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0397-02.png)![图片](Images/f0398-01.png)'
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![图片](Images/car.png) 测试驱动'
- en: When we click on the FAB without selecting a pizza type, a toast is displayed
    asking us to choose a pizza.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击 FAB 而没有选择披萨类型时，会显示一个提示框，要求我们选择披萨。
- en: When we select a pizza type and click on the FAB again, a snackbar appears at
    the bottom of the screen giving details of our order.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择披萨类型并再次点击 FAB 时，屏幕底部会出现一个 Snackbar，显示我们订单的详细信息。
- en: '![image](Images/f0398-02.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0398-02.png)'
- en: Congratulations! You’ve now learned how to make the FAB respond to clicks by
    displaying a pop-up message.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在学会了通过显示弹出消息来响应 FAB 的点击。
- en: Pool Puzzle
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](Images/common01.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common01.png)'
- en: Your **goal** is to complete the fragment code below so that when a FAB with
    an ID of `fab` is clicked, it displays a snackbar. The snackbar should include
    an action, “Undo”, which shows a toast when clicked. Take code snippets from the
    pool and place them into the blank lines in the code. You may **not** use the
    same snippet more than once, and you won’t need to use all the snippets.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**目标**是完成下面片段代码，这样当点击 ID 为 `fab` 的 FAB 时，它会显示一个 Snackbar。Snackbar 应包含一个“撤销”操作，点击后会显示一个提示框。从池中选取代码片段填入空白行中。每个片段只能使用一次，并且不需要使用所有片段。
- en: '[PRE7]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![image](Images/f0399-01.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0399-01.png)'
- en: Note
  id: totrans-333
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note: each thing from the pool can only be used once!**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个池中的内容只能使用一次！**'
- en: Pool Puzzle Solution
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题解答
- en: '![image](Images/common01.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common01.png)'
- en: Your **goal** is to complete the fragment code below so that when a FAB with
    an ID of `fab` is clicked, it displays a snackbar. The snackbar should include
    an action, “Undo”, which shows a toast when clicked. Take code snippets from the
    pool and place them into the blank lines in the code. You may **not** use the
    same snippet more than once, and you won’t need to use all the snippets.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**目标**是完成下面片段代码，这样当点击 ID 为 `fab` 的 FAB 时，它会显示一个 Snackbar。Snackbar 应包含一个“撤销”操作，点击后会显示一个提示框。从池中选取代码片段填入空白行中。每个片段只能使用一次，并且不需要使用所有片段。
- en: '![image](Images/f0400-01.png)![image](Images/f0400-02.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0400-01.png)![图片](Images/f0400-02.png)'
- en: Layout Magnets Solution
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局磁铁解答
- en: '![image](Images/common02.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common02.png)'
- en: Someone arranged some magnets on the fridge door to show how to structure a
    layout file that implements a collapsing toolbar with an image. Unfortunately,
    the magnets fell off when a large pterodactyl flew by in search of food.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有人在冰箱门上排列了一些磁铁，展示了如何制作一个带有图片的折叠工具栏布局文件。不幸的是，当一只大翼龙飞过寻找食物时，磁铁掉了下来。
- en: See if you can put the magnets back in the right order.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能不能把磁铁放回正确的顺序。
- en: '![image](Images/f0401-01.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0401-01.png)'
- en: Your Android Toolbox
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的 Android 工具箱
- en: '![image](Images/tools.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/tools.png)'
- en: '**You’ve got [Chapter 9](#material_viewscolon_a_material_world) under your
    belt and now you’ve added more views and components to your toolbox.**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**你已经掌握了[第 9 章](#material_viewscolon_a_material_world)，现在你已经为工具箱增加了更多视图和组件。**'
- en: '![image](Images/f0402-01.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0402-01.png)'
