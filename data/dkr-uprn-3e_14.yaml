- en: Chapter 13\. Container Platform Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 容器平台设计
- en: When implementing any technology in production, you’ll often gain the most mileage
    by designing a resilient platform that can withstand the unexpected issues that
    will inevitably occur. Docker can be a powerful tool but requires attention to
    detail to get the whole platform right around it. As a technology that is going
    through very rapid growth, it is bound to produce frustrating bugs that crop up
    between the various components that make up your container platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在将任何技术投入生产时，通过设计一个能够抵御不可避免出现的意外问题的弹性平台，您通常可以最大化技术的应用价值。Docker 可以是一个强大的工具，但需要对整个平台的细节进行关注。作为一个正在经历快速增长的技术，它很可能在构成您的容器平台的各个组件之间产生令人沮丧的错误。
- en: If instead of simply deploying Docker into your existing environment, you take
    the time to build a well-designed container platform utilizing Docker as one of
    the core components, you can enjoy the many benefits of a container-based workflow
    while simultaneously protecting yourself from some of the sharper edges that can
    exist in such high-velocity projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不仅仅是将 Docker 部署到现有环境中，而是花时间构建一个以 Docker 作为核心组件之一的精心设计的容器平台，您可以享受基于容器的工作流程的诸多好处，同时保护自己免受在这种高速项目中可能存在的某些尖锐边缘的影响。
- en: Like all other technology, Docker doesn’t magically solve all your problems.
    To reach its true potential, organizations must make very conscious decisions
    about why and how to use it. For small projects, it is possible to use Docker
    in a simple manner; however, if you plan to support a large project that can scale
    with demand, it’s crucial that you design your applications and the platform very
    deliberately. This ensures that you can maximize the return on your investment
    in the technology. Taking the time to intentionally design your platform will
    also make it much easier to modify your production workflow over time. A well-designed
    container platform and deployment process will be as lightweight and straightforward
    as possible while still supporting the features required to meet all the technical
    and compliance requirements. A well-thought-out design will help ensure that your
    software is running on a dynamic foundation that can easily be upgraded as technology
    and company processes develop.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有其他技术一样，Docker 并不能神奇地解决所有问题。要实现其真正的潜力，组织必须对何时以及如何使用它做出非常慎重的决策。对于小项目来说，可以简单地使用
    Docker；然而，如果您计划支持一个能够按需扩展的大型项目，那么设计应用程序和平台非常关键。这确保您可以最大化对技术投资的回报。花时间有意识地设计您的平台，还将使您能够随着时间的推移轻松修改生产工作流程。一个精心设计的容器平台和部署流程将尽可能地简单明了，同时仍支持满足所有技术和合规要求的必要功能。经过深思熟虑的设计将有助于确保您的软件运行在一个能够轻松升级的动态基础上，以适应技术和公司流程的发展。
- en: In this chapter, we will explore two open documents, [“The Twelve-Factor App”](https://12factor.net)
    and [“The Reactive Manifesto”](https://www.reactivemanifesto.org) (a companion
    document to [“The Reactive Principles”](https://www.reactiveprinciples.org)),
    and discuss how they relate to Docker and building robust container platforms.
    Both documents contain a lot of ideas that should help guide you through the design
    and implementation of your container platform and ensure more resiliency and supportability
    across the board.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨两个开放文档，[“十二要素应用”](https://12factor.net) 和 [“反应式宣言”](https://www.reactivemanifesto.org)（作为
    [“反应式原则”](https://www.reactiveprinciples.org) 的附属文档），并讨论它们与 Docker 及构建健壮容器平台的关系。这两个文档包含了许多思想，应该帮助您设计和实施容器平台，并确保更多的弹性和可支持性。
- en: The Twelve-Factor App
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: In November of 2011, well before the release of Docker, Heroku cofounder Adam
    Wiggins and his colleagues released an article called [“The Twelve-Factor App”](https://12factor.net).
    This document describes a series of 12 practices, distilled from the experiences
    of the [Heroku](https://www.heroku.com) engineers, for designing applications
    that will thrive and grow in a modern container-based SaaS environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 发布之前的2011年11月，Heroku 的联合创始人亚当·威金斯及其同事发布了一篇名为 [“十二要素应用”](https://12factor.net)
    的文章。该文档从 [Heroku](https://www.heroku.com) 工程师的经验中提炼出了一系列12个实践，用于设计能够在现代基于容器的SaaS环境中蓬勃发展的应用程序。
- en: 'Although not required, applications built with these 12 steps in mind are ideal
    candidates for the Docker workflow. Throughout this chapter, we will explore each
    of the following steps and explain why these practices can, in numerous ways,
    help improve your development cycle:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但是以这12个步骤为基础构建的应用程序是Docker工作流的理想候选者。在本章中，我们将探讨以下每个步骤，并解释为什么这些做法可以在多方面帮助改进您的开发周期：
- en: Codebase
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库
- en: Dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系
- en: Config
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Backing services
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后备服务
- en: Build, release, run
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建、发布、运行
- en: Processes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程
- en: Port binding
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口绑定
- en: Concurrency
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发性
- en: Disposability
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可处置
- en: Development/production parity
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发/生产一致性
- en: Logs
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志
- en: Admin processes
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理流程
- en: Codebase
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码库
- en: '*One codebase tracked in revision control.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个代码库由版本控制跟踪。*'
- en: Many instances of your application will be running at any given time, but they
    should all come from the same code repository. Every single Docker image for a
    given application should be built from a single source code repository that contains
    all the code required to build the Linux container. This ensures that the code
    can easily be rebuilt and that all third-party requirements are well-defined within
    the repository and will automatically be pulled in during a build.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时间可能会有多个应用程序实例在运行，但它们都应该来自同一个代码仓库。给定应用程序的每个Docker镜像都应该由一个单一的源代码仓库构建，该仓库包含构建Linux容器所需的所有代码。这确保了代码可以轻松重建，并且所有第三方要求在仓库中都有明确定义，并且在构建过程中将自动拉取。
- en: What this means is that building your application shouldn’t require stitching
    together code from multiple source repositories. That is not to say that you can’t
    have a dependency on an artifact from another repo. But it does mean that there
    should be a clear mechanism for determining which pieces of code were shipped
    when you built your application. Docker’s ability to simplify dependency management
    is much less useful if building your application requires pulling down multiple
    source code repositories and stitching pieces together. It also is not very repeatable
    if you must know a magic incantation to get the build to work correctly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着构建应用程序不应该需要从多个源代码库中拼凑代码。这并不意味着你不能依赖来自另一个仓库的构件。但是这意味着应该有一个清晰的机制来确定在构建应用程序时哪些代码片段已经被包含进去了。如果构建应用程序需要拉取多个源代码库并将这些片段拼凑在一起，那么Docker简化依赖管理的能力就显得不太有用。如果你必须知道一个魔法咒语才能让构建正确工作，那么它也不太可重复。
- en: A good test might be to give a new developer in your company a clean laptop
    and a paragraph of directions and then see if they can successfully build your
    application in under an hour. If they can’t, then the process probably needs to
    be refined and simplified.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的测试可能是给你公司的新开发者一台干净的笔记本电脑和一段说明文字，然后看看他们是否能在一个小时内成功构建你的应用程序。如果不能，那么这个流程可能需要进一步优化和简化。
- en: Dependencies
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖关系
- en: '*Explicitly declare and isolate dependencies*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*明确声明和隔离依赖项*。'
- en: Never rely on the belief that a dependency will be made available via some other
    avenue, like the operating system install. Any dependencies that your application
    requires should be well defined in the codebase and pulled in by the build process.
    This will help ensure that your application will run when deployed, without relying
    on libraries being installed by other people or processes. This is particularly
    important within a container since the container’s processes are isolated from
    the rest of the host operating system and will usually not have access to anything
    outside of the host’s kernel and the container image’s filesystem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要依赖于某种依赖项将通过其他途径（如操作系统安装）提供。你的应用程序需要的任何依赖项应该在代码库中被明确定义，并且由构建过程拉取。这将有助于确保你的应用程序在部署时能够运行，而不依赖于其他人或过程安装的库。这在容器内尤为重要，因为容器的进程与主机操作系统的其余部分隔离，并且通常无法访问主机的内核和容器镜像的文件系统之外的任何内容。
- en: The *Dockerfile* and language-dependent configuration files like Node’s *package.json*
    or Ruby’s *Gemfile* should define every nonexternal dependency required by your
    application. This ensures that your image will run correctly on any system to
    which it is deployed. Gone will be the days when you try to deploy and run your
    application in production only to find out that important libraries are missing
    or installed with the wrong version. This pattern has huge reliability and repeatability
    advantages and very positive ramifications for system security. If to fix a security
    issue, you update the OpenSSL or *libyaml* libraries that your containerized application
    uses, then you can be assured that it will always be running with that version
    wherever you deploy that particular application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile* 和类似 Node 的 *package.json* 或 Ruby 的 *Gemfile* 这样的语言相关配置文件应定义应用程序所需的每一个非外部依赖项。这确保了你的镜像能在部署到任何系统时正确运行。不再出现你尝试在生产环境中部署和运行应用程序，却发现重要的库缺失或安装的版本错误的情况。这种模式具有极大的可靠性和可重复性优势，并对系统安全性有非常积极的影响。如果为了修复安全问题，你更新了容器化应用程序所使用的
    OpenSSL 或 *libyaml* 库，那么可以确保无论在哪里部署该特定应用程序，它始终会使用该版本运行。'
- en: It is also important to note that many Docker base images are larger than they
    need to be. Remember that your application process will be running on a shared
    kernel, and the only files that you need inside your image are the ones that the
    process will require to run. It’s good that base images are so readily available,
    but they can sometimes mask hidden dependencies. Although people often start with
    a minimal install of Alpine, Ubuntu, or Fedora, these images still contain a lot
    of operating system files and applications that your process almost certainly
    does not need, or possibly some files that your application is making use of that
    you aren’t consciously aware of, like compiling your application using the *musl*
    system library in Alpine versus the *glibc* system library in many other base
    images. You need to be fully aware of your dependencies, even when containerizing
    your application. It is also important to consider what support tools, if any,
    you are including in your images, as there can be a fine line between making things
    easier to debug and increasing the security attack surface of your application
    and environments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，许多 Docker 基础镜像比它们实际需要的要大。记住，你的应用程序进程将在共享内核上运行，你镜像中唯一需要的文件是进程运行所需的那些文件。基础镜像如此易于获取固然是好事，但有时可能掩盖了隐藏的依赖关系。尽管人们经常从
    Alpine、Ubuntu 或 Fedora 的最小安装开始，这些镜像仍包含大量操作系统文件和你的进程几乎肯定不需要的应用程序，或者你的应用程序可能在使用一些你没有意识到的文件，例如在
    Alpine 中使用 *musl* 系统库与其他许多基础镜像中使用的 *glibc* 系统库来编译你的应用程序。即使在容器化你的应用程序时，你也需要充分了解你的依赖关系。此外，还要考虑在你的镜像中是否包含了哪些支持工具，因为在使调试变得更加简单的同时，也可能增加你的应用程序和环境的安全攻击面。
- en: A good way to shed light on what files are required inside an image is to compare
    a “small” base image with an image for a statically linked program written in
    a language like Go or C. These applications can be designed to run directly on
    the Linux kernel without any additional libraries or files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理清镜像内所需文件的一个好方法是比较“小型”基础镜像与使用像 Go 或 C 这样的语言编写的静态链接程序镜像。这些应用程序可以设计为直接在 Linux
    内核上运行，而不需要任何额外的库或文件。
- en: To help drive this point home, it might be useful to review the exercises in
    [“Keeping Images Small”](ch04.html#small_images), where we explored one of these
    ultra-light containers, `spkane/scratch-helloworld`, and then dived into the underlying
    filesystem a bit and compared it with the popular `alpine` base image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地阐明这一点，回顾一下 [“Keeping Images Small”](ch04.html#small_images) 中的练习可能会有所帮助，我们在那里探讨了一个这样的超轻量级容器
    `spkane/scratch-helloworld`，然后稍微深入地研究了底层文件系统，并将其与流行的 `alpine` 基础镜像进行了比较。
- en: In addition to being conscientious about how you manage the filesystem layers
    in your images, keeping your images stripped down to the bare necessities is another
    great way to keep everything streamlined and your `docker image pull` commands
    fast. Applications written with interpreted languages will require many more files
    because of the large runtimes and dependency graphs you often need to install,
    but you should try to keep as minimal a base layer as needed for your use case
    so that you can reason about your dependencies. Docker helps you package them
    up, but you still need to be in charge of reasoning about them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注意如何管理镜像中的文件系统层，保持镜像仅包含最基本的必需品也是保持一切简洁并且快速执行`docker image pull`命令的另一种好方法。使用解释性语言编写的应用程序将需要更多文件，因为通常需要安装大型运行时和依赖图，但是您应尽量保持最小化的基础层以便为您的用例进行推理。Docker帮助您打包它们，但仍然需要您负责推理它们。
- en: Config
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: '*Store configuration in environment variables, not in files checked into the
    codebase.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*将配置存储在环境变量中，而不是检入代码库的文件中。*'
- en: This makes it simple to deploy the same codebase to different environments,
    like staging and production, without maintaining complicated configuration in
    code or rebuilding your container for each environment. This keeps your codebase
    much cleaner by keeping environment-specific information like database names and
    passwords out of your source code repository. More importantly, though, it means
    that you don’t bake deployment environment assumptions into the repository, and
    thus it is extremely easy to deploy your applications anywhere that it might be
    useful. You also want to be able to test the same image you will ship to production.
    You can’t do that if you have to build an image for each environment with all
    of its configuration already baked in.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在不同环境（如测试和生产）中部署相同的代码库变得非常简单，而无需在代码中维护复杂的配置或为每个环境重新构建容器。通过将像数据库名称和密码等特定于环境的信息保持在源代码库之外，可以使代码库更加干净。更重要的是，这意味着您不会将部署环境的假设编码到存储库中，因此可以非常轻松地将应用程序部署到任何可能有用的地方。您还希望能够测试将要发布到生产环境的相同镜像。如果您必须为每个环境构建已经烘焙好了所有配置的镜像，那么这是做不到的。
- en: As discussed in [Chapter 4](ch04.html#docker_images), you can achieve this by
    launching `docker container run` commands that leverage the `-e` command-line
    argument. Using `-e APP_ENV=` `*production*` tells Docker to set the environment
    variable `APP_ENV` to the value `production` within the newly launched container.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第四章](ch04.html#docker_images)所讨论的，您可以通过启动使用`-e`命令行参数的`docker container run`命令来实现这一点。使用`-e
    APP_ENV=` `*production*`告诉Docker在新启动的容器内将环境变量`APP_ENV`设置为值`production`。
- en: 'For a real-world example, let’s assume we pulled the image for the chat robot
    Hubot with the [Rocket.Chat](https://www.rocket.chat) adapter installed. We’d
    issue something like the following command to get it running:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 举个实际例子，假设我们拉取了安装了[Rocket.Chat](https://www.rocket.chat)适配器的聊天机器人Hubot的镜像。我们会发出以下类似的命令来让它运行：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we are passing a whole set of environment variables into the container
    when it is created. When the process is launched in the container, it will have
    access to these environment variables so that it can properly configure itself
    at runtime. These configuration items are now an external dependency that we can
    inject at runtime.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在创建容器时传递了一整套环境变量。当进程在容器中启动时，它将访问这些环境变量，以便在运行时正确配置自身。这些配置项现在是一个可以在运行时注入的外部依赖项。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are many other ways to provide this data to a container, including using
    key/value stores like `etcd` and `consul`. Environment variables are simply a
    universal option that acts as a very good starting point for most projects. They
    are the easy path for container configuration because they are well supported
    by the platform and every programming language in common use. They also aid in
    the observability of your applications because the configuration can easily be
    inspected with `docker container inspect`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数据提供给容器的其他方式还有很多，包括使用像`etcd`和`consul`这样的键值存储。环境变量只是一个作为大多数项目非常好的起点的通用选项。它们是容器配置的简单途径，因为它们得到了平台和所有常用编程语言的广泛支持。它们还有助于应用程序的可观察性，因为可以轻松地使用`docker
    container inspect`来检查配置。
- en: 'In the case of a Node.js application like `hubot`, you could then write the
    following code to make decisions based on these environment variables:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 `hubot` 这样的 Node.js 应用程序，您可以编写以下代码，根据这些环境变量做出决策：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The exact method used to pass this configuration data into your container will
    vary depending on the specific tooling that you’ve chosen for your projects, but
    almost all of them will make it easy to ensure that every deployment contains
    the proper settings for that environment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将配置数据传递到容器中的确切方法将因您为项目选择的具体工具而异，但几乎所有工具都会轻松确保每次部署包含该环境的正确设置。
- en: Keeping specific configuration information out of your source code makes it
    very easy to deploy the exact same container to multiple environments, with no
    changes and no sensitive information committed into your source code repository.
    Crucially, it supports testing your container images thoroughly before deploying
    to production by allowing the same image to be used in all environments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将特定配置信息从源代码中分离出来，可以轻松地在多个环境中部署完全相同的容器，无需修改，也无需将敏感信息提交到源代码库中。关键是，在部署到生产环境之前，通过允许在所有环境中使用相同的镜像来彻底测试容器映像。
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you need a process for managing secrets that need to be provided to your
    containers, you might want to look into the [documentation](https://docs.docker.com/engine/swarm/secrets)
    for the `docker secret` command, which works with Docker Swarm mode, and HashiCorp’s
    [Vault](https://www.vaultproject.io).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要管理需要提供给您的容器的秘密的过程，您可能需要查看 `docker secret` 命令的[文档](https://docs.docker.com/engine/swarm/secrets)，该命令适用于
    Docker Swarm 模式，以及 HashiCorp 的 [Vault](https://www.vaultproject.io)。
- en: Backing Services
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后备服务
- en: '*Treat backing services as attached resources.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*将后备服务视为附加资源。*'
- en: Local databases are no more reliable than third-party services and should be
    treated as such. Applications should handle the loss of an attached resource gracefully.
    By implementing graceful degradation in your application and never assuming that
    any resource, including filesystem space, is available, you ensure that your application
    will continue to perform as many of its functions as it can, even when external
    resources are unavailable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本地数据库不比第三方服务更可靠，应以此为对待。应用程序应优雅地处理所附资源的丢失。通过在应用程序中实施优雅降级，并永不假设包括文件系统空间在内的任何资源可用，您可以确保即使外部资源不可用时，应用程序仍将尽可能执行其许多功能。
- en: This isn’t something that Docker helps you with directly, and although it is
    always a good idea to write robust services, it is even more important when you
    are using containers. When using containers, you achieve high availability most
    often through horizontal scaling and rolling deployments, instead of relying on
    the live migration of long-running processes, like on traditional VMs. This means
    that specific instances of a service will often come and go over time, and your
    service should be able to handle this gracefully.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 并不直接提供这种功能，尽管编写健壮的服务始终是个好主意，但在使用容器时更为重要。在使用容器时，通常通过水平扩展和滚动部署实现高可用性，而不是依赖于传统虚拟机上长时间运行进程的实时迁移。这意味着服务的特定实例经常会随时间的推移而来来去去，而你的服务应能优雅地处理这一点。
- en: Additionally, because Linux containers have limited filesystem resources, you
    can’t simply rely on having some local storage available. You need to plan that
    into your application’s dependencies and handle it explicitly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于 Linux 容器具有有限的文件系统资源，您不能简单地依赖于某些本地存储的可用性。您需要计划进入应用程序的依赖项，并显式地处理它。
- en: Build, Release, Run
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建、发布、运行
- en: '*Strictly separate build and run stages.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*严格分离构建和运行阶段。*'
- en: Build the code, release it with the proper configuration, and then deploy it.
    This ensures that you maintain control of the process and can perform any single
    step without triggering the whole workflow. By ensuring that each of these steps
    is self-contained in a distinct process, you can tighten the feedback loop and
    react more quickly to any problems within the deployment flow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构建代码，使用正确的配置发布，然后部署它。这确保您控制整个过程，并可以执行任何单个步骤，而不会触发整个工作流程。通过确保每个步骤都在独立的进程中自包含，您可以缩短反馈循环，并更快地对部署流程中的任何问题做出反应。
- en: As you design your Docker workflow, you want to clearly separate each step in
    the deployment process. It is perfectly fine to have a single button that builds
    a container, tests it, and then deploys it, assuming that you trust your testing
    processes—but you don’t want to be forced to rebuild a container simply to deploy
    it to another environment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计Docker工作流程时，你希望清晰地分隔部署过程中的每个步骤。可以有一个单独的按钮来构建容器，测试它，然后部署它，这是完全可以接受的，前提是你信任你的测试过程，但你不希望被迫重新构建容器，只是为了将其部署到另一个环境。
- en: Docker supports the 12-factor ideal well in this area because the image registry
    provides a clean handoff point between building an image and shipping it to production.
    If your build process generates images and pushes them to the registry, then deployment
    can simply be pulling the image down to servers and running it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在这一领域很好地支持了12因素理想，因为镜像注册表提供了在构建镜像和将其推送到生产环境之间进行清晰交接的点。如果你的构建过程生成镜像并将其推送到注册表，那么部署就可以简单地将镜像拉到服务器上并运行它。
- en: Processes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: '*Execute the app as one or more stateless processes.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*将应用程序作为一个或多个无状态进程执行。*'
- en: All shared data must be accessed via a stateful backing store so that application
    instances can easily be redeployed without losing any important session data.
    You don’t want to keep any critical state on disk in your ephemeral container
    or in the memory of one of its processes. Containerized applications should always
    be considered ephemeral. A truly dynamic container environment requires the ability
    to destroy and re-create containers at a moment’s notice. This flexibility helps
    enable the rapid deployment cycle and outage recovery demanded by modern, Agile
    workflows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有共享数据必须通过有状态的后备存储访问，以便可以轻松地重新部署应用程序实例而不会丢失任何重要的会话数据。你不希望在短暂的容器或其进程的内存中保留任何关键状态。容器化应用程序应始终被视为短暂的。真正动态的容器环境需要在瞬间销毁和重新创建容器的能力。这种灵活性有助于支持现代敏捷工作流所需的快速部署周期和故障恢复。
- en: As much as possible, it is preferable to write applications that do not need
    to keep state longer than the time required to process and respond to a single
    request. This ensures that the impact of stopping any given container in your
    application pool is very minimal. When you must maintain state, the best approach
    is to use a remote datastore like Redis, PostgreSQL, Memcache, or even Amazon
    S3, depending on your resiliency needs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，最好编写不需要保持状态时间超过处理和响应单个请求所需时间的应用程序。这样做可以确保停止应用程序池中的任何容器的影响非常小。当必须保持状态时，最佳方法是使用像Redis、PostgreSQL、Memcache甚至Amazon
    S3这样的远程数据存储，具体取决于你的弹性需求。
- en: Port Binding
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口绑定
- en: '*Export services via port binding.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过端口绑定导出服务。*'
- en: Your application needs to be addressable by a port specific to itself. Applications
    should bind directly to a port to expose the service and should not rely on an
    external daemon like `inetd` to handle that for them. You should be certain that
    when you’re talking to that port, you’re talking to your application. Most modern
    web platforms are quite capable of directly binding to a port and servicing their
    own requests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序需要通过特定的端口可寻址。应用程序应直接绑定到端口以公开服务，而不应依赖外部守护程序（如`inetd`）来处理这些事务。确保当你连接到该端口时，你正在与你的应用程序通信。大多数现代网络平台都能直接绑定到端口并为其自己的请求提供服务。
- en: To expose a port from your container, as discussed in [Chapter 4](ch04.html#docker_images),
    you can launch `docker container run` commands that use the `--publish` command-line
    argument. Using `--publish mode=ingress,published=80,target=8080`, for example,
    would tell Docker to proxy the container’s port 8080 on the host’s port 80.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要从你的容器中暴露一个端口，如在[第四章](ch04.html#docker_images)中讨论的，你可以使用`docker container run`命令，该命令使用`--publish`命令行参数。例如，使用`--publish
    mode=ingress,published=80,target=8080`将告诉Docker代理主机端口80上容器的端口8080。
- en: The statically linked Go Hello World container that we discussed in [“Keeping
    Images Small”](ch04.html#small_images) is a great example of this, because the
    container contains nothing but our application to serve its content to a web browser.
    We did not need to include any additional web servers, which would require further
    configuration, introduce additional complexity, and increase the number of potential
    failure points in our system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“保持镜像小”](ch04.html#small_images)中讨论的静态链接的Go Hello World容器是一个很好的例子，因为容器中除了用于提供内容的应用程序外，没有包含任何其他Web服务器。我们不需要包含任何额外的Web服务器，这将需要进一步的配置，引入额外的复杂性，并增加系统中潜在故障点的数量。
- en: Concurrency
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发性
- en: '*Scale out via the process model.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过进程模型进行横向扩展。*'
- en: Design for concurrency and horizontal scaling within your applications. Increasing
    the resources of an existing instance can be difficult and hard to reverse. Adding
    and removing instances as scale fluctuates is much easier and helps maintain flexibility
    in the infrastructure. Launching another container on a new server is incredibly
    inexpensive compared to the effort and expense required to add resources to an
    underlying virtual or physical system. Designing for horizontal scaling allows
    the platform to react much faster to changes in resource requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 设计您的应用程序以支持并发和横向扩展。增加现有实例的资源可能会很困难且难以逆转。根据规模波动添加和删除实例要容易得多，这有助于保持基础设施的灵活性。在新服务器上启动另一个容器的成本非常低廉，相比于为底层虚拟或物理系统添加资源所需的工作和费用，设计横向扩展使平台能够更快地响应资源需求的变化。
- en: 'As an example, in [Chapter 10](ch10.html#containers_scale), you saw how easily
    a service could be scaled using Docker Swarm mode by simply running a command
    like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，在[第 10 章](ch10.html#containers_scale)中，你看到了如何通过运行以下命令轻松地使用 Docker Swarm
    模式来扩展服务：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is where tools like Docker Swarm mode, Mesos, and Kubernetes truly begin
    to shine. Once you have implemented a Docker cluster with a dynamic scheduler,
    it is very easy to add three more instances of a container to the cluster as load
    increases and then to be able to easily remove two instances of your application
    from the cluster as load starts to decrease again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是像 Docker Swarm 模式、Mesos 和 Kubernetes 这样的工具真正开始发挥作用的地方。一旦您实施了具有动态调度程序的 Docker
    集群，就可以很容易地将三个容器实例添加到集群中以应对负载增加，然后在负载开始减少时轻松地从集群中移除两个应用程序实例。
- en: Disposability
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可处置性
- en: '*Maximize robustness with fast startup and graceful shutdown.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过快速启动和优雅关闭来最大化鲁棒性。*'
- en: Services should be designed to be ephemeral. We already talked a little bit
    about this when discussing external state with containers. Responding well to
    dynamic horizontal scaling, rolling deploys, and unexpected problems requires
    applications that can quickly and easily be started or shut down. Services should
    respond gracefully to a `SIGTERM` signal from the operating system and even handle
    hard failures confidently. Most importantly, we shouldn’t care if any given container
    for our application is up and running. As long as requests are being served, the
    developer should be freed of concerns about the health of any single component
    within the system. If an individual node is behaving poorly, turning it off or
    redeploying it should be an easy decision that doesn’t entail long planning sessions
    and concerns about the health of the rest of the cluster.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应设计为短暂的。在讨论容器的外部状态时，我们已经稍微提到了这一点。对动态水平扩展、滚动部署和意外问题的良好响应要求应用程序能够快速且轻松地启动或关闭。服务应能够从操作系统接收`SIGTERM`信号并且能够自信地处理硬件故障。最重要的是，我们不应该关心应用程序中的任何容器是否正在运行。只要能够提供服务，开发者就无需担心系统中任何单个组件的健康状态。如果单个节点表现不佳，关闭它或重新部署它应该是一个简单的决定，不需要长时间的规划会议和对其余集群健康状态的担忧。
- en: As discussed in [Chapter 7](ch07.html#debug_docker), Docker sends standard Unix
    signals to containers when it is stopping or killing them; therefore, any containerized
    application can detect these signals and take the appropriate steps to shut down
    gracefully.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 7 章](ch07.html#debug_docker)所述，Docker 在停止或杀死容器时向其发送标准的 Unix 信号；因此，任何容器化应用程序都可以检测这些信号并采取适当的步骤以优雅地关闭。
- en: Development/Production Parity
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发/生产环境的一致性
- en: '*Keep development, staging, and production as similar as possible.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能使开发、测试和生产环境尽可能相似。*'
- en: The same processes and artifacts should be used to build, test, and deploy services
    into all environments. The same people should do the work in all environments,
    and the physical nature of the environments should be as similar as reasonably
    possible. Repeatability is incredibly important. Almost any issue discovered in
    production points to a failure in the process. Every area where production diverges
    from staging is an area where risk is being introduced into the system. These
    inconsistencies blind you to certain types of issues that could occur in your
    production environment until it is too late to proactively deal with them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境中构建、测试和部署服务应使用相同的流程和工件。同一组人员应在所有环境中进行工作，并且环境的物理特性应尽可能相似。可重复性非常重要。几乎在生产中发现的任何问题都指向流程失败。生产环境与暂存环境分歧的每个领域都是引入风险的领域。这些不一致会使您对可能发生在生产环境中的某些问题变瞎，直到为时已晚才能主动处理它们。
- en: In many ways, this advice essentially repeats a few of the early recommendations.
    However, the specific point here is that any environment divergence introduces
    risks, and although these differences are common in many organizations, they are
    much less necessary in a containerized environment. Docker servers can normally
    be created so that they are identical in all of your environments, and environment-based
    configuration changes should typically impact only which endpoints your service
    connects to without specifically changing the application’s behavior.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这些建议基本上重复了早期的一些建议。然而，这里的具体观点是，任何环境分歧都会引入风险，尽管这些差异在许多组织中很常见，但在容器化环境中却不太必要。Docker服务器通常可以创建为在所有环境中都相同，环境配置更改通常只应影响服务连接到的端点，而不会明确更改应用程序的行为。
- en: Logs
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: '*Treat logs as event streams.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*将日志视为事件流。*'
- en: Services should not concern themselves with routing or storing logs. Instead,
    events should be streamed, unbuffered, to `STDOUT` and `STDERR` for handling by
    the hosting process. In development, `STDOUT` and `STDERR` can be easily viewed,
    whereas in staging and production, the streams can be routed to anything, including
    a central logging service. Different environments have different exceptions for
    log handling. This logic should never be hardcoded into the application. Streaming
    everything to `STDOUT` and `STDERR` enables the top-level process manager to handle
    the logs via whatever method is best for the environment, allowing the application
    developer to focus on core functionality.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 服务不应关注路由或存储日志。相反，事件应被流式传输，无缓冲，到`STDOUT`和`STDERR`以供托管进程处理。在开发中，`STDOUT`和`STDERR`可以轻松查看，而在暂存和生产中，流可以路由到任何地方，包括中央日志服务。不同环境对日志处理有不同的例外情况。这种逻辑不应硬编码到应用程序中。将所有内容流式传输到`STDOUT`和`STDERR`使得顶级进程管理器能够通过最适合环境的方法处理日志，从而使应用程序开发人员能够专注于核心功能。
- en: In [Chapter 6](ch06.html#exploring_docker), we discussed the `docker container
    logs` command, which collects the output from your container’s `STDOUT` and `STDERR`
    and records it as logs. If you write logs to random files within the container’s
    filesystem, you will not have easy access to them. It is also possible to configure
    Docker to send logs to a local or remote logging system using tools like `rsyslog`,
    `journald`, or `fluentd`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html#exploring_docker)中，我们讨论了`docker container logs`命令，该命令收集容器的`STDOUT`和`STDERR`的输出并记录为日志。如果将日志写入容器文件系统中的随机文件，您将无法轻松访问它们。还可以配置Docker将日志发送到本地或远程日志系统，使用类似`rsyslog`、`journald`或`fluentd`的工具。
- en: If you use a process manager or initialization system on your servers, like
    `systemd` or `upstart`, it is usually very easy to direct all process output to
    `STDOUT` and `STDERR` and then have your process monitor capture them and send
    them to a remote logging host.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在服务器上使用进程管理器或初始化系统，如`systemd`或`upstart`，通常很容易将所有进程输出定向到`STDOUT`和`STDERR`，然后让您的进程监视器捕获它们并将它们发送到远程日志主机。
- en: Admin Processes
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理流程
- en: '*Run admin/management tasks as one-off processes.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*将管理任务作为一次性流程运行。*'
- en: One-off administration tasks should be run via the same codebase and configuration
    that the application uses. This helps avoid synchronization problems and code/schema
    drift problems. Oftentimes, management tools exist as one-off scripts or live
    in a completely different codebase. It is much safer to build management tools
    within the application’s codebase and utilize the same libraries and functions
    to perform the required work. This can significantly improve the reliability of
    these tools by ensuring that they leverage the same code paths that the application
    relies on to perform its core functionality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性管理任务应通过与应用程序使用相同的代码库和配置来运行。这有助于避免同步问题和代码/架构漂移问题。管理工具往往存在于一次性脚本中，或者完全存在于不同的代码库中。在应用程序的代码库内构建管理工具并利用相同的库和函数执行所需的工作，这样做可以显著提高这些工具的可靠性，确保它们利用与应用程序核心功能相同的代码路径。
- en: What this means is that you should never rely on random `cron`-like scripts
    to perform administrative and maintenance functions. Instead, include all of these
    scripts and functionality in your application codebase. Assuming that these don’t
    need to be run on every instance of your application, you can launch a special
    short-lived container, or use `docker container exec` with the existing container,
    whenever you need to run a maintenance job. This command can trigger the required
    job, report its status somewhere, and then exit.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不应该依赖类似于`cron`的随机脚本来执行管理和维护功能。相反，应将所有这些脚本和功能包含在你的应用程序代码库中。假设这些不需要在你的应用程序的每个实例上运行，你可以启动一个特殊的短暂容器，或者在需要运行维护作业时使用`docker
    container exec`与现有容器一起。这个命令可以触发所需的作业，在某处报告其状态，然后退出。
- en: Twelve-Factor Wrap-Up
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十二要素总结
- en: While “The Twelve-Factor App” wasn’t written as a Docker-specific manifesto,
    almost all of this advice can be applied to writing and deploying applications
    on a Docker platform. This is in part because the article heavily influenced Docker’s
    design, and in part because the manifesto itself codified many of the best practices
    promoted by modern software architects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“十二要素应用”并非专门为Docker而写的宣言，但几乎所有这些建议都可以应用于在Docker平台上编写和部署应用程序。部分原因是因为该文章深刻影响了Docker的设计，部分原因是因为宣言本身明确了现代软件架构师推广的许多最佳实践。
- en: The Reactive Manifesto
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式宣言
- en: Riding alongside “The Twelve-Factor App,” another pertinent document was released
    in July of 2013 by Typesafe cofounder and CTO Jonas Bonér, entitled [“The Reactive
    Manifesto”](https://www.reactivemanifesto.org). Jonas originally worked with a
    small group of contributors to solidify a manifesto that discusses how the expectations
    for application resiliency have evolved over the last few years and how applications
    should be engineered to react predictably to various forms of interaction, including
    events, users, load, and [failures](https://www.lightbend.com/blog/why-do-we-need-a-reactive-manifesto).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与“十二要素应用”并驾齐驱的是另一份相关文档，由Typesafe联合创始人兼CTO Jonas Bonér在2013年7月发布，题为[“响应式宣言”](https://www.reactivemanifesto.org)。Jonas最初与一小组贡献者共同工作，以明确阐述一份关于如何预测性地应对各种交互形式（包括事件、用户、负载和[故障](https://www.lightbend.com/blog/why-do-we-need-a-reactive-manifesto)）的宣言，讨论了应用程序弹性的期望如何在过去几年里演变，以及应该如何设计应用程序以可预测地对各种交互做出反应。
- en: “The Reactive Manifesto” states that “reactive systems” are responsive, resilient,
    elastic, and message driven.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: “响应式宣言”指出，“响应式系统”具备响应性、弹性、伸缩性和消息驱动性。
- en: Responsive
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应性
- en: '*The system responds in a timely manner if at all possible.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果可能，系统应及时响应*。'
- en: In general, this means that the application should respond to requests very
    quickly. Users simply don’t want to wait, and there is rarely a good reason to
    make them. If you have a containerized service that renders large PDF files, design
    it so that it immediately responds with a “job submitted” message so that users
    can go about their day, and then provide a message or banner that informs them
    when the job is finished and where they can download the resulting PDF.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这意味着应用程序应该非常快速地响应请求。用户根本不想等待，而且很少有充分的理由让他们等待。如果你有一个容器化的服务来渲染大型PDF文件，设计它可以立即响应“作业已提交”的消息，这样用户可以继续他们的工作，然后提供一个消息或横幅，告知他们作业何时完成以及从哪里下载生成的PDF。
- en: Resilient
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性
- en: '*The system stays responsive in the face of failure*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统在面对故障时保持响应*。'
- en: When your application fails for any reason, the situation will always be worse
    if it becomes unresponsive. It is much better to handle the failure gracefully
    and dynamically reduce the application’s functionality or even display a simple
    but clear problem message to the user while reporting the issue internally.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用由于任何原因失败时，如果变得无响应，情况将会变得更糟。最好是优雅地处理失败，并动态降低应用的功能，甚至向用户显示简单而清晰的问题消息，同时内部报告问题。
- en: Elastic
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性
- en: '*The system stays responsive under varying workload.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统在不同工作负载下保持响应性。*'
- en: With Docker, you achieve this by dynamically deploying and decommissioning containers
    as requirements and load fluctuate so that your application is always able to
    handle server requests quickly, without deploying a lot of underutilized resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，你通过动态部署和下架容器来实现这一点，以便在需求和负载波动时，你的应用始终能够快速处理服务器请求，而不需要部署大量未充分利用的资源。
- en: Message Driven
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息驱动
- en: '*Reactive systems rely on asynchronous message passing to establish a boundary
    between components that ensures loose coupling, isolation, and location transparency.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应式系统依赖于异步消息传递来建立组件之间的边界，确保松耦合、隔离和位置透明性。*'
- en: Although not directly addressed by Docker, the idea here is that there are times
    when an application can become busy or unavailable. If you utilize asynchronous
    message passing between your services, you can help ensure that your services
    will not lose requests and that they will be processed as soon as possible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker并未直接处理这一点，但这里的想法是，有时应用程序可能会变得繁忙或不可用。如果你在服务之间利用异步消息传递，可以帮助确保你的服务不会丢失请求，并且请求将尽快被处理。
- en: Wrap-Up
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: All four of the design features in “The Reactive Manifesto” require application
    developers to design graceful degradation and define a clear separation of responsibilities
    in their applications. By treating all dependencies as properly designed, attached
    resources, dynamic container environments allow you to easily maintain *N*+2 status
    across your application stack, reliably scale individual services in your environment,
    and quickly replace unhealthy nodes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在“响应式宣言”中的四个设计特性都要求应用开发者设计优雅的降级，并在其应用中明确划分责任。通过将所有依赖视为设计良好的、连接的资源，动态容器环境允许你轻松地在应用堆栈中保持
    *N*+2 的状态，可靠地扩展环境中的个别服务，并快速替换不健康的节点。
- en: A service is only as reliable as its least reliable dependency, so it is vital
    to incorporate these ideas into every component of your platform.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务的可靠性取决于其最不可靠的依赖，因此将这些理念融入到平台的每个组件中至关重要。
- en: The core ideas in “The Reactive Manifesto” merge very nicely with “The Twelve-Factor
    App” and the Docker workflow. These documents successfully summarize many of the
    most important discussions about the way you need to think and work if you want
    to be successful in meeting new expectations in the industry. The Docker workflow
    provides a practical way to implement many of these ideas in any organization
    in a completely approachable manner.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “响应式宣言”中的核心思想与“十二要素应用”及Docker工作流非常契合。这些文档成功地总结了关于如何在行业中满足新期望的许多重要讨论。Docker工作流为在任何组织中以完全可接近的方式实施这些思想提供了实用的方法。
