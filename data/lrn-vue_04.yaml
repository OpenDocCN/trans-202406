- en: Chapter 4\. Interactions Between Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#unique_chapter_id_03), we deep-dived into composing
    a component with lifecycle hooks, computed properties, watchers, methods, and
    other features. We also learned about the power of slots and how to receive external
    data from other components using props.
  prefs: []
  type: TYPE_NORMAL
- en: Based on that foundation, this chapter guides you on how to build the interactions
    between components using custom events and provide/inject patterns. It also introduces
    Teleport API, which allows you to move elements around the DOM tree while keeping
    their order of appearance inside a Vue component.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Components and Data Flow in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue components can nest other Vue components inside them. This feature is handy
    in allowing users to organize their code into smaller, manageable, and reusable
    pieces in a complex UI project. We call nested elements child components and the
    component containing them their parent component.
  prefs: []
  type: TYPE_NORMAL
- en: Data flow in a Vue application is unidirectional by default, which means that
    the parent component can pass data to its child component but not the other way
    around. The parent can pass data to the child component using `props` (discussed
    briefly in [“Exploring the Options API”](ch02.html#ch02_exploring_options)), and
    the child component can emit events back to the parent component using custom
    events `emits`. [Figure 4-1](#figure_04_04) demonstrates the data flow between
    components.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram shows the one-way data flow between components](assets/lvue_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. One-way data flow in Vue components
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Passing Functions as Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other frameworks, Vue does not allow you to pass a function as a prop
    to the child component. Instead, you can bind the function as a custom event emitter
    (see [“Communication Between Components with Custom Events”](#custom-event-emitters)).
  prefs: []
  type: TYPE_NORMAL
- en: Using Props to Pass Data to Child Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the form of an object or array, the `props` field of a Vue component contains
    all the available data properties that the component can receive from its parent.
    Each property of `props` is a prop of the target component. To start receiving
    data from the parent, you need to declare the `props` field in the component’s
    options object, as shown in [Example 4-1](#example_04_01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Defining props in a component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 4-1](#example_04_01), the `ChildComponent` component accepts a `name`
    prop of type `String`. The parent component then can pass data to the child component
    using this `name` prop, as shown in [Example 4-2](#example_04_02).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. Passing static data as props to a child component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `ChildComponent` receives a static “Red Sweater” as a `name` value in the
    previous example. If you want to pass and bind a dynamic data variable to `name`,
    such as the first element in the `children` list, you can use the `v-bind` attribute,
    denoted by `:`, as shown in [Example 4-3](#example_04_03).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. Passing dynamic variables as props to a child component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output for the previous code is the same as passing a static string, `Red
    Sweater`, to the `name` prop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the `name` prop is not of type `String`, you still need to use the `v-bind`
    attribute (or `:`) to pass static data to the child component, such as `:name="true"`
    for `Boolean`, or `:name="["hello", "world"]"` for `Array` type.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 4-3](#example_04_03), whenever the value of `children[0]` changes,
    Vue will also update the `name` prop in the `ChildComponent`, and the child component
    will re-render its content if needed.
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than one prop in the child component, you can follow the same
    approach and pass each data to the relevant prop. For instance, to pass `name`
    and `price` of a product to the `ProductComp` component, you can perform this
    ([Example 4-4](#example_04_04)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. Passing multiple props to a child component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And we can define the `ProductComp` component as in [Example 4-5](#example_04_05).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. Defining multiple props in `ProductComp`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `v-bind` (*not* `:`) to pass the entire object `user`
    and have its properties bound to the relevant child component’s props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that only the child component will receive the relevant declared props.
    Hence, if you have another field, `product.description`, in the parent component,
    it will not be available for access in the child component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another approach to declare your component’s `props` is to use an array of
    strings, each representing the name of the prop it accepts, such as `props: ["name",
    "price"]`. This approach is practical when you want to prototype a component quickly.
    However, I strongly recommend you use the object form of `props` and declare all
    your props with types, as a good practice for code readability and bug prevention.'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to declare props with types, but how do we validate the
    data passed to the child’s props when needed? How can we set a fallback value
    for a prop when no value is passed? Let’s find out next.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Prop Types with Validation and Default Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in [Example 4-1](#example_04_01), we declared the `name` prop as a `String`
    type. Vue will warn if the parent component passes a non-string value to the `name`
    prop during run-time. However, to be able to enjoy the benefit of Vue’s type validation,
    we should use the full declaration syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In which:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type` is the type of prop. It can be a constructor function (or custom class)
    or one of the built-in types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` is the prop’s default value if no value is passed. For types `Object`,
    `Function`, and `Array`, the default value must be a function that returns the
    initial value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` is a boolean value indicating whether the prop is mandatory. If
    `required` is `true`, the parent component must pass a value to the prop. By default,
    all props are optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validator` is a function that validates the value passed to the prop, mainly
    for development debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can declare the `name` prop to be more specific, including a default value,
    as shown in [Example 4-6](#example_06_04_01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6\. Defining prop as a string with a default value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the parent component does not pass a value, the child component will fall
    back to the default value *“Child component”* for the `name` prop.
  prefs: []
  type: TYPE_NORMAL
- en: We can also set `name` as a mandatory prop for the child component and add a
    validator for its received data, as shown in [Example 4-7](#example_ch04_05).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7\. Defining name as required with a prop validator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, if the parent component does not pass a value to the `name`
    prop, or the given value matches *Child component*, Vue will throw a warning in
    development mode ([Figure 4-2](#figure_ch04_warning)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of console warning for failed name prop validation](assets/lvue_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Console warning in development for failed prop validation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the `default` field, the `Function` type is a function that returns the
    initial value of the prop. You can’t use it to pass data back to the parent component
    or to trigger data changes on the parent level.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the built-in types and validation provided by Vue, you can combine
    a JavaScript `Class` or a function constructor and TypeScript to create your custom
    prop type. I’ll cover them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Props with Custom Type Checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using primitive types like `Array`, `String`, or `Object` suits the essential
    use case. However, as your application grows, primitive types can be too generic
    to keep your component’s type safe. Take a `PizzaComponent` with the following
    template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This component accepts a mandatory `pizza` prop, which is an `Object` containing
    some details about the `pizza`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Straightforward enough. However, by declaring `pizza` as an `Object` type, we
    assume the parent will always pass the suitable object with the appropriate fields
    (`title`, `image`, `description`, `quantity`, and `price`) required for a `pizza`
    to render.
  prefs: []
  type: TYPE_NORMAL
- en: This assumption can lead to a problem. Since `pizza` accepts data of type `Object`,
    any component that uses `PizzaComponent` can pass any object data to the prop
    `pizza` without the actual fields needed for a `pizza`, as in [Example 4-8](#example_06_04_02).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8\. Using Pizza component with wrong data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code results in a broken UI render of `PizzaComponent`, where
    only a `description` is available, and the rest of the fields are empty (with
    a broken image), as shown in [Figure 4-3](#figure_ch04_01_02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a pizza without title, price, quantity and image rendered](assets/lvue_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Broken UI with no image link and missing fields for a pizza
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'TypeScript won’t be able to detect the data type mismatch here either, as it
    performs the type checking according to the declared type of `pizza`: the generic
    `Object`. Another potential problem is that passing `pizza` in the wrong nest
    properties format can cause the app to crash. Therefore, to avoid such accidents,
    we use custom type declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: We can define the `Pizza` class and declare the prop `pizza` of type `Pizza`
    as shown in [Example 4-9](#example_ch04_07).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9\. Declaring a Pizza custom type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_interactions_between_components_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the type of `pizza` props as `Pizza` directly
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use TypeScript’s `interface` or `type` to define your
    custom type instead of `Class`. However, in such scenarios, you must use type
    `PropType` from the `vue` package, with the following syntax, to map the declared
    type to the target prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s rewrite the `Pizza` class as an `interface` instead ([Example 4-10](#example_04_08)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10\. Declaring a Pizza custom type using the TypeScript interface
    API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_interactions_between_components_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the type of `pizza` props as `Pizza` interface with `PropType` help.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `PizzaComponent` with the wrong data format, TypeScript will detect
    and highlight the error appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vue performs type validation during run-time, while TypeScript performs type
    checking during compile-time. Hence, it is a good practice to use both Vue’s type
    checking and TypeScript’s type checking to ensure your code is bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Props Using defineProps() and withDefaults()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in [“setup”](ch03.html#setup_hook_03), starting with Vue 3.x,
    Vue offers `<script setup>` syntax for declaring a functional component without
    the classic Options API. Within this `<script setup>` block, you can use `defineProps()`
    to declare props, as shown in [Example 4-11](#example_ch04_09).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11\. Props declaration with `defineProps()` and `<script setup>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to TypeScript, we can also declare the accepted type for `defineProps()`
    per component with type validation on compile-time, as shown in [Example 4-12](#example_ch04_10).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12\. Props declaration with `defineProps()` and `TypeScript type`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, to declare the default value of the `message` prop, we need to
    wrap the `defineProps()` call with `withDefaults()`, as in [Example 4-13](#example_ch04_11).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13\. Props declaration with `defineProps()` and `withDefaults()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using defineProps() with TypeScript Type Checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can’t combine run-time and compile-time type checking when using `defineProps()`.
    I recommend using `defineProps()` in the approach in [Example 4-11](#example_ch04_09),
    for better readability and a combination of both Vue and TypeScript type checking.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to declare props for passing raw data in a Vue component,
    with type checking and validation. Next, we will explore how to pass functions
    as custom event emitters to a child component.
  prefs: []
  type: TYPE_NORMAL
- en: Communication Between Components with Custom Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue treats data passed to a child component via props as read-only and raw data.
    One-way data flow ensures that the parent component is the only one that can update
    the data prop. We often want to update a specific data prop and sync it with the
    parent component. To do so, we use the `emits` field in the component’s options
    to declare custom events.
  prefs: []
  type: TYPE_NORMAL
- en: Take a to-do list, or `ToDoList` component, for instance. This `ToDoList` will
    use `ToDoItem` as its child component to render a list of tasks with the code
    in [Example 4-14](#example_ch04_12).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14\. `ToDoList` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And `ToDoItem` is a component that receives a `task` prop and renders an `input`
    as a checkbox for the user to mark the task as completed or not. This `input`
    element receives `task.completed` as its initial value for the `checked` attribute.
    Let’s look at [Example 4-15](#example_ch04_09_01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15\. `ToDoItem` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When a user toggles this `input` checkbox, we want to emit an event called `task-completed-toggle`
    to inform about the `task.completed` value of the specific task to the parent
    component. We can do so by first declaring the event in the `emits` field of the
    component’s options ([Example 4-16](#example_ch04_09_todo_with_emits)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-16\. `ToDoItem` component with emits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, we create a new method `onTaskCompleted` to emit the `task-completed-toggle`
    event with the new value of `task.completed` from the checkbox and the `task.id`
    as the event’s payload ([Example 4-17](#example_ch04_09_todo_with_emits2)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-17\. `ToDoItem` component with a method to emit `task-completed-toggle`
    event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We use `defineComponent` to wrap around the component’s options and create a
    TypeScript-friendly component. Using `define` `Component` is not required for
    simple components, but you need to use it to access other data properties of `this`
    inside components’ methods, hooks, or computed properties. Otherwise, TypeScript
    will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Then we bind the `onTaskCompleted` method to the `input` element’s `change`
    event, as shown in [Example 4-18](#example_ch04_09_todo_with_emits3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-18\. `ToDoItem` component’s updated template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now in the parent component `<ToDoList>` of `ToDoItem`, we can bind the `task-completed-toggle`
    event to a method using `@` notation, with the template in [Example 4-19](#example_ch04_09_todo_parent).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-19\. `ToDoList` component’s updated template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `onTaskCompleted` method in the parent component `<ToDoList>` will receive
    the payload of the `task-completed-toggle` event, and update the `task.completed`
    value of the specific task in the `tasks` array, as in [Example 4-20](#ch04_09_todo_parent_script).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-20\. `ToDoList` component’s script with a method to handle `task-completed-toggle`
    event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These code blocks will render the page shown in [Figure 4-4](#figure_04_02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a to-do list with three tasks, each with a checkbox and task''s
    title](assets/lvue_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. `ToDoList` component with three items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vue will update the related data in `ToDoList` and accordingly render the relevant
    `ToDoItem` component instance. You can toggle the checkbox to mark a to-do item
    as completed. [Figure 4-5](#figure_04_03) shows we can detect the component’s
    event using the Vue Devtools.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Vue Devtools showing the event emitted by the +ToDoItem+
    component](assets/lvue_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. Mark a to-do item as completed and debug the event emitted using
    Vue Devtools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Defining Custom Events Using defineEmits()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to [“Declaring Props Using defineProps() and withDefaults()”](#declaring-props-defineProps),
    within a `<script setup>` code block, you can use `defineEmits()` to define custom
    events. The `defineEmits()` function accepts the same input parameter type as
    `emits` accepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It then returns a function instance that we can use to invoke a specific event
    from the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Thus we can write the script section of `ToDoItem` as in [Example 4-21](#example_04_12).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-21\. `ToDoItem` component with the custom event using `defineEmits()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note here we don’t need to use `defineComponent` since there is no `this` instance
    available within the `<script setup>` code block.
  prefs: []
  type: TYPE_NORMAL
- en: For better type checking, you can use type-only declaration for the `task-completed-toggle`
    event instead of a single string. Let’s improve the `emits` declaration in [Example 4-21](#example_04_12)
    to use type `EmitEvents` as shown in [Example 4-22](#example_04_13).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-22\. Custom event using `defineEmits()` and type-only declaration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach helps ensure you bind the correct method to the declared event.
    As seen for the `task-complete-toggle` event, any event declaration should follow
    the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the previous syntax, `e` is the event’s name, and `arguments` are all the
    inputs passed to the event emitter. In the case of the `task-completed-toggle`
    event, its emitter’s argument is `task` of type `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: '`emits` is a powerful feature that allows you to enable two-way communication
    between a parent and a child component without breaking the data flow mechanism
    of Vue. However, `props` and `emits` are only beneficial when you want direct
    data communication.'
  prefs: []
  type: TYPE_NORMAL
- en: You must use a different approach to pass data from a component to its grandchild
    or descendant. In the next section, we will see how to use the `provide` and `inject`
    APIs to pass data from a parent component to its child or grandchild component.
  prefs: []
  type: TYPE_NORMAL
- en: Communicate Between Components with provide/inject Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To establish data communication between an ancestor component and its descendants,
    the `provide/inject` API is a reasonable option. The `provide` field passes data
    from the ancestor, while `inject` ensures that Vue injects the provided data into
    any target descendant.
  prefs: []
  type: TYPE_NORMAL
- en: Using provide to Pass Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The component’s option field `provide` accepts two formats: a data object or
    a function.'
  prefs: []
  type: TYPE_NORMAL
- en: '`provide` can be an object containing data to inject, with each property representing
    a (key, value) data type. In the following example, `ProductList` provides a data
    value, `selectedIds`, with the value `[1]` to all its descendants ([Example 4-23](#example_04_provide)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-23\. Passing `selectedIds` using provide in `ProductList` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Another format type for `provide` is a function that returns an object containing
    the data available to inject for descendants. A benefit of this format type is
    we can access the `this` instance and map dynamic data or a component method to
    the relevant fields of the return object. From [Example 4-23](#example_04_provide),
    we can rewrite the `provide` field as a function as shown in [Example 4-24](#example_04_provide_function).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-24\. Passing `selectedIds` using provide in `ProductList` component
    as a function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike `props`, you can pass a function and have the target descendant trigger
    it using the `provide` field. Doing so enables sending data back up to the parent
    component. However, Vue considers this approach an anti-pattern, and you should
    use it cautiously.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our `ProductList` passes some data values to its descendant using
    `provide`. Next, we must inject the provided values to operate within a descendant.
  prefs: []
  type: TYPE_NORMAL
- en: Using inject to Receive Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like `props`, the `inject` field can accept an array of strings, each representing
    the provided data key (`inject: [*selectedId*]`) or an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `inject` as an object field, each of its properties is an object,
    with the key presenting the local data key used within the component and the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, `from` is optional if the property key is the same as the provided key
    from the ancestor. Take [Example 4-23](#example_04_provide) with the `selectedIds`
    as the data provided by `ProductList` to its descendants, for instance. We can
    compute a `ProductComp` that receives the provided data, `selectedIds`, from `ProductList`
    and rename it to `current` `SelectedIds` to use locally, as shown in [Example 4-25](#example_04_inject).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-25\. Injecting provided data in `ProductComp`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this code, Vue will take the value of injected `selectedIds` and assign it
    to a local data field, `currentSelectedIds`, or use its default value `[]` if
    there is no injected value.
  prefs: []
  type: TYPE_NORMAL
- en: Within the Components section of the Vue tab in the browser’s Developer Tools,
    when selecting the `ProductComp` from the component tree (the left-side panel),
    you can debug the indication of the renaming for the injected data (the right-side
    panel), as shown in [Figure 4-6](#figure_04_05).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot shows the Component tab of the Vue tab in the browser''s Develop
    tools with information about a component''s provided and injected data.](assets/lvue_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Debug the provided and injected data using Vue Devtools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The equivalent hooks in Composition API for `provide/inject` are `provide()`
    and `inject()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now we understand how to use `provide` and `inject` to pass data between components
    efficiently without props drilling. Let’s explore how we can render a specific
    content section of an element to another location in the DOM with the `<Teleport>`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Teleport API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to styling constraints, we often need to implement a component that contains
    elements that Vue should render in a different location in the actual DOM for
    full visual effect. In such cases, we usually need to “teleport” those elements
    to the desired place by developing a complex solution, resulting in lousy performance
    impact, time consumption, etc. To solve this “teleport” challenge, Vue offers
    the `<Teleport>` component.
  prefs: []
  type: TYPE_NORMAL
- en: The `<Teleport>` component accepts a prop `to`, which indicates the target container,
    whether an element’s query selector or the desired HTML element. Suppose we have
    a `House` component that will have a section of *Sky and clouds* that needs the
    Vue engine to teleport it to a designated `#sky` DOM element, as in [Example 4-26](#example_04_teleport).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-26\. House component with `Teleport`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In our `App.vue`, we add a `section` element with the target id `sky` above
    the `House` component, as in [Example 4-27](#example_04_teleport_app).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-27\. Template of `App.vue` with `House` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-7](#figure_04_06) shows the code outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot displaying two texts in the reverse order](assets/lvue_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Actual display order when using the `Teleport` component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you inspect the DOM tree using the Elements tab of the browser’s Developer
    Tools, “Sky and clouds” appears as nested within `<section id="sky">` instead
    ([Figure 4-8](#figure_04_07)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot displaying the DOM tree](assets/lvue_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. Actual DOM tree when using the Teleport component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also temporarily disable moving the content inside a `<Teleport>` component
    instance with its Boolean prop `disabled`. This component is handy when you want
    to keep the DOM tree structure, and Vue should move only the desired content to
    the target location when needed. An everyday use case for `Teleport` is a modal,
    which we will implement next.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Both Sections Under a Parent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The destination component for teleporting must exist in the DOM before mounting
    `<Teleport>`. In [Example 4-27](#example_04_teleport_app), if you wrap both instances
    of `section` under a `main` element, the `<Teleport>` component will not work
    as expected. See [“Rendering Problem Using Teleport”](#rendering-problem-using-teleport)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Modal with Teleport and the <dialog> Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A modal is a dialog window that appears on top of a screen and blocks the user’s
    interaction with the main page. The user must interact with the modal to dismiss
    it and then returns to the main page.
  prefs: []
  type: TYPE_NORMAL
- en: A modal is very handy in displaying essential notifications that require the
    user’s full attention and should appear only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s design a basic modal. Similar to a dialog, a modal should contain the
    following elements ([Figure 4-9](#figure_04_08)):'
  prefs: []
  type: TYPE_NORMAL
- en: A backdrop that covers the entire screen where the modal appears on top and
    blocks the user’s interactions with the current page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modal window that contains the modal’s content, including a `header` with
    a title and a close button, a `main` content section, and a `footer` section with
    a default close button. These three sections should be customizable using slots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Screenshot displaying the design of a basic modal.](assets/lvue_0409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9\. Design of a basic modal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Based on the preceding design, we implement a `Modal` component template using
    the `<dialog>` HTML element in [Example 4-28](#example_04_modal).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-28\. `Modal` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use three slot sections to allow the user to customize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_interactions_between_components_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The modal’s header (`m-header`)
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_interactions_between_components_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The main content (`m-main`)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_interactions_between_components_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The modal’s footer (`m-footer`)
  prefs: []
  type: TYPE_NORMAL
- en: 'We also bind the `<dialog>` element’s `open` attribute to a local data prop
    `open` for controlling the modal’s visibility (visible/hidden). In addition, we
    render the `title` prop as the modal’s default title. Now, let’s implement the
    `Modal` component’s options, which receive two props: `open` and `title` as in
    [Example 4-29](#example_04_modal_props).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-29\. Adding props to `Modal` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When a user clicks on the modal’s close button or the “X” button on the header,
    it should close itself. Since we control the visibility of the modal using the
    `open` prop, we need to emit a `closeDialog` event with the new value of `open`
    from the `Modal` component to the parent. Let’s declare `emits` and a `close`
    method that emits the target event as in [Example 4-30](#example_04_modal_emits).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-30\. Declaring the event `closeDialog` for `Modal` to emit
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_interactions_between_components_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`emits` with one event, `closeDialog`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_interactions_between_components_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`close` method that emits the `closeDialog` event with the new value of `open`
    as `false`'
  prefs: []
  type: TYPE_NORMAL
- en: Then we bind it to the relevant action elements in the `<dialog>` element using
    `@` notation, as shown in [Example 4-31](#example_04_modal_close).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-31\. Binding event listener on click events
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_interactions_between_components_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@click` event handler for the “X” button on the header'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_interactions_between_components_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@click` event handler for the default close button on the footer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to wrap the `dialog` element with a `<Teleport>` component to
    move it outside the parent component’s DOM tree. We also pass the `to` prop to
    the `<Teleport>` component to specify the target location: an HTML element with
    an id, `modal`. Finally, we bind the `disabled` prop to the component’s `open`
    value to ensure Vue moves only the modal component content to the desired location
    when visible ([Example 4-32](#example_04_modal_teleport)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-32\. Using `<Teleport>` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_interactions_between_components_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Teleport>` component'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_interactions_between_components_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`to` prop with the target location with id selector `modal`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_interactions_between_components_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`disabled` prop with the condition when component’s `open` value is falsy'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try out our `Modal` component in a `WithModalComponent` by adding
    the following code in [Example 4-33](#with_modal_component_04) to the `WithModalComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-33\. Using modal component in `WithModalComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a `<div>` element with id `modal` to the `body` element in the
    `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_interactions_between_components_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`div` element with id `modal`'
  prefs: []
  type: TYPE_NORMAL
- en: By doing so, Vue renders the `Modal` component’s content to this `div` with
    id `modal` whenever the `open` prop is set to `true` ([Figure 4-10](#figure_04_09)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Modal component rendered to the +div+ with id +modal+ when visible](assets/lvue_0410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. Modal component rendered to the `div` with id `modal` when visible
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 4-11](#figure_04_13) shows how it looks on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the +WithModalComponent+ when modal is visible](assets/lvue_0411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. Output of the `WithModalComponent` when modal is visible
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And when the `open` prop is `false`, the `div` with id `modal` is empty ([Figure 4-12](#figure_04_10)),
    and the modal is invisible on screen ([Figure 4-13](#figure_04_14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Modal component not rendered to the +div+ with id +modal+ when hidden](assets/lvue_0412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12\. Modal component not rendered to the `div` with id `modal` when
    hidden
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Modal component not visible when hidden](assets/lvue_0413.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13\. Modal component not visible when hidden
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At this point, you have a working modal component. However, the visual appearance
    of the modal isn’t exactly as good as we wanted; there should be a dark overlay
    over the main page content when the modal is visible. Let’s fix this issue using
    CSS stylings for `::backdrop` selector in the `<style>` section of the modal element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this won’t change the appearance of the modal’s backdrop. This behavior
    is because the browser applies the `::backdrop` CSS selector rules to the dialog
    only when we open the dialog using `dialog.showModal()` method, and not by changing
    the `open` attribute. To fix this issue, we need to perform the following modifications
    in our `Modal` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a direct reference to the `<dialog>` element by assigning a “dialog” value
    to the `ref` attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Trigger `$refs.dialog.showModal()` or `$refs.dialog.close()` on the `dialog`
    element whenever the `open` prop changes respectively with `watch`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the original binding for the `open` attribute of the `<dialog>` element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the use of the `disabled` attribute in the `<teleport>` component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When opening the modal using the built-in `showModal()` method, the browser
    will add a `::backdrop` pseudo-element to the actual `<dialog>` element in the
    DOM, and dynamically moving the element content to the target location will disable
    this functionality, leaving the modal without the desired backdrop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also reposition the modal to the center of the page and on top of other
    elements by adding the following CSS rules to the `dialog` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as shown in [Figure 4-14](#figure_04_11) when the modal is
    visible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modal component with backdrop and stylings](assets/lvue_0414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14\. Modal component with backdrop and stylings
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have learned how to implement a reusable `Modal` component using `Teleport`
    and explored different use cases with each of the built-in `<dialog>` element
    features. We also learned how to use the `::backdrop` CSS selector to style the
    modal’s backdrop.
  prefs: []
  type: TYPE_NORMAL
- en: As you have noticed, we set the target location `div` for the modal to be a
    direct child of `body`, outside of the Vue app entry element `<div id="app">`.
    What happens if we want to move the modal’s target `div` to within the entry component
    `App.vue` of the Vue application? Let’s find out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Problem Using Teleport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the problem with using `Teleport` to render the modal inside
    a child component of the `App.vue` component, let’s first move the `<div id="modal"></div>`
    from `index.html` to `App.vue`, after the `WithModalComponent` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After running your application, you can see that the browser doesn’t render
    the modal despite how often you click on the `Open modal` button. And the console
    shows the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error message when rendering modal inside App.vue](assets/lvue_0415.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15\. Console error message when rendering modal inside `App.vue`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Due to the Vue rendering order mechanism, the parent waits for the children
    to render before rendering itself. The children render in the order of appearance
    in the parent’s `template` section. In this scenario, the `WithModalComponent`
    renders first. Thus Vue renders the `<dialog>` element and starts moving the component’s
    content to the target location before rendering the `ParentComponent`. However,
    since the `ParentComponent` is still waiting for `WithModalComponent` to finish
    its rendering, the `<div id="modal">` element doesn’t yet exist on the DOM. As
    a result, Vue can’t locate the target location and perform the right move, and
    it can’t render the `<dialog>` element inside the `<div id="modal">` element,
    hence the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A workaround to bypass this limitation is to put the target element `<div id="modal">`
    to appear before `WithModalComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This solution ensures the target `div` is available before Vue renders the `Modal`
    element and moves the content. Another approach is to use the `disabled` attribute
    to postpone the content moving process for `Modal` during rendering until the
    user clicks on the `Open modal` button. Both options have pros and cons, and you
    should choose the one that best suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The most common solution is to insert the target element as a direct child of
    the `body` element and isolate it from the Vue rendering context.
  prefs: []
  type: TYPE_NORMAL
- en: A significant benefit of using `<Teleport>` is achieving the maximum visual
    display effect (such as fullscreen mode, modal, sidebar, etc.) while maintaining
    the code hierarchy structure, component isolation, and readability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the concept of different approaches in components’ communication
    using the built-in Vue features such as `props`, `emits`, and `provide/inject`.
    We learned how to use these features to pass data and events between components
    while keeping Vue’s data flow mechanism intact. We also learned how to use Teleport
    API to render an element outside the parent component’s DOM tree while keeping
    its appearance order in the parent component’s `<template>`. `<Teleport>` is beneficial
    for building components that require displaying with alignment to the main page
    element, such as popups, dialogs, modals, etc.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore more on Composition API and how to use
    it to compose Vue components together.
  prefs: []
  type: TYPE_NORMAL
